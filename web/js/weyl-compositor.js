import { m as defineStore, q as defineComponent, r as ref, c as computed, a as createElementBlock, d as openBlock, s as createBaseVNode, t as createCommentVNode, v as withDirectives, F as Fragment, x as renderList, y as toDisplayString, z as vModelText, A as normalizeClass, B as withModifiers, o as onMounted, n as normalizeStyle, w as watch, C as onUnmounted, g as createBlock, D as withKeys, T as Teleport, E as createTextVNode, u as unref, G as createVNode, H as createStaticVNode, I as vModelSelect, J as markRaw, h as resolveDynamicComponent, K as reactive, L as vModelCheckbox, M as vShow, N as shallowRef, k as nextTick, O as withCtx, P as createApp, Q as createPinia } from './weyl-vue-vendor.js';
import { g as ge, P as Pe } from './weyl-ui-vendor.js';
import { G as Group, M as MathUtils, a as Mesh, N as NormalBlending, A as AddEquation, S as SrcAlphaFactor, O as OneMinusSrcAlphaFactor, b as OneFactor, C as CustomBlending, c as MaxEquation, d as MinEquation, e as OneMinusDstColorFactor, f as OneMinusSrcColorFactor, g as SubtractEquation, h as SubtractiveBlending, i as AdditiveBlending, j as MultiplyBlending, V as Vector3, k as CatmullRomCurve3, B as BufferGeometry, L as LineBasicMaterial, l as Line, m as OctahedronGeometry, n as MeshBasicMaterial, o as SphereGeometry, p as Box3, P as PlaneGeometry, D as DoubleSide, q as VideoTexture, r as LinearFilter, R as RGBAFormat, s as SRGBColorSpace, t as SVGLoader, u as Color, v as Matrix4, E as ExtrudeGeometry, w as ShapeGeometry, x as BufferAttribute, y as MeshStandardMaterial, z as MeshPhysicalMaterial, F as BackSide, H as FrontSide, I as Float32BufferAttribute, T as TubeGeometry, J as TextureLoader, K as BoxGeometry, Q as IcosahedronGeometry, U as TetrahedronGeometry, W as TorusGeometry, X as CylinderGeometry, Y as ConeGeometry, Z as InstancedMesh, _ as DynamicDrawUsage, $ as Euler, a0 as Quaternion, a1 as Scene, a2 as PerspectiveCamera, a3 as AmbientLight, a4 as DirectionalLight, a5 as WebGLRenderer, a6 as NearestFilter, a7 as SpriteMaterial, a8 as RGBELoader, a9 as EXRLoader, aa as PMREMGenerator, ab as RepeatWrapping, ac as LinearMipmapLinearFilter, ad as LinearSRGBColorSpace, ae as Vector2, af as AxesHelper, ag as GridHelper, ah as EquirectangularReflectionMapping, ai as LineLoop, aj as Shape, ak as Path, al as ACESFilmicToneMapping, am as PCFSoftShadowMap, an as EffectComposer, ao as MeshNormalMaterial, ap as WebGLRenderTarget, aq as HalfFloatType, ar as DepthTexture, as as DepthFormat, at as UnsignedIntType, au as FloatType, av as ShaderMaterial, aw as RenderPass, ax as OutputPass, ay as BokehPass, az as SSAOPass, aA as UnrealBloomPass, aB as ShaderPass, aC as UnsignedByteType, aD as CircleGeometry, aE as CurvePath, aF as CubicBezierCurve3, aG as Text, aH as DataTexture, aI as RedFormat, aJ as InstancedBufferGeometry, aK as InstancedBufferAttribute, aL as RingGeometry, aM as PointLight, aN as RectAreaLight, aO as SpotLight, aP as RectAreaLightHelper, aQ as DirectionalLightHelper, aR as SpotLightHelper, aS as PointLightHelper, aT as RectAreaLightUniformsLib, aU as CanvasTexture, aV as GLTFLoader, aW as DRACOLoader, aX as MeshoptDecoder, aY as OBJLoader, aZ as FBXLoader, a_ as ColladaLoader, a$ as AnimationMixer, b0 as LoopRepeat, b1 as LoopOnce, b2 as MeshDepthMaterial, b3 as RGBADepthPacking, b4 as BoxHelper, b5 as SkeletonHelper, b6 as SkinnedMesh, b7 as PLYLoader, b8 as PCDLoader, b9 as Points, ba as Raycaster, bb as OrbitControls, bc as MOUSE, bd as OrthographicCamera, be as Texture, bf as TransformControls } from './weyl-three-vendor.js';
import { M as Muxer, A as ArrayBufferTarget, a as Muxer$1, b as ArrayBufferTarget$1 } from './weyl-export-vendor.js';

const PI = Math.PI;
const c1$1 = 1.70158;
const c2$1 = c1$1 * 1.525;
const c3$1 = c1$1 + 1;
const c4$1 = 2 * PI / 3;
const c5$1 = 2 * PI / 4.5;
const easings = {
  // Linear - no easing
  linear: (t) => t,
  // Sine easing
  easeInSine: (t) => 1 - Math.cos(t * PI / 2),
  easeOutSine: (t) => Math.sin(t * PI / 2),
  easeInOutSine: (t) => -(Math.cos(PI * t) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
    return (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // Circ (circular)
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (t) => c3$1 * t * t * t - c1$1 * t * t,
  easeOutBack: (t) => 1 + c3$1 * Math.pow(t - 1, 3) + c1$1 * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2$1 + 1) * 2 * t - c2$1) / 2 : (Math.pow(2 * t - 2, 2) * ((c2$1 + 1) * (t * 2 - 2) + c2$1) + 2) / 2,
  // Elastic
  easeInElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4$1);
  },
  easeOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4$1) + 1;
  },
  easeInOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) {
      return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5$1)) / 2;
    }
    return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5$1) / 2 + 1;
  },
  // Bounce
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInBounce: (t) => 1 - easings.easeOutBounce(1 - t),
  easeInOutBounce: (t) => t < 0.5 ? (1 - easings.easeOutBounce(1 - 2 * t)) / 2 : (1 + easings.easeOutBounce(2 * t - 1)) / 2
};
function getEasing(name) {
  if (name in easings) {
    return easings[name];
  }
  return easings.linear;
}

const LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
const config = {
  level: "warn",
  prefix: "[Weyl]"};
function shouldLog(level) {
  return LOG_LEVELS[level] >= LOG_LEVELS[config.level];
}
function formatMessage(level, context, message) {
  const parts = [];
  {
    parts.push(config.prefix);
  }
  if (context) {
    parts.push(`[${context}]`);
  }
  parts.push(message);
  return parts.join(" ");
}
function createLogger(context) {
  return {
    debug(message, ...args) {
      if (shouldLog("debug")) {
        console.log(formatMessage("DEBUG", context, message), ...args);
      }
    },
    info(message, ...args) {
      if (shouldLog("info")) {
        console.info(formatMessage("INFO", context, message), ...args);
      }
    },
    warn(message, ...args) {
      if (shouldLog("warn")) {
        console.warn(formatMessage("WARN", context, message), ...args);
      }
    },
    error(message, ...args) {
      if (shouldLog("error")) {
        console.error(formatMessage("ERROR", context, message), ...args);
      }
    },
    /**
     * Log with a specific level
     */
    log(level, message, ...args) {
      switch (level) {
        case "debug":
          this.debug(message, ...args);
          break;
        case "info":
          this.info(message, ...args);
          break;
        case "warn":
          this.warn(message, ...args);
          break;
        case "error":
          this.error(message, ...args);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(label) {
      if (shouldLog("debug")) {
        console.group(formatMessage("", context, label));
      }
    },
    groupEnd() {
      if (shouldLog("debug")) {
        console.groupEnd();
      }
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(data) {
      if (shouldLog("debug")) {
        console.log(formatMessage("", context, "Table:"));
        console.table(data);
      }
    },
    /**
     * Measure time for an operation
     */
    time(label) {
      if (shouldLog("debug")) {
        console.time(`${config.prefix} [${context}] ${label}`);
      }
    },
    timeEnd(label) {
      if (shouldLog("debug")) {
        console.timeEnd(`${config.prefix} [${context}] ${label}`);
      }
    }
  };
}
const storeLogger = createLogger("Store");
const engineLogger = createLogger("Engine");
const layerLogger = createLogger("Layer");
const renderLogger = createLogger("Render");
const exportLogger = createLogger("Export");

const easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
const easeOutSine = (t) => Math.sin(t * Math.PI / 2);
const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
const easeInQuad = (t) => t * t;
const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
const easeInCubic = (t) => t * t * t;
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
const easeInQuart = (t) => t * t * t * t;
const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
const easeInQuint = (t) => t * t * t * t * t;
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
const easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
const easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
const easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
const easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
const easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
const c1 = 1.70158;
const c2 = c1 * 1.525;
const c3 = c1 + 1;
const easeInBack = (t) => c3 * t * t * t - c1 * t * t;
const easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
const easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
const c4 = 2 * Math.PI / 3;
const c5 = 2 * Math.PI / 4.5;
const easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
const easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
const easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
const easeOutBounce = (t) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
const easeInBounce = (t) => 1 - easeOutBounce(1 - t);
const easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
const linear = (t) => t;
const stepStart = (t) => t === 0 ? 0 : 1;
const stepEnd = (t) => t === 1 ? 1 : 0;
const EASING_FUNCTIONS = {
  // Linear
  linear,
  // Sine
  easeInSine,
  easeOutSine,
  easeInOutSine,
  // Quad
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  // Cubic
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  // Quart
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  // Quint
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  // Expo
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  // Circ
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  // Back
  easeInBack,
  easeOutBack,
  easeInOutBack,
  // Elastic
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  // Bounce
  easeInBounce,
  easeOutBounce,
  easeInOutBounce,
  // Step
  stepStart,
  stepEnd
};
function inertia(ctx, amplitude = 0.1, frequency = 2, decay = 2) {
  const { time: time2, keyframes, value, velocity } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let nearestKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      nearestKey = keyframes[i];
      break;
    }
  }
  if (!nearestKey) return value;
  const keyTime = nearestKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const vel = typeof velocity === "number" ? velocity : velocity[0];
  const val = typeof value === "number" ? value : value[0];
  const oscillation = vel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  if (typeof value === "number") {
    return val + oscillation;
  }
  return value.map((v, i) => {
    const componentVel = velocity[i] || 0;
    return v + componentVel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  });
}
function bounce(ctx, elasticity = 0.7, gravity = 4e3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  let bounceTime = t;
  let bounceHeight = 1;
  let totalBounces = 0;
  const maxBounces = 10;
  while (bounceTime > 0 && totalBounces < maxBounces) {
    const bounceDuration2 = Math.sqrt(2 * bounceHeight / gravity);
    if (bounceTime < bounceDuration2 * 2) {
      break;
    }
    bounceTime -= bounceDuration2 * 2;
    bounceHeight *= elasticity * elasticity;
    totalBounces++;
  }
  const bounceDuration = Math.sqrt(2 * bounceHeight / gravity);
  const bounceT = bounceTime / (bounceDuration * 2);
  const bounceOffset = bounceHeight * 4 * bounceT * (1 - bounceT);
  if (typeof value === "number") {
    return value - bounceOffset * (1 - elasticity);
  }
  return value.map((v) => v - bounceOffset * (1 - elasticity));
}
function elastic(ctx, amplitude = 1, period = 0.3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const s = period / 4;
  const decay = Math.pow(2, -10 * t);
  const oscillation = decay * Math.sin((t - s) * (2 * Math.PI) / period);
  if (typeof value === "number") {
    return value + amplitude * oscillation;
  }
  return value.map((v) => v + amplitude * oscillation);
}
function loopOut(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const startIdx = numKeyframes > 0 ? Math.max(0, keyframes.length - numKeyframes) : 0;
  const startKey = keyframes[startIdx];
  const endKey = keyframes[keyframes.length - 1];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 <= endTime) return ctx.value;
  const elapsed = time2 - endTime;
  switch (type) {
    case "cycle": {
      const cycleTime = startTime + elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? 1 - cycleProgress : cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = startTime + elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(endKey.value, startKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value + velocity * elapsed;
      }
      return ctx.value.map((v, i) => v + velocity[i] * elapsed);
    }
  }
}
function loopIn(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const endIdx = numKeyframes > 0 ? Math.min(keyframes.length - 1, numKeyframes - 1) : keyframes.length - 1;
  const startKey = keyframes[0];
  const endKey = keyframes[endIdx];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 >= startTime) return ctx.value;
  const elapsed = startTime - time2;
  switch (type) {
    case "cycle": {
      const cycleTime = endTime - elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? cycleProgress : 1 - cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = endTime - elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(startKey.value, endKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value - velocity * elapsed;
      }
      return ctx.value.map((v, i) => v - velocity[i] * elapsed);
    }
  }
}
function wiggle(ctx, frequency = 5, amplitude = 50, octaves = 1, amplitudeMultiplier = 0.5, time2) {
  const t = time2 ?? ctx.time;
  const { value } = ctx;
  const noise = (seed, t2) => {
    let result = 0;
    let amp = 1;
    let freq = 1;
    for (let i = 0; i < octaves; i++) {
      result += amp * Math.sin(t2 * frequency * freq * Math.PI * 2 + seed * 1e3);
      result += amp * 0.5 * Math.sin(t2 * frequency * freq * Math.PI * 2 * 1.5 + seed * 500);
      amp *= amplitudeMultiplier;
      freq *= 2;
    }
    return result / (1 + (octaves - 1) * amplitudeMultiplier);
  };
  if (typeof value === "number") {
    return value + noise(0, t) * amplitude;
  }
  return value.map((v, i) => v + noise(i, t) * amplitude);
}
const timeExpressions = {
  /**
   * Linear time ramp
   */
  timeRamp(startTime, endTime, startValue, endValue, time2) {
    if (time2 <= startTime) return startValue;
    if (time2 >= endTime) return endValue;
    const t = (time2 - startTime) / (endTime - startTime);
    return startValue + (endValue - startValue) * t;
  },
  /**
   * Periodic function (loops every period seconds)
   */
  periodic(time2, period) {
    return time2 % period / period;
  },
  /**
   * Sawtooth wave
   */
  sawtooth(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * 2 * (t - Math.floor(t + 0.5));
  },
  /**
   * Triangle wave
   */
  triangle(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1);
  },
  /**
   * Square wave
   */
  square(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (t - Math.floor(t) < 0.5 ? 1 : -1);
  },
  /**
   * Sine wave
   */
  sine(time2, frequency, amplitude = 1, phase = 0) {
    return amplitude * Math.sin(2 * Math.PI * frequency * time2 + phase);
  },
  /**
   * Pulse (duty cycle controlled square)
   */
  pulse(time2, frequency, dutyCycle = 0.5, amplitude = 1) {
    const t = time2 * frequency % 1;
    return amplitude * (t < dutyCycle ? 1 : 0);
  }
};
const mathExpressions = {
  /**
   * Linear interpolation
   */
  lerp(a, b, t) {
    return a + (b - a) * t;
  },
  /**
   * Clamp value between min and max
   */
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  },
  /**
   * Map value from one range to another
   */
  map(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  },
  /**
   * Normalized value (0-1) based on range
   */
  normalize(value, min, max) {
    return (value - min) / (max - min);
  },
  /**
   * Smooth step (Hermite interpolation)
   */
  smoothstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  },
  /**
   * Smoother step (Ken Perlin's improved version)
   */
  smootherstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * t * (t * (t * 6 - 15) + 10);
  },
  /**
   * Modulo with support for negative numbers
   */
  mod(a, b) {
    return (a % b + b) % b;
  },
  /**
   * Distance between two 2D points
   */
  distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  },
  /**
   * Angle between two 2D points (in radians)
   */
  angleBetween(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  },
  /**
   * Convert degrees to radians
   */
  degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  },
  /**
   * Convert radians to degrees
   */
  radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  },
  /**
   * Random number with seed (deterministic)
   */
  seedRandom(seed, min = 0, max = 1) {
    const x = Math.sin(seed * 12.9898) * 43758.5453;
    const rand = x - Math.floor(x);
    return min + rand * (max - min);
  },
  /**
   * Gaussian random (normal distribution)
   */
  gaussRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }
};
function interpolateAtTime(keyframes, time2, fps) {
  const frame = time2 * fps;
  let before = null;
  let after = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      before = kf;
    } else if (!after) {
      after = kf;
      break;
    }
  }
  if (!before) return keyframes[0].value;
  if (!after) return before.value;
  const t = (frame - before.frame) / (after.frame - before.frame);
  const easedT = applyEasing$2(t, before.interpolation);
  return lerpValues(before.value, after.value, easedT);
}
function applyEasing$2(t, interpolation) {
  const fn = EASING_FUNCTIONS[interpolation];
  return fn ? fn(t) : t;
}
function lerpValues(a, b, t) {
  if (typeof a === "number" && typeof b === "number") {
    return a + (b - a) * t;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + (b[i] - v) * t);
  }
  return a;
}
function subtractValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v - b[i]);
  }
  return 0;
}
function addValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + b[i]);
  }
  return a;
}
function scaleValue(v, s) {
  if (typeof v === "number") {
    return v * s;
  }
  if (Array.isArray(v)) {
    return v.map((x) => x * s);
  }
  return 0;
}
function evaluateExpression(expression, ctx) {
  if (!expression.enabled) return ctx.value;
  switch (expression.type) {
    case "preset":
      return evaluatePreset(expression.name, ctx, expression.params);
    case "function":
      return evaluateFunction(expression.name, ctx, expression.params);
    default:
      return ctx.value;
  }
}
function evaluatePreset(name, ctx, params) {
  switch (name) {
    case "inertia":
      return inertia(ctx, params.amplitude, params.frequency, params.decay);
    case "bounce":
      return bounce(ctx, params.elasticity, params.gravity);
    case "elastic":
      return elastic(ctx, params.amplitude, params.period);
    case "wiggle":
      return wiggle(ctx, params.frequency, params.amplitude, params.octaves);
    case "loopOut":
      return loopOut(ctx, params.type, params.numKeyframes);
    case "loopIn":
      return loopIn(ctx, params.type, params.numKeyframes);
    default:
      return ctx.value;
  }
}
function evaluateFunction(name, ctx, params) {
  if (name in timeExpressions) {
    const fn = timeExpressions[name];
    return fn(ctx.time, ...Object.values(params));
  }
  if (name in mathExpressions) {
    const fn = mathExpressions[name];
    const val = typeof ctx.value === "number" ? ctx.value : ctx.value[0];
    return fn(val, ...Object.values(params));
  }
  return ctx.value;
}

class BezierCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 500;
  /**
   * Generate cache key from bezier parameters
   * Uses fixed precision to avoid floating point key variations
   */
  makeKey(outHandle, inHandle, frameDuration, valueDelta) {
    const round = (n) => Math.round(n * 1e4);
    return `${round(outHandle.frame)},${round(outHandle.value)},${round(inHandle.frame)},${round(inHandle.value)},${round(frameDuration)},${round(valueDelta)}`;
  }
  /**
   * Get cached normalized bezier or compute and cache it
   */
  get(outHandle, inHandle, frameDuration, valueDelta) {
    const key = this.makeKey(outHandle, inHandle, frameDuration, valueDelta);
    const cached = this.cache.get(key);
    if (cached) {
      this.cache.delete(key);
      this.cache.set(key, cached);
      return cached;
    }
    const x1 = frameDuration > 0 ? Math.abs(outHandle.frame) / frameDuration : 0.33;
    const y1 = valueDelta !== 0 ? outHandle.value / valueDelta : 0.33;
    const x2 = frameDuration > 0 ? 1 - Math.abs(inHandle.frame) / frameDuration : 0.67;
    const y2 = valueDelta !== 0 ? 1 - inHandle.value / valueDelta : 0.67;
    const normalized = { x1, y1, x2, y2 };
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, normalized);
    return normalized;
  }
  /**
   * Clear the cache (call on project load)
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const bezierCache = new BezierCache();
function findKeyframeIndex(keyframes, frame) {
  let low = 0;
  let high = keyframes.length - 2;
  while (low <= high) {
    const mid = low + high >>> 1;
    const midFrame = keyframes[mid].frame;
    const nextFrame = keyframes[mid + 1].frame;
    if (frame >= midFrame && frame <= nextFrame) {
      return mid;
    } else if (frame < midFrame) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return Math.max(0, Math.min(low, keyframes.length - 2));
}
function getValueDelta(v1, v2) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v2 - v1;
  }
  if (typeof v1 === "object" && v1 !== null && "x" in v1 && "y" in v1 && typeof v2 === "object" && v2 !== null && "x" in v2 && "y" in v2) {
    const dx = v2.x - v1.x;
    const dy = v2.y - v1.y;
    return Math.sqrt(dx * dx + dy * dy) || 1;
  }
  return 1;
}
function interpolateProperty(property, frame, fps = 30, layerId = "") {
  let value;
  if (!property.animated || property.keyframes.length === 0) {
    value = property.value;
  } else {
    const keyframes = property.keyframes;
    if (frame <= keyframes[0].frame) {
      value = keyframes[0].value;
    } else if (frame >= keyframes[keyframes.length - 1].frame) {
      value = keyframes[keyframes.length - 1].value;
    } else {
      const idx = findKeyframeIndex(keyframes, frame);
      const k1 = keyframes[idx];
      const k2 = keyframes[idx + 1];
      const duration = k2.frame - k1.frame;
      const elapsed = frame - k1.frame;
      let t = duration > 0 ? elapsed / duration : 0;
      const interpolation = k1.interpolation || "linear";
      if (interpolation === "hold") {
        value = k1.value;
      } else {
        if (interpolation === "bezier") {
          const valueDelta = getValueDelta(k1.value, k2.value);
          t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
        } else if (interpolation !== "linear" && interpolation in easings) {
          const easingFn = getEasing(interpolation);
          t = easingFn(t);
        } else if (interpolation !== "linear") {
          renderLogger.warn(`Unknown interpolation type: ${interpolation}, using linear`);
        }
        value = interpolateValue$1(k1.value, k2.value, t);
      }
    }
  }
  if (property.expression?.enabled) {
    value = applyPropertyExpression(property, value, frame, fps);
  }
  return value;
}
function applyPropertyExpression(property, value, frame, fps, layerId) {
  const expr = property.expression;
  if (!expr || !expr.enabled) return value;
  const time = frame / fps;
  const velocity = calculateVelocity(property, frame, fps);
  const ctx = {
    time,
    fps,
    value,
    velocity,
    keyframes: property.keyframes
  };
  const expression = {
    type: expr.type,
    name: expr.name,
    params: expr.params,
    enabled: expr.enabled
  };
  const result = evaluateExpression(expression, ctx);
  return result;
}
function calculateVelocity(property, frame, fps) {
  const delta = 0.5;
  const valueBefore = interpolatePropertyBase(property, frame - delta);
  const valueAfter = interpolatePropertyBase(property, frame + delta);
  if (typeof valueBefore === "number" && typeof valueAfter === "number") {
    return (valueAfter - valueBefore) * fps;
  }
  if (typeof valueBefore === "object" && typeof valueAfter === "object") {
    const vb = valueBefore;
    const va = valueAfter;
    if ("x" in vb && "y" in vb) {
      const result = [(va.x - vb.x) * fps, (va.y - vb.y) * fps];
      if ("z" in vb && "z" in va) {
        result.push((va.z - vb.z) * fps);
      }
      return result;
    }
  }
  return 0;
}
function interpolatePropertyBase(property, frame) {
  if (!property.animated || property.keyframes.length === 0) {
    return property.value;
  }
  const keyframes = property.keyframes;
  if (frame <= keyframes[0].frame) {
    return keyframes[0].value;
  }
  if (frame >= keyframes[keyframes.length - 1].frame) {
    return keyframes[keyframes.length - 1].value;
  }
  const idx = findKeyframeIndex(keyframes, frame);
  const k1 = keyframes[idx];
  const k2 = keyframes[idx + 1];
  const duration = k2.frame - k1.frame;
  const elapsed = frame - k1.frame;
  let t = duration > 0 ? elapsed / duration : 0;
  const interpolation = k1.interpolation || "linear";
  if (interpolation === "hold") {
    return k1.value;
  } else if (interpolation === "bezier") {
    const valueDelta = getValueDelta(k1.value, k2.value);
    t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
  } else if (interpolation !== "linear" && interpolation in easings) {
    const easingFn = getEasing(interpolation);
    t = easingFn(t);
  }
  return interpolateValue$1(k1.value, k2.value, t);
}
function cubicBezierEasing(t, outHandle, inHandle, frameDuration = 1, valueDelta = 1) {
  if (!outHandle.enabled && !inHandle.enabled) {
    return t;
  }
  const { x1, y1, x2, y2 } = bezierCache.get(outHandle, inHandle, frameDuration, valueDelta);
  let guessT = t;
  const EPSILON = 1e-6;
  const MAX_ITERATIONS = 8;
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const currentX = bezierPoint(guessT, 0, x1, x2, 1);
    const error = currentX - t;
    if (Math.abs(error) < EPSILON) break;
    const currentSlope = bezierDerivative(guessT, 0, x1, x2, 1);
    if (Math.abs(currentSlope) < EPSILON) break;
    guessT -= error / currentSlope;
    guessT = Math.max(0, Math.min(1, guessT));
  }
  return bezierPoint(guessT, 0, y1, y2, 1);
}
function bezierPoint(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
}
function bezierDerivative(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
}
function interpolateValue$1(v1, v2, t) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v1 + (v2 - v1) * t;
  }
  if (typeof v1 === "object" && v1 !== null && typeof v2 === "object" && v2 !== null && "x" in v1 && "y" in v1 && "x" in v2 && "y" in v2) {
    const val1 = v1;
    const val2 = v2;
    const result = {
      x: val1.x + (val2.x - val1.x) * t,
      y: val1.y + (val2.y - val1.y) * t
    };
    if ("z" in val1 && "z" in val2) {
      result.z = val1.z + (val2.z - val1.z) * t;
    } else if ("z" in val1) {
      result.z = val1.z * (1 - t);
    } else if ("z" in val2) {
      result.z = val2.z * t;
    }
    return result;
  }
  if (typeof v1 === "string" && typeof v2 === "string" && v1.startsWith("#") && v2.startsWith("#")) {
    return interpolateColor(v1, v2, t);
  }
  return t < 0.5 ? v1 : v2;
}
function interpolateColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);
  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
const EASING_PRESETS_NORMALIZED = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
const EASING_PRESETS = EASING_PRESETS_NORMALIZED;
function getBezierCurvePointNormalized(t, outHandle, inHandle) {
  const x1 = outHandle.x;
  const y1 = outHandle.y;
  const x2 = 1 - inHandle.x;
  const y2 = 1 - inHandle.y;
  return {
    x: bezierPoint(t, 0, x1, x2, 1),
    y: bezierPoint(t, 0, y1, y2, 1)
  };
}
function applyEasing$1(ratio, preset) {
  const t = Math.max(0, Math.min(1, ratio));
  const point = getBezierCurvePointNormalized(t, preset.outHandle, preset.inHandle);
  return point.y;
}

function getFeatureAtFrame(analysis, feature, frame) {
  const clampedFrame = Math.max(0, Math.min(frame, analysis.frameCount - 1));
  switch (feature) {
    case "amplitude":
      return analysis.amplitudeEnvelope[clampedFrame] ?? 0;
    case "rms":
      return analysis.rmsEnergy[clampedFrame] ?? 0;
    case "spectralCentroid":
      return analysis.spectralCentroid[clampedFrame] ?? 0;
    case "sub":
      return analysis.frequencyBands.sub[clampedFrame] ?? 0;
    case "bass":
      return analysis.frequencyBands.bass[clampedFrame] ?? 0;
    case "lowMid":
      return analysis.frequencyBands.lowMid[clampedFrame] ?? 0;
    case "mid":
      return analysis.frequencyBands.mid[clampedFrame] ?? 0;
    case "highMid":
      return analysis.frequencyBands.highMid[clampedFrame] ?? 0;
    case "high":
      return analysis.frequencyBands.high[clampedFrame] ?? 0;
    case "onsets":
      return analysis.onsets.includes(clampedFrame) ? 1 : 0;
    case "spectralFlux":
      return analysis.spectralFlux?.[clampedFrame] ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return analysis.zeroCrossingRate?.[clampedFrame] ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return analysis.spectralRolloff?.[clampedFrame] ?? 0;
    case "spectralFlatness":
    case "flatness":
      return analysis.spectralFlatness?.[clampedFrame] ?? 0;
    case "chromaEnergy":
      return analysis.chromaFeatures?.chromaEnergy[clampedFrame] ?? 0;
    case "chromaC":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[0] ?? 0;
    case "chromaCs":
    case "chromaDb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[1] ?? 0;
    case "chromaD":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[2] ?? 0;
    case "chromaDs":
    case "chromaEb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[3] ?? 0;
    case "chromaE":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[4] ?? 0;
    case "chromaF":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[5] ?? 0;
    case "chromaFs":
    case "chromaGb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[6] ?? 0;
    case "chromaG":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[7] ?? 0;
    case "chromaGs":
    case "chromaAb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[8] ?? 0;
    case "chromaA":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[9] ?? 0;
    case "chromaAs":
    case "chromaBb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[10] ?? 0;
    case "chromaB":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[11] ?? 0;
    default:
      return 0;
  }
}
function detectPeaks(weights, config) {
  const { threshold, minPeaksDistance, multiply } = config;
  const amplified = weights.map((w) => Math.min(1, w * multiply));
  const rawPeaks = [];
  for (let i = 1; i < amplified.length - 1; i++) {
    const prev = amplified[i - 1];
    const curr = amplified[i];
    const next = amplified[i + 1];
    if (curr > prev && curr > next && curr >= threshold) {
      rawPeaks.push({ index: i, value: curr });
    }
  }
  const filteredPeaks = [];
  for (const peak of rawPeaks) {
    const recentPeakIndex = filteredPeaks.findIndex(
      (p) => Math.abs(p.index - peak.index) < minPeaksDistance
    );
    if (recentPeakIndex === -1) {
      filteredPeaks.push(peak);
    } else {
      if (peak.value > filteredPeaks[recentPeakIndex].value) {
        filteredPeaks[recentPeakIndex] = peak;
      }
    }
  }
  filteredPeaks.sort((a, b) => a.index - b.index);
  const alternating = new Array(weights.length).fill(0);
  let currentState = 0;
  for (let i = 0; i < weights.length; i++) {
    const isPeak = filteredPeaks.some((p) => p.index === i);
    if (isPeak) {
      currentState = 1 - currentState;
    }
    alternating[i] = currentState;
  }
  return {
    indices: filteredPeaks.map((p) => p.index),
    values: filteredPeaks.map((p) => p.value),
    count: filteredPeaks.length,
    alternating
  };
}
function isBeatAtFrame(analysis, frame) {
  return analysis.onsets.includes(frame);
}
function isPeakAtFrame(peaks, frame) {
  return peaks.indices.includes(frame);
}

/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2024 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
// these __PURE__ comments help uglifyjs with dead code removal
//
const SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);
const F2 = 0.5 * (SQRT3 - 1.0);
const G2 = (3.0 - SQRT3) / 6.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x) => Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
    -1, 1,
    1, -1,
    -1, -1,
    1, 0,
    -1, 0,
    1, 0,
    -1, 0,
    0, 1,
    0, -1,
    0, 1,
    0, -1]);
/**
 * Creates a 2D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction2D}
 */
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
/**
 * Builds a random permutation table.
 * This is exported only for (internal) testing purposes.
 * Do not rely on this export.
 * @private
 */
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for (let i = 0; i < tableSize / 2; i++) {
        p[i] = i;
    }
    for (let i = 0; i < tableSize / 2 - 1; i++) {
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for (let i = 256; i < tableSize; i++) {
        p[i] = p[i - 256];
    }
    return p;
}

class SeededRandom {
  state;
  initialSeed;
  constructor(seed = 12345) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Reset to initial seed */
  reset() {
    this.state = this.initialSeed;
  }
  /** Reset to a new seed */
  setSeed(seed) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
  /** Get initial seed */
  getSeed() {
    return this.initialSeed;
  }
  /**
   * Get next random number in [0, 1)
   * Uses mulberry32 algorithm
   */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get random integer in range [min, max] inclusive */
  int(min, max) {
    return Math.floor(this.range(min, max + 1));
  }
  /** Get random value with variance: base + random(-variance, +variance) */
  variance(base, variance) {
    return base + (this.next() - 0.5) * 2 * variance;
  }
  /** Get random boolean with given probability of true */
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  /** Get random angle in radians [0, 2Ï€) */
  angle() {
    return this.next() * Math.PI * 2;
  }
  /** Get random point in unit circle */
  inCircle() {
    const angle = this.angle();
    const r = Math.sqrt(this.next());
    return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
  }
  /** Get random point on unit sphere */
  onSphere() {
    const theta = this.angle();
    const phi = Math.acos(2 * this.next() - 1);
    return {
      x: Math.sin(phi) * Math.cos(theta),
      y: Math.sin(phi) * Math.sin(theta),
      z: Math.cos(phi)
    };
  }
}
function createDefaultCollisionConfig() {
  return {
    enabled: false,
    particleCollision: false,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: false,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: false,
    floorY: 1,
    ceilingEnabled: false,
    ceilingY: 0,
    wallsEnabled: false,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function createDefaultConnectionConfig() {
  return {
    enabled: false,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: true
  };
}
function createDefaultSystemConfig() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: false,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: createDefaultCollisionConfig()
  };
}
function createDefaultRenderOptions() {
  return {
    blendMode: "additive",
    renderTrails: false,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: false,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: false,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: createDefaultConnectionConfig(),
    spriteSmoothing: true,
    spriteOpacityByAge: true,
    emissiveEnabled: false,
    emissiveIntensity: 2,
    emissiveColor: null
  };
}
class ParticleSystem {
  particles = [];
  emitters = /* @__PURE__ */ new Map();
  gravityWells = /* @__PURE__ */ new Map();
  vortices = /* @__PURE__ */ new Map();
  modulations = [];
  config;
  boundaryMask = null;
  frameCount = 0;
  emissionAccumulators = /* @__PURE__ */ new Map();
  nextParticleId = 0;
  trailHistory = /* @__PURE__ */ new Map();
  // ============================================================================
  // PARTICLE POOL - Recycles dead particles to reduce GC pressure
  // Memory management: Pool limited to maxParticles to prevent unbounded growth
  // ============================================================================
  particlePool = [];
  poolMaxSize = 1e4;
  // Cap pool size
  // Audio reactivity state
  featureOverrides = /* @__PURE__ */ new Map();
  // Turbulence noise generator (seeded for determinism)
  noise2D;
  noiseTime = 0;
  // Render options cache for spatial grid
  renderOptions = createDefaultRenderOptions();
  // Sprite image cache - maps emitter ID to loaded image
  spriteCache = /* @__PURE__ */ new Map();
  // Collision spatial hash grid
  collisionGrid = /* @__PURE__ */ new Map();
  collisionGridCellSize = 50;
  // SEEDED RNG - For deterministic simulation
  // Same seed + same config + same frame = identical particle state
  rng;
  // Spline path provider for emitters with shape='spline'
  // Set by the engine integration (e.g., WeylEngine) to resolve spline paths
  splineProvider = null;
  // Current frame for spline queries
  currentFrame = 0;
  // Sequential emit state per emitter (for 'sequential' emit mode)
  sequentialEmitT = /* @__PURE__ */ new Map();
  constructor(config = {}, seed = 12345) {
    this.config = { ...createDefaultSystemConfig(), ...config };
    this.rng = new SeededRandom(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
    if (this.config.collision) {
      this.collisionGridCellSize = this.config.collision.spatialHashCellSize;
    }
  }
  /**
   * Get the RNG instance (for external access/checkpointing)
   */
  getRng() {
    return this.rng;
  }
  /**
   * Set new seed and reset RNG
   */
  setSeed(seed) {
    this.rng.setSeed(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
  }
  /**
   * Set the spline path provider callback
   * This allows emitters with shape='spline' to query spline positions
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get the current spline provider
   */
  getSplineProvider() {
    return this.splineProvider;
  }
  /**
   * Set the current frame for spline queries
   * Called by the engine before stepping the simulation
   */
  setCurrentFrame(frame) {
    this.currentFrame = frame;
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(emitterId, imageUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.spriteCache.set(emitterId, img);
        const emitter = this.emitters.get(emitterId);
        if (emitter && emitter.sprite) {
          emitter.sprite.imageData = img;
        }
        resolve();
      };
      img.onerror = reject;
      img.src = imageUrl;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(emitterId, image) {
    this.spriteCache.set(emitterId, image);
    const emitter = this.emitters.get(emitterId);
    if (emitter && emitter.sprite) {
      emitter.sprite.imageData = image;
    }
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(emitterId) {
    return this.spriteCache.get(emitterId) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, { ...config });
    this.emissionAccumulators.set(config.id, 0);
    if (config.initialBurst > 0 && config.enabled) {
      const burstCount = Math.floor(config.emissionRate * config.initialBurst * 10);
      for (let i = 0; i < burstCount; i++) {
        this.spawnParticle(config);
      }
    }
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.emissionAccumulators.delete(id);
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(config) {
    this.gravityWells.set(config.id, { ...config });
  }
  updateGravityWell(id, updates) {
    const well = this.gravityWells.get(id);
    if (well) {
      Object.assign(well, updates);
    }
  }
  removeGravityWell(id) {
    this.gravityWells.delete(id);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(config) {
    this.vortices.set(config.id, { ...config });
  }
  updateVortex(id, updates) {
    const vortex = this.vortices.get(id);
    if (vortex) {
      Object.assign(vortex, updates);
    }
  }
  removeVortex(id) {
    this.vortices.delete(id);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(mod) {
    this.modulations.push({ ...mod });
  }
  removeModulation(id) {
    const index = this.modulations.findIndex((m) => m.id === id);
    if (index >= 0) {
      this.modulations.splice(index, 1);
    }
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(mask) {
    this.boundaryMask = mask;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(param, value, emitterId) {
    const key = emitterId ? `${emitterId}:${param}` : `*:${param}`;
    this.featureOverrides.set(key, value);
  }
  getFeatureValue(param, emitterId) {
    return this.featureOverrides.get(`${emitterId}:${param}`) ?? this.featureOverrides.get(`*:${param}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(deltaTime = 1) {
    this.emitters.forEach((emitter, id) => {
      if (!emitter.enabled) return;
      const baseRate = this.getFeatureValue("emissionRate", id) ?? emitter.emissionRate;
      const particlesToEmit = baseRate * deltaTime;
      let accumulated = (this.emissionAccumulators.get(id) || 0) + particlesToEmit;
      while (accumulated >= 1 && this.particles.length < this.config.maxParticles) {
        this.spawnParticle(emitter);
        accumulated -= 1;
      }
      this.emissionAccumulators.set(id, accumulated);
    });
    const windRadians = this.config.windDirection * Math.PI / 180;
    const windX = Math.cos(windRadians) * this.config.windStrength * 1e-3;
    const windY = Math.sin(windRadians) * this.config.windStrength * 1e-3;
    const gravity = this.getFeatureValue("gravity", "*") ?? this.config.gravity;
    const windStrength = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength;
    const actualWindX = windX * (windStrength / Math.max(1, this.config.windStrength));
    const actualWindY = windY * (windStrength / Math.max(1, this.config.windStrength));
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.prevX = p.x;
      p.prevY = p.y;
      if (this.trailHistory.has(p.id)) {
        const trail = this.trailHistory.get(p.id);
        trail.unshift({ x: p.x, y: p.y });
        if (trail.length > 20) trail.pop();
      }
      p.vy += gravity * 1e-3 * deltaTime;
      p.vx += actualWindX * deltaTime;
      p.vy += actualWindY * deltaTime;
      this.gravityWells.forEach((well) => {
        if (!well.enabled) return;
        const dx = well.x - p.x;
        const dy = well.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < well.radius && dist > 1e-3) {
          let force = well.strength * 1e-4;
          switch (well.falloff) {
            case "linear":
              force *= 1 - dist / well.radius;
              break;
            case "quadratic":
              force *= Math.pow(1 - dist / well.radius, 2);
              break;
          }
          const nx = dx / dist;
          const ny = dy / dist;
          p.vx += nx * force * deltaTime;
          p.vy += ny * force * deltaTime;
        }
      });
      this.vortices.forEach((vortex) => {
        if (!vortex.enabled) return;
        const dx = vortex.x - p.x;
        const dy = vortex.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < vortex.radius && dist > 1e-3) {
          const influence = 1 - dist / vortex.radius;
          const strength = vortex.strength * 1e-4 * influence;
          const nx = dx / dist;
          const ny = dy / dist;
          const perpX = -ny;
          const perpY = nx;
          p.vx += perpX * strength * deltaTime;
          p.vy += perpY * strength * deltaTime;
          const inward = vortex.inwardPull * 1e-4 * influence;
          p.vx += nx * inward * deltaTime;
          p.vy += ny * inward * deltaTime;
        }
      });
      this.applyTurbulence(p, deltaTime);
      const frictionFactor = 1 - this.config.friction;
      p.vx *= frictionFactor;
      p.vy *= frictionFactor;
      if (p.angularVelocity !== 0) {
        p.rotation += p.angularVelocity * deltaTime;
      }
      const emitter = this.emitters.get(p.emitterId);
      if (emitter?.sprite?.alignToVelocity && (p.vx !== 0 || p.vy !== 0)) {
        p.rotation = Math.atan2(p.vy, p.vx);
      }
      if (emitter?.sprite?.isSheet && emitter.sprite.totalFrames > 1) {
        this.updateSpriteFrame(p, emitter.sprite, deltaTime);
      }
      p.x += p.vx * deltaTime;
      p.y += p.vy * deltaTime;
      if (this.boundaryMask && this.config.respectMaskBoundary) {
        this.handleBoundaryCollision(p);
      }
      this.handleCanvasBoundary(p);
      this.applyModulations(p);
      p.age += deltaTime;
      if (p.age > p.lifetime) {
        if (!p.isSubParticle) {
          this.triggerSubEmitters(p);
        }
        if (this.particlePool.length < this.poolMaxSize) {
          this.particlePool.push(p);
        }
        this.particles.splice(i, 1);
        this.trailHistory.delete(p.id);
      }
    }
    if (this.config.collision?.enabled && this.config.collision.particleCollision) {
      this.handleParticleCollisions();
    }
    if (this.config.collision?.enabled) {
      this.handleEnvironmentCollisions();
    }
    this.noiseTime += deltaTime;
    this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(p, sprite, _deltaTime) {
    const totalFrames = sprite.totalFrames;
    switch (sprite.playMode) {
      case "loop": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = framesElapsed % totalFrames;
        break;
      }
      case "once": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = Math.min(framesElapsed, totalFrames - 1);
        break;
      }
      case "pingpong": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        const cycle = Math.floor(framesElapsed / (totalFrames - 1));
        const frameInCycle = framesElapsed % (totalFrames - 1);
        p.spriteIndex = cycle % 2 === 0 ? frameInCycle : totalFrames - 1 - frameInCycle;
        break;
      }
      case "random": {
        if (this.rng.bool(0.1)) {
          p.spriteIndex = this.rng.int(0, totalFrames - 1);
        }
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const collision = this.config.collision;
    if (!collision || !collision.particleCollision) return;
    this.collisionGrid.clear();
    const cellSize = this.collisionGridCellSize / 1e3;
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      const key = `${cellX},${cellY}`;
      if (!this.collisionGrid.has(key)) {
        this.collisionGrid.set(key, []);
      }
      this.collisionGrid.get(key).push(p);
    }
    const checked = /* @__PURE__ */ new Set();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          const cell = this.collisionGrid.get(key);
          if (!cell) continue;
          for (const other of cell) {
            if (other.id <= p.id) continue;
            const pairKey = `${Math.min(p.id, other.id)}-${Math.max(p.id, other.id)}`;
            if (checked.has(pairKey)) continue;
            checked.add(pairKey);
            const radiusP = p.size / 1e3 * collision.particleCollisionRadius;
            const radiusO = other.size / 1e3 * collision.particleCollisionRadius;
            const minDist = radiusP + radiusO;
            const dx2 = other.x - p.x;
            const dy2 = other.y - p.y;
            const distSq = dx2 * dx2 + dy2 * dy2;
            if (distSq < minDist * minDist && distSq > 1e-6) {
              const dist = Math.sqrt(distSq);
              const nx = dx2 / dist;
              const ny = dy2 / dist;
              switch (collision.particleCollisionResponse) {
                case "bounce": {
                  const dvx = p.vx - other.vx;
                  const dvy = p.vy - other.vy;
                  const dvDotN = dvx * nx + dvy * ny;
                  if (dvDotN > 0) {
                    const damping = collision.particleCollisionDamping;
                    p.vx -= dvDotN * nx * damping;
                    p.vy -= dvDotN * ny * damping;
                    other.vx += dvDotN * nx * damping;
                    other.vy += dvDotN * ny * damping;
                    const overlap = minDist - dist;
                    p.x -= nx * overlap * 0.5;
                    p.y -= ny * overlap * 0.5;
                    other.x += nx * overlap * 0.5;
                    other.y += ny * overlap * 0.5;
                  }
                  break;
                }
                case "absorb": {
                  if (p.size > other.size) {
                    p.size += other.size * 0.1;
                    other.age = other.lifetime + 1;
                  } else {
                    other.size += p.size * 0.1;
                    p.age = p.lifetime + 1;
                  }
                  break;
                }
                case "explode": {
                  p.age = p.lifetime + 1;
                  other.age = other.lifetime + 1;
                  break;
                }
              }
              p.collisionCount++;
              other.collisionCount++;
            }
          }
        }
      }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const collision = this.config.collision;
    if (!collision?.enabled) return;
    const bounciness = collision.bounciness;
    const friction = collision.friction;
    for (const p of this.particles) {
      if (collision.floorEnabled && p.y > collision.floorY) {
        p.y = collision.floorY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.ceilingEnabled && p.y < collision.ceilingY) {
        p.y = collision.ceilingY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.wallsEnabled) {
        if (p.x < 0) {
          p.x = 0;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
      }
    }
  }
  spawnParticle(emitter) {
    if (this.particles.length >= this.config.maxParticles) return;
    const spawnPos = this.getEmitterSpawnPosition(emitter);
    const baseDirection = spawnPos.direction !== void 0 ? spawnPos.direction : emitter.direction;
    const spreadRad = emitter.spread * Math.PI / 180;
    const baseRad = baseDirection * Math.PI / 180;
    const angle = baseRad + (this.rng.next() - 0.5) * spreadRad;
    const speed = this.rng.variance(emitter.speed, emitter.speedVariance);
    const speedNormalized = speed * 1e-3;
    const size = Math.max(1, this.rng.variance(emitter.size, emitter.sizeVariance));
    const lifetime = Math.max(1, this.rng.variance(emitter.particleLifetime, emitter.lifetimeVariance));
    let rotation = 0;
    let angularVelocity = 0;
    const sprite = emitter.sprite;
    if (sprite && sprite.rotationEnabled) {
      rotation = this.rng.angle();
      const rotSpeed = sprite.rotationSpeed * (Math.PI / 180);
      const rotVariance = sprite.rotationSpeedVariance * (Math.PI / 180);
      angularVelocity = this.rng.variance(rotSpeed, rotVariance);
    }
    if (sprite && sprite.alignToVelocity) {
      rotation = angle;
    }
    let spriteIndex = 0;
    if (sprite && sprite.isSheet && sprite.playMode === "random") {
      spriteIndex = this.rng.int(0, sprite.totalFrames - 1);
    }
    let particle;
    if (this.particlePool.length > 0) {
      particle = this.particlePool.pop();
      particle.id = this.nextParticleId++;
      particle.x = spawnPos.x;
      particle.y = spawnPos.y;
      particle.prevX = spawnPos.x;
      particle.prevY = spawnPos.y;
      particle.vx = Math.cos(angle) * speedNormalized;
      particle.vy = Math.sin(angle) * speedNormalized;
      particle.age = 0;
      particle.lifetime = lifetime;
      particle.size = size;
      particle.baseSize = size;
      particle.color[0] = emitter.color[0];
      particle.color[1] = emitter.color[1];
      particle.color[2] = emitter.color[2];
      particle.color[3] = 255;
      particle.baseColor[0] = emitter.color[0];
      particle.baseColor[1] = emitter.color[1];
      particle.baseColor[2] = emitter.color[2];
      particle.baseColor[3] = 255;
      particle.emitterId = emitter.id;
      particle.isSubParticle = false;
      particle.rotation = rotation;
      particle.angularVelocity = angularVelocity;
      particle.spriteIndex = spriteIndex;
      particle.collisionCount = 0;
    } else {
      particle = {
        id: this.nextParticleId++,
        x: spawnPos.x,
        y: spawnPos.y,
        prevX: spawnPos.x,
        prevY: spawnPos.y,
        vx: Math.cos(angle) * speedNormalized,
        vy: Math.sin(angle) * speedNormalized,
        age: 0,
        lifetime,
        size,
        baseSize: size,
        color: [...emitter.color, 255],
        baseColor: [...emitter.color, 255],
        emitterId: emitter.id,
        isSubParticle: false,
        rotation,
        angularVelocity,
        spriteIndex,
        collisionCount: 0
      };
    }
    this.particles.push(particle);
    this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   * Returns position and optionally a direction override for spline emission
   */
  getEmitterSpawnPosition(emitter) {
    const shape = emitter.shape || "point";
    switch (shape) {
      case "point":
        return { x: emitter.x, y: emitter.y };
      case "line": {
        const t = this.rng.next();
        const halfWidth = emitter.shapeWidth / 2;
        const dirRad = emitter.direction * Math.PI / 180;
        const perpX = -Math.sin(dirRad);
        const perpY = Math.cos(dirRad);
        return {
          x: emitter.x + perpX * (t - 0.5) * halfWidth * 2,
          y: emitter.y + perpY * (t - 0.5) * halfWidth * 2
        };
      }
      case "circle": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const angle = this.rng.angle();
          return {
            x: emitter.x + Math.cos(angle) * radius,
            y: emitter.y + Math.sin(angle) * radius
          };
        } else {
          const angle = this.rng.angle();
          const r = radius * Math.sqrt(this.rng.next());
          return {
            x: emitter.x + Math.cos(angle) * r,
            y: emitter.y + Math.sin(angle) * r
          };
        }
      }
      case "ring": {
        const innerR = emitter.shapeInnerRadius;
        const outerR = emitter.shapeRadius;
        const angle = this.rng.angle();
        const r = Math.sqrt(this.rng.next() * (outerR * outerR - innerR * innerR) + innerR * innerR);
        return {
          x: emitter.x + Math.cos(angle) * r,
          y: emitter.y + Math.sin(angle) * r
        };
      }
      case "box": {
        const halfW = emitter.shapeWidth / 2;
        const halfH = emitter.shapeHeight / 2;
        if (emitter.emitFromEdge) {
          const perimeter = 2 * (emitter.shapeWidth + emitter.shapeHeight);
          const t = this.rng.next() * perimeter;
          if (t < emitter.shapeWidth) {
            return { x: emitter.x - halfW + t, y: emitter.y - halfH };
          } else if (t < emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW, y: emitter.y - halfH + (t - emitter.shapeWidth) };
          } else if (t < 2 * emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW - (t - emitter.shapeWidth - emitter.shapeHeight), y: emitter.y + halfH };
          } else {
            return { x: emitter.x - halfW, y: emitter.y + halfH - (t - 2 * emitter.shapeWidth - emitter.shapeHeight) };
          }
        } else {
          return {
            x: emitter.x + (this.rng.next() - 0.5) * emitter.shapeWidth,
            y: emitter.y + (this.rng.next() - 0.5) * emitter.shapeHeight
          };
        }
      }
      case "sphere": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const theta = this.rng.angle();
          const phi = Math.acos(2 * this.rng.next() - 1);
          return {
            x: emitter.x + Math.sin(phi) * Math.cos(theta) * radius,
            y: emitter.y + Math.sin(phi) * Math.sin(theta) * radius
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let x, y, z;
          do {
            x = (this.rng.next() - 0.5) * 2;
            y = (this.rng.next() - 0.5) * 2;
            z = (this.rng.next() - 0.5) * 2;
          } while (x * x + y * y + z * z > 1);
          return {
            x: emitter.x + x * radius,
            y: emitter.y + y * radius
          };
        }
      }
      case "spline": {
        return this.getSplineEmitPosition(emitter);
      }
      default:
        return { x: emitter.x, y: emitter.y };
    }
  }
  /**
   * Get emission position along a spline path
   * Returns position and optionally modifies emission direction
   * DETERMINISM: Uses seeded RNG (this.rng) for random positions
   */
  getSplineEmitPosition(emitter) {
    const splinePath = emitter.splinePath;
    if (!splinePath || !this.splineProvider) {
      return { x: emitter.x, y: emitter.y };
    }
    let t;
    switch (splinePath.emitMode) {
      case "start":
        t = splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "end":
        t = 1 - splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "random":
        t = this.rng.next();
        break;
      case "uniform":
        const interval = Math.max(0.01, splinePath.parameter);
        const numSlots = Math.ceil(1 / interval);
        const slot = this.rng.int(0, numSlots - 1);
        t = slot * interval;
        break;
      case "sequential":
        const currentT = this.sequentialEmitT.get(emitter.id) ?? 0;
        t = currentT;
        const speed = Math.max(1e-3, splinePath.parameter);
        let nextT = currentT + speed;
        if (nextT > 1) nextT = nextT - 1;
        this.sequentialEmitT.set(emitter.id, nextT);
        break;
      default:
        t = this.rng.next();
    }
    t = Math.max(0, Math.min(1, t));
    const result = this.splineProvider(splinePath.layerId, t, this.currentFrame);
    if (!result) {
      return { x: emitter.x, y: emitter.y };
    }
    let x = result.point.x;
    let y = result.point.y;
    if (splinePath.offset !== 0) {
      const tangentLength = Math.sqrt(result.tangent.x ** 2 + result.tangent.y ** 2);
      if (tangentLength > 1e-4) {
        const perpX = -result.tangent.y / tangentLength;
        const perpY = result.tangent.x / tangentLength;
        x += perpX * splinePath.offset;
        y += perpY * splinePath.offset;
      }
    }
    let direction;
    if (splinePath.alignToPath) {
      const tangentAngle = Math.atan2(result.tangent.y, result.tangent.x) * (180 / Math.PI);
      if (splinePath.bidirectional && this.rng.bool(0.5)) {
        direction = tangentAngle + 180;
      } else {
        direction = tangentAngle;
      }
      direction += 90;
    }
    return { x, y, direction };
  }
  handleBoundaryCollision(p) {
    if (!this.boundaryMask) return;
    const px = Math.floor(p.x * this.boundaryMask.width);
    const py = Math.floor(p.y * this.boundaryMask.height);
    if (px < 0 || px >= this.boundaryMask.width || py < 0 || py >= this.boundaryMask.height) {
      return;
    }
    const idx = (py * this.boundaryMask.width + px) * 4;
    const maskValue = this.boundaryMask.data[idx];
    if (maskValue < 128) {
      switch (this.config.boundaryBehavior) {
        case "bounce":
          p.vx *= -0.8;
          p.vy *= -0.8;
          p.x = p.prevX;
          p.y = p.prevY;
          break;
        case "kill":
          p.age = p.lifetime + 1;
          break;
        case "wrap":
          p.x = this.rng.next();
          p.y = this.rng.next();
          break;
      }
    }
  }
  handleCanvasBoundary(p) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        if (p.x < 0) {
          p.x = 0;
          p.vx *= -0.8;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx *= -0.8;
        }
        if (p.y < 0) {
          p.y = 0;
          p.vy *= -0.8;
        }
        if (p.y > 1) {
          p.y = 1;
          p.vy *= -0.8;
        }
        break;
      case "kill":
        if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1) {
          p.age = p.lifetime + 1;
        }
        break;
      case "wrap":
        if (p.x < 0) p.x += 1;
        if (p.x > 1) p.x -= 1;
        if (p.y < 0) p.y += 1;
        if (p.y > 1) p.y -= 1;
        break;
    }
  }
  applyModulations(p) {
    const lifeRatio = p.age / p.lifetime;
    for (const mod of this.modulations) {
      if (mod.emitterId !== "*" && mod.emitterId !== p.emitterId) continue;
      const easingKey = mod.easing;
      const easing = EASING_PRESETS[easingKey] || EASING_PRESETS.linear;
      const easedRatio = applyEasing$1(lifeRatio, easing);
      const value = mod.startValue + (mod.endValue - mod.startValue) * easedRatio;
      switch (mod.property) {
        case "size":
          p.size = p.baseSize * value;
          break;
        case "speed":
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (currentSpeed > 1e-4) {
            const scale = value / Math.max(1e-4, currentSpeed * 1e3);
            p.vx *= scale;
            p.vy *= scale;
          }
          break;
        case "opacity":
          p.color[3] = Math.max(0, Math.min(255, p.baseColor[3] * value));
          break;
        case "colorR":
          p.color[0] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorG":
          p.color[1] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorB":
          p.color[2] = Math.max(0, Math.min(255, value * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(p, deltaTime) {
    const turbFields = this.config.turbulenceFields || [];
    for (const turb of turbFields) {
      if (!turb.enabled) continue;
      const nx = p.x * turb.scale * 1e3;
      const ny = p.y * turb.scale * 1e3;
      const nt = this.noiseTime * turb.evolutionSpeed;
      const angle = this.noise2D(nx + nt, ny + nt) * Math.PI * 2;
      const force = turb.strength * 1e-5;
      p.vx += Math.cos(angle) * force * deltaTime;
      p.vy += Math.sin(angle) * force * deltaTime;
    }
  }
  addTurbulence(config) {
    if (!this.config.turbulenceFields) this.config.turbulenceFields = [];
    this.config.turbulenceFields.push(config);
  }
  updateTurbulence(id, updates) {
    const turb = this.config.turbulenceFields?.find((t) => t.id === id);
    if (turb) Object.assign(turb, updates);
  }
  removeTurbulence(id) {
    if (this.config.turbulenceFields) {
      this.config.turbulenceFields = this.config.turbulenceFields.filter((t) => t.id !== id);
    }
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  /**
   * Trigger sub-emitters when a particle dies
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   */
  triggerSubEmitters(deadParticle) {
    const subEmitters = this.config.subEmitters || [];
    for (const sub of subEmitters) {
      if (!sub.enabled) continue;
      if (sub.parentEmitterId !== "*" && sub.parentEmitterId !== deadParticle.emitterId) continue;
      for (let i = 0; i < sub.spawnCount; i++) {
        const angle = (this.rng.next() - 0.5) * sub.spread * Math.PI / 180;
        const baseAngle = Math.atan2(deadParticle.vy, deadParticle.vx);
        const emitAngle = baseAngle + angle;
        const inheritedSpeed = Math.sqrt(deadParticle.vx ** 2 + deadParticle.vy ** 2) * sub.inheritVelocity;
        const totalSpeed = sub.speed * 1e-3 + inheritedSpeed;
        const particle = {
          id: this.nextParticleId++,
          x: deadParticle.x,
          y: deadParticle.y,
          prevX: deadParticle.x,
          prevY: deadParticle.y,
          vx: Math.cos(emitAngle) * totalSpeed + deadParticle.vx * sub.inheritVelocity,
          vy: Math.sin(emitAngle) * totalSpeed + deadParticle.vy * sub.inheritVelocity,
          age: 0,
          lifetime: sub.lifetime * (1 + (this.rng.next() - 0.5) * 0.2),
          size: sub.size * (1 + (this.rng.next() - 0.5) * sub.sizeVariance / sub.size),
          baseSize: sub.size,
          color: [...sub.color, 255],
          baseColor: [...sub.color, 255],
          emitterId: sub.id,
          isSubParticle: true,
          rotation: deadParticle.rotation,
          // Inherit parent rotation
          angularVelocity: 0,
          spriteIndex: 0,
          collisionCount: 0
        };
        this.particles.push(particle);
        this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
      }
    }
  }
  addSubEmitter(config) {
    if (!this.config.subEmitters) this.config.subEmitters = [];
    this.config.subEmitters.push(config);
  }
  updateSubEmitter(id, updates) {
    const sub = this.config.subEmitters?.find((s) => s.id === id);
    if (sub) Object.assign(sub, updates);
  }
  removeSubEmitter(id) {
    if (this.config.subEmitters) {
      this.config.subEmitters = this.config.subEmitters.filter((s) => s.id !== id);
    }
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(emitterId, count) {
    const emitter = this.emitters.get(emitterId);
    if (!emitter || !emitter.enabled) return;
    const burstCount = count ?? emitter.burstCount ?? 20;
    for (let i = 0; i < burstCount; i++) {
      this.spawnParticle(emitter);
    }
  }
  triggerAllBursts() {
    for (const emitter of this.emitters.values()) {
      if (emitter.burstOnBeat && emitter.enabled) {
        this.triggerBurst(emitter.id);
      }
    }
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    const cellSize = this.renderOptions.connections?.maxDistance || 100;
    const cells = /* @__PURE__ */ new Map();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x * 1e3 / cellSize);
      const cellY = Math.floor(p.y * 1e3 / cellSize);
      const key = `${cellX},${cellY}`;
      if (!cells.has(key)) cells.set(key, []);
      cells.get(key).push(p);
    }
    return { cellSize, cells };
  }
  getNeighborParticles(p, grid) {
    const cellX = Math.floor(p.x * 1e3 / grid.cellSize);
    const cellY = Math.floor(p.y * 1e3 / grid.cellSize);
    const neighbors = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cellX + dx},${cellY + dy}`;
        const cell = grid.cells.get(key);
        if (cell) neighbors.push(...cell);
      }
    }
    return neighbors;
  }
  renderConnections(ctx, width, height) {
    const config = this.renderOptions.connections;
    if (!config?.enabled || this.particles.length < 2) return;
    const grid = this.buildSpatialGrid();
    const maxDist = config.maxDistance / 1e3;
    const maxDistSq = maxDist * maxDist;
    ctx.lineWidth = config.lineWidth;
    for (const p of this.particles) {
      const neighbors = this.getNeighborParticles(p, grid);
      let connectionCount = 0;
      for (const other of neighbors) {
        if (other.id <= p.id) continue;
        if (connectionCount >= config.maxConnections) break;
        const dx = other.x - p.x;
        const dy = other.y - p.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < maxDistSq) {
          const dist = Math.sqrt(distSq);
          let opacity = config.lineOpacity;
          if (config.fadeByDistance) {
            opacity *= 1 - dist / maxDist;
          }
          const r = Math.round((p.color[0] + other.color[0]) / 2);
          const g = Math.round((p.color[1] + other.color[1]) / 2);
          const b = Math.round((p.color[2] + other.color[2]) / 2);
          ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
          ctx.beginPath();
          ctx.moveTo(p.x * width, p.y * height);
          ctx.lineTo(other.x * width, other.y * height);
          ctx.stroke();
          connectionCount++;
        }
      }
    }
  }
  reset() {
    this.particles = [];
    this.particlePool = [];
    this.frameCount = 0;
    this.trailHistory.clear();
    this.emissionAccumulators.forEach((_, key) => {
      this.emissionAccumulators.set(key, 0);
    });
    this.nextParticleId = 0;
    this.sequentialEmitT.clear();
    this.currentFrame = 0;
  }
  /**
   * Get particle pool statistics for debugging
   */
  getPoolStats() {
    return {
      poolSize: this.particlePool.length,
      maxPoolSize: this.poolMaxSize,
      activeParticles: this.particles.length
    };
  }
  /**
   * Clear the particle pool to free memory
   * Call this when memory pressure is high
   */
  clearPool() {
    this.particlePool = [];
  }
  /**
   * Restore particles from serialized state (for checkpoint restoration)
   * DETERMINISM: Restores exact particle positions for scrub-safe simulation
   *
   * @param particleStates - Array of serialized particle states from a checkpoint
   * @param frameCount - The frame number being restored to
   */
  restoreParticles(particleStates, frameCount) {
    this.particles = [];
    this.trailHistory.clear();
    let maxId = 0;
    for (const state of particleStates) {
      const particle = {
        id: state.id,
        x: state.x,
        y: state.y,
        prevX: state.x,
        // Previous position set to current (no trail initially)
        prevY: state.y,
        vx: state.vx,
        vy: state.vy,
        age: state.age,
        lifetime: state.lifetime,
        size: state.size,
        baseSize: state.size,
        // Base size set to current
        color: [...state.color],
        baseColor: [...state.color],
        emitterId: state.emitterId,
        isSubParticle: false,
        rotation: state.rotation,
        angularVelocity: 0,
        // Default angular velocity
        spriteIndex: 0,
        collisionCount: 0
        // Reset collision count on restore
      };
      this.particles.push(particle);
      maxId = Math.max(maxId, state.id);
    }
    this.nextParticleId = maxId + 1;
    this.frameCount = frameCount;
  }
  warmup() {
    for (let i = 0; i < this.config.warmupPeriod; i++) {
      this.step(1);
    }
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(ctx, width, height, options = createDefaultRenderOptions()) {
    this.renderOptions = options;
    ctx.save();
    switch (options.blendMode) {
      case "additive":
        ctx.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        ctx.globalCompositeOperation = "multiply";
        break;
      case "screen":
        ctx.globalCompositeOperation = "screen";
        break;
      default:
        ctx.globalCompositeOperation = "source-over";
    }
    this.renderConnections(ctx, width, height);
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size;
      if (options.renderTrails) {
        const trail = this.trailHistory.get(p.id);
        if (trail && trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          const trailLen = Math.min(trail.length, options.trailLength);
          for (let i = 0; i < trailLen; i++) {
            const tp = trail[i];
            const opacity = p.color[3] * Math.pow(options.trailOpacityFalloff, i + 1);
            ctx.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${opacity / 255})`;
            ctx.lineWidth = size * Math.pow(options.trailOpacityFalloff, i);
            ctx.lineTo(tp.x * width, tp.y * height);
          }
          ctx.stroke();
        }
      }
      if (options.glowEnabled) {
        ctx.shadowBlur = options.glowRadius;
        ctx.shadowColor = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${options.glowIntensity})`;
      } else {
        ctx.shadowBlur = 0;
      }
      if (options.motionBlur && (p.vx !== 0 || p.vy !== 0)) {
        this.renderParticleWithMotionBlur(ctx, p, x, y, size, width, height, options);
      } else {
        this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
      }
    }
    ctx.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(ctx, p, x, y, size, _width, _height, options) {
    const velocityMag = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
    if (velocityMag < 1e-4) {
      this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape);
      return;
    }
    const stretchFactor = options.motionBlurStrength * velocityMag * 500;
    const samples = Math.min(options.motionBlurSamples, 16);
    const dirX = p.vx / velocityMag;
    const dirY = p.vy / velocityMag;
    const stretchDistance = Math.min(stretchFactor * size, size * 10);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      const sampleOpacity = (1 - t * 0.8) / samples;
      const sampleX = x - dirX * stretchDistance * t;
      const sampleY = y - dirY * stretchDistance * t;
      const sampleSize = size * (1 - t * 0.3);
      const alpha = p.color[3] / 255 * sampleOpacity * samples;
      ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${Math.min(1, alpha)})`;
      this.renderParticleShape(ctx, sampleX, sampleY, sampleSize, null, options.particleShape, p, options);
    }
    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.color[3] / 255})`;
    this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(ctx, x, y, size, color, shape, particle, options) {
    if (color) {
      ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
    }
    if (shape === "sprite" && particle) {
      this.renderSprite(ctx, x, y, size, particle, options);
      return;
    }
    const hasRotation = particle && particle.rotation !== 0;
    if (hasRotation && particle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(particle.rotation);
      this.drawShapeAtOrigin(ctx, size, shape);
      ctx.restore();
    } else {
      switch (shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          break;
        case "star":
          this.drawStar(ctx, x, y, 5, size / 2, size / 4);
          ctx.fill();
          break;
      }
    }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(ctx, size, shape) {
    switch (shape) {
      case "circle":
        ctx.beginPath();
        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case "square":
        ctx.fillRect(-size / 2, -size / 2, size, size);
        break;
      case "triangle":
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(-size / 2, size / 2);
        ctx.lineTo(size / 2, size / 2);
        ctx.closePath();
        ctx.fill();
        break;
      case "star":
        this.drawStar(ctx, 0, 0, 5, size / 2, size / 4);
        ctx.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(ctx, x, y, size, particle, options) {
    const emitter = this.emitters.get(particle.emitterId);
    if (!emitter?.sprite?.enabled) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    const sprite = emitter.sprite;
    const image = sprite.imageData || this.spriteCache.get(particle.emitterId);
    if (!image) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    ctx.save();
    ctx.imageSmoothingEnabled = options?.spriteSmoothing ?? true;
    let alpha = particle.color[3] / 255;
    if (options?.spriteOpacityByAge) {
      const lifeRatio = particle.age / particle.lifetime;
      if (lifeRatio > 0.8) {
        alpha *= 1 - (lifeRatio - 0.8) / 0.2;
      }
    }
    ctx.globalAlpha = alpha;
    let sx = 0;
    let sy = 0;
    let sw = image.width;
    let sh = image.height;
    if (sprite.isSheet && sprite.columns > 1 || sprite.rows > 1) {
      const frameWidth = image.width / sprite.columns;
      const frameHeight = image.height / sprite.rows;
      const col = particle.spriteIndex % sprite.columns;
      const row = Math.floor(particle.spriteIndex / sprite.columns) % sprite.rows;
      sx = col * frameWidth;
      sy = row * frameHeight;
      sw = frameWidth;
      sh = frameHeight;
    }
    ctx.translate(x, y);
    if (particle.rotation !== 0) {
      ctx.rotate(particle.rotation);
    }
    const halfSize = size / 2;
    ctx.drawImage(
      image,
      sx,
      sy,
      sw,
      sh,
      // Source rectangle
      -halfSize,
      -halfSize,
      size,
      size
      // Destination rectangle
    );
    ctx.restore();
  }
  drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    ctx.beginPath();
    let rotation = -Math.PI / 2;
    for (let i = 0; i < spikes; i++) {
      const outerX = cx + Math.cos(rotation) * outerRadius;
      const outerY = cy + Math.sin(rotation) * outerRadius;
      if (i === 0) {
        ctx.moveTo(outerX, outerY);
      } else {
        ctx.lineTo(outerX, outerY);
      }
      rotation += Math.PI / spikes;
      const innerX = cx + Math.cos(rotation) * innerRadius;
      const innerY = cy + Math.sin(rotation) * innerRadius;
      ctx.lineTo(innerX, innerY);
      rotation += Math.PI / spikes;
    }
    ctx.closePath();
  }
  renderToMask(width, height) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    const connConfig = this.renderOptions.connections;
    if (connConfig?.enabled && this.particles.length >= 2) {
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = connConfig.lineWidth * 2;
      this.renderConnections(ctx, width, height);
    }
    ctx.fillStyle = "#000000";
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
    return ctx.getImageData(0, 0, width, height);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(data) {
    const system = new ParticleSystem(data.config);
    if (data.emitters) {
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
    }
    if (data.modulations) {
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
    }
    return system;
  }
}

class SeededRNG {
  state;
  constructor(seed) {
    this.state = seed;
  }
  /** Reset to initial seed */
  reset(seed) {
    this.state = seed;
  }
  /** Get next random number in [0, 1) */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
}
class ParticleSimulationController {
  /** The underlying particle system (used for simulation) */
  system;
  /** Configuration (immutable after construction) */
  config;
  /** Master seed for deterministic simulation */
  seed;
  /** Seeded RNG instance */
  rng;
  /** Checkpoint interval (frames between cached states) */
  checkpointInterval;
  /** Cached checkpoints: frame â†’ checkpoint */
  checkpoints;
  /** Last evaluated frame (for optimization) */
  lastEvaluatedFrame = -1;
  /** Last snapshot (cached for repeated access) */
  lastSnapshot = null;
  constructor(config, seed = 12345, checkpointInterval = 30) {
    this.config = { ...config };
    this.seed = seed;
    this.rng = new SeededRNG(seed);
    this.checkpointInterval = checkpointInterval;
    this.checkpoints = /* @__PURE__ */ new Map();
    this.system = new ParticleSystem(config, seed);
    this.createCheckpoint(0);
  }
  /**
   * Evaluate particle state at a specific frame
   *
   * PURE (relative to frame number): Same frame always produces same result.
   *
   * @param frame - Target frame number
   * @returns Immutable ParticleSnapshot
   */
  evaluateAtFrame(frame) {
    if (frame === this.lastEvaluatedFrame && this.lastSnapshot) {
      return this.lastSnapshot;
    }
    const checkpointFrame = this.findNearestCheckpoint(frame);
    this.restoreCheckpoint(checkpointFrame);
    const framesToSimulate = frame - checkpointFrame;
    for (let i = 0; i < framesToSimulate; i++) {
      this.deterministicStep();
      const currentFrame = checkpointFrame + i + 1;
      if (currentFrame % this.checkpointInterval === 0 && !this.checkpoints.has(currentFrame)) {
        this.createCheckpoint(currentFrame);
      }
    }
    const snapshot = this.createSnapshot(frame);
    this.lastEvaluatedFrame = frame;
    this.lastSnapshot = snapshot;
    return snapshot;
  }
  /**
   * Get the underlying particles for rendering
   * NOTE: This is a convenience method; prefer evaluateAtFrame() for determinism
   */
  getParticles() {
    return this.system.getParticles();
  }
  /**
   * Reset controller and clear all checkpoints
   */
  reset() {
    this.system.reset();
    this.rng.reset(this.seed);
    this.checkpoints.clear();
    this.lastEvaluatedFrame = -1;
    this.lastSnapshot = null;
    this.createCheckpoint(0);
  }
  /**
   * Update configuration (clears all checkpoints)
   */
  updateConfig(updates) {
    Object.assign(this.config, updates);
    this.system.setConfig(updates);
    this.reset();
  }
  /**
   * Get current seed
   */
  getSeed() {
    return this.seed;
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  /**
   * Find the frame number of the nearest checkpoint at or before target
   */
  findNearestCheckpoint(targetFrame) {
    let nearest = 0;
    for (const frame of this.checkpoints.keys()) {
      if (frame <= targetFrame && frame > nearest) {
        nearest = frame;
      }
    }
    return nearest;
  }
  /**
   * Create a checkpoint at the current state
   * DETERMINISM: Captures RNG state for exact restoration
   */
  createCheckpoint(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    const checkpoint = {
      frame,
      particles,
      emissionAccumulators: /* @__PURE__ */ new Map(),
      // Would need access to system internals
      nextParticleId: particles.length > 0 ? Math.max(...particles.map((p) => p.id)) + 1 : 0,
      noiseTime: 0,
      // Would need access to system internals
      frameCount: frame,
      // Capture RNG state from the particle system for deterministic restoration
      rngState: this.system.getRng().getState()
    };
    this.checkpoints.set(frame, checkpoint);
  }
  /**
   * Restore state from a checkpoint
   * DETERMINISM: Restores exact RNG state for reproducible continuation
   */
  restoreCheckpoint(frame) {
    const checkpoint = this.checkpoints.get(frame);
    if (!checkpoint) {
      throw new Error(`No checkpoint at frame ${frame}`);
    }
    this.system.getRng().setState(checkpoint.rngState);
    this.rng.setState(checkpoint.rngState);
    this.system.restoreParticles(checkpoint.particles, checkpoint.frame);
  }
  /**
   * Perform one deterministic simulation step
   * DETERMINISM: ParticleSystem now uses seeded RNG (mulberry32) for all randomness
   */
  deterministicStep() {
    this.system.step(1);
  }
  /**
   * Serialize a particle to immutable state
   */
  serializeParticle(p) {
    return Object.freeze({
      id: p.id,
      x: p.x,
      y: p.y,
      vx: p.vx,
      vy: p.vy,
      age: p.age,
      lifetime: p.lifetime,
      size: p.size,
      color: Object.freeze([...p.color]),
      rotation: p.rotation,
      emitterId: p.emitterId
    });
  }
  /**
   * Create an immutable snapshot of current state
   * DETERMINISM: No timestamps - only deterministic values
   */
  createSnapshot(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    return Object.freeze({
      frame,
      particles: Object.freeze(particles),
      count: particles.length,
      seed: this.seed,
      rngState: this.system.getRng().getState()
    });
  }
}
class ParticleSimulationRegistry {
  controllers = /* @__PURE__ */ new Map();
  /**
   * Get or create a controller for a layer
   */
  getController(layerId, config, seed) {
    let controller = this.controllers.get(layerId);
    if (!controller) {
      controller = new ParticleSimulationController(config, seed ?? this.generateSeed(layerId));
      this.controllers.set(layerId, controller);
    }
    return controller;
  }
  /**
   * Evaluate particles for a layer at a frame
   */
  evaluateLayer(layerId, frame, config, seed) {
    const controller = this.getController(layerId, config, seed);
    return controller.evaluateAtFrame(frame);
  }
  /**
   * Reset a specific layer's controller
   */
  resetLayer(layerId) {
    const controller = this.controllers.get(layerId);
    if (controller) {
      controller.reset();
    }
  }
  /**
   * Clear all controllers
   */
  clear() {
    this.controllers.clear();
  }
  /**
   * Generate deterministic seed from layer ID
   */
  generateSeed(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
const particleSimulationRegistry = new ParticleSimulationRegistry();

class FrameStateCache {
  cache = /* @__PURE__ */ new Map();
  maxSize;
  maxAgeMs;
  constructor(maxSize = 120, maxAgeMs = 3e4) {
    this.maxSize = maxSize;
    this.maxAgeMs = maxAgeMs;
  }
  /**
   * Generate cache key from frame + composition ID
   */
  makeKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Compute a lightweight hash of project state that affects rendering
   * Changes to layers, keyframes, or effects invalidate the cache
   */
  computeProjectHash(project) {
    const comp = project.compositions[project.mainCompositionId];
    if (!comp) return "";
    let hash = 0;
    const str = JSON.stringify({
      layerCount: comp.layers.length,
      layerIds: comp.layers.map((l) => l.id),
      modified: project.meta?.modified || "",
      // Include layer visibility and animation state in hash
      layerStates: comp.layers.map((l) => ({
        id: l.id,
        visible: l.visible,
        inPoint: l.inPoint,
        outPoint: l.outPoint,
        kfCount: l.properties.reduce((sum, p) => sum + (p.keyframes?.length || 0), 0)
      }))
    });
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  /**
   * Get cached frame state if valid
   */
  get(frame, compositionId, projectHash) {
    const key = this.makeKey(frame, compositionId);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (entry.projectHash !== projectHash || now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.frameState;
  }
  /**
   * Store frame state in cache
   */
  set(frame, compositionId, projectHash, frameState) {
    const key = this.makeKey(frame, compositionId);
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, {
      frameState,
      projectHash,
      timestamp: Date.now()
    });
  }
  /**
   * Invalidate all cached entries
   * Call when project structure changes (layer add/remove, etc.)
   */
  invalidate() {
    this.cache.clear();
  }
  /**
   * Invalidate entries for a specific composition
   */
  invalidateComposition(compositionId) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${compositionId}:`)) {
        this.cache.delete(key);
      }
    }
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: 0
      // Would need hit/miss tracking
    };
  }
}
class MotionEngine {
  /**
   * Frame state cache for memoization
   * Dramatically improves scrubbing performance (90%+ for repeated frames)
   */
  frameCache = new FrameStateCache();
  lastProjectHash = "";
  /**
   * Invalidate the frame cache
   * Call this when project structure changes
   */
  invalidateCache() {
    this.frameCache.invalidate();
    this.lastProjectHash = "";
  }
  /**
   * Get cache statistics for debugging
   */
  getCacheStats() {
    return this.frameCache.getStats();
  }
  /**
   * Evaluate complete frame state
   *
   * PURE FUNCTION: Same inputs always produce same outputs
   * NO SIDE EFFECTS: Does not mutate project, layers, or any external state
   *
   * @param frame - Absolute frame number (0-indexed)
   * @param project - The project data (read-only)
   * @param audioAnalysis - Pre-computed audio analysis (optional)
   * @param activeCameraId - ID of active camera layer (optional)
   * @param useCache - Whether to use memoization cache (default: true)
   * @returns Immutable FrameState snapshot
   */
  evaluate(frame, project, audioAnalysis, activeCameraId, useCache = true) {
    const composition = project.compositions[project.mainCompositionId];
    if (!composition) {
      return this.createEmptyFrameState(frame, project.composition);
    }
    const projectHash = useCache ? this.frameCache.computeProjectHash(project) : "";
    if (useCache) {
      const cached = this.frameCache.get(frame, project.mainCompositionId, projectHash);
      if (cached) {
        return cached;
      }
    }
    const evaluatedLayers = this.evaluateLayers(frame, composition.layers);
    const evaluatedCamera = this.evaluateCamera(
      frame,
      composition.layers,
      activeCameraId ?? null,
      composition.settings
    );
    const evaluatedAudio = this.evaluateAudio(frame, audioAnalysis ?? null);
    const particleSnapshots = this.evaluateParticleLayers(frame, composition.layers);
    const frameState = Object.freeze({
      frame,
      composition: composition.settings,
      layers: Object.freeze(evaluatedLayers),
      camera: evaluatedCamera,
      audio: evaluatedAudio,
      particleSnapshots: Object.freeze(particleSnapshots)
    });
    if (useCache) {
      this.frameCache.set(frame, project.mainCompositionId, projectHash, frameState);
    }
    return frameState;
  }
  /**
   * Evaluate a single property at a given frame
   * Utility method for UI components that need individual values
   */
  evaluateProperty(property, frame) {
    return interpolateProperty(property, frame);
  }
  /**
   * Check if a layer is visible at a given frame
   */
  isLayerVisibleAtFrame(layer, frame) {
    return layer.visible && frame >= layer.inPoint && frame <= layer.outPoint;
  }
  // ============================================================================
  // PRIVATE EVALUATION METHODS
  // ============================================================================
  evaluateLayers(frame, layers) {
    const evaluated = [];
    for (const layer of layers) {
      const inRange = frame >= layer.inPoint && frame <= layer.outPoint;
      const visible = layer.visible && inRange;
      const transform = this.evaluateTransform(frame, layer.transform, layer.threeD);
      const opacity = interpolateProperty(layer.opacity, frame);
      const effects = this.evaluateEffects(frame, layer.effects);
      const properties = this.evaluateLayerProperties(frame, layer);
      evaluated.push(Object.freeze({
        id: layer.id,
        type: layer.type,
        name: layer.name,
        visible,
        inRange,
        opacity,
        transform: Object.freeze(transform),
        effects: Object.freeze(effects),
        properties: Object.freeze(properties),
        parentId: layer.parentId,
        blendMode: layer.blendMode,
        threeD: layer.threeD,
        layerRef: layer
        // Reference for static data only - NOT for evaluation
      }));
    }
    return evaluated;
  }
  evaluateTransform(frame, transform, is3D) {
    const position = interpolateProperty(transform.position, frame);
    const anchorPoint = interpolateProperty(transform.anchorPoint, frame);
    const scale = interpolateProperty(transform.scale, frame);
    const rotation = interpolateProperty(transform.rotation, frame);
    const result = {
      position: { ...position },
      anchorPoint: { ...anchorPoint },
      scale: { ...scale },
      rotation
    };
    if (is3D) {
      return {
        ...result,
        rotationX: transform.rotationX ? interpolateProperty(transform.rotationX, frame) : 0,
        rotationY: transform.rotationY ? interpolateProperty(transform.rotationY, frame) : 0,
        rotationZ: transform.rotationZ ? interpolateProperty(transform.rotationZ, frame) : rotation
      };
    }
    return result;
  }
  evaluateEffects(frame, effects) {
    return effects.map((effect) => {
      const evaluatedParams = {};
      for (const [key, param] of Object.entries(effect.parameters)) {
        if (this.isAnimatableProperty(param)) {
          evaluatedParams[key] = interpolateProperty(param, frame);
        } else {
          evaluatedParams[key] = param;
        }
      }
      return Object.freeze({
        id: effect.id,
        type: effect.effectKey,
        // Use effectKey as the effect type identifier
        enabled: effect.enabled,
        parameters: Object.freeze(evaluatedParams)
      });
    });
  }
  evaluateLayerProperties(frame, layer) {
    const evaluated = {};
    for (const prop of layer.properties) {
      evaluated[prop.name] = interpolateProperty(prop, frame);
    }
    switch (layer.type) {
      case "text":
        break;
      case "solid":
        break;
      case "depthflow":
        if (layer.data && "animatedZoom" in layer.data) {
          const data = layer.data;
          if (data.animatedZoom) {
            evaluated["zoom"] = interpolateProperty(data.animatedZoom, frame);
          }
          if (data.animatedOffsetX) {
            evaluated["offsetX"] = interpolateProperty(data.animatedOffsetX, frame);
          }
          if (data.animatedOffsetY) {
            evaluated["offsetY"] = interpolateProperty(data.animatedOffsetY, frame);
          }
          if (data.animatedRotation) {
            evaluated["rotation"] = interpolateProperty(data.animatedRotation, frame);
          }
        }
        break;
      case "particles":
        evaluated["_requiresSimulation"] = true;
        break;
    }
    return evaluated;
  }
  evaluateCamera(frame, layers, activeCameraId, compositionSettings) {
    let cameraLayer;
    if (activeCameraId) {
      cameraLayer = layers.find(
        (l) => l.id === activeCameraId && l.type === "camera"
      );
    }
    if (!cameraLayer) {
      cameraLayer = layers.find(
        (l) => l.type === "camera" && l.visible && frame >= l.inPoint && frame <= l.outPoint
      );
    }
    if (!cameraLayer || !cameraLayer.data) {
      return null;
    }
    const cameraData = cameraLayer.data;
    const transform = this.evaluateTransform(frame, cameraLayer.transform, true);
    const compWidth = compositionSettings?.width ?? 1024;
    const compHeight = compositionSettings?.height ?? 1024;
    const centerX = compWidth / 2;
    const centerY = compHeight / 2;
    let position = { x: transform.position.x, y: transform.position.y, z: 0 };
    let target = { x: centerX, y: centerY, z: 0 };
    let fov = 50;
    let focalLength = 50;
    if (cameraData.animatedPosition) {
      const pos = interpolateProperty(cameraData.animatedPosition, frame);
      position = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    }
    if (cameraData.animatedTarget) {
      const tgt = interpolateProperty(cameraData.animatedTarget, frame);
      target = { x: tgt.x, y: tgt.y, z: tgt.z ?? 0 };
    }
    if (cameraData.animatedFov) {
      fov = interpolateProperty(cameraData.animatedFov, frame);
    }
    if (cameraData.animatedFocalLength) {
      focalLength = interpolateProperty(cameraData.animatedFocalLength, frame);
    }
    let focusDistance = cameraData.depthOfField?.focusDistance ?? 1e3;
    let aperture = cameraData.depthOfField?.aperture ?? 2.8;
    let blurLevel = cameraData.depthOfField?.blurLevel ?? 50;
    if (cameraData.animatedFocusDistance) {
      focusDistance = interpolateProperty(cameraData.animatedFocusDistance, frame);
    }
    if (cameraData.animatedAperture) {
      aperture = interpolateProperty(cameraData.animatedAperture, frame);
    }
    if (cameraData.animatedBlurLevel) {
      blurLevel = interpolateProperty(cameraData.animatedBlurLevel, frame);
    }
    return Object.freeze({
      id: cameraLayer.id,
      name: cameraLayer.name,
      position: Object.freeze(position),
      target: Object.freeze(target),
      fov,
      focalLength,
      depthOfField: Object.freeze({
        enabled: cameraData.depthOfField?.enabled ?? false,
        focusDistance,
        aperture,
        blurLevel
      })
    });
  }
  evaluateAudio(frame, analysis) {
    if (!analysis) {
      return Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      });
    }
    return Object.freeze({
      hasAudio: true,
      amplitude: getFeatureAtFrame(analysis, "amplitude", frame),
      rms: getFeatureAtFrame(analysis, "rms", frame),
      bass: getFeatureAtFrame(analysis, "bass", frame),
      mid: getFeatureAtFrame(analysis, "mid", frame),
      high: getFeatureAtFrame(analysis, "high", frame),
      spectralCentroid: getFeatureAtFrame(analysis, "spectralCentroid", frame),
      isBeat: getFeatureAtFrame(analysis, "onsets", frame) > 0.5,
      isOnset: getFeatureAtFrame(analysis, "onsets", frame) > 0,
      bpm: analysis.bpm
    });
  }
  /**
   * Evaluate particle layers through deterministic simulation
   * DETERMINISM: Uses ParticleSimulationRegistry which guarantees same frame = same result
   */
  evaluateParticleLayers(frame, layers) {
    const snapshots = {};
    for (const layer of layers) {
      if (layer.type !== "particles" || !layer.visible) continue;
      if (frame < layer.inPoint || frame > layer.outPoint) continue;
      const data = layer.data;
      if (!data?.systemConfig) continue;
      const config = this.convertToParticleSystemConfig(data);
      const relativeFrame = frame - layer.inPoint;
      const snapshot = particleSimulationRegistry.evaluateLayer(
        layer.id,
        relativeFrame,
        config
      );
      snapshots[layer.id] = snapshot;
    }
    return snapshots;
  }
  /**
   * Convert ParticleLayerData to ParticleSystemConfig
   * Maps the project-level configuration to the simulation config
   */
  convertToParticleSystemConfig(data) {
    const sys = data.systemConfig;
    return {
      maxParticles: sys.maxParticles,
      gravity: sys.gravity,
      windStrength: sys.windStrength,
      windDirection: sys.windDirection,
      warmupPeriod: sys.warmupPeriod,
      respectMaskBoundary: sys.respectMaskBoundary,
      boundaryBehavior: sys.boundaryBehavior,
      friction: sys.friction,
      turbulenceFields: sys.turbulenceFields ?? [],
      subEmitters: sys.subEmitters ?? [],
      collision: {
        enabled: false,
        particleCollision: false,
        particleCollisionRadius: 1,
        particleCollisionResponse: "bounce",
        particleCollisionDamping: 0.5,
        layerCollision: false,
        layerCollisionLayerId: null,
        layerCollisionThreshold: 0.5,
        floorEnabled: false,
        floorY: 1,
        ceilingEnabled: false,
        ceilingY: 0,
        wallsEnabled: false,
        bounciness: 0.8,
        friction: 0.1,
        spatialHashCellSize: 32
      }
    };
  }
  /**
   * Create empty frame state for missing compositions
   * DETERMINISM: No timestamps or non-deterministic values
   */
  createEmptyFrameState(frame, settings) {
    return Object.freeze({
      frame,
      composition: settings,
      layers: Object.freeze([]),
      camera: null,
      audio: Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      }),
      particleSnapshots: Object.freeze({})
    });
  }
  /**
   * Type guard to check if a value is an AnimatableProperty
   */
  isAnimatableProperty(value) {
    return typeof value === "object" && value !== null && "value" in value && "keyframes" in value && Array.isArray(value.keyframes);
  }
}
const motionEngine = new MotionEngine();

const easingFunctions = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (t) => t,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return c3 * t * t * t - c1 * t * t;
  },
  easeOutBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  },
  easeInOutBack: (t) => {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;
    return t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
  },
  easeOutElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  },
  easeInOutElastic: (t) => {
    const c5 = 2 * Math.PI / 4.5;
    return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (t) => 1 - easingFunctions.easeOutBounce(1 - t),
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInOutBounce: (t) => t < 0.5 ? (1 - easingFunctions.easeOutBounce(1 - 2 * t)) / 2 : (1 + easingFunctions.easeOutBounce(2 * t - 1)) / 2
};

class KeyframeEvaluator {
  // Cache for recent evaluations (cleared per frame batch)
  cache = /* @__PURE__ */ new Map();
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(property, frame) {
    const cacheKey = property.id;
    const cached = this.cache.get(cacheKey);
    if (cached && cached.frame === frame) {
      return cached.value;
    }
    let value;
    if (!property.animated || !property.keyframes || property.keyframes.length === 0) {
      value = property.value;
    } else {
      value = this.evaluateKeyframes(property.keyframes, frame, property.value);
    }
    this.cache.set(cacheKey, { frame, value });
    return value;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(keyframes, frame, defaultValue) {
    const sorted = [...keyframes].sort((a, b) => a.frame - b.frame);
    if (frame <= sorted[0].frame) {
      return sorted[0].value;
    }
    if (frame >= sorted[sorted.length - 1].frame) {
      return sorted[sorted.length - 1].value;
    }
    let prevKeyframe = sorted[0];
    let nextKeyframe = sorted[sorted.length - 1];
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i].frame <= frame && sorted[i + 1].frame > frame) {
        prevKeyframe = sorted[i];
        nextKeyframe = sorted[i + 1];
        break;
      }
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const rawT = frameDiff > 0 ? (frame - prevKeyframe.frame) / frameDiff : 0;
    const easedT = this.applyEasing(rawT, prevKeyframe.interpolation, prevKeyframe, nextKeyframe);
    return this.interpolateValue(prevKeyframe.value, nextKeyframe.value, easedT, defaultValue);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(t, interpolation, prevKeyframe, nextKeyframe) {
    switch (interpolation) {
      case "hold":
        return 0;
      case "linear":
        return t;
      case "bezier":
        return this.evaluateBezier(t, prevKeyframe, nextKeyframe);
      default:
        const easingFn = easingFunctions[interpolation];
        if (easingFn) {
          return easingFn(t);
        }
        return t;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(t, prevKeyframe, nextKeyframe) {
    const outHandle = prevKeyframe.outHandle;
    const inHandle = nextKeyframe.inHandle;
    if (!outHandle?.enabled && !inHandle?.enabled) {
      return t;
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const p0 = { x: 0, y: 0 };
    const p1 = {
      x: outHandle?.enabled ? Math.min(1, Math.max(0, outHandle.frame / frameDiff)) : 0.33,
      y: outHandle?.enabled ? outHandle.value : 0
    };
    const p2 = {
      x: inHandle?.enabled ? Math.min(1, Math.max(0, 1 + inHandle.frame / frameDiff)) : 0.67,
      y: inHandle?.enabled ? 1 + inHandle.value : 1
    };
    const p3 = { x: 1, y: 1 };
    return this.solveCubicBezier(t, p0.x, p1.x, p2.x, p3.x, p0.y, p1.y, p2.y, p3.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(x, x0, x1, x2, x3, y0, y1, y2, y3) {
    let t = x;
    const epsilon = 1e-4;
    for (let i = 0; i < 10; i++) {
      const currentX = this.cubicBezier(t, x0, x1, x2, x3);
      const diff = currentX - x;
      if (Math.abs(diff) < epsilon) {
        break;
      }
      const derivative = this.cubicBezierDerivative(t, x0, x1, x2, x3);
      if (Math.abs(derivative) < epsilon) {
        break;
      }
      t -= diff / derivative;
      t = Math.max(0, Math.min(1, t));
    }
    return this.cubicBezier(t, y0, y1, y2, y3);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(from, to, t, defaultValue) {
    if (typeof from === "number" && typeof to === "number") {
      return from + (to - from) * t;
    }
    if (this.isPositionLike(from) && this.isPositionLike(to)) {
      return this.interpolatePosition(from, to, t);
    }
    if (typeof from === "string" && typeof to === "string") {
      if (from.startsWith("#") && to.startsWith("#")) {
        return this.interpolateColor(from, to, t);
      }
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return this.interpolateArray(from, to, t);
    }
    return t < 0.5 ? from : to;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(value) {
    return value !== null && typeof value === "object" && "x" in value && "y" in value;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(from, to, t) {
    const result = {
      x: from.x + (to.x - from.x) * t,
      y: from.y + (to.y - from.y) * t
    };
    if ("z" in from || "z" in to) {
      result.z = (from.z ?? 0) + ((to.z ?? 0) - (from.z ?? 0)) * t;
    }
    return result;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(from, to, t) {
    const fromRGB = this.hexToRGB(from);
    const toRGB = this.hexToRGB(to);
    const r = Math.round(fromRGB.r + (toRGB.r - fromRGB.r) * t);
    const g = Math.round(fromRGB.g + (toRGB.g - fromRGB.g) * t);
    const b = Math.round(fromRGB.b + (toRGB.b - fromRGB.b) * t);
    return this.rgbToHex(r, g, b);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(from, to, t) {
    const length = Math.max(from.length, to.length);
    const result = [];
    for (let i = 0; i < length; i++) {
      const fromVal = from[i] ?? 0;
      const toVal = to[i] ?? 0;
      result.push(fromVal + (toVal - fromVal) * t);
    }
    return result;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(r, g, b) {
    return "#" + [r, g, b].map((x) => Math.max(0, Math.min(255, x)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}

class CanvasPool {
  pool = [];
  maxSize = 20;
  // Max pooled canvases
  maxAge = 6e4;
  // 60 second TTL for unused canvases
  /**
   * Acquire a canvas of the specified dimensions
   */
  acquire(width, height) {
    const now = Date.now();
    for (const item of this.pool) {
      if (!item.inUse && item.width === width && item.height === height) {
        item.inUse = true;
        item.lastUsed = now;
        item.ctx.clearRect(0, 0, width, height);
        return { canvas: item.canvas, ctx: item.ctx };
      }
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (this.pool.length < this.maxSize) {
      this.pool.push({
        canvas,
        ctx,
        width,
        height,
        inUse: true,
        lastUsed: now
      });
    }
    return { canvas, ctx };
  }
  /**
   * Release a canvas back to the pool
   * Call this when done with an effect result
   */
  release(canvas) {
    const item = this.pool.find((p) => p.canvas === canvas);
    if (item) {
      item.inUse = false;
      item.lastUsed = Date.now();
    }
  }
  /**
   * Clean up old unused canvases to free memory
   */
  cleanup() {
    const now = Date.now();
    this.pool = this.pool.filter((item) => {
      if (!item.inUse && now - item.lastUsed > this.maxAge) {
        return false;
      }
      return true;
    });
  }
  /**
   * Clear all pooled canvases
   */
  clear() {
    this.pool = [];
  }
  /**
   * Get pool statistics
   */
  getStats() {
    const inUse = this.pool.filter((p) => p.inUse).length;
    return {
      total: this.pool.length,
      inUse,
      available: this.pool.length - inUse
    };
  }
}
const canvasPool = new CanvasPool();
const effectRenderers = /* @__PURE__ */ new Map();
function registerEffectRenderer(effectKey, renderer) {
  effectRenderers.set(effectKey, renderer);
}
function evaluateEffectParameters(effect, frame) {
  const evaluated = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    const animatableProp = param;
    evaluated[key] = interpolateProperty(animatableProp, frame);
  }
  return evaluated;
}
function processEffectStack(effects, inputCanvas, frame) {
  const workCanvas = document.createElement("canvas");
  workCanvas.width = inputCanvas.width;
  workCanvas.height = inputCanvas.height;
  const workCtx = workCanvas.getContext("2d");
  workCtx.drawImage(inputCanvas, 0, 0);
  let current = {
    canvas: workCanvas,
    ctx: workCtx
  };
  for (const effect of effects) {
    if (!effect.enabled) {
      continue;
    }
    const renderer = effectRenderers.get(effect.effectKey);
    if (!renderer) {
      renderLogger.warn(`No renderer registered for effect: ${effect.effectKey}`);
      continue;
    }
    const params = evaluateEffectParameters(effect, frame);
    try {
      current = renderer(current, params);
    } catch (error) {
      renderLogger.error(`Error applying effect ${effect.name}:`, error);
    }
  }
  return current;
}
function createMatchingCanvas(source) {
  return canvasPool.acquire(source.width, source.height);
}
function hasEnabledEffects(effects) {
  return effects.some((e) => e.enabled);
}

function renderMaskPath(ctx, path) {
  if (path.vertices.length < 2) return;
  ctx.beginPath();
  const vertices = path.vertices;
  const n = vertices.length;
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 0; i < n; i++) {
    const current = vertices[i];
    const next = vertices[(i + 1) % n];
    if (!path.closed && i === n - 1) break;
    const cp1x = current.x + current.outTangentX;
    const cp1y = current.y + current.outTangentY;
    const cp2x = next.x + next.inTangentX;
    const cp2y = next.y + next.inTangentY;
    if (cp1x === current.x && cp1y === current.y && cp2x === next.x && cp2y === next.y) {
      ctx.lineTo(next.x, next.y);
    } else {
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
    }
  }
  if (path.closed) {
    ctx.closePath();
  }
}
function calculateVertexNormal(prev, curr, next) {
  let inDx, inDy;
  if (curr.inTangentX || curr.inTangentY) {
    inDx = -curr.inTangentX;
    inDy = -curr.inTangentY;
  } else {
    inDx = curr.x - prev.x;
    inDy = curr.y - prev.y;
  }
  let outDx, outDy;
  if (curr.outTangentX || curr.outTangentY) {
    outDx = curr.outTangentX;
    outDy = curr.outTangentY;
  } else {
    outDx = next.x - curr.x;
    outDy = next.y - curr.y;
  }
  const inLen = Math.sqrt(inDx * inDx + inDy * inDy);
  if (inLen > 0) {
    inDx /= inLen;
    inDy /= inLen;
  }
  const outLen = Math.sqrt(outDx * outDx + outDy * outDy);
  if (outLen > 0) {
    outDx /= outLen;
    outDy /= outLen;
  }
  const inNx = -inDy;
  const inNy = inDx;
  const outNx = -outDy;
  const outNy = outDx;
  let nx = (inNx + outNx) / 2;
  let ny = (inNy + outNy) / 2;
  const nLen = Math.sqrt(nx * nx + ny * ny);
  if (nLen > 0) {
    nx /= nLen;
    ny /= nLen;
  } else {
    nx = inNx;
    ny = inNy;
  }
  const dot = inNx * outNx + inNy * outNy;
  const miterFactor = 1 / Math.max(0.5, (1 + dot) / 2);
  return {
    nx: nx * Math.min(miterFactor, 2),
    ny: ny * Math.min(miterFactor, 2)
  };
}
function expandMaskPath(path, expansion) {
  if (expansion === 0) return path;
  const vertices = path.vertices;
  if (vertices.length < 2) return path;
  const expandedVertices = [];
  for (let i = 0; i < vertices.length; i++) {
    const prev = vertices[(i - 1 + vertices.length) % vertices.length];
    const curr = vertices[i];
    const next = vertices[(i + 1) % vertices.length];
    const effectivePrev = !path.closed && i === 0 ? curr : prev;
    const effectiveNext = !path.closed && i === vertices.length - 1 ? curr : next;
    const { nx, ny } = calculateVertexNormal(effectivePrev, curr, effectiveNext);
    const offsetX = nx * expansion;
    const offsetY = ny * expansion;
    const handleScale = 1 + expansion / 100;
    expandedVertices.push({
      x: curr.x + offsetX,
      y: curr.y + offsetY,
      // Scale handles to maintain curve shape
      inTangentX: curr.inTangentX * handleScale,
      inTangentY: curr.inTangentY * handleScale,
      outTangentX: curr.outTangentX * handleScale,
      outTangentY: curr.outTangentY * handleScale
    });
  }
  return { ...path, vertices: expandedVertices };
}
function calculateMaskMotion(currentPath, previousPath) {
  if (!previousPath || currentPath.vertices.length !== previousPath.vertices.length) {
    return currentPath.vertices.map(() => ({
      dx: 0,
      dy: 0,
      magnitude: 0,
      angle: 0
    }));
  }
  return currentPath.vertices.map((curr, i) => {
    const prev = previousPath.vertices[i];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    return { dx, dy, magnitude, angle };
  });
}
function applyMotionAwareFeather(canvas, baseFeather, motionVectors, motionScale = 1) {
  const width = canvas.width;
  const height = canvas.height;
  let avgDx = 0;
  let avgDy = 0;
  let avgMagnitude = 0;
  for (const motion of motionVectors) {
    avgDx += motion.dx;
    avgDy += motion.dy;
    avgMagnitude += motion.magnitude;
  }
  const count = motionVectors.length || 1;
  avgDx /= count;
  avgDy /= count;
  avgMagnitude /= count;
  if (avgMagnitude < 0.5) {
    if (baseFeather > 0) {
      const ctx2 = canvas.getContext("2d");
      const blurCanvas = document.createElement("canvas");
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext("2d");
      blurCtx.filter = `blur(${baseFeather}px)`;
      blurCtx.drawImage(canvas, 0, 0);
      ctx2.clearRect(0, 0, width, height);
      ctx2.drawImage(blurCanvas, 0, 0);
    }
    return canvas;
  }
  const motionFeather = avgMagnitude * motionScale;
  const len = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
  const normDx = len > 0 ? avgDx / len : 0;
  const normDy = len > 0 ? avgDy / len : 0;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = width;
  baseCanvas.height = height;
  const baseCtx = baseCanvas.getContext("2d");
  if (baseFeather > 0) {
    baseCtx.filter = `blur(${baseFeather}px)`;
  }
  baseCtx.drawImage(canvas, 0, 0);
  const steps = Math.max(3, Math.min(15, Math.ceil(motionFeather / 2)));
  resultCtx.globalAlpha = 1 / steps;
  for (let i = 0; i < steps; i++) {
    const t = i / (steps - 1) - 0.5;
    const offsetX = normDx * motionFeather * t;
    const offsetY = normDy * motionFeather * t;
    resultCtx.drawImage(baseCanvas, offsetX, offsetY);
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, width, height);
  ctx.globalAlpha = 1;
  ctx.drawImage(resultCanvas, 0, 0);
  return canvas;
}
const previousPathCache = /* @__PURE__ */ new Map();
function getPreviousPath(maskId, currentFrame) {
  const cached = previousPathCache.get(maskId);
  if (cached && cached.frame === currentFrame - 1) {
    return cached.path;
  }
  return null;
}
function cachePath(maskId, frame, path) {
  previousPathCache.set(maskId, { frame, path });
}
function renderMask(mask, width, height, frame) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);
  if (!mask.enabled) return canvas;
  const path = interpolateProperty(mask.path, frame);
  const expansion = interpolateProperty(mask.expansion, frame);
  const opacity = interpolateProperty(mask.opacity, frame);
  const feather = interpolateProperty(mask.feather, frame);
  const expandedPath = expandMaskPath(path, expansion);
  ctx.fillStyle = "white";
  renderMaskPath(ctx, expandedPath);
  ctx.fill();
  if (opacity < 100) {
    const opacityFactor = opacity / 100;
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = Math.round(imageData.data[i] * opacityFactor);
    }
    ctx.putImageData(imageData, 0, 0);
  }
  const previousPath = getPreviousPath(mask.id, frame);
  const motionVectors = calculateMaskMotion(path, previousPath);
  cachePath(mask.id, frame, path);
  const avgMotion = motionVectors.reduce((sum, v) => sum + v.magnitude, 0) / motionVectors.length;
  if (feather > 0 || avgMotion > 1) {
    applyMotionAwareFeather(canvas, feather, motionVectors, 0.5);
  }
  if (mask.inverted) {
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = 255 - imageData.data[i];
      imageData.data[i + 1] = 255 - imageData.data[i + 1];
      imageData.data[i + 2] = 255 - imageData.data[i + 2];
    }
    ctx.putImageData(imageData, 0, 0);
  }
  return canvas;
}
function combineMasks(masks, width, height, frame) {
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const enabledMasks = masks.filter((m) => m.enabled && m.mode !== "none");
  if (enabledMasks.length === 0) {
    resultCtx.fillStyle = "white";
    resultCtx.fillRect(0, 0, width, height);
    return resultCanvas;
  }
  resultCtx.fillStyle = "black";
  resultCtx.fillRect(0, 0, width, height);
  const resultData = resultCtx.getImageData(0, 0, width, height);
  const result = resultData.data;
  for (const mask of enabledMasks) {
    const maskCanvas = renderMask(mask, width, height, frame);
    const maskCtx = maskCanvas.getContext("2d");
    const maskData = maskCtx.getImageData(0, 0, width, height);
    const maskPixels = maskData.data;
    for (let i = 0; i < result.length; i += 4) {
      const maskValue = maskPixels[i];
      switch (mask.mode) {
        case "add":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "subtract":
          result[i] = Math.max(0, result[i] - maskValue);
          result[i + 1] = Math.max(0, result[i + 1] - maskValue);
          result[i + 2] = Math.max(0, result[i + 2] - maskValue);
          break;
        case "intersect":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "lighten":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "darken":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "difference":
          result[i] = Math.abs(result[i] - maskValue);
          result[i + 1] = Math.abs(result[i + 1] - maskValue);
          result[i + 2] = Math.abs(result[i + 2] - maskValue);
          break;
      }
    }
  }
  resultCtx.putImageData(resultData, 0, 0);
  return resultCanvas;
}
function applyTrackMatte(layerCanvas, matteCanvas, matteType) {
  if (matteType === "none") return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const matteScaled = document.createElement("canvas");
  matteScaled.width = width;
  matteScaled.height = height;
  const matteScaledCtx = matteScaled.getContext("2d");
  matteScaledCtx.drawImage(matteCanvas, 0, 0, width, height);
  const matteData = matteScaledCtx.getImageData(0, 0, width, height);
  const matte = matteData.data;
  for (let i = 0; i < layer.length; i += 4) {
    let matteValue;
    switch (matteType) {
      case "alpha":
        matteValue = matte[i + 3] / 255;
        break;
      case "alpha_inverted":
        matteValue = 1 - matte[i + 3] / 255;
        break;
      case "luma":
        matteValue = (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      case "luma_inverted":
        matteValue = 1 - (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      default:
        matteValue = 1;
    }
    layer[i + 3] = Math.round(layer[i + 3] * matteValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}
function applyMasksToLayer(layerCanvas, masks, frame) {
  if (!masks || masks.length === 0) return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const combinedMask = combineMasks(masks, width, height, frame);
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const maskCtx = combinedMask.getContext("2d");
  const maskData = maskCtx.getImageData(0, 0, width, height);
  const mask = maskData.data;
  for (let i = 0; i < layer.length; i += 4) {
    const maskValue = mask[i] / 255;
    layer[i + 3] = Math.round(layer[i + 3] * maskValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}

class BaseLayer {
  /** Unique layer identifier */
  id;
  /** Layer type */
  type;
  /** The Three.js group containing this layer's content */
  group;
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /** Keyframe evaluator for animated properties */
  evaluator;
  /** Layer visibility */
  visible;
  /** Layer locked state */
  locked;
  /** In point (start frame) */
  inPoint;
  /** Out point (end frame) */
  outPoint;
  /** Layer opacity (0-100) */
  opacity;
  /** Layer transform */
  transform;
  /** 3D layer flag */
  threeD;
  /** Blend mode */
  blendMode;
  /** Parent layer ID (for parenting hierarchy) */
  parentId;
  /** Reference to parent layer (set by LayerManager) */
  parentLayer = null;
  /** Driven values override (from property drivers/expressions) */
  drivenValues = /* @__PURE__ */ new Map();
  /** Audio reactive values (from audio analysis mapping) */
  audioReactiveValues = /* @__PURE__ */ new Map();
  /** Effects stack for this layer */
  effects = [];
  /** Source canvas for effect processing (lazy initialized) */
  effectSourceCanvas = null;
  /** Flag to track if effects need processing */
  effectsDirty = false;
  // ============================================================================
  // MASK & MATTE SYSTEM
  // ============================================================================
  /** Masks applied to this layer (vector cutouts) */
  masks = [];
  /** Track matte type (uses another layer as alpha/luma source) */
  trackMatteType = "none";
  /** ID of the layer used as track matte source */
  trackMatteLayerId = null;
  /** ID of composition containing matte layer (for cross-comp mattes) */
  trackMatteCompositionId = null;
  /** Canvas of track matte layer (set externally by LayerManager) */
  trackMatteCanvas = null;
  /** Preserve transparency - only paint on existing pixels */
  preserveTransparency = false;
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /** Motion path line visualization */
  motionPath = null;
  /** Motion path points (frame positions) */
  motionPathPoints = [];
  /** Whether motion path is visible */
  showMotionPath = false;
  /** Motion path keyframe markers */
  motionPathMarkers = null;
  /** 3D axis gizmo at anchor point */
  axisGizmo = null;
  /** Whether 3D axis gizmo is visible */
  showAxisGizmo = false;
  constructor(layerData) {
    this.id = layerData.id;
    this.type = layerData.type;
    this.group = new Group();
    this.group.name = `layer_${this.id}`;
    this.group.userData.layerId = this.id;
    this.group.userData.layerType = this.type;
    this.evaluator = new KeyframeEvaluator();
    this.visible = layerData.visible;
    this.locked = layerData.locked;
    this.inPoint = layerData.inPoint;
    this.outPoint = layerData.outPoint;
    this.opacity = layerData.opacity;
    this.transform = layerData.transform;
    this.threeD = layerData.threeD ?? false;
    this.blendMode = layerData.blendMode ?? "normal";
    this.parentId = layerData.parentId ?? null;
    this.effects = layerData.effects ?? [];
    this.masks = layerData.masks ?? [];
    this.trackMatteType = layerData.trackMatteType ?? "none";
    this.trackMatteLayerId = layerData.trackMatteLayerId ?? null;
    this.trackMatteCompositionId = layerData.trackMatteCompositionId ?? null;
    this.preserveTransparency = layerData.preserveTransparency ?? false;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    if (this.blendMode !== "normal") {
      this.applyBlendMode(this.blendMode);
    }
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(frame) {
    const inRange = frame >= this.inPoint && frame <= this.outPoint;
    this.group.visible = this.visible && inRange;
    if (!this.group.visible) {
      return;
    }
    let baseOpacity = this.evaluator.evaluate(this.opacity, frame);
    baseOpacity = this.getDrivenOrBase("opacity", baseOpacity);
    const opacityValue = this.applyAudioModulation(baseOpacity, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(opacityValue);
    this.evaluateTransform(frame);
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(frame) {
    const basePosition = this.evaluator.evaluate(this.transform.position, frame);
    let posX = this.getDrivenOrBase("transform.position.x", basePosition.x);
    let posY = this.getDrivenOrBase("transform.position.y", basePosition.y);
    const posZ = this.getDrivenOrBase("transform.position.z", basePosition.z ?? 0);
    posX = this.applyAudioModulation(posX, "layer.x", "add");
    posY = this.applyAudioModulation(posY, "layer.y", "add");
    const position = { x: posX, y: posY, z: posZ };
    const baseScale = this.evaluator.evaluate(this.transform.scale, frame);
    let scaleX = this.getDrivenOrBase("transform.scale.x", baseScale.x ?? 100);
    let scaleY = this.getDrivenOrBase("transform.scale.y", baseScale.y ?? 100);
    const scaleZ = this.getDrivenOrBase("transform.scale.z", baseScale.z ?? 100);
    const audioScaleMod = this.getAudioReactiveValue("layer.scale");
    if (audioScaleMod !== 0) {
      const scaleFactor = 0.5 + audioScaleMod;
      scaleX *= scaleFactor;
      scaleY *= scaleFactor;
    }
    const scale = { x: scaleX, y: scaleY, z: scaleZ };
    const baseAnchor = this.evaluator.evaluate(this.transform.anchorPoint, frame);
    const anchorPoint = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", baseAnchor.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", baseAnchor.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", baseAnchor.z ?? 0)
    };
    let rotation = 0;
    let rotationX = 0;
    let rotationY = 0;
    if (this.threeD) {
      const baseRotX = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, frame) : 0;
      rotationX = this.getDrivenOrBase("transform.rotationX", baseRotX);
      const baseRotY = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, frame) : 0;
      rotationY = this.getDrivenOrBase("transform.rotationY", baseRotY);
      const baseRotZ = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, frame) : 0;
      rotation = this.getDrivenOrBase("transform.rotationZ", baseRotZ);
    } else {
      const baseRotation = this.evaluator.evaluate(this.transform.rotation, frame);
      rotation = this.getDrivenOrBase("transform.rotation", baseRotation);
    }
    const audioRotMod = this.getAudioReactiveValue("layer.rotation");
    if (audioRotMod !== 0) {
      rotation += audioRotMod * 360;
    }
    this.applyTransform({
      position: {
        x: position.x,
        y: position.y,
        z: position.z
      },
      rotation: {
        x: rotationX,
        y: rotationY,
        z: rotation
      },
      scale: {
        x: scale.x / 100,
        y: scale.y / 100,
        z: scale.z / 100
      },
      anchorPoint: {
        x: anchorPoint.x,
        y: anchorPoint.y,
        z: anchorPoint.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(transform) {
    const { position, rotation, scale, anchorPoint } = transform;
    this.group.position.set(
      position.x - anchorPoint.x,
      -(position.y - anchorPoint.y),
      // Negate for screen coords
      position.z - anchorPoint.z
    );
    this.group.rotation.set(
      MathUtils.degToRad(rotation.x),
      MathUtils.degToRad(rotation.y),
      MathUtils.degToRad(-rotation.z)
    );
    this.group.scale.set(scale.x, scale.y, scale.z);
    this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        if ("opacity" in material) {
          material.opacity = normalizedOpacity;
          material.transparent = normalizedOpacity < 1;
          material.needsUpdate = true;
        }
      }
    });
  }
  // ============================================================================
  // EVALUATED STATE APPLICATION (NEW - SINGLE SOURCE OF TRUTH)
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer visual state.
   * All values are already computed - layers only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * @param state - Pre-evaluated layer state from MotionEngine
   */
  applyEvaluatedState(state) {
    this.group.visible = state.visible;
    if (!state.visible) {
      return;
    }
    const opacity = this.getDrivenOrBase("opacity", state.opacity);
    this.applyOpacity(opacity);
    const transform = state.transform;
    this.applyTransform({
      position: {
        x: this.getDrivenOrBase("transform.position.x", transform.position.x),
        y: this.getDrivenOrBase("transform.position.y", transform.position.y),
        z: this.getDrivenOrBase("transform.position.z", transform.position.z ?? 0)
      },
      rotation: {
        x: this.getDrivenOrBase("transform.rotationX", transform.rotationX ?? 0),
        y: this.getDrivenOrBase("transform.rotationY", transform.rotationY ?? 0),
        z: this.getDrivenOrBase("transform.rotation", transform.rotation)
      },
      scale: {
        x: this.getDrivenOrBase("transform.scale.x", transform.scale.x ?? 100) / 100,
        y: this.getDrivenOrBase("transform.scale.y", transform.scale.y ?? 100) / 100,
        z: this.getDrivenOrBase("transform.scale.z", transform.scale.z ?? 100) / 100
      },
      anchorPoint: {
        x: this.getDrivenOrBase("transform.anchorPoint.x", transform.anchorPoint.x),
        y: this.getDrivenOrBase("transform.anchorPoint.y", transform.anchorPoint.y),
        z: this.getDrivenOrBase("transform.anchorPoint.z", transform.anchorPoint.z ?? 0)
      }
    });
    this.onApplyEvaluatedState(state);
  }
  /**
   * Override in subclasses for type-specific state application
   * Default implementation calls legacy onEvaluateFrame for compatibility
   */
  onApplyEvaluatedState(state) {
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(properties) {
    if (properties.visible !== void 0) {
      this.visible = properties.visible;
      this.group.visible = this.visible;
    }
    if (properties.locked !== void 0) {
      this.locked = properties.locked;
    }
    if (properties.inPoint !== void 0) {
      this.inPoint = properties.inPoint;
    }
    if (properties.outPoint !== void 0) {
      this.outPoint = properties.outPoint;
    }
    if (properties.opacity !== void 0) {
      this.opacity = properties.opacity;
    }
    if (properties.transform !== void 0) {
      this.transform = properties.transform;
    }
    if (properties.threeD !== void 0) {
      this.threeD = properties.threeD;
    }
    if (properties.blendMode !== void 0) {
      this.blendMode = properties.blendMode;
      this.applyBlendMode(this.blendMode);
    }
    if (properties.effects !== void 0) {
      this.setEffects(properties.effects);
    }
    if (properties.masks !== void 0) {
      this.masks = properties.masks;
    }
    if (properties.trackMatteType !== void 0) {
      this.trackMatteType = properties.trackMatteType;
    }
    if (properties.trackMatteLayerId !== void 0) {
      this.trackMatteLayerId = properties.trackMatteLayerId;
      this.trackMatteCanvas = null;
    }
    if (properties.trackMatteCompositionId !== void 0) {
      this.trackMatteCompositionId = properties.trackMatteCompositionId;
      this.trackMatteCanvas = null;
    }
    if (properties.preserveTransparency !== void 0) {
      this.preserveTransparency = properties.preserveTransparency;
    }
    this.onUpdate(properties);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(visible) {
    this.visible = visible;
    this.group.visible = visible;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(values) {
    this.drivenValues = values;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(propertyPath, baseValue) {
    return this.drivenValues.get(propertyPath) ?? baseValue;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(values) {
    this.audioReactiveValues = values;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(target) {
    return this.audioReactiveValues.get(target) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(baseValue, target, mode = "add", range = {}) {
    const audioValue = this.getAudioReactiveValue(target);
    if (audioValue === 0) return baseValue;
    let result;
    switch (mode) {
      case "multiply":
        result = baseValue * (0.5 + audioValue);
        break;
      case "replace":
        result = audioValue;
        break;
      case "add":
      default:
        result = baseValue + audioValue * 100;
        break;
    }
    if (range.min !== void 0) result = Math.max(range.min, result);
    if (range.max !== void 0) result = Math.min(range.max, result);
    return result;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(effects) {
    this.effects = effects;
    this.effectsDirty = true;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return hasEnabledEffects(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(frame) {
    if (!this.hasEnabledEffects()) {
      return null;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    try {
      const result = processEffectStack(this.effects, sourceCanvas, frame);
      return result.canvas;
    } catch (error) {
      layerLogger.error(`Error processing effects for layer ${this.id}:`, error);
      return null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(_processedCanvas) {
  }
  // ============================================================================
  // MASK PROCESSING
  // ============================================================================
  /**
   * Check if this layer has any enabled masks
   */
  hasMasks() {
    return this.masks.length > 0 && this.masks.some((m) => m.enabled);
  }
  /**
   * Check if this layer has a track matte assigned
   */
  hasTrackMatte() {
    return this.trackMatteType !== "none" && this.trackMatteCanvas !== null;
  }
  /**
   * Set the track matte canvas (called by LayerManager when compositing)
   * @param canvas - The rendered canvas of the matte layer
   */
  setTrackMatteCanvas(canvas) {
    this.trackMatteCanvas = canvas;
  }
  /**
   * Get the track matte layer ID
   */
  getTrackMatteLayerId() {
    return this.trackMatteLayerId;
  }
  /**
   * Get the track matte composition ID (for cross-comp mattes)
   * Returns null if matte is in the same composition
   */
  getTrackMatteCompositionId() {
    return this.trackMatteCompositionId;
  }
  /**
   * Check if this layer uses a cross-composition track matte
   */
  hasCrossCompMatte() {
    return this.trackMatteCompositionId !== null && this.trackMatteLayerId !== null;
  }
  /**
   * Get the track matte type
   */
  getTrackMatteType() {
    return this.trackMatteType;
  }
  /**
   * Update masks
   */
  setMasks(masks) {
    this.masks = masks;
  }
  /**
   * Process masks and track matte on a canvas
   * @param canvas - Source canvas to apply masks to
   * @param frame - Current frame for animated masks
   * @returns Processed canvas with masks applied
   */
  processMasksAndMattes(canvas, frame) {
    let result = canvas;
    if (this.hasMasks()) {
      result = applyMasksToLayer(result, this.masks, frame);
    }
    if (this.hasTrackMatte() && this.trackMatteCanvas) {
      result = applyTrackMatte(result, this.trackMatteCanvas, this.trackMatteType);
    }
    return result;
  }
  /**
   * Called after frame evaluation to apply effects AND masks
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(frame) {
    const hasEffects = this.hasEnabledEffects();
    const hasMasks = this.hasMasks();
    const hasTrackMatte = this.hasTrackMatte();
    if (!hasEffects && !hasMasks && !hasTrackMatte) {
      return;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return;
    }
    let processedCanvas = sourceCanvas;
    if (hasEffects) {
      const effectResult = this.processEffects(frame);
      if (effectResult) {
        processedCanvas = effectResult;
      }
    }
    if (hasMasks || hasTrackMatte) {
      processedCanvas = this.processMasksAndMattes(processedCanvas, frame);
    }
    if (processedCanvas !== sourceCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Apply pre-evaluated effects from MotionEngine
   * Uses the evaluated effect parameters rather than re-evaluating
   */
  applyEvaluatedEffects(evaluatedEffects) {
    if (evaluatedEffects.length === 0 || !this.hasEnabledEffects()) {
      return;
    }
    const processedCanvas = this.processEffectsWithEvaluated(evaluatedEffects);
    if (processedCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Process effects using pre-evaluated parameters
   */
  processEffectsWithEvaluated(evaluatedEffects) {
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    let currentCanvas = sourceCanvas;
    for (const evalEffect of evaluatedEffects) {
      if (!evalEffect.enabled) continue;
      const effect = this.effects.find((e) => e.id === evalEffect.id);
      if (!effect) continue;
      const result = this.processEffectWithParams(effect, currentCanvas, evalEffect.parameters);
      if (result) {
        currentCanvas = result;
      }
    }
    return currentCanvas !== sourceCanvas ? currentCanvas : null;
  }
  /**
   * Process a single effect with pre-evaluated parameters
   */
  processEffectWithParams(effect, sourceCanvas, params) {
    return null;
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(parent) {
    if (this.parentLayer) {
      this.parentLayer.getObject().remove(this.group);
    }
    this.parentLayer = parent;
    if (parent) {
      parent.getObject().add(this.group);
    }
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(mode) {
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        this.setMaterialBlendMode(material, mode);
        material.needsUpdate = true;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(material, mode) {
    material.blending = NormalBlending;
    material.blendEquation = AddEquation;
    material.blendSrc = SrcAlphaFactor;
    material.blendDst = OneMinusSrcAlphaFactor;
    material.blendEquationAlpha = AddEquation;
    material.blendSrcAlpha = OneFactor;
    material.blendDstAlpha = OneMinusSrcAlphaFactor;
    switch (mode) {
      case "normal":
        material.blending = NormalBlending;
        break;
      case "add":
        material.blending = AdditiveBlending;
        break;
      case "multiply":
        material.blending = MultiplyBlending;
        break;
      case "screen":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "overlay":
        material.blending = MultiplyBlending;
        break;
      case "soft-light":
        material.blending = NormalBlending;
        break;
      case "hard-light":
        material.blending = MultiplyBlending;
        break;
      case "color-dodge":
        material.blending = AdditiveBlending;
        break;
      case "color-burn":
        material.blending = SubtractiveBlending;
        break;
      case "difference":
        material.blending = CustomBlending;
        material.blendEquation = SubtractEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "exclusion":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneMinusDstColorFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "darken":
        material.blending = CustomBlending;
        material.blendEquation = MinEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "lighten":
        material.blending = CustomBlending;
        material.blendEquation = MaxEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      default:
        material.blending = NormalBlending;
        break;
    }
  }
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /**
   * Compute motion path from position keyframes
   * Samples position at each frame from inPoint to outPoint
   */
  computeMotionPath(startFrame, endFrame) {
    const start = startFrame ?? this.inPoint;
    const end = endFrame ?? this.outPoint;
    this.motionPathPoints = [];
    for (let frame = start; frame <= end; frame++) {
      const pos = this.evaluator.evaluate(this.transform.position, frame);
      this.motionPathPoints.push(new Vector3(pos.x, -pos.y, pos.z ?? 0));
    }
    this.rebuildMotionPath();
  }
  /**
   * Rebuild the motion path line from computed points
   */
  rebuildMotionPath() {
    if (this.motionPath) {
      this.group.remove(this.motionPath);
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.group.remove(this.motionPathMarkers);
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.motionPathPoints.length < 2) return;
    const curve = new CatmullRomCurve3(this.motionPathPoints);
    const curvePoints = curve.getPoints(this.motionPathPoints.length * 10);
    const geometry = new BufferGeometry().setFromPoints(curvePoints);
    const material = new LineBasicMaterial({
      color: 4886745,
      // Blue motion path
      linewidth: 2,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    this.motionPath = new Line(geometry, material);
    this.motionPath.name = `motion_path_${this.id}`;
    this.motionPath.renderOrder = 998;
    this.motionPath.visible = this.showMotionPath;
    this.motionPath.matrixAutoUpdate = false;
    this.motionPath.matrix.identity();
    this.group.add(this.motionPath);
    this.createMotionPathMarkers();
  }
  /**
   * Create markers at keyframe positions on the motion path
   */
  createMotionPathMarkers() {
    this.motionPathMarkers = new Group();
    this.motionPathMarkers.name = `motion_path_markers_${this.id}`;
    this.motionPathMarkers.renderOrder = 999;
    const positionKeyframes = this.transform.position.keyframes;
    if (!positionKeyframes || positionKeyframes.length === 0) return;
    const markerGeometry = new OctahedronGeometry(5, 0);
    const markerMaterial = new MeshBasicMaterial({
      color: 16763904,
      // Yellow keyframe markers
      transparent: true,
      opacity: 0.9,
      depthTest: false
    });
    for (const kf of positionKeyframes) {
      const pos = kf.value;
      const marker = new Mesh(markerGeometry.clone(), markerMaterial.clone());
      marker.position.set(pos.x, -pos.y, pos.z ?? 0);
      marker.userData.frame = kf.frame;
      this.motionPathMarkers.add(marker);
    }
    this.motionPathMarkers.visible = this.showMotionPath;
    this.group.add(this.motionPathMarkers);
  }
  /**
   * Set motion path visibility
   */
  setMotionPathVisible(visible) {
    this.showMotionPath = visible;
    if (visible && this.motionPathPoints.length === 0) {
      this.computeMotionPath();
    }
    if (this.motionPath) {
      this.motionPath.visible = visible;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.visible = visible;
    }
  }
  /**
   * Check if motion path is visible
   */
  isMotionPathVisible() {
    return this.showMotionPath;
  }
  /**
   * Check if layer has position animation
   */
  hasPositionAnimation() {
    return (this.transform.position.keyframes?.length ?? 0) > 0;
  }
  // ============================================================================
  // 3D AXIS GIZMO
  // ============================================================================
  /**
   * Create 3D axis gizmo at anchor point
   */
  createAxisGizmo(size = 50) {
    if (this.axisGizmo) {
      this.group.remove(this.axisGizmo);
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.axisGizmo = new Group();
    this.axisGizmo.name = `axis_gizmo_${this.id}`;
    this.axisGizmo.renderOrder = 1e3;
    const xGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(size, 0, 0)
    ]);
    const xMat = new LineBasicMaterial({
      color: 16711680,
      linewidth: 2,
      depthTest: false
    });
    const xLine = new Line(xGeom, xMat);
    this.axisGizmo.add(xLine);
    const yGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(0, size, 0)
    ]);
    const yMat = new LineBasicMaterial({
      color: 65280,
      linewidth: 2,
      depthTest: false
    });
    const yLine = new Line(yGeom, yMat);
    this.axisGizmo.add(yLine);
    if (this.threeD) {
      const zGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, size)
      ]);
      const zMat = new LineBasicMaterial({
        color: 35071,
        linewidth: 2,
        depthTest: false
      });
      const zLine = new Line(zGeom, zMat);
      this.axisGizmo.add(zLine);
    }
    this.addAxisLabels(size);
    const anchor = this.transform.anchorPoint.value;
    this.axisGizmo.position.set(-anchor.x, anchor.y, -(anchor.z ?? 0));
    this.axisGizmo.visible = this.showAxisGizmo;
    this.group.add(this.axisGizmo);
  }
  /**
   * Add axis labels (X, Y, Z)
   */
  addAxisLabels(size) {
    if (!this.axisGizmo) return;
    const sphereGeom = new SphereGeometry(3, 8, 8);
    const xSphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 16711680, depthTest: false })
    );
    xSphere.position.set(size + 5, 0, 0);
    this.axisGizmo.add(xSphere);
    const ySphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 65280, depthTest: false })
    );
    ySphere.position.set(0, size + 5, 0);
    this.axisGizmo.add(ySphere);
    if (this.threeD) {
      const zSphere = new Mesh(
        sphereGeom.clone(),
        new MeshBasicMaterial({ color: 35071, depthTest: false })
      );
      zSphere.position.set(0, 0, size + 5);
      this.axisGizmo.add(zSphere);
    }
  }
  /**
   * Set axis gizmo visibility
   */
  setAxisGizmoVisible(visible) {
    this.showAxisGizmo = visible;
    if (visible && !this.axisGizmo) {
      this.createAxisGizmo();
    }
    if (this.axisGizmo) {
      this.axisGizmo.visible = visible;
    }
  }
  /**
   * Check if axis gizmo is visible
   */
  isAxisGizmoVisible() {
    return this.showAxisGizmo;
  }
  /**
   * Update axis gizmo position to match anchor point
   */
  updateAxisGizmoPosition() {
    if (!this.axisGizmo) return;
    const anchor = this.transform.anchorPoint.value;
    this.axisGizmo.position.set(-anchor.x, anchor.y, -(anchor.z ?? 0));
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const box = new Box3();
    box.setFromObject(this.group);
    return box;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const box = this.getBoundingBox();
    const center = new Vector3();
    box.getCenter(center);
    return center;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    if (this.motionPath) {
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.axisGizmo) {
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.group.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry?.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else if (child.material) {
          child.material.dispose();
        }
      }
    });
    this.group.clear();
    this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}

class VideoLayer extends BaseLayer {
  resources;
  // Video elements
  videoElement = null;
  videoTexture = null;
  mesh = null;
  material = null;
  // Video data
  videoData;
  assetRef = null;
  // Metadata (populated after video loads)
  metadata = null;
  // Animation evaluator
  videoEvaluator;
  // Playback state
  lastEvaluatedFrame = -1;
  isPlaying = false;
  // Callbacks for composition auto-resize
  onMetadataLoaded;
  // Composition FPS for time calculation
  compositionFPS = 30;
  // Canvas for effect processing
  effectCanvas = null;
  effectCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.videoEvaluator = new KeyframeEvaluator();
    this.videoData = this.extractVideoData(layerData);
    this.createPlaceholderMesh();
    if (this.videoData.assetId) {
      this.loadVideo(this.videoData.assetId);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      loop: data?.loop ?? false,
      pingPong: data?.pingPong ?? false,
      startTime: data?.startTime ?? 0,
      endTime: data?.endTime,
      speed: data?.speed ?? 1,
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      frameBlending: data?.frameBlending ?? "none",
      audioEnabled: data?.audioEnabled ?? true,
      audioLevel: data?.audioLevel ?? 100,
      posterFrame: data?.posterFrame ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 3355443,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `video_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(assetId) {
    const asset = this.resources.getAsset(assetId);
    if (!asset || asset.type !== "video") {
      layerLogger.warn(`VideoLayer: Asset ${assetId} not found or not a video`);
      return;
    }
    this.assetRef = asset;
    this.videoData.assetId = assetId;
    this.videoElement = document.createElement("video");
    this.videoElement.crossOrigin = "anonymous";
    this.videoElement.playsInline = true;
    this.videoElement.muted = !this.videoData.audioEnabled;
    this.videoElement.loop = false;
    this.videoElement.preload = "auto";
    if (asset.data) {
      this.videoElement.src = asset.data;
    }
    await this.waitForMetadata();
    this.createVideoTexture();
    this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((resolve, reject) => {
      if (!this.videoElement) {
        reject(new Error("No video element"));
        return;
      }
      const onLoadedMetadata = () => {
        this.extractMetadata();
        cleanup();
        resolve();
      };
      const onError = (e) => {
        cleanup();
        reject(new Error(`Video load error: ${e}`));
      };
      const cleanup = () => {
        this.videoElement?.removeEventListener("loadedmetadata", onLoadedMetadata);
        this.videoElement?.removeEventListener("error", onError);
      };
      this.videoElement.addEventListener("loadedmetadata", onLoadedMetadata);
      this.videoElement.addEventListener("error", onError);
      this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    if (!this.videoElement) return;
    const duration = this.videoElement.duration;
    const width = this.videoElement.videoWidth;
    const height = this.videoElement.videoHeight;
    const fps = this.assetRef?.fps ?? 30;
    const frameCount = Math.ceil(duration * fps);
    this.metadata = {
      duration,
      frameCount,
      fps,
      width,
      height,
      hasAudio: this.hasAudioTrack()
    };
    if (this.assetRef) {
      this.assetRef.duration = duration;
      this.assetRef.frameCount = frameCount;
      this.assetRef.fps = fps;
      this.assetRef.hasAudio = this.metadata.hasAudio;
    }
    this.onMetadataLoaded?.(this.metadata);
    layerLogger.debug(`VideoLayer: Loaded: ${width}x${height}, ${frameCount} frames @ ${fps}fps, ${duration.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return false;
    const audioTracks = this.videoElement.audioTracks;
    if (audioTracks) {
      return audioTracks.length > 0;
    }
    return true;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    if (!this.videoElement || !this.metadata) return;
    this.videoTexture = new VideoTexture(this.videoElement);
    this.videoTexture.minFilter = LinearFilter;
    this.videoTexture.magFilter = LinearFilter;
    this.videoTexture.format = RGBAFormat;
    this.videoTexture.colorSpace = SRGBColorSpace;
    if (this.material) {
      this.material.map = this.videoTexture;
      this.material.color.setHex(16777215);
      this.material.needsUpdate = true;
    }
    this.resizeMesh(this.metadata.width, this.metadata.height);
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(compositionFrame) {
    if (!this.videoElement || !this.metadata) return;
    const videoTime = this.calculateVideoTime(compositionFrame);
    const clampedTime = Math.max(0, Math.min(videoTime, this.videoElement.duration));
    this.videoElement.currentTime = clampedTime;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(compositionFrame) {
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && this.videoData.timeRemap?.animated) {
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, compositionFrame);
    }
    const compFps = this.compositionFPS;
    const compTime = compositionFrame / compFps;
    let videoTime = compTime * this.videoData.speed;
    videoTime += this.videoData.startTime;
    const effectiveDuration = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && effectiveDuration > 0) {
      if (this.videoData.pingPong) {
        const cycles = Math.floor(videoTime / effectiveDuration);
        const phase = videoTime % effectiveDuration;
        videoTime = cycles % 2 === 0 ? phase : effectiveDuration - phase;
      } else {
        videoTime = videoTime % effectiveDuration;
      }
      videoTime += this.videoData.startTime;
    }
    return videoTime;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(level) {
    this.videoData.audioLevel = level;
    if (this.videoElement) {
      this.videoElement.volume = Math.max(0, Math.min(1, level / 100));
    }
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(enabled) {
    this.videoData.audioEnabled = enabled;
    if (this.videoElement) {
      this.videoElement.muted = !enabled;
    }
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.compositionFPS = fps;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(callback) {
    this.onMetadataLoaded = callback;
    if (this.metadata) {
      callback(this.metadata);
    }
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(loop) {
    this.videoData.loop = loop;
  }
  setPingPong(pingPong) {
    this.videoData.pingPong = pingPong;
  }
  setSpeed(speed) {
    this.videoData.speed = speed;
    if (this.videoElement) {
      this.videoElement.playbackRate = speed;
    }
  }
  setStartTime(time) {
    this.videoData.startTime = time;
  }
  setEndTime(time) {
    this.videoData.endTime = time;
  }
  setFrameBlending(mode) {
    this.videoData.frameBlending = mode;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata) {
      return null;
    }
    const width = this.metadata.width;
    const height = this.metadata.height;
    if (!this.effectCanvas || this.effectCanvas.width !== width || this.effectCanvas.height !== height) {
      this.effectCanvas = document.createElement("canvas");
      this.effectCanvas.width = width;
      this.effectCanvas.height = height;
      this.effectCanvasCtx = this.effectCanvas.getContext("2d");
    }
    if (!this.effectCanvasCtx) {
      return null;
    }
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    return this.effectCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    if (!this.material || !this.metadata) return;
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (frame === this.lastEvaluatedFrame) return;
    this.lastEvaluatedFrame = frame;
    this.seekToFrame(frame);
    if (this.videoTexture) {
      this.videoTexture.needsUpdate = true;
    }
    if (this.hasEnabledEffects()) {
      this.evaluateEffects(frame);
    } else if (this.material && this.videoTexture) {
      this.material.map = this.videoTexture;
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.videoElement) {
      const targetTime = props["timeRemap"];
      const clampedTime = Math.max(0, Math.min(targetTime, this.videoElement.duration || targetTime));
      this.videoElement.currentTime = clampedTime;
    }
    if (props["speed"] !== void 0) {
      this.videoData.speed = props["speed"];
    }
    if (props["audioLevel"] !== void 0) {
      this.setAudioLevel(props["audioLevel"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.videoData.assetId) {
        if (data.assetId) {
          this.loadVideo(data.assetId);
        } else {
          this.clearVideo();
        }
      }
      if (data.loop !== void 0) this.setLoop(data.loop);
      if (data.pingPong !== void 0) this.setPingPong(data.pingPong);
      if (data.speed !== void 0) this.setSpeed(data.speed);
      if (data.startTime !== void 0) this.setStartTime(data.startTime);
      if (data.endTime !== void 0) this.setEndTime(data.endTime);
      if (data.frameBlending !== void 0) this.setFrameBlending(data.frameBlending);
      if (data.audioEnabled !== void 0) this.setAudioEnabled(data.audioEnabled);
      if (data.audioLevel !== void 0) this.setAudioLevel(data.audioLevel);
    }
  }
  /**
   * Clear current video
   */
  clearVideo() {
    if (this.videoElement) {
      this.videoElement.pause();
      this.videoElement.src = "";
      this.videoElement = null;
    }
    if (this.videoTexture) {
      this.videoTexture.dispose();
      this.videoTexture = null;
    }
    if (this.material) {
      this.material.map = null;
      this.material.color.setHex(3355443);
    }
    this.metadata = null;
    this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo();
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
  }
}
async function extractVideoMetadata(source) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.preload = "metadata";
    const cleanup = () => {
      video.removeEventListener("loadedmetadata", onLoad);
      video.removeEventListener("error", onError);
      URL.revokeObjectURL(video.src);
    };
    const onLoad = () => {
      const metadata = {
        duration: video.duration,
        frameCount: Math.ceil(video.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: video.videoWidth,
        height: video.videoHeight,
        hasAudio: true
        // Assume true
      };
      cleanup();
      resolve(metadata);
    };
    const onError = () => {
      cleanup();
      reject(new Error("Failed to load video metadata"));
    };
    video.addEventListener("loadedmetadata", onLoad);
    video.addEventListener("error", onError);
    if (typeof source === "string") {
      video.src = source;
    } else {
      video.src = URL.createObjectURL(source);
    }
  });
}
function calculateCompositionFromVideo(metadata, targetFps = 16) {
  const width = Math.round(metadata.width / 8) * 8;
  const height = Math.round(metadata.height / 8) * 8;
  const frameCount = Math.ceil(metadata.duration * targetFps);
  return { width, height, frameCount };
}

const CAMERA_PRESETS = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function createDefaultCamera(id, compWidth, compHeight) {
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  return {
    id,
    name: "Camera 1",
    type: "two-node",
    position: { x: centerX, y: centerY, z: -1500 },
    pointOfInterest: { x: centerX, y: centerY, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: false,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: false
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function createDefaultViewportState() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function createDefaultViewOptions() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: true,
    showLayerHandles: true,
    showSafeZones: false,
    showGrid: false,
    showRulers: true,
    show3DReferenceAxes: true,
    showCompositionBounds: true,
    showFocalPlane: false
  };
}

function createAnimatableProperty(name, value, type = "number", group) {
  return {
    id: `prop_${name}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name,
    type,
    value,
    animated: false,
    keyframes: [],
    group
  };
}
function createDefaultTransform() {
  return {
    position: createAnimatableProperty("position", { x: 0, y: 0 }, "position"),
    anchorPoint: createAnimatableProperty("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: createAnimatableProperty("scale", { x: 100, y: 100 }, "position"),
    rotation: createAnimatableProperty("rotation", 0, "number")
  };
}
function createEmptyProject(width, height) {
  const mainCompId = "main";
  const compositionSettings = {
    width,
    height,
    frameCount: 81,
    fps: 16,
    duration: 81 / 16,
    backgroundColor: "#000000",
    autoResizeToContent: true
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [mainCompId]: {
        id: mainCompId,
        name: "Main Comp",
        settings: compositionSettings,
        layers: [],
        currentFrame: 0,
        isPrecomp: false
      }
    },
    mainCompositionId: mainCompId,
    // Legacy alias
    composition: compositionSettings,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}

function isSplineControlPointPath(path) {
  return path.startsWith("spline.controlPoint.");
}
function createSplineControlPointPath(index, property) {
  return `spline.controlPoint.${index}.${property}`;
}
class PropertyDriverSystem {
  drivers = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  audioAnalysis = null;
  propertyGetter = null;
  constructor() {
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(analysis) {
    this.audioAnalysis = analysis;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(getter) {
    this.propertyGetter = getter;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(driver) {
    if (driver.sourceType === "property" && driver.sourceLayerId && driver.sourceProperty) {
      if (this.wouldCreateCycle(driver)) {
        storeLogger.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency");
        return false;
      }
    }
    this.drivers.set(driver.id, driver);
    this.smoothedValues.set(driver.id, 0);
    return true;
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(newDriver) {
    if (newDriver.sourceType !== "property") return false;
    if (!newDriver.sourceLayerId || !newDriver.sourceProperty) return false;
    const visited = /* @__PURE__ */ new Set();
    const targetKey = `${newDriver.targetLayerId}:${newDriver.targetProperty}`;
    const hasCycle = (layerId, property) => {
      const key = `${layerId}:${property}`;
      if (key === targetKey) return true;
      if (visited.has(key)) return false;
      visited.add(key);
      for (const driver of this.drivers.values()) {
        if (driver.sourceType !== "property") continue;
        if (driver.targetLayerId !== layerId || driver.targetProperty !== property) continue;
        if (!driver.sourceLayerId || !driver.sourceProperty) continue;
        if (hasCycle(driver.sourceLayerId, driver.sourceProperty)) {
          return true;
        }
      }
      return false;
    };
    return hasCycle(newDriver.sourceLayerId, newDriver.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(id) {
    this.drivers.delete(id);
    this.smoothedValues.delete(id);
  }
  /**
   * Update a driver
   */
  updateDriver(id, updates) {
    const driver = this.drivers.get(id);
    if (driver) {
      Object.assign(driver, updates);
    }
  }
  /**
   * Get a driver by ID
   */
  getDriver(id) {
    return this.drivers.get(id);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(layerId) {
    return Array.from(this.drivers.values()).filter((d) => d.targetLayerId === layerId);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(layerId, property) {
    return Array.from(this.drivers.values()).filter(
      (d) => d.targetLayerId === layerId && d.targetProperty === property && d.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(driver, frame, baseValue) {
    if (!driver.enabled) return baseValue;
    let value = this.getSourceValue(driver, frame);
    if (value === null) return baseValue;
    value = this.applyTransforms(driver, value);
    return this.blendValue(baseValue, value, driver.blendMode, driver.blendAmount);
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(driver, frame) {
    switch (driver.sourceType) {
      case "property":
        return this.getPropertySourceValue(driver, frame);
      case "audio":
        return this.getAudioSourceValue(driver, frame);
      case "time":
        return frame;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(driver, frame) {
    if (!this.propertyGetter || !driver.sourceLayerId || !driver.sourceProperty) {
      return null;
    }
    return this.propertyGetter(driver.sourceLayerId, driver.sourceProperty, frame);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(driver, frame) {
    if (!this.audioAnalysis || !driver.audioFeature) {
      return null;
    }
    let value = getFeatureAtFrame(this.audioAnalysis, driver.audioFeature, frame);
    if (driver.audioThreshold !== void 0) {
      if (driver.audioAboveThreshold) {
        value = value > driver.audioThreshold ? value : 0;
      } else {
        value = value >= driver.audioThreshold ? value : 0;
      }
    }
    return value;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(driver, value) {
    for (const transform of driver.transforms) {
      value = this.applyTransform(driver.id, transform, value);
    }
    return value;
  }
  /**
   * Apply a single transform
   */
  applyTransform(driverId, transform, value) {
    switch (transform.type) {
      case "scale":
        return value * (transform.factor ?? 1);
      case "offset":
        return value + (transform.amount ?? 0);
      case "clamp":
        return Math.max(transform.min ?? -Infinity, Math.min(transform.max ?? Infinity, value));
      case "smooth": {
        const prevValue = this.smoothedValues.get(driverId) ?? value;
        const smoothing = transform.smoothing ?? 0.5;
        const smoothed = prevValue * smoothing + value * (1 - smoothing);
        this.smoothedValues.set(driverId, smoothed);
        return smoothed;
      }
      case "invert":
        return 1 - value;
      case "remap": {
        const inMin = transform.inMin ?? 0;
        const inMax = transform.inMax ?? 1;
        const outMin = transform.outMin ?? 0;
        const outMax = transform.outMax ?? 1;
        const normalized = (value - inMin) / (inMax - inMin);
        return outMin + normalized * (outMax - outMin);
      }
      case "threshold":
        return value > (transform.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const freq = transform.frequency ?? 1;
        const amp = transform.amplitude ?? 1;
        const phase = transform.phase ?? 0;
        return Math.sin((value * freq + phase) * Math.PI * 2) * amp;
      }
      default:
        return value;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(base, driven, mode, amount) {
    let result;
    switch (mode) {
      case "replace":
        result = driven;
        break;
      case "add":
        result = base + driven;
        break;
      case "multiply":
        result = base * driven;
        break;
      default:
        result = driven;
    }
    return base * (1 - amount) + result * amount;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(layerId, frame, baseValues) {
    const result = /* @__PURE__ */ new Map();
    const drivers = this.getDriversForLayer(layerId);
    for (const driver of drivers) {
      if (!driver.enabled) continue;
      const baseValue = baseValues.get(driver.targetProperty) ?? 0;
      const drivenValue = this.evaluateDriver(driver, frame, baseValue);
      const existing = result.get(driver.targetProperty);
      if (existing !== void 0) {
        result.set(driver.targetProperty, existing + drivenValue - baseValue);
      } else {
        result.set(driver.targetProperty, drivenValue);
      }
    }
    return result;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear();
    this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(drivers) {
    this.clear();
    for (const driver of drivers) {
      this.addDriver(driver);
    }
  }
}
function createPropertyDriver(targetLayerId, targetProperty, sourceType = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: true,
    targetLayerId,
    targetProperty,
    sourceType,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function createAudioDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "audio");
  driver.audioFeature = audioFeature;
  driver.audioThreshold = options.threshold ?? 0;
  driver.audioAboveThreshold = options.threshold !== void 0;
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  if (options.smoothing !== void 0 && options.smoothing > 0) {
    driver.transforms.push({ type: "smooth", smoothing: options.smoothing });
  }
  return driver;
}
function createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "property");
  driver.sourceLayerId = sourceLayerId;
  driver.sourceProperty = sourceProperty;
  driver.blendMode = options.blendMode ?? "add";
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  return driver;
}

const DEFAULT_SNAP_CONFIG = {
  enabled: true,
  snapToGrid: true,
  snapToKeyframes: true,
  snapToBeats: true,
  snapToPeaks: true,
  snapToLayerBounds: true,
  snapToPlayhead: true,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function findNearestSnap(frame, config, pixelsPerFrame, context) {
  if (!config.enabled) {
    return null;
  }
  const snapTargets = [];
  const thresholdFrames = config.threshold / pixelsPerFrame;
  if (config.snapToGrid) {
    const nearestGridFrame = Math.round(frame / config.gridInterval) * config.gridInterval;
    const gridDistance = Math.abs(frame - nearestGridFrame);
    if (gridDistance <= thresholdFrames) {
      snapTargets.push({
        frame: nearestGridFrame,
        type: "frame",
        distance: gridDistance * pixelsPerFrame
      });
    }
  }
  if (config.snapToKeyframes && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, snapTargets);
    }
  }
  if (config.snapToBeats && context.audioAnalysis?.onsets) {
    for (const onset of context.audioAnalysis.onsets) {
      const distance = Math.abs(frame - onset);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: onset,
          type: "beat",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPeaks && context.peakData?.indices) {
    for (const peakFrame of context.peakData.indices) {
      const distance = Math.abs(frame - peakFrame);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: peakFrame,
          type: "peak",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToLayerBounds && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      const inDistance = Math.abs(frame - layer.inPoint);
      const outDistance = Math.abs(frame - layer.outPoint);
      if (inDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.inPoint,
          type: "layer-in",
          distance: inDistance * pixelsPerFrame
        });
      }
      if (outDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.outPoint,
          type: "layer-out",
          distance: outDistance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPlayhead && context.currentFrame !== void 0) {
    const distance = Math.abs(frame - context.currentFrame);
    if (distance <= thresholdFrames && distance > 0) {
      snapTargets.push({
        frame: context.currentFrame,
        type: "playhead",
        distance: distance * pixelsPerFrame
      });
    }
  }
  if (snapTargets.length === 0) {
    return null;
  }
  const priority = {
    "playhead": 5,
    "beat": 4,
    "peak": 4,
    "keyframe": 3,
    "layer-in": 2,
    "layer-out": 2,
    "frame": 1
  };
  snapTargets.sort((a, b) => {
    const distDiff = a.distance - b.distance;
    if (Math.abs(distDiff) < 0.5) {
      return priority[b.type] - priority[a.type];
    }
    return distDiff;
  });
  return snapTargets[0];
}
function collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, targets) {
  const properties = [
    layer.transform.position,
    layer.transform.scale,
    layer.transform.rotation,
    layer.opacity,
    ...layer.properties
  ];
  for (const prop of properties) {
    if (!prop.animated || !prop.keyframes) continue;
    for (const kf of prop.keyframes) {
      const distance = Math.abs(frame - kf.frame);
      if (distance <= thresholdFrames) {
        if (!targets.some((t) => t.frame === kf.frame && t.type === "keyframe")) {
          targets.push({
            frame: kf.frame,
            type: "keyframe",
            distance: distance * pixelsPerFrame
          });
        }
      }
    }
  }
}
function getBeatFrames(audioAnalysis) {
  return audioAnalysis?.onsets ?? [];
}
function getPeakFrames(peakData) {
  return peakData?.indices ?? [];
}

const useSelectionStore = defineStore("selection", {
  state: () => ({
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select"
  }),
  getters: {
    hasSelection: (state) => state.selectedLayerIds.length > 0,
    hasMultipleSelected: (state) => state.selectedLayerIds.length > 1,
    hasKeyframeSelection: (state) => state.selectedKeyframeIds.length > 0,
    singleSelectedLayerId: (state) => state.selectedLayerIds.length === 1 ? state.selectedLayerIds[0] : null
  },
  actions: {
    // ============================================================
    // LAYER SELECTION
    // ============================================================
    /**
     * Select a single layer (replaces current selection)
     */
    selectLayer(layerId) {
      this.selectedLayerIds = [layerId];
      storeLogger.debug("Selected layer:", layerId);
    },
    /**
     * Select multiple layers (replaces current selection)
     */
    selectLayers(layerIds) {
      this.selectedLayerIds = [...layerIds];
      storeLogger.debug("Selected layers:", layerIds.length);
    },
    /**
     * Add layer to selection (multi-select)
     */
    addToSelection(layerId) {
      if (!this.selectedLayerIds.includes(layerId)) {
        this.selectedLayerIds.push(layerId);
      }
    },
    /**
     * Remove layer from selection
     */
    removeFromSelection(layerId) {
      const index = this.selectedLayerIds.indexOf(layerId);
      if (index >= 0) {
        this.selectedLayerIds.splice(index, 1);
      }
    },
    /**
     * Toggle layer selection
     */
    toggleLayerSelection(layerId) {
      if (this.selectedLayerIds.includes(layerId)) {
        this.removeFromSelection(layerId);
      } else {
        this.addToSelection(layerId);
      }
    },
    /**
     * Clear layer selection
     */
    clearLayerSelection() {
      this.selectedLayerIds = [];
    },
    /**
     * Check if layer is selected
     */
    isLayerSelected(layerId) {
      return this.selectedLayerIds.includes(layerId);
    },
    // ============================================================
    // KEYFRAME SELECTION
    // ============================================================
    /**
     * Select a single keyframe
     */
    selectKeyframe(keyframeId) {
      this.selectedKeyframeIds = [keyframeId];
    },
    /**
     * Select multiple keyframes
     */
    selectKeyframes(keyframeIds) {
      this.selectedKeyframeIds = [...keyframeIds];
    },
    /**
     * Add keyframe to selection
     */
    addKeyframeToSelection(keyframeId) {
      if (!this.selectedKeyframeIds.includes(keyframeId)) {
        this.selectedKeyframeIds.push(keyframeId);
      }
    },
    /**
     * Remove keyframe from selection
     */
    removeKeyframeFromSelection(keyframeId) {
      const index = this.selectedKeyframeIds.indexOf(keyframeId);
      if (index >= 0) {
        this.selectedKeyframeIds.splice(index, 1);
      }
    },
    /**
     * Toggle keyframe selection
     */
    toggleKeyframeSelection(keyframeId) {
      if (this.selectedKeyframeIds.includes(keyframeId)) {
        this.removeKeyframeFromSelection(keyframeId);
      } else {
        this.addKeyframeToSelection(keyframeId);
      }
    },
    /**
     * Clear keyframe selection
     */
    clearKeyframeSelection() {
      this.selectedKeyframeIds = [];
    },
    /**
     * Check if keyframe is selected
     */
    isKeyframeSelected(keyframeId) {
      return this.selectedKeyframeIds.includes(keyframeId);
    },
    // ============================================================
    // PROPERTY SELECTION
    // ============================================================
    /**
     * Set selected property path (for graph editor focus)
     */
    setSelectedPropertyPath(path) {
      this.selectedPropertyPath = path;
    },
    // ============================================================
    // TOOL STATE
    // ============================================================
    /**
     * Set current tool
     */
    setTool(tool) {
      this.currentTool = tool;
    },
    // ============================================================
    // CLEAR ALL
    // ============================================================
    /**
     * Clear all selections
     */
    clearAll() {
      this.selectedLayerIds = [];
      this.selectedKeyframeIds = [];
      this.selectedPropertyPath = null;
    }
  }
});

const layerVersions = /* @__PURE__ */ new Map();
function markLayerDirty(layerId) {
  const current = layerVersions.get(layerId) ?? 0;
  layerVersions.set(layerId, current + 1);
}
const evaluationCache = /* @__PURE__ */ new Map();
function clearLayerCache(layerId) {
  const keysToDelete = [];
  for (const key of evaluationCache.keys()) {
    if (key.startsWith(`${layerId}:`)) {
      keysToDelete.push(key);
    }
  }
  keysToDelete.forEach((key) => evaluationCache.delete(key));
}

function deleteLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const index = layers.findIndex((l) => l.id === layerId);
  if (index === -1) return;
  layers.splice(index, 1);
  useSelectionStore().removeFromSelection(layerId);
  clearLayerCache(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function duplicateLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const original = layers.find((l) => l.id === layerId);
  if (!original) return null;
  const duplicate = JSON.parse(JSON.stringify(original));
  duplicate.id = crypto.randomUUID();
  duplicate.name = original.name + " Copy";
  regenerateKeyframeIds(duplicate);
  const index = layers.findIndex((l) => l.id === layerId);
  layers.splice(index, 0, duplicate);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return duplicate;
}
function copySelectedLayers(store) {
  const layers = store.getActiveCompLayers();
  const selection = useSelectionStore();
  const selectedLayers = layers.filter((l) => selection.selectedLayerIds.includes(l.id));
  if (selectedLayers.length === 0) return;
  store.clipboard.layers = selectedLayers.map((layer) => JSON.parse(JSON.stringify(layer)));
  storeLogger.debug(`Copied ${store.clipboard.layers.length} layer(s) to clipboard`);
}
function pasteLayers(store) {
  if (store.clipboard.layers.length === 0) return [];
  const layers = store.getActiveCompLayers();
  const pastedLayers = [];
  for (const clipboardLayer of store.clipboard.layers) {
    const newLayer = JSON.parse(JSON.stringify(clipboardLayer));
    newLayer.id = crypto.randomUUID();
    newLayer.name = clipboardLayer.name + " Copy";
    regenerateKeyframeIds(newLayer);
    newLayer.parentId = null;
    layers.unshift(newLayer);
    pastedLayers.push(newLayer);
  }
  useSelectionStore().selectLayers(pastedLayers.map((l) => l.id));
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  storeLogger.debug(`Pasted ${pastedLayers.length} layer(s)`);
  return pastedLayers;
}
function cutSelectedLayers(store) {
  copySelectedLayers(store);
  const layerIds = [...useSelectionStore().selectedLayerIds];
  for (const id of layerIds) {
    deleteLayer(store, id);
  }
}
function updateLayer(store, layerId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  Object.assign(layer, updates);
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateLayerData(store, layerId, dataUpdates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.data) return;
  Object.assign(layer.data, dataUpdates);
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveLayer(store, layerId, newIndex) {
  const layers = store.getActiveCompLayers();
  const currentIndex = layers.findIndex((l) => l.id === layerId);
  if (currentIndex === -1) return;
  const [layer] = layers.splice(currentIndex, 1);
  layers.splice(newIndex, 0, layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleLayer3D(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  layer.threeD = !layer.threeD;
  if (layer.threeD) {
    const t = layer.transform;
    const pos = t.position.value;
    t.position.value = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    t.position.type = "vector3";
    const anch = t.anchorPoint.value;
    t.anchorPoint.value = { x: anch.x, y: anch.y, z: anch.z ?? 0 };
    t.anchorPoint.type = "vector3";
    const scl = t.scale.value;
    t.scale.value = { x: scl.x, y: scl.y, z: scl.z ?? 100 };
    t.scale.type = "vector3";
    if (!t.orientation) {
      t.orientation = createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3");
    }
    if (!t.rotationX) {
      t.rotationX = createAnimatableProperty("rotationX", 0, "number");
    }
    if (!t.rotationY) {
      t.rotationY = createAnimatableProperty("rotationY", 0, "number");
    }
    if (!t.rotationZ) {
      t.rotationZ = createAnimatableProperty("rotationZ", 0, "number");
      t.rotationZ.value = t.rotation.value;
    }
  } else {
    if (layer.transform.rotationZ) {
      layer.transform.rotation.value = layer.transform.rotationZ.value;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setLayerParent(store, layerId, parentId) {
  const layers = store.getActiveCompLayers();
  const layer = layers.find((l) => l.id === layerId);
  if (!layer) return;
  if (parentId === layerId) return;
  if (parentId) {
    const getDescendants = (id) => {
      const descendants2 = /* @__PURE__ */ new Set();
      const children = layers.filter((l) => l.parentId === id);
      for (const child of children) {
        descendants2.add(child.id);
        const childDescendants = getDescendants(child.id);
        childDescendants.forEach((d) => descendants2.add(d));
      }
      return descendants2;
    };
    const descendants = getDescendants(layerId);
    if (descendants.has(parentId)) {
      storeLogger.warn("Cannot set parent: would create circular reference");
      return;
    }
  }
  layer.parentId = parentId;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function addSplineControlPoint(store, layerId, point) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  splineData.controlPoints.push(point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateSplineControlPoint(store, layerId, pointId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const point = splineData.controlPoints?.find((p) => p.id === pointId);
  if (!point) return;
  Object.assign(point, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteSplineControlPoint(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) return;
  const index = splineData.controlPoints.findIndex((p) => p.id === pointId);
  if (index >= 0) {
    splineData.controlPoints.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function selectLayer(_store, layerId, addToSelection = false) {
  const selection = useSelectionStore();
  if (addToSelection) {
    selection.addToSelection(layerId);
  } else {
    selection.selectLayer(layerId);
  }
}
function deselectLayer(_store, layerId) {
  useSelectionStore().removeFromSelection(layerId);
}
function regenerateKeyframeIds(layer) {
  if (layer.transform) {
    for (const key of Object.keys(layer.transform)) {
      const prop = layer.transform[key];
      if (prop?.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
  if (layer.properties) {
    for (const prop of layer.properties) {
      if (prop.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
}

function findPropertyByPath(layer, propertyPath) {
  const normalizedPath = propertyPath.replace(/^transform\./, "");
  if (normalizedPath === "position") {
    return layer.transform.position;
  }
  if (normalizedPath === "scale") {
    return layer.transform.scale;
  }
  if (normalizedPath === "rotation") {
    return layer.transform.rotation;
  }
  if (normalizedPath === "anchorPoint") {
    return layer.transform.anchorPoint;
  }
  if (propertyPath === "opacity") {
    return layer.opacity;
  }
  if (normalizedPath === "rotationX" && layer.transform.rotationX) {
    return layer.transform.rotationX;
  }
  if (normalizedPath === "rotationY" && layer.transform.rotationY) {
    return layer.transform.rotationY;
  }
  if (normalizedPath === "rotationZ" && layer.transform.rotationZ) {
    return layer.transform.rotationZ;
  }
  if (normalizedPath === "orientation" && layer.transform.orientation) {
    return layer.transform.orientation;
  }
  return layer.properties.find((p) => p.name === propertyPath || p.id === propertyPath);
}
function addKeyframe(store, layerId, propertyPath, value, atFrame) {
  const comp = store.getActiveComp();
  const frame = atFrame ?? (comp?.currentFrame ?? 0);
  storeLogger.debug("addKeyframe called:", { layerId, propertyPath, value, frame });
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.debug("addKeyframe: layer not found");
    return null;
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    storeLogger.debug("addKeyframe: property not found:", propertyPath);
    return null;
  }
  property.animated = true;
  const keyframe = {
    id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    frame,
    value,
    interpolation: "linear",
    inHandle: { frame: 0, value: 0, enabled: false },
    outHandle: { frame: 0, value: 0, enabled: false },
    controlMode: "smooth"
  };
  const existingIndex = property.keyframes.findIndex((k) => k.frame === frame);
  if (existingIndex >= 0) {
    property.keyframes[existingIndex] = keyframe;
    storeLogger.debug("addKeyframe: replaced existing keyframe at frame", frame);
  } else {
    property.keyframes.push(keyframe);
    property.keyframes.sort((a, b) => a.frame - b.frame);
    storeLogger.debug("addKeyframe: added new keyframe at frame", frame, "total keyframes:", property.keyframes.length);
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  return keyframe;
}
function removeKeyframe(store, layerId, propertyPath, keyframeId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const index = property.keyframes.findIndex((k) => k.id === keyframeId);
  if (index >= 0) {
    property.keyframes.splice(index, 1);
    if (property.keyframes.length === 0) {
      property.animated = false;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveKeyframe(store, layerId, propertyPath, keyframeId, newFrame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  const existingAtTarget = property.keyframes.find(
    (kf) => kf.frame === newFrame && kf.id !== keyframeId
  );
  if (existingAtTarget) {
    property.keyframes = property.keyframes.filter((kf) => kf.id !== existingAtTarget.id);
  }
  keyframe.frame = newFrame;
  property.keyframes.sort((a, b) => a.frame - b.frame);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeValue(store, layerId, propertyPath, keyframeId, newValue) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (typeof keyframe.value === "object" && keyframe.value !== null && typeof newValue === "number") {
    storeLogger.warn("setKeyframeValue: Cannot directly update vector keyframes with scalar. Use separate dimension curves.");
    return;
  }
  keyframe.value = newValue;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateKeyframe(store, layerId, propertyPath, keyframeId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (updates.frame !== void 0) {
    keyframe.frame = updates.frame;
    property.keyframes.sort((a, b) => a.frame - b.frame);
  }
  if (updates.value !== void 0) {
    keyframe.value = updates.value;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeInterpolation(store, layerId, propertyPath, keyframeId, interpolation) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  keyframe.interpolation = interpolation;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeHandle(store, layerId, propertyPath, keyframeId, handleType, handle) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (handleType === "in") {
    keyframe.inHandle = { ...handle };
  } else {
    keyframe.outHandle = { ...handle };
  }
  if (handle.enabled && keyframe.interpolation === "linear") {
    keyframe.interpolation = "bezier";
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyValue(store, layerId, propertyPath, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.value = value;
  if (property.animated && property.keyframes.length > 0) {
    const currentFrame = store.getActiveComp()?.currentFrame ?? 0;
    const existingKf = property.keyframes.find((kf) => kf.frame === currentFrame);
    if (existingKf) {
      existingKf.value = value;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyAnimated(store, layerId, propertyPath, animated, addKeyframeCallback) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.animated = animated;
  if (animated && property.keyframes.length === 0) {
    if (addKeyframeCallback) {
      addKeyframeCallback();
    } else {
      const comp = store.getActiveComp();
      const frame = comp?.currentFrame ?? 0;
      const keyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame,
        value: property.value,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false },
        controlMode: "smooth"
      };
      property.keyframes.push(keyframe);
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}

const logger$2 = createLogger("ProjectStorage");
const API_BASE = "/weyl/compositor";
async function saveProject(project, projectId) {
  try {
    logger$2.info(`Saving project${projectId ? ` (${projectId})` : ""}...`);
    const response = await fetch(`${API_BASE}/save_project`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        project,
        project_id: projectId
      })
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project saved: ${result.project_id}`);
    } else {
      logger$2.error(`Failed to save project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error saving project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function loadProject(projectId) {
  try {
    logger$2.info(`Loading project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/load_project/${encodeURIComponent(projectId)}`);
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project loaded: ${projectId}`);
    } else {
      logger$2.error(`Failed to load project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error loading project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function listProjects() {
  try {
    logger$2.info("Listing projects...");
    const response = await fetch(`${API_BASE}/list_projects`);
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Found ${result.projects?.length || 0} projects`);
    } else {
      logger$2.error(`Failed to list projects: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error listing projects:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function deleteProject(projectId) {
  try {
    logger$2.info(`Deleting project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/delete_project/${encodeURIComponent(projectId)}`, {
      method: "DELETE"
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$2.info(`Project deleted: ${projectId}`);
    } else {
      logger$2.error(`Failed to delete project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$2.error("Error deleting project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}

const MAX_HISTORY_SIZE = 50;
function pushHistory(store) {
  if (store.historyIndex < store.historyStack.length - 1) {
    store.historyStack = store.historyStack.slice(0, store.historyIndex + 1);
  }
  const snapshot = JSON.parse(JSON.stringify(store.project));
  store.historyStack.push(snapshot);
  store.historyIndex = store.historyStack.length - 1;
  if (store.historyStack.length > MAX_HISTORY_SIZE) {
    store.historyStack = store.historyStack.slice(-MAX_HISTORY_SIZE);
    store.historyIndex = store.historyStack.length - 1;
  }
}
function undo(store) {
  if (store.historyIndex <= 0) return false;
  store.historyIndex--;
  store.project = JSON.parse(JSON.stringify(store.historyStack[store.historyIndex]));
  return true;
}
function redo(store) {
  if (store.historyIndex >= store.historyStack.length - 1) return false;
  store.historyIndex++;
  store.project = JSON.parse(JSON.stringify(store.historyStack[store.historyIndex]));
  return true;
}
function exportProject(store) {
  return JSON.stringify(store.project, null, 2);
}
function importProject(store, json, pushHistoryFn) {
  try {
    const project = JSON.parse(json);
    store.project = project;
    pushHistoryFn();
    return true;
  } catch (err) {
    storeLogger.error("Failed to import project:", err);
    return false;
  }
}
async function saveProjectToServer(store, projectId) {
  try {
    const result = await saveProject(store.project, projectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project saved to server:", result.project_id);
      return result.project_id;
    } else {
      storeLogger.error("Failed to save project:", result.message);
      return null;
    }
  } catch (err) {
    storeLogger.error("Error saving project to server:", err);
    return null;
  }
}
async function loadProjectFromServer(store, projectId, pushHistoryFn) {
  try {
    const result = await loadProject(projectId);
    if (result.status === "success" && result.project) {
      store.project = result.project;
      pushHistoryFn();
      store.lastSaveProjectId = projectId;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project loaded from server:", projectId);
      return true;
    } else {
      storeLogger.error("Failed to load project:", result.message);
      return false;
    }
  } catch (err) {
    storeLogger.error("Error loading project from server:", err);
    return false;
  }
}
async function listServerProjects() {
  try {
    const result = await listProjects();
    if (result.status === "success" && result.projects) {
      return result.projects;
    }
    return [];
  } catch (err) {
    storeLogger.error("Error listing projects:", err);
    return [];
  }
}
async function deleteServerProject(projectId) {
  try {
    const result = await deleteProject(projectId);
    return result.status === "success";
  } catch (err) {
    storeLogger.error("Error deleting project:", err);
    return false;
  }
}
function startAutosave(store, performAutosaveFn) {
  if (store.autosaveTimerId !== null || !store.autosaveEnabled) {
    return;
  }
  store.autosaveTimerId = window.setInterval(
    performAutosaveFn,
    store.autosaveIntervalMs
  );
  storeLogger.info("Autosave started with interval:", store.autosaveIntervalMs);
}
function stopAutosave(store) {
  if (store.autosaveTimerId !== null && store.autosaveTimerId !== void 0) {
    window.clearInterval(store.autosaveTimerId);
    store.autosaveTimerId = null;
    storeLogger.info("Autosave stopped");
  }
}
function configureAutosave(store, options, performAutosaveFn) {
  if (options.enabled !== void 0) {
    store.autosaveEnabled = options.enabled;
  }
  if (options.intervalMs !== void 0) {
    store.autosaveIntervalMs = options.intervalMs;
  }
  stopAutosave(store);
  if (store.autosaveEnabled) {
    startAutosave(store, performAutosaveFn);
  }
}
async function performAutosave(store) {
  if (!store.hasUnsavedChanges) return;
  try {
    const existingProjectId = store.lastSaveProjectId || void 0;
    const result = await saveProject(store.project, existingProjectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Autosaved project:", result.project_id);
    } else {
      storeLogger.error("Autosave failed:", result.message);
    }
  } catch (error) {
    storeLogger.error("Autosave failed:", error);
  }
}
function markUnsavedChanges(store) {
  store.hasUnsavedChanges = true;
}

let worker = null;
let currentResolve = null;
let currentReject = null;
let currentOnProgress = null;
function ensureWorker() {
  if (!worker) {
    worker = new Worker(
      new URL(/* @vite-ignore */ "/worker-audioWorker.js", import.meta.url),
      { type: "module" }
    );
    worker.onmessage = (event) => {
      const message = event.data;
      switch (message.type) {
        case "progress":
          if (currentOnProgress) {
            currentOnProgress({
              phase: message.payload.phase,
              progress: message.payload.progress,
              message: message.payload.message
            });
          }
          break;
        case "complete":
          if (currentResolve) {
            currentResolve(message.payload);
            cleanup();
          }
          break;
        case "error":
          if (currentReject) {
            currentReject(new Error(message.payload.message));
            cleanup();
          }
          break;
      }
    };
    worker.onerror = (error) => {
      console.error("[AudioWorker] Worker error:", error);
      if (currentReject) {
        currentReject(new Error(`Worker error: ${error.message}`));
        cleanup();
      }
    };
  }
  return worker;
}
function cleanup() {
  currentResolve = null;
  currentReject = null;
  currentOnProgress = null;
}
function cancelAnalysis() {
  if (worker) {
    worker.postMessage({ type: "cancel" });
  }
}
async function analyzeAudioInWorker(audioBuffer, fps, options = {}) {
  const w = ensureWorker();
  if (currentResolve) {
    throw new Error("Analysis already in progress. Cancel it first.");
  }
  const channelData = audioBuffer.getChannelData(0);
  const channelDataCopy = new Float32Array(channelData);
  return new Promise((resolve, reject) => {
    currentResolve = resolve;
    currentReject = reject;
    currentOnProgress = options.onProgress || null;
    w.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: channelDataCopy,
          sampleRate: audioBuffer.sampleRate,
          fps
        }
      },
      [channelDataCopy.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function loadAndAnalyzeAudio(file, fps, options = {}) {
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 0,
      message: "Decoding audio file..."
    });
  }
  const arrayBuffer = await file.arrayBuffer();
  const audioContext = new AudioContext();
  let buffer;
  try {
    buffer = await audioContext.decodeAudioData(arrayBuffer);
  } finally {
    await audioContext.close();
  }
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 1,
      message: "Audio decoded successfully"
    });
  }
  const analysis = await analyzeAudioInWorker(buffer, fps, options);
  return { buffer, analysis };
}

function createDefaultAudioMapping(id, feature = "amplitude", target = "particle.emissionRate") {
  return {
    id: id || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature,
    target,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: false,
    threshold: 0,
    enabled: true,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class AudioReactiveMapper {
  analysis;
  mappings = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  releaseEnvelopes = /* @__PURE__ */ new Map();
  // ATI-style release tracking
  beatToggleStates = /* @__PURE__ */ new Map();
  // For beat toggle/flip
  peakData = null;
  constructor(analysis) {
    this.analysis = analysis;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(peakData) {
    this.peakData = peakData;
  }
  /**
   * Add a new mapping
   */
  addMapping(mapping) {
    this.mappings.set(mapping.id, mapping);
    this.smoothedValues.set(mapping.id, 0);
    this.releaseEnvelopes.set(mapping.id, 0);
    this.beatToggleStates.set(mapping.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(id) {
    this.mappings.delete(id);
    this.smoothedValues.delete(id);
    this.releaseEnvelopes.delete(id);
    this.beatToggleStates.delete(id);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(id, updates) {
    const mapping = this.mappings.get(id);
    if (mapping) {
      Object.assign(mapping, updates);
    }
  }
  /**
   * Get a specific mapping
   */
  getMapping(id) {
    return this.mappings.get(id);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(layerId) {
    return Array.from(this.mappings.values()).filter(
      (m) => m.targetLayerId === layerId || m.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(target) {
    return Array.from(this.mappings.values()).filter((m) => m.target === target);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(feature, frame) {
    if (feature === "peaks") {
      if (this.peakData) {
        return isPeakAtFrame(this.peakData, frame) ? 1 : 0;
      }
      return 0;
    }
    return getFeatureAtFrame(this.analysis, feature, frame);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(mappingId, frame) {
    const mapping = this.mappings.get(mappingId);
    if (!mapping || !mapping.enabled) return 0;
    let value = this.getFeatureAtFrame(mapping.feature, frame);
    if (value < mapping.threshold) {
      value = 0;
    }
    if (mapping.amplitudeCurve !== 1) {
      value = Math.pow(value, mapping.amplitudeCurve);
    }
    const releaseEnvelope = this.releaseEnvelopes.get(mappingId) || 0;
    if (value > releaseEnvelope) {
      this.releaseEnvelopes.set(mappingId, value);
    } else {
      const decayRate = 1 - mapping.release * 0.98;
      const newEnvelope = releaseEnvelope * decayRate;
      this.releaseEnvelopes.set(mappingId, newEnvelope);
      value = Math.max(value, newEnvelope);
    }
    if (mapping.beatResponse !== "none") {
      const isBeat = this.analysis.onsets.includes(frame) && this.getFeatureAtFrame(mapping.feature, frame) > mapping.beatThreshold;
      if (isBeat) {
        const currentToggle = this.beatToggleStates.get(mappingId) || 0;
        switch (mapping.beatResponse) {
          case "flip":
            this.beatToggleStates.set(mappingId, currentToggle === 0 ? 1 : 0);
            break;
          case "pulse":
            value = 1;
            break;
          case "toggle":
            const newToggle = currentToggle === 0 ? 1 : 0;
            this.beatToggleStates.set(mappingId, newToggle);
            value = newToggle;
            break;
        }
      }
      if (mapping.beatResponse === "flip") {
        const toggle = this.beatToggleStates.get(mappingId) || 0;
        if (toggle === 1) {
          value = 1 - value;
        }
      }
    }
    value = this.applyCurve(value, mapping.curve);
    if (mapping.invert) {
      value = 1 - value;
    }
    value *= mapping.sensitivity;
    value += mapping.offset;
    value = Math.max(mapping.min, Math.min(mapping.max, value));
    const prevSmoothed = this.smoothedValues.get(mappingId) || 0;
    const smoothed = prevSmoothed * mapping.smoothing + value * (1 - mapping.smoothing);
    this.smoothedValues.set(mappingId, smoothed);
    return smoothed;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(layerId, frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      if (mapping.targetLayerId && mapping.targetLayerId !== layerId) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(value, curve) {
    const clamped = Math.max(0, Math.min(1, value));
    switch (curve) {
      case "exponential":
        return clamped * clamped;
      case "logarithmic":
        return Math.sqrt(clamped);
      case "smoothstep":
        return clamped * clamped * (3 - 2 * clamped);
      case "bounce":
        if (clamped < 0.5) {
          return 2 * clamped * clamped;
        } else {
          const t = clamped - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * t, 2));
        }
      case "linear":
      default:
        return clamped;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
    for (const mapping of this.mappings.values()) {
      this.smoothedValues.set(mapping.id, 0);
      this.releaseEnvelopes.set(mapping.id, 0);
      this.beatToggleStates.set(mapping.id, 0);
    }
  }
  /**
   * Update analysis data
   */
  setAnalysis(analysis) {
    this.analysis = analysis;
    this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear();
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(mappings) {
    this.clear();
    for (const mapping of mappings) {
      this.addMapping(mapping);
    }
  }
}
function getFeatureDisplayName(feature) {
  const names = {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  };
  return names[feature] || feature;
}
function getTargetDisplayName(target) {
  const splineMatch = target.match(/^spline\.controlPoint\.(\d+)\.(x|y|depth)$/);
  if (splineMatch) {
    const index = splineMatch[1];
    const prop = splineMatch[2] === "x" ? "X" : splineMatch[2] === "y" ? "Y" : "Depth";
    return `Spline: Control Point ${index} ${prop}`;
  }
  const names = {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  };
  return names[target] || target;
}
function getAllFeatures() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function getFeaturesByCategory() {
  return {
    "Energy": ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    "Spectral": ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    "Events": ["onsets", "peaks"],
    "Harmonic": ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function getTargetsByCategory() {
  return {
    "Particle": [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    "Depthflow": [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    "Path": ["path.position"],
    "Layer": [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
    // Note: 'Spline' targets are generated dynamically based on control point count
    // Use createSplineControlPointTargets() to get targets for a specific spline
  };
}

const DEFAULT_CONFIG$1 = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: true,
  beatThreshold: 0.05,
  motionBlur: false,
  motionBlurStrength: 0.5
};
class AudioPathAnimator {
  config;
  state;
  pathSegments = [];
  totalLength = 0;
  releaseState = 0;
  // For amplitude mode release tracking
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$1, ...config };
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(pathData) {
    this.pathSegments = this.parsePath(pathData);
    this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(pathData) {
    const segments = [];
    const commands = pathData.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let currentX = 0;
    let currentY = 0;
    for (const cmd of commands) {
      const type = cmd[0].toUpperCase();
      const nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter((n) => !isNaN(n));
      switch (type) {
        case "M":
          currentX = nums[0] || 0;
          currentY = nums[1] || 0;
          segments.push({
            type: "M",
            points: [currentX, currentY],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          segments.push({
            type: "L",
            points: [currentX, currentY, nums[0], nums[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[0];
          currentY = nums[1];
          break;
        case "C":
          segments.push({
            type: "C",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[4];
          currentY = nums[5];
          break;
        case "Q":
          segments.push({
            type: "Q",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[2];
          currentY = nums[3];
          break;
        case "Z":
          const firstMove = segments.find((s) => s.type === "M");
          if (firstMove) {
            segments.push({
              type: "L",
              points: [currentX, currentY, firstMove.points[0], firstMove.points[1]],
              length: 0,
              startT: 0,
              endT: 0
            });
          }
          break;
      }
    }
    return segments;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let totalLength = 0;
    for (const segment of this.pathSegments) {
      switch (segment.type) {
        case "M":
          segment.length = 0;
          break;
        case "L":
          segment.length = this.lineLength(segment.points);
          break;
        case "C":
          segment.length = this.bezierLength(segment.points, 3);
          break;
        case "Q":
          segment.length = this.bezierLength(segment.points, 2);
          break;
      }
      segment.startT = totalLength;
      totalLength += segment.length;
      segment.endT = totalLength;
    }
    this.totalLength = totalLength;
    if (this.totalLength > 0) {
      for (const segment of this.pathSegments) {
        segment.startT /= this.totalLength;
        segment.endT /= this.totalLength;
      }
    }
  }
  lineLength(points) {
    const dx = points[2] - points[0];
    const dy = points[3] - points[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  bezierLength(points, degree) {
    const steps = 20;
    let length = 0;
    let prevX = points[0];
    let prevY = points[1];
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const { x, y } = this.getBezierPoint(points, t, degree);
      const dx = x - prevX;
      const dy = y - prevY;
      length += Math.sqrt(dx * dx + dy * dy);
      prevX = x;
      prevY = y;
    }
    return length;
  }
  getBezierPoint(points, t, degree) {
    if (degree === 2) {
      const mt = 1 - t;
      return {
        x: mt * mt * points[0] + 2 * mt * t * points[2] + t * t * points[4],
        y: mt * mt * points[1] + 2 * mt * t * points[3] + t * t * points[5]
      };
    } else {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;
      return {
        x: mt2 * mt * points[0] + 3 * mt2 * t * points[2] + 3 * mt * t2 * points[4] + t2 * t * points[6],
        y: mt2 * mt * points[1] + 3 * mt2 * t * points[3] + 3 * mt * t2 * points[5] + t2 * t * points[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(audioValue, isBeat) {
    this.state.previousPosition = this.state.position;
    const smoothedInput = this.state.smoothedValue * this.config.smoothing + audioValue * (1 - this.config.smoothing);
    this.state.smoothedValue = smoothedInput;
    if (this.config.movementMode === "amplitude") {
      this.updateAmplitudeMode(smoothedInput);
    } else {
      this.updateAccumulateMode(smoothedInput, isBeat);
    }
    const pathPoint = this.getPositionOnPath(this.state.position);
    this.state.x = pathPoint.x;
    this.state.y = pathPoint.y;
    this.state.angle = pathPoint.angle;
    return { ...this.state };
  }
  updateAmplitudeMode(audioValue) {
    let processedValue = Math.pow(audioValue, this.config.amplitudeCurve);
    if (processedValue > this.releaseState) {
      this.releaseState = processedValue;
    } else {
      const decayRate = 1 - this.config.release * 0.95;
      this.releaseState *= decayRate;
    }
    const finalValue = Math.max(processedValue, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, finalValue * this.config.sensitivity));
  }
  updateAccumulateMode(audioValue, isBeat) {
    if (this.config.flipOnBeat && isBeat && audioValue > this.config.beatThreshold) {
      this.state.direction *= -1;
    }
    const delta = audioValue * this.config.sensitivity * 0.02 * this.state.direction;
    let newPosition = this.state.position + delta;
    if (newPosition > 1) {
      newPosition = 2 - newPosition;
      this.state.direction = -1;
    } else if (newPosition < 0) {
      newPosition = -newPosition;
      this.state.direction = 1;
    }
    this.state.position = Math.max(0, Math.min(1, newPosition));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(t) {
    t = Math.max(0, Math.min(1, t));
    if (this.pathSegments.length === 0) {
      return { x: 0, y: 0, angle: 0 };
    }
    let segment = this.pathSegments[0];
    for (const seg of this.pathSegments) {
      if (seg.type !== "M" && t >= seg.startT && t <= seg.endT) {
        segment = seg;
        break;
      }
    }
    if (segment.type === "M") {
      return { x: segment.points[0], y: segment.points[1], angle: 0 };
    }
    const segmentT = segment.endT > segment.startT ? (t - segment.startT) / (segment.endT - segment.startT) : 0;
    let x, y;
    let tangentX, tangentY;
    switch (segment.type) {
      case "L":
        x = segment.points[0] + (segment.points[2] - segment.points[0]) * segmentT;
        y = segment.points[1] + (segment.points[3] - segment.points[1]) * segmentT;
        tangentX = segment.points[2] - segment.points[0];
        tangentY = segment.points[3] - segment.points[1];
        break;
      case "Q": {
        const result = this.getBezierPoint(segment.points, segmentT, 2);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        tangentX = 2 * mt * (segment.points[2] - segment.points[0]) + 2 * segmentT * (segment.points[4] - segment.points[2]);
        tangentY = 2 * mt * (segment.points[3] - segment.points[1]) + 2 * segmentT * (segment.points[5] - segment.points[3]);
        break;
      }
      case "C": {
        const result = this.getBezierPoint(segment.points, segmentT, 3);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        const mt2 = mt * mt;
        const t2 = segmentT * segmentT;
        tangentX = 3 * mt2 * (segment.points[2] - segment.points[0]) + 6 * mt * segmentT * (segment.points[4] - segment.points[2]) + 3 * t2 * (segment.points[6] - segment.points[4]);
        tangentY = 3 * mt2 * (segment.points[3] - segment.points[1]) + 6 * mt * segmentT * (segment.points[5] - segment.points[3]) + 3 * t2 * (segment.points[7] - segment.points[5]);
        break;
      }
      default:
        x = 0;
        y = 0;
        tangentX = 1;
        tangentY = 0;
    }
    const angle = Math.atan2(tangentY, tangentX);
    return { x, y, angle };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(steps = 5) {
    if (!this.config.motionBlur) return [];
    const trail = [];
    const startT = this.state.previousPosition;
    const endT = this.state.position;
    for (let i = 0; i <= steps; i++) {
      const t = startT + (endT - startT) * (i / steps);
      const pos = this.getPositionOnPath(t);
      const opacity = i / steps * this.config.motionBlurStrength;
      trail.push({ x: pos.x, y: pos.y, opacity });
    }
    return trail;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
    this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}

async function loadAudio(store, file) {
  store.audioFile = file;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioLoadingState = "decoding";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "Preparing...";
  store.audioLoadingError = null;
  try {
    const result = await loadAndAnalyzeAudio(
      file,
      store.project.composition.fps,
      {
        onProgress: (progress) => {
          if (progress.phase === "decoding") {
            store.audioLoadingState = "decoding";
          } else {
            store.audioLoadingState = "analyzing";
          }
          store.audioLoadingProgress = progress.progress;
          store.audioLoadingPhase = progress.message;
        }
      }
    );
    store.audioBuffer = result.buffer;
    store.audioAnalysis = result.analysis;
    store.audioLoadingState = "complete";
    store.audioLoadingProgress = 1;
    store.audioLoadingPhase = "Complete";
    initializeAudioReactiveMapper(store);
    if (store.propertyDriverSystem && store.audioAnalysis) {
      store.propertyDriverSystem.setAudioAnalysis(store.audioAnalysis);
    }
    storeLogger.debug("Audio loaded:", {
      duration: store.audioBuffer.duration,
      bpm: store.audioAnalysis.bpm,
      frameCount: store.audioAnalysis.frameCount
    });
  } catch (error) {
    storeLogger.error("Failed to load audio:", error);
    store.audioFile = null;
    store.audioBuffer = null;
    store.audioAnalysis = null;
    store.audioReactiveMapper = null;
    store.audioLoadingState = "error";
    store.audioLoadingError = error.message;
  }
}
function cancelAudioLoad(store) {
  cancelAnalysis();
  store.audioLoadingState = "idle";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "";
  store.audioLoadingError = null;
}
function clearAudio(store) {
  cancelAudioLoad(store);
  store.audioFile = null;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioMappings.clear();
}
function getAudioFeatureAtFrame(store, feature, frame) {
  if (!store.audioAnalysis) return 0;
  return getFeatureAtFrame(store.audioAnalysis, feature, frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function setPeakData(store, peakData) {
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
}
function detectAudioPeaks(store, config) {
  if (!store.audioAnalysis) return null;
  const weights = store.audioAnalysis.amplitudeEnvelope;
  const peakData = detectPeaks(weights, config);
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
  return peakData;
}
function addAudioMapping(store, mapping) {
  store.audioReactiveMappings.push(mapping);
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.addMapping(mapping);
  }
}
function removeAudioMapping(store, mappingId) {
  const index = store.audioReactiveMappings.findIndex((m) => m.id === mappingId);
  if (index >= 0) {
    store.audioReactiveMappings.splice(index, 1);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.removeMapping(mappingId);
  }
}
function updateAudioMapping(store, mappingId, updates) {
  const mapping = store.audioReactiveMappings.find((m) => m.id === mappingId);
  if (mapping) {
    Object.assign(mapping, updates);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.updateMapping(mappingId, updates);
  }
}
function getMappedValueAtFrame(store, mappingId, frame) {
  if (!store.audioReactiveMapper) return 0;
  return store.audioReactiveMapper.getValueAtFrame(mappingId, frame);
}
function getAllMappedValuesAtFrame(store, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getAllValuesAtFrame(frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function getActiveMappingsForLayer(store, layerId) {
  return store.audioReactiveMappings.filter(
    (m) => m.enabled && (m.targetLayerId === layerId || m.targetLayerId === void 0)
  );
}
function getAudioReactiveValuesForLayer(store, layerId, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getValuesForLayerAtFrame(layerId, frame);
}
function isBeatAtCurrentFrame(store) {
  if (!store.audioAnalysis) return false;
  return isBeatAtFrame(store.audioAnalysis, store.getActiveComp()?.currentFrame ?? 0);
}
function initializeAudioReactiveMapper(store) {
  if (!store.audioAnalysis) return;
  store.audioReactiveMapper = new AudioReactiveMapper(store.audioAnalysis);
  for (const mapping of store.audioReactiveMappings) {
    store.audioReactiveMapper.addMapping(mapping);
  }
  if (store.peakData) {
    store.audioReactiveMapper.setPeakData(store.peakData);
  }
}
function createPathAnimator(store, layerId, config = {}) {
  const animator = new AudioPathAnimator(config);
  store.pathAnimators.set(layerId, animator);
}
function setPathAnimatorPath(store, layerId, pathData) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setPath(pathData);
  }
}
function updatePathAnimatorConfig(store, layerId, config) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setConfig(config);
  }
}
function removePathAnimator(store, layerId) {
  store.pathAnimators.delete(layerId);
}
function getPathAnimator(store, layerId) {
  return store.pathAnimators.get(layerId);
}
function updatePathAnimators(store) {
  if (!store.audioAnalysis) return;
  const frame = store.getActiveComp()?.currentFrame ?? 0;
  const amplitude = getFeatureAtFrame(store.audioAnalysis, "amplitude", frame);
  const isBeat = isBeatAtFrame(store.audioAnalysis, frame);
  for (const [_layerId, animator] of store.pathAnimators) {
    animator.update(amplitude, isBeat);
  }
}
function resetPathAnimators(store) {
  for (const animator of store.pathAnimators.values()) {
    animator.reset();
  }
}
function applyAudioToParticles(store, layerId, mapping) {
  const existing = store.audioMappings.get(layerId) || [];
  existing.push(mapping);
  store.audioMappings.set(layerId, existing);
}
function removeLegacyAudioMapping(store, layerId, index) {
  const mappings = store.audioMappings.get(layerId);
  if (mappings) {
    mappings.splice(index, 1);
    if (mappings.length === 0) {
      store.audioMappings.delete(layerId);
    }
  }
}
function getAudioMappingsForLayer(store, layerId) {
  return store.audioMappings.get(layerId) || [];
}

function getEvaluatedLayerProperties(store, layerId, frame) {
  if (!store.propertyDriverSystem) {
    return /* @__PURE__ */ new Map();
  }
  const layer = store.getLayer(layerId);
  if (!layer) return /* @__PURE__ */ new Map();
  const baseValues = /* @__PURE__ */ new Map();
  const pos = interpolateProperty(layer.transform.position, frame);
  baseValues.set("transform.position.x", pos.x);
  baseValues.set("transform.position.y", pos.y);
  const scale = interpolateProperty(layer.transform.scale, frame);
  baseValues.set("transform.scale.x", scale.x);
  baseValues.set("transform.scale.y", scale.y);
  baseValues.set("transform.rotation", interpolateProperty(layer.transform.rotation, frame));
  if (layer.transform.rotationX) {
    baseValues.set("transform.rotationX", interpolateProperty(layer.transform.rotationX, frame));
  }
  if (layer.transform.rotationY) {
    baseValues.set("transform.rotationY", interpolateProperty(layer.transform.rotationY, frame));
  }
  if (layer.transform.rotationZ) {
    baseValues.set("transform.rotationZ", interpolateProperty(layer.transform.rotationZ, frame));
  }
  baseValues.set("opacity", interpolateProperty(layer.opacity, frame));
  return store.propertyDriverSystem.evaluateLayerDrivers(layerId, frame, baseValues);
}
function addPropertyDriver(store, driver) {
  if (store.propertyDriverSystem) {
    const added = store.propertyDriverSystem.addDriver(driver);
    if (!added) {
      storeLogger.warn("Cannot add property driver: would create circular dependency");
      return false;
    }
  }
  store.propertyDrivers.push(driver);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return true;
}
function createAudioPropertyDriver(store, targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createAudioDriver(targetLayerId, targetProperty, audioFeature, options);
  addPropertyDriver(store, driver);
  return driver;
}
function createPropertyLinkDriver(store, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyLink(
    targetLayerId,
    targetProperty,
    sourceLayerId,
    sourceProperty,
    options
  );
  const success = addPropertyDriver(store, driver);
  if (!success) {
    return null;
  }
  return driver;
}
function removePropertyDriver(store, driverId) {
  const index = store.propertyDrivers.findIndex((d) => d.id === driverId);
  if (index >= 0) {
    store.propertyDrivers.splice(index, 1);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.removeDriver(driverId);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function updatePropertyDriver(store, driverId, updates) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    Object.assign(driver, updates);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.updateDriver(driverId, updates);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function getDriversForLayer(store, layerId) {
  return store.propertyDrivers.filter((d) => d.targetLayerId === layerId);
}
function togglePropertyDriver(store, driverId) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    driver.enabled = !driver.enabled;
    if (store.propertyDriverSystem) {
      store.propertyDriverSystem.updateDriver(driverId, { enabled: driver.enabled });
    }
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}

async function estimateVRAM(adapter) {
  try {
    const device = await adapter.requestDevice();
    const maxBufferSize = device.limits.maxBufferSize;
    device.destroy();
    return Math.round(maxBufferSize * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function detectGPUTier() {
  if ("gpu" in navigator) {
    try {
      const gpu = navigator.gpu;
      const adapter = await gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (adapter) {
        let deviceName = "";
        if ("info" in adapter) {
          const info = adapter.info;
          deviceName = info?.device || info?.description || "";
        }
        if (deviceName.includes("RTX 50") || deviceName.toLowerCase().includes("blackwell") || deviceName.includes("B100") || deviceName.includes("B200")) {
          return {
            tier: "blackwell",
            vram: await estimateVRAM(adapter),
            features: ["fp4_tensor", "webgpu", "cuda_12"]
          };
        }
        return {
          tier: "webgpu",
          vram: await estimateVRAM(adapter),
          features: ["webgpu"]
        };
      }
    } catch (error) {
      engineLogger.warn("WebGPU detection failed:", error);
    }
  }
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2");
  if (gl) {
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
    engineLogger.debug("WebGL renderer:", renderer);
    return {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}

const TIER_CONFIGS = {
  blackwell: {
    maxFrames: 500,
    maxMemoryBytes: 4 * 1024 * 1024 * 1024,
    // 4GB
    compression: false,
    // Fast GPU, no need for compression
    preCacheWindow: 30
  },
  webgpu: {
    maxFrames: 200,
    maxMemoryBytes: 1 * 1024 * 1024 * 1024,
    // 1GB
    compression: true,
    preCacheWindow: 15
  },
  webgl: {
    maxFrames: 100,
    maxMemoryBytes: 512 * 1024 * 1024,
    // 512MB
    compression: true,
    preCacheWindow: 10
  },
  cpu: {
    maxFrames: 50,
    maxMemoryBytes: 256 * 1024 * 1024,
    // 256MB
    compression: true,
    preCacheWindow: 5
  }
};
const DEFAULT_CONFIG = {
  maxFrames: 100,
  maxMemoryBytes: 512 * 1024 * 1024,
  compression: true,
  compressionQuality: 0.92,
  preCacheWindow: 10,
  predictivePreCache: true
};
class FrameCache {
  cache = /* @__PURE__ */ new Map();
  accessOrder = [];
  // For LRU tracking
  config;
  currentMemory = 0;
  stats = { hits: 0, misses: 0 };
  // Pre-caching state
  preCacheQueue = [];
  isPreCaching = false;
  preCacheAbort = null;
  // Composition state tracking
  stateHashCache = /* @__PURE__ */ new Map();
  // Frame render callback (set by engine)
  renderFrame = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Initialize cache with GPU-tier-appropriate settings
   */
  async initializeForGPU() {
    const tier = await detectGPUTier();
    const tierConfig = TIER_CONFIGS[tier.tier];
    this.config = { ...this.config, ...tierConfig };
  }
  /**
   * Set the frame render callback
   * This is called to render frames for pre-caching
   */
  setRenderCallback(callback) {
    this.renderFrame = callback;
  }
  /**
   * Generate a cache key for a frame
   */
  getCacheKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Get a cached frame
   * @returns The cached frame or null if not found/invalid
   */
  get(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.updateAccessOrder(key);
    this.stats.hits++;
    if (cached.compressed) {
      return null;
    }
    return cached.data;
  }
  /**
   * Get a cached frame (async, supports compression)
   */
  async getAsync(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.updateAccessOrder(key);
    this.stats.hits++;
    if (cached.compressed) {
      return this.decompressFrame(cached);
    }
    return cached.data;
  }
  /**
   * Cache a frame
   */
  async set(frame, compositionId, imageData, stateHash) {
    const key = this.getCacheKey(frame, compositionId);
    if (this.cache.has(key)) {
      this.remove(frame, compositionId);
    }
    let data = imageData;
    let compressed = false;
    let size = imageData.width * imageData.height * 4;
    if (this.config.compression) {
      const compressedData = await this.compressFrame(imageData);
      if (compressedData.size < size * 0.7) {
        data = compressedData;
        compressed = true;
        size = compressedData.size;
      }
    }
    await this.ensureCapacity(size);
    const cachedFrame = {
      frame,
      compositionId,
      data,
      compressed,
      width: imageData.width,
      height: imageData.height,
      timestamp: Date.now(),
      size,
      stateHash
    };
    this.cache.set(key, cachedFrame);
    this.accessOrder.push(key);
    this.currentMemory += size;
  }
  /**
   * Remove a cached frame
   */
  remove(frame, compositionId) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (cached) {
      this.currentMemory -= cached.size;
      this.cache.delete(key);
      this.accessOrder = this.accessOrder.filter((k) => k !== key);
    }
  }
  /**
   * Check if a frame is cached
   */
  has(frame, compositionId) {
    return this.cache.has(this.getCacheKey(frame, compositionId));
  }
  /**
   * Clear all cached frames for a composition
   */
  clearComposition(compositionId) {
    const keysToRemove = [];
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${compositionId}:`)) {
        keysToRemove.push(key);
      }
    }
    for (const key of keysToRemove) {
      const cached = this.cache.get(key);
      if (cached) {
        this.currentMemory -= cached.size;
      }
      this.cache.delete(key);
    }
    this.accessOrder = this.accessOrder.filter((k) => !keysToRemove.includes(k));
  }
  /**
   * Clear all cached frames
   */
  clear() {
    this.cache.clear();
    this.accessOrder = [];
    this.currentMemory = 0;
    this.stats = { hits: 0, misses: 0 };
    this.abortPreCache();
  }
  /**
   * Invalidate cache for a composition (when state changes)
   */
  invalidate(compositionId, newStateHash) {
    const oldHash = this.stateHashCache.get(compositionId);
    if (oldHash !== newStateHash) {
      this.clearComposition(compositionId);
      this.stateHashCache.set(compositionId, newStateHash);
    }
  }
  /**
   * Start predictive pre-caching around the current frame
   */
  async startPreCache(currentFrame, compositionId, stateHash, direction = "both") {
    if (!this.config.predictivePreCache || !this.renderFrame) {
      return;
    }
    this.abortPreCache();
    this.preCacheAbort = new AbortController();
    const signal = this.preCacheAbort.signal;
    this.preCacheQueue = [];
    const window = this.config.preCacheWindow;
    for (let i = 1; i <= window; i++) {
      if (direction !== "backward") {
        this.preCacheQueue.push({
          frame: currentFrame + i,
          compositionId,
          priority: window - i
          // Closer frames have higher priority
        });
      }
      if (direction !== "forward") {
        this.preCacheQueue.push({
          frame: currentFrame - i,
          compositionId,
          priority: window - i
        });
      }
    }
    this.preCacheQueue.sort((a, b) => b.priority - a.priority);
    this.isPreCaching = true;
    for (const item of this.preCacheQueue) {
      if (signal.aborted) {
        break;
      }
      if (!this.has(item.frame, item.compositionId)) {
        try {
          const imageData = await this.renderFrame(item.frame);
          if (!signal.aborted) {
            await this.set(item.frame, item.compositionId, imageData, stateHash);
          }
        } catch (error) {
          console.warn(`Pre-cache failed for frame ${item.frame}:`, error);
        }
      }
    }
    this.isPreCaching = false;
  }
  /**
   * Abort any ongoing pre-cache operation
   */
  abortPreCache() {
    if (this.preCacheAbort) {
      this.preCacheAbort.abort();
      this.preCacheAbort = null;
    }
    this.preCacheQueue = [];
    this.isPreCaching = false;
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    return {
      cachedFrames: this.cache.size,
      memoryUsed: this.currentMemory,
      hitRatio: total > 0 ? this.stats.hits / total : 0,
      hits: this.stats.hits,
      misses: this.stats.misses
    };
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  updateAccessOrder(key) {
    const index = this.accessOrder.indexOf(key);
    if (index > -1) {
      this.accessOrder.splice(index, 1);
    }
    this.accessOrder.push(key);
  }
  async ensureCapacity(requiredSize) {
    while ((this.cache.size >= this.config.maxFrames || this.currentMemory + requiredSize > this.config.maxMemoryBytes) && this.accessOrder.length > 0) {
      const oldestKey = this.accessOrder.shift();
      const cached = this.cache.get(oldestKey);
      if (cached) {
        this.currentMemory -= cached.size;
        this.cache.delete(oldestKey);
      }
    }
  }
  async compressFrame(imageData) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: "image/webp",
      quality: this.config.compressionQuality
    });
  }
  async decompressFrame(cached) {
    if (!(cached.data instanceof Blob)) {
      return cached.data;
    }
    const bitmap = await createImageBitmap(cached.data);
    const canvas = new OffscreenCanvas(cached.width, cached.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bitmap, 0, 0);
    bitmap.close();
    return ctx.getImageData(0, 0, cached.width, cached.height);
  }
}
let globalFrameCache = null;
function getFrameCache() {
  if (!globalFrameCache) {
    globalFrameCache = new FrameCache();
  }
  return globalFrameCache;
}
async function initializeFrameCache() {
  const cache = getFrameCache();
  await cache.initializeForGPU();
  return cache;
}

async function initializeCache(store) {
  if (store.frameCacheEnabled) {
    await initializeFrameCache();
    storeLogger.info("Frame cache initialized");
  }
}
function setFrameCacheEnabled(store, enabled) {
  store.frameCacheEnabled = enabled;
  if (!enabled) {
    clearFrameCache();
  }
  storeLogger.info("Frame cache", enabled ? "enabled" : "disabled");
}
function getCachedFrame(store, frame) {
  if (!store.frameCacheEnabled) return null;
  const cache = getFrameCache();
  return cache.get(frame, store.activeCompositionId, store.projectStateHash);
}
async function cacheFrame(store, frame, imageData) {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.set(frame, store.activeCompositionId, imageData, store.projectStateHash);
}
function isFrameCached(store, frame) {
  if (!store.frameCacheEnabled) return false;
  const cache = getFrameCache();
  return cache.has(frame, store.activeCompositionId);
}
async function startPreCache(store, currentFrame, direction = "both") {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.startPreCache(currentFrame, store.activeCompositionId, store.projectStateHash, direction);
}
function invalidateFrameCache(store) {
  store.projectStateHash = computeProjectHash(store);
  const cache = getFrameCache();
  cache.invalidate(store.activeCompositionId, store.projectStateHash);
}
function clearFrameCache() {
  const cache = getFrameCache();
  cache.clear();
  storeLogger.info("Frame cache cleared");
}
function getFrameCacheStats() {
  const cache = getFrameCache();
  return cache.getStats();
}
function computeProjectHash(store) {
  const comp = store.project.compositions[store.activeCompositionId];
  if (!comp) return "";
  const fingerprint = {
    layerCount: comp.layers.length,
    layerIds: comp.layers.map((l) => l.id).join(","),
    modified: store.project.meta.modified,
    settings: comp.settings
  };
  const str = JSON.stringify(fingerprint);
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return hash.toString(16);
}

function vec3(x, y, z) {
  return { x, y, z };
}
function addVec3(a, b) {
  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
function subVec3(a, b) {
  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
function scaleVec3(v, s) {
  return { x: v.x * s, y: v.y * s, z: v.z * s };
}
function lengthVec3(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
function normalizeVec3(v) {
  const len = lengthVec3(v);
  if (len === 0) return { x: 0, y: 0, z: 0 };
  return { x: v.x / len, y: v.y / len, z: v.z / len };
}
function crossVec3(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
  };
}
function dotVec3(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function perspectiveMat4(fovY, aspect, near, far) {
  const te = new Float32Array(16);
  const f = 1 / Math.tan(fovY / 2);
  const nf = 1 / (near - far);
  te[0] = f / aspect;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = f;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = (far + near) * nf;
  te[11] = -1;
  te[12] = 0;
  te[13] = 0;
  te[14] = 2 * far * near * nf;
  te[15] = 0;
  return { elements: te };
}
function orthographicMat4(left, right, bottom, top, near, far) {
  const te = new Float32Array(16);
  const w = 1 / (right - left);
  const h = 1 / (top - bottom);
  const p = 1 / (far - near);
  te[0] = 2 * w;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = 2 * h;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = -2 * p;
  te[11] = 0;
  te[12] = -(right + left) * w;
  te[13] = -(top + bottom) * h;
  te[14] = -10001 * p;
  te[15] = 1;
  return { elements: te };
}
function lookAtMat4(eye, target, up) {
  const te = new Float32Array(16);
  let zx = eye.x - target.x;
  let zy = eye.y - target.y;
  let zz = eye.z - target.z;
  let len = Math.sqrt(zx * zx + zy * zy + zz * zz);
  if (len === 0) {
    zz = 1;
  } else {
    len = 1 / len;
    zx *= len;
    zy *= len;
    zz *= len;
  }
  let xx = up.y * zz - up.z * zy;
  let xy = up.z * zx - up.x * zz;
  let xz = up.x * zy - up.y * zx;
  len = Math.sqrt(xx * xx + xy * xy + xz * xz);
  if (len === 0) {
    xx = 0;
    xy = 0;
    xz = 0;
  } else {
    len = 1 / len;
    xx *= len;
    xy *= len;
    xz *= len;
  }
  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;
  len = Math.sqrt(yx * yx + yy * yy + yz * yz);
  if (len === 0) {
    yx = 0;
    yy = 0;
    yz = 0;
  } else {
    len = 1 / len;
    yx *= len;
    yy *= len;
    yz *= len;
  }
  te[0] = xx;
  te[4] = xy;
  te[8] = xz;
  te[12] = -dotVec3({ x: xx, y: xy, z: xz }, eye);
  te[1] = yx;
  te[5] = yy;
  te[9] = yz;
  te[13] = -dotVec3({ x: yx, y: yy, z: yz }, eye);
  te[2] = zx;
  te[6] = zy;
  te[10] = zz;
  te[14] = -dotVec3({ x: zx, y: zy, z: zz }, eye);
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[15] = 1;
  return { elements: te };
}
function transformPoint(m, p) {
  const e = m.elements;
  const w = e[3] * p.x + e[7] * p.y + e[11] * p.z + e[15];
  return {
    x: (e[0] * p.x + e[4] * p.y + e[8] * p.z + e[12]) / w,
    y: (e[1] * p.x + e[5] * p.y + e[9] * p.z + e[13]) / w,
    z: (e[2] * p.x + e[6] * p.y + e[10] * p.z + e[14]) / w
  };
}
function focalLengthToFOV(focalLength, sensorSize) {
  return 2 * Math.atan(sensorSize / (2 * focalLength));
}
function fovToFocalLength(fov, sensorSize) {
  return sensorSize / (2 * Math.tan(fov / 2));
}

function interpolateCameraAtFrame(camera, keyframes, frame) {
  if (!keyframes || keyframes.length === 0) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  let prev = null;
  let next = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      prev = kf;
    }
    if (kf.frame >= frame && !next) {
      next = kf;
    }
  }
  if (!prev && !next) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  if (!prev) prev = next;
  if (!next) next = prev;
  const getPos = (kf) => kf?.position ?? camera.position;
  const getOri = (kf) => kf?.orientation ?? camera.orientation;
  const getFocal = (kf) => kf?.focalLength ?? camera.focalLength;
  const getZoom = (kf) => kf?.zoom ?? camera.zoom;
  const getFocusDist = (kf) => kf?.focusDistance ?? camera.depthOfField.focusDistance;
  if (prev.frame === next.frame) {
    return {
      position: getPos(prev),
      rotation: getOri(prev),
      focalLength: getFocal(prev),
      zoom: getZoom(prev),
      focusDistance: getFocusDist(prev)
    };
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevPos = getPos(prev);
  const nextPos = getPos(next);
  const prevOri = getOri(prev);
  const nextOri = getOri(next);
  return {
    position: {
      x: lerp(prevPos.x, nextPos.x, t),
      y: lerp(prevPos.y, nextPos.y, t),
      z: lerp(prevPos.z, nextPos.z, t)
    },
    rotation: {
      x: lerpAngle(prevOri.x, nextOri.x, t),
      y: lerpAngle(prevOri.y, nextOri.y, t),
      z: lerpAngle(prevOri.z, nextOri.z, t)
    },
    focalLength: lerp(getFocal(prev), getFocal(next), t),
    zoom: lerp(getZoom(prev), getZoom(next), t),
    focusDistance: lerp(getFocusDist(prev), getFocusDist(next), t)
  };
}
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return a + diff * t;
}
function computeViewMatrix(cam) {
  const { position, rotation } = cam;
  const rx = rotation.x * Math.PI / 180;
  const ry = rotation.y * Math.PI / 180;
  const rz = rotation.z * Math.PI / 180;
  const cosX = Math.cos(rx), sinX = Math.sin(rx);
  const cosY = Math.cos(ry), sinY = Math.sin(ry);
  const cosZ = Math.cos(rz), sinZ = Math.sin(rz);
  const r00 = cosY * cosZ + sinY * sinX * sinZ;
  const r01 = -cosY * sinZ + sinY * sinX * cosZ;
  const r02 = sinY * cosX;
  const r10 = cosX * sinZ;
  const r11 = cosX * cosZ;
  const r12 = -sinX;
  const r20 = -sinY * cosZ + cosY * sinX * sinZ;
  const r21 = sinY * sinZ + cosY * sinX * cosZ;
  const r22 = cosY * cosX;
  const tx = -(r00 * position.x + r10 * position.y + r20 * position.z);
  const ty = -(r01 * position.x + r11 * position.y + r21 * position.z);
  const tz = -(r02 * position.x + r12 * position.y + r22 * position.z);
  return [
    [r00, r01, r02, tx],
    [r10, r11, r12, ty],
    [r20, r21, r22, tz],
    [0, 0, 0, 1]
  ];
}
function computeProjectionMatrix(cam, aspectRatio, nearClip = 0.1, farClip = 1e3) {
  const fov = focalLengthToFOV(cam.focalLength, 36);
  const fovRad = fov * Math.PI / 180;
  const tanHalfFov = Math.tan(fovRad / 2);
  const f = 1 / tanHalfFov;
  const nf = 1 / (nearClip - farClip);
  return [
    [f / aspectRatio, 0, 0, 0],
    [0, f, 0, 0],
    [0, 0, (farClip + nearClip) * nf, 2 * farClip * nearClip * nf],
    [0, 0, -1, 0]
  ];
}
function exportToMotionCtrl(camera, keyframes, frameCount) {
  const poses = [];
  for (let frame = 0; frame < frameCount; frame++) {
    const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(interpolated);
    poses.push({
      RT: viewMatrix
    });
  }
  return { camera_poses: poses };
}
function detectMotionCtrlSVDPreset(keyframes) {
  if (!keyframes || keyframes.length < 2) return "static";
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const threshold = 50;
  if (Math.abs(deltaZ) > threshold) {
    return deltaZ < 0 ? "zoom_in" : "zoom_out";
  }
  if (Math.abs(deltaRy) > 15) {
    return deltaRy > 0 ? "rotate_cw" : "rotate_ccw";
  }
  if (Math.abs(deltaX) > threshold) {
    return deltaX > 0 ? "pan_right" : "pan_left";
  }
  if (Math.abs(deltaY) > threshold) {
    return deltaY > 0 ? "pan_down" : "pan_up";
  }
  return "static";
}
function exportToMotionCtrlSVD(camera, keyframes, frameCount) {
  const preset = detectMotionCtrlSVDPreset(keyframes);
  if (preset !== "static" && keyframes.length <= 2) {
    return { motion_camera: preset };
  }
  const motionctrlData = exportToMotionCtrl(camera, keyframes, frameCount);
  return {
    motion_camera: preset,
    camera_poses: JSON.stringify(motionctrlData.camera_poses)
  };
}
function analyzeCameraMotion(keyframes) {
  if (!keyframes || keyframes.length < 2) {
    return {
      hasPan: false,
      panMagnitude: 0,
      hasZoom: false,
      zoomMagnitude: 0,
      hasOrbit: false,
      orbitMagnitude: 0,
      hasRotation: false,
      rotationMagnitude: 0
    };
  }
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const panThreshold = 30;
  const zoomThreshold = 50;
  const orbitThreshold = 20;
  let panDirection;
  const panX = Math.abs(deltaX);
  const panY = Math.abs(deltaY);
  if (panX > panThreshold || panY > panThreshold) {
    if (panX > panY) {
      panDirection = deltaX > 0 ? "right" : "left";
    } else {
      panDirection = deltaY > 0 ? "down" : "up";
    }
  }
  let zoomDirection;
  if (Math.abs(deltaZ) > zoomThreshold) {
    zoomDirection = deltaZ < 0 ? "in" : "out";
  }
  let orbitDirection;
  if (Math.abs(deltaRy) > orbitThreshold && Math.abs(deltaX) > panThreshold) {
    orbitDirection = deltaRy > 0 ? "right" : "left";
  }
  return {
    hasPan: !!panDirection,
    panDirection,
    panMagnitude: Math.max(panX, panY),
    hasZoom: !!zoomDirection,
    zoomDirection,
    zoomMagnitude: Math.abs(deltaZ),
    hasOrbit: !!orbitDirection,
    orbitDirection,
    orbitMagnitude: Math.abs(deltaRy),
    hasRotation: Math.abs(deltaRy) > 5,
    rotationMagnitude: Math.abs(deltaRy)
  };
}
function mapToWan22FunCamera(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  let preset = "Static";
  if (motion.hasOrbit) {
    preset = motion.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  } else if (motion.hasZoom && motion.hasPan) {
    const panDir = capitalize(motion.panDirection || "up");
    const zoomDir = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    preset = `Pan ${panDir} + ${zoomDir}`;
  } else if (motion.hasZoom) {
    preset = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
  } else if (motion.hasPan) {
    preset = `Pan ${capitalize(motion.panDirection || "up")}`;
  }
  return { camera_motion: preset };
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function detectUni3CTrajectoryType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (motion.hasOrbit && motion.orbitMagnitude > 45) {
    return "orbit";
  }
  if (motion.hasPan && motion.hasZoom) {
    return "custom";
  }
  if (!motion.hasPan && !motion.hasZoom && !motion.hasOrbit) {
    return "free1";
  }
  return "custom";
}
function exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight) {
  const detectedType = detectUni3CTrajectoryType(keyframes);
  if (detectedType !== "custom") {
    return { traj_type: detectedType };
  }
  const trajectory = [];
  const baseCamera = interpolateCameraAtFrame(camera, keyframes, 0);
  for (let frame = 0; frame < frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    trajectory.push({
      zoom: cam.zoom / baseCamera.zoom,
      x_offset: (cam.position.x - baseCamera.position.x) / compWidth,
      y_offset: (cam.position.y - baseCamera.position.y) / compHeight,
      z_offset: (cam.position.z - baseCamera.position.z) / 1e3,
      pitch: cam.rotation.x,
      yaw: cam.rotation.y,
      roll: cam.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: trajectory
  };
}
function detectCameraCtrlMotionType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (!motion.hasPan && !motion.hasZoom && !motion.hasRotation) {
    return "Static";
  }
  if (motion.hasZoom) {
    return motion.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  }
  if (motion.hasPan) {
    switch (motion.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  }
  if (motion.hasRotation) {
    const first = keyframes[0];
    const last = keyframes[keyframes.length - 1];
    const firstOri = first.orientation ?? { x: 0, y: 0, z: 0 };
    const lastOri = last.orientation ?? { x: 0, y: 0, z: 0 };
    const deltaRx = lastOri.x - firstOri.x;
    const deltaRy = lastOri.y - firstOri.y;
    const deltaRz = lastOri.z - firstOri.z;
    if (Math.abs(deltaRy) > Math.abs(deltaRx) && Math.abs(deltaRy) > Math.abs(deltaRz)) {
      return deltaRy > 0 ? "Rotate Right" : "Rotate Left";
    }
    if (Math.abs(deltaRx) > Math.abs(deltaRz)) {
      return deltaRx > 0 ? "Rotate Down" : "Rotate Up";
    }
    return deltaRz > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function exportToCameraCtrl(keyframes, frameCount) {
  const motionType = detectCameraCtrlMotionType(keyframes);
  const motion = analyzeCameraMotion(keyframes);
  let speed = 0;
  if (motion.hasZoom) {
    speed = Math.min(100, motion.zoomMagnitude / 5);
  } else if (motion.hasPan) {
    speed = Math.min(100, motion.panMagnitude / 3);
  } else if (motion.hasRotation) {
    speed = Math.min(100, motion.rotationMagnitude * 2);
  }
  return {
    motion_type: motionType,
    speed: Math.round(speed),
    frame_length: frameCount
  };
}
function exportCameraMatrices(camera, keyframes, options) {
  const frames = [];
  const aspectRatio = options.width / options.height;
  for (let frame = 0; frame < options.frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(cam);
    const projMatrix = computeProjectionMatrix(cam, aspectRatio);
    frames.push({
      frame,
      timestamp: frame / options.fps,
      view_matrix: viewMatrix,
      projection_matrix: projMatrix,
      position: [cam.position.x, cam.position.y, cam.position.z],
      rotation: [cam.rotation.x, cam.rotation.y, cam.rotation.z],
      fov: focalLengthToFOV(cam.focalLength, camera.filmSize),
      focal_length: cam.focalLength,
      focus_distance: cam.focusDistance
    });
  }
  return {
    frames,
    metadata: {
      width: options.width,
      height: options.height,
      fps: options.fps,
      total_frames: options.frameCount,
      camera_type: camera.type,
      film_size: camera.filmSize
    }
  };
}
function exportCameraForTarget(target, camera, keyframes, frameCount, compWidth = 1920, compHeight = 1080, fps = 24) {
  switch (target) {
    case "motionctrl":
      return exportToMotionCtrl(camera, keyframes, frameCount);
    case "motionctrl-svd":
      return exportToMotionCtrlSVD(camera, keyframes, frameCount);
    case "wan22-fun-camera":
      return mapToWan22FunCamera(keyframes);
    case "uni3c-camera":
    case "uni3c-motion":
      return exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight);
    case "animatediff-cameractrl":
      return exportToCameraCtrl(keyframes, frameCount);
    default:
      return exportCameraMatrices(camera, keyframes, {
        frameCount,
        width: compWidth,
        height: compHeight,
        fps
      });
  }
}

function createCameraLayer(store, name) {
  const comp = store.getActiveComp();
  const layers = store.getActiveCompLayers();
  const cameraId = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const cameraName = name || `Camera ${store.cameras.size + 1}`;
  const camera = createDefaultCamera(
    cameraId,
    comp?.settings.width || 1024,
    comp?.settings.height || 1024
  );
  camera.name = cameraName;
  store.cameras.set(cameraId, camera);
  if (!store.activeCameraId) {
    store.activeCameraId = cameraId;
  }
  const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const layer = {
    id: layerId,
    name: cameraName,
    type: "camera",
    visible: true,
    locked: false,
    solo: false,
    threeD: true,
    motionBlur: false,
    inPoint: 0,
    outPoint: (comp?.settings.frameCount || 81) - 1,
    parentId: null,
    blendMode: "normal",
    opacity: createAnimatableProperty("opacity", 100, "number"),
    transform: createDefaultTransform(),
    properties: [],
    effects: [],
    data: {
      cameraId,
      isActiveCamera: !store.activeCameraId || store.activeCameraId === cameraId
    }
  };
  layers.unshift(layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  store.selectLayer(layerId);
  return { camera, layer };
}
function getCamera(store, cameraId) {
  return store.cameras.get(cameraId) || null;
}
function updateCamera(store, cameraId, updates) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return;
  Object.assign(camera, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setActiveCamera(store, cameraId) {
  if (!store.cameras.has(cameraId)) return;
  store.activeCameraId = cameraId;
  const layers = store.getActiveCompLayers();
  for (const layer of layers) {
    if (layer.type === "camera" && layer.data) {
      const cameraData = layer.data;
      cameraData.isActiveCamera = cameraData.cameraId === cameraId;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteCamera(store, cameraId) {
  const layers = store.getActiveCompLayers();
  const layerIndex = layers.findIndex(
    (l) => l.type === "camera" && l.data?.cameraId === cameraId
  );
  if (layerIndex !== -1) {
    const layerId = layers[layerIndex].id;
    layers.splice(layerIndex, 1);
    useSelectionStore().removeFromSelection(layerId);
  }
  store.cameraKeyframes.delete(cameraId);
  store.cameras.delete(cameraId);
  if (store.activeCameraId === cameraId) {
    const remaining = Array.from(store.cameras.keys());
    store.activeCameraId = remaining.length > 0 ? remaining[0] : null;
    if (store.activeCameraId) {
      setActiveCamera(store, store.activeCameraId);
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getCameraKeyframes(store, cameraId) {
  return store.cameraKeyframes.get(cameraId) || [];
}
function addCameraKeyframe(store, cameraId, keyframe) {
  let keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) {
    keyframes = [];
    store.cameraKeyframes.set(cameraId, keyframes);
  }
  const existingIndex = keyframes.findIndex((k) => k.frame === keyframe.frame);
  if (existingIndex >= 0) {
    keyframes[existingIndex] = keyframe;
  } else {
    keyframes.push(keyframe);
    keyframes.sort((a, b) => a.frame - b.frame);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function removeCameraKeyframe(store, cameraId, frame) {
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) return;
  const index = keyframes.findIndex((k) => k.frame === frame);
  if (index >= 0) {
    keyframes.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function getCameraAtFrame(store, cameraId, frame) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return null;
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes || keyframes.length === 0) {
    return camera;
  }
  const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
  return {
    ...camera,
    position: interpolated.position,
    orientation: interpolated.rotation,
    focalLength: interpolated.focalLength,
    zoom: interpolated.zoom,
    depthOfField: {
      ...camera.depthOfField,
      focusDistance: interpolated.focusDistance
    }
  };
}
function getActiveCameraAtFrame(store, frame) {
  if (!store.activeCameraId) return null;
  return getCameraAtFrame(store, store.activeCameraId, frame ?? store.currentFrame);
}
function updateViewportState(store, updates) {
  Object.assign(store.viewportState, updates);
}
function updateViewOptions(store, updates) {
  Object.assign(store.viewOptions, updates);
}

function getApiBase() {
  return "";
}
async function segmentImage(request) {
  const response = await fetch(`${getApiBase()}/weyl/segment`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `Segmentation failed: ${response.status}`);
  }
  return response.json();
}
async function segmentByPoint(imageBase64, point, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points: [point],
    labels: [1]
    // Foreground
  });
}
async function segmentByBox(imageBase64, box, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "box",
    model,
    box
  });
}
async function segmentByMultiplePoints(imageBase64, foregroundPoints, backgroundPoints = [], model = "sam2") {
  const points = [...foregroundPoints, ...backgroundPoints];
  const labels = [
    ...foregroundPoints.map(() => 1),
    // Foreground
    ...backgroundPoints.map(() => 0)
    // Background
  ];
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points,
    labels
  });
}
async function autoSegment(imageBase64, options = {}) {
  return segmentImage({
    image: imageBase64,
    mode: "auto",
    model: options.model || "sam2",
    minArea: options.minArea || 100,
    maxMasks: options.maxMasks || 20
  });
}
function applyMaskToImage(sourceImageBase64, maskBase64, bounds) {
  return new Promise((resolve, reject) => {
    const sourceImg = new Image();
    const maskImg = new Image();
    let sourceLoaded = false;
    let maskLoaded = false;
    const checkComplete = () => {
      if (!sourceLoaded || !maskLoaded) return;
      try {
        const canvas = document.createElement("canvas");
        canvas.width = bounds.width;
        canvas.height = bounds.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = maskImg.width;
        maskCanvas.height = maskImg.height;
        const maskCtx = maskCanvas.getContext("2d");
        if (!maskCtx) {
          reject(new Error("Failed to get mask canvas context"));
          return;
        }
        maskCtx.drawImage(maskImg, 0, 0);
        const maskData = maskCtx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
        ctx.drawImage(
          sourceImg,
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
          0,
          0,
          bounds.width,
          bounds.height
        );
        const imageData = ctx.getImageData(0, 0, bounds.width, bounds.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          imageData.data[i + 3] = maskData.data[i];
        }
        ctx.putImageData(imageData, 0, 0);
        const resultBase64 = canvas.toDataURL("image/png").split(",")[1];
        resolve(resultBase64);
      } catch (err) {
        reject(err);
      }
    };
    sourceImg.onload = () => {
      sourceLoaded = true;
      checkComplete();
    };
    sourceImg.onerror = () => reject(new Error("Failed to load source image"));
    maskImg.onload = () => {
      maskLoaded = true;
      checkComplete();
    };
    maskImg.onerror = () => reject(new Error("Failed to load mask image"));
    sourceImg.src = `data:image/png;base64,${sourceImageBase64}`;
    maskImg.src = `data:image/png;base64,${maskBase64}`;
  });
}

async function createLayerFromMask(store, sourceImageBase64, mask, name, positionAtCenter = false) {
  try {
    const maskedImageBase64 = await applyMaskToImage(
      sourceImageBase64,
      mask.mask,
      mask.bounds
    );
    const assetId = `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const asset = {
      id: assetId,
      type: "image",
      source: "generated",
      width: mask.bounds.width,
      height: mask.bounds.height,
      data: maskedImageBase64
    };
    store.project.assets[assetId] = asset;
    const layer = store.createLayer("image", name || "Segmented");
    const imageData = {
      assetId,
      fit: "none",
      // Don't scale - use original size
      sourceType: "segmented"
    };
    layer.data = imageData;
    if (positionAtCenter) {
      layer.transform.position.value = {
        x: store.project.composition.width / 2,
        y: store.project.composition.height / 2
      };
    } else {
      layer.transform.position.value = {
        x: mask.bounds.x + mask.bounds.width / 2,
        y: mask.bounds.y + mask.bounds.height / 2
      };
    }
    layer.transform.anchorPoint.value = {
      x: mask.bounds.width / 2,
      y: mask.bounds.height / 2
    };
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
    storeLogger.info(`Created segmented layer: ${layer.name} (${mask.bounds.width}x${mask.bounds.height})`);
    return layer;
  } catch (err) {
    storeLogger.error("Failed to create layer from mask:", err);
    return null;
  }
}
async function segmentToLayerByPoint(store, point, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByPoint(sourceImage, point, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByBox(store, box, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByBox(sourceImage, box, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByMultiplePoints(store, foregroundPoints, backgroundPoints = [], options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByMultiplePoints(
      sourceImage,
      foregroundPoints,
      backgroundPoints,
      options.model || "sam2"
    );
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function autoSegmentToLayers(store, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return [];
  }
  try {
    const result = await autoSegment(sourceImage, {
      model: options.model || "sam2",
      minArea: options.minArea || 1e3,
      maxMasks: options.maxMasks || 10
    });
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Auto-segmentation failed:", result.message);
      return [];
    }
    const layers = [];
    const prefix = options.namePrefix || "Segment";
    for (let i = 0; i < result.masks.length; i++) {
      const mask = result.masks[i];
      const layer = await createLayerFromMask(
        store,
        sourceImage,
        mask,
        `${prefix} ${i + 1}`,
        false
        // Don't center - preserve original position
      );
      if (layer) {
        layers.push(layer);
      }
    }
    return layers;
  } catch (err) {
    storeLogger.error("Auto-segmentation error:", err);
    return [];
  }
}

function getAnimatableType(paramType) {
  switch (paramType) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const EFFECT_DEFINITIONS = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: true },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: true },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: true }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: true },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: false },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: false }
    ]
  },
  "sharpen": {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: true }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: true },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: true },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Use Legacy", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: false },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: true, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "curves": {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false }
      // Note: Actual curve control would be a custom component
    ]
  },
  "levels": {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: false },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: true },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "tint": {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  // Distort
  "transform": {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: true },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: true },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "warp": {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: false },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: false },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true }
    ]
  },
  // Generate
  "fill": {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: true },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: true },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: false },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  // Stylize
  "glow": {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: true },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: true },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: true },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: false },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: true }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: true },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: true },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: true },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: true },
      { name: "Shadow Only", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: false },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: false },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: true },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: true },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: true },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: true }
    ]
  }
};
const EFFECT_CATEGORIES = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  "distort": { label: "Distort", icon: "D", description: "Distortion effects" },
  "generate": { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  "keying": { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  "matte": { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  "perspective": { label: "Perspective", icon: "P", description: "3D perspective effects" },
  "stylize": { label: "Stylize", icon: "S", description: "Stylization effects" },
  "time": { label: "Time", icon: "T", description: "Time-based effects" },
  "transition": { label: "Transition", icon: "Tr", description: "Transition effects" },
  "utility": { label: "Utility", icon: "U", description: "Utility effects" }
};
function createEffectInstance(definitionKey) {
  const def = EFFECT_DEFINITIONS[definitionKey];
  if (!def) return null;
  const parameters = {};
  def.parameters.forEach((param, index) => {
    const paramKey = param.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    parameters[paramKey] = {
      id: `${definitionKey}-${paramKey}-${index}`,
      name: param.name,
      type: getAnimatableType(param.type),
      value: param.defaultValue,
      animated: false,
      keyframes: []
    };
  });
  return {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: definitionKey,
    name: def.name,
    category: def.category,
    enabled: true,
    expanded: true,
    parameters
  };
}
const ANIMATION_PRESETS = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];

function addEffectToLayer(store, layerId, effectKey) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const effect = createEffectInstance(effectKey);
  if (!effect) return;
  if (!layer.effects) {
    layer.effects = [];
  }
  layer.effects.push(effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function removeEffectFromLayer(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const index = layer.effects.findIndex((e) => e.id === effectId);
  if (index >= 0) {
    layer.effects.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
  }
}
function updateEffectParameter(store, layerId, effectId, paramKey, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  effect.parameters[paramKey].value = value;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setEffectParamAnimated(store, layerId, effectId, paramKey, animated) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  const param = effect.parameters[paramKey];
  param.animated = animated;
  if (animated && (!param.keyframes || param.keyframes.length === 0)) {
    param.keyframes = [{
      id: `kf_${Date.now()}`,
      frame: store.currentFrame,
      value: param.value,
      interpolation: "linear",
      inHandle: { frame: -5, value: 0, enabled: false },
      outHandle: { frame: 5, value: 0, enabled: false },
      controlMode: "smooth"
    }];
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleEffect(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect) return;
  effect.enabled = !effect.enabled;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function reorderEffects(store, layerId, fromIndex, toIndex) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  if (fromIndex < 0 || fromIndex >= layer.effects.length) return;
  if (toIndex < 0 || toIndex >= layer.effects.length) return;
  const [effect] = layer.effects.splice(fromIndex, 1);
  layer.effects.splice(toIndex, 0, effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getEffectParameterValue(store, layerId, effectId, paramKey, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return null;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return null;
  const param = effect.parameters[paramKey];
  const targetFrame = frame ?? (store.getActiveComp()?.currentFrame ?? 0);
  if (param.animated && param.keyframes.length > 0) {
    return interpolateProperty(param, targetFrame);
  }
  return param.value;
}

const usePlaybackStore = defineStore("playback", {
  state: () => ({
    isPlaying: false,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    loopPlayback: true
  }),
  getters: {
    playing: (state) => state.isPlaying
  },
  actions: {
    /**
     * Start playback
     * @param fps - Frames per second
     * @param frameCount - Total frame count
     * @param currentFrame - Starting frame
     * @param onFrame - Callback for each frame
     */
    play(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) return;
      this.isPlaying = true;
      this.playbackStartTime = performance.now();
      this.playbackStartFrame = currentFrame;
      const frameDuration = 1e3 / fps;
      let lastFrameTime = this.playbackStartTime;
      const tick = (now) => {
        if (!this.isPlaying) return;
        const elapsed = now - lastFrameTime;
        if (elapsed >= frameDuration) {
          const framesToAdvance = Math.floor(elapsed / frameDuration);
          let newFrame = currentFrame + framesToAdvance;
          if (newFrame >= frameCount) {
            if (this.loopPlayback) {
              newFrame = newFrame % frameCount;
            } else {
              newFrame = frameCount - 1;
              this.stop();
              onFrame(newFrame);
              return;
            }
          }
          currentFrame = newFrame;
          lastFrameTime = now - elapsed % frameDuration;
          onFrame(currentFrame);
        }
        this.playbackRequestId = requestAnimationFrame(tick);
      };
      this.playbackRequestId = requestAnimationFrame(tick);
      storeLogger.debug("Playback started at frame", currentFrame);
    },
    /**
     * Stop playback
     */
    stop() {
      if (this.playbackRequestId !== null) {
        cancelAnimationFrame(this.playbackRequestId);
        this.playbackRequestId = null;
      }
      this.isPlaying = false;
      this.playbackStartTime = null;
      storeLogger.debug("Playback stopped");
    },
    /**
     * Toggle playback
     */
    toggle(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) {
        this.stop();
      } else {
        this.play(fps, frameCount, currentFrame, onFrame);
      }
    },
    /**
     * Set loop playback mode
     */
    setLoopPlayback(loop) {
      this.loopPlayback = loop;
    },
    /**
     * Go to first frame
     */
    goToStart(onFrame) {
      this.stop();
      onFrame(0);
    },
    /**
     * Go to last frame
     */
    goToEnd(frameCount, onFrame) {
      this.stop();
      onFrame(frameCount - 1);
    },
    /**
     * Step forward one frame
     */
    stepForward(currentFrame, frameCount, onFrame) {
      this.stop();
      const newFrame = Math.min(currentFrame + 1, frameCount - 1);
      onFrame(newFrame);
    },
    /**
     * Step backward one frame
     */
    stepBackward(currentFrame, onFrame) {
      this.stop();
      const newFrame = Math.max(currentFrame - 1, 0);
      onFrame(newFrame);
    },
    /**
     * Jump to specific frame
     */
    goToFrame(frame, frameCount, onFrame) {
      const clampedFrame = Math.max(0, Math.min(frame, frameCount - 1));
      onFrame(clampedFrame);
    }
  }
});

const useCompositorStore = defineStore("compositor", {
  state: () => ({
    project: createEmptyProject(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: false,
    segmentToolActive: false,
    segmentMode: "point",
    segmentPendingMask: null,
    segmentBoxStart: null,
    segmentIsLoading: false,
    graphEditorVisible: false,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioVolume: 100,
    audioMuted: false,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: createDefaultViewportState(),
    viewOptions: createDefaultViewOptions(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...DEFAULT_SNAP_CONFIG },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    },
    // Autosave (enabled by default, every 60 seconds)
    autosaveEnabled: true,
    autosaveIntervalMs: 6e4,
    autosaveTimerId: null,
    lastSaveTime: null,
    lastSaveProjectId: null,
    hasUnsavedChanges: false,
    // Frame cache (enabled by default)
    frameCacheEnabled: true,
    projectStateHash: ""
  }),
  getters: {
    // Active composition helper
    activeComposition: (state) => {
      return state.project.compositions[state.activeCompositionId] || null;
    },
    // Project info - now uses active composition
    hasProject: (state) => state.sourceImage !== null,
    width(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.width || 1024;
    },
    height(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.height || 1024;
    },
    frameCount(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.frameCount || 81;
    },
    fps(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.fps || 16;
    },
    duration(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.duration || 5;
    },
    // Current frame - per composition
    currentFrame(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.currentFrame || 0;
    },
    currentTime(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      if (!comp) return 0;
      return comp.currentFrame / comp.settings.fps;
    },
    // Layers - from active composition
    layers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.layers || [];
    },
    visibleLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.visible);
    },
    // Selection (delegated to selectionStore)
    selectedLayerIds() {
      return useSelectionStore().selectedLayerIds;
    },
    selectedKeyframeIds() {
      return useSelectionStore().selectedKeyframeIds;
    },
    selectedPropertyPath() {
      return useSelectionStore().selectedPropertyPath;
    },
    currentTool(state) {
      if (state.segmentToolActive) return "segment";
      return useSelectionStore().currentTool;
    },
    selectedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      const selectionStore = useSelectionStore();
      return (comp?.layers || []).filter((l) => selectionStore.selectedLayerIds.includes(l.id));
    },
    selectedLayer(state) {
      const selectionStore = useSelectionStore();
      if (selectionStore.selectedLayerIds.length !== 1) return null;
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).find((l) => l.id === selectionStore.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (state) => {
      return Object.values(state.project.compositions);
    },
    openCompositions(state) {
      return state.openCompositionIds.map((id) => state.project.compositions[id]).filter(Boolean);
    },
    // Assets
    assets: (state) => state.project.assets,
    // History
    canUndo: (state) => state.historyIndex > 0,
    canRedo: (state) => state.historyIndex < state.historyStack.length - 1,
    // Camera
    activeCamera: (state) => {
      if (!state.activeCameraId) return null;
      return state.cameras.get(state.activeCameraId) || null;
    },
    allCameras: (state) => Array.from(state.cameras.values()),
    cameraLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const comp = this.project.compositions[this.activeCompositionId];
      return comp?.layers || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(name, settings, isPrecomp = false) {
      const id = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const activeComp = this.project.compositions[this.activeCompositionId];
      const defaultSettings = {
        width: settings?.width ?? activeComp?.settings.width ?? 1024,
        height: settings?.height ?? activeComp?.settings.height ?? 1024,
        frameCount: settings?.frameCount ?? activeComp?.settings.frameCount ?? 81,
        fps: settings?.fps ?? activeComp?.settings.fps ?? 16,
        duration: 0,
        backgroundColor: settings?.backgroundColor ?? "#000000",
        autoResizeToContent: settings?.autoResizeToContent ?? true
      };
      defaultSettings.duration = defaultSettings.frameCount / defaultSettings.fps;
      const composition = {
        id,
        name,
        settings: defaultSettings,
        layers: [],
        currentFrame: 0,
        isPrecomp
      };
      this.project.compositions[id] = composition;
      if (!this.openCompositionIds.includes(id)) {
        this.openCompositionIds.push(id);
      }
      this.activeCompositionId = id;
      storeLogger.debug("Created composition:", name, id);
      return composition;
    },
    /**
     * Delete a composition
     */
    deleteComposition(compId) {
      if (compId === this.project.mainCompositionId) {
        storeLogger.warn("Cannot delete main composition");
        return false;
      }
      const comp = this.project.compositions[compId];
      if (!comp) return false;
      delete this.project.compositions[compId];
      const openIdx = this.openCompositionIds.indexOf(compId);
      if (openIdx >= 0) {
        this.openCompositionIds.splice(openIdx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId;
      }
      storeLogger.debug("Deleted composition:", compId);
      return true;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Composition not found:", compId);
        return;
      }
      if (!this.openCompositionIds.includes(compId)) {
        this.openCompositionIds.push(compId);
      }
      const selection = useSelectionStore();
      selection.clearLayerSelection();
      selection.clearKeyframeSelection();
      this.activeCompositionId = compId;
      storeLogger.debug("Switched to composition:", compId);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(compId) {
      if (this.openCompositionIds.length <= 1) {
        storeLogger.warn("Cannot close the last tab");
        return;
      }
      const idx = this.openCompositionIds.indexOf(compId);
      if (idx >= 0) {
        this.openCompositionIds.splice(idx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[Math.max(0, idx - 1)];
      }
    },
    /**
     * Rename a composition
     */
    renameComposition(compId, newName) {
      const comp = this.project.compositions[compId];
      if (comp) {
        comp.name = newName;
      }
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(compId, settings) {
      const comp = this.project.compositions[compId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      Object.assign(comp.settings, settings);
      comp.settings.duration = comp.settings.frameCount / comp.settings.fps;
      if (settings.frameCount && settings.frameCount > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = settings.frameCount - 1;
          }
        }
      }
      if (compId === this.project.mainCompositionId) {
        Object.assign(this.project.composition, comp.settings);
      }
    },
    /**
     * Get a composition by ID
     */
    getComposition(compId) {
      return this.project.compositions[compId] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(name) {
      if (this.selectedLayerIds.length === 0) {
        storeLogger.warn("No layers selected for pre-compose");
        return null;
      }
      const activeComp = this.project.compositions[this.activeCompositionId];
      if (!activeComp) return null;
      const precomp = this.createComposition(
        name || "Pre-comp",
        activeComp.settings,
        true
      );
      const selectedLayers = activeComp.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      );
      const earliestIn = Math.min(...selectedLayers.map((l) => l.inPoint));
      for (const layer of selectedLayers) {
        layer.inPoint -= earliestIn;
        layer.outPoint -= earliestIn;
        const idx = activeComp.layers.indexOf(layer);
        if (idx >= 0) {
          activeComp.layers.splice(idx, 1);
        }
        precomp.layers.push(layer);
      }
      const maxOut = Math.max(...precomp.layers.map((l) => l.outPoint));
      precomp.settings.frameCount = maxOut + 1;
      precomp.settings.duration = precomp.settings.frameCount / precomp.settings.fps;
      const precompLayer = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: precomp.name,
        type: "precomp",
        visible: true,
        locked: false,
        solo: false,
        threeD: false,
        inPoint: earliestIn,
        outPoint: earliestIn + precomp.settings.frameCount - 1,
        parentId: null,
        transform: createDefaultTransform(),
        opacity: createAnimatableProperty("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: false,
        data: {
          compositionId: precomp.id,
          timeRemapEnabled: false,
          collapseTransformations: false
        }
      };
      activeComp.layers.push(precompLayer);
      useSelectionStore().clearLayerSelection();
      this.activeCompositionId = activeComp.id;
      storeLogger.debug("Pre-composed layers into:", precomp.name);
      return precomp;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(inputs) {
      this.comfyuiNodeId = inputs.node_id;
      this.sourceImage = inputs.source_image;
      this.depthMap = inputs.depth_map;
      const comp = this.project.compositions[this.activeCompositionId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = inputs.width;
      comp.settings.height = inputs.height;
      comp.settings.frameCount = inputs.frame_count;
      comp.settings.duration = inputs.frame_count / comp.settings.fps;
      this.project.composition.width = inputs.width;
      this.project.composition.height = inputs.height;
      this.project.composition.frameCount = inputs.frame_count;
      this.project.composition.duration = inputs.frame_count / this.project.composition.fps;
      if (inputs.frame_count > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = inputs.frame_count - 1;
          }
        }
      }
      if (inputs.source_image) {
        this.project.assets["source_image"] = {
          id: "source_image",
          type: "image",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.source_image
        };
      }
      if (inputs.depth_map) {
        this.project.assets["depth_map"] = {
          id: "depth_map",
          type: "depth_map",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.depth_map
        };
      }
      if (comp) comp.currentFrame = 0;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      storeLogger.debug("Loaded inputs from ComfyUI:", {
        width: inputs.width,
        height: inputs.height,
        frameCount: inputs.frame_count
      });
      this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(type, name) {
      const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let layerData = null;
      switch (type) {
        case "text":
          layerData = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: false,
            pathPerpendicularToPath: true,
            pathForceAlignment: false,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          layerData = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          layerData = {
            size: 40
          };
          break;
        case "spline":
          layerData = {
            pathData: "",
            controlPoints: [],
            closed: false,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          layerData = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: false,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: true,
              burstOnBeat: false,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: false,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: false,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: false,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: false,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: true
              }
            }
          };
          break;
        case "depthflow":
          layerData = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: false
            }
          };
          break;
        case "light":
          layerData = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: false,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          layerData = {
            cameraId: null,
            isActiveCamera: false
          };
          break;
        case "image":
          layerData = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          layerData = {
            assetId: null,
            loop: false,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let audioProps = void 0;
      if (type === "video" || type === "audio") {
        audioProps = {
          level: createAnimatableProperty("Audio Levels", 0, "number")
          // 0dB default
        };
      }
      const comp = this.getActiveComp();
      const layers = this.getActiveCompLayers();
      const layer = {
        id,
        name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
        type,
        visible: true,
        locked: false,
        solo: false,
        threeD: false,
        motionBlur: false,
        inPoint: 0,
        outPoint: (comp?.settings.frameCount || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: createAnimatableProperty("opacity", 100, "number"),
        transform: createDefaultTransform(),
        audio: audioProps,
        properties: [],
        effects: [],
        data: layerData
      };
      if (type === "camera") {
        storeLogger.warn("Use createCameraLayer() for camera layers");
      }
      layers.unshift(layer);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Delete a layer
     */
    deleteLayer(layerId) {
      deleteLayer(this, layerId);
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(layerId) {
      return duplicateLayer(this, layerId);
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      copySelectedLayers(this);
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      return pasteLayers(this);
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      cutSelectedLayers(this);
    },
    /**
     * Update layer properties
     */
    updateLayer(layerId, updates) {
      updateLayer(this, layerId, updates);
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(layerId, dataUpdates) {
      updateLayerData(this, layerId, dataUpdates);
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(layerId, point) {
      addSplineControlPoint(this, layerId, point);
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(layerId, pointId, updates) {
      updateSplineControlPoint(this, layerId, pointId, updates);
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(layerId, pointId) {
      deleteSplineControlPoint(this, layerId, pointId);
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(layerId) {
      toggleLayer3D(this, layerId);
    },
    /**
     * Reorder layers
     */
    moveLayer(layerId, newIndex) {
      moveLayer(this, layerId, newIndex);
    },
    /**
     * Selection
     */
    selectLayer(layerId, addToSelection = false) {
      selectLayer(this, layerId, addToSelection);
    },
    deselectLayer(layerId) {
      deselectLayer(this, layerId);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(layerId, parentId) {
      setLayerParent(this, layerId, parentId);
    },
    clearSelection() {
      const selection = useSelectionStore();
      selection.clearAll();
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(propertyPath) {
      useSelectionStore().setSelectedPropertyPath(propertyPath);
    },
    // ============================================================
    // MOTION ENGINE INTEGRATION
    // ============================================================
    /**
     * Get evaluated FrameState for the current frame
     *
     * This is the CANONICAL way to get evaluated state for rendering.
     * Uses MotionEngine.evaluate() which is PURE and deterministic.
     *
     * @param frame - Optional frame override (defaults to currentFrame)
     * @returns Immutable FrameState snapshot
     */
    getFrameState(frame) {
      const comp = this.getActiveComp();
      const targetFrame = frame ?? (comp?.currentFrame ?? 0);
      return motionEngine.evaluate(
        targetFrame,
        this.project,
        this.audioAnalysis,
        this.activeCameraId
      );
    },
    // ============================================================
    // PLAYBACK CONTROLS
    // ============================================================
    /**
     * Start playback
     * NOTE: This only updates UI state (currentFrame).
     * Actual frame evaluation happens via getFrameState().
     */
    play() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) return;
      const comp = this.getActiveComp();
      if (!comp) return;
      playback.play(
        comp.settings.fps,
        comp.settings.frameCount,
        comp.currentFrame,
        (frame) => {
          comp.currentFrame = frame;
        }
      );
      this.isPlaying = true;
    },
    /**
     * Pause playback
     */
    pause() {
      const playback = usePlaybackStore();
      playback.stop();
      this.isPlaying = false;
    },
    /**
     * Toggle playback state
     */
    togglePlayback() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) {
        this.pause();
      } else {
        this.play();
      }
    },
    /**
     * Set current frame (UI state only)
     * Components watching currentFrame should call getFrameState() to evaluate.
     */
    setFrame(frame) {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
    },
    /**
     * Advance to next frame (UI state only)
     */
    nextFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame < comp.settings.frameCount - 1) {
        comp.currentFrame++;
      }
    },
    /**
     * Go to previous frame (UI state only)
     */
    prevFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame > 0) {
        comp.currentFrame--;
      }
    },
    /**
     * Jump to first frame (UI state only)
     */
    goToStart() {
      const comp = this.getActiveComp();
      if (comp) comp.currentFrame = 0;
    },
    /**
     * Jump to last frame (UI state only)
     */
    goToEnd() {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = comp.settings.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(tool) {
      if (tool === "segment") {
        this.segmentToolActive = true;
      } else {
        this.segmentToolActive = false;
        useSelectionStore().setTool(tool);
        this.clearSegmentPendingMask();
      }
    },
    /**
     * Set segmentation mode (point or box)
     */
    setSegmentMode(mode) {
      this.segmentMode = mode;
      this.clearSegmentPendingMask();
    },
    /**
     * Clear pending segmentation mask
     */
    clearSegmentPendingMask() {
      this.segmentPendingMask = null;
      this.segmentBoxStart = null;
    },
    /**
     * Set pending segmentation mask (preview before creating layer)
     */
    setSegmentPendingMask(mask) {
      this.segmentPendingMask = mask;
    },
    /**
     * Set box selection start point
     */
    setSegmentBoxStart(point) {
      this.segmentBoxStart = point;
    },
    /**
     * Set segmentation loading state
     */
    setSegmentLoading(loading) {
      this.segmentIsLoading = loading;
    },
    /**
     * Confirm pending mask and create layer from it
     */
    async confirmSegmentMask(layerName) {
      if (!this.segmentPendingMask || !this.sourceImage) {
        return null;
      }
      const layer = await createLayerFromMask(
        this,
        this.sourceImage,
        this.segmentPendingMask,
        layerName,
        false
      );
      this.clearSegmentPendingMask();
      return layer;
    },
    /**
     * History management
     */
    pushHistory() {
      pushHistory(this);
    },
    undo() {
      undo(this);
    },
    redo() {
      redo(this);
    },
    /**
     * Project serialization
     */
    exportProject() {
      return exportProject(this);
    },
    importProject(json) {
      importProject(this, json, () => this.pushHistory());
    },
    /**
     * Save project to server (ComfyUI backend)
     */
    async saveProjectToServer(projectId) {
      return saveProjectToServer(this, projectId);
    },
    /**
     * Load project from server (ComfyUI backend)
     */
    async loadProjectFromServer(projectId) {
      return loadProjectFromServer(this, projectId, () => this.pushHistory());
    },
    /**
     * List all projects saved on server
     */
    async listServerProjects() {
      return listServerProjects();
    },
    /**
     * Delete a project from server
     */
    async deleteServerProject(projectId) {
      return deleteServerProject(projectId);
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(property) {
      return interpolateProperty(property, this.getActiveComp()?.currentFrame ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(layerId, propertyName, value, atFrame) {
      return addKeyframe(this, layerId, propertyName, value, atFrame);
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(layerId, propertyName, keyframeId) {
      removeKeyframe(this, layerId, propertyName, keyframeId);
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(layerId, propertyPath, value) {
      setPropertyValue(this, layerId, propertyPath, value);
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(layerId, propertyPath, animated) {
      setPropertyAnimated(this, layerId, propertyPath, animated, () => {
        this.addKeyframe(layerId, propertyPath, findPropertyByPath(
          this.getActiveCompLayers().find((l) => l.id === layerId),
          propertyPath
        )?.value);
      });
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(layerId, propertyPath, keyframeId, newFrame) {
      moveKeyframe(this, layerId, propertyPath, keyframeId, newFrame);
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(layerId, propertyPath, keyframeId, newValue) {
      setKeyframeValue(this, layerId, propertyPath, keyframeId, newValue);
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(layerId, propertyPath, keyframeId, interpolation) {
      setKeyframeInterpolation(this, layerId, propertyPath, keyframeId, interpolation);
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(layerId, propertyPath, keyframeId, updates) {
      updateKeyframe(this, layerId, propertyPath, keyframeId, updates);
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(layerId, propertyPath, keyframeId, handleType, handle) {
      setKeyframeHandle(this, layerId, propertyPath, keyframeId, handleType, handle);
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(text = "Text") {
      const layer = this.createLayer("text", text.substring(0, 20));
      const textData = {
        text,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: false
      };
      layer.data = textData;
      layer.properties.push(createAnimatableProperty("Font Size", 72, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Fill Color", "#ffffff", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Color", "#000000", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Width", 0, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Path Offset", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("First Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Last Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options"));
      layer.properties.push(createAnimatableProperty("Tracking", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Line Spacing", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Offset", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Value", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Blur", { x: 0, y: 0 }, "position", "Advanced"));
      return layer;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const layer = this.createLayer("spline");
      const splineData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      layer.data = splineData;
      return layer;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const layer = this.createLayer("particles", "Particle System");
      const particleData = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20,
          // Geometric emitter shape defaults
          shape: "point",
          shapeRadius: 0.1,
          shapeWidth: 0.2,
          shapeHeight: 0.2,
          shapeDepth: 0.2,
          shapeInnerRadius: 0.05,
          emitFromEdge: false,
          emitFromVolume: false,
          // Spline path emission (null = disabled)
          splinePath: null,
          // Sprite configuration
          sprite: {
            enabled: false,
            imageUrl: null,
            imageData: null,
            isSheet: false,
            columns: 1,
            rows: 1,
            totalFrames: 1,
            frameRate: 30,
            playMode: "loop",
            billboard: true,
            rotationEnabled: false,
            rotationSpeed: 0,
            rotationSpeedVariance: 0,
            alignToVelocity: false
          }
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      layer.data = particleData;
      return layer;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(layerId, config) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters.push(config);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(layerId, emitterId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      const emitter = data.emitters.find((e) => e.id === emitterId);
      if (emitter) {
        Object.assign(emitter, updates);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(layerId, emitterId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters = data.emitters.filter((e) => e.id !== emitterId);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(sourceLayerId = "", depthLayerId = "") {
      const layer = this.createLayer("depthflow", "Depthflow");
      const depthflowData = {
        sourceLayerId,
        depthLayerId,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        },
        animatedZoom: createAnimatableProperty("zoom", 1, "number"),
        animatedOffsetX: createAnimatableProperty("offsetX", 0, "number"),
        animatedOffsetY: createAnimatableProperty("offsetY", 0, "number"),
        animatedRotation: createAnimatableProperty("rotation", 0, "number"),
        animatedDepthScale: createAnimatableProperty("depthScale", 1, "number")
      };
      layer.data = depthflowData;
      return layer;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "depthflow") return;
      const data = layer.data;
      Object.assign(data.config, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(file, autoResizeComposition = true) {
      let videoUrl;
      try {
        videoUrl = URL.createObjectURL(file);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let metadata;
      try {
        metadata = await extractVideoMetadata(videoUrl);
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        throw new Error(`Failed to load video metadata: ${error.message}`);
      }
      const assetId = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const asset = {
        id: assetId,
        type: "video",
        source: "file",
        width: metadata.width,
        height: metadata.height,
        data: videoUrl,
        // Video-specific metadata
        duration: metadata.duration,
        frameCount: metadata.frameCount,
        fps: metadata.fps,
        hasAudio: metadata.hasAudio
      };
      this.project.assets[assetId] = asset;
      if (autoResizeComposition) {
        const compSettings = calculateCompositionFromVideo(metadata, this.project.composition.fps);
        storeLogger.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: compSettings.width,
          newHeight: compSettings.height,
          newFrameCount: compSettings.frameCount,
          videoDuration: metadata.duration
        });
        this.project.composition.width = compSettings.width;
        this.project.composition.height = compSettings.height;
        this.project.composition.frameCount = compSettings.frameCount;
        this.project.composition.duration = compSettings.frameCount / this.project.composition.fps;
      }
      const layer = this.createLayer("video", file.name.replace(/\.[^.]+$/, ""));
      const videoData = {
        assetId,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: metadata.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      layer.data = videoData;
      if (!autoResizeComposition) {
        const videoFrameCount = Math.ceil(metadata.duration * this.project.composition.fps);
        layer.outPoint = Math.min(videoFrameCount - 1, this.project.composition.frameCount - 1);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Created video layer:", {
        layerId: layer.id,
        assetId,
        dimensions: `${metadata.width}x${metadata.height}`,
        duration: `${metadata.duration.toFixed(2)}s`,
        frameCount: metadata.frameCount,
        hasAudio: metadata.hasAudio
      });
      return layer;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(layerId, metadata) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const videoData = layer.data;
      if (!videoData.assetId) return;
      const asset = this.project.assets[videoData.assetId];
      if (asset) {
        asset.width = metadata.width;
        asset.height = metadata.height;
        asset.duration = metadata.duration;
        asset.frameCount = metadata.frameCount;
        asset.fps = metadata.fps;
        asset.hasAudio = metadata.hasAudio;
      }
      storeLogger.debug("Video metadata loaded:", { layerId, metadata });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(width, height, frameCount) {
      const comp = this.getActiveComp();
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = width;
      comp.settings.height = height;
      this.project.composition.width = width;
      this.project.composition.height = height;
      if (frameCount !== void 0) {
        comp.settings.frameCount = frameCount;
        comp.settings.duration = frameCount / comp.settings.fps;
        this.project.composition.frameCount = frameCount;
        this.project.composition.duration = frameCount / this.project.composition.fps;
        if (frameCount > oldFrameCount) {
          for (const layer of comp.layers) {
            if (layer.outPoint === oldFrameCount - 1) {
              layer.outPoint = frameCount - 1;
            }
          }
        }
      }
      if (comp.currentFrame >= comp.settings.frameCount) {
        comp.currentFrame = comp.settings.frameCount - 1;
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Composition resized:", {
        width,
        height,
        frameCount: comp.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(compositionId, name) {
      const layer = this.createLayer("precomp", name || "Precomp");
      const precompData = {
        compositionId,
        timeRemapEnabled: false,
        timeRemap: void 0,
        collapseTransformations: false,
        overrideFrameRate: false,
        frameRate: void 0
      };
      layer.data = precompData;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "precomp") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // SEGMENTATION ACTIONS (delegated to segmentationActions)
    // ============================================================
    async segmentToLayerByPoint(point, options = {}) {
      return segmentToLayerByPoint(this, point, options);
    },
    async segmentToLayerByBox(box, options = {}) {
      return segmentToLayerByBox(this, box, options);
    },
    async segmentToLayerByMultiplePoints(foregroundPoints, backgroundPoints = [], options = {}) {
      return segmentToLayerByMultiplePoints(this, foregroundPoints, backgroundPoints, options);
    },
    async autoSegmentToLayers(options = {}) {
      return autoSegmentToLayers(this, options);
    },
    // ============================================================
    // EFFECT ACTIONS (delegated to effectActions)
    // ============================================================
    addEffectToLayer(layerId, effectKey) {
      addEffectToLayer(this, layerId, effectKey);
    },
    removeEffectFromLayer(layerId, effectId) {
      removeEffectFromLayer(this, layerId, effectId);
    },
    updateEffectParameter(layerId, effectId, paramKey, value) {
      updateEffectParameter(this, layerId, effectId, paramKey, value);
    },
    setEffectParamAnimated(layerId, effectId, paramKey, animated) {
      setEffectParamAnimated(this, layerId, effectId, paramKey, animated);
    },
    toggleEffect(layerId, effectId) {
      toggleEffect(this, layerId, effectId);
    },
    reorderEffects(layerId, fromIndex, toIndex) {
      reorderEffects(this, layerId, fromIndex, toIndex);
    },
    getEffectParameterValue(layerId, effectId, paramKey, frame) {
      return getEffectParameterValue(this, layerId, effectId, paramKey, frame);
    },
    // ============================================================
    // CAMERA ACTIONS (delegated to cameraActions module)
    // ============================================================
    createCameraLayer(name) {
      return createCameraLayer(this, name);
    },
    getCamera(cameraId) {
      return getCamera(this, cameraId);
    },
    updateCamera(cameraId, updates) {
      updateCamera(this, cameraId, updates);
    },
    setActiveCamera(cameraId) {
      setActiveCamera(this, cameraId);
    },
    deleteCamera(cameraId) {
      deleteCamera(this, cameraId);
    },
    getCameraKeyframes(cameraId) {
      return getCameraKeyframes(this, cameraId);
    },
    addCameraKeyframe(cameraId, keyframe) {
      addCameraKeyframe(this, cameraId, keyframe);
    },
    removeCameraKeyframe(cameraId, frame) {
      removeCameraKeyframe(this, cameraId, frame);
    },
    getCameraAtFrame(cameraId, frame) {
      return getCameraAtFrame(this, cameraId, frame);
    },
    getActiveCameraAtFrame(frame) {
      return getActiveCameraAtFrame(this, frame);
    },
    updateViewportState(updates) {
      updateViewportState(this, updates);
    },
    updateViewOptions(updates) {
      updateViewOptions(this, updates);
    },
    // ============================================================
    // AUDIO ACTIONS (delegated to audioActions module)
    // ============================================================
    async loadAudio(file) {
      return loadAudio(this, file);
    },
    cancelAudioLoad() {
      cancelAudioLoad(this);
    },
    clearAudio() {
      clearAudio(this);
    },
    setAudioVolume(volume) {
      this.audioVolume = Math.max(0, Math.min(100, volume));
    },
    setAudioMuted(muted) {
      this.audioMuted = muted;
    },
    toggleAudioMute() {
      this.audioMuted = !this.audioMuted;
    },
    getAudioFeatureAtFrame(feature, frame) {
      return getAudioFeatureAtFrame(this, feature, frame);
    },
    applyAudioToParticles(layerId, mapping) {
      applyAudioToParticles(this, layerId, mapping);
    },
    removeLegacyAudioMapping(layerId, index) {
      removeLegacyAudioMapping(this, layerId, index);
    },
    getAudioMappingsForLayer(layerId) {
      return getAudioMappingsForLayer(this, layerId);
    },
    setPeakData(peakData) {
      setPeakData(this, peakData);
    },
    detectAudioPeaks(config) {
      return detectAudioPeaks(this, config);
    },
    addAudioMapping(mapping) {
      addAudioMapping(this, mapping);
    },
    removeAudioMapping(mappingId) {
      removeAudioMapping(this, mappingId);
    },
    updateAudioMapping(mappingId, updates) {
      updateAudioMapping(this, mappingId, updates);
    },
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    getMappedValueAtFrame(mappingId, frame) {
      return getMappedValueAtFrame(this, mappingId, frame);
    },
    getAllMappedValuesAtFrame(frame) {
      return getAllMappedValuesAtFrame(this, frame);
    },
    getActiveMappingsForLayer(layerId) {
      return getActiveMappingsForLayer(this, layerId);
    },
    getAudioReactiveValuesForLayer(layerId, frame) {
      return getAudioReactiveValuesForLayer(this, layerId, frame);
    },
    isBeatAtCurrentFrame() {
      return isBeatAtCurrentFrame(this);
    },
    // Timeline snapping (simple inline - no need for delegation)
    findSnapPoint(frame, pixelsPerFrame, selectedLayerId) {
      return findNearestSnap(frame, this.snapConfig, pixelsPerFrame, {
        layers: this.layers,
        selectedLayerId,
        currentFrame: this.getActiveComp()?.currentFrame ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    getAudioBeatFrames() {
      return getBeatFrames(this.audioAnalysis);
    },
    getAudioPeakFrames() {
      return getPeakFrames(this.peakData);
    },
    setSnapConfig(config) {
      this.snapConfig = { ...this.snapConfig, ...config };
    },
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    toggleSnapType(type) {
      const typeMap = {
        "grid": "snapToGrid",
        "keyframes": "snapToKeyframes",
        "beats": "snapToBeats",
        "peaks": "snapToPeaks",
        "layerBounds": "snapToLayerBounds",
        "playhead": "snapToPlayhead"
      };
      const key = typeMap[type];
      if (key && typeof this.snapConfig[key] === "boolean") {
        this.snapConfig[key] = !this.snapConfig[key];
      }
    },
    // Path animator (delegated to audioActions module)
    createPathAnimator(layerId, config = {}) {
      createPathAnimator(this, layerId, config);
    },
    setPathAnimatorPath(layerId, pathData) {
      setPathAnimatorPath(this, layerId, pathData);
    },
    updatePathAnimatorConfig(layerId, config) {
      updatePathAnimatorConfig(this, layerId, config);
    },
    removePathAnimator(layerId) {
      removePathAnimator(this, layerId);
    },
    getPathAnimator(layerId) {
      return getPathAnimator(this, layerId);
    },
    updatePathAnimators() {
      updatePathAnimators(this);
    },
    resetPathAnimators() {
      resetPathAnimators(this);
    },
    initializeAudioReactiveMapper() {
      initializeAudioReactiveMapper(this);
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (delegated to propertyDriverActions)
    // ============================================================
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new PropertyDriverSystem();
      this.propertyDriverSystem.setPropertyGetter((layerId, propertyPath, frame) => {
        return this.getPropertyValueAtFrame(layerId, propertyPath, frame);
      });
      if (this.audioAnalysis) this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const driver of this.propertyDrivers) this.propertyDriverSystem.addDriver(driver);
    },
    getPropertyValueAtFrame(layerId, propertyPath, frame) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return null;
      const parts = propertyPath.split(".");
      if (parts[0] === "transform") {
        const t = layer.transform;
        if (parts[1] === "position") {
          const p = interpolateProperty(t.position, frame);
          return parts[2] === "x" ? p.x : parts[2] === "y" ? p.y : p.z ?? 0;
        }
        if (parts[1] === "anchorPoint") {
          const a = interpolateProperty(t.anchorPoint, frame);
          return parts[2] === "x" ? a.x : parts[2] === "y" ? a.y : a.z ?? 0;
        }
        if (parts[1] === "scale") {
          const s = interpolateProperty(t.scale, frame);
          return parts[2] === "x" ? s.x : parts[2] === "y" ? s.y : s.z ?? 100;
        }
        if (parts[1] === "rotation") return interpolateProperty(t.rotation, frame);
        if (parts[1] === "rotationX" && t.rotationX) return interpolateProperty(t.rotationX, frame);
        if (parts[1] === "rotationY" && t.rotationY) return interpolateProperty(t.rotationY, frame);
        if (parts[1] === "rotationZ" && t.rotationZ) return interpolateProperty(t.rotationZ, frame);
      }
      return parts[0] === "opacity" ? interpolateProperty(layer.opacity, frame) : null;
    },
    getDrivenValuesForLayer(layerId) {
      return getEvaluatedLayerProperties(this, layerId, this.getActiveComp()?.currentFrame ?? 0);
    },
    addPropertyDriver(driver) {
      return addPropertyDriver(this, driver);
    },
    createAudioPropertyDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
      return createAudioPropertyDriver(this, targetLayerId, targetProperty, audioFeature, options);
    },
    createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
      return createPropertyLinkDriver(this, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options);
    },
    removePropertyDriver(driverId) {
      removePropertyDriver(this, driverId);
    },
    updatePropertyDriver(driverId, updates) {
      updatePropertyDriver(this, driverId, updates);
    },
    getDriversForLayer(layerId) {
      return getDriversForLayer(this, layerId);
    },
    togglePropertyDriver(driverId) {
      togglePropertyDriver(this, driverId);
    },
    // ============================================================
    // PARTICLE SIMULATION ACTIONS
    // ============================================================
    /**
     * Reset a particle layer's simulation
     * Called when particle configuration changes
     */
    resetParticleSimulation(layerId) {
      particleSimulationRegistry.resetLayer(layerId);
      storeLogger.debug("Reset particle simulation for layer:", layerId);
    },
    /**
     * Clear all particle simulations
     * Called on project load/new
     */
    clearAllParticleSimulations() {
      particleSimulationRegistry.clear();
      storeLogger.debug("Cleared all particle simulations");
    },
    /**
     * Get particle snapshot for a layer at a specific frame
     * Evaluates the frame state to get the deterministic snapshot
     */
    getParticleSnapshot(layerId, frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots[layerId] ?? null;
    },
    /**
     * Get all particle snapshots from current frame
     */
    getAllParticleSnapshots(frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots;
    },
    // ============================================================
    // AUTOSAVE/PROJECT ACTIONS (delegated to projectActions)
    // ============================================================
    enableAutosave(intervalMs) {
      configureAutosave(this, { enabled: true, intervalMs }, () => this.performAutosave());
    },
    disableAutosave() {
      stopAutosave(this);
      this.autosaveEnabled = false;
    },
    startAutosaveTimer() {
      startAutosave(this, () => this.performAutosave());
    },
    stopAutosaveTimer() {
      stopAutosave(this);
    },
    async performAutosave() {
      return performAutosave(this);
    },
    markUnsavedChanges() {
      markUnsavedChanges(this);
      this.invalidateFrameCache();
    },
    async saveProjectToBackend() {
      const result = await saveProjectToServer(this);
      if (!result) throw new Error("Save failed");
      return result;
    },
    async loadProjectFromBackend(projectId) {
      const success = await loadProjectFromServer(this, projectId, () => this.pushHistory());
      if (!success) throw new Error("Load failed");
    },
    async listSavedProjects() {
      return listServerProjects();
    },
    // ============================================================
    // FRAME CACHE ACTIONS (delegated to cacheActions)
    // ============================================================
    async initializeFrameCache() {
      return initializeCache(this);
    },
    setFrameCacheEnabled(enabled) {
      setFrameCacheEnabled(this, enabled);
    },
    getCachedFrame(frame) {
      return getCachedFrame(this, frame);
    },
    async cacheFrame(frame, imageData) {
      return cacheFrame(this, frame, imageData);
    },
    isFrameCached(frame) {
      return isFrameCached(this, frame);
    },
    async startPreCache(currentFrame, direction = "both") {
      return startPreCache(this, currentFrame, direction);
    },
    invalidateFrameCache() {
      invalidateFrameCache(this);
    },
    clearFrameCache() {
      clearFrameCache();
    },
    getFrameCacheStats() {
      return getFrameCacheStats();
    },
    computeProjectHash() {
      return computeProjectHash(this);
    }
  }
});

const _hoisted_1$E = { class: "project-panel" };
const _hoisted_2$D = { class: "panel-header" };
const _hoisted_3$B = { class: "header-actions" };
const _hoisted_4$A = { class: "dropdown-container" };
const _hoisted_5$A = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_6$A = {
  key: 0,
  class: "search-bar"
};
const _hoisted_7$A = { class: "panel-content" };
const _hoisted_8$z = { class: "folder-tree" };
const _hoisted_9$y = ["onClick", "onDblclick"];
const _hoisted_10$x = ["onClick"];
const _hoisted_11$w = { class: "folder-name" };
const _hoisted_12$u = { class: "item-count" };
const _hoisted_13$t = {
  key: 0,
  class: "folder-contents"
};
const _hoisted_14$r = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_15$r = { class: "item-icon" };
const _hoisted_16$r = { class: "item-name" };
const _hoisted_17$q = { class: "item-info" };
const _hoisted_18$p = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_19$p = { class: "item-icon" };
const _hoisted_20$p = { class: "item-name" };
const _hoisted_21$n = { class: "item-info" };
const _hoisted_22$m = {
  key: 0,
  class: "empty-state"
};
const _hoisted_23$m = {
  key: 1,
  class: "panel-footer"
};
const _hoisted_24$k = { class: "item-details" };
const _hoisted_25$k = { class: "detail-label" };
const _hoisted_26$k = { class: "detail-info" };
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const fileInputRef = ref(null);
    const showSearch = ref(false);
    const showNewMenu = ref(false);
    const searchQuery = ref("");
    const selectedItem = ref(null);
    const expandedFolders = ref(["compositions", "footage"]);
    const folders = computed(() => [
      {
        id: "compositions",
        name: "Compositions",
        items: [
          {
            id: "comp-main",
            name: "Main Comp",
            type: "composition",
            width: store.width,
            height: store.height,
            fps: store.fps,
            duration: store.frameCount
          }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]);
    const items = ref([]);
    const filteredFolders = computed(() => {
      if (!searchQuery.value) return folders.value;
      const query = searchQuery.value.toLowerCase();
      return folders.value.map((folder) => ({
        ...folder,
        items: folder.items.filter(
          (item) => item.name.toLowerCase().includes(query)
        )
      })).filter((folder) => folder.items.length > 0 || folder.name.toLowerCase().includes(query));
    });
    const filteredRootItems = computed(() => {
      if (!searchQuery.value) return items.value;
      const query = searchQuery.value.toLowerCase();
      return items.value.filter(
        (item) => item.name.toLowerCase().includes(query)
      );
    });
    const selectedItemDetails = computed(() => {
      if (!selectedItem.value) return null;
      for (const folder of folders.value) {
        const item2 = folder.items.find((i) => i.id === selectedItem.value);
        if (item2) {
          return {
            name: item2.name,
            info: getItemInfo(item2)
          };
        }
      }
      const item = items.value.find((i) => i.id === selectedItem.value);
      if (item) {
        return {
          name: item.name,
          info: getItemInfo(item)
        };
      }
      return null;
    });
    function toggleFolder(folderId) {
      const index = expandedFolders.value.indexOf(folderId);
      if (index >= 0) {
        expandedFolders.value.splice(index, 1);
      } else {
        expandedFolders.value.push(folderId);
      }
    }
    function selectItem(itemId) {
      selectedItem.value = itemId;
    }
    function openItem(item) {
      if (item.type === "composition") {
        console.log("Opening composition:", item.name);
      }
    }
    function createNewComposition() {
      showNewMenu.value = false;
      emit("openCompositionSettings");
    }
    function createNewSolid() {
      showNewMenu.value = false;
      const layer = store.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", layer.id);
    }
    function createNewText() {
      showNewMenu.value = false;
      const layer = store.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", layer.id);
    }
    function createNewNull() {
      showNewMenu.value = false;
      const layer = store.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", layer.id);
    }
    function createNewSpline() {
      showNewMenu.value = false;
      const layer = store.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", layer.id);
    }
    function createNewModel() {
      showNewMenu.value = false;
      const layer = store.createLayer("model", "3D Model");
      console.log("[ProjectPanel] Created model layer:", layer.id);
    }
    function createNewPointCloud() {
      showNewMenu.value = false;
      const layer = store.createLayer("pointcloud", "Point Cloud");
      console.log("[ProjectPanel] Created point cloud layer:", layer.id);
    }
    function triggerFileImport() {
      fileInputRef.value?.click();
    }
    async function handleFileImport(event) {
      const input = event.target;
      const files = input.files;
      if (!files || files.length === 0) return;
      for (const file of Array.from(files)) {
        const type = getFileType(file);
        const newItem = {
          id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: file.name,
          type
        };
        if (type === "audio") {
          store.loadAudio(file);
        } else if (file.type.startsWith("video/")) {
          try {
            const layer = await store.createVideoLayer(file, true);
            newItem.id = layer.id;
            newItem.width = store.width;
            newItem.height = store.height;
            newItem.duration = store.frameCount;
            newItem.fps = store.fps;
            console.log("[ProjectPanel] Video layer created:", layer.id, layer.name);
          } catch (error) {
            console.error("[ProjectPanel] Failed to import video:", error);
            continue;
          }
        } else if (file.type.startsWith("image/")) {
          const imageUrl = URL.createObjectURL(file);
          const assetId = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          store.project.assets[assetId] = {
            id: assetId,
            type: "image",
            source: "file",
            width: 0,
            // Will be updated when image loads
            height: 0,
            data: imageUrl
          };
          const layer = store.createLayer("image", file.name.replace(/\.[^.]+$/, ""));
          layer.data = { assetId };
          newItem.id = layer.id;
        }
        const folder = folders.value.find((f) => f.id === "footage");
        if (folder) {
          folder.items.push(newItem);
        } else {
          items.value.push(newItem);
        }
        console.log("[ProjectPanel] Imported:", file.name, type);
      }
      input.value = "";
    }
    function getFileType(file) {
      const mime = file.type;
      if (mime.startsWith("audio/")) return "audio";
      if (mime.startsWith("video/")) return "footage";
      if (mime.startsWith("image/")) return "footage";
      return "footage";
    }
    function getItemIcon(type) {
      const icons = {
        composition: "ðŸŽ¬",
        footage: "ðŸŽž",
        solid: "â¬œ",
        audio: "ðŸ”Š",
        folder: "ðŸ“"
      };
      return icons[type] || "ðŸ“„";
    }
    function getItemInfo(item) {
      if (item.type === "composition" || item.type === "footage") {
        const parts = [];
        if (item.width && item.height) {
          parts.push(`${item.width}Ã—${item.height}`);
        }
        if (item.fps) {
          parts.push(`${item.fps}fps`);
        }
        if (item.duration) {
          const seconds = item.duration / (item.fps || 30);
          parts.push(`${seconds.toFixed(1)}s`);
        }
        return parts.join(" â€¢ ");
      }
      return "";
    }
    function onDragStart(item, event) {
      event.dataTransfer?.setData("application/project-item", JSON.stringify(item));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createBaseVNode("div", _hoisted_2$D, [
          _cache[3] || (_cache[3] = createBaseVNode("span", { class: "panel-title" }, "Project", -1)),
          createBaseVNode("div", _hoisted_3$B, [
            createBaseVNode("button", {
              onClick: triggerFileImport,
              title: "Import File (Ctrl+I)"
            }, "ðŸ“¥"),
            createBaseVNode("div", _hoisted_4$A, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => showNewMenu.value = !showNewMenu.value),
                title: "New Item"
              }, "+"),
              showNewMenu.value ? (openBlock(), createElementBlock("div", _hoisted_5$A, [
                createBaseVNode("button", { onClick: createNewComposition }, "ðŸŽ¬ New Composition"),
                createBaseVNode("button", { onClick: createNewSolid }, "â¬œ New Solid"),
                createBaseVNode("button", { onClick: createNewText }, "T New Text"),
                createBaseVNode("button", { onClick: createNewNull }, "â—‡ New Null"),
                createBaseVNode("button", { onClick: createNewSpline }, "âœ New Spline"),
                createBaseVNode("button", { onClick: createNewModel }, "ðŸ§Š New 3D Model"),
                createBaseVNode("button", { onClick: createNewPointCloud }, "â˜ New Point Cloud")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => showSearch.value = !showSearch.value),
              title: "Search"
            }, "ðŸ”")
          ])
        ]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          multiple: "",
          accept: "image/*,video/*,audio/*,.json",
          style: { "display": "none" },
          onChange: handleFileImport
        }, null, 544),
        showSearch.value ? (openBlock(), createElementBlock("div", _hoisted_6$A, [
          withDirectives(createBaseVNode("input", {
            type: "text",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchQuery.value = $event),
            placeholder: "Search project...",
            class: "search-input"
          }, null, 512), [
            [vModelText, searchQuery.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_7$A, [
          createBaseVNode("div", _hoisted_8$z, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredFolders.value, (folder) => {
              return openBlock(), createElementBlock("div", {
                key: folder.id,
                class: "folder-item"
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["folder-header", { selected: selectedItem.value === folder.id }]),
                  onClick: ($event) => selectItem(folder.id),
                  onDblclick: ($event) => toggleFolder(folder.id)
                }, [
                  createBaseVNode("span", {
                    class: "expand-icon",
                    onClick: withModifiers(($event) => toggleFolder(folder.id), ["stop"])
                  }, toDisplayString(expandedFolders.value.includes(folder.id) ? "â–¼" : "â–º"), 9, _hoisted_10$x),
                  _cache[4] || (_cache[4] = createBaseVNode("span", { class: "folder-icon" }, "ðŸ“", -1)),
                  createBaseVNode("span", _hoisted_11$w, toDisplayString(folder.name), 1),
                  createBaseVNode("span", _hoisted_12$u, toDisplayString(folder.items.length), 1)
                ], 42, _hoisted_9$y),
                expandedFolders.value.includes(folder.id) ? (openBlock(), createElementBlock("div", _hoisted_13$t, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(folder.items, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.id,
                      class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                      onClick: ($event) => selectItem(item.id),
                      onDblclick: ($event) => openItem(item),
                      draggable: "true",
                      onDragstart: ($event) => onDragStart(item, $event)
                    }, [
                      createBaseVNode("span", _hoisted_15$r, toDisplayString(getItemIcon(item.type)), 1),
                      createBaseVNode("span", _hoisted_16$r, toDisplayString(item.name), 1),
                      createBaseVNode("span", _hoisted_17$q, toDisplayString(getItemInfo(item)), 1)
                    ], 42, _hoisted_14$r);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredRootItems.value, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.id,
                class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                onClick: ($event) => selectItem(item.id),
                onDblclick: ($event) => openItem(item),
                draggable: "true",
                onDragstart: ($event) => onDragStart(item, $event)
              }, [
                createBaseVNode("span", _hoisted_19$p, toDisplayString(getItemIcon(item.type)), 1),
                createBaseVNode("span", _hoisted_20$p, toDisplayString(item.name), 1),
                createBaseVNode("span", _hoisted_21$n, toDisplayString(getItemInfo(item)), 1)
              ], 42, _hoisted_18$p);
            }), 128))
          ]),
          items.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_22$m, [..._cache[5] || (_cache[5] = [
            createBaseVNode("p", null, "No items in project", -1),
            createBaseVNode("p", { class: "hint" }, "Import footage or create compositions", -1)
          ])])) : createCommentVNode("", true)
        ]),
        selectedItemDetails.value ? (openBlock(), createElementBlock("div", _hoisted_23$m, [
          createBaseVNode("div", _hoisted_24$k, [
            createBaseVNode("span", _hoisted_25$k, toDisplayString(selectedItemDetails.value.name), 1),
            createBaseVNode("span", _hoisted_26$k, toDisplayString(selectedItemDetails.value.info), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const ProjectPanel = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__scopeId", "data-v-9eb71ff8"]]);

const _hoisted_1$D = { class: "effects-panel" };
const _hoisted_2$C = { class: "panel-header" };
const _hoisted_3$A = { class: "header-actions" };
const _hoisted_4$z = { class: "panel-content" };
const _hoisted_5$z = { class: "tabs" };
const _hoisted_6$z = {
  key: 0,
  class: "effects-list"
};
const _hoisted_7$z = ["onClick"];
const _hoisted_8$y = { class: "expand-icon" };
const _hoisted_9$x = { class: "category-icon" };
const _hoisted_10$w = { class: "category-name" };
const _hoisted_11$v = { class: "effect-count" };
const _hoisted_12$t = {
  key: 0,
  class: "category-effects"
};
const _hoisted_13$s = ["onDblclick", "onDragstart"];
const _hoisted_14$q = { class: "effect-name" };
const _hoisted_15$q = ["onClick", "title"];
const _hoisted_16$q = {
  key: 1,
  class: "presets-list"
};
const _hoisted_17$p = ["onClick"];
const _hoisted_18$o = { class: "expand-icon" };
const _hoisted_19$o = { class: "category-name" };
const _hoisted_20$o = { class: "preset-count" };
const _hoisted_21$m = {
  key: 0,
  class: "category-presets"
};
const _hoisted_22$l = ["onDblclick", "onDragstart"];
const _hoisted_23$l = { class: "preset-info" };
const _hoisted_24$j = { class: "preset-name" };
const _hoisted_25$j = { class: "preset-description" };
const _hoisted_26$j = {
  key: 2,
  class: "favorites-list"
};
const _hoisted_27$h = {
  key: 0,
  class: "empty-favorites"
};
const _hoisted_28$h = ["onDblclick", "onDragstart"];
const _hoisted_29$h = { class: "category-badge" };
const _hoisted_30$h = { class: "effect-name" };
const _hoisted_31$e = ["onClick"];
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "EffectsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const activeTab = ref("effects");
    const searchQuery = ref("");
    const expandedCategories = ref(["blur-sharpen", "color-correction"]);
    const expandedPresetCategories = ref(["Fade", "Scale"]);
    const favorites = ref([]);
    onMounted(() => {
      const saved = localStorage.getItem("effect-favorites");
      if (saved) {
        try {
          favorites.value = JSON.parse(saved);
        } catch {
          favorites.value = [];
        }
      }
    });
    function saveFavorites() {
      localStorage.setItem("effect-favorites", JSON.stringify(favorites.value));
    }
    const allEffects = computed(() => {
      return Object.entries(EFFECT_DEFINITIONS).map(([key, def]) => ({
        key,
        name: def.name,
        category: def.category,
        description: def.description
      }));
    });
    const filteredCategories = computed(() => {
      const query = searchQuery.value.toLowerCase();
      return Object.entries(EFFECT_CATEGORIES).map(([key, cat]) => {
        const effects = allEffects.value.filter((e) => {
          if (e.category !== key) return false;
          if (query && !e.name.toLowerCase().includes(query)) return false;
          return true;
        });
        return {
          key,
          label: cat.label,
          icon: cat.icon,
          effects
        };
      }).filter((cat) => cat.effects.length > 0);
    });
    const groupedPresets = computed(() => {
      const query = searchQuery.value.toLowerCase();
      const groups = {};
      for (const preset of ANIMATION_PRESETS) {
        if (query && !preset.name.toLowerCase().includes(query)) continue;
        if (!groups[preset.category]) {
          groups[preset.category] = [];
        }
        groups[preset.category].push(preset);
      }
      return Object.entries(groups).map(([category, presets]) => ({
        category,
        presets
      }));
    });
    const favoriteEffects = computed(() => {
      return allEffects.value.filter((e) => favorites.value.includes(e.key));
    });
    function toggleCategory(category) {
      const index = expandedCategories.value.indexOf(category);
      if (index >= 0) {
        expandedCategories.value.splice(index, 1);
      } else {
        expandedCategories.value.push(category);
      }
    }
    function togglePresetCategory(category) {
      const index = expandedPresetCategories.value.indexOf(category);
      if (index >= 0) {
        expandedPresetCategories.value.splice(index, 1);
      } else {
        expandedPresetCategories.value.push(category);
      }
    }
    function toggleFavorite(effectKey) {
      const index = favorites.value.indexOf(effectKey);
      if (index >= 0) {
        favorites.value.splice(index, 1);
      } else {
        favorites.value.push(effectKey);
      }
      saveFavorites();
    }
    function getCategoryIcon(category) {
      return EFFECT_CATEGORIES[category]?.icon || "?";
    }
    function applyEffect(effectKey) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) {
        console.warn("No layer selected to apply effect");
        return;
      }
      store.addEffectToLayer(selectedLayer.id, effectKey);
    }
    function applyPreset(preset) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const startFrame = selectedLayer.inPoint;
      const endFrame = selectedLayer.outPoint;
      const duration = endFrame - startFrame;
      for (const propDef of preset.keyframes) {
        for (const kf of propDef.keyframes) {
          const frame = Math.round(startFrame + kf.time * duration);
          store.addKeyframe(selectedLayer.id, propDef.property, kf.value, frame);
        }
      }
    }
    function onDragStart(effectKey, event) {
      event.dataTransfer?.setData("application/effect", effectKey);
    }
    function onDragPreset(preset, event) {
      event.dataTransfer?.setData("application/preset", JSON.stringify(preset));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        createBaseVNode("div", _hoisted_2$C, [
          _cache[4] || (_cache[4] = createBaseVNode("span", { class: "panel-title" }, "Effects & Presets", -1)),
          createBaseVNode("div", _hoisted_3$A, [
            withDirectives(createBaseVNode("input", {
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              placeholder: "Search...",
              class: "search-input"
            }, null, 512), [
              [vModelText, searchQuery.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$z, [
          createBaseVNode("div", _hoisted_5$z, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "effects" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "effects")
            }, " Effects ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "presets" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "presets")
            }, " Presets ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "favorites" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "favorites")
            }, " Favorites ", 2)
          ]),
          activeTab.value === "effects" ? (openBlock(), createElementBlock("div", _hoisted_6$z, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
              return openBlock(), createElementBlock("div", {
                key: category.key,
                class: "effect-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => toggleCategory(category.key)
                }, [
                  createBaseVNode("span", _hoisted_8$y, toDisplayString(expandedCategories.value.includes(category.key) ? "â–¼" : "â–º"), 1),
                  createBaseVNode("span", _hoisted_9$x, toDisplayString(category.icon), 1),
                  createBaseVNode("span", _hoisted_10$w, toDisplayString(category.label), 1),
                  createBaseVNode("span", _hoisted_11$v, toDisplayString(category.effects.length), 1)
                ], 8, _hoisted_7$z),
                expandedCategories.value.includes(category.key) ? (openBlock(), createElementBlock("div", _hoisted_12$t, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.effects, (effect) => {
                    return openBlock(), createElementBlock("div", {
                      key: effect.key,
                      class: normalizeClass(["effect-item", { favorite: favorites.value.includes(effect.key) }]),
                      onDblclick: ($event) => applyEffect(effect.key),
                      onDragstart: ($event) => onDragStart(effect.key, $event),
                      draggable: "true"
                    }, [
                      createBaseVNode("span", _hoisted_14$q, toDisplayString(effect.name), 1),
                      createBaseVNode("button", {
                        class: "favorite-btn",
                        onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"]),
                        title: favorites.value.includes(effect.key) ? "Remove from favorites" : "Add to favorites"
                      }, toDisplayString(favorites.value.includes(effect.key) ? "â˜…" : "â˜†"), 9, _hoisted_15$q)
                    ], 42, _hoisted_13$s);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "presets" ? (openBlock(), createElementBlock("div", _hoisted_16$q, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedPresets.value, (group) => {
              return openBlock(), createElementBlock("div", {
                key: group.category,
                class: "preset-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => togglePresetCategory(group.category)
                }, [
                  createBaseVNode("span", _hoisted_18$o, toDisplayString(expandedPresetCategories.value.includes(group.category) ? "â–¼" : "â–º"), 1),
                  createBaseVNode("span", _hoisted_19$o, toDisplayString(group.category), 1),
                  createBaseVNode("span", _hoisted_20$o, toDisplayString(group.presets.length), 1)
                ], 8, _hoisted_17$p),
                expandedPresetCategories.value.includes(group.category) ? (openBlock(), createElementBlock("div", _hoisted_21$m, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(group.presets, (preset) => {
                    return openBlock(), createElementBlock("div", {
                      key: preset.id,
                      class: "preset-item",
                      onDblclick: ($event) => applyPreset(preset),
                      onDragstart: ($event) => onDragPreset(preset, $event),
                      draggable: "true"
                    }, [
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "preset-preview" }, [
                        createBaseVNode("span", { class: "preview-icon" }, "â–¶")
                      ], -1)),
                      createBaseVNode("div", _hoisted_23$l, [
                        createBaseVNode("span", _hoisted_24$j, toDisplayString(preset.name), 1),
                        createBaseVNode("span", _hoisted_25$j, toDisplayString(preset.description), 1)
                      ])
                    ], 40, _hoisted_22$l);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "favorites" ? (openBlock(), createElementBlock("div", _hoisted_26$j, [
            favoriteEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_27$h, [..._cache[6] || (_cache[6] = [
              createBaseVNode("p", null, "No favorites yet", -1),
              createBaseVNode("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
            ])])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(favoriteEffects.value, (effect) => {
              return openBlock(), createElementBlock("div", {
                key: effect.key,
                class: "effect-item",
                onDblclick: ($event) => applyEffect(effect.key),
                onDragstart: ($event) => onDragStart(effect.key, $event),
                draggable: "true"
              }, [
                createBaseVNode("span", _hoisted_29$h, toDisplayString(getCategoryIcon(effect.category)), 1),
                createBaseVNode("span", _hoisted_30$h, toDisplayString(effect.name), 1),
                createBaseVNode("button", {
                  class: "favorite-btn active",
                  onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"])
                }, " â˜… ", 8, _hoisted_31$e)
              ], 40, _hoisted_28$h);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "panel-footer" }, [
          createBaseVNode("span", { class: "info-text" }, "Double-click or drag to apply")
        ], -1))
      ]);
    };
  }
});

const EffectsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__scopeId", "data-v-5e081b38"]]);

const _hoisted_1$C = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$B = {
  key: 1,
  class: "scrub-unit"
};
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -Infinity },
    max: { default: Infinity },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const isScrubbing = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const defaultValue = computed(() => props.default ?? props.modelValue);
    const showReset = computed(() => props.default !== void 0);
    const displayValue = computed(() => {
      if (Number.isInteger(props.modelValue) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      let multiplier = props.sensitivity;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX * props.step * multiplier * 0.5;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onKeyDown(e) {
      if (props.disabled) return;
      let delta = 0;
      if (e.key === "ArrowUp") delta = props.step;
      else if (e.key === "ArrowDown") delta = -props.step;
      if (delta !== 0) {
        e.preventDefault();
        if (e.shiftKey) delta *= 10;
        if (e.ctrlKey || e.metaKey) delta *= 0.1;
        emit("update:modelValue", round(clamp(props.modelValue + delta)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    function reset() {
      if (props.default !== void 0) {
        emit("update:modelValue", props.default);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["scrubable-number", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["scrub-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("input", {
          type: "number",
          class: "scrub-input",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onKeydown: onKeyDown,
          onBlur
        }, null, 40, _hoisted_1$C),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$B, toDisplayString(__props.unit), 1)) : createCommentVNode("", true),
        showReset.value && __props.modelValue !== defaultValue.value ? (openBlock(), createElementBlock("button", {
          key: 2,
          class: "reset-btn",
          onClick: reset,
          title: "Reset to default"
        }, [..._cache[0] || (_cache[0] = [
          createBaseVNode("i", { class: "pi pi-refresh" }, null, -1)
        ])])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const ScrubableNumber = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-dcc786e6"]]);

const _hoisted_1$B = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$A = {
  key: 2,
  class: "slider-unit"
};
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: true },
    gradient: {},
    disabled: { type: Boolean, default: false },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const trackRef = ref(null);
    const isScrubbing = ref(false);
    const isDragging = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const fillPercent = computed(() => {
      const range = props.max - props.min;
      if (range === 0) return 0;
      return (props.modelValue - props.min) / range * 100;
    });
    const displayValue = computed(() => {
      if (Number.isInteger(props.step) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      const range = props.max - props.min;
      let multiplier = 1;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX / 200 * range * multiplier;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onTrackClick(e) {
      if (props.disabled || !trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + percent * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function startThumbDrag(_e) {
      if (props.disabled) return;
      isDragging.value = true;
      document.addEventListener("mousemove", onThumbDrag);
      document.addEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onThumbDrag(e) {
      if (!trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + Math.max(0, Math.min(1, percent)) * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function stopThumbDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onThumbDrag);
      document.removeEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slider-input", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["slider-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "slider-track",
          ref_key: "trackRef",
          ref: trackRef,
          onMousedown: onTrackClick
        }, [
          createBaseVNode("div", {
            class: "slider-fill",
            style: normalizeStyle({ width: fillPercent.value + "%", background: __props.gradient || void 0 })
          }, null, 4),
          createBaseVNode("div", {
            class: "slider-thumb",
            style: normalizeStyle({ left: fillPercent.value + "%" }),
            onMousedown: withModifiers(startThumbDrag, ["stop"])
          }, null, 36)
        ], 544),
        __props.showValue ? (openBlock(), createElementBlock("input", {
          key: 1,
          type: "number",
          class: "slider-value",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onBlur
        }, null, 40, _hoisted_1$B)) : createCommentVNode("", true),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$A, toDisplayString(__props.unit), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const SliderInput = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-9dd40416"]]);

const _hoisted_1$A = { class: "dial-marks" };
const _hoisted_2$z = {
  key: 0,
  class: "angle-value"
};
const _hoisted_3$z = ["value", "disabled"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const dialRef = ref(null);
    const isDragging = ref(false);
    const displayValue = computed(() => {
      return Math.round(props.modelValue * 10) / 10;
    });
    function normalizeAngle(angle) {
      return (angle % 360 + 360) % 360;
    }
    function startDrag(e) {
      if (props.disabled) return;
      isDragging.value = true;
      updateAngle(e);
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      updateAngle(e);
    }
    function updateAngle(e) {
      if (!dialRef.value) return;
      const rect = dialRef.value.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      let angle = Math.atan2(deltaX, -deltaY) * (180 / Math.PI);
      angle = normalizeAngle(angle);
      if (e.shiftKey) {
        angle = Math.round(angle / 45) * 45;
      }
      emit("update:modelValue", angle);
    }
    function stopDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mouseup", stopDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", normalizeAngle(value));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["angle-dial", { disabled: __props.disabled }])
      }, [
        createBaseVNode("div", {
          class: "dial",
          ref_key: "dialRef",
          ref: dialRef,
          style: normalizeStyle({ width: __props.size + "px", height: __props.size + "px" }),
          onMousedown: startDrag
        }, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "dial-ring" }, null, -1)),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "dial-center" }, null, -1)),
          createBaseVNode("div", {
            class: "dial-indicator",
            style: normalizeStyle({ transform: `rotate(${__props.modelValue}deg)` })
          }, null, 4),
          createBaseVNode("div", _hoisted_1$A, [
            (openBlock(), createElementBlock(Fragment, null, renderList(8, (i) => {
              return createBaseVNode("div", {
                class: "dial-mark",
                key: i,
                style: normalizeStyle({ transform: `rotate(${i * 45}deg)` })
              }, null, 4);
            }), 64))
          ])
        ], 36),
        __props.showValue ? (openBlock(), createElementBlock("div", _hoisted_2$z, [
          createBaseVNode("input", {
            type: "number",
            class: "angle-input",
            value: displayValue.value,
            disabled: __props.disabled,
            onInput,
            onBlur
          }, null, 40, _hoisted_3$z),
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "angle-unit" }, "Â°", -1))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const AngleDial = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__scopeId", "data-v-04a5caf6"]]);

function hsvToRgb(h, s, v) {
  h = (h % 360 + 360) % 360;
  const c = v * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = v - c;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (d !== 0) {
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, v];
}
function hslToRgb$1(h, s, l) {
  h = (h % 360 + 360) % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsl$1(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, l];
}
function hexToRgb(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length === 6 || hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
      return [r, g, b];
    }
  }
  return null;
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "ff";
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  if (hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = parseInt(hex.slice(6, 8), 16) / 255;
    if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
      return [r, g, b, a];
    }
  }
  return null;
}
function rgbToHex(r, g, b) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function rgbaToHex(r, g, b, a) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}${toHex(a * 255)}`;
}
const STANDARD_SWATCHES = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
];

const _hoisted_1$z = {
  key: 0,
  class: "checkerboard"
};
const _hoisted_2$y = ["value"];
const _hoisted_3$y = { class: "mode-tabs" };
const _hoisted_4$y = ["onClick"];
const _hoisted_5$y = {
  key: 1,
  class: "rgb-sliders"
};
const _hoisted_6$y = { class: "color-slider" };
const _hoisted_7$y = ["value"];
const _hoisted_8$x = { class: "color-slider" };
const _hoisted_9$w = ["value"];
const _hoisted_10$v = { class: "color-slider" };
const _hoisted_11$u = ["value"];
const _hoisted_12$s = {
  key: 2,
  class: "hsl-sliders"
};
const _hoisted_13$r = { class: "color-slider" };
const _hoisted_14$p = ["value"];
const _hoisted_15$p = { class: "color-slider" };
const _hoisted_16$p = ["value"];
const _hoisted_17$o = { class: "color-slider" };
const _hoisted_18$n = ["value"];
const _hoisted_19$n = {
  key: 3,
  class: "alpha-slider"
};
const _hoisted_20$n = ["value"];
const _hoisted_21$l = { class: "swatches-section" };
const _hoisted_22$k = { class: "swatches-grid" };
const _hoisted_23$k = ["onClick"];
const _hoisted_24$i = {
  key: 4,
  class: "recent-section"
};
const _hoisted_25$i = { class: "swatches-grid" };
const _hoisted_26$i = ["onClick"];
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: false },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const modes = ["hsv", "rgb", "hsl"];
    const containerRef = ref(null);
    const panelRef = ref(null);
    const svSquareRef = ref(null);
    const hueSliderRef = ref(null);
    const alphaSliderRef = ref(null);
    const isOpen = ref(false);
    const currentMode = ref("hsv");
    const alphaValue = ref(1);
    const recentColors = ref([]);
    const rgb = ref([255, 255, 255]);
    const hsv = ref([0, 0, 1]);
    const hsl = ref([0, 0, 1]);
    const allSwatches = computed(() => props.swatches || STANDARD_SWATCHES);
    const panelStyle = computed(() => {
      if (!containerRef.value || !props.teleport) return {};
      const rect = containerRef.value.getBoundingClientRect();
      return {
        top: `${rect.bottom + 4}px`,
        left: `${rect.left}px`
      };
    });
    function updateFromHex(hex) {
      const parsed = hexToRgb(hex);
      if (parsed) {
        rgb.value = parsed;
        hsv.value = rgbToHsv(parsed[0], parsed[1], parsed[2]);
        hsl.value = rgbToHsl$1(parsed[0], parsed[1], parsed[2]);
      }
    }
    function emitColor() {
      const hex = rgbToHex(rgb.value[0], rgb.value[1], rgb.value[2]);
      emit("update:modelValue", hex);
    }
    function togglePicker() {
      isOpen.value = !isOpen.value;
    }
    function closePicker() {
      if (isOpen.value) {
        isOpen.value = false;
        addToRecent(props.modelValue);
      }
    }
    function addToRecent(color) {
      const index = recentColors.value.indexOf(color);
      if (index !== -1) {
        recentColors.value.splice(index, 1);
      }
      recentColors.value.unshift(color);
      if (recentColors.value.length > props.recentCount) {
        recentColors.value.pop();
      }
    }
    function selectSwatch(color) {
      emit("update:modelValue", color);
    }
    let isDraggingSV = false;
    function startSVDrag(e) {
      isDraggingSV = true;
      updateSV(e);
      document.addEventListener("mousemove", onSVDrag);
      document.addEventListener("mouseup", stopSVDrag);
    }
    function onSVDrag(e) {
      if (isDraggingSV) updateSV(e);
    }
    function updateSV(e) {
      if (!svSquareRef.value) return;
      const rect = svSquareRef.value.getBoundingClientRect();
      const s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
      hsv.value = [hsv.value[0], s, v];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopSVDrag() {
      isDraggingSV = false;
      document.removeEventListener("mousemove", onSVDrag);
      document.removeEventListener("mouseup", stopSVDrag);
    }
    let isDraggingHue = false;
    function startHueDrag(e) {
      isDraggingHue = true;
      updateHue(e);
      document.addEventListener("mousemove", onHueDrag);
      document.addEventListener("mouseup", stopHueDrag);
    }
    function onHueDrag(e) {
      if (isDraggingHue) updateHue(e);
    }
    function updateHue(e) {
      if (!hueSliderRef.value) return;
      const rect = hueSliderRef.value.getBoundingClientRect();
      const h = Math.max(0, Math.min(360, (e.clientX - rect.left) / rect.width * 360));
      hsv.value = [h, hsv.value[1], hsv.value[2]];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopHueDrag() {
      isDraggingHue = false;
      document.removeEventListener("mousemove", onHueDrag);
      document.removeEventListener("mouseup", stopHueDrag);
    }
    let draggingSlider = null;
    let sliderRect = null;
    function startSliderDrag(slider, e) {
      draggingSlider = slider;
      const track = e.target.closest(".slider-track");
      if (track) {
        sliderRect = track.getBoundingClientRect();
        updateSlider(e);
        document.addEventListener("mousemove", onSliderDrag);
        document.addEventListener("mouseup", stopSliderDrag);
      }
    }
    function onSliderDrag(e) {
      if (draggingSlider) updateSlider(e);
    }
    function updateSlider(e) {
      if (!sliderRect || !draggingSlider) return;
      const percent = Math.max(0, Math.min(1, (e.clientX - sliderRect.left) / sliderRect.width));
      switch (draggingSlider) {
        case "r":
          rgb.value = [Math.round(percent * 255), rgb.value[1], rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "g":
          rgb.value = [rgb.value[0], Math.round(percent * 255), rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "b":
          rgb.value = [rgb.value[0], rgb.value[1], Math.round(percent * 255)];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "h":
          hsl.value = [percent * 360, hsl.value[1], hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "s":
          hsl.value = [hsl.value[0], percent, hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "l":
          hsl.value = [hsl.value[0], hsl.value[1], percent];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
      }
      emitColor();
    }
    function stopSliderDrag() {
      draggingSlider = null;
      sliderRect = null;
      document.removeEventListener("mousemove", onSliderDrag);
      document.removeEventListener("mouseup", stopSliderDrag);
    }
    let isDraggingAlpha = false;
    function startAlphaDrag(e) {
      isDraggingAlpha = true;
      updateAlpha(e);
      document.addEventListener("mousemove", onAlphaDrag);
      document.addEventListener("mouseup", stopAlphaDrag);
    }
    function onAlphaDrag(e) {
      if (isDraggingAlpha) updateAlpha(e);
    }
    function updateAlpha(e) {
      if (!alphaSliderRef.value) return;
      const rect = alphaSliderRef.value.getBoundingClientRect();
      alphaValue.value = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    }
    function stopAlphaDrag() {
      isDraggingAlpha = false;
      document.removeEventListener("mousemove", onAlphaDrag);
      document.removeEventListener("mouseup", stopAlphaDrag);
    }
    function onHexInput(e) {
      const input = e.target;
      let value = input.value.trim();
      if (!value.startsWith("#")) {
        value = "#" + value;
      }
      if (/^#[0-9a-f]{6}$/i.test(value)) {
        emit("update:modelValue", value.toLowerCase());
      }
    }
    function onHexBlur(e) {
      const input = e.target;
      input.value = props.modelValue;
    }
    function onRgbInput(index, e) {
      const input = e.target;
      const value = Math.max(0, Math.min(255, parseInt(input.value) || 0));
      const newRgb = [...rgb.value];
      newRgb[index] = value;
      rgb.value = newRgb;
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onHslInput(index, e) {
      const input = e.target;
      let value = parseFloat(input.value) || 0;
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
        hsl.value = [value, hsl.value[1], hsl.value[2]];
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
        if (index === 1) hsl.value = [hsl.value[0], value, hsl.value[2]];
        else hsl.value = [hsl.value[0], hsl.value[1], value];
      }
      rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onAlphaInput(e) {
      const input = e.target;
      alphaValue.value = Math.max(0, Math.min(100, parseInt(input.value) || 0)) / 100;
    }
    function onClickOutside(e) {
      if (containerRef.value && !containerRef.value.contains(e.target) && panelRef.value && !panelRef.value.contains(e.target)) {
        closePicker();
      }
    }
    watch(() => props.modelValue, (newVal) => {
      updateFromHex(newVal);
    }, { immediate: true });
    onMounted(() => {
      document.addEventListener("mousedown", onClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("mousedown", onClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "color-picker",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("button", {
          class: "color-swatch",
          style: normalizeStyle({ backgroundColor: __props.modelValue }),
          onClick: togglePicker
        }, [
          __props.alpha ? (openBlock(), createElementBlock("span", _hoisted_1$z)) : createCommentVNode("", true)
        ], 4),
        createBaseVNode("input", {
          type: "text",
          class: "hex-input",
          value: __props.modelValue,
          onInput: onHexInput,
          onBlur: onHexBlur,
          onKeydown: _cache[0] || (_cache[0] = withKeys(($event) => $event.target.blur(), ["enter"]))
        }, null, 40, _hoisted_2$y),
        (openBlock(), createBlock(Teleport, {
          to: "body",
          disabled: !__props.teleport
        }, [
          isOpen.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "picker-panel",
            style: normalizeStyle(panelStyle.value),
            ref_key: "panelRef",
            ref: panelRef
          }, [
            createBaseVNode("div", _hoisted_3$y, [
              (openBlock(), createElementBlock(Fragment, null, renderList(modes, (mode) => {
                return createBaseVNode("button", {
                  key: mode,
                  class: normalizeClass({ active: currentMode.value === mode }),
                  onClick: ($event) => currentMode.value = mode
                }, toDisplayString(mode.toUpperCase()), 11, _hoisted_4$y);
              }), 64))
            ]),
            currentMode.value === "hsv" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: "sv-square",
                style: normalizeStyle({ backgroundColor: `hsl(${hsv.value[0]}, 100%, 50%)` }),
                onMousedown: startSVDrag,
                ref_key: "svSquareRef",
                ref: svSquareRef
              }, [
                _cache[13] || (_cache[13] = createBaseVNode("div", { class: "sv-white" }, null, -1)),
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "sv-black" }, null, -1)),
                createBaseVNode("div", {
                  class: "sv-cursor",
                  style: normalizeStyle({ left: hsv.value[1] * 100 + "%", top: (1 - hsv.value[2]) * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("div", {
                class: "hue-slider",
                onMousedown: startHueDrag,
                ref_key: "hueSliderRef",
                ref: hueSliderRef
              }, [
                createBaseVNode("div", {
                  class: "hue-cursor",
                  style: normalizeStyle({ left: hsv.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 544)
            ], 64)) : currentMode.value === "rgb" ? (openBlock(), createElementBlock("div", _hoisted_5$y, [
              createBaseVNode("div", _hoisted_6$y, [
                _cache[15] || (_cache[15] = createBaseVNode("label", null, "R", -1)),
                createBaseVNode("div", {
                  class: "slider-track r-track",
                  onMousedown: _cache[1] || (_cache[1] = ($event) => startSliderDrag("r", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[0] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[0],
                  min: "0",
                  max: "255",
                  onInput: _cache[2] || (_cache[2] = ($event) => onRgbInput(0, $event))
                }, null, 40, _hoisted_7$y)
              ]),
              createBaseVNode("div", _hoisted_8$x, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "G", -1)),
                createBaseVNode("div", {
                  class: "slider-track g-track",
                  onMousedown: _cache[3] || (_cache[3] = ($event) => startSliderDrag("g", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[1] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[1],
                  min: "0",
                  max: "255",
                  onInput: _cache[4] || (_cache[4] = ($event) => onRgbInput(1, $event))
                }, null, 40, _hoisted_9$w)
              ]),
              createBaseVNode("div", _hoisted_10$v, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "B", -1)),
                createBaseVNode("div", {
                  class: "slider-track b-track",
                  onMousedown: _cache[5] || (_cache[5] = ($event) => startSliderDrag("b", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[2] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[2],
                  min: "0",
                  max: "255",
                  onInput: _cache[6] || (_cache[6] = ($event) => onRgbInput(2, $event))
                }, null, 40, _hoisted_11$u)
              ])
            ])) : currentMode.value === "hsl" ? (openBlock(), createElementBlock("div", _hoisted_12$s, [
              createBaseVNode("div", _hoisted_13$r, [
                _cache[18] || (_cache[18] = createBaseVNode("label", null, "H", -1)),
                createBaseVNode("div", {
                  class: "slider-track hue-track",
                  onMousedown: _cache[7] || (_cache[7] = ($event) => startSliderDrag("h", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[0] / 360 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[0]),
                  min: "0",
                  max: "360",
                  onInput: _cache[8] || (_cache[8] = ($event) => onHslInput(0, $event))
                }, null, 40, _hoisted_14$p)
              ]),
              createBaseVNode("div", _hoisted_15$p, [
                _cache[19] || (_cache[19] = createBaseVNode("label", null, "S", -1)),
                createBaseVNode("div", {
                  class: "slider-track sat-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[9] || (_cache[9] = ($event) => startSliderDrag("s", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[1] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[1] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[10] || (_cache[10] = ($event) => onHslInput(1, $event))
                }, null, 40, _hoisted_16$p)
              ]),
              createBaseVNode("div", _hoisted_17$o, [
                _cache[20] || (_cache[20] = createBaseVNode("label", null, "L", -1)),
                createBaseVNode("div", {
                  class: "slider-track light-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[11] || (_cache[11] = ($event) => startSliderDrag("l", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[2] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[2] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[12] || (_cache[12] = ($event) => onHslInput(2, $event))
                }, null, 40, _hoisted_18$n)
              ])
            ])) : createCommentVNode("", true),
            __props.alpha ? (openBlock(), createElementBlock("div", _hoisted_19$n, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "A", -1)),
              createBaseVNode("div", {
                class: "slider-track alpha-track",
                style: normalizeStyle({ "--color": __props.modelValue }),
                onMousedown: startAlphaDrag,
                ref_key: "alphaSliderRef",
                ref: alphaSliderRef
              }, [
                createBaseVNode("div", {
                  class: "slider-cursor",
                  style: normalizeStyle({ left: alphaValue.value * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("input", {
                type: "number",
                value: Math.round(alphaValue.value * 100),
                min: "0",
                max: "100",
                onInput: onAlphaInput
              }, null, 40, _hoisted_20$n)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_21$l, [
              _cache[22] || (_cache[22] = createBaseVNode("div", { class: "swatches-label" }, "Swatches", -1)),
              createBaseVNode("div", _hoisted_22$k, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allSwatches.value, (swatch) => {
                  return openBlock(), createElementBlock("button", {
                    key: swatch,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: swatch }),
                    onClick: ($event) => selectSwatch(swatch)
                  }, null, 12, _hoisted_23$k);
                }), 128))
              ])
            ]),
            recentColors.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_24$i, [
              _cache[23] || (_cache[23] = createBaseVNode("div", { class: "swatches-label" }, "Recent", -1)),
              createBaseVNode("div", _hoisted_25$i, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(recentColors.value, (color) => {
                  return openBlock(), createElementBlock("button", {
                    key: color,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: color }),
                    onClick: ($event) => selectSwatch(color)
                  }, null, 12, _hoisted_26$i);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ], 8, ["disabled"]))
      ], 512);
    };
  }
});

const ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__scopeId", "data-v-05165efb"]]);

const _hoisted_1$y = { class: "effect-controls" };
const _hoisted_2$x = { class: "panel-header" };
const _hoisted_3$x = { class: "header-row" };
const _hoisted_4$x = {
  key: 0,
  class: "layer-badge"
};
const _hoisted_5$x = { class: "layer-type-icon" };
const _hoisted_6$x = ["disabled"];
const _hoisted_7$x = {
  key: 0,
  class: "effect-menu"
};
const _hoisted_8$w = { class: "category-label" };
const _hoisted_9$v = { class: "cat-icon" };
const _hoisted_10$u = { class: "category-items" };
const _hoisted_11$t = ["onClick"];
const _hoisted_12$r = { class: "panel-content" };
const _hoisted_13$q = {
  key: 0,
  class: "empty-state"
};
const _hoisted_14$o = {
  key: 1,
  class: "empty-state"
};
const _hoisted_15$o = {
  key: 2,
  class: "effects-list"
};
const _hoisted_16$o = ["onClick"];
const _hoisted_17$n = { class: "header-left" };
const _hoisted_18$m = { class: "arrow" };
const _hoisted_19$m = ["onClick"];
const _hoisted_20$m = { class: "effect-name" };
const _hoisted_21$k = { class: "header-right" };
const _hoisted_22$j = ["onClick"];
const _hoisted_23$j = {
  key: 0,
  class: "effect-params"
};
const _hoisted_24$h = { class: "param-header" };
const _hoisted_25$h = ["title"];
const _hoisted_26$h = ["onClick"];
const _hoisted_27$g = { class: "param-control" };
const _hoisted_28$g = {
  key: 0,
  class: "control-group"
};
const _hoisted_29$g = {
  key: 1,
  class: "control-group"
};
const _hoisted_30$g = {
  key: 2,
  class: "control-group point-group"
};
const _hoisted_31$d = ["checked", "onChange"];
const _hoisted_32$c = ["value", "onChange"];
const _hoisted_33$c = ["value"];
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "EffectControlsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const showAddMenu = ref(false);
    const menuRef = ref(null);
    const layer = computed(() => store.selectedLayer);
    const categories = EFFECT_CATEGORIES;
    function getEffectsByCategory(cat) {
      return Object.entries(EFFECT_DEFINITIONS).filter(([_, def]) => def.category === cat).map(([key, def]) => ({ key, ...def }));
    }
    function getParamDef(effectKey, paramKey) {
      const def = EFFECT_DEFINITIONS[effectKey];
      return def?.parameters.find((p) => formatParamKey(p.name) === paramKey);
    }
    function formatParamKey(name) {
      return name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function hasRange(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def && (def.min !== void 0 || def.max !== void 0);
    }
    function isCheckbox(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "checkbox";
    }
    function isAngleParam(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "angle";
    }
    function getParamOptions(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.options || [];
    }
    function getLayerIcon(type) {
      const icons = {
        solid: "â– ",
        text: "T",
        spline: "~",
        null: "â–¡",
        camera: "ðŸ“·",
        light: "ðŸ’¡",
        particles: "âœ¦",
        image: "ðŸ–¼"
      };
      return icons[type] || "â€¢";
    }
    function addEffect(key) {
      if (layer.value) {
        store.addEffectToLayer(layer.value.id, key);
        showAddMenu.value = false;
      }
    }
    function removeEffect(effect) {
      if (layer.value) store.removeEffectFromLayer(layer.value.id, effect.id);
    }
    function toggleEffect(effect) {
      if (layer.value) store.toggleEffect(layer.value.id, effect.id);
    }
    function toggleExpand(effect) {
      effect.expanded = !effect.expanded;
    }
    function updateParam(effectId, paramKey, value) {
      if (layer.value) store.updateEffectParameter(layer.value.id, effectId, paramKey, value);
    }
    function updatePoint(effectId, paramKey, axis, val) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      if (!effect) return;
      const current = effect.parameters[paramKey].value;
      const newValue = { ...current, [axis]: val };
      store.updateEffectParameter(layer.value.id, effectId, paramKey, newValue);
    }
    function formatColor(val) {
      if (typeof val === "string") return val;
      return rgbaToHex(val.r, val.g, val.b, val.a ?? 1);
    }
    function updateColor(effectId, paramKey, hex) {
      const rgba = hexToRgba(hex);
      if (rgba && layer.value) {
        const val = { r: rgba[0], g: rgba[1], b: rgba[2], a: rgba[3] };
        store.updateEffectParameter(layer.value.id, effectId, paramKey, val);
      }
    }
    function toggleParamAnim(effectId, paramKey) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      const param = effect?.parameters[paramKey];
      if (param) {
        store.setEffectParamAnimated(layer.value.id, effectId, paramKey, !param.animated);
      }
    }
    function onClickOutside(e) {
      if (menuRef.value && !menuRef.value.contains(e.target)) {
        showAddMenu.value = false;
      }
    }
    onMounted(() => window.addEventListener("mousedown", onClickOutside));
    onUnmounted(() => window.removeEventListener("mousedown", onClickOutside));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        createBaseVNode("div", _hoisted_2$x, [
          createBaseVNode("div", _hoisted_3$x, [
            _cache[1] || (_cache[1] = createBaseVNode("h3", null, "Effect Controls", -1)),
            layer.value ? (openBlock(), createElementBlock("div", _hoisted_4$x, [
              createBaseVNode("span", _hoisted_5$x, toDisplayString(getLayerIcon(layer.value.type)), 1),
              createTextVNode(" " + toDisplayString(layer.value.name), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: "add-effect-wrapper",
            ref_key: "menuRef",
            ref: menuRef
          }, [
            createBaseVNode("button", {
              class: "add-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => showAddMenu.value = !showAddMenu.value),
              disabled: !layer.value
            }, [..._cache[2] || (_cache[2] = [
              createBaseVNode("span", { class: "icon" }, "+", -1),
              createTextVNode(" Add Effect ", -1)
            ])], 8, _hoisted_6$x),
            showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_7$x, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(categories), (catInfo, catKey) => {
                return openBlock(), createElementBlock("div", {
                  key: catKey,
                  class: "effect-category"
                }, [
                  createBaseVNode("div", _hoisted_8$w, [
                    createBaseVNode("span", _hoisted_9$v, toDisplayString(catInfo.icon), 1),
                    createTextVNode(" " + toDisplayString(catInfo.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_10$u, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getEffectsByCategory(catKey), (def) => {
                      return openBlock(), createElementBlock("button", {
                        key: def.key,
                        onClick: ($event) => addEffect(def.key)
                      }, toDisplayString(def.name), 9, _hoisted_11$t);
                    }), 128))
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 512)
        ]),
        createBaseVNode("div", _hoisted_12$r, [
          !layer.value ? (openBlock(), createElementBlock("div", _hoisted_13$q, " Select a layer to edit effects ")) : !layer.value.effects || layer.value.effects.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_14$o, " No effects applied ")) : (openBlock(), createElementBlock("div", _hoisted_15$o, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(layer.value.effects, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: normalizeClass(["effect-item", { collapsed: !effect.expanded }])
              }, [
                createBaseVNode("div", {
                  class: "effect-header",
                  onClick: ($event) => toggleExpand(effect)
                }, [
                  createBaseVNode("div", _hoisted_17$n, [
                    createBaseVNode("span", _hoisted_18$m, toDisplayString(effect.expanded ? "â–¼" : "â–¶"), 1),
                    createBaseVNode("button", {
                      class: "icon-btn",
                      onClick: withModifiers(($event) => toggleEffect(effect), ["stop"])
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(["fx-icon", { disabled: !effect.enabled }])
                      }, "fx", 2)
                    ], 8, _hoisted_19$m),
                    createBaseVNode("span", _hoisted_20$m, toDisplayString(effect.name), 1)
                  ]),
                  createBaseVNode("div", _hoisted_21$k, [
                    createBaseVNode("button", {
                      class: "icon-btn delete",
                      onClick: withModifiers(($event) => removeEffect(effect), ["stop"]),
                      title: "Remove Effect"
                    }, "Ã—", 8, _hoisted_22$j)
                  ])
                ], 8, _hoisted_16$o),
                effect.expanded ? (openBlock(), createElementBlock("div", _hoisted_23$j, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(effect.parameters, (param, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: "param-row"
                    }, [
                      createBaseVNode("div", _hoisted_24$h, [
                        createBaseVNode("span", {
                          class: "param-name",
                          title: String(key)
                        }, toDisplayString(param.name), 9, _hoisted_25$h),
                        createBaseVNode("button", {
                          class: normalizeClass(["stopwatch", { active: param.animated }]),
                          onClick: ($event) => toggleParamAnim(effect.id, String(key)),
                          title: "Toggle Animation"
                        }, "â±", 10, _hoisted_26$h)
                      ]),
                      createBaseVNode("div", _hoisted_27$g, [
                        param.type === "number" && isAngleParam(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("div", _hoisted_28$g, [
                          createVNode(AngleDial, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            size: 32,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            unit: "Â°"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "number" ? (openBlock(), createElementBlock("div", _hoisted_29$g, [
                          hasRange(effect.effectKey, String(key)) ? (openBlock(), createBlock(SliderInput, {
                            key: 0,
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            min: getParamDef(effect.effectKey, String(key))?.min ?? 0,
                            max: getParamDef(effect.effectKey, String(key))?.max ?? 100,
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 1,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : createCommentVNode("", true),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 0.1
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                        ])) : param.type === "position" ? (openBlock(), createElementBlock("div", _hoisted_30$g, [
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.x,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "x", v),
                            label: "X"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.y,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "y", v),
                            label: "Y"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "color" ? (openBlock(), createBlock(ColorPicker, {
                          key: 3,
                          modelValue: formatColor(param.value),
                          "onUpdate:modelValue": (v) => updateColor(effect.id, String(key), v),
                          alpha: true
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])) : param.type === "enum" && isCheckbox(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("input", {
                          key: 4,
                          type: "checkbox",
                          checked: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.checked)
                        }, null, 40, _hoisted_31$d)) : param.type === "enum" ? (openBlock(), createElementBlock("select", {
                          key: 5,
                          value: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.value),
                          class: "param-select"
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(getParamOptions(effect.effectKey, String(key)), (opt) => {
                            return openBlock(), createElementBlock("option", {
                              key: opt.value,
                              value: opt.value
                            }, toDisplayString(opt.label), 9, _hoisted_33$c);
                          }), 128))
                        ], 40, _hoisted_32$c)) : createCommentVNode("", true)
                      ])
                    ]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]))
        ])
      ]);
    };
  }
});

const EffectControlsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-8ac57c6b"]]);

const fontLogger = createLogger("Font");
const WEB_SAFE_FONTS = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
];
const GOOGLE_FONTS = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class FontService {
  systemFonts = [];
  loadedGoogleFonts = /* @__PURE__ */ new Set();
  initialized = false;
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    if (this.initialized) return;
    if ("queryLocalFonts" in window) {
      await this.loadSystemFonts();
    }
    this.initialized = true;
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const fonts = await window.queryLocalFonts();
      const familyMap = /* @__PURE__ */ new Map();
      for (const font of fonts) {
        if (!familyMap.has(font.family) || font.style === "Regular") {
          familyMap.set(font.family, {
            family: font.family,
            fullName: font.fullName,
            style: font.style,
            source: "system"
          });
        }
      }
      this.systemFonts = Array.from(familyMap.values()).sort((a, b) => a.family.localeCompare(b.family));
      fontLogger.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (error) {
      if (error.name === "NotAllowedError") {
        fontLogger.info("User denied font access permission");
      } else {
        fontLogger.error("Error loading system fonts:", error);
      }
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const categories = [];
    if (this.systemFonts.length > 0) {
      categories.push({
        name: "System Fonts",
        fonts: this.systemFonts
      });
    }
    categories.push({
      name: "Web Safe",
      fonts: WEB_SAFE_FONTS
    });
    categories.push({
      name: "Google Fonts",
      fonts: GOOGLE_FONTS.map((family) => ({
        family,
        fullName: family,
        style: "normal",
        source: "google"
      }))
    });
    return categories;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const families = /* @__PURE__ */ new Set();
    WEB_SAFE_FONTS.forEach((f) => families.add(f.family));
    GOOGLE_FONTS.forEach((f) => families.add(f));
    this.systemFonts.forEach((f) => families.add(f.family));
    return Array.from(families).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(family, weights = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(family)) return;
    const weightsStr = weights.join(";");
    const url = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(family)}:wght@${weightsStr}&display=swap`;
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = url;
    document.head.appendChild(link);
    try {
      await document.fonts.load(`400 16px "${family}"`);
      this.loadedGoogleFonts.add(family);
      fontLogger.debug(`Loaded Google Font: ${family}`);
    } catch (error) {
      fontLogger.error(`Failed to load Google Font: ${family}`, error);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(family) {
    if (WEB_SAFE_FONTS.some((f) => f.family === family)) {
      return true;
    }
    if (GOOGLE_FONTS.includes(family)) {
      await this.loadGoogleFont(family);
      return true;
    }
    if (this.systemFonts.some((f) => f.family === family)) {
      return true;
    }
    return this.isFontAvailable(family);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(family) {
    const testString = "mmmmmmmmmmlli";
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = "72px monospace";
    const fallbackWidth = ctx.measureText(testString).width;
    ctx.font = `72px "${family}", monospace`;
    const testWidth = ctx.measureText(testString).width;
    return fallbackWidth !== testWidth;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return WEB_SAFE_FONTS;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return GOOGLE_FONTS;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    if (!("queryLocalFonts" in window)) {
      fontLogger.info("Local Font Access API not available");
      return false;
    }
    await this.loadSystemFonts();
    return this.systemFonts.length > 0;
  }
}
const fontService = new FontService();

const _hoisted_1$x = { class: "text-properties" };
const _hoisted_2$w = { class: "prop-section" };
const _hoisted_3$w = ["value"];
const _hoisted_4$w = { class: "prop-section" };
const _hoisted_5$w = { class: "row font-row" };
const _hoisted_6$w = ["value"];
const _hoisted_7$w = ["label"];
const _hoisted_8$v = ["value"];
const _hoisted_9$u = { class: "style-toggles" };
const _hoisted_10$t = {
  key: 0,
  class: "row"
};
const _hoisted_11$s = ["disabled"];
const _hoisted_12$q = { class: "row" };
const _hoisted_13$p = { class: "row color-row" };
const _hoisted_14$n = { class: "color-item" };
const _hoisted_15$n = ["value"];
const _hoisted_16$n = { class: "color-item" };
const _hoisted_17$m = ["value"];
const _hoisted_18$l = { class: "row" };
const _hoisted_19$l = { class: "row" };
const _hoisted_20$l = { class: "align-buttons" };
const _hoisted_21$j = { class: "prop-section" };
const _hoisted_22$i = { class: "row" };
const _hoisted_23$i = { class: "vec2" };
const _hoisted_24$g = { class: "row" };
const _hoisted_25$g = { class: "vec2" };
const _hoisted_26$g = { class: "row" };
const _hoisted_27$f = { class: "vec2" };
const _hoisted_28$f = { class: "row" };
const _hoisted_29$f = { class: "row" };
const _hoisted_30$f = { class: "prop-section" };
const _hoisted_31$c = { class: "row" };
const _hoisted_32$b = ["value"];
const _hoisted_33$b = ["value"];
const _hoisted_34$b = { class: "row" };
const _hoisted_35$b = { class: "row" };
const _hoisted_36$b = { class: "row" };
const _hoisted_37$b = { class: "row checkbox-row" };
const _hoisted_38$b = ["checked"];
const _hoisted_39$a = { class: "row checkbox-row" };
const _hoisted_40$9 = ["checked"];
const _hoisted_41$7 = { class: "row checkbox-row" };
const _hoisted_42$6 = ["checked"];
const _hoisted_43$6 = { class: "prop-section" };
const _hoisted_44$6 = { class: "row" };
const _hoisted_45$6 = { class: "row" };
const _hoisted_46$6 = { class: "row" };
const _hoisted_47$6 = { class: "prop-section checkbox" };
const _hoisted_48$6 = ["checked"];
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const fontCategories = ref([]);
    const hasSystemFonts = ref(false);
    const loadingFonts = ref(false);
    onMounted(async () => {
      await fontService.initialize();
      fontCategories.value = fontService.getFontCategories();
      hasSystemFonts.value = fontService.hasSystemFonts();
    });
    async function requestFontAccess() {
      loadingFonts.value = true;
      try {
        const success = await fontService.requestSystemFontAccess();
        if (success) {
          fontCategories.value = fontService.getFontCategories();
          hasSystemFonts.value = true;
        }
      } finally {
        loadingFonts.value = false;
      }
    }
    const textData = computed(() => props.layer.data);
    const transform = computed(() => props.layer.transform);
    const splineLayers = computed(() => store.layers.filter((l) => l.type === "spline"));
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const p = getProperty(name);
      return p ? p.value : null;
    }
    function updateText(val) {
      store.setPropertyValue(props.layer.id, "Source Text", val);
      store.updateLayerData(props.layer.id, { text: val });
      emit("update");
    }
    function updateData(key, val) {
      store.updateLayerData(props.layer.id, { [key]: val });
      const map = {
        "fill": "Fill Color",
        "stroke": "Stroke Color",
        "fontSize": "Font Size",
        "strokeWidth": "Stroke Width"
      };
      if (map[key]) {
        store.setPropertyValue(props.layer.id, map[key], val);
      }
      emit("update");
    }
    function updateAnimatable(name, val) {
      store.setPropertyValue(props.layer.id, name, val);
      const keyMap = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        "Tracking": "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      if (keyMap[name]) {
        store.updateLayerData(props.layer.id, { [keyMap[name]]: val });
      }
      emit("update");
    }
    function isPropertyAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function toggleKeyframe(name) {
      const prop = getProperty(name);
      if (!prop) return;
      const currentFrame = store.currentFrame;
      const existingKf = prop.keyframes?.find((kf) => kf.frame === currentFrame);
      if (existingKf) {
        store.removeKeyframe(props.layer.id, name, existingKf.id);
      } else {
        store.addKeyframe(props.layer.id, name, prop.value, currentFrame);
      }
      emit("update");
    }
    function updateTransform(propName, axis, val) {
      const prop = transform.value[propName];
      let newValue;
      if (axis) {
        newValue = { ...prop.value, [axis]: val };
      } else {
        newValue = val;
      }
      store.setPropertyValue(props.layer.id, `transform.${propName}`, newValue);
      emit("update");
    }
    function updateOpacity(val) {
      store.setPropertyValue(props.layer.id, "opacity", val);
      emit("update");
    }
    function toggleBold() {
      updateData("fontWeight", textData.value.fontWeight === "bold" ? "400" : "bold");
    }
    function toggleItalic() {
      updateData("fontStyle", textData.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function handleFontChange(family) {
      await fontService.ensureFont(family);
      updateData("fontFamily", family);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", _hoisted_2$w, [
          _cache[29] || (_cache[29] = createBaseVNode("div", { class: "section-title" }, "Source Text", -1)),
          createBaseVNode("textarea", {
            value: textData.value.text,
            onInput: _cache[0] || (_cache[0] = (e) => updateText(e.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, _hoisted_3$w)
        ]),
        createBaseVNode("div", _hoisted_4$w, [
          _cache[35] || (_cache[35] = createBaseVNode("div", { class: "section-title" }, "Character", -1)),
          createBaseVNode("div", _hoisted_5$w, [
            createBaseVNode("select", {
              value: textData.value.fontFamily,
              onChange: _cache[1] || (_cache[1] = (e) => handleFontChange(e.target.value)),
              class: "font-select"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(fontCategories.value, (category) => {
                return openBlock(), createElementBlock("optgroup", {
                  key: category.name,
                  label: category.name
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.fonts, (font) => {
                    return openBlock(), createElementBlock("option", {
                      key: font.family,
                      value: font.family
                    }, toDisplayString(font.family), 9, _hoisted_8$v);
                  }), 128))
                ], 8, _hoisted_7$w);
              }), 128))
            ], 40, _hoisted_6$w),
            createBaseVNode("div", _hoisted_9$u, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontWeight === "bold" }),
                onClick: toggleBold
              }, "B", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontStyle === "italic" }),
                onClick: toggleItalic
              }, "I", 2)
            ])
          ]),
          !hasSystemFonts.value ? (openBlock(), createElementBlock("div", _hoisted_10$t, [
            createBaseVNode("button", {
              class: "font-access-btn",
              onClick: requestFontAccess,
              disabled: loadingFonts.value
            }, toDisplayString(loadingFonts.value ? "Loading..." : "+ Load System Fonts"), 9, _hoisted_11$s)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$q, [
            _cache[30] || (_cache[30] = createBaseVNode("label", null, "Size", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Font Size") || textData.value.fontSize,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("Font Size", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_13$p, [
            createBaseVNode("div", _hoisted_14$n, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.fill,
                onInput: _cache[3] || (_cache[3] = (e) => updateData("fill", e.target.value))
              }, null, 40, _hoisted_15$n),
              _cache[31] || (_cache[31] = createBaseVNode("span", null, "Fill", -1))
            ]),
            createBaseVNode("div", _hoisted_16$n, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.stroke || "#000000",
                onInput: _cache[4] || (_cache[4] = (e) => updateData("stroke", e.target.value))
              }, null, 40, _hoisted_17$m),
              _cache[32] || (_cache[32] = createBaseVNode("span", null, "Stroke", -1))
            ])
          ]),
          createBaseVNode("div", _hoisted_18$l, [
            _cache[33] || (_cache[33] = createBaseVNode("label", null, "Stroke Width", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Stroke Width") || textData.value.strokeWidth || 0,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_19$l, [
            _cache[34] || (_cache[34] = createBaseVNode("label", null, "Alignment", -1)),
            createBaseVNode("div", _hoisted_20$l, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "left" }),
                onClick: _cache[6] || (_cache[6] = ($event) => updateData("textAlign", "left"))
              }, "â—€", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "center" }),
                onClick: _cache[7] || (_cache[7] = ($event) => updateData("textAlign", "center"))
              }, "â–¬", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "right" }),
                onClick: _cache[8] || (_cache[8] = ($event) => updateData("textAlign", "right"))
              }, "â–¶", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_21$j, [
          _cache[41] || (_cache[41] = createBaseVNode("div", { class: "section-title" }, "Transform", -1)),
          createBaseVNode("div", _hoisted_22$i, [
            _cache[36] || (_cache[36] = createBaseVNode("label", null, "Position", -1)),
            createBaseVNode("div", _hoisted_23$i, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.x,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateTransform("position", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.y,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateTransform("position", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_24$g, [
            _cache[37] || (_cache[37] = createBaseVNode("label", null, "Anchor Pt", -1)),
            createBaseVNode("div", _hoisted_25$g, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.x,
                "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateTransform("anchorPoint", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.y,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateTransform("anchorPoint", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_26$g, [
            _cache[38] || (_cache[38] = createBaseVNode("label", null, "Scale %", -1)),
            createBaseVNode("div", _hoisted_27$f, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.x,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateTransform("scale", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.y,
                "onUpdate:modelValue": _cache[14] || (_cache[14] = (v) => updateTransform("scale", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_28$f, [
            _cache[39] || (_cache[39] = createBaseVNode("label", null, "Rotation", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: transform.value.rotation.value,
              "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateTransform("rotation", null, v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_29$f, [
            _cache[40] || (_cache[40] = createBaseVNode("label", null, "Opacity", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: __props.layer.opacity?.value ?? 100,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updateOpacity(v)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_30$f, [
          _cache[50] || (_cache[50] = createBaseVNode("div", { class: "section-title" }, "Path Options", -1)),
          createBaseVNode("div", _hoisted_31$c, [
            _cache[43] || (_cache[43] = createBaseVNode("label", null, "Path", -1)),
            createBaseVNode("select", {
              value: textData.value.pathLayerId || "",
              onChange: _cache[17] || (_cache[17] = (e) => updateData("pathLayerId", e.target.value || null)),
              class: "full-select"
            }, [
              _cache[42] || (_cache[42] = createBaseVNode("option", { value: "" }, "None", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (l) => {
                return openBlock(), createElementBlock("option", {
                  key: l.id,
                  value: l.id
                }, toDisplayString(l.name), 9, _hoisted_33$b);
              }), 128))
            ], 40, _hoisted_32$b)
          ]),
          textData.value.pathLayerId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_34$b, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Path Offset %", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Offset") ?? textData.value.pathOffset ?? 0,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Path Offset", v)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isPropertyAnimated("Path Offset") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Path Offset")),
                title: "Add keyframe"
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_35$b, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "First Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("First Margin") ?? textData.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateAnimatable("First Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_36$b, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Last Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Last Margin") ?? textData.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Last Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$b, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathReversed,
                  onChange: _cache[22] || (_cache[22] = ($event) => updateData("pathReversed", !textData.value.pathReversed))
                }, null, 40, _hoisted_38$b),
                _cache[47] || (_cache[47] = createTextVNode(" Reverse Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_39$a, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathPerpendicularToPath ?? true,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateData("pathPerpendicularToPath", !textData.value.pathPerpendicularToPath))
                }, null, 40, _hoisted_40$9),
                _cache[48] || (_cache[48] = createTextVNode(" Perpendicular to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_41$7, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathForceAlignment,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateData("pathForceAlignment", !textData.value.pathForceAlignment))
                }, null, 40, _hoisted_42$6),
                _cache[49] || (_cache[49] = createTextVNode(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_43$6, [
          _cache[54] || (_cache[54] = createBaseVNode("div", { class: "section-title" }, "Advanced", -1)),
          createBaseVNode("div", _hoisted_44$6, [
            _cache[51] || (_cache[51] = createBaseVNode("label", null, "Tracking", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Tracking") || textData.value.tracking || 0,
              "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Tracking", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_45$6, [
            _cache[52] || (_cache[52] = createBaseVNode("label", null, "Line Spacing", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Line Spacing") || textData.value.lineSpacing || 0,
              "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateAnimatable("Line Spacing", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_46$6, [
            _cache[53] || (_cache[53] = createBaseVNode("label", null, "Char Offset", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Character Offset") || textData.value.characterOffset || 0,
              "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateAnimatable("Character Offset", v)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_47$6, [
          createBaseVNode("label", null, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: textData.value.perCharacter3D,
              onChange: _cache[28] || (_cache[28] = ($event) => updateData("perCharacter3D", !textData.value.perCharacter3D))
            }, null, 40, _hoisted_48$6),
            _cache[55] || (_cache[55] = createTextVNode(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
});

const TextProperties = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-947c42b2"]]);

const _hoisted_1$w = { class: "particle-properties" };
const _hoisted_2$v = { class: "property-section" };
const _hoisted_3$v = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$v = { class: "property-row" };
const _hoisted_5$v = ["value"];
const _hoisted_6$v = { class: "value-display" };
const _hoisted_7$v = { class: "property-row" };
const _hoisted_8$u = ["value"];
const _hoisted_9$t = { class: "value-display" };
const _hoisted_10$s = { class: "property-row" };
const _hoisted_11$r = ["value"];
const _hoisted_12$p = { class: "value-display" };
const _hoisted_13$o = { class: "property-row" };
const _hoisted_14$m = ["value"];
const _hoisted_15$m = { class: "value-display" };
const _hoisted_16$m = { class: "property-row" };
const _hoisted_17$l = ["value"];
const _hoisted_18$k = { class: "value-display" };
const _hoisted_19$k = { class: "property-row" };
const _hoisted_20$k = ["value"];
const _hoisted_21$i = { class: "property-section" };
const _hoisted_22$h = {
  key: 0,
  class: "section-content"
};
const _hoisted_23$h = ["onClick"];
const _hoisted_24$f = ["value", "onInput"];
const _hoisted_25$f = { class: "enabled-toggle" };
const _hoisted_26$f = ["checked", "onChange"];
const _hoisted_27$e = ["onClick"];
const _hoisted_28$e = {
  key: 0,
  class: "emitter-content"
};
const _hoisted_29$e = { class: "property-row" };
const _hoisted_30$e = ["value", "onInput"];
const _hoisted_31$b = { class: "value-display" };
const _hoisted_32$a = { class: "property-row" };
const _hoisted_33$a = ["value", "onInput"];
const _hoisted_34$a = { class: "value-display" };
const _hoisted_35$a = { class: "property-row" };
const _hoisted_36$a = ["value", "onInput"];
const _hoisted_37$a = { class: "value-display" };
const _hoisted_38$a = { class: "property-row" };
const _hoisted_39$9 = ["value", "onInput"];
const _hoisted_40$8 = { class: "value-display" };
const _hoisted_41$6 = { class: "property-row" };
const _hoisted_42$5 = ["value", "onInput"];
const _hoisted_43$5 = { class: "value-display" };
const _hoisted_44$5 = { class: "property-row" };
const _hoisted_45$5 = ["value", "onInput"];
const _hoisted_46$5 = { class: "value-display" };
const _hoisted_47$5 = { class: "property-row" };
const _hoisted_48$5 = ["value", "onInput"];
const _hoisted_49$5 = { class: "value-display" };
const _hoisted_50$4 = { class: "property-row" };
const _hoisted_51$4 = ["value", "onInput"];
const _hoisted_52$4 = { class: "value-display" };
const _hoisted_53$4 = { class: "property-row" };
const _hoisted_54$4 = ["value", "onInput"];
const _hoisted_55$4 = { class: "property-row" };
const _hoisted_56$4 = ["value", "onInput"];
const _hoisted_57$4 = { class: "value-display" };
const _hoisted_58$4 = { class: "property-row" };
const _hoisted_59$4 = ["value", "onInput"];
const _hoisted_60$4 = { class: "value-display" };
const _hoisted_61$4 = { class: "property-row" };
const _hoisted_62$4 = ["value", "onInput"];
const _hoisted_63$2 = { class: "value-display" };
const _hoisted_64$2 = { class: "property-row checkbox-row" };
const _hoisted_65$2 = ["checked", "onChange"];
const _hoisted_66$2 = {
  key: 0,
  class: "property-row"
};
const _hoisted_67$2 = ["value", "onInput"];
const _hoisted_68$2 = { class: "value-display" };
const _hoisted_69$2 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_70$2 = { class: "property-section" };
const _hoisted_71$2 = {
  key: 0,
  class: "section-content"
};
const _hoisted_72$2 = { class: "force-tabs" };
const _hoisted_73$2 = {
  key: 0,
  class: "force-list"
};
const _hoisted_74$2 = { class: "force-header" };
const _hoisted_75$2 = ["value", "onInput"];
const _hoisted_76$2 = { class: "enabled-toggle" };
const _hoisted_77$2 = ["checked", "onChange"];
const _hoisted_78$2 = ["onClick"];
const _hoisted_79$1 = { class: "property-row" };
const _hoisted_80$1 = ["value", "onInput"];
const _hoisted_81$1 = { class: "value-display" };
const _hoisted_82$1 = { class: "property-row" };
const _hoisted_83$1 = ["value", "onInput"];
const _hoisted_84$1 = { class: "value-display" };
const _hoisted_85$1 = { class: "property-row" };
const _hoisted_86$1 = ["value", "onInput"];
const _hoisted_87$1 = { class: "value-display" };
const _hoisted_88$1 = { class: "property-row" };
const _hoisted_89$1 = ["value", "onInput"];
const _hoisted_90$1 = { class: "value-display" };
const _hoisted_91$1 = { class: "property-row" };
const _hoisted_92$1 = ["value", "onChange"];
const _hoisted_93$1 = {
  key: 1,
  class: "force-list"
};
const _hoisted_94$1 = { class: "force-header" };
const _hoisted_95 = ["value", "onInput"];
const _hoisted_96 = { class: "enabled-toggle" };
const _hoisted_97 = ["checked", "onChange"];
const _hoisted_98 = ["onClick"];
const _hoisted_99 = { class: "property-row" };
const _hoisted_100 = ["value", "onInput"];
const _hoisted_101 = { class: "value-display" };
const _hoisted_102 = { class: "property-row" };
const _hoisted_103 = ["value", "onInput"];
const _hoisted_104 = { class: "value-display" };
const _hoisted_105 = { class: "property-row" };
const _hoisted_106 = ["value", "onInput"];
const _hoisted_107 = { class: "value-display" };
const _hoisted_108 = { class: "property-row" };
const _hoisted_109 = ["value", "onInput"];
const _hoisted_110 = { class: "value-display" };
const _hoisted_111 = { class: "property-row" };
const _hoisted_112 = ["value", "onInput"];
const _hoisted_113 = { class: "value-display" };
const _hoisted_114 = { class: "property-row" };
const _hoisted_115 = ["value", "onInput"];
const _hoisted_116 = { class: "value-display" };
const _hoisted_117 = { class: "property-section" };
const _hoisted_118 = {
  key: 0,
  class: "section-content"
};
const _hoisted_119 = { class: "force-header" };
const _hoisted_120 = { class: "enabled-toggle" };
const _hoisted_121 = ["checked", "onChange"];
const _hoisted_122 = ["onClick"];
const _hoisted_123 = { class: "property-row" };
const _hoisted_124 = ["value", "onInput"];
const _hoisted_125 = { class: "value-display" };
const _hoisted_126 = { class: "property-row" };
const _hoisted_127 = ["value", "onInput"];
const _hoisted_128 = { class: "value-display" };
const _hoisted_129 = { class: "property-row" };
const _hoisted_130 = ["value", "onInput"];
const _hoisted_131 = { class: "value-display" };
const _hoisted_132 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_133 = { class: "property-section" };
const _hoisted_134 = {
  key: 0,
  class: "section-content"
};
const _hoisted_135 = { class: "force-header" };
const _hoisted_136 = ["value", "onChange"];
const _hoisted_137 = ["value"];
const _hoisted_138 = { class: "enabled-toggle" };
const _hoisted_139 = ["checked", "onChange"];
const _hoisted_140 = ["onClick"];
const _hoisted_141 = { class: "property-row" };
const _hoisted_142 = ["value", "onChange"];
const _hoisted_143 = { class: "property-row" };
const _hoisted_144 = ["value", "onInput"];
const _hoisted_145 = { class: "value-display" };
const _hoisted_146 = { class: "property-row" };
const _hoisted_147 = ["value", "onInput"];
const _hoisted_148 = { class: "value-display" };
const _hoisted_149 = { class: "property-row" };
const _hoisted_150 = ["value", "onInput"];
const _hoisted_151 = { class: "value-display" };
const _hoisted_152 = { class: "property-row" };
const _hoisted_153 = ["value", "onInput"];
const _hoisted_154 = { class: "value-display" };
const _hoisted_155 = { class: "property-row" };
const _hoisted_156 = ["value", "onInput"];
const _hoisted_157 = { class: "value-display" };
const _hoisted_158 = { class: "property-row" };
const _hoisted_159 = ["value", "onInput"];
const _hoisted_160 = { class: "value-display" };
const _hoisted_161 = { class: "property-row" };
const _hoisted_162 = ["value", "onInput"];
const _hoisted_163 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_164 = { class: "property-section" };
const _hoisted_165 = {
  key: 0,
  class: "section-content"
};
const _hoisted_166 = { class: "modulation-header" };
const _hoisted_167 = ["value", "onChange"];
const _hoisted_168 = ["value"];
const _hoisted_169 = ["onClick"];
const _hoisted_170 = { class: "property-row" };
const _hoisted_171 = ["value", "onChange"];
const _hoisted_172 = { class: "property-row" };
const _hoisted_173 = ["value", "onInput"];
const _hoisted_174 = { class: "property-row" };
const _hoisted_175 = ["value", "onInput"];
const _hoisted_176 = { class: "property-row" };
const _hoisted_177 = ["value", "onChange"];
const _hoisted_178 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_179 = { class: "property-section" };
const _hoisted_180 = {
  key: 0,
  class: "section-content"
};
const _hoisted_181 = { class: "property-row" };
const _hoisted_182 = ["value"];
const _hoisted_183 = { class: "property-row" };
const _hoisted_184 = ["value"];
const _hoisted_185 = { class: "property-row checkbox-row" };
const _hoisted_186 = ["checked"];
const _hoisted_187 = {
  key: 0,
  class: "property-row"
};
const _hoisted_188 = ["value"];
const _hoisted_189 = { class: "value-display" };
const _hoisted_190 = { class: "property-row checkbox-row" };
const _hoisted_191 = ["checked"];
const _hoisted_192 = {
  key: 1,
  class: "property-row"
};
const _hoisted_193 = ["value"];
const _hoisted_194 = { class: "value-display" };
const _hoisted_195 = {
  key: 2,
  class: "property-row"
};
const _hoisted_196 = ["value"];
const _hoisted_197 = { class: "value-display" };
const _hoisted_198 = { class: "property-row checkbox-row" };
const _hoisted_199 = ["checked"];
const _hoisted_200 = {
  key: 3,
  class: "property-row"
};
const _hoisted_201 = ["value"];
const _hoisted_202 = { class: "value-display" };
const _hoisted_203 = {
  key: 4,
  class: "property-row"
};
const _hoisted_204 = ["value"];
const _hoisted_205 = { class: "value-display" };
const _hoisted_206 = {
  key: 5,
  class: "property-row"
};
const _hoisted_207 = ["value"];
const _hoisted_208 = { class: "value-display" };
const _hoisted_209 = {
  key: 6,
  class: "property-row"
};
const _hoisted_210 = ["value"];
const _hoisted_211 = { class: "value-display" };
const _hoisted_212 = {
  key: 7,
  class: "property-row checkbox-row"
};
const _hoisted_213 = ["checked"];
const _hoisted_214 = { class: "particle-count" };
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const expandedSections = ref(/* @__PURE__ */ new Set(["system", "emitters"]));
    const expandedEmitters = ref(/* @__PURE__ */ new Set());
    const forceTab = ref("wells");
    const layerData = computed(() => {
      const data = props.layer.data;
      return data || {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
    });
    const systemConfig = computed(() => layerData.value.systemConfig);
    const emitters = computed(() => layerData.value.emitters);
    const gravityWells = computed(() => layerData.value.gravityWells);
    const vortices = computed(() => layerData.value.vortices);
    const modulations = computed(() => layerData.value.modulations);
    const renderOptions = computed(() => layerData.value.renderOptions);
    const turbulenceFields = computed(() => layerData.value.turbulenceFields || []);
    const subEmitters = computed(() => layerData.value.subEmitters || []);
    const connections = computed(() => renderOptions.value.connections || {
      enabled: false,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: true
    });
    const particleCount = computed(() => props.particleCount);
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleEmitter(id) {
      if (expandedEmitters.value.has(id)) {
        expandedEmitters.value.delete(id);
      } else {
        expandedEmitters.value.add(id);
      }
    }
    function updateSystemConfig(key, value) {
      emit("update", {
        systemConfig: { ...systemConfig.value, [key]: value }
      });
    }
    function updateEmitter(id, key, value) {
      const updated = emitters.value.map(
        (e) => e.id === id ? { ...e, [key]: value } : e
      );
      emit("update", { emitters: updated });
    }
    function updateEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateEmitter(id, "color", rgb);
    }
    function addEmitter() {
      const newEmitter = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${emitters.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: true,
        burstOnBeat: false,
        burstCount: 20
      };
      emit("update", { emitters: [...emitters.value, newEmitter] });
      expandedEmitters.value.add(newEmitter.id);
    }
    function removeEmitter(id) {
      emit("update", { emitters: emitters.value.filter((e) => e.id !== id) });
    }
    function updateGravityWell(id, key, value) {
      const updated = gravityWells.value.map(
        (w) => w.id === id ? { ...w, [key]: value } : w
      );
      emit("update", { gravityWells: updated });
    }
    function addGravityWell() {
      const newWell = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${gravityWells.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: true
      };
      emit("update", { gravityWells: [...gravityWells.value, newWell] });
    }
    function removeGravityWell(id) {
      emit("update", { gravityWells: gravityWells.value.filter((w) => w.id !== id) });
    }
    function updateVortex(id, key, value) {
      const updated = vortices.value.map(
        (v) => v.id === id ? { ...v, [key]: value } : v
      );
      emit("update", { vortices: updated });
    }
    function addVortex() {
      const newVortex = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${vortices.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: true
      };
      emit("update", { vortices: [...vortices.value, newVortex] });
    }
    function removeVortex(id) {
      emit("update", { vortices: vortices.value.filter((v) => v.id !== id) });
    }
    function updateModulation(id, key, value) {
      const updated = modulations.value.map(
        (m) => m.id === id ? { ...m, [key]: value } : m
      );
      emit("update", { modulations: updated });
    }
    function addModulation() {
      const newMod = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      emit("update", { modulations: [...modulations.value, newMod] });
    }
    function removeModulation(id) {
      emit("update", { modulations: modulations.value.filter((m) => m.id !== id) });
    }
    function updateRenderOption(key, value) {
      emit("update", {
        renderOptions: { ...renderOptions.value, [key]: value }
      });
    }
    function updateConnection(key, value) {
      emit("update", {
        renderOptions: {
          ...renderOptions.value,
          connections: { ...connections.value, [key]: value }
        }
      });
    }
    function updateTurbulence(id, key, value) {
      const updated = turbulenceFields.value.map(
        (t) => t.id === id ? { ...t, [key]: value } : t
      );
      emit("update", { turbulenceFields: updated });
    }
    function addTurbulence() {
      const newTurb = {
        id: `turb_${Date.now()}`,
        enabled: true,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      emit("update", { turbulenceFields: [...turbulenceFields.value, newTurb] });
    }
    function removeTurbulence(id) {
      emit("update", { turbulenceFields: turbulenceFields.value.filter((t) => t.id !== id) });
    }
    function updateSubEmitter(id, key, value) {
      const updated = subEmitters.value.map(
        (s) => s.id === id ? { ...s, [key]: value } : s
      );
      emit("update", { subEmitters: updated });
    }
    function updateSubEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateSubEmitter(id, "color", rgb);
    }
    function addSubEmitter() {
      const newSub = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: true
      };
      emit("update", { subEmitters: [...subEmitters.value, newSub] });
    }
    function removeSubEmitter(id) {
      emit("update", { subEmitters: subEmitters.value.filter((s) => s.id !== id) });
    }
    function rgbToHex(rgb) {
      return "#" + rgb.map((c) => c.toString(16).padStart(2, "0")).join("");
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("div", _hoisted_2$v, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("system"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[30] || (_cache[30] = createBaseVNode("span", null, "System Settings", -1))
          ]),
          expandedSections.value.has("system") ? (openBlock(), createElementBlock("div", _hoisted_3$v, [
            createBaseVNode("div", _hoisted_4$v, [
              _cache[31] || (_cache[31] = createBaseVNode("label", null, "Max Particles", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.maxParticles,
                min: "100",
                max: "50000",
                step: "100",
                onInput: _cache[1] || (_cache[1] = ($event) => updateSystemConfig("maxParticles", Number($event.target.value)))
              }, null, 40, _hoisted_5$v),
              createBaseVNode("span", _hoisted_6$v, toDisplayString(systemConfig.value.maxParticles), 1)
            ]),
            createBaseVNode("div", _hoisted_7$v, [
              _cache[32] || (_cache[32] = createBaseVNode("label", null, "Gravity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.gravity,
                min: "-1000",
                max: "1000",
                step: "10",
                onInput: _cache[2] || (_cache[2] = ($event) => updateSystemConfig("gravity", Number($event.target.value)))
              }, null, 40, _hoisted_8$u),
              createBaseVNode("span", _hoisted_9$t, toDisplayString(systemConfig.value.gravity), 1)
            ]),
            createBaseVNode("div", _hoisted_10$s, [
              _cache[33] || (_cache[33] = createBaseVNode("label", null, "Wind Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windStrength,
                min: "0",
                max: "1000",
                step: "10",
                onInput: _cache[3] || (_cache[3] = ($event) => updateSystemConfig("windStrength", Number($event.target.value)))
              }, null, 40, _hoisted_11$r),
              createBaseVNode("span", _hoisted_12$p, toDisplayString(systemConfig.value.windStrength), 1)
            ]),
            createBaseVNode("div", _hoisted_13$o, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Wind Direction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windDirection,
                min: "0",
                max: "360",
                step: "5",
                onInput: _cache[4] || (_cache[4] = ($event) => updateSystemConfig("windDirection", Number($event.target.value)))
              }, null, 40, _hoisted_14$m),
              createBaseVNode("span", _hoisted_15$m, toDisplayString(systemConfig.value.windDirection) + "Â°", 1)
            ]),
            createBaseVNode("div", _hoisted_16$m, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Friction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.friction,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[5] || (_cache[5] = ($event) => updateSystemConfig("friction", Number($event.target.value)))
              }, null, 40, _hoisted_17$l),
              createBaseVNode("span", _hoisted_18$k, toDisplayString(systemConfig.value.friction.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_19$k, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Boundary", -1)),
              createBaseVNode("select", {
                value: systemConfig.value.boundaryBehavior,
                onChange: _cache[6] || (_cache[6] = ($event) => updateSystemConfig("boundaryBehavior", $event.target.value))
              }, [..._cache[36] || (_cache[36] = [
                createBaseVNode("option", { value: "kill" }, "Kill", -1),
                createBaseVNode("option", { value: "bounce" }, "Bounce", -1),
                createBaseVNode("option", { value: "wrap" }, "Wrap", -1)
              ])], 40, _hoisted_20$k)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_21$i, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("emitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[39] || (_cache[39] = createBaseVNode("span", null, "Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addEmitter, ["stop"]),
              title: "Add Emitter"
            }, [..._cache[38] || (_cache[38] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("emitters") ? (openBlock(), createElementBlock("div", _hoisted_22$h, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (emitter) => {
              return openBlock(), createElementBlock("div", {
                key: emitter.id,
                class: "emitter-item"
              }, [
                createBaseVNode("div", {
                  class: "emitter-header",
                  onClick: ($event) => toggleEmitter(emitter.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedEmitters.value.has(emitter.id) ? "pi-chevron-down" : "pi-chevron-right"])
                  }, null, 2),
                  createBaseVNode("input", {
                    type: "text",
                    value: emitter.name,
                    onInput: ($event) => updateEmitter(emitter.id, "name", $event.target.value),
                    onClick: _cache[8] || (_cache[8] = withModifiers(() => {
                    }, ["stop"])),
                    class: "emitter-name"
                  }, null, 40, _hoisted_24$f),
                  createBaseVNode("label", _hoisted_25$f, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: emitter.enabled,
                      onChange: ($event) => updateEmitter(emitter.id, "enabled", $event.target.checked),
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 40, _hoisted_26$f)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: withModifiers(($event) => removeEmitter(emitter.id), ["stop"]),
                    title: "Remove"
                  }, [..._cache[40] || (_cache[40] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_27$e)
                ], 8, _hoisted_23$h),
                expandedEmitters.value.has(emitter.id) ? (openBlock(), createElementBlock("div", _hoisted_28$e, [
                  createBaseVNode("div", _hoisted_29$e, [
                    _cache[41] || (_cache[41] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_30$e),
                    createBaseVNode("span", _hoisted_31$b, toDisplayString(emitter.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$a, [
                    _cache[42] || (_cache[42] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_33$a),
                    createBaseVNode("span", _hoisted_34$a, toDisplayString(emitter.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$a, [
                    _cache[43] || (_cache[43] = createBaseVNode("label", null, "Direction", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.direction,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "direction", Number($event.target.value))
                    }, null, 40, _hoisted_36$a),
                    createBaseVNode("span", _hoisted_37$a, toDisplayString(emitter.direction) + "Â°", 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$a, [
                    _cache[44] || (_cache[44] = createBaseVNode("label", null, "Spread", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.spread,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "spread", Number($event.target.value))
                    }, null, 40, _hoisted_39$9),
                    createBaseVNode("span", _hoisted_40$8, toDisplayString(emitter.spread) + "Â°", 1)
                  ]),
                  createBaseVNode("div", _hoisted_41$6, [
                    _cache[45] || (_cache[45] = createBaseVNode("label", null, "Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speed,
                      min: "1",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speed", Number($event.target.value))
                    }, null, 40, _hoisted_42$5),
                    createBaseVNode("span", _hoisted_43$5, toDisplayString(emitter.speed), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$5, [
                    _cache[46] || (_cache[46] = createBaseVNode("label", null, "Speed Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speedVariance,
                      min: "0",
                      max: "500",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speedVariance", Number($event.target.value))
                    }, null, 40, _hoisted_45$5),
                    createBaseVNode("span", _hoisted_46$5, toDisplayString(emitter.speedVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$5, [
                    _cache[47] || (_cache[47] = createBaseVNode("label", null, "Size", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.size,
                      min: "1",
                      max: "400",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "size", Number($event.target.value))
                    }, null, 40, _hoisted_48$5),
                    createBaseVNode("span", _hoisted_49$5, toDisplayString(emitter.size) + "px", 1)
                  ]),
                  createBaseVNode("div", _hoisted_50$4, [
                    _cache[48] || (_cache[48] = createBaseVNode("label", null, "Size Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.sizeVariance,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "sizeVariance", Number($event.target.value))
                    }, null, 40, _hoisted_51$4),
                    createBaseVNode("span", _hoisted_52$4, toDisplayString(emitter.sizeVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_53$4, [
                    _cache[49] || (_cache[49] = createBaseVNode("label", null, "Color", -1)),
                    createBaseVNode("input", {
                      type: "color",
                      value: rgbToHex(emitter.color),
                      onInput: ($event) => updateEmitterColor(emitter.id, $event.target.value)
                    }, null, 40, _hoisted_54$4)
                  ]),
                  createBaseVNode("div", _hoisted_55$4, [
                    _cache[50] || (_cache[50] = createBaseVNode("label", null, "Emission Rate", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.emissionRate,
                      min: "0.1",
                      max: "100",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "emissionRate", Number($event.target.value))
                    }, null, 40, _hoisted_56$4),
                    createBaseVNode("span", _hoisted_57$4, toDisplayString(emitter.emissionRate.toFixed(1)) + "/s", 1)
                  ]),
                  createBaseVNode("div", _hoisted_58$4, [
                    _cache[51] || (_cache[51] = createBaseVNode("label", null, "Lifetime", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.particleLifetime,
                      min: "1",
                      max: "300",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "particleLifetime", Number($event.target.value))
                    }, null, 40, _hoisted_59$4),
                    createBaseVNode("span", _hoisted_60$4, toDisplayString(emitter.particleLifetime) + "f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_61$4, [
                    _cache[52] || (_cache[52] = createBaseVNode("label", null, "Initial Burst", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.initialBurst,
                      min: "0",
                      max: "1",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "initialBurst", Number($event.target.value))
                    }, null, 40, _hoisted_62$4),
                    createBaseVNode("span", _hoisted_63$2, toDisplayString((emitter.initialBurst * 100).toFixed(0)) + "%", 1)
                  ]),
                  createBaseVNode("div", _hoisted_64$2, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.burstOnBeat,
                        onChange: ($event) => updateEmitter(emitter.id, "burstOnBeat", $event.target.checked)
                      }, null, 40, _hoisted_65$2),
                      _cache[53] || (_cache[53] = createTextVNode(" Burst on Beat ", -1))
                    ])
                  ]),
                  emitter.burstOnBeat ? (openBlock(), createElementBlock("div", _hoisted_66$2, [
                    _cache[54] || (_cache[54] = createBaseVNode("label", null, "Burst Count", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.burstCount,
                      min: "1",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "burstCount", Number($event.target.value))
                    }, null, 40, _hoisted_67$2),
                    createBaseVNode("span", _hoisted_68$2, toDisplayString(emitter.burstCount), 1)
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            emitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_69$2, " No emitters. Click + to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_70$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("forces"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[55] || (_cache[55] = createBaseVNode("span", null, "Force Fields", -1))
          ]),
          expandedSections.value.has("forces") ? (openBlock(), createElementBlock("div", _hoisted_71$2, [
            createBaseVNode("div", _hoisted_72$2, [
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "wells" }),
                onClick: _cache[11] || (_cache[11] = ($event) => forceTab.value = "wells")
              }, " Gravity Wells ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "vortices" }),
                onClick: _cache[12] || (_cache[12] = ($event) => forceTab.value = "vortices")
              }, " Vortices ", 2)
            ]),
            forceTab.value === "wells" ? (openBlock(), createElementBlock("div", _hoisted_73$2, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addGravityWell
              }, [..._cache[56] || (_cache[56] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Gravity Well ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(gravityWells.value, (well) => {
                return openBlock(), createElementBlock("div", {
                  key: well.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_74$2, [
                    createBaseVNode("input", {
                      type: "text",
                      value: well.name,
                      onInput: ($event) => updateGravityWell(well.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_75$2),
                    createBaseVNode("label", _hoisted_76$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: well.enabled,
                        onChange: ($event) => updateGravityWell(well.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_77$2)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeGravityWell(well.id)
                    }, [..._cache[57] || (_cache[57] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_78$2)
                  ]),
                  createBaseVNode("div", _hoisted_79$1, [
                    _cache[58] || (_cache[58] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_80$1),
                    createBaseVNode("span", _hoisted_81$1, toDisplayString(well.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_82$1, [
                    _cache[59] || (_cache[59] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_83$1),
                    createBaseVNode("span", _hoisted_84$1, toDisplayString(well.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_85$1, [
                    _cache[60] || (_cache[60] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.strength,
                      min: "-1000",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateGravityWell(well.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_86$1),
                    createBaseVNode("span", _hoisted_87$1, toDisplayString(well.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_88$1, [
                    _cache[61] || (_cache[61] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_89$1),
                    createBaseVNode("span", _hoisted_90$1, toDisplayString(well.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_91$1, [
                    _cache[63] || (_cache[63] = createBaseVNode("label", null, "Falloff", -1)),
                    createBaseVNode("select", {
                      value: well.falloff,
                      onChange: ($event) => updateGravityWell(well.id, "falloff", $event.target.value)
                    }, [..._cache[62] || (_cache[62] = [
                      createBaseVNode("option", { value: "linear" }, "Linear", -1),
                      createBaseVNode("option", { value: "quadratic" }, "Quadratic", -1),
                      createBaseVNode("option", { value: "constant" }, "Constant", -1)
                    ])], 40, _hoisted_92$1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            forceTab.value === "vortices" ? (openBlock(), createElementBlock("div", _hoisted_93$1, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addVortex
              }, [..._cache[64] || (_cache[64] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Vortex ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(vortices.value, (vortex) => {
                return openBlock(), createElementBlock("div", {
                  key: vortex.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_94$1, [
                    createBaseVNode("input", {
                      type: "text",
                      value: vortex.name,
                      onInput: ($event) => updateVortex(vortex.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_95),
                    createBaseVNode("label", _hoisted_96, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: vortex.enabled,
                        onChange: ($event) => updateVortex(vortex.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_97)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeVortex(vortex.id)
                    }, [..._cache[65] || (_cache[65] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_98)
                  ]),
                  createBaseVNode("div", _hoisted_99, [
                    _cache[66] || (_cache[66] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_100),
                    createBaseVNode("span", _hoisted_101, toDisplayString(vortex.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_102, [
                    _cache[67] || (_cache[67] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_103),
                    createBaseVNode("span", _hoisted_104, toDisplayString(vortex.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_105, [
                    _cache[68] || (_cache[68] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.strength,
                      min: "0",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateVortex(vortex.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_106),
                    createBaseVNode("span", _hoisted_107, toDisplayString(vortex.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_108, [
                    _cache[69] || (_cache[69] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_109),
                    createBaseVNode("span", _hoisted_110, toDisplayString(vortex.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_111, [
                    _cache[70] || (_cache[70] = createBaseVNode("label", null, "Rotation Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.rotationSpeed,
                      min: "0",
                      max: "50",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "rotationSpeed", Number($event.target.value))
                    }, null, 40, _hoisted_112),
                    createBaseVNode("span", _hoisted_113, toDisplayString(vortex.rotationSpeed) + "Â°/f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_114, [
                    _cache[71] || (_cache[71] = createBaseVNode("label", null, "Inward Pull", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.inwardPull,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "inwardPull", Number($event.target.value))
                    }, null, 40, _hoisted_115),
                    createBaseVNode("span", _hoisted_116, toDisplayString(vortex.inwardPull), 1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_117, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("turbulence"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[73] || (_cache[73] = createBaseVNode("span", null, "Turbulence", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addTurbulence, ["stop"]),
              title: "Add Turbulence Field"
            }, [..._cache[72] || (_cache[72] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("turbulence") ? (openBlock(), createElementBlock("div", _hoisted_118, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(turbulenceFields.value, (turb) => {
              return openBlock(), createElementBlock("div", {
                key: turb.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_119, [
                  _cache[75] || (_cache[75] = createBaseVNode("span", { class: "force-label" }, "Turbulence Field", -1)),
                  createBaseVNode("label", _hoisted_120, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: turb.enabled,
                      onChange: ($event) => updateTurbulence(turb.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_121)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeTurbulence(turb.id)
                  }, [..._cache[74] || (_cache[74] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_122)
                ]),
                createBaseVNode("div", _hoisted_123, [
                  _cache[76] || (_cache[76] = createBaseVNode("label", null, "Scale", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.scale,
                    min: "0.001",
                    max: "0.02",
                    step: "0.001",
                    onInput: ($event) => updateTurbulence(turb.id, "scale", Number($event.target.value))
                  }, null, 40, _hoisted_124),
                  createBaseVNode("span", _hoisted_125, toDisplayString(turb.scale.toFixed(3)), 1)
                ]),
                createBaseVNode("div", _hoisted_126, [
                  _cache[77] || (_cache[77] = createBaseVNode("label", null, "Strength", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.strength,
                    min: "0",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateTurbulence(turb.id, "strength", Number($event.target.value))
                  }, null, 40, _hoisted_127),
                  createBaseVNode("span", _hoisted_128, toDisplayString(turb.strength), 1)
                ]),
                createBaseVNode("div", _hoisted_129, [
                  _cache[78] || (_cache[78] = createBaseVNode("label", null, "Evolution", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.evolutionSpeed,
                    min: "0",
                    max: "1",
                    step: "0.01",
                    onInput: ($event) => updateTurbulence(turb.id, "evolutionSpeed", Number($event.target.value))
                  }, null, 40, _hoisted_130),
                  createBaseVNode("span", _hoisted_131, toDisplayString(turb.evolutionSpeed.toFixed(2)), 1)
                ])
              ]);
            }), 128)),
            turbulenceFields.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_132, " No turbulence fields. Add one for organic particle motion. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_133, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("subEmitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[80] || (_cache[80] = createBaseVNode("span", null, "Sub-Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addSubEmitter, ["stop"]),
              title: "Add Sub-Emitter"
            }, [..._cache[79] || (_cache[79] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("subEmitters") ? (openBlock(), createElementBlock("div", _hoisted_134, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(subEmitters.value, (sub) => {
              return openBlock(), createElementBlock("div", {
                key: sub.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_135, [
                  createBaseVNode("select", {
                    value: sub.parentEmitterId,
                    onChange: ($event) => updateSubEmitter(sub.id, "parentEmitterId", $event.target.value),
                    class: "sub-emitter-parent"
                  }, [
                    _cache[81] || (_cache[81] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_137);
                    }), 128))
                  ], 40, _hoisted_136),
                  createBaseVNode("label", _hoisted_138, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: sub.enabled,
                      onChange: ($event) => updateSubEmitter(sub.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_139)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeSubEmitter(sub.id)
                  }, [..._cache[82] || (_cache[82] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_140)
                ]),
                createBaseVNode("div", _hoisted_141, [
                  _cache[84] || (_cache[84] = createBaseVNode("label", null, "Trigger", -1)),
                  createBaseVNode("select", {
                    value: sub.trigger,
                    onChange: ($event) => updateSubEmitter(sub.id, "trigger", $event.target.value)
                  }, [..._cache[83] || (_cache[83] = [
                    createBaseVNode("option", { value: "death" }, "On Death", -1)
                  ])], 40, _hoisted_142)
                ]),
                createBaseVNode("div", _hoisted_143, [
                  _cache[85] || (_cache[85] = createBaseVNode("label", null, "Spawn Count", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spawnCount,
                    min: "1",
                    max: "10",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "spawnCount", Number($event.target.value))
                  }, null, 40, _hoisted_144),
                  createBaseVNode("span", _hoisted_145, toDisplayString(sub.spawnCount), 1)
                ]),
                createBaseVNode("div", _hoisted_146, [
                  _cache[86] || (_cache[86] = createBaseVNode("label", null, "Inherit Velocity", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.inheritVelocity,
                    min: "0",
                    max: "1",
                    step: "0.1",
                    onInput: ($event) => updateSubEmitter(sub.id, "inheritVelocity", Number($event.target.value))
                  }, null, 40, _hoisted_147),
                  createBaseVNode("span", _hoisted_148, toDisplayString((sub.inheritVelocity * 100).toFixed(0)) + "%", 1)
                ]),
                createBaseVNode("div", _hoisted_149, [
                  _cache[87] || (_cache[87] = createBaseVNode("label", null, "Size", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.size,
                    min: "1",
                    max: "100",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "size", Number($event.target.value))
                  }, null, 40, _hoisted_150),
                  createBaseVNode("span", _hoisted_151, toDisplayString(sub.size) + "px", 1)
                ]),
                createBaseVNode("div", _hoisted_152, [
                  _cache[88] || (_cache[88] = createBaseVNode("label", null, "Lifetime", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.lifetime,
                    min: "1",
                    max: "120",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "lifetime", Number($event.target.value))
                  }, null, 40, _hoisted_153),
                  createBaseVNode("span", _hoisted_154, toDisplayString(sub.lifetime) + "f", 1)
                ]),
                createBaseVNode("div", _hoisted_155, [
                  _cache[89] || (_cache[89] = createBaseVNode("label", null, "Speed", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.speed,
                    min: "1",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateSubEmitter(sub.id, "speed", Number($event.target.value))
                  }, null, 40, _hoisted_156),
                  createBaseVNode("span", _hoisted_157, toDisplayString(sub.speed), 1)
                ]),
                createBaseVNode("div", _hoisted_158, [
                  _cache[90] || (_cache[90] = createBaseVNode("label", null, "Spread", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spread,
                    min: "0",
                    max: "360",
                    step: "5",
                    onInput: ($event) => updateSubEmitter(sub.id, "spread", Number($event.target.value))
                  }, null, 40, _hoisted_159),
                  createBaseVNode("span", _hoisted_160, toDisplayString(sub.spread) + "Â°", 1)
                ]),
                createBaseVNode("div", _hoisted_161, [
                  _cache[91] || (_cache[91] = createBaseVNode("label", null, "Color", -1)),
                  createBaseVNode("input", {
                    type: "color",
                    value: rgbToHex(sub.color),
                    onInput: ($event) => updateSubEmitterColor(sub.id, $event.target.value)
                  }, null, 40, _hoisted_162)
                ])
              ]);
            }), 128)),
            subEmitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_163, " No sub-emitters. Add one for particle death effects. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_164, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[15] || (_cache[15] = ($event) => toggleSection("modulations"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[93] || (_cache[93] = createBaseVNode("span", null, "Modulations", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addModulation, ["stop"]),
              title: "Add Modulation"
            }, [..._cache[92] || (_cache[92] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("modulations") ? (openBlock(), createElementBlock("div", _hoisted_165, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(modulations.value, (mod) => {
              return openBlock(), createElementBlock("div", {
                key: mod.id,
                class: "modulation-item"
              }, [
                createBaseVNode("div", _hoisted_166, [
                  createBaseVNode("select", {
                    value: mod.emitterId,
                    onChange: ($event) => updateModulation(mod.id, "emitterId", $event.target.value)
                  }, [
                    _cache[94] || (_cache[94] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_168);
                    }), 128))
                  ], 40, _hoisted_167),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeModulation(mod.id)
                  }, [..._cache[95] || (_cache[95] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_169)
                ]),
                createBaseVNode("div", _hoisted_170, [
                  _cache[97] || (_cache[97] = createBaseVNode("label", null, "Property", -1)),
                  createBaseVNode("select", {
                    value: mod.property,
                    onChange: ($event) => updateModulation(mod.id, "property", $event.target.value)
                  }, [..._cache[96] || (_cache[96] = [
                    createStaticVNode('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
                  ])], 40, _hoisted_171)
                ]),
                createBaseVNode("div", _hoisted_172, [
                  _cache[98] || (_cache[98] = createBaseVNode("label", null, "Start Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.startValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "startValue", Number($event.target.value))
                  }, null, 40, _hoisted_173)
                ]),
                createBaseVNode("div", _hoisted_174, [
                  _cache[99] || (_cache[99] = createBaseVNode("label", null, "End Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.endValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "endValue", Number($event.target.value))
                  }, null, 40, _hoisted_175)
                ]),
                createBaseVNode("div", _hoisted_176, [
                  _cache[101] || (_cache[101] = createBaseVNode("label", null, "Easing", -1)),
                  createBaseVNode("select", {
                    value: mod.easing,
                    onChange: ($event) => updateModulation(mod.id, "easing", $event.target.value)
                  }, [..._cache[100] || (_cache[100] = [
                    createStaticVNode('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
                  ])], 40, _hoisted_177)
                ])
              ]);
            }), 128)),
            modulations.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_178, " No modulations. Add one to animate particle properties over lifetime. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_179, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[16] || (_cache[16] = ($event) => toggleSection("render"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[102] || (_cache[102] = createBaseVNode("span", null, "Render Options", -1))
          ]),
          expandedSections.value.has("render") ? (openBlock(), createElementBlock("div", _hoisted_180, [
            createBaseVNode("div", _hoisted_181, [
              _cache[104] || (_cache[104] = createBaseVNode("label", null, "Blend Mode", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.blendMode,
                onChange: _cache[17] || (_cache[17] = ($event) => updateRenderOption("blendMode", $event.target.value))
              }, [..._cache[103] || (_cache[103] = [
                createBaseVNode("option", { value: "normal" }, "Normal", -1),
                createBaseVNode("option", { value: "additive" }, "Additive", -1),
                createBaseVNode("option", { value: "multiply" }, "Multiply", -1),
                createBaseVNode("option", { value: "screen" }, "Screen", -1)
              ])], 40, _hoisted_182)
            ]),
            createBaseVNode("div", _hoisted_183, [
              _cache[106] || (_cache[106] = createBaseVNode("label", null, "Shape", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.particleShape,
                onChange: _cache[18] || (_cache[18] = ($event) => updateRenderOption("particleShape", $event.target.value))
              }, [..._cache[105] || (_cache[105] = [
                createBaseVNode("option", { value: "circle" }, "Circle", -1),
                createBaseVNode("option", { value: "square" }, "Square", -1),
                createBaseVNode("option", { value: "triangle" }, "Triangle", -1),
                createBaseVNode("option", { value: "star" }, "Star", -1)
              ])], 40, _hoisted_184)
            ]),
            createBaseVNode("div", _hoisted_185, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.renderTrails,
                  onChange: _cache[19] || (_cache[19] = ($event) => updateRenderOption("renderTrails", $event.target.checked))
                }, null, 40, _hoisted_186),
                _cache[107] || (_cache[107] = createTextVNode(" Render Trails ", -1))
              ])
            ]),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_187, [
              _cache[108] || (_cache[108] = createBaseVNode("label", null, "Trail Length", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailLength,
                min: "1",
                max: "20",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateRenderOption("trailLength", Number($event.target.value)))
              }, null, 40, _hoisted_188),
              createBaseVNode("span", _hoisted_189, toDisplayString(renderOptions.value.trailLength), 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_190, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.glowEnabled,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateRenderOption("glowEnabled", $event.target.checked))
                }, null, 40, _hoisted_191),
                _cache[109] || (_cache[109] = createTextVNode(" Enable Glow ", -1))
              ])
            ]),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_192, [
              _cache[110] || (_cache[110] = createBaseVNode("label", null, "Glow Radius", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowRadius,
                min: "1",
                max: "50",
                step: "1",
                onInput: _cache[22] || (_cache[22] = ($event) => updateRenderOption("glowRadius", Number($event.target.value)))
              }, null, 40, _hoisted_193),
              createBaseVNode("span", _hoisted_194, toDisplayString(renderOptions.value.glowRadius) + "px", 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_195, [
              _cache[111] || (_cache[111] = createBaseVNode("label", null, "Glow Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowIntensity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[23] || (_cache[23] = ($event) => updateRenderOption("glowIntensity", Number($event.target.value)))
              }, null, 40, _hoisted_196),
              createBaseVNode("span", _hoisted_197, toDisplayString(renderOptions.value.glowIntensity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            _cache[118] || (_cache[118] = createBaseVNode("div", { class: "subsection-divider" }, "Particle Connections", -1)),
            createBaseVNode("div", _hoisted_198, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.enabled,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConnection("enabled", $event.target.checked))
                }, null, 40, _hoisted_199),
                _cache[112] || (_cache[112] = createTextVNode(" Enable Connections ", -1))
              ])
            ]),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_200, [
              _cache[113] || (_cache[113] = createBaseVNode("label", null, "Max Distance", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxDistance,
                min: "10",
                max: "300",
                step: "10",
                onInput: _cache[25] || (_cache[25] = ($event) => updateConnection("maxDistance", Number($event.target.value)))
              }, null, 40, _hoisted_201),
              createBaseVNode("span", _hoisted_202, toDisplayString(connections.value.maxDistance) + "px", 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_203, [
              _cache[114] || (_cache[114] = createBaseVNode("label", null, "Max Connections", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxConnections,
                min: "1",
                max: "5",
                step: "1",
                onInput: _cache[26] || (_cache[26] = ($event) => updateConnection("maxConnections", Number($event.target.value)))
              }, null, 40, _hoisted_204),
              createBaseVNode("span", _hoisted_205, toDisplayString(connections.value.maxConnections), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_206, [
              _cache[115] || (_cache[115] = createBaseVNode("label", null, "Line Width", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineWidth,
                min: "0.5",
                max: "3",
                step: "0.1",
                onInput: _cache[27] || (_cache[27] = ($event) => updateConnection("lineWidth", Number($event.target.value)))
              }, null, 40, _hoisted_207),
              createBaseVNode("span", _hoisted_208, toDisplayString(connections.value.lineWidth.toFixed(1)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_209, [
              _cache[116] || (_cache[116] = createBaseVNode("label", null, "Line Opacity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineOpacity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[28] || (_cache[28] = ($event) => updateConnection("lineOpacity", Number($event.target.value)))
              }, null, 40, _hoisted_210),
              createBaseVNode("span", _hoisted_211, toDisplayString(connections.value.lineOpacity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_212, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.fadeByDistance,
                  onChange: _cache[29] || (_cache[29] = ($event) => updateConnection("fadeByDistance", $event.target.checked))
                }, null, 40, _hoisted_213),
                _cache[117] || (_cache[117] = createTextVNode(" Fade by Distance ", -1))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_214, [
          _cache[119] || (_cache[119] = createBaseVNode("i", { class: "pi pi-circle-fill" }, null, -1)),
          createBaseVNode("span", null, toDisplayString(particleCount.value) + " particles", 1)
        ])
      ]);
    };
  }
});

const ParticleProperties = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-60b9bdc8"]]);

const _hoisted_1$v = ["title"];
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const hasKeyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return false;
      return props.property.keyframes.some((k) => k.frame === store.currentFrame);
    });
    const keyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return null;
      return props.property.keyframes.find((k) => k.frame === store.currentFrame) || null;
    });
    const iconClass = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "pi-circle-fill";
      }
      if (props.property.animated) {
        return "pi-circle";
      }
      return "pi-stopwatch";
    });
    const buttonTitle = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "Remove keyframe at current frame";
      }
      if (props.property.animated) {
        return "Add keyframe at current frame";
      }
      return "Enable animation (add keyframe)";
    });
    function toggleKeyframe() {
      if (hasKeyframeAtCurrentFrame.value) {
        removeKeyframe();
      } else {
        addKeyframe();
      }
    }
    function addKeyframe() {
      const defaultHandle = { frame: 0, value: 0, enabled: false };
      const newKeyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: store.currentFrame,
        value: props.property.value,
        interpolation: "linear",
        inHandle: { ...defaultHandle },
        outHandle: { ...defaultHandle },
        controlMode: "smooth"
      };
      if (!props.property.animated) {
        props.property.animated = true;
        emit("animationToggled", true);
      }
      props.property.keyframes.push(newKeyframe);
      props.property.keyframes.sort((a, b) => a.frame - b.frame);
      emit("keyframeAdded", newKeyframe);
    }
    function removeKeyframe() {
      const keyframe = keyframeAtCurrentFrame.value;
      if (!keyframe) return;
      const index = props.property.keyframes.findIndex((k) => k.id === keyframe.id);
      if (index >= 0) {
        props.property.keyframes.splice(index, 1);
        emit("keyframeRemoved", keyframe.id);
      }
      if (props.property.keyframes.length === 0) {
        props.property.animated = false;
        emit("animationToggled", false);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["keyframe-toggle", {
          animated: __props.property.animated,
          "has-keyframe": hasKeyframeAtCurrentFrame.value
        }]),
        onClick: toggleKeyframe,
        title: buttonTitle.value
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["pi", iconClass.value])
        }, null, 2)
      ], 10, _hoisted_1$v);
    };
  }
});

const KeyframeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-b9271c8f"]]);

const _hoisted_1$u = { class: "depthflow-properties" };
const _hoisted_2$u = { class: "property-section" };
const _hoisted_3$u = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$u = { class: "property-row" };
const _hoisted_5$u = ["value"];
const _hoisted_6$u = ["value"];
const _hoisted_7$u = { class: "property-row" };
const _hoisted_8$t = ["value"];
const _hoisted_9$s = ["value"];
const _hoisted_10$r = { class: "property-section" };
const _hoisted_11$q = {
  key: 0,
  class: "section-content"
};
const _hoisted_12$o = { class: "preset-grid" };
const _hoisted_13$n = ["onClick"];
const _hoisted_14$l = {
  key: 0,
  class: "property-row"
};
const _hoisted_15$l = ["value"];
const _hoisted_16$l = { class: "value-display" };
const _hoisted_17$k = { class: "property-section" };
const _hoisted_18$j = {
  key: 0,
  class: "section-content"
};
const _hoisted_19$j = { class: "property-row" };
const _hoisted_20$j = ["value"];
const _hoisted_21$h = { class: "value-display" };
const _hoisted_22$g = { class: "property-row" };
const _hoisted_23$g = ["value"];
const _hoisted_24$e = { class: "value-display" };
const _hoisted_25$e = { class: "property-row" };
const _hoisted_26$e = ["value"];
const _hoisted_27$d = { class: "value-display" };
const _hoisted_28$d = { class: "property-row" };
const _hoisted_29$d = ["value"];
const _hoisted_30$d = { class: "value-display" };
const _hoisted_31$a = { class: "property-section" };
const _hoisted_32$9 = {
  key: 0,
  class: "section-content"
};
const _hoisted_33$9 = { class: "property-row" };
const _hoisted_34$9 = ["value"];
const _hoisted_35$9 = { class: "value-display" };
const _hoisted_36$9 = { class: "property-row" };
const _hoisted_37$9 = ["value"];
const _hoisted_38$9 = { class: "value-display" };
const _hoisted_39$8 = {
  key: 0,
  class: "property-section"
};
const _hoisted_40$7 = {
  key: 0,
  class: "section-content"
};
const _hoisted_41$5 = { class: "property-row" };
const _hoisted_42$4 = ["value"];
const _hoisted_43$4 = { class: "value-display" };
const _hoisted_44$4 = { class: "property-row" };
const _hoisted_45$4 = ["value"];
const _hoisted_46$4 = { class: "value-display" };
const _hoisted_47$4 = { class: "property-row" };
const _hoisted_48$4 = ["value"];
const _hoisted_49$4 = { class: "value-display" };
const _hoisted_50$3 = { class: "property-row" };
const _hoisted_51$3 = ["value"];
const _hoisted_52$3 = { class: "value-display" };
const _hoisted_53$3 = {
  key: 2,
  class: "property-row"
};
const _hoisted_54$3 = ["value"];
const _hoisted_55$3 = { class: "value-display" };
const _hoisted_56$3 = { class: "property-section" };
const _hoisted_57$3 = {
  key: 0,
  class: "section-content"
};
const _hoisted_58$3 = { class: "property-row" };
const _hoisted_59$3 = ["value"];
const _hoisted_60$3 = { class: "value-display" };
const _hoisted_61$3 = { class: "property-row checkbox-row" };
const _hoisted_62$3 = ["checked"];
const _hoisted_63$1 = { class: "property-section" };
const _hoisted_64$1 = {
  key: 0,
  class: "sync-badge"
};
const _hoisted_65$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_66$1 = { class: "property-row checkbox-row" };
const _hoisted_67$1 = ["checked"];
const _hoisted_68$1 = { class: "property-row" };
const _hoisted_69$1 = ["value"];
const _hoisted_70$1 = ["value"];
const _hoisted_71$1 = { class: "property-row" };
const _hoisted_72$1 = ["value"];
const _hoisted_73$1 = { class: "value-display" };
const _hoisted_74$1 = { class: "property-row" };
const _hoisted_75$1 = ["value"];
const _hoisted_76$1 = { class: "value-display" };
const _hoisted_77$1 = { class: "property-row" };
const _hoisted_78$1 = ["value"];
const _hoisted_79 = { class: "value-display" };
const _hoisted_80 = { class: "property-row" };
const _hoisted_81 = ["value"];
const _hoisted_82 = { class: "value-display" };
const _hoisted_83 = { class: "property-row checkbox-row" };
const _hoisted_84 = ["checked"];
const _hoisted_85 = { style: { "margin-left": "16px" } };
const _hoisted_86 = ["checked"];
const _hoisted_87 = { class: "property-row" };
const _hoisted_88 = ["value"];
const _hoisted_89 = { class: "value-display" };
const _hoisted_90 = { class: "property-section" };
const _hoisted_91 = {
  key: 0,
  class: "section-content"
};
const _hoisted_92 = { class: "preview-container" };
const _hoisted_93 = { class: "preview-controls" };
const _hoisted_94 = { class: "frame-indicator" };
const previewSize = 200;
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const DEFAULT_CAMERA_SYNC_CONFIG = {
      sensitivityX: 0.5,
      sensitivityY: 0.5,
      sensitivityZ: 1e-3,
      sensitivityRotation: 1,
      baseZoom: 1,
      invertX: false,
      invertY: false,
      zoomClamp: { min: 0.5, max: 3 },
      offsetClamp: { min: -1, max: 1 }
    };
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const previewCanvas = ref(null);
    const isPreviewPlaying = ref(false);
    const previewFrame = ref(0);
    const previewAnimationId = ref(null);
    const expandedSections = ref(/* @__PURE__ */ new Set(["source", "preset", "camera"]));
    const presetIntensity = ref(1);
    const presets = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ];
    const config = computed(() => {
      const data = props.layer.data;
      return data || {
        sourceLayerId: "",
        depthLayerId: "",
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        }
      };
    });
    const depthflowConfig = computed(() => config.value.config);
    const totalFrames = computed(() => store.frameCount);
    const imageLayers = computed(
      () => store.layers.filter((l) => l.type === "image" || l.type === "generated")
    );
    const depthLayers = computed(
      () => store.layers.filter((l) => l.type === "depth" || l.type === "generated")
    );
    const cameraLayers = computed(
      () => store.layers.filter((l) => l.type === "camera")
    );
    const cameraSyncConfig = computed(() => {
      return config.value.cameraSyncConfig ?? DEFAULT_CAMERA_SYNC_CONFIG;
    });
    const isOrbitPreset = computed(
      () => ["circle_cw", "circle_ccw"].includes(depthflowConfig.value.preset)
    );
    const isSwingPreset = computed(
      () => ["horizontal_swing", "vertical_swing"].includes(depthflowConfig.value.preset)
    );
    const isDollyPreset = computed(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(depthflowConfig.value.preset)
    );
    const showPresetSettings = computed(
      () => isOrbitPreset.value || isSwingPreset.value || isDollyPreset.value
    );
    const presetSettingsTitle = computed(() => {
      if (isOrbitPreset.value) return "Orbit Settings";
      if (isSwingPreset.value) return "Swing Settings";
      if (isDollyPreset.value) return "Dolly Zoom Settings";
      return "Preset Settings";
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function updateConfig(key, value) {
      emit("update", { [key]: value });
    }
    function updateDepthflowConfig(key, value) {
      emit("update", {
        config: { ...depthflowConfig.value, [key]: value }
      });
    }
    function selectPreset(preset) {
      updateDepthflowConfig("preset", preset);
    }
    function updateCameraSyncConfig(key, value) {
      emit("update", {
        cameraSyncConfig: { ...cameraSyncConfig.value, [key]: value }
      });
    }
    function updatePresetIntensity(intensity) {
      presetIntensity.value = intensity;
      if (isOrbitPreset.value) {
        updateDepthflowConfig("orbitRadius", 0.1 * intensity);
      } else if (isSwingPreset.value) {
        updateDepthflowConfig("swingAmplitude", 0.1 * intensity);
      } else {
        updateDepthflowConfig("depthScale", 1 * intensity);
      }
    }
    function togglePreview() {
      isPreviewPlaying.value = !isPreviewPlaying.value;
      if (isPreviewPlaying.value) {
        playPreview();
      } else {
        if (previewAnimationId.value !== null) {
          cancelAnimationFrame(previewAnimationId.value);
          previewAnimationId.value = null;
        }
      }
    }
    function playPreview() {
      if (!isPreviewPlaying.value) return;
      previewFrame.value = (previewFrame.value + 1) % totalFrames.value;
      renderPreview();
      previewAnimationId.value = requestAnimationFrame(() => {
        setTimeout(playPreview, 1e3 / store.fps);
      });
    }
    function renderPreview() {
      const canvas = previewCanvas.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, previewSize, previewSize);
      ctx.fillStyle = "#333";
      ctx.fillRect(10, 10, previewSize - 20, previewSize - 20);
      ctx.fillStyle = "#666";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Depthflow Preview", previewSize / 2, previewSize / 2);
      ctx.fillText(`Frame ${previewFrame.value}`, previewSize / 2, previewSize / 2 + 16);
    }
    onMounted(() => {
      renderPreview();
    });
    onUnmounted(() => {
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$u, [
        createBaseVNode("div", _hoisted_2$u, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("source"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Source Selection", -1))
          ]),
          expandedSections.value.has("source") ? (openBlock(), createElementBlock("div", _hoisted_3$u, [
            createBaseVNode("div", _hoisted_4$u, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Source Layer", -1)),
              createBaseVNode("select", {
                value: config.value.sourceLayerId,
                onChange: _cache[1] || (_cache[1] = ($event) => updateConfig("sourceLayerId", $event.target.value))
              }, [
                _cache[34] || (_cache[34] = createBaseVNode("option", { value: "" }, "Select source...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_6$u);
                }), 128))
              ], 40, _hoisted_5$u)
            ]),
            createBaseVNode("div", _hoisted_7$u, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Depth Layer", -1)),
              createBaseVNode("select", {
                value: config.value.depthLayerId,
                onChange: _cache[2] || (_cache[2] = ($event) => updateConfig("depthLayerId", $event.target.value))
              }, [
                _cache[36] || (_cache[36] = createBaseVNode("option", { value: "" }, "Select depth map...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(depthLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_9$s);
                }), 128))
              ], 40, _hoisted_8$t)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_10$r, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[3] || (_cache[3] = ($event) => toggleSection("preset"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[38] || (_cache[38] = createBaseVNode("span", null, "Motion Preset", -1))
          ]),
          expandedSections.value.has("preset") ? (openBlock(), createElementBlock("div", _hoisted_11$q, [
            createBaseVNode("div", _hoisted_12$o, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.value,
                  class: normalizeClass(["preset-btn", { active: depthflowConfig.value.preset === preset.value }]),
                  onClick: ($event) => selectPreset(preset.value)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(preset.icon)
                  }, null, 2),
                  createBaseVNode("span", null, toDisplayString(preset.label), 1)
                ], 10, _hoisted_13$n);
              }), 64))
            ]),
            depthflowConfig.value.preset !== "static" ? (openBlock(), createElementBlock("div", _hoisted_14$l, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: presetIntensity.value,
                min: "0.1",
                max: "2",
                step: "0.1",
                onInput: _cache[4] || (_cache[4] = ($event) => updatePresetIntensity(Number($event.target.value)))
              }, null, 40, _hoisted_15$l),
              createBaseVNode("span", _hoisted_16$l, toDisplayString(presetIntensity.value.toFixed(1)) + "x", 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_17$k, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("camera"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[40] || (_cache[40] = createBaseVNode("span", null, "Camera Controls", -1))
          ]),
          expandedSections.value.has("camera") ? (openBlock(), createElementBlock("div", _hoisted_18$j, [
            createBaseVNode("div", _hoisted_19$j, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Zoom", -1)),
              config.value.animatedZoom ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedZoom,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.zoom,
                min: "0.5",
                max: "2",
                step: "0.01",
                onInput: _cache[6] || (_cache[6] = ($event) => updateDepthflowConfig("zoom", Number($event.target.value)))
              }, null, 40, _hoisted_20$j),
              createBaseVNode("span", _hoisted_21$h, toDisplayString(depthflowConfig.value.zoom.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_22$g, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Offset X", -1)),
              config.value.animatedOffsetX ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetX,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetX,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[7] || (_cache[7] = ($event) => updateDepthflowConfig("offsetX", Number($event.target.value)))
              }, null, 40, _hoisted_23$g),
              createBaseVNode("span", _hoisted_24$e, toDisplayString(depthflowConfig.value.offsetX.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_25$e, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Offset Y", -1)),
              config.value.animatedOffsetY ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetY,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetY,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[8] || (_cache[8] = ($event) => updateDepthflowConfig("offsetY", Number($event.target.value)))
              }, null, 40, _hoisted_26$e),
              createBaseVNode("span", _hoisted_27$d, toDisplayString(depthflowConfig.value.offsetY.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_28$d, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Rotation", -1)),
              config.value.animatedRotation ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedRotation,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.rotation,
                min: "-180",
                max: "180",
                step: "1",
                onInput: _cache[9] || (_cache[9] = ($event) => updateDepthflowConfig("rotation", Number($event.target.value)))
              }, null, 40, _hoisted_29$d),
              createBaseVNode("span", _hoisted_30$d, toDisplayString(depthflowConfig.value.rotation) + "Â°", 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_31$a, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("depth"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[45] || (_cache[45] = createBaseVNode("span", null, "Depth Settings", -1))
          ]),
          expandedSections.value.has("depth") ? (openBlock(), createElementBlock("div", _hoisted_32$9, [
            createBaseVNode("div", _hoisted_33$9, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Depth Scale", -1)),
              config.value.animatedDepthScale ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedDepthScale,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.depthScale,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: _cache[11] || (_cache[11] = ($event) => updateDepthflowConfig("depthScale", Number($event.target.value)))
              }, null, 40, _hoisted_34$9),
              createBaseVNode("span", _hoisted_35$9, toDisplayString(depthflowConfig.value.depthScale.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_36$9, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Focus Depth", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.focusDepth,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[12] || (_cache[12] = ($event) => updateDepthflowConfig("focusDepth", Number($event.target.value)))
              }, null, 40, _hoisted_37$9),
              createBaseVNode("span", _hoisted_38$9, toDisplayString(depthflowConfig.value.focusDepth.toFixed(2)), 1)
            ]),
            _cache[48] || (_cache[48] = createBaseVNode("div", { class: "depth-hint" }, [
              createTextVNode(" Objects at focus depth stay stationary."),
              createBaseVNode("br"),
              createTextVNode(" Closer objects move more, distant objects move less. ")
            ], -1))
          ])) : createCommentVNode("", true)
        ]),
        showPresetSettings.value ? (openBlock(), createElementBlock("div", _hoisted_39$8, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("presetSettings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            createBaseVNode("span", null, toDisplayString(presetSettingsTitle.value), 1)
          ]),
          expandedSections.value.has("presetSettings") ? (openBlock(), createElementBlock("div", _hoisted_40$7, [
            isOrbitPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_41$5, [
                _cache[49] || (_cache[49] = createBaseVNode("label", null, "Orbit Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitRadius,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[14] || (_cache[14] = ($event) => updateDepthflowConfig("orbitRadius", Number($event.target.value)))
                }, null, 40, _hoisted_42$4),
                createBaseVNode("span", _hoisted_43$4, toDisplayString(depthflowConfig.value.orbitRadius.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_44$4, [
                _cache[50] || (_cache[50] = createBaseVNode("label", null, "Orbit Speed", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitSpeed,
                  min: "1",
                  max: "720",
                  step: "1",
                  onInput: _cache[15] || (_cache[15] = ($event) => updateDepthflowConfig("orbitSpeed", Number($event.target.value)))
                }, null, 40, _hoisted_45$4),
                createBaseVNode("span", _hoisted_46$4, toDisplayString(depthflowConfig.value.orbitSpeed) + "Â°", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isSwingPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_47$4, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Amplitude", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingAmplitude,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[16] || (_cache[16] = ($event) => updateDepthflowConfig("swingAmplitude", Number($event.target.value)))
                }, null, 40, _hoisted_48$4),
                createBaseVNode("span", _hoisted_49$4, toDisplayString(depthflowConfig.value.swingAmplitude.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_50$3, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Frequency", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingFrequency,
                  min: "0.1",
                  max: "5",
                  step: "0.1",
                  onInput: _cache[17] || (_cache[17] = ($event) => updateDepthflowConfig("swingFrequency", Number($event.target.value)))
                }, null, 40, _hoisted_51$3),
                createBaseVNode("span", _hoisted_52$3, toDisplayString(depthflowConfig.value.swingFrequency.toFixed(1)) + " Hz", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isDollyPreset.value ? (openBlock(), createElementBlock("div", _hoisted_53$3, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Dolly Rate", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.dollyZoom,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[18] || (_cache[18] = ($event) => updateDepthflowConfig("dollyZoom", Number($event.target.value)))
              }, null, 40, _hoisted_54$3),
              createBaseVNode("span", _hoisted_55$3, toDisplayString(depthflowConfig.value.dollyZoom.toFixed(2)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_56$3, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[19] || (_cache[19] = ($event) => toggleSection("quality"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[54] || (_cache[54] = createBaseVNode("span", null, "Quality", -1))
          ]),
          expandedSections.value.has("quality") ? (openBlock(), createElementBlock("div", _hoisted_57$3, [
            createBaseVNode("div", _hoisted_58$3, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Edge Dilation", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.edgeDilation,
                min: "0",
                max: "50",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateDepthflowConfig("edgeDilation", Number($event.target.value)))
              }, null, 40, _hoisted_59$3),
              createBaseVNode("span", _hoisted_60$3, toDisplayString(depthflowConfig.value.edgeDilation) + "px", 1)
            ]),
            createBaseVNode("div", _hoisted_61$3, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: depthflowConfig.value.inpaintEdges,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateDepthflowConfig("inpaintEdges", $event.target.checked))
                }, null, 40, _hoisted_62$3),
                _cache[56] || (_cache[56] = createTextVNode(" Inpaint Edges ", -1))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_63$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[22] || (_cache[22] = ($event) => toggleSection("cameraSync"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("cameraSync") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[57] || (_cache[57] = createBaseVNode("span", null, "Camera Sync", -1)),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock("span", _hoisted_64$1, "Active")) : createCommentVNode("", true)
          ]),
          expandedSections.value.has("cameraSync") ? (openBlock(), createElementBlock("div", _hoisted_65$1, [
            createBaseVNode("div", _hoisted_66$1, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: config.value.cameraSyncEnabled ?? false,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateConfig("cameraSyncEnabled", $event.target.checked))
                }, null, 40, _hoisted_67$1),
                _cache[58] || (_cache[58] = createTextVNode(" Enable Camera Sync ", -1))
              ])
            ]),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_68$1, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Camera Layer", -1)),
                createBaseVNode("select", {
                  value: config.value.cameraSyncLayerId ?? "",
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConfig("cameraSyncLayerId", $event.target.value))
                }, [
                  _cache[59] || (_cache[59] = createBaseVNode("option", { value: "" }, "Select camera...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(cameraLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_70$1);
                  }), 128))
                ], 40, _hoisted_69$1)
              ]),
              _cache[68] || (_cache[68] = createBaseVNode("div", { class: "sync-hint" }, " Camera movement will drive parallax. Adjust sensitivity below. ", -1)),
              createBaseVNode("div", _hoisted_71$1, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "X Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityX,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[25] || (_cache[25] = ($event) => updateCameraSyncConfig("sensitivityX", Number($event.target.value)))
                }, null, 40, _hoisted_72$1),
                createBaseVNode("span", _hoisted_73$1, toDisplayString(cameraSyncConfig.value.sensitivityX.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_74$1, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Y Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityY,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[26] || (_cache[26] = ($event) => updateCameraSyncConfig("sensitivityY", Number($event.target.value)))
                }, null, 40, _hoisted_75$1),
                createBaseVNode("span", _hoisted_76$1, toDisplayString(cameraSyncConfig.value.sensitivityY.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_77$1, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Z Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityZ * 1e3,
                  min: "0",
                  max: "10",
                  step: "0.1",
                  onInput: _cache[27] || (_cache[27] = ($event) => updateCameraSyncConfig("sensitivityZ", Number($event.target.value) / 1e3))
                }, null, 40, _hoisted_78$1),
                createBaseVNode("span", _hoisted_79, toDisplayString((cameraSyncConfig.value.sensitivityZ * 1e3).toFixed(1)), 1)
              ]),
              createBaseVNode("div", _hoisted_80, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "Rotation Sens.", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityRotation,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[28] || (_cache[28] = ($event) => updateCameraSyncConfig("sensitivityRotation", Number($event.target.value)))
                }, null, 40, _hoisted_81),
                createBaseVNode("span", _hoisted_82, toDisplayString(cameraSyncConfig.value.sensitivityRotation.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_83, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertX,
                    onChange: _cache[29] || (_cache[29] = ($event) => updateCameraSyncConfig("invertX", $event.target.checked))
                  }, null, 40, _hoisted_84),
                  _cache[65] || (_cache[65] = createTextVNode(" Invert X ", -1))
                ]),
                createBaseVNode("label", _hoisted_85, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertY,
                    onChange: _cache[30] || (_cache[30] = ($event) => updateCameraSyncConfig("invertY", $event.target.checked))
                  }, null, 40, _hoisted_86),
                  _cache[66] || (_cache[66] = createTextVNode(" Invert Y ", -1))
                ])
              ]),
              createBaseVNode("div", _hoisted_87, [
                _cache[67] || (_cache[67] = createBaseVNode("label", null, "Base Zoom", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.baseZoom,
                  min: "0.5",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[31] || (_cache[31] = ($event) => updateCameraSyncConfig("baseZoom", Number($event.target.value)))
                }, null, 40, _hoisted_88),
                createBaseVNode("span", _hoisted_89, toDisplayString(cameraSyncConfig.value.baseZoom.toFixed(2)), 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_90, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[32] || (_cache[32] = ($event) => toggleSection("preview"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[69] || (_cache[69] = createBaseVNode("span", null, "Preview", -1))
          ]),
          expandedSections.value.has("preview") ? (openBlock(), createElementBlock("div", _hoisted_91, [
            createBaseVNode("div", _hoisted_92, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                class: "preview-canvas",
                width: previewSize,
                height: previewSize
              }, null, 512)
            ]),
            createBaseVNode("div", _hoisted_93, [
              createBaseVNode("button", {
                class: normalizeClass(["preview-btn", { active: isPreviewPlaying.value }]),
                onClick: togglePreview
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(isPreviewPlaying.value ? "pi pi-pause" : "pi pi-play")
                }, null, 2),
                createTextVNode(" " + toDisplayString(isPreviewPlaying.value ? "Pause" : "Play"), 1)
              ], 2),
              createBaseVNode("span", _hoisted_94, " Frame " + toDisplayString(previewFrame.value) + " / " + toDisplayString(totalFrames.value - 1), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const DepthflowProperties = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-fe3d8389"]]);

const _hoisted_1$t = { class: "light-properties" };
const _hoisted_2$t = { class: "property-section" };
const _hoisted_3$t = { class: "section-content" };
const _hoisted_4$t = { class: "property-row" };
const _hoisted_5$t = ["value"];
const _hoisted_6$t = { class: "property-group" };
const _hoisted_7$t = { class: "property-group" };
const _hoisted_8$s = { class: "control-row" };
const _hoisted_9$r = { class: "property-group" };
const _hoisted_10$q = { class: "control-row" };
const _hoisted_11$p = { class: "property-group" };
const _hoisted_12$n = {
  key: 1,
  class: "property-row"
};
const _hoisted_13$m = ["value"];
const _hoisted_14$k = {
  key: 2,
  class: "property-group"
};
const _hoisted_15$k = {
  key: 3,
  class: "property-group"
};
const _hoisted_16$k = { class: "property-group checkbox-row" };
const _hoisted_17$j = ["checked"];
const _hoisted_18$i = { class: "property-group" };
const _hoisted_19$i = { class: "property-group" };
const _hoisted_20$i = {
  key: 5,
  class: "note"
};
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const lightData = computed(() => {
      return props.layer.data || {
        lightType: "spot",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0,
        coneAngle: 90,
        coneFeather: 50
      };
    });
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...lightData.value, [key]: value }
      });
      emit("update");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$t, [
        createBaseVNode("div", _hoisted_2$t, [
          _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-header" }, "Light Settings", -1)),
          createBaseVNode("div", _hoisted_3$t, [
            createBaseVNode("div", _hoisted_4$t, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Type", -1)),
              createBaseVNode("select", {
                value: lightData.value.lightType,
                onChange: _cache[0] || (_cache[0] = ($event) => update("lightType", $event.target.value)),
                class: "type-select"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("option", { value: "parallel" }, "Parallel", -1),
                createBaseVNode("option", { value: "spot" }, "Spot", -1),
                createBaseVNode("option", { value: "point" }, "Point", -1),
                createBaseVNode("option", { value: "ambient" }, "Ambient", -1)
              ])], 40, _hoisted_5$t)
            ]),
            createBaseVNode("div", _hoisted_6$t, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: lightData.value.color,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => update("color", v))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$t, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("div", _hoisted_8$s, [
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.intensity,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => update("intensity", v)),
                  min: 0,
                  max: 500,
                  step: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ]),
            lightData.value.lightType === "spot" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_9$r, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "Cone Angle", -1)),
                createBaseVNode("div", _hoisted_10$q, [
                  createVNode(unref(AngleDial), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => update("coneAngle", v)),
                    size: 32
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => update("coneAngle", v)),
                    unit: "Â°"
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11$p, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "Cone Feather", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.coneFeather ?? 50,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => update("coneFeather", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_12$n, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Falloff", -1)),
              createBaseVNode("select", {
                value: lightData.value.falloff,
                onChange: _cache[6] || (_cache[6] = ($event) => update("falloff", $event.target.value)),
                class: "type-select"
              }, [..._cache[18] || (_cache[18] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "smooth" }, "Smooth", -1),
                createBaseVNode("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
              ])], 40, _hoisted_13$m)
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" && lightData.value.lightType !== "parallel" ? (openBlock(), createElementBlock("div", _hoisted_14$k, [
              _cache[20] || (_cache[20] = createBaseVNode("label", null, "Radius", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.radius,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => update("radius", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_15$k, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Falloff Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.falloffDistance ?? 500,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => update("falloffDistance", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_16$k, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: lightData.value.castShadows,
                  onChange: _cache[9] || (_cache[9] = ($event) => update("castShadows", $event.target.checked))
                }, null, 40, _hoisted_17$j),
                _cache[22] || (_cache[22] = createTextVNode(" Casts Shadows ", -1))
              ])
            ]),
            lightData.value.castShadows ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
              createBaseVNode("div", _hoisted_18$i, [
                _cache[23] || (_cache[23] = createBaseVNode("label", null, "Shadow Darkness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.shadowDarkness ?? 100,
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => update("shadowDarkness", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$i, [
                _cache[24] || (_cache[24] = createBaseVNode("label", null, "Shadow Diffusion", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: lightData.value.shadowDiffusion ?? 0,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => update("shadowDiffusion", v)),
                  min: 0,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.castShadows ? (openBlock(), createElementBlock("div", _hoisted_20$i, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const LightProperties = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-7bf0f1bf"]]);

const _hoisted_1$s = { class: "shape-properties" };
const _hoisted_2$s = { class: "prop-section" };
const _hoisted_3$s = { class: "expand-icon" };
const _hoisted_4$s = ["checked"];
const _hoisted_5$s = {
  key: 0,
  class: "section-content"
};
const _hoisted_6$s = { class: "property-row" };
const _hoisted_7$s = { class: "color-input-wrapper" };
const _hoisted_8$r = ["value"];
const _hoisted_9$q = { class: "property-row" };
const _hoisted_10$p = { class: "property-row" };
const _hoisted_11$o = { class: "property-row" };
const _hoisted_12$m = { class: "icon-toggle-group" };
const _hoisted_13$l = { class: "property-row" };
const _hoisted_14$j = { class: "icon-toggle-group" };
const _hoisted_15$j = { class: "property-row" };
const _hoisted_16$j = ["value"];
const _hoisted_17$i = {
  key: 0,
  class: "property-row"
};
const _hoisted_18$h = { class: "prop-section" };
const _hoisted_19$h = { class: "expand-icon" };
const _hoisted_20$h = ["checked"];
const _hoisted_21$g = {
  key: 0,
  class: "section-content"
};
const _hoisted_22$f = { class: "property-row" };
const _hoisted_23$f = { class: "color-input-wrapper" };
const _hoisted_24$d = ["value"];
const _hoisted_25$d = { class: "property-row" };
const _hoisted_26$d = { class: "prop-section" };
const _hoisted_27$c = { class: "expand-icon" };
const _hoisted_28$c = {
  key: 0,
  class: "section-content"
};
const _hoisted_29$c = { class: "property-row" };
const _hoisted_30$c = { class: "property-row" };
const _hoisted_31$9 = { class: "property-row" };
const _hoisted_32$8 = { class: "prop-section" };
const _hoisted_33$8 = { class: "expand-icon" };
const _hoisted_34$8 = {
  key: 0,
  class: "section-content"
};
const _hoisted_35$8 = { class: "property-row checkbox-row" };
const _hoisted_36$8 = ["checked"];
const _hoisted_37$8 = { class: "property-row info-row" };
const _hoisted_38$8 = { class: "info-value" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["stroke", "fill", "trim"]);
    const shapeData = computed(() => {
      return props.layer.data || {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#ffffff",
        strokeWidth: 2,
        strokeOpacity: 100,
        strokeLineCap: "round",
        strokeLineJoin: "round",
        fill: "",
        fillOpacity: 100,
        trimStart: 0,
        trimEnd: 100,
        trimOffset: 0
      };
    });
    const hasFill = computed(() => !!shapeData.value.fill && shapeData.value.fill !== "transparent");
    const hasStroke = computed(() => !!shapeData.value.stroke && (shapeData.value.strokeWidth ?? 0) > 0);
    const strokeLineCap = computed(() => shapeData.value.strokeLineCap || "round");
    const strokeLineJoin = computed(() => shapeData.value.strokeLineJoin || "round");
    const hasDashes = computed(() => (shapeData.value.strokeDashArray?.length ?? 0) > 0);
    const dashArrayString = computed(() => {
      return shapeData.value.strokeDashArray?.join(", ") || "";
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...shapeData.value, [key]: value }
      });
      emit("update");
    }
    function toggleFill(e) {
      const checked = e.target.checked;
      update("fill", checked ? "#ffffff" : "");
    }
    function toggleStroke(e) {
      const checked = e.target.checked;
      if (checked) {
        update("stroke", "#ffffff");
        if ((shapeData.value.strokeWidth ?? 0) <= 0) {
          update("strokeWidth", 2);
        }
      } else {
        update("strokeWidth", 0);
      }
    }
    function updateDashArray(e) {
      const input = e.target.value;
      if (!input.trim()) {
        update("strokeDashArray", []);
        return;
      }
      const values = input.split(",").map((v) => parseFloat(v.trim())).filter((v) => !isNaN(v) && v >= 0);
      update("strokeDashArray", values);
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      update(dataKey, value);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
    }
    function toggleKeyframe(propName, dataKey) {
      ensureProperty(propName, dataKey);
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function ensureProperty(propName, dataKey) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        const currentValue = shapeData.value[dataKey] ?? 0;
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: currentValue,
          animated: false,
          keyframes: [],
          group: propName.includes("Trim") ? "Trim Paths" : propName.includes("Stroke") ? "Stroke" : propName.includes("Fill") ? "Fill" : "Shape"
        });
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$s, [
        createBaseVNode("div", _hoisted_2$s, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("stroke"))
          }, [
            createBaseVNode("span", _hoisted_3$s, toDisplayString(expandedSections.value.includes("stroke") ? "â–¼" : "â–º"), 1),
            _cache[29] || (_cache[29] = createBaseVNode("span", { class: "section-title" }, "Stroke", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasStroke.value,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleStroke,
              class: "section-toggle"
            }, null, 40, _hoisted_4$s)
          ]),
          expandedSections.value.includes("stroke") && hasStroke.value ? (openBlock(), createElementBlock("div", _hoisted_5$s, [
            createBaseVNode("div", _hoisted_6$s, [
              _cache[30] || (_cache[30] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_7$s, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.stroke || "#ffffff",
                  onInput: _cache[2] || (_cache[2] = (e) => update("stroke", e.target.value))
                }, null, 40, _hoisted_8$r)
              ])
            ]),
            createBaseVNode("div", _hoisted_9$q, [
              _cache[31] || (_cache[31] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Opacity") ?? shapeData.value.strokeOpacity ?? 100,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateAnimatable("Stroke Opacity", v, "strokeOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Opacity") }]),
                onClick: _cache[4] || (_cache[4] = ($event) => toggleKeyframe("Stroke Opacity", "strokeOpacity"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_10$p, [
              _cache[32] || (_cache[32] = createBaseVNode("label", null, "Width", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Width") ?? shapeData.value.strokeWidth ?? 2,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v, "strokeWidth")),
                min: 0,
                max: 500,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Width") }]),
                onClick: _cache[6] || (_cache[6] = ($event) => toggleKeyframe("Stroke Width", "strokeWidth"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_11$o, [
              _cache[33] || (_cache[33] = createBaseVNode("label", null, "Line Cap", -1)),
              createBaseVNode("div", _hoisted_12$m, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "butt" }),
                  onClick: _cache[7] || (_cache[7] = ($event) => update("strokeLineCap", "butt")),
                  title: "Butt Cap"
                }, "â”ƒ", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "round" }),
                  onClick: _cache[8] || (_cache[8] = ($event) => update("strokeLineCap", "round")),
                  title: "Round Cap"
                }, "â—¯", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "square" }),
                  onClick: _cache[9] || (_cache[9] = ($event) => update("strokeLineCap", "square")),
                  title: "Square Cap"
                }, "â–¡", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$l, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Line Join", -1)),
              createBaseVNode("div", _hoisted_14$j, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "miter" }),
                  onClick: _cache[10] || (_cache[10] = ($event) => update("strokeLineJoin", "miter")),
                  title: "Miter Join"
                }, "âŸ¨", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "round" }),
                  onClick: _cache[11] || (_cache[11] = ($event) => update("strokeLineJoin", "round")),
                  title: "Round Join"
                }, "â— ", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "bevel" }),
                  onClick: _cache[12] || (_cache[12] = ($event) => update("strokeLineJoin", "bevel")),
                  title: "Bevel Join"
                }, "âˆ ", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_15$j, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Dashes", -1)),
              createBaseVNode("input", {
                type: "text",
                class: "dash-input",
                value: dashArrayString.value,
                onChange: updateDashArray,
                placeholder: "e.g. 10, 5",
                title: "Comma-separated dash pattern"
              }, null, 40, _hoisted_16$j)
            ]),
            hasDashes.value ? (openBlock(), createElementBlock("div", _hoisted_17$i, [
              _cache[36] || (_cache[36] = createBaseVNode("label", null, "Dash Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Dash Offset") ?? shapeData.value.strokeDashOffset ?? 0,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateAnimatable("Dash Offset", v, "strokeDashOffset"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Dash Offset") }]),
                onClick: _cache[14] || (_cache[14] = ($event) => toggleKeyframe("Dash Offset", "strokeDashOffset"))
              }, "â—†", 2)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_18$h, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[16] || (_cache[16] = ($event) => toggleSection("fill"))
          }, [
            createBaseVNode("span", _hoisted_19$h, toDisplayString(expandedSections.value.includes("fill") ? "â–¼" : "â–º"), 1),
            _cache[37] || (_cache[37] = createBaseVNode("span", { class: "section-title" }, "Fill", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasFill.value,
              onClick: _cache[15] || (_cache[15] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleFill,
              class: "section-toggle"
            }, null, 40, _hoisted_20$h)
          ]),
          expandedSections.value.includes("fill") && hasFill.value ? (openBlock(), createElementBlock("div", _hoisted_21$g, [
            createBaseVNode("div", _hoisted_22$f, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_23$f, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.fill || "#ffffff",
                  onInput: _cache[17] || (_cache[17] = (e) => update("fill", e.target.value))
                }, null, 40, _hoisted_24$d)
              ])
            ]),
            createBaseVNode("div", _hoisted_25$d, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Fill Opacity") ?? shapeData.value.fillOpacity ?? 100,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Fill Opacity", v, "fillOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Fill Opacity") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Fill Opacity", "fillOpacity"))
              }, "â—†", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_26$d, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[20] || (_cache[20] = ($event) => toggleSection("trim"))
          }, [
            createBaseVNode("span", _hoisted_27$c, toDisplayString(expandedSections.value.includes("trim") ? "â–¼" : "â–º"), 1),
            _cache[40] || (_cache[40] = createBaseVNode("span", { class: "section-title" }, "Trim Paths", -1))
          ]),
          expandedSections.value.includes("trim") ? (openBlock(), createElementBlock("div", _hoisted_28$c, [
            createBaseVNode("div", _hoisted_29$c, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Start", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Start") ?? shapeData.value.trimStart ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Trim Start", v, "trimStart")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Start") }]),
                onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("Trim Start", "trimStart"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_30$c, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "End", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim End") ?? shapeData.value.trimEnd ?? 100,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updateAnimatable("Trim End", v, "trimEnd")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim End") }]),
                onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("Trim End", "trimEnd"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_31$9, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Offset") ?? shapeData.value.trimOffset ?? 0,
                "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Trim Offset", v, "trimOffset")),
                min: -360,
                max: 360,
                unit: "Â°"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Offset") }]),
                onClick: _cache[26] || (_cache[26] = ($event) => toggleKeyframe("Trim Offset", "trimOffset"))
              }, "â—†", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$8, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[27] || (_cache[27] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_33$8, toDisplayString(expandedSections.value.includes("path") ? "â–¼" : "â–º"), 1),
            _cache[44] || (_cache[44] = createBaseVNode("span", { class: "section-title" }, "Path", -1))
          ]),
          expandedSections.value.includes("path") ? (openBlock(), createElementBlock("div", _hoisted_34$8, [
            createBaseVNode("div", _hoisted_35$8, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: shapeData.value.closed,
                  onChange: _cache[28] || (_cache[28] = ($event) => update("closed", $event.target.checked))
                }, null, 40, _hoisted_36$8),
                _cache[45] || (_cache[45] = createTextVNode(" Closed Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_37$8, [
              _cache[46] || (_cache[46] = createBaseVNode("span", { class: "info-label" }, "Points:", -1)),
              createBaseVNode("span", _hoisted_38$8, toDisplayString(shapeData.value.controlPoints?.length || 0), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ShapeProperties = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-ec86bc1a"]]);

const _hoisted_1$r = { class: "video-properties" };
const _hoisted_2$r = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$r = { class: "section-content info-grid" };
const _hoisted_4$r = { class: "info-row" };
const _hoisted_5$r = { class: "info-value" };
const _hoisted_6$r = { class: "info-row" };
const _hoisted_7$r = { class: "info-value" };
const _hoisted_8$q = { class: "info-row" };
const _hoisted_9$p = { class: "info-value" };
const _hoisted_10$o = { class: "info-row" };
const _hoisted_11$n = { class: "info-value" };
const _hoisted_12$l = { class: "property-section" };
const _hoisted_13$k = { class: "section-content" };
const _hoisted_14$i = { class: "property-row" };
const _hoisted_15$i = { class: "property-row" };
const _hoisted_16$i = { class: "property-row" };
const _hoisted_17$h = { class: "checkbox-group" };
const _hoisted_18$g = { class: "checkbox-row" };
const _hoisted_19$g = ["checked"];
const _hoisted_20$g = { class: "checkbox-row" };
const _hoisted_21$f = ["checked"];
const _hoisted_22$e = { class: "property-section" };
const _hoisted_23$e = { class: "section-header" };
const _hoisted_24$c = { class: "header-toggle" };
const _hoisted_25$c = ["checked"];
const _hoisted_26$c = {
  key: 0,
  class: "section-content"
};
const _hoisted_27$b = { class: "property-row" };
const _hoisted_28$b = { class: "control-with-keyframe" };
const _hoisted_29$b = { class: "property-section" };
const _hoisted_30$b = { class: "section-content" };
const _hoisted_31$8 = { class: "property-row" };
const _hoisted_32$7 = ["value"];
const _hoisted_33$7 = {
  key: 1,
  class: "property-section"
};
const _hoisted_34$7 = { class: "section-content" };
const _hoisted_35$7 = { class: "checkbox-group" };
const _hoisted_36$7 = { class: "checkbox-row" };
const _hoisted_37$7 = ["checked"];
const _hoisted_38$7 = {
  key: 0,
  class: "property-row"
};
const _hoisted_39$7 = { class: "control-with-keyframe" };
const _hoisted_40$6 = {
  key: 1,
  class: "property-row"
};
const _hoisted_41$4 = {
  key: 2,
  class: "waveform-container"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const videoData = computed(() => {
      return props.layer.data || {
        assetId: null,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: true,
        audioLevel: 100,
        posterFrame: 0
      };
    });
    const assetInfo = computed(() => {
      const assetId = videoData.value.assetId;
      if (!assetId) return null;
      return store.assets[assetId] || null;
    });
    const audioLevel = computed(() => {
      return props.layer.audio?.level;
    });
    const timeRemapValue = computed(() => {
      if (!videoData.value.timeRemap) return 0;
      return videoData.value.timeRemap.value;
    });
    function formatDuration(seconds) {
      if (!seconds) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = Math.floor(seconds % 1 * (assetInfo.value?.fps || 30));
      return `${mins}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
    }
    function updateSpeed(val) {
      store.updateVideoLayerData(props.layer.id, { speed: val });
      emit("update");
    }
    function updateStartTime(val) {
      store.updateVideoLayerData(props.layer.id, { startTime: val });
      emit("update");
    }
    function updateEndTime(val) {
      store.updateVideoLayerData(props.layer.id, { endTime: val });
      emit("update");
    }
    function updateLoop(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { loop: target.checked });
      emit("update");
    }
    function updatePingPong(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { pingPong: target.checked });
      emit("update");
    }
    function toggleTimeRemap(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { timeRemapEnabled: target.checked });
      emit("update");
    }
    function updateTimeRemap(val) {
      const data = props.layer.data;
      if (data.timeRemap) {
        data.timeRemap.value = val;
      }
      emit("update");
    }
    function updateFrameBlending(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { frameBlending: target.value });
      emit("update");
    }
    function updateAudioEnabled(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { audioEnabled: target.checked });
      emit("update");
    }
    function updateAudioLevel(val) {
      store.updateVideoLayerData(props.layer.id, { audioLevel: val });
      emit("update");
    }
    function updateLevel(val) {
      if (props.layer.audio?.level) {
        props.layer.audio.level.value = val;
        emit("update");
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        assetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$r, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "section-header" }, "Video Info", -1)),
          createBaseVNode("div", _hoisted_3$r, [
            createBaseVNode("div", _hoisted_4$r, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_5$r, toDisplayString(assetInfo.value.width) + " Ã— " + toDisplayString(assetInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_6$r, [
              _cache[1] || (_cache[1] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_7$r, toDisplayString(formatDuration(assetInfo.value.duration)), 1)
            ]),
            createBaseVNode("div", _hoisted_8$q, [
              _cache[2] || (_cache[2] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_9$p, toDisplayString(assetInfo.value.fps?.toFixed(2) || "?") + " fps", 1)
            ]),
            createBaseVNode("div", _hoisted_10$o, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "info-label" }, "Has Audio", -1)),
              createBaseVNode("span", _hoisted_11$n, toDisplayString(assetInfo.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_12$l, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, "Playback", -1)),
          createBaseVNode("div", _hoisted_13$k, [
            createBaseVNode("div", _hoisted_14$i, [
              _cache[5] || (_cache[5] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.speed,
                "onUpdate:modelValue": updateSpeed,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$i, [
              _cache[6] || (_cache[6] = createBaseVNode("label", null, "Start Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.startTime,
                "onUpdate:modelValue": updateStartTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_16$i, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "End Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.endTime || assetInfo.value?.duration || 0,
                "onUpdate:modelValue": updateEndTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_17$h, [
              createBaseVNode("label", _hoisted_18$g, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.loop,
                  onChange: updateLoop
                }, null, 40, _hoisted_19$g),
                _cache[8] || (_cache[8] = createBaseVNode("span", null, "Loop", -1))
              ]),
              createBaseVNode("label", _hoisted_20$g, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.pingPong,
                  onChange: updatePingPong
                }, null, 40, _hoisted_21$f),
                _cache[9] || (_cache[9] = createBaseVNode("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_22$e, [
          createBaseVNode("div", _hoisted_23$e, [
            _cache[11] || (_cache[11] = createBaseVNode("span", null, "Time Remap", -1)),
            createBaseVNode("label", _hoisted_24$c, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: videoData.value.timeRemapEnabled,
                onChange: toggleTimeRemap
              }, null, 40, _hoisted_25$c)
            ])
          ]),
          videoData.value.timeRemapEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$c, [
            createBaseVNode("div", _hoisted_27$b, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Remap Time", -1)),
              createBaseVNode("div", _hoisted_28$b, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: timeRemapValue.value,
                  "onUpdate:modelValue": updateTimeRemap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                videoData.value.timeRemap ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: videoData.value.timeRemap,
                  layerId: __props.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[13] || (_cache[13] = createBaseVNode("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_29$b, [
          _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-header" }, "Frame Blending", -1)),
          createBaseVNode("div", _hoisted_30$b, [
            createBaseVNode("div", _hoisted_31$8, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Mode", -1)),
              createBaseVNode("select", {
                value: videoData.value.frameBlending,
                onChange: updateFrameBlending,
                class: "select-input"
              }, [..._cache[14] || (_cache[14] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "frame-mix" }, "Frame Mix", -1),
                createBaseVNode("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, _hoisted_32$7)
            ])
          ])
        ]),
        assetInfo.value?.hasAudio !== false ? (openBlock(), createElementBlock("div", _hoisted_33$7, [
          _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, "Audio", -1)),
          createBaseVNode("div", _hoisted_34$7, [
            createBaseVNode("div", _hoisted_35$7, [
              createBaseVNode("label", _hoisted_36$7, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.audioEnabled,
                  onChange: updateAudioEnabled
                }, null, 40, _hoisted_37$7),
                _cache[17] || (_cache[17] = createBaseVNode("span", null, "Audio Enabled", -1))
              ])
            ]),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_38$7, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Level", -1)),
              createBaseVNode("div", _hoisted_39$7, [
                audioLevel.value ? (openBlock(), createBlock(unref(ScrubableNumber), {
                  key: 0,
                  modelValue: audioLevel.value.value,
                  "onUpdate:modelValue": updateLevel,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                audioLevel.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 1,
                  property: audioLevel.value,
                  layerId: __props.layer.id
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_40$6, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Volume", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.audioLevel,
                "onUpdate:modelValue": updateAudioLevel,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_41$4, [..._cache[20] || (_cache[20] = [
              createBaseVNode("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VideoProperties = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-5f46759a"]]);

const _hoisted_1$q = { class: "camera-properties" };
const _hoisted_2$q = { class: "prop-section" };
const _hoisted_3$q = { class: "expand-icon" };
const _hoisted_4$q = {
  key: 0,
  class: "section-content"
};
const _hoisted_5$q = { class: "property-row checkbox-row" };
const _hoisted_6$q = ["checked"];
const _hoisted_7$q = { class: "property-row" };
const _hoisted_8$p = { class: "property-row" };
const _hoisted_9$o = { class: "prop-section" };
const _hoisted_10$n = { class: "expand-icon" };
const _hoisted_11$m = ["checked"];
const _hoisted_12$k = {
  key: 0,
  class: "section-content"
};
const _hoisted_13$j = { class: "property-row" };
const _hoisted_14$h = { class: "property-row" };
const _hoisted_15$h = { class: "property-row" };
const _hoisted_16$h = { class: "prop-section" };
const _hoisted_17$g = { class: "expand-icon" };
const _hoisted_18$f = ["checked"];
const _hoisted_19$f = {
  key: 0,
  class: "section-content"
};
const _hoisted_20$f = { class: "property-row" };
const _hoisted_21$e = ["value"];
const _hoisted_22$d = ["value"];
const _hoisted_23$d = { class: "property-row" };
const _hoisted_24$b = { class: "property-row" };
const _hoisted_25$b = { class: "property-row" };
const _hoisted_26$b = { class: "property-row" };
const _hoisted_27$a = { class: "property-row checkbox-row" };
const _hoisted_28$a = ["checked"];
const _hoisted_29$a = { class: "property-row checkbox-row" };
const _hoisted_30$a = ["checked"];
const _hoisted_31$7 = {
  key: 0,
  class: "property-row"
};
const _hoisted_32$6 = { class: "prop-section" };
const _hoisted_33$6 = { class: "expand-icon" };
const _hoisted_34$6 = {
  key: 0,
  class: "section-content"
};
const _hoisted_35$6 = { class: "property-row" };
const _hoisted_36$6 = { class: "property-row" };
const _hoisted_37$6 = { class: "property-row" };
const _hoisted_38$6 = { class: "property-row" };
const _hoisted_39$6 = { class: "property-row" };
const _hoisted_40$5 = { class: "property-row" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["settings", "dof"]);
    const cameraData = computed(() => {
      return props.layer.data || {
        cameraId: "",
        isActiveCamera: false
      };
    });
    const depthOfField = computed(() => {
      return cameraData.value.depthOfField || {
        enabled: false,
        focusDistance: 500,
        aperture: 2.8,
        blurLevel: 50
      };
    });
    const dofEnabled = computed(() => depthOfField.value.enabled);
    const pathFollowing = computed(() => {
      return cameraData.value.pathFollowing || {
        enabled: false,
        pathLayerId: "",
        parameter: { id: "", name: "Path Position", type: "number", value: 0, animated: false, keyframes: [], group: "Path Following" },
        lookAhead: 0.05,
        bankingStrength: 0,
        offsetY: 0,
        alignToPath: true,
        autoAdvance: false,
        autoAdvanceSpeed: 0.01
      };
    });
    const splineLayers = computed(() => {
      return store.layers.filter((l) => l.type === "spline" && l.id !== props.layer.id);
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...cameraData.value, [key]: value }
      });
      emit("update");
    }
    function toggleDOF(e) {
      const checked = e.target.checked;
      const newDOF = { ...depthOfField.value, enabled: checked };
      update("depthOfField", newDOF);
    }
    function togglePathFollowing(e) {
      const checked = e.target.checked;
      const newPath = { ...pathFollowing.value, enabled: checked };
      update("pathFollowing", newPath);
    }
    function updatePathLayer(e) {
      const layerId = e.target.value;
      const newPath = { ...pathFollowing.value, pathLayerId: layerId };
      update("pathFollowing", newPath);
    }
    function updatePathConfig(key, value) {
      const newPath = { ...pathFollowing.value, [key]: value };
      update("pathFollowing", newPath);
    }
    function updatePathProperty(key, value) {
      const param = pathFollowing.value.parameter;
      const newParam = { ...param, value };
      const newPath = { ...pathFollowing.value, parameter: newParam };
      update("pathFollowing", newPath);
      const prop = getProperty("Path Position");
      if (prop) {
        prop.value = value;
      }
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      const animProp = cameraData.value[dataKey];
      if (animProp) {
        animProp.value = value;
        update(dataKey, animProp);
      }
      emit("update");
    }
    function updateDOFAnimatable(propName, value, dofKey) {
      const newDOF = { ...depthOfField.value, [dofKey]: value };
      update("depthOfField", newDOF);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      emit("update");
    }
    function ensureProperty(propName, defaultValue, group) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: defaultValue,
          animated: false,
          keyframes: [],
          group
        });
      }
    }
    function toggleKeyframe(propName, dataKey, defaultValue) {
      ensureProperty(propName, defaultValue, propName.includes("Focus") || propName.includes("Aperture") || propName.includes("Blur") ? "Depth of Field" : "Camera");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function togglePathKeyframe(propName) {
      ensureProperty(propName, pathFollowing.value.parameter?.value ?? 0, "Path Following");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function getVec3Value(propName, axis) {
      const dataKey = propName === "Position" ? "animatedPosition" : "animatedTarget";
      const animProp = cameraData.value[dataKey];
      if (animProp?.value) {
        return animProp.value[axis] ?? 0;
      }
      return 0;
    }
    function updateVec3Property(propName, axis, value, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const newValue = { ...animProp.value, [axis]: value };
      animProp.value = newValue;
      update(dataKey, animProp);
    }
    function toggleVec3Keyframe(propName, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const frame = store.currentFrame;
      const hasKeyframeAtFrame = animProp.keyframes.some((k) => k.frame === frame);
      if (hasKeyframeAtFrame) {
        animProp.keyframes = animProp.keyframes.filter((k) => k.frame !== frame);
        animProp.animated = animProp.keyframes.length > 0;
      } else {
        animProp.keyframes.push({
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          frame,
          value: { ...animProp.value },
          easing: "linear"
        });
        animProp.animated = true;
      }
      update(dataKey, animProp);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$q, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("settings"))
          }, [
            createBaseVNode("span", _hoisted_3$q, toDisplayString(expandedSections.value.includes("settings") ? "â–¼" : "â–º"), 1),
            _cache[33] || (_cache[33] = createBaseVNode("span", { class: "section-title" }, "Camera Settings", -1))
          ]),
          expandedSections.value.includes("settings") ? (openBlock(), createElementBlock("div", _hoisted_4$q, [
            createBaseVNode("div", _hoisted_5$q, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: cameraData.value.isActiveCamera,
                  onChange: _cache[1] || (_cache[1] = ($event) => update("isActiveCamera", $event.target.checked))
                }, null, 40, _hoisted_6$q),
                _cache[34] || (_cache[34] = createTextVNode(" Active Camera ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_7$q, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "FOV", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("FOV") ?? 50,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("FOV", v, "animatedFov")),
                min: 10,
                max: 120,
                unit: "Â°"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("FOV") }]),
                onClick: _cache[3] || (_cache[3] = ($event) => toggleKeyframe("FOV", "animatedFov", 50))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_8$p, [
              _cache[36] || (_cache[36] = createBaseVNode("label", null, "Focal Length", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focal Length") ?? 50,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateAnimatable("Focal Length", v, "animatedFocalLength")),
                min: 10,
                max: 300,
                unit: "mm"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focal Length") }]),
                onClick: _cache[5] || (_cache[5] = ($event) => toggleKeyframe("Focal Length", "animatedFocalLength", 50))
              }, "â—†", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_9$o, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("dof"))
          }, [
            createBaseVNode("span", _hoisted_10$n, toDisplayString(expandedSections.value.includes("dof") ? "â–¼" : "â–º"), 1),
            _cache[37] || (_cache[37] = createBaseVNode("span", { class: "section-title" }, "Depth of Field", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: dofEnabled.value,
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleDOF,
              class: "section-toggle"
            }, null, 40, _hoisted_11$m)
          ]),
          expandedSections.value.includes("dof") && dofEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_12$k, [
            createBaseVNode("div", _hoisted_13$j, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Focus Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focus Distance") ?? depthOfField.value.focusDistance,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateDOFAnimatable("Focus Distance", v, "focusDistance")),
                min: 0,
                max: 1e4,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focus Distance") }]),
                onClick: _cache[9] || (_cache[9] = ($event) => toggleKeyframe("Focus Distance", "animatedFocusDistance", depthOfField.value.focusDistance))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_14$h, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Aperture", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Aperture") ?? depthOfField.value.aperture,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateDOFAnimatable("Aperture", v, "aperture")),
                min: 0.5,
                max: 32,
                step: 0.1,
                unit: "f/"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Aperture") }]),
                onClick: _cache[11] || (_cache[11] = ($event) => toggleKeyframe("Aperture", "animatedAperture", depthOfField.value.aperture))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_15$h, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Blur Level", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Blur Level") ?? depthOfField.value.blurLevel,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateDOFAnimatable("Blur Level", v, "blurLevel")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Blur Level") }]),
                onClick: _cache[13] || (_cache[13] = ($event) => toggleKeyframe("Blur Level", "animatedBlurLevel", depthOfField.value.blurLevel))
              }, "â—†", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_16$h, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[15] || (_cache[15] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_17$g, toDisplayString(expandedSections.value.includes("path") ? "â–¼" : "â–º"), 1),
            _cache[41] || (_cache[41] = createBaseVNode("span", { class: "section-title" }, "Path Following", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: pathFollowing.value.enabled,
              onClick: _cache[14] || (_cache[14] = withModifiers(() => {
              }, ["stop"])),
              onChange: togglePathFollowing,
              class: "section-toggle"
            }, null, 40, _hoisted_18$f)
          ]),
          expandedSections.value.includes("path") && pathFollowing.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_19$f, [
            createBaseVNode("div", _hoisted_20$f, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Path Layer", -1)),
              createBaseVNode("select", {
                class: "path-select",
                value: pathFollowing.value.pathLayerId,
                onChange: updatePathLayer
              }, [
                _cache[42] || (_cache[42] = createBaseVNode("option", { value: "" }, "Select Path...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_22$d);
                }), 128))
              ], 40, _hoisted_21$e)
            ]),
            createBaseVNode("div", _hoisted_23$d, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Position", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Position") ?? pathFollowing.value.parameter?.value ?? 0,
                "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updatePathProperty("parameter", v)),
                min: 0,
                max: 1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Path Position") }]),
                onClick: _cache[17] || (_cache[17] = ($event) => togglePathKeyframe("Path Position"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_24$b, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Look Ahead", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.lookAhead ?? 0.05,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updatePathConfig("lookAhead", v)),
                min: 0,
                max: 0.5,
                step: 0.01,
                precision: 2
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$b, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Banking", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.bankingStrength ?? 0,
                "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updatePathConfig("bankingStrength", v)),
                min: 0,
                max: 1,
                step: 0.05
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_26$b, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Height Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.offsetY ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updatePathConfig("offsetY", v)),
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_27$a, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.alignToPath,
                  onChange: _cache[21] || (_cache[21] = ($event) => updatePathConfig("alignToPath", $event.target.checked))
                }, null, 40, _hoisted_28$a),
                _cache[48] || (_cache[48] = createTextVNode(" Align to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$a, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.autoAdvance,
                  onChange: _cache[22] || (_cache[22] = ($event) => updatePathConfig("autoAdvance", $event.target.checked))
                }, null, 40, _hoisted_30$a),
                _cache[49] || (_cache[49] = createTextVNode(" Auto Advance ", -1))
              ])
            ]),
            pathFollowing.value.autoAdvance ? (openBlock(), createElementBlock("div", _hoisted_31$7, [
              _cache[50] || (_cache[50] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.autoAdvanceSpeed ?? 0.01,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updatePathConfig("autoAdvanceSpeed", v)),
                min: 1e-3,
                max: 0.1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$6, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[24] || (_cache[24] = ($event) => toggleSection("position"))
          }, [
            createBaseVNode("span", _hoisted_33$6, toDisplayString(expandedSections.value.includes("position") ? "â–¼" : "â–º"), 1),
            _cache[51] || (_cache[51] = createBaseVNode("span", { class: "section-title" }, "Position & Target", -1))
          ]),
          expandedSections.value.includes("position") ? (openBlock(), createElementBlock("div", _hoisted_34$6, [
            createBaseVNode("div", _hoisted_35$6, [
              _cache[52] || (_cache[52] = createBaseVNode("label", null, "Position X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "x"),
                "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateVec3Property("Position", "x", v, "animatedPosition"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Position") }]),
                onClick: _cache[26] || (_cache[26] = ($event) => toggleVec3Keyframe("Position", "animatedPosition"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_36$6, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Position Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "y"),
                "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateVec3Property("Position", "y", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$6, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Position Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "z"),
                "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateVec3Property("Position", "z", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            _cache[58] || (_cache[58] = createBaseVNode("div", { class: "property-row separator" }, [
              createBaseVNode("span", { class: "separator-line" })
            ], -1)),
            createBaseVNode("div", _hoisted_38$6, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Target X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "x"),
                "onUpdate:modelValue": _cache[29] || (_cache[29] = (v) => updateVec3Property("Target", "x", v, "animatedTarget"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Target") }]),
                onClick: _cache[30] || (_cache[30] = ($event) => toggleVec3Keyframe("Target", "animatedTarget"))
              }, "â—†", 2)
            ]),
            createBaseVNode("div", _hoisted_39$6, [
              _cache[56] || (_cache[56] = createBaseVNode("label", null, "Target Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "y"),
                "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateVec3Property("Target", "y", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_40$5, [
              _cache[57] || (_cache[57] = createBaseVNode("label", null, "Target Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "z"),
                "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateVec3Property("Target", "z", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const CameraProperties$1 = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-de00c3b0"]]);

const _hoisted_1$p = ["title"];
const _hoisted_2$p = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
};
const _hoisted_3$p = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_4$p = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_5$p = ["x1", "y1", "x2", "y2"];
const _hoisted_6$p = ["cx", "cy"];
const _hoisted_7$p = { class: "drop-label" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const containerRef = ref(null);
    const isDragging = ref(false);
    const dragStart = ref({ x: 0, y: 0 });
    const dragEnd = ref({ x: 0, y: 0 });
    const currentDropTarget = ref(null);
    const hasLink = computed(() => !!props.linkedTo);
    const linkTargetName = computed(() => {
      if (!props.linkedTo) return "";
      return `${props.linkedTo.layerId}.${props.linkedTo.property}`;
    });
    const lineStyle = computed(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    }));
    const dropTargetStyle = computed(() => {
      if (!currentDropTarget.value) return {};
      const rect = currentDropTarget.value.rect;
      return {
        position: "fixed",
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        zIndex: 9999
      };
    });
    function findDropTargets() {
      const targets = [];
      const elements = document.querySelectorAll("[data-pickwhip-target]");
      elements.forEach((el) => {
        const htmlEl = el;
        const layerId = htmlEl.dataset.pickwhipLayerId;
        const property = htmlEl.dataset.pickwhipTarget;
        const label = htmlEl.dataset.pickwhipLabel || property;
        if (layerId === props.layerId && property === props.property) {
          return;
        }
        if (layerId && property) {
          targets.push({
            layerId,
            property,
            label,
            element: htmlEl,
            rect: htmlEl.getBoundingClientRect()
          });
        }
      });
      return targets;
    }
    function findTargetAtPosition(x, y, targets) {
      for (const target of targets) {
        const rect = target.rect;
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return target;
        }
      }
      return null;
    }
    let dropTargets = [];
    function startDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      const rect = containerRef.value?.getBoundingClientRect();
      if (rect) {
        dragStart.value = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      } else {
        dragStart.value = { x: clientX, y: clientY };
      }
      dragEnd.value = { x: clientX, y: clientY };
      isDragging.value = true;
      dropTargets = findDropTargets();
      window.addEventListener("mousemove", onDrag);
      window.addEventListener("mouseup", endDrag);
      window.addEventListener("touchmove", onDrag);
      window.addEventListener("touchend", endDrag);
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      dragEnd.value = { x: clientX, y: clientY };
      dropTargets.forEach((t) => {
        t.rect = t.element.getBoundingClientRect();
      });
      currentDropTarget.value = findTargetAtPosition(clientX, clientY, dropTargets);
    }
    function endDrag(e) {
      if (!isDragging.value) return;
      const clientX = "changedTouches" in e ? e.changedTouches[0].clientX : e.clientX;
      const clientY = "changedTouches" in e ? e.changedTouches[0].clientY : e.clientY;
      const target = findTargetAtPosition(clientX, clientY, dropTargets);
      if (target) {
        emit("link", { layerId: target.layerId, property: target.property });
      }
      isDragging.value = false;
      currentDropTarget.value = null;
      dropTargets = [];
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    }
    function clearLink() {
      emit("unlink");
    }
    onUnmounted(() => {
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "pickwhip-container",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["pickwhip-handle", { dragging: isDragging.value, linked: hasLink.value }]),
          onMousedown: startDrag,
          onTouchstart: withModifiers(startDrag, ["prevent"]),
          title: hasLink.value ? `Linked to: ${linkTargetName.value}` : "Drag to link property"
        }, [
          (openBlock(), createElementBlock("svg", _hoisted_2$p, [
            _cache[0] || (_cache[0] = createBaseVNode("circle", {
              cx: "8",
              cy: "8",
              r: "3",
              fill: "currentColor"
            }, null, -1)),
            !hasLink.value ? (openBlock(), createElementBlock("path", _hoisted_3$p)) : (openBlock(), createElementBlock("path", _hoisted_4$p))
          ]))
        ], 42, _hoisted_1$p),
        hasLink.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "clear-link-btn",
          onClick: clearLink,
          title: "Remove link"
        }, " Ã— ")) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "pickwhip-line",
            style: normalizeStyle(lineStyle.value)
          }, [
            createBaseVNode("line", {
              x1: dragStart.value.x,
              y1: dragStart.value.y,
              x2: dragEnd.value.x,
              y2: dragEnd.value.y,
              stroke: "#4a90d9",
              "stroke-width": "2",
              "stroke-dasharray": "4 2"
            }, null, 8, _hoisted_5$p),
            createBaseVNode("circle", {
              cx: dragEnd.value.x,
              cy: dragEnd.value.y,
              r: "6",
              fill: "#4a90d9",
              stroke: "#fff",
              "stroke-width": "1"
            }, null, 8, _hoisted_6$p)
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value && currentDropTarget.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "drop-target-highlight",
            style: normalizeStyle(dropTargetStyle.value)
          }, [
            createBaseVNode("span", _hoisted_7$p, toDisplayString(currentDropTarget.value.label), 1)
          ], 4)) : createCommentVNode("", true)
        ]))
      ], 512);
    };
  }
});

const Pickwhip = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-da1938e3"]]);

const _hoisted_1$o = {
  key: 0,
  class: "driver-list"
};
const _hoisted_2$o = { class: "expand-icon" };
const _hoisted_3$o = { class: "count" };
const _hoisted_4$o = {
  key: 0,
  class: "driver-items"
};
const _hoisted_5$o = { class: "driver-header" };
const _hoisted_6$o = ["onClick"];
const _hoisted_7$o = { class: "driver-info" };
const _hoisted_8$o = { class: "target" };
const _hoisted_9$n = {
  key: 0,
  class: "source"
};
const _hoisted_10$m = {
  key: 1,
  class: "source audio"
};
const _hoisted_11$l = {
  key: 2,
  class: "source time"
};
const _hoisted_12$j = ["onClick"];
const _hoisted_13$i = {
  key: 0,
  class: "driver-transforms"
};
const _hoisted_14$g = ["title"];
const _hoisted_15$g = {
  key: 1,
  class: "add-driver-section"
};
const _hoisted_16$g = {
  key: 0,
  class: "add-menu"
};
const _hoisted_17$f = { class: "menu-section" };
const _hoisted_18$e = { class: "menu-section" };
const _hoisted_19$e = { class: "menu-section" };
const _hoisted_20$e = { class: "menu-section" };
const _hoisted_21$d = { class: "menu-actions" };
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(__props) {
    const props = __props;
    const store = useCompositorStore();
    const expanded = ref(true);
    const showAddMenu = ref(false);
    const newDriver = ref({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    });
    const drivers = computed(() => {
      return store.getDriversForLayer(props.layerId);
    });
    function formatProperty(prop) {
      if (!prop) return "?";
      const names = {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        "opacity": "Opacity"
      };
      return names[prop] || prop;
    }
    function getSourceLayerName(layerId) {
      if (!layerId) return "?";
      const layer = store.layers.find((l) => l.id === layerId);
      return layer?.name || layerId.slice(0, 8);
    }
    function formatTransform(t) {
      switch (t.type) {
        case "scale":
          return `Scale: ${t.factor}`;
        case "offset":
          return `Offset: ${t.amount}`;
        case "clamp":
          return `Clamp: ${t.min}-${t.max}`;
        case "smooth":
          return `Smooth: ${t.smoothing}`;
        case "threshold":
          return `Threshold: ${t.threshold}`;
        default:
          return t.type;
      }
    }
    function toggleDriver(driverId) {
      store.togglePropertyDriver(driverId);
    }
    function removeDriver(driverId) {
      store.removePropertyDriver(driverId);
    }
    function createAudioDriver() {
      store.createAudioPropertyDriver(
        props.layerId,
        newDriver.value.targetProperty,
        newDriver.value.audioFeature,
        {
          scale: newDriver.value.scale,
          threshold: newDriver.value.threshold > 0 ? newDriver.value.threshold : void 0
        }
      );
      showAddMenu.value = false;
    }
    return (_ctx, _cache) => {
      return drivers.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$o, [
        createBaseVNode("div", {
          class: "driver-list-header",
          onClick: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
        }, [
          createBaseVNode("span", _hoisted_2$o, toDisplayString(expanded.value ? "â–¼" : "â–º"), 1),
          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "title" }, "Property Drivers", -1)),
          createBaseVNode("span", _hoisted_3$o, "(" + toDisplayString(drivers.value.length) + ")", 1)
        ]),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_4$o, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(drivers.value, (driver) => {
            return openBlock(), createElementBlock("div", {
              key: driver.id,
              class: normalizeClass(["driver-item", { disabled: !driver.enabled }])
            }, [
              createBaseVNode("div", _hoisted_5$o, [
                createBaseVNode("button", {
                  class: normalizeClass(["toggle-btn", { active: driver.enabled }]),
                  onClick: ($event) => toggleDriver(driver.id),
                  title: "Toggle driver"
                }, " âš¡ ", 10, _hoisted_6$o),
                createBaseVNode("div", _hoisted_7$o, [
                  createBaseVNode("span", _hoisted_8$o, toDisplayString(formatProperty(driver.targetProperty)), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "arrow" }, "â†", -1)),
                  driver.sourceType === "property" ? (openBlock(), createElementBlock("span", _hoisted_9$n, toDisplayString(getSourceLayerName(driver.sourceLayerId)) + "." + toDisplayString(formatProperty(driver.sourceProperty)), 1)) : driver.sourceType === "audio" ? (openBlock(), createElementBlock("span", _hoisted_10$m, " ðŸŽµ " + toDisplayString(driver.audioFeature), 1)) : driver.sourceType === "time" ? (openBlock(), createElementBlock("span", _hoisted_11$l, " â± Time ")) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: "remove-btn",
                  onClick: ($event) => removeDriver(driver.id),
                  title: "Remove driver"
                }, " Ã— ", 8, _hoisted_12$j)
              ]),
              driver.transforms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$i, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(driver.transforms, (t, i) => {
                  return openBlock(), createElementBlock("span", {
                    key: i,
                    class: "transform-chip",
                    title: formatTransform(t)
                  }, toDisplayString(t.type), 9, _hoisted_14$g);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_15$g, [
          createBaseVNode("button", {
            class: "add-driver-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => showAddMenu.value = !showAddMenu.value)
          }, " + Add Audio Driver "),
          showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_16$g, [
            createBaseVNode("div", _hoisted_17$f, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Audio Feature:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newDriver.value.audioFeature = $event)
              }, [..._cache[9] || (_cache[9] = [
                createStaticVNode('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
              ])], 512), [
                [vModelSelect, newDriver.value.audioFeature]
              ])
            ]),
            createBaseVNode("div", _hoisted_18$e, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Target Property:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newDriver.value.targetProperty = $event)
              }, [..._cache[11] || (_cache[11] = [
                createStaticVNode('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
              ])], 512), [
                [vModelSelect, newDriver.value.targetProperty]
              ])
            ]),
            createBaseVNode("div", _hoisted_19$e, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Scale:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newDriver.value.scale = $event),
                step: "10"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.scale,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_20$e, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Threshold:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newDriver.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.threshold,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_21$d, [
              createBaseVNode("button", { onClick: createAudioDriver }, "Create"),
              createBaseVNode("button", {
                onClick: _cache[6] || (_cache[6] = ($event) => showAddMenu.value = false)
              }, "Cancel")
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});

const DriverList = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-d3107912"]]);

const _hoisted_1$n = { class: "properties-panel" };
const _hoisted_2$n = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$n = { class: "property-section" };
const _hoisted_4$n = { class: "property-row" };
const _hoisted_5$n = { class: "property-section" };
const _hoisted_6$n = { class: "property-row" };
const _hoisted_7$n = ["value"];
const _hoisted_8$n = ["value"];
const _hoisted_9$m = { class: "property-section" };
const _hoisted_10$l = { class: "expand-icon" };
const _hoisted_11$k = ["checked"];
const _hoisted_12$i = {
  key: 0,
  class: "section-content"
};
const _hoisted_13$h = ["data-pickwhip-layer-id"];
const _hoisted_14$f = { class: "multi-value" };
const _hoisted_15$f = { class: "multi-value" };
const _hoisted_16$f = { class: "property-row" };
const _hoisted_17$e = { class: "multi-value orientation-row" };
const _hoisted_18$d = { class: "property-row" };
const _hoisted_19$d = { class: "single-value" };
const _hoisted_20$d = { class: "property-row" };
const _hoisted_21$c = { class: "single-value" };
const _hoisted_22$c = { class: "property-row" };
const _hoisted_23$c = { class: "single-value" };
const _hoisted_24$a = { class: "single-value" };
const _hoisted_25$a = { class: "property-row" };
const _hoisted_26$a = { class: "multi-value" };
const _hoisted_27$9 = { class: "single-value" };
const _hoisted_28$9 = { class: "property-section" };
const _hoisted_29$9 = { class: "property-row" };
const _hoisted_30$9 = ["value"];
const _hoisted_31$6 = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "PropertiesPanel",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(["transform"]);
    const scaleLocked = ref(true);
    const layerName = ref("");
    const transform = ref({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    });
    const blendMode = ref("normal");
    const keyframes = ref([]);
    const blendModes = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ];
    const selectedLayer = computed(() => store.selectedLayer);
    const availableParents = computed(() => {
      if (!selectedLayer.value) return [];
      const selfId = selectedLayer.value.id;
      const getDescendantIds = (layerId) => {
        const children = store.layers.filter((l) => l.parentId === layerId);
        let ids = children.map((c) => c.id);
        for (const child of children) {
          ids = ids.concat(getDescendantIds(child.id));
        }
        return ids;
      };
      const descendantIds = new Set(getDescendantIds(selfId));
      return store.layers.filter(
        (l) => l.id !== selfId && !descendantIds.has(l.id) && l.type !== "camera"
        // Camera layers shouldn't be parents
      );
    });
    const layerPropertiesComponent = computed(() => {
      if (!selectedLayer.value) return null;
      switch (selectedLayer.value.type) {
        case "text":
          return markRaw(TextProperties);
        case "particles":
          return markRaw(ParticleProperties);
        case "depthflow":
          return markRaw(DepthflowProperties);
        case "light":
          return markRaw(LightProperties);
        case "spline":
          return markRaw(ShapeProperties);
        case "video":
          return markRaw(VideoProperties);
        case "camera":
          return markRaw(CameraProperties$1);
        default:
          return null;
      }
    });
    watch(selectedLayer, (layer) => {
      if (layer) {
        layerName.value = layer.name;
        const t = layer.transform;
        transform.value = {
          position: {
            x: t?.position?.value?.x || 0,
            y: t?.position?.value?.y || 0,
            z: t?.position?.value?.z || 0
          },
          scale: { x: t?.scale?.value?.x || 100, y: t?.scale?.value?.y || 100 },
          rotation: t?.rotation?.value || 0,
          anchorPoint: { x: t?.anchorPoint?.value?.x || 0, y: t?.anchorPoint?.value?.y || 0 },
          opacity: layer.opacity?.value || 100,
          // 3D properties
          orientationX: t?.orientation?.value?.x || 0,
          orientationY: t?.orientation?.value?.y || 0,
          orientationZ: t?.orientation?.value?.z || 0,
          rotationX: t?.rotationX?.value || 0,
          rotationY: t?.rotationY?.value || 0,
          rotationZ: t?.rotationZ?.value || 0
        };
        blendMode.value = layer.blendMode || "normal";
      }
    }, { immediate: true });
    watch(() => transform.value.scale.x, (newX, oldX) => {
      if (scaleLocked.value && newX !== oldX) {
        const ratio = newX / oldX;
        transform.value.scale.y = Math.round(transform.value.scale.y * ratio * 10) / 10;
      }
    });
    function toggleSection(section) {
      const index = expandedSections.value.indexOf(section);
      if (index >= 0) {
        expandedSections.value.splice(index, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function updateLayerName() {
      if (selectedLayer.value && layerName.value) {
        selectedLayer.value.name = layerName.value;
      }
    }
    function updateTransform() {
      if (!selectedLayer.value) return;
      const t = selectedLayer.value.transform;
      const v = transform.value;
      if (t?.position) {
        t.position.value = { x: v.position.x, y: v.position.y, z: v.position.z };
      }
      if (t?.scale) {
        t.scale.value = { x: v.scale.x, y: v.scale.y };
      }
      if (t?.rotation) {
        t.rotation.value = v.rotation;
      }
      if (t?.anchorPoint) {
        t.anchorPoint.value = { x: v.anchorPoint.x, y: v.anchorPoint.y };
      }
      if (selectedLayer.value.opacity) {
        selectedLayer.value.opacity.value = v.opacity;
      }
      if (selectedLayer.value.threeD) {
        if (t?.orientation) {
          t.orientation.value = { x: v.orientationX, y: v.orientationY, z: v.orientationZ };
        }
        if (t?.rotationX) t.rotationX.value = v.rotationX;
        if (t?.rotationY) t.rotationY.value = v.rotationY;
        if (t?.rotationZ) t.rotationZ.value = v.rotationZ;
      }
      onLayerUpdate();
    }
    function updateBlendMode() {
      if (selectedLayer.value) {
        selectedLayer.value.blendMode = blendMode.value;
      }
    }
    function toggle3D(event) {
      if (!selectedLayer.value) return;
      const threeD = event.target.checked;
      store.updateLayer(selectedLayer.value.id, { threeD });
      if (threeD && selectedLayer.value.transform?.position) {
        if (selectedLayer.value.transform.position.value.z === void 0) {
          selectedLayer.value.transform.position.value.z = 0;
        }
      }
    }
    function hasKeyframe(property) {
      return keyframes.value.includes(property);
    }
    function toggleKeyframe(property) {
      const index = keyframes.value.indexOf(property);
      if (index >= 0) {
        keyframes.value.splice(index, 1);
      } else {
        keyframes.value.push(property);
        console.log(`Added keyframe for ${property} at frame ${store.currentFrame}`);
      }
    }
    function onLayerUpdate(dataUpdates) {
      if (!selectedLayer.value) return;
      if (dataUpdates && Object.keys(dataUpdates).length > 0) {
        store.updateLayerData(selectedLayer.value.id, dataUpdates);
      } else {
        store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    function updateParent(event) {
      if (!selectedLayer.value) return;
      const parentId = event.target.value || null;
      store.setLayerParent(selectedLayer.value.id, parentId);
    }
    function getDriverForProperty(property) {
      if (!selectedLayer.value) return null;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === property && d.sourceType === "property");
      if (driver && driver.sourceLayerId && driver.sourceProperty) {
        return {
          layerId: driver.sourceLayerId,
          property: driver.sourceProperty
        };
      }
      return null;
    }
    function onPickwhipLink(targetProperty, source) {
      if (!selectedLayer.value) return;
      store.createPropertyLink(
        selectedLayer.value.id,
        targetProperty,
        source.layerId,
        source.property,
        { blendMode: "add" }
      );
      console.log(`[PropertiesPanel] Linked ${selectedLayer.value.id}.${targetProperty} <- ${source.layerId}.${source.property}`);
    }
    function onPickwhipUnlink(targetProperty) {
      if (!selectedLayer.value) return;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === targetProperty && d.sourceType === "property");
      if (driver) {
        store.removePropertyDriver(driver.id);
        console.log(`[PropertiesPanel] Unlinked ${selectedLayer.value.id}.${targetProperty}`);
      }
    }
    function hasDriver(property) {
      if (!selectedLayer.value) return false;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      return drivers.some((d) => d.targetProperty === property && d.enabled);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        _cache[51] || (_cache[51] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        selectedLayer.value ? (openBlock(), createElementBlock("div", _hoisted_2$n, [
          createBaseVNode("div", _hoisted_3$n, [
            createBaseVNode("div", _hoisted_4$n, [
              withDirectives(createBaseVNode("input", {
                type: "text",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => layerName.value = $event),
                class: "layer-name-input",
                onBlur: updateLayerName,
                onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => $event.target.blur(), ["enter"]))
              }, null, 544), [
                [vModelText, layerName.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_5$n, [
            createBaseVNode("div", _hoisted_6$n, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Parent", -1)),
              createBaseVNode("select", {
                class: "parent-select",
                value: selectedLayer.value?.parentId || "",
                onChange: updateParent
              }, [
                _cache[37] || (_cache[37] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_8$n);
                }), 128))
              ], 40, _hoisted_7$n)
            ])
          ]),
          createBaseVNode("div", _hoisted_9$m, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[3] || (_cache[3] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_10$l, toDisplayString(expandedSections.value.includes("transform") ? "â–¼" : "â–º"), 1),
              _cache[40] || (_cache[40] = createBaseVNode("span", { class: "section-title" }, "Transform", -1)),
              createBaseVNode("label", {
                class: "threeD-toggle",
                onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: selectedLayer.value?.threeD,
                  onChange: toggle3D
                }, null, 40, _hoisted_11$k),
                _cache[39] || (_cache[39] = createBaseVNode("span", { class: "toggle-label" }, "3D", -1))
              ])
            ]),
            expandedSections.value.includes("transform") ? (openBlock(), createElementBlock("div", _hoisted_12$i, [
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.position.x") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.position.x",
                  linkedTo: getDriverForProperty("transform.position.x"),
                  onLink: _cache[4] || (_cache[4] = (target) => onPickwhipLink("transform.position.x", target)),
                  onUnlink: _cache[5] || (_cache[5] = () => onPickwhipUnlink("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                createBaseVNode("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": selectedLayer.value?.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, _hoisted_13$h),
                createBaseVNode("div", _hoisted_14$f, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.x,
                    "onUpdate:modelValue": [
                      _cache[6] || (_cache[6] = ($event) => transform.value.position.x = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.y,
                    "onUpdate:modelValue": [
                      _cache[7] || (_cache[7] = ($event) => transform.value.position.y = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.position.z,
                    "onUpdate:modelValue": [
                      _cache[8] || (_cache[8] = ($event) => transform.value.position.z = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("position") }]),
                  onClick: _cache[9] || (_cache[9] = ($event) => toggleKeyframe("position"))
                }, "â—†", 2)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.scale.x") || hasDriver("transform.scale.y") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.scale.x",
                  linkedTo: getDriverForProperty("transform.scale.x"),
                  onLink: _cache[10] || (_cache[10] = (target) => onPickwhipLink("transform.scale.x", target)),
                  onUnlink: _cache[11] || (_cache[11] = () => onPickwhipUnlink("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[41] || (_cache[41] = createBaseVNode("label", null, "Scale", -1)),
                createBaseVNode("div", _hoisted_15$f, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.x,
                    "onUpdate:modelValue": [
                      _cache[12] || (_cache[12] = ($event) => transform.value.scale.x = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  createBaseVNode("button", {
                    class: normalizeClass(["link-btn", { active: scaleLocked.value }]),
                    onClick: _cache[13] || (_cache[13] = ($event) => scaleLocked.value = !scaleLocked.value),
                    title: "Link scale values"
                  }, " ðŸ”— ", 2),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.y,
                    "onUpdate:modelValue": [
                      _cache[14] || (_cache[14] = ($event) => transform.value.scale.y = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("scale") }]),
                  onClick: _cache[15] || (_cache[15] = ($event) => toggleKeyframe("scale"))
                }, "â—†", 2)
              ], 2),
              selectedLayer.value?.threeD ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_16$f, [
                  _cache[42] || (_cache[42] = createBaseVNode("label", null, "Orientation", -1)),
                  createBaseVNode("div", _hoisted_17$e, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationX,
                      "onUpdate:modelValue": [
                        _cache[16] || (_cache[16] = ($event) => transform.value.orientationX = $event),
                        updateTransform
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationY,
                      "onUpdate:modelValue": [
                        _cache[17] || (_cache[17] = ($event) => transform.value.orientationY = $event),
                        updateTransform
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationZ,
                      "onUpdate:modelValue": [
                        _cache[18] || (_cache[18] = ($event) => transform.value.orientationZ = $event),
                        updateTransform
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$d, [
                  _cache[43] || (_cache[43] = createBaseVNode("label", null, "X Rotation", -1)),
                  createBaseVNode("div", _hoisted_19$d, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationX,
                      "onUpdate:modelValue": [
                        _cache[19] || (_cache[19] = ($event) => transform.value.rotationX = $event),
                        updateTransform
                      ],
                      unit: "Â°"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationX") }]),
                    onClick: _cache[20] || (_cache[20] = ($event) => toggleKeyframe("rotationX"))
                  }, "â—†", 2)
                ]),
                createBaseVNode("div", _hoisted_20$d, [
                  _cache[44] || (_cache[44] = createBaseVNode("label", null, "Y Rotation", -1)),
                  createBaseVNode("div", _hoisted_21$c, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationY,
                      "onUpdate:modelValue": [
                        _cache[21] || (_cache[21] = ($event) => transform.value.rotationY = $event),
                        updateTransform
                      ],
                      unit: "Â°"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationY") }]),
                    onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("rotationY"))
                  }, "â—†", 2)
                ]),
                createBaseVNode("div", _hoisted_22$c, [
                  _cache[45] || (_cache[45] = createBaseVNode("label", null, "Z Rotation", -1)),
                  createBaseVNode("div", _hoisted_23$c, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationZ,
                      "onUpdate:modelValue": [
                        _cache[23] || (_cache[23] = ($event) => transform.value.rotationZ = $event),
                        updateTransform
                      ],
                      unit: "Â°"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotationZ") }]),
                    onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("rotationZ"))
                  }, "â—†", 2)
                ])
              ], 64)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.rotation") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.rotation",
                  linkedTo: getDriverForProperty("transform.rotation"),
                  onLink: _cache[25] || (_cache[25] = (target) => onPickwhipLink("transform.rotation", target)),
                  onUnlink: _cache[26] || (_cache[26] = () => onPickwhipUnlink("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[46] || (_cache[46] = createBaseVNode("label", null, "Rotation", -1)),
                createBaseVNode("div", _hoisted_24$a, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.rotation,
                    "onUpdate:modelValue": [
                      _cache[27] || (_cache[27] = ($event) => transform.value.rotation = $event),
                      updateTransform
                    ],
                    min: -360,
                    max: 360,
                    unit: "Â°",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("rotation") }]),
                  onClick: _cache[28] || (_cache[28] = ($event) => toggleKeyframe("rotation"))
                }, "â—†", 2)
              ], 2)),
              createBaseVNode("div", _hoisted_25$a, [
                _cache[47] || (_cache[47] = createBaseVNode("label", null, "Anchor Point", -1)),
                createBaseVNode("div", _hoisted_26$a, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      _cache[29] || (_cache[29] = ($event) => transform.value.anchorPoint.x = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      _cache[30] || (_cache[30] = ($event) => transform.value.anchorPoint.y = $event),
                      updateTransform
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("anchorPoint") }]),
                  onClick: _cache[31] || (_cache[31] = ($event) => toggleKeyframe("anchorPoint"))
                }, "â—†", 2)
              ]),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("opacity") }])
              }, [
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "opacity",
                  linkedTo: getDriverForProperty("opacity"),
                  onLink: _cache[32] || (_cache[32] = (target) => onPickwhipLink("opacity", target)),
                  onUnlink: _cache[33] || (_cache[33] = () => onPickwhipUnlink("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[48] || (_cache[48] = createBaseVNode("label", null, "Opacity", -1)),
                createBaseVNode("div", _hoisted_27$9, [
                  createVNode(unref(SliderInput), {
                    modelValue: transform.value.opacity,
                    "onUpdate:modelValue": [
                      _cache[34] || (_cache[34] = ($event) => transform.value.opacity = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": selectedLayer.value?.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                createBaseVNode("button", {
                  class: normalizeClass(["keyframe-btn", { active: hasKeyframe("opacity") }]),
                  onClick: _cache[35] || (_cache[35] = ($event) => toggleKeyframe("opacity"))
                }, "â—†", 2)
              ], 2)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_28$9, [
            createBaseVNode("div", _hoisted_29$9, [
              _cache[49] || (_cache[49] = createBaseVNode("label", null, "Blend Mode", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[36] || (_cache[36] = ($event) => blendMode.value = $event),
                class: "blend-select",
                onChange: updateBlendMode
              }, [
                (openBlock(), createElementBlock(Fragment, null, renderList(blendModes, (mode) => {
                  return createBaseVNode("option", {
                    key: mode.value,
                    value: mode.value
                  }, toDisplayString(mode.label), 9, _hoisted_30$9);
                }), 64))
              ], 544), [
                [vModelSelect, blendMode.value]
              ])
            ])
          ]),
          layerPropertiesComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(layerPropertiesComponent.value), {
            key: 0,
            layer: selectedLayer.value,
            onUpdate: onLayerUpdate
          }, null, 40, ["layer"])) : createCommentVNode("", true),
          selectedLayer.value ? (openBlock(), createBlock(DriverList, {
            key: 1,
            layerId: selectedLayer.value.id
          }, null, 8, ["layerId"])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_31$6, [..._cache[50] || (_cache[50] = [
          createBaseVNode("p", null, "No layer selected", -1),
          createBaseVNode("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
});

const PropertiesPanel = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-d2bb46b8"]]);

const DEFAULT_TRAJECTORY = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: false
};
const TRAJECTORY_PRESETS = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function applyEasing(t, easing) {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t;
    case "ease-out":
      return 1 - (1 - t) * (1 - t);
    case "ease-in-out":
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    case "bounce":
      if (t < 0.5) {
        return 8 * t * t * t * t;
      }
      const f = t - 1;
      return 1 - 8 * f * f * f * f;
    default:
      return t;
  }
}
function getTrajectoryPosition(config, t) {
  const easedT = applyEasing(t, config.easing);
  const { center, baseDistance, amplitude, loops, startPhase, type } = config;
  let position = { x: center.x, y: center.y, z: center.z - baseDistance };
  let target = { ...center };
  switch (type) {
    case "orbit":
    case "orbit_reverse": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI * Math.sign(amplitude);
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const maxAngle = Math.abs(amplitude) * Math.PI;
      const angle = Math.sin(easedT * Math.PI) * maxAngle;
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "dolly_in": {
      const distance = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "dolly_out": {
      const distance = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const panAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x + Math.sin(panAngle) * baseDistance,
        y: center.y,
        z: center.z + Math.cos(panAngle) * baseDistance - baseDistance
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const tiltAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x,
        y: center.y + Math.sin(tiltAngle) * baseDistance,
        z: center.z
      };
      break;
    }
    case "circle": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.cos(angle) * radius * 0.5,
        // Elliptical
        z: center.z - baseDistance + Math.cos(angle) * radius * 0.3
      };
      break;
    }
    case "figure8": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.sin(angle * 2) * radius * 0.3,
        z: center.z - baseDistance
      };
      break;
    }
    case "spiral_in": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "spiral_out": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      position = {
        x: center.x,
        y: center.y + easedT * amplitude,
        z: center.z - baseDistance
      };
      target = {
        x: center.x,
        y: center.y + easedT * amplitude * 0.5,
        // Target moves less
        z: center.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      position = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z - baseDistance
      };
      target = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const arcAngle = easedT * amplitude * 2 * Math.PI;
      position = {
        x: center.x + Math.sin(arcAngle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(arcAngle) * baseDistance
      };
      break;
    }
  }
  return { position, target };
}
function generateTrajectoryKeyframes(config, startFrame = 0, keyframeInterval = 5) {
  const positionKeyframes = [];
  const poiKeyframes = [];
  const zoomKeyframes = [];
  const numKeyframes = Math.ceil(config.duration / keyframeInterval) + 1;
  for (let i = 0; i < numKeyframes; i++) {
    const frame = startFrame + Math.min(i * keyframeInterval, config.duration);
    const t = Math.min(i * keyframeInterval, config.duration) / config.duration;
    const { position, target } = getTrajectoryPosition(config, t);
    positionKeyframes.push({
      frame,
      position,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    poiKeyframes.push({
      frame,
      pointOfInterest: target,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    if (config.type === "zoom_in" || config.type === "zoom_out") {
      const easedT = applyEasing(t, config.easing);
      const zoomMultiplier = config.type === "zoom_in" ? 1 + easedT * Math.abs(config.amplitude) : 1 - easedT * Math.abs(config.amplitude);
      zoomKeyframes.push({
        frame,
        zoom: 1778 * zoomMultiplier,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: positionKeyframes,
    pointOfInterest: poiKeyframes,
    zoom: zoomKeyframes.length > 0 ? zoomKeyframes : void 0
  };
}
function getTrajectoryDescription(type) {
  const descriptions = {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360Â° horizontal orbit around target",
    orbit_reverse: "360Â° reverse orbit around target",
    swing1: "Gentle pendulum swing (45Â°)",
    swing2: "Wide pendulum swing (90Â°)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  };
  return descriptions[type] || "Unknown trajectory";
}
function getTrajectoryCategory(type) {
  const categories = {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  };
  return categories[type] || "Other";
}
function getTrajectoryTypesByCategory() {
  const types = Object.keys(TRAJECTORY_PRESETS);
  const grouped = {};
  for (const type of types) {
    const category = getTrajectoryCategory(type);
    if (!grouped[category]) {
      grouped[category] = [];
    }
    grouped[category].push(type);
  }
  return grouped;
}

const _hoisted_1$m = { class: "camera-properties" };
const _hoisted_2$m = { class: "panel-header" };
const _hoisted_3$m = { class: "camera-name" };
const _hoisted_4$m = {
  key: 0,
  class: "properties-content"
};
const _hoisted_5$m = { class: "property-section" };
const _hoisted_6$m = { class: "property-row" };
const _hoisted_7$m = ["value"];
const _hoisted_8$m = { class: "property-section" };
const _hoisted_9$l = { class: "toggle-icon" };
const _hoisted_10$k = { class: "section-content" };
const _hoisted_11$j = { class: "property-group" };
const _hoisted_12$h = { class: "xyz-inputs" };
const _hoisted_13$g = {
  key: 0,
  class: "property-group"
};
const _hoisted_14$e = { class: "xyz-inputs" };
const _hoisted_15$e = { class: "property-group" };
const _hoisted_16$e = { class: "xyz-inputs" };
const _hoisted_17$d = { class: "property-group" };
const _hoisted_18$c = { class: "property-group" };
const _hoisted_19$c = { class: "property-group" };
const _hoisted_20$c = { class: "property-section" };
const _hoisted_21$b = { class: "toggle-icon" };
const _hoisted_22$b = { class: "section-content" };
const _hoisted_23$b = { class: "preset-row" };
const _hoisted_24$9 = ["onClick"];
const _hoisted_25$9 = { class: "property-group" };
const _hoisted_26$9 = { class: "property-group" };
const _hoisted_27$8 = { class: "property-group" };
const _hoisted_28$8 = { class: "property-group" };
const _hoisted_29$8 = ["value"];
const _hoisted_30$8 = { class: "property-section" };
const _hoisted_31$5 = { class: "toggle-icon" };
const _hoisted_32$5 = { class: "section-content" };
const _hoisted_33$5 = { class: "property-group checkbox-group" };
const _hoisted_34$5 = ["checked"];
const _hoisted_35$5 = { class: "property-group" };
const _hoisted_36$5 = { class: "property-group" };
const _hoisted_37$5 = { class: "property-group" };
const _hoisted_38$5 = { class: "property-group checkbox-group" };
const _hoisted_39$5 = ["checked"];
const _hoisted_40$4 = { class: "property-section" };
const _hoisted_41$3 = { class: "toggle-icon" };
const _hoisted_42$3 = { class: "section-content" };
const _hoisted_43$3 = { class: "property-group" };
const _hoisted_44$3 = { class: "property-group" };
const _hoisted_45$3 = { class: "property-group" };
const _hoisted_46$3 = { class: "property-group" };
const _hoisted_47$3 = { class: "property-group" };
const _hoisted_48$3 = { class: "property-section" };
const _hoisted_49$3 = { class: "toggle-icon" };
const _hoisted_50$2 = { class: "section-content" };
const _hoisted_51$2 = { class: "property-group" };
const _hoisted_52$2 = { class: "property-group" };
const _hoisted_53$2 = { class: "property-group" };
const _hoisted_54$2 = { class: "property-section" };
const _hoisted_55$2 = { class: "toggle-icon" };
const _hoisted_56$2 = { class: "section-content" };
const _hoisted_57$2 = { class: "property-group" };
const _hoisted_58$2 = ["value"];
const _hoisted_59$2 = { class: "property-section" };
const _hoisted_60$2 = { class: "toggle-icon" };
const _hoisted_61$2 = { class: "section-content" };
const _hoisted_62$2 = { class: "property-group" };
const _hoisted_63 = { class: "property-group" };
const _hoisted_64 = { class: "property-section" };
const _hoisted_65 = { class: "toggle-icon" };
const _hoisted_66 = { class: "section-content" };
const _hoisted_67 = { class: "property-group" };
const _hoisted_68 = ["label"];
const _hoisted_69 = ["value"];
const _hoisted_70 = { class: "trajectory-description" };
const _hoisted_71 = { class: "property-group" };
const _hoisted_72 = { class: "property-group" };
const _hoisted_73 = {
  key: 0,
  class: "property-group"
};
const _hoisted_74 = { class: "property-group" };
const _hoisted_75 = { class: "property-group checkbox-group" };
const _hoisted_76 = { class: "property-group" };
const _hoisted_77 = { class: "property-group" };
const _hoisted_78 = {
  key: 1,
  class: "no-camera"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "camera" && selectedLayer.data) {
        const cameraData = selectedLayer.data;
        return store.getCamera(cameraData.cameraId);
      }
      return store.activeCamera;
    });
    const expandedSections = reactive({
      transform: true,
      lens: true,
      dof: false,
      iris: false,
      highlight: false,
      autoOrient: false,
      clipping: false,
      trajectory: false
    });
    const trajectoryConfig = reactive({
      ...DEFAULT_TRAJECTORY
    });
    const trajectoryTypesByCategory = computed(() => getTrajectoryTypesByCategory());
    const trajectoryDescription = computed(() => getTrajectoryDescription(trajectoryConfig.type));
    const isOrbitalTrajectory = computed(() => {
      const orbitalTypes = ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"];
      return orbitalTypes.includes(trajectoryConfig.type);
    });
    function formatTrajectoryName(type) {
      return type.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    }
    const previewAnimationId = ref(null);
    function previewTrajectory() {
      if (!camera.value) return;
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
      const startTime = performance.now();
      const duration = trajectoryConfig.duration / 30 * 1e3;
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
        )
      };
      function animate() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const { position, target } = getTrajectoryPosition(config, t);
        store.updateCamera(camera.value.id, {
          position,
          pointOfInterest: target
        });
        if (t < 1) {
          previewAnimationId.value = requestAnimationFrame(animate);
        } else {
          previewAnimationId.value = null;
        }
      }
      animate();
    }
    function applyTrajectory() {
      if (!camera.value) return;
      const baseDistance = Math.sqrt(
        Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
      );
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance
      };
      const keyframes = generateTrajectoryKeyframes(config, store.currentFrame);
      for (const kf of keyframes.position) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          position: kf.position,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      for (const kf of keyframes.pointOfInterest) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          pointOfInterest: kf.pointOfInterest,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      if (keyframes.zoom) {
        for (const kf of keyframes.zoom) {
          store.addCameraKeyframe(camera.value.id, {
            frame: kf.frame,
            zoom: kf.zoom,
            temporalInterpolation: kf.temporalInterpolation
          });
        }
      }
      console.log(`Applied ${keyframes.position.length} camera trajectory keyframes`);
    }
    function toggleSection(section) {
      expandedSections[section] = !expandedSections[section];
    }
    function updateProperty(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, { [key]: value });
    }
    function updatePosition(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        position: { ...camera.value.position, [axis]: value }
      });
    }
    function updatePOI(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        pointOfInterest: { ...camera.value.pointOfInterest, [axis]: value }
      });
    }
    function updateOrientation(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        orientation: { ...camera.value.orientation, [axis]: value }
      });
    }
    function updateFocalLength(value) {
      if (!camera.value) return;
      const angleOfView = focalLengthToFOV(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        focalLength: value,
        angleOfView
      });
    }
    function updateAngleOfView(value) {
      if (!camera.value) return;
      const focalLength = fovToFocalLength(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        angleOfView: value,
        focalLength
      });
    }
    function updateDOF(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        depthOfField: { ...camera.value.depthOfField, [key]: value }
      });
    }
    function updateIris(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        iris: { ...camera.value.iris, [key]: value }
      });
    }
    function updateHighlight(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        highlight: { ...camera.value.highlight, [key]: value }
      });
    }
    function applyPreset(preset) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        focalLength: preset.focalLength,
        angleOfView: preset.angleOfView,
        zoom: preset.zoom
      });
    }
    function createCamera() {
      store.createCameraLayer();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$m, [
          _cache[47] || (_cache[47] = createBaseVNode("span", { class: "panel-title" }, "Camera", -1)),
          createBaseVNode("span", _hoisted_3$m, toDisplayString(camera.value?.name ?? "No Camera"), 1)
        ]),
        camera.value ? (openBlock(), createElementBlock("div", _hoisted_4$m, [
          createBaseVNode("div", _hoisted_5$m, [
            _cache[49] || (_cache[49] = createBaseVNode("div", { class: "section-header" }, "Type", -1)),
            createBaseVNode("div", _hoisted_6$m, [
              createBaseVNode("select", {
                value: camera.value.type,
                onChange: _cache[0] || (_cache[0] = ($event) => updateProperty("type", $event.target.value)),
                class: "type-select"
              }, [..._cache[48] || (_cache[48] = [
                createBaseVNode("option", { value: "one-node" }, "One-Node Camera", -1),
                createBaseVNode("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, _hoisted_7$m)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$m, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_9$l, toDisplayString(expandedSections.transform ? "â–¼" : "â–º"), 1),
              _cache[50] || (_cache[50] = createTextVNode(" Transform ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_10$k, [
              createBaseVNode("div", _hoisted_11$j, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_12$h, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updatePosition("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updatePosition("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.z,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updatePosition("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              camera.value.type === "two-node" ? (openBlock(), createElementBlock("div", _hoisted_13$g, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Point of Interest", -1)),
                createBaseVNode("div", _hoisted_14$e, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updatePOI("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updatePOI("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.z,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => updatePOI("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_15$e, [
                _cache[53] || (_cache[53] = createBaseVNode("label", null, "Orientation", -1)),
                createBaseVNode("div", _hoisted_16$e, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.x,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateOrientation("x", v)),
                    label: "X",
                    unit: "Â°",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.y,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateOrientation("y", v)),
                    label: "Y",
                    unit: "Â°",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.z,
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateOrientation("z", v)),
                    label: "Z",
                    unit: "Â°",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$d, [
                _cache[54] || (_cache[54] = createBaseVNode("label", null, "X Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.xRotation,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateProperty("xRotation", v)),
                  unit: "Â°",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_18$c, [
                _cache[55] || (_cache[55] = createBaseVNode("label", null, "Y Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.yRotation,
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateProperty("yRotation", v)),
                  unit: "Â°",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$c, [
                _cache[56] || (_cache[56] = createBaseVNode("label", null, "Z Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.zRotation,
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateProperty("zRotation", v)),
                  unit: "Â°",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.transform]
            ])
          ]),
          createBaseVNode("div", _hoisted_20$c, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("lens"))
            }, [
              createBaseVNode("span", _hoisted_21$b, toDisplayString(expandedSections.lens ? "â–¼" : "â–º"), 1),
              _cache[57] || (_cache[57] = createTextVNode(" Lens ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_22$b, [
              createBaseVNode("div", _hoisted_23$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(CAMERA_PRESETS), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.name,
                    class: normalizeClass({ active: Math.abs(camera.value.focalLength - preset.focalLength) < 0.5 }),
                    onClick: ($event) => applyPreset(preset)
                  }, toDisplayString(preset.name), 11, _hoisted_24$9);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_25$9, [
                _cache[58] || (_cache[58] = createBaseVNode("label", null, "Focal Length", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.focalLength,
                  "onUpdate:modelValue": updateFocalLength,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_26$9, [
                _cache[59] || (_cache[59] = createBaseVNode("label", null, "Angle of View", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.angleOfView,
                  "onUpdate:modelValue": updateAngleOfView,
                  min: 1,
                  max: 170,
                  unit: "Â°",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_27$8, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Film Size", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.filmSize,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateProperty("filmSize", v)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_28$8, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Measure Film Size", -1)),
                createBaseVNode("select", {
                  value: camera.value.measureFilmSize,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateProperty("measureFilmSize", $event.target.value))
                }, [..._cache[61] || (_cache[61] = [
                  createBaseVNode("option", { value: "horizontal" }, "Horizontal", -1),
                  createBaseVNode("option", { value: "vertical" }, "Vertical", -1),
                  createBaseVNode("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, _hoisted_29$8)
              ])
            ], 512), [
              [vShow, expandedSections.lens]
            ])
          ]),
          createBaseVNode("div", _hoisted_30$8, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[17] || (_cache[17] = ($event) => toggleSection("dof"))
            }, [
              createBaseVNode("span", _hoisted_31$5, toDisplayString(expandedSections.dof ? "â–¼" : "â–º"), 1),
              _cache[63] || (_cache[63] = createTextVNode(" Depth of Field ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_32$5, [
              createBaseVNode("div", _hoisted_33$5, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: camera.value.depthOfField.enabled,
                    onChange: _cache[18] || (_cache[18] = ($event) => updateDOF("enabled", $event.target.checked))
                  }, null, 40, _hoisted_34$5),
                  _cache[64] || (_cache[64] = createTextVNode(" Enable DOF ", -1))
                ])
              ]),
              camera.value.depthOfField.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_35$5, [
                  _cache[65] || (_cache[65] = createBaseVNode("label", null, "Focus Distance", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updateDOF("focusDistance", v)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_36$5, [
                  _cache[66] || (_cache[66] = createBaseVNode("label", null, "f-Stop", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.fStop,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateDOF("fStop", v)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_37$5, [
                  _cache[67] || (_cache[67] = createBaseVNode("label", null, "Blur Level", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: camera.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateDOF("blurLevel", v)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_38$5, [
                  createBaseVNode("label", null, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: camera.value.depthOfField.lockToZoom,
                      onChange: _cache[22] || (_cache[22] = ($event) => updateDOF("lockToZoom", $event.target.checked))
                    }, null, 40, _hoisted_39$5),
                    _cache[68] || (_cache[68] = createTextVNode(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : createCommentVNode("", true)
            ], 512), [
              [vShow, expandedSections.dof]
            ])
          ]),
          createBaseVNode("div", _hoisted_40$4, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[23] || (_cache[23] = ($event) => toggleSection("iris"))
            }, [
              createBaseVNode("span", _hoisted_41$3, toDisplayString(expandedSections.iris ? "â–¼" : "â–º"), 1),
              _cache[69] || (_cache[69] = createTextVNode(" Iris ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_42$3, [
              createBaseVNode("div", _hoisted_43$3, [
                createBaseVNode("label", null, "Shape (" + toDisplayString(Math.round(camera.value.iris.shape)) + "-gon)", 1),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.shape,
                  "onUpdate:modelValue": _cache[24] || (_cache[24] = (v) => updateIris("shape", v)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_44$3, [
                _cache[70] || (_cache[70] = createBaseVNode("label", null, "Rotation", -1)),
                createVNode(unref(AngleDial), {
                  modelValue: camera.value.iris.rotation,
                  "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateIris("rotation", v)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_45$3, [
                _cache[71] || (_cache[71] = createBaseVNode("label", null, "Roundness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.roundness,
                  "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateIris("roundness", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_46$3, [
                _cache[72] || (_cache[72] = createBaseVNode("label", null, "Aspect Ratio", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.aspectRatio,
                  "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateIris("aspectRatio", v)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_47$3, [
                _cache[73] || (_cache[73] = createBaseVNode("label", null, "Diffraction Fringe", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.diffractionFringe,
                  "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateIris("diffractionFringe", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.iris]
            ])
          ]),
          createBaseVNode("div", _hoisted_48$3, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("highlight"))
            }, [
              createBaseVNode("span", _hoisted_49$3, toDisplayString(expandedSections.highlight ? "â–¼" : "â–º"), 1),
              _cache[74] || (_cache[74] = createTextVNode(" Highlight ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_50$2, [
              createBaseVNode("div", _hoisted_51$2, [
                _cache[75] || (_cache[75] = createBaseVNode("label", null, "Gain", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.gain,
                  "onUpdate:modelValue": _cache[30] || (_cache[30] = (v) => updateHighlight("gain", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_52$2, [
                _cache[76] || (_cache[76] = createBaseVNode("label", null, "Threshold", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.threshold,
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateHighlight("threshold", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_53$2, [
                _cache[77] || (_cache[77] = createBaseVNode("label", null, "Saturation", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.saturation,
                  "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateHighlight("saturation", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.highlight]
            ])
          ]),
          createBaseVNode("div", _hoisted_54$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[33] || (_cache[33] = ($event) => toggleSection("autoOrient"))
            }, [
              createBaseVNode("span", _hoisted_55$2, toDisplayString(expandedSections.autoOrient ? "â–¼" : "â–º"), 1),
              _cache[78] || (_cache[78] = createTextVNode(" Auto-Orient ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_56$2, [
              createBaseVNode("div", _hoisted_57$2, [
                createBaseVNode("select", {
                  value: camera.value.autoOrient,
                  onChange: _cache[34] || (_cache[34] = ($event) => updateProperty("autoOrient", $event.target.value))
                }, [..._cache[79] || (_cache[79] = [
                  createBaseVNode("option", { value: "off" }, "Off", -1),
                  createBaseVNode("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  createBaseVNode("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, _hoisted_58$2)
              ])
            ], 512), [
              [vShow, expandedSections.autoOrient]
            ])
          ]),
          createBaseVNode("div", _hoisted_59$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[35] || (_cache[35] = ($event) => toggleSection("clipping"))
            }, [
              createBaseVNode("span", _hoisted_60$2, toDisplayString(expandedSections.clipping ? "â–¼" : "â–º"), 1),
              _cache[80] || (_cache[80] = createTextVNode(" Clipping ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_61$2, [
              createBaseVNode("div", _hoisted_62$2, [
                _cache[81] || (_cache[81] = createBaseVNode("label", null, "Near Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.nearClip,
                  "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateProperty("nearClip", v)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_63, [
                _cache[82] || (_cache[82] = createBaseVNode("label", null, "Far Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.farClip,
                  "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateProperty("farClip", v)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.clipping]
            ])
          ]),
          createBaseVNode("div", _hoisted_64, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[38] || (_cache[38] = ($event) => toggleSection("trajectory"))
            }, [
              createBaseVNode("span", _hoisted_65, toDisplayString(expandedSections.trajectory ? "â–¼" : "â–º"), 1),
              _cache[83] || (_cache[83] = createTextVNode(" Trajectory ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_66, [
              createBaseVNode("div", _hoisted_67, [
                _cache[84] || (_cache[84] = createBaseVNode("label", null, "Motion Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[39] || (_cache[39] = ($event) => trajectoryConfig.type = $event),
                  class: "trajectory-select"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(trajectoryTypesByCategory.value, (types, category) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: category,
                      label: category
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(types, (type) => {
                        return openBlock(), createElementBlock("option", {
                          key: type,
                          value: type
                        }, toDisplayString(formatTrajectoryName(type)), 9, _hoisted_69);
                      }), 128))
                    ], 8, _hoisted_68);
                  }), 128))
                ], 512), [
                  [vModelSelect, trajectoryConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_70, toDisplayString(trajectoryDescription.value), 1),
              createBaseVNode("div", _hoisted_71, [
                _cache[85] || (_cache[85] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.duration,
                  "onUpdate:modelValue": _cache[40] || (_cache[40] = (v) => trajectoryConfig.duration = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_72, [
                _cache[86] || (_cache[86] = createBaseVNode("label", null, "Amplitude", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: Math.abs(trajectoryConfig.amplitude),
                  "onUpdate:modelValue": _cache[41] || (_cache[41] = (v) => trajectoryConfig.amplitude = v * Math.sign(trajectoryConfig.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              isOrbitalTrajectory.value ? (openBlock(), createElementBlock("div", _hoisted_73, [
                _cache[87] || (_cache[87] = createBaseVNode("label", null, "Loops", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.loops,
                  "onUpdate:modelValue": _cache[42] || (_cache[42] = (v) => trajectoryConfig.loops = v),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_74, [
                _cache[89] || (_cache[89] = createBaseVNode("label", null, "Easing", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => trajectoryConfig.easing = $event)
                }, [..._cache[88] || (_cache[88] = [
                  createStaticVNode('<option value="linear" data-v-e0e3fe0b>Linear</option><option value="ease-in" data-v-e0e3fe0b>Ease In</option><option value="ease-out" data-v-e0e3fe0b>Ease Out</option><option value="ease-in-out" data-v-e0e3fe0b>Ease In-Out</option><option value="bounce" data-v-e0e3fe0b>Bounce</option>', 5)
                ])], 512), [
                  [vModelSelect, trajectoryConfig.easing]
                ])
              ]),
              createBaseVNode("div", _hoisted_75, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => trajectoryConfig.audioReactive = $event)
                  }, null, 512), [
                    [vModelCheckbox, trajectoryConfig.audioReactive]
                  ]),
                  _cache[90] || (_cache[90] = createTextVNode(" Audio Reactive ", -1))
                ])
              ]),
              trajectoryConfig.audioReactive ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_76, [
                  _cache[92] || (_cache[92] = createBaseVNode("label", null, "Audio Feature", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[45] || (_cache[45] = ($event) => trajectoryConfig.audioFeature = $event)
                  }, [..._cache[91] || (_cache[91] = [
                    createStaticVNode('<option value="amplitude" data-v-e0e3fe0b>Amplitude</option><option value="bass" data-v-e0e3fe0b>Bass</option><option value="mid" data-v-e0e3fe0b>Mid</option><option value="high" data-v-e0e3fe0b>High</option><option value="onsets" data-v-e0e3fe0b>Onsets</option>', 5)
                  ])], 512), [
                    [vModelSelect, trajectoryConfig.audioFeature]
                  ])
                ]),
                createBaseVNode("div", _hoisted_77, [
                  _cache[93] || (_cache[93] = createBaseVNode("label", null, "Sensitivity", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: trajectoryConfig.audioSensitivity ?? 1,
                    "onUpdate:modelValue": _cache[46] || (_cache[46] = (v) => trajectoryConfig.audioSensitivity = v),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("div", { class: "trajectory-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewTrajectory
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyTrajectory
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.trajectory]
            ])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_78, [
          _cache[94] || (_cache[94] = createBaseVNode("p", null, "No camera selected", -1)),
          createBaseVNode("button", { onClick: createCamera }, "Create Camera")
        ]))
      ]);
    };
  }
});

const CameraProperties = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-e0e3fe0b"]]);

const _hoisted_1$l = { class: "audio-properties" };
const _hoisted_2$l = { class: "property-section" };
const _hoisted_3$l = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$l = { class: "property-row" };
const _hoisted_5$l = { class: "value-display" };
const _hoisted_6$l = { class: "property-row" };
const _hoisted_7$l = { class: "value-display" };
const _hoisted_8$l = { class: "property-row" };
const _hoisted_9$k = { class: "value-display" };
const _hoisted_10$j = { class: "property-row" };
const _hoisted_11$i = {
  key: 0,
  class: "peak-count"
};
const _hoisted_12$g = { class: "property-section" };
const _hoisted_13$f = { class: "mapping-count" };
const _hoisted_14$d = {
  key: 0,
  class: "section-content"
};
const _hoisted_15$d = { class: "mapping-header" };
const _hoisted_16$d = { class: "mapping-enabled" };
const _hoisted_17$c = ["onUpdate:modelValue"];
const _hoisted_18$b = { class: "mapping-name" };
const _hoisted_19$b = ["onClick"];
const _hoisted_20$b = {
  key: 0,
  class: "mapping-details"
};
const _hoisted_21$a = { class: "property-row" };
const _hoisted_22$a = ["onUpdate:modelValue"];
const _hoisted_23$a = ["label"];
const _hoisted_24$8 = ["value"];
const _hoisted_25$8 = { class: "property-row" };
const _hoisted_26$8 = ["onUpdate:modelValue"];
const _hoisted_27$7 = ["label"];
const _hoisted_28$7 = ["value"];
const _hoisted_29$7 = { class: "property-row" };
const _hoisted_30$7 = ["onUpdate:modelValue"];
const _hoisted_31$4 = { class: "value-display" };
const _hoisted_32$4 = { class: "property-row" };
const _hoisted_33$4 = ["onUpdate:modelValue"];
const _hoisted_34$4 = { class: "value-display" };
const _hoisted_35$4 = { class: "property-row" };
const _hoisted_36$4 = ["onUpdate:modelValue"];
const _hoisted_37$4 = { class: "value-display" };
const _hoisted_38$4 = { class: "property-row" };
const _hoisted_39$4 = ["onUpdate:modelValue"];
const _hoisted_40$3 = ["onUpdate:modelValue"];
const _hoisted_41$2 = { class: "property-row" };
const _hoisted_42$2 = ["onUpdate:modelValue"];
const _hoisted_43$2 = { class: "value-display" };
const _hoisted_44$2 = { class: "property-row" };
const _hoisted_45$2 = ["onUpdate:modelValue"];
const _hoisted_46$2 = { class: "value-display" };
const _hoisted_47$2 = { class: "property-row" };
const _hoisted_48$2 = ["onUpdate:modelValue"];
const _hoisted_49$2 = { class: "property-row" };
const _hoisted_50$1 = ["onUpdate:modelValue"];
const _hoisted_51$1 = {
  key: 0,
  class: "property-row"
};
const _hoisted_52$1 = ["onUpdate:modelValue"];
const _hoisted_53$1 = { class: "value-display" };
const _hoisted_54$1 = { class: "property-row checkbox-row" };
const _hoisted_55$1 = ["onUpdate:modelValue"];
const _hoisted_56$1 = ["onClick"];
const _hoisted_57$1 = { class: "property-section" };
const _hoisted_58$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_59$1 = { class: "property-row" };
const _hoisted_60$1 = ["value"];
const _hoisted_61$1 = { class: "visualizer-canvas-container" };
const _hoisted_62$1 = { class: "visualizer-value" };
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "AudioProperties",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(/* @__PURE__ */ new Set(["peaks", "mappings"]));
    const expandedMappings = ref(/* @__PURE__ */ new Set());
    const peakConfig = ref({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    });
    const peakData = ref(null);
    const mappings = ref([]);
    const visualizerFeature = ref("amplitude");
    const visualizerCanvas = ref(null);
    const allFeatures = computed(() => getAllFeatures());
    const featuresByCategory = computed(() => getFeaturesByCategory());
    const targetsByCategory = computed(() => getTargetsByCategory());
    const playheadPosition = computed(
      () => store.currentFrame / store.frameCount * 100
    );
    const currentFeatureValue = computed(() => {
      if (!store.audioAnalysis) return 0;
      return getFeatureAtFrame(store.audioAnalysis, visualizerFeature.value, store.currentFrame);
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleMappingExpanded(id) {
      if (expandedMappings.value.has(id)) {
        expandedMappings.value.delete(id);
      } else {
        expandedMappings.value.add(id);
      }
    }
    function detectPeaks$1() {
      if (!store.audioAnalysis) return;
      const weights = store.audioAnalysis.amplitudeEnvelope;
      peakData.value = detectPeaks(weights, peakConfig.value);
      store.setPeakData(peakData.value);
    }
    function addMapping() {
      const mapping = createDefaultAudioMapping();
      mappings.value.push(mapping);
      expandedMappings.value.add(mapping.id);
      store.addAudioMapping(mapping);
    }
    function removeMapping(id) {
      const index = mappings.value.findIndex((m) => m.id === id);
      if (index >= 0) {
        mappings.value.splice(index, 1);
        expandedMappings.value.delete(id);
        store.removeAudioMapping(id);
      }
    }
    function drawVisualizer() {
      const canvas = visualizerCanvas.value;
      if (!canvas || !store.audioAnalysis) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, width, height);
      let featureData = [];
      const analysis = store.audioAnalysis;
      switch (visualizerFeature.value) {
        case "amplitude":
          featureData = analysis.amplitudeEnvelope;
          break;
        case "rms":
          featureData = analysis.rmsEnergy;
          break;
        case "spectralCentroid":
          featureData = analysis.spectralCentroid;
          break;
        case "bass":
          featureData = analysis.frequencyBands.bass;
          break;
        case "mid":
          featureData = analysis.frequencyBands.mid;
          break;
        case "high":
          featureData = analysis.frequencyBands.high;
          break;
        case "sub":
          featureData = analysis.frequencyBands.sub;
          break;
        case "lowMid":
          featureData = analysis.frequencyBands.lowMid;
          break;
        case "highMid":
          featureData = analysis.frequencyBands.highMid;
          break;
        case "spectralFlux":
          featureData = analysis.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          featureData = analysis.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          featureData = analysis.spectralRolloff || [];
          break;
        case "spectralFlatness":
          featureData = analysis.spectralFlatness || [];
          break;
        case "chromaEnergy":
          featureData = analysis.chromaFeatures?.chromaEnergy || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if (analysis.chromaFeatures?.chroma) {
            const pitchIndex = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(visualizerFeature.value);
            featureData = analysis.chromaFeatures.chroma.map((frame) => frame[pitchIndex] || 0);
          }
          break;
        case "onsets":
          featureData = new Array(analysis.frameCount).fill(0);
          for (const onset of analysis.onsets) {
            if (onset < featureData.length) featureData[onset] = 1;
          }
          break;
        case "peaks":
          if (peakData.value) {
            featureData = new Array(analysis.frameCount).fill(0);
            for (const peakIndex of peakData.value.indices) {
              if (peakIndex < featureData.length) featureData[peakIndex] = 1;
            }
          }
          break;
      }
      if (featureData.length === 0) return;
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < featureData.length; i++) {
        const x = i / featureData.length * width;
        const y = height - featureData[i] * height * 0.9 - 5;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      if (peakData.value && visualizerFeature.value !== "peaks") {
        ctx.fillStyle = "#ff6b6b";
        for (const peakIndex of peakData.value.indices) {
          const x = peakIndex / featureData.length * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.strokeStyle = "rgba(255, 107, 107, 0.3)";
          ctx.stroke();
        }
      }
    }
    watch(
      () => [store.audioAnalysis, visualizerFeature.value, peakData.value],
      () => {
        drawVisualizer();
      }
    );
    watch(
      mappings,
      (newMappings) => {
        for (const mapping of newMappings) {
          store.updateAudioMapping(mapping.id, mapping);
        }
      },
      { deep: true }
    );
    onMounted(() => {
      drawVisualizer();
      const existingMappings = store.getAudioMappings();
      if (existingMappings.length > 0) {
        mappings.value = [...existingMappings];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", _hoisted_2$l, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("peaks"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[7] || (_cache[7] = createBaseVNode("span", null, "Peak Detection", -1))
          ]),
          expandedSections.value.has("peaks") ? (openBlock(), createElementBlock("div", _hoisted_3$l, [
            createBaseVNode("div", _hoisted_4$l, [
              _cache[8] || (_cache[8] = createBaseVNode("label", null, "Threshold", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => peakConfig.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.01"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.threshold,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_5$l, toDisplayString(peakConfig.value.threshold.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_6$l, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Min Peak Distance", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => peakConfig.value.minPeaksDistance = $event),
                min: "1",
                max: "60",
                step: "1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.minPeaksDistance,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_7$l, toDisplayString(peakConfig.value.minPeaksDistance) + " frames", 1)
            ]),
            createBaseVNode("div", _hoisted_8$l, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Multiply", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => peakConfig.value.multiply = $event),
                min: "0.1",
                max: "5",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.multiply,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$k, toDisplayString(peakConfig.value.multiply.toFixed(1)) + "x", 1)
            ]),
            createBaseVNode("div", _hoisted_10$j, [
              createBaseVNode("button", {
                class: "action-btn",
                onClick: detectPeaks$1
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("i", { class: "pi pi-bolt" }, null, -1),
                createTextVNode(" Detect Peaks ", -1)
              ])]),
              peakData.value ? (openBlock(), createElementBlock("span", _hoisted_11$i, toDisplayString(peakData.value.count) + " peaks found ", 1)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_12$g, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[4] || (_cache[4] = ($event) => toggleSection("mappings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[12] || (_cache[12] = createBaseVNode("span", null, "Audio Mappings", -1)),
            createBaseVNode("span", _hoisted_13$f, toDisplayString(mappings.value.length), 1)
          ]),
          expandedSections.value.has("mappings") ? (openBlock(), createElementBlock("div", _hoisted_14$d, [
            createBaseVNode("button", {
              class: "action-btn add-mapping-btn",
              onClick: addMapping
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
              createTextVNode(" Add Mapping ", -1)
            ])]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(mappings.value, (mapping) => {
              return openBlock(), createElementBlock("div", {
                key: mapping.id,
                class: "mapping-item"
              }, [
                createBaseVNode("div", _hoisted_15$d, [
                  createBaseVNode("label", _hoisted_16$d, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ($event) => mapping.enabled = $event
                    }, null, 8, _hoisted_17$c), [
                      [vModelCheckbox, mapping.enabled]
                    ])
                  ]),
                  createBaseVNode("span", _hoisted_18$b, toDisplayString(unref(getFeatureDisplayName)(mapping.feature)) + " â†’ " + toDisplayString(unref(getTargetDisplayName)(mapping.target)), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: ($event) => removeMapping(mapping.id)
                  }, [..._cache[14] || (_cache[14] = [
                    createBaseVNode("i", { class: "pi pi-times" }, null, -1)
                  ])], 8, _hoisted_19$b)
                ]),
                expandedMappings.value.has(mapping.id) ? (openBlock(), createElementBlock("div", _hoisted_20$b, [
                  createBaseVNode("div", _hoisted_21$a, [
                    _cache[15] || (_cache[15] = createBaseVNode("label", null, "Feature", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.feature = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(featuresByCategory.value, (feats, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(feats, (feat) => {
                            return openBlock(), createElementBlock("option", {
                              key: feat,
                              value: feat
                            }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_24$8);
                          }), 128))
                        ], 8, _hoisted_23$a);
                      }), 128))
                    ], 8, _hoisted_22$a), [
                      [vModelSelect, mapping.feature]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_25$8, [
                    _cache[16] || (_cache[16] = createBaseVNode("label", null, "Target", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.target = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targetsByCategory.value, (targets, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                            return openBlock(), createElementBlock("option", {
                              key: target,
                              value: target
                            }, toDisplayString(unref(getTargetDisplayName)(target)), 9, _hoisted_28$7);
                          }), 128))
                        ], 8, _hoisted_27$7);
                      }), 128))
                    ], 8, _hoisted_26$8), [
                      [vModelSelect, mapping.target]
                    ])
                  ]),
                  _cache[30] || (_cache[30] = createBaseVNode("div", { class: "subsection-header" }, "Basic Controls", -1)),
                  createBaseVNode("div", _hoisted_29$7, [
                    _cache[17] || (_cache[17] = createBaseVNode("label", null, "Sensitivity", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.sensitivity = $event,
                      min: "0.1",
                      max: "5",
                      step: "0.1"
                    }, null, 8, _hoisted_30$7), [
                      [
                        vModelText,
                        mapping.sensitivity,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_31$4, toDisplayString(mapping.sensitivity.toFixed(1)) + "x", 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$4, [
                    _cache[18] || (_cache[18] = createBaseVNode("label", null, "Threshold", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.threshold = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_33$4), [
                      [
                        vModelText,
                        mapping.threshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_34$4, toDisplayString(mapping.threshold.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$4, [
                    _cache[19] || (_cache[19] = createBaseVNode("label", null, "Smoothing", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.smoothing = $event,
                      min: "0",
                      max: "0.99",
                      step: "0.01"
                    }, null, 8, _hoisted_36$4), [
                      [
                        vModelText,
                        mapping.smoothing,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_37$4, toDisplayString(mapping.smoothing.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$4, [
                    _cache[20] || (_cache[20] = createBaseVNode("label", null, "Min/Max", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.min = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_39$4), [
                      [
                        vModelText,
                        mapping.min,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "separator" }, "-", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.max = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_40$3), [
                      [
                        vModelText,
                        mapping.max,
                        void 0,
                        { number: true }
                      ]
                    ])
                  ]),
                  _cache[31] || (_cache[31] = createBaseVNode("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                  createBaseVNode("div", _hoisted_41$2, [
                    _cache[22] || (_cache[22] = createBaseVNode("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.amplitudeCurve = $event,
                      min: "0.1",
                      max: "4",
                      step: "0.1"
                    }, null, 8, _hoisted_42$2), [
                      [
                        vModelText,
                        mapping.amplitudeCurve,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_43$2, toDisplayString(mapping.amplitudeCurve?.toFixed(1) || "1.0"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$2, [
                    _cache[23] || (_cache[23] = createBaseVNode("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.release = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_45$2), [
                      [
                        vModelText,
                        mapping.release,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_46$2, toDisplayString(mapping.release?.toFixed(2) || "0.50"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$2, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", null, "Curve", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.curve = $event,
                      class: "curve-select"
                    }, [..._cache[24] || (_cache[24] = [
                      createStaticVNode('<option value="linear" data-v-0611c34c>Linear</option><option value="exponential" data-v-0611c34c>Exponential</option><option value="logarithmic" data-v-0611c34c>Logarithmic</option><option value="smoothstep" data-v-0611c34c>Smoothstep</option><option value="bounce" data-v-0611c34c>Bounce</option>', 5)
                    ])], 8, _hoisted_48$2), [
                      [vModelSelect, mapping.curve]
                    ])
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("div", { class: "subsection-header" }, "Beat Response", -1)),
                  createBaseVNode("div", _hoisted_49$2, [
                    _cache[27] || (_cache[27] = createBaseVNode("label", null, "On Beat", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.beatResponse = $event,
                      class: "beat-select"
                    }, [..._cache[26] || (_cache[26] = [
                      createBaseVNode("option", { value: "none" }, "None", -1),
                      createBaseVNode("option", { value: "flip" }, "Flip (reverse direction)", -1),
                      createBaseVNode("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                      createBaseVNode("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                    ])], 8, _hoisted_50$1), [
                      [vModelSelect, mapping.beatResponse]
                    ])
                  ]),
                  mapping.beatResponse !== "none" ? (openBlock(), createElementBlock("div", _hoisted_51$1, [
                    _cache[28] || (_cache[28] = createBaseVNode("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.beatThreshold = $event,
                      min: "0.01",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_52$1), [
                      [
                        vModelText,
                        mapping.beatThreshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_53$1, toDisplayString(mapping.beatThreshold?.toFixed(2) || "0.50"), 1)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_54$1, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": ($event) => mapping.invert = $event
                      }, null, 8, _hoisted_55$1), [
                        [vModelCheckbox, mapping.invert]
                      ]),
                      _cache[29] || (_cache[29] = createTextVNode(" Invert Output ", -1))
                    ])
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  class: "expand-btn",
                  onClick: ($event) => toggleMappingExpanded(mapping.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedMappings.value.has(mapping.id) ? "pi-chevron-up" : "pi-chevron-down"])
                  }, null, 2)
                ], 8, _hoisted_56$1)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_57$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("visualizer"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Feature Visualizer", -1))
          ]),
          expandedSections.value.has("visualizer") ? (openBlock(), createElementBlock("div", _hoisted_58$1, [
            createBaseVNode("div", _hoisted_59$1, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Feature", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => visualizerFeature.value = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allFeatures.value, (feat) => {
                  return openBlock(), createElementBlock("option", {
                    key: feat,
                    value: feat
                  }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_60$1);
                }), 128))
              ], 512), [
                [vModelSelect, visualizerFeature.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_61$1, [
              createBaseVNode("canvas", {
                ref_key: "visualizerCanvas",
                ref: visualizerCanvas,
                class: "visualizer-canvas",
                width: "240",
                height: "60"
              }, null, 512),
              createBaseVNode("div", {
                class: "visualizer-playhead",
                style: normalizeStyle({ left: `${playheadPosition.value}%` })
              }, null, 4)
            ]),
            createBaseVNode("div", _hoisted_62$1, " Current: " + toDisplayString(currentFeatureValue.value.toFixed(3)), 1)
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AudioProperties = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-0611c34c"]]);

const _hoisted_1$k = { class: "audio-panel" };
const _hoisted_2$k = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$k = { class: "audio-info" };
const _hoisted_4$k = { class: "file-info" };
const _hoisted_5$k = { class: "file-details" };
const _hoisted_6$k = { class: "file-name" };
const _hoisted_7$k = { class: "file-meta" };
const _hoisted_8$k = { class: "control-section" };
const _hoisted_9$j = { class: "control-row" };
const _hoisted_10$i = { class: "waveform-section" };
const _hoisted_11$h = { class: "waveform-display" };
const _hoisted_12$f = { class: "linker-section" };
const _hoisted_13$e = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "AudioPanel",
  setup(__props) {
    const store = useCompositorStore();
    const audioFileInput = ref(null);
    const waveformCanvas = ref(null);
    const masterVolume = computed({
      get: () => store.audioVolume,
      set: (val) => store.setAudioVolume(val)
    });
    const isMuted = computed({
      get: () => store.audioMuted,
      set: (val) => store.setAudioMuted(val)
    });
    const hasAudio = computed(() => !!store.audioBuffer);
    const audioFileName = computed(() => store.audioFile?.name || "Unknown");
    const audioSampleRate = computed(() => store.audioBuffer ? `${(store.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "");
    const audioDuration = computed(() => {
      if (!store.audioBuffer) return "0:00";
      const m = Math.floor(store.audioBuffer.duration / 60);
      const s = Math.floor(store.audioBuffer.duration % 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    });
    function loadAudioFile() {
      audioFileInput.value?.click();
    }
    async function handleAudioFileSelected(e) {
      const input = e.target;
      if (input.files?.length) await store.loadAudio(input.files[0]);
      input.value = "";
    }
    function removeAudio() {
      store.clearAudio();
    }
    function toggleMute() {
      store.toggleAudioMute();
    }
    function drawWaveform() {
      if (!waveformCanvas.value || !store.audioBuffer) return;
      const canvas = waveformCanvas.value;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 60 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      const data = store.audioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / rect.width);
      const amp = 30;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, rect.width, 60);
      ctx.beginPath();
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1;
      for (let i = 0; i < rect.width; i++) {
        let min = 1;
        let max = -1;
        for (let j = 0; j < step; j++) {
          const datum = data[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.stroke();
      const px = store.currentFrame / store.frameCount * rect.width;
      ctx.fillStyle = "#fff";
      ctx.fillRect(px, 0, 1, 60);
    }
    watch(() => [store.audioBuffer, store.currentFrame], drawWaveform);
    onMounted(() => {
      if (hasAudio.value) {
        setTimeout(drawWaveform, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("div", { class: "panel-header" }, [
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "panel-title" }, "Audio Source", -1)),
          createBaseVNode("div", { class: "header-actions" }, [
            createBaseVNode("button", {
              onClick: loadAudioFile,
              title: "Load Audio"
            }, [..._cache[1] || (_cache[1] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ“", -1)
            ])])
          ])
        ]),
        hasAudio.value ? (openBlock(), createElementBlock("div", _hoisted_2$k, [
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("div", _hoisted_4$k, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "file-icon" }, "ðŸŽµ", -1)),
              createBaseVNode("div", _hoisted_5$k, [
                createBaseVNode("span", _hoisted_6$k, toDisplayString(audioFileName.value), 1),
                createBaseVNode("span", _hoisted_7$k, toDisplayString(audioDuration.value) + " â€¢ " + toDisplayString(audioSampleRate.value), 1)
              ]),
              createBaseVNode("button", {
                class: "remove-btn",
                onClick: removeAudio,
                title: "Remove Audio"
              }, "Ã—")
            ])
          ]),
          createBaseVNode("div", _hoisted_8$k, [
            createBaseVNode("div", _hoisted_9$j, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Master Vol", -1)),
              createVNode(unref(SliderInput), {
                modelValue: masterVolume.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => masterVolume.value = $event),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["mute-btn", { active: isMuted.value }]),
                onClick: toggleMute,
                title: "Mute"
              }, toDisplayString(isMuted.value ? "ðŸ”‡" : "ðŸ”Š"), 3)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$i, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Waveform")
            ], -1)),
            createBaseVNode("div", _hoisted_11$h, [
              createBaseVNode("canvas", {
                ref_key: "waveformCanvas",
                ref: waveformCanvas,
                class: "waveform-canvas"
              }, null, 512)
            ])
          ]),
          createBaseVNode("div", _hoisted_12$f, [
            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "linker-header" }, "Audio Linker", -1)),
            createVNode(AudioProperties)
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_13$e, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "empty-icon" }, "ðŸŽµ", -1)),
          _cache[8] || (_cache[8] = createBaseVNode("p", null, "No audio loaded", -1)),
          createBaseVNode("button", {
            class: "load-btn",
            onClick: loadAudioFile
          }, "Load Audio File"),
          _cache[9] || (_cache[9] = createBaseVNode("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
        ])),
        createBaseVNode("input", {
          ref_key: "audioFileInput",
          ref: audioFileInput,
          type: "file",
          accept: "audio/*",
          style: { "display": "none" },
          onChange: handleAudioFileSelected
        }, null, 544)
      ]);
    };
  }
});

const AudioPanel = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-a7c33cfc"]]);

class SVGExtrusionService {
  svgLoader;
  documentCache = /* @__PURE__ */ new Map();
  meshCache = /* @__PURE__ */ new Map();
  constructor() {
    this.svgLoader = new SVGLoader();
  }
  // ==========================================================================
  // SVG LOADING AND PARSING
  // ==========================================================================
  /**
   * Load and parse an SVG file from URL
   */
  async loadFromURL(url, name) {
    return new Promise((resolve, reject) => {
      this.svgLoader.load(
        url,
        (data) => {
          const doc = this.parseSVGResult(data, name || url);
          this.documentCache.set(doc.id, doc);
          resolve(doc);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load and parse SVG from string content
   */
  loadFromString(svgString, name = "svg") {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
    const svgElement = svgDoc.querySelector("svg");
    if (!svgElement) {
      throw new Error("Invalid SVG: No SVG element found");
    }
    const data = this.svgLoader.parse(svgString);
    const doc = this.parseSVGResult(data, name);
    this.documentCache.set(doc.id, doc);
    return doc;
  }
  /**
   * Parse SVGLoader result into our format
   */
  parseSVGResult(data, name) {
    const id = `svg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const paths = [];
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    data.paths.forEach((shapePath, index) => {
      const shapes = SVGLoader.createShapes(shapePath);
      if (shapes.length === 0) return;
      const fillColor = shapePath.userData?.style?.fill;
      const color = new Color(
        fillColor && fillColor !== "none" ? fillColor : "#ffffff"
      );
      const fillOpacity = shapePath.userData?.style?.fillOpacity ?? 1;
      const strokeColor = shapePath.userData?.style?.stroke;
      const strokeWidth = shapePath.userData?.style?.strokeWidth ?? 0;
      const pathBounds = this.calculatePathBounds(shapes);
      minX = Math.min(minX, pathBounds.minX);
      minY = Math.min(minY, pathBounds.minY);
      maxX = Math.max(maxX, pathBounds.maxX);
      maxY = Math.max(maxY, pathBounds.maxY);
      paths.push({
        id: `${id}_path_${index}`,
        name: `Path ${index + 1}`,
        path: shapePath,
        shapes,
        color,
        fillOpacity,
        strokeColor: strokeColor && strokeColor !== "none" ? new Color(strokeColor) : null,
        strokeWidth,
        bounds: pathBounds,
        originalTransform: new Matrix4()
      });
    });
    const viewBox = {
      x: 0,
      y: 0,
      width: maxX - minX,
      height: maxY - minY
    };
    return {
      id,
      name,
      paths,
      viewBox,
      bounds: {
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  }
  /**
   * Calculate bounds for a set of shapes
   */
  calculatePathBounds(shapes) {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    for (const shape of shapes) {
      const points = shape.getPoints(50);
      for (const point of points) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
      for (const hole of shape.holes) {
        const holePoints = hole.getPoints(50);
        for (const point of holePoints) {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }
      }
    }
    const width = maxX - minX;
    const height = maxY - minY;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width,
      height,
      centerX: minX + width / 2,
      centerY: minY + height / 2
    };
  }
  // ==========================================================================
  // EXTRUSION
  // ==========================================================================
  /**
   * Create extruded geometry from an SVG path
   */
  createExtrudedGeometry(path, config = {}) {
    const cacheKey = `${path.id}_${JSON.stringify(config)}`;
    const cached = this.meshCache.get(cacheKey);
    if (cached) return cached.clone();
    const extrudeSettings = {
      depth: config.depth ?? 10,
      bevelEnabled: config.bevelEnabled ?? false,
      bevelThickness: config.bevelThickness ?? 1,
      bevelSize: config.bevelSize ?? 0.5,
      bevelOffset: config.bevelOffset ?? 0,
      bevelSegments: config.bevelSegments ?? 3,
      curveSegments: config.curveSegments ?? 12,
      steps: config.steps ?? 1
    };
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ExtrudeGeometry(shape, extrudeSettings);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    finalGeometry.computeVertexNormals();
    this.meshCache.set(cacheKey, finalGeometry);
    return finalGeometry.clone();
  }
  /**
   * Create a flat (2D) geometry from SVG path
   */
  createFlatGeometry(path) {
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ShapeGeometry(shape);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    return finalGeometry;
  }
  /**
   * Merge multiple geometries into one
   */
  mergeGeometries(geometries) {
    let totalVertices = 0;
    let totalIndices = 0;
    let hasNormals = true;
    let hasUVs = true;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      if (pos) totalVertices += pos.count;
      const idx = geom.getIndex();
      if (idx) totalIndices += idx.count;
      else totalIndices += pos?.count ?? 0;
      if (!geom.getAttribute("normal")) hasNormals = false;
      if (!geom.getAttribute("uv")) hasUVs = false;
    }
    const positions = new Float32Array(totalVertices * 3);
    const normals = hasNormals ? new Float32Array(totalVertices * 3) : null;
    const uvs = hasUVs ? new Float32Array(totalVertices * 2) : null;
    const indices = new Uint32Array(totalIndices);
    let vertexOffset = 0;
    let indexOffset = 0;
    let indexVertexOffset = 0;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      const norm = geom.getAttribute("normal");
      const uv = geom.getAttribute("uv");
      const idx = geom.getIndex();
      if (pos) {
        positions.set(pos.array, vertexOffset * 3);
        if (normals && norm) {
          normals.set(norm.array, vertexOffset * 3);
        }
        if (uvs && uv) {
          uvs.set(uv.array, vertexOffset * 2);
        }
        if (idx) {
          for (let i = 0; i < idx.count; i++) {
            indices[indexOffset + i] = idx.getX(i) + indexVertexOffset;
          }
          indexOffset += idx.count;
        } else {
          for (let i = 0; i < pos.count; i++) {
            indices[indexOffset + i] = i + indexVertexOffset;
          }
          indexOffset += pos.count;
        }
        indexVertexOffset += pos.count;
        vertexOffset += pos.count;
      }
    }
    const merged = new BufferGeometry();
    merged.setAttribute("position", new BufferAttribute(positions, 3));
    if (normals) {
      merged.setAttribute("normal", new BufferAttribute(normals, 3));
    }
    if (uvs) {
      merged.setAttribute("uv", new BufferAttribute(uvs, 2));
    }
    merged.setIndex(new BufferAttribute(indices, 1));
    return merged;
  }
  // ==========================================================================
  // MESH CREATION
  // ==========================================================================
  /**
   * Create a 3D mesh from extruded SVG path
   */
  createMesh(path, extrusionConfig = {}, materialConfig = {}) {
    const geometry = this.createExtrudedGeometry(path, extrusionConfig);
    const material = this.createMaterial(path, materialConfig);
    const mesh = new Mesh(geometry, material);
    mesh.name = path.name;
    mesh.userData.svgPathId = path.id;
    return mesh;
  }
  /**
   * Create material for extruded mesh
   */
  createMaterial(path, config = {}) {
    const type = config.type ?? "standard";
    const color = config.color ?? `#${path.color.getHexString()}`;
    const side = this.getSide(config.side ?? "double");
    const baseParams = {
      color: new Color(color),
      transparent: config.transparent ?? path.fillOpacity < 1,
      opacity: config.opacity ?? path.fillOpacity,
      side
    };
    switch (type) {
      case "basic":
        return new MeshBasicMaterial(baseParams);
      case "physical":
        return new MeshPhysicalMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
      case "standard":
      default:
        return new MeshStandardMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
    }
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  // ==========================================================================
  // LAYER CREATION (LOGO WORKFLOW)
  // ==========================================================================
  /**
   * Create multiple layers from an SVG document for depth stacking
   * This is the main entry point for the logo workflow
   */
  createLayeredMeshes(document, layerConfigs) {
    const group = new Group();
    group.name = document.name;
    const centerX = document.bounds.minX + document.bounds.width / 2;
    const centerY = document.bounds.minY + document.bounds.height / 2;
    for (const config of layerConfigs) {
      const path = document.paths.find((p) => p.id === config.pathId);
      if (!path) continue;
      const mesh = this.createMesh(
        path,
        { depth: config.extrusionDepth },
        config.material
      );
      mesh.scale.setScalar(config.scale);
      mesh.position.set(
        config.position.x - centerX * config.scale,
        config.position.y + centerY * config.scale,
        // Flip Y
        config.position.z + config.depth
      );
      mesh.rotation.set(
        config.rotation.x * (Math.PI / 180),
        config.rotation.y * (Math.PI / 180),
        config.rotation.z * (Math.PI / 180)
      );
      group.add(mesh);
    }
    return group;
  }
  /**
   * Auto-generate layer configs for all paths in a document
   * Assigns incrementing depths to each path
   */
  generateAutoLayerConfigs(document, baseDepth = 0, depthIncrement = 5, extrusionDepth = 2) {
    return document.paths.map((path, index) => ({
      pathId: path.id,
      depth: baseDepth + index * depthIncrement,
      extrusionDepth,
      scale: 1,
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0, z: 0 },
      material: {
        type: "standard",
        color: `#${path.color.getHexString()}`,
        metalness: 0,
        roughness: 0.5,
        emissive: "#000000",
        emissiveIntensity: 0,
        opacity: path.fillOpacity,
        transparent: path.fillOpacity < 1,
        side: "double"
      }
    }));
  }
  // ==========================================================================
  // PARTICLE MESH GENERATION
  // ==========================================================================
  /**
   * Create a particle-ready mesh from SVG path
   * Optimized for instanced rendering
   */
  createParticleMesh(path, config = {}) {
    const extrusionDepth = config.extrusionDepth ?? 1;
    const scale = config.scale ?? 1;
    let geometry = this.createExtrudedGeometry(path, {
      depth: extrusionDepth,
      bevelEnabled: false,
      curveSegments: config.simplify ? 6 : 12
    });
    if (config.simplify) {
      geometry = this.simplifyGeometry(
        geometry,
        config.simplifyTolerance ?? 0.1
      );
    }
    if (config.centerOrigin !== false) {
      geometry.computeBoundingBox();
      const center = new Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);
    }
    if (scale !== 1) {
      geometry.scale(scale, scale, scale);
    }
    geometry.computeVertexNormals();
    return geometry;
  }
  /**
   * Simple geometry simplification (reduces vertex count)
   */
  simplifyGeometry(geometry, tolerance) {
    const position = geometry.getAttribute("position");
    const index = geometry.getIndex();
    if (!position) return geometry;
    const vertices = /* @__PURE__ */ new Map();
    const newPositions = [];
    const newIndices = [];
    const indexMap = /* @__PURE__ */ new Map();
    const roundToTolerance = (v) => Math.round(v / tolerance) * tolerance;
    for (let i = 0; i < position.count; i++) {
      const x = roundToTolerance(position.getX(i));
      const y = roundToTolerance(position.getY(i));
      const z = roundToTolerance(position.getZ(i));
      const key = `${x},${y},${z}`;
      if (!vertices.has(key)) {
        vertices.set(key, newPositions.length / 3);
        newPositions.push(x, y, z);
      }
      indexMap.set(i, vertices.get(key));
    }
    if (index) {
      for (let i = 0; i < index.count; i++) {
        const oldIdx = index.getX(i);
        newIndices.push(indexMap.get(oldIdx));
      }
    } else {
      for (let i = 0; i < position.count; i++) {
        newIndices.push(indexMap.get(i));
      }
    }
    const simplified = new BufferGeometry();
    simplified.setAttribute(
      "position",
      new Float32BufferAttribute(newPositions, 3)
    );
    simplified.setIndex(newIndices);
    simplified.computeVertexNormals();
    return simplified;
  }
  // ==========================================================================
  // STROKE/OUTLINE GEOMETRY
  // ==========================================================================
  /**
   * Create tube geometry from SVG stroke
   * Useful for neon-style effects or 3D outlines
   */
  createStrokeGeometry(path, tubeRadius = 1, tubularSegments = 64, radialSegments = 8) {
    const geometries = [];
    for (const shape of path.shapes) {
      const points = shape.getPoints(tubularSegments);
      const points3D = points.map((p) => new Vector3(p.x, -p.y, 0));
      const curve = new CatmullRomCurve3(points3D);
      const tubeGeometry = new TubeGeometry(
        curve,
        tubularSegments,
        tubeRadius,
        radialSegments,
        false
        // closed
      );
      geometries.push(tubeGeometry);
    }
    return geometries;
  }
  // ==========================================================================
  // UTILITY METHODS
  // ==========================================================================
  /**
   * Get cached document
   */
  getDocument(id) {
    return this.documentCache.get(id);
  }
  /**
   * Get all cached documents
   */
  getAllDocuments() {
    return Array.from(this.documentCache.values());
  }
  /**
   * Clear caches
   */
  clearCache() {
    this.documentCache.clear();
    for (const geometry of this.meshCache.values()) {
      geometry.dispose();
    }
    this.meshCache.clear();
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.clearCache();
  }
}
const svgExtrusionService = new SVGExtrusionService();

class MeshParticleManager {
  /** Registered mesh particles */
  meshRegistry = /* @__PURE__ */ new Map();
  /** Instanced mesh renderers */
  instancedMeshes = /* @__PURE__ */ new Map();
  /** Default material for mesh particles */
  defaultMaterial;
  /** Texture loader for thumbnails */
  textureLoader;
  constructor() {
    this.defaultMaterial = new MeshStandardMaterial({
      color: 16777215,
      metalness: 0,
      roughness: 0.5,
      side: DoubleSide
    });
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // MESH REGISTRATION
  // ==========================================================================
  /**
   * Register a mesh for use as particles
   */
  registerMesh(id, name, geometry, source, config) {
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();
    const registration = {
      id,
      name,
      source,
      geometry,
      boundingBox: geometry.boundingBox.clone(),
      boundingSphere: geometry.boundingSphere.clone(),
      vertexCount: geometry.getAttribute("position")?.count ?? 0,
      faceCount: geometry.index ? geometry.index.count / 3 : (geometry.getAttribute("position")?.count ?? 0) / 3,
      config
    };
    this.meshRegistry.set(id, registration);
    return registration;
  }
  /**
   * Register mesh from SVG path
   */
  registerFromSVG(svgDocumentId, svgPathId, name, options = {}) {
    const document2 = svgExtrusionService.getDocument(svgDocumentId);
    if (!document2) {
      console.warn(`SVG document not found: ${svgDocumentId}`);
      return null;
    }
    const path = document2.paths.find((p) => p.id === svgPathId);
    if (!path) {
      console.warn(`SVG path not found: ${svgPathId}`);
      return null;
    }
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: svgPathId
    });
    const id = `svg_particle_${svgDocumentId}_${svgPathId}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgDocumentId,
      svgPathId,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register mesh from parsed SVG path directly
   */
  registerFromSVGPath(path, name, options = {}) {
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: path.id
    });
    const id = `svg_particle_${path.id}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgPathId: path.id,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register a primitive shape as mesh particle
   */
  registerPrimitive(type, name, size = 1, detail = 1) {
    let geometry;
    switch (type) {
      case "cube":
        geometry = new BoxGeometry(size, size, size);
        break;
      case "sphere":
        geometry = new SphereGeometry(size / 2, 8 * detail, 6 * detail);
        break;
      case "cone":
        geometry = new ConeGeometry(size / 2, size, 8 * detail);
        break;
      case "cylinder":
        geometry = new CylinderGeometry(size / 2, size / 2, size, 8 * detail);
        break;
      case "torus":
        geometry = new TorusGeometry(size / 2, size / 6, 8 * detail, 12 * detail);
        break;
      case "tetrahedron":
        geometry = new TetrahedronGeometry(size / 2, detail - 1);
        break;
      case "octahedron":
        geometry = new OctahedronGeometry(size / 2, detail - 1);
        break;
      case "icosahedron":
        geometry = new IcosahedronGeometry(size / 2, detail - 1);
        break;
      default:
        geometry = new BoxGeometry(size, size, size);
    }
    const id = `primitive_${type}_${size}_${detail}`;
    const displayName = name ?? `${type?.charAt(0).toUpperCase()}${type?.slice(1)}`;
    return this.registerMesh(id, displayName, geometry, "primitive", {
      source: "primitive",
      primitiveType: type,
      primitiveSize: size,
      primitiveDetail: detail,
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0
    });
  }
  /**
   * Register a custom geometry
   */
  registerCustom(id, name, geometry, config) {
    return this.registerMesh(id, name, geometry, "custom", {
      source: "custom",
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0,
      ...config
    });
  }
  // ==========================================================================
  // INSTANCED MESH RENDERING
  // ==========================================================================
  /**
   * Create an instanced mesh for particle rendering
   */
  createInstancedMesh(meshId, maxInstances, material) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) {
      console.warn(`Mesh not found: ${meshId}`);
      return null;
    }
    const mat = material ?? this.createMaterialForMesh(registration);
    const instancedMesh = new InstancedMesh(
      registration.geometry,
      mat,
      maxInstances
    );
    instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);
    instancedMesh.count = 0;
    instancedMesh.frustumCulled = false;
    const instance = {
      mesh: instancedMesh,
      maxInstances,
      activeInstances: 0,
      geometry: registration.geometry,
      material: mat
    };
    this.instancedMeshes.set(meshId, instance);
    return instance;
  }
  /**
   * Update instanced mesh with particle data
   * @param meshId - Registered mesh ID
   * @param particles - Array of particle transforms
   */
  updateInstancedMesh(meshId, particles) {
    const instance = this.instancedMeshes.get(meshId);
    if (!instance) return;
    const matrix = new Matrix4();
    const quaternion = new Quaternion();
    const scaleVec = new Vector3();
    const count = Math.min(particles.length, instance.maxInstances);
    instance.mesh.count = count;
    instance.activeInstances = count;
    for (let i = 0; i < count; i++) {
      const p = particles[i];
      if (p.rotation instanceof Euler) {
        quaternion.setFromEuler(p.rotation);
      } else {
        quaternion.copy(p.rotation);
      }
      if (typeof p.scale === "number") {
        scaleVec.set(p.scale, p.scale, p.scale);
      } else {
        scaleVec.copy(p.scale);
      }
      matrix.compose(p.position, quaternion, scaleVec);
      instance.mesh.setMatrixAt(i, matrix);
      if (p.color && instance.mesh.instanceColor) {
        instance.mesh.setColorAt(i, p.color);
      }
    }
    instance.mesh.instanceMatrix.needsUpdate = true;
    if (instance.mesh.instanceColor) {
      instance.mesh.instanceColor.needsUpdate = true;
    }
  }
  /**
   * Create default material for a mesh
   */
  createMaterialForMesh(registration) {
    const config = registration.config;
    if (!config) {
      return this.defaultMaterial.clone();
    }
    return new MeshStandardMaterial({
      color: new Color(config.color ?? "#ffffff"),
      metalness: config.metalness ?? 0,
      roughness: config.roughness ?? 0.5,
      emissive: new Color(config.emissive ?? "#000000"),
      emissiveIntensity: config.emissiveIntensity ?? 0,
      side: DoubleSide
    });
  }
  // ==========================================================================
  // EMITTER INTEGRATION
  // ==========================================================================
  /**
   * Get EmitterShapeConfig for mesh emission
   * Particles emit from mesh vertices
   */
  getEmitterShapeConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const position = registration.geometry.getAttribute("position");
    const normal = registration.geometry.getAttribute("normal");
    if (!position) return null;
    const vertices = new Float32Array(position.array);
    const normals = normal ? new Float32Array(normal.array) : void 0;
    return {
      type: "mesh",
      meshVertices: vertices,
      meshNormals: normals
    };
  }
  /**
   * Get RenderConfig for mesh particle rendering
   */
  getRenderConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    return {
      mode: "mesh",
      meshGeometry: meshId
    };
  }
  // ==========================================================================
  // LOD MANAGEMENT
  // ==========================================================================
  /**
   * Add LOD levels to a registered mesh
   */
  addLODLevels(meshId, lodGeometries, lodDistances) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return;
    registration.lodGeometries = lodGeometries;
    registration.lodDistances = lodDistances;
  }
  /**
   * Get appropriate LOD geometry for distance
   */
  getLODGeometry(meshId, distance) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    if (!registration.lodGeometries || !registration.lodDistances) {
      return registration.geometry;
    }
    for (let i = registration.lodDistances.length - 1; i >= 0; i--) {
      if (distance >= registration.lodDistances[i]) {
        return registration.lodGeometries[i];
      }
    }
    return registration.geometry;
  }
  // ==========================================================================
  // THUMBNAIL GENERATION
  // ==========================================================================
  /**
   * Generate a thumbnail preview for a mesh
   */
  async generateThumbnail(meshId, size = 128) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const scene = new Scene();
    scene.background = new Color(1710618);
    const mesh = new Mesh(
      registration.geometry,
      new MeshStandardMaterial({
        color: 16777215,
        metalness: 0.3,
        roughness: 0.6
      })
    );
    scene.add(mesh);
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    const radius = registration.boundingSphere.radius;
    const distance = radius / Math.sin(camera.fov * Math.PI / 360);
    camera.position.set(distance * 0.8, distance * 0.5, distance * 0.8);
    camera.lookAt(registration.boundingSphere.center);
    const ambient = new AmbientLight(16777215, 0.5);
    const directional = new DirectionalLight(16777215, 1);
    directional.position.set(5, 10, 5);
    scene.add(ambient, directional);
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const renderer = new WebGLRenderer({
      canvas,
      antialias: true,
      preserveDrawingBuffer: true
    });
    renderer.setSize(size, size);
    renderer.render(scene, camera);
    const dataUrl = canvas.toDataURL("image/png");
    renderer.dispose();
    mesh.geometry.dispose();
    mesh.material.dispose();
    registration.thumbnail = dataUrl;
    return dataUrl;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a registered mesh
   */
  getMesh(id) {
    return this.meshRegistry.get(id);
  }
  /**
   * Get all registered meshes
   */
  getAllMeshes() {
    return Array.from(this.meshRegistry.values());
  }
  /**
   * Get meshes by source type
   */
  getMeshesBySource(source) {
    return Array.from(this.meshRegistry.values()).filter(
      (m) => m.source === source
    );
  }
  /**
   * Get instanced mesh renderer
   */
  getInstancedMesh(meshId) {
    return this.instancedMeshes.get(meshId);
  }
  /**
   * Check if a mesh is registered
   */
  hasMesh(id) {
    return this.meshRegistry.has(id);
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Unregister a mesh
   */
  unregisterMesh(id) {
    const registration = this.meshRegistry.get(id);
    if (registration) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.delete(id);
    const instance = this.instancedMeshes.get(id);
    if (instance) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const registration of this.meshRegistry.values()) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.clear();
    for (const instance of this.instancedMeshes.values()) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.clear();
    this.defaultMaterial.dispose();
  }
}
const meshParticleManager = new MeshParticleManager();

class SpriteSheetService {
  sheets = /* @__PURE__ */ new Map();
  textureLoader;
  constructor() {
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // LOADING
  // ==========================================================================
  /**
   * Load a sprite sheet from URL with grid-based layout
   */
  async loadFromGrid(url, columns, rows, options = {}) {
    const texture = await this.loadTexture(url);
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            // Flip Y for Three.js
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: {
            x,
            y,
            width: frameWidth,
            height: frameHeight
          }
        });
      }
    }
    const config = {
      id,
      name: options.name || url,
      url,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load a sprite sheet from URL with JSON metadata
   */
  async loadFromMetadata(imageUrl, metadataUrl, options = {}) {
    const [texture, metadataResponse] = await Promise.all([
      this.loadTexture(imageUrl),
      fetch(metadataUrl)
    ]);
    const metadata = await metadataResponse.json();
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frames = [];
    const frameEntries = Object.entries(metadata.frames);
    frameEntries.forEach(([name, frameData], index) => {
      const f = frameData.frame;
      frames.push({
        index,
        name,
        uv: {
          u: f.x / imageWidth,
          v: 1 - (f.y + f.h) / imageHeight,
          w: f.w / imageWidth,
          h: f.h / imageHeight
        },
        source: {
          x: f.x,
          y: f.y,
          width: f.w,
          height: f.h
        },
        duration: frameData.duration
      });
    });
    const columns = Math.ceil(Math.sqrt(frames.length));
    const rows = Math.ceil(frames.length / columns);
    const config = {
      id,
      name: options.name || imageUrl,
      url: imageUrl,
      texture,
      columns,
      rows,
      frames,
      totalFrames: frames.length,
      frameWidth: frames[0]?.source.width ?? 0,
      frameHeight: frames[0]?.source.height ?? 0,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: true
    };
    if (metadata.meta?.frameTags) {
      for (const tag of metadata.meta.frameTags) {
        const animFrames = [];
        for (let i = tag.from; i <= tag.to; i++) {
          animFrames.push(i);
        }
        config.animations.set(tag.name, {
          name: tag.name,
          frames: animFrames,
          frameRate: config.defaultFrameRate,
          loop: true,
          pingPong: tag.direction === "pingpong"
        });
      }
    }
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load texture from URL
   */
  loadTexture(url) {
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          texture.magFilter = NearestFilter;
          texture.minFilter = NearestFilter;
          texture.generateMipmaps = false;
          texture.colorSpace = SRGBColorSpace;
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Create a sprite sheet from an existing texture
   */
  createFromTexture(texture, columns, rows, options = {}) {
    const id = options.id || `spritesheet_${Date.now()}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: { x, y, width: frameWidth, height: frameHeight }
        });
      }
    }
    const config = {
      id,
      name: options.name || id,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  // ==========================================================================
  // ANIMATION MANAGEMENT
  // ==========================================================================
  /**
   * Add a custom animation to a sprite sheet
   */
  addAnimation(sheetId, animation) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) {
      console.warn(`Sprite sheet not found: ${sheetId}`);
      return;
    }
    sheet.animations.set(animation.name, animation);
  }
  /**
   * Get frame index for a specific time in an animation
   */
  getFrameAtTime(sheetId, animationName, timeMs) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) return 0;
    const animation = sheet.animations.get(animationName);
    if (!animation || animation.frames.length === 0) return 0;
    const frameDuration = 1e3 / animation.frameRate;
    const totalDuration = animation.frames.length * frameDuration;
    let t = timeMs;
    if (animation.loop) {
      if (animation.pingPong) {
        const fullCycle = totalDuration * 2 - frameDuration * 2;
        t = t % fullCycle;
        if (t > totalDuration - frameDuration) {
          t = fullCycle - t;
        }
      } else {
        t = t % totalDuration;
      }
    } else {
      t = Math.min(t, totalDuration - frameDuration);
    }
    const frameIndex = Math.floor(t / frameDuration);
    return animation.frames[Math.min(frameIndex, animation.frames.length - 1)];
  }
  /**
   * Get UV coordinates for a specific frame
   */
  getFrameUV(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || frameIndex < 0 || frameIndex >= sheet.frames.length) {
      return null;
    }
    return sheet.frames[frameIndex].uv;
  }
  // ==========================================================================
  // PARTICLE SYSTEM INTEGRATION
  // ==========================================================================
  /**
   * Get texture config for GPU particle system
   */
  getParticleTextureConfig(sheetId, animationName) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || !sheet.url) return null;
    const animation = animationName ? sheet.animations.get(animationName) : sheet.animations.get("all");
    return {
      diffuseMap: sheet.url,
      spriteSheetColumns: sheet.columns,
      spriteSheetRows: sheet.rows,
      animateSprite: true,
      spriteFrameRate: animation?.frameRate ?? sheet.defaultFrameRate,
      randomStartFrame: true
    };
  }
  /**
   * Create a Three.js SpriteMaterial for a specific frame
   */
  createSpriteMaterial(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture) return null;
    const frame = sheet.frames[frameIndex];
    if (!frame) return null;
    const texture = sheet.texture.clone();
    texture.offset.set(frame.uv.u, frame.uv.v);
    texture.repeat.set(frame.uv.w, frame.uv.h);
    texture.needsUpdate = true;
    return new SpriteMaterial({
      map: texture,
      transparent: true
    });
  }
  /**
   * Update a SpriteMaterial to show a specific frame
   */
  updateSpriteMaterialFrame(material, sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture || !material.map) return;
    const frame = sheet.frames[frameIndex];
    if (!frame) return;
    material.map.offset.set(frame.uv.u, frame.uv.v);
    material.map.repeat.set(frame.uv.w, frame.uv.h);
    material.map.needsUpdate = true;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a sprite sheet by ID
   */
  getSheet(id) {
    return this.sheets.get(id);
  }
  /**
   * Get all sprite sheets
   */
  getAllSheets() {
    return Array.from(this.sheets.values());
  }
  /**
   * Check if a sprite sheet exists
   */
  hasSheet(id) {
    return this.sheets.has(id);
  }
  /**
   * Get texture for a sprite sheet
   */
  getTexture(sheetId) {
    return this.sheets.get(sheetId)?.texture;
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Remove a sprite sheet
   */
  removeSheet(id) {
    const sheet = this.sheets.get(id);
    if (sheet?.texture) {
      sheet.texture.dispose();
    }
    this.sheets.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const sheet of this.sheets.values()) {
      if (sheet.texture) {
        sheet.texture.dispose();
      }
    }
    this.sheets.clear();
  }
}
const spriteSheetService = new SpriteSheetService();

class MaterialSystem {
  /** Texture cache */
  textureCache = /* @__PURE__ */ new Map();
  /** Material cache */
  materialCache = /* @__PURE__ */ new Map();
  /** Current environment map */
  envMap = null;
  /** Environment configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true
  };
  /** HDRI loader */
  rgbeLoader;
  exrLoader;
  /** Texture loader */
  textureLoader;
  /** PMREMGenerator for environment maps */
  pmremGenerator = null;
  /** Asset getter callback */
  assetGetter;
  constructor() {
    this.rgbeLoader = new RGBELoader();
    this.exrLoader = new EXRLoader();
    this.textureLoader = new TextureLoader();
  }
  /**
   * Initialize with WebGL renderer (required for PMREM)
   */
  initialize(renderer) {
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Set asset getter callback
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  // ============================================================================
  // TEXTURE LOADING
  // ============================================================================
  /**
   * Load a texture from URL or asset ID
   */
  async loadTexture(urlOrAssetId, mapType, options) {
    const cacheKey = `${urlOrAssetId}:${mapType}`;
    const cached = this.textureCache.get(cacheKey);
    if (cached) return cached;
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.configureTextureForMapType(texture, mapType);
          if (options?.repeat) {
            texture.repeat.set(options.repeat.x, options.repeat.y);
            texture.wrapS = RepeatWrapping;
            texture.wrapT = RepeatWrapping;
          }
          if (options?.offset) {
            texture.offset.set(options.offset.x, options.offset.y);
          }
          if (options?.rotation !== void 0) {
            texture.rotation = options.rotation * (Math.PI / 180);
          }
          this.textureCache.set(cacheKey, texture);
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Configure texture settings based on map type
   */
  configureTextureForMapType(texture, mapType) {
    texture.generateMipmaps = true;
    texture.minFilter = LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    switch (mapType) {
      case "albedo":
      case "emissive":
        texture.colorSpace = SRGBColorSpace;
        break;
      case "normal":
      case "roughness":
      case "metalness":
      case "ao":
      case "height":
      case "opacity":
      case "specular":
        texture.colorSpace = LinearSRGBColorSpace;
        break;
    }
  }
  // ============================================================================
  // PBR MATERIAL CREATION
  // ============================================================================
  /**
   * Create a PBR material from configuration
   */
  async createPBRMaterial(config) {
    const cached = this.materialCache.get(config.id);
    if (cached) return cached;
    const material = new MeshStandardMaterial({
      color: new Color(config.color),
      metalness: config.metalness,
      roughness: config.roughness,
      transparent: config.transparent,
      opacity: config.opacity,
      emissive: new Color(config.emissive),
      emissiveIntensity: config.emissiveIntensity,
      envMapIntensity: config.envMapIntensity,
      normalScale: new Vector2(config.normalScale, config.normalScale),
      displacementScale: config.displacementScale,
      displacementBias: config.displacementBias,
      aoMapIntensity: config.aoMapIntensity,
      flatShading: config.flatShading,
      wireframe: config.wireframe,
      depthWrite: config.depthWrite,
      depthTest: config.depthTest,
      side: this.getSide(config.side)
    });
    const texturePromises = [];
    if (config.maps.albedo) {
      texturePromises.push(
        this.loadTexture(config.maps.albedo, "albedo", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.map = tex;
        })
      );
    }
    if (config.maps.normal) {
      texturePromises.push(
        this.loadTexture(config.maps.normal, "normal", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.normalMap = tex;
        })
      );
    }
    if (config.maps.roughness) {
      texturePromises.push(
        this.loadTexture(config.maps.roughness, "roughness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.roughnessMap = tex;
        })
      );
    }
    if (config.maps.metalness) {
      texturePromises.push(
        this.loadTexture(config.maps.metalness, "metalness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.metalnessMap = tex;
        })
      );
    }
    if (config.maps.ao) {
      texturePromises.push(
        this.loadTexture(config.maps.ao, "ao", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.aoMap = tex;
        })
      );
    }
    if (config.maps.emissive) {
      texturePromises.push(
        this.loadTexture(config.maps.emissive, "emissive", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.emissiveMap = tex;
        })
      );
    }
    if (config.maps.height) {
      texturePromises.push(
        this.loadTexture(config.maps.height, "height", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.displacementMap = tex;
        })
      );
    }
    if (config.maps.opacity) {
      texturePromises.push(
        this.loadTexture(config.maps.opacity, "opacity", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.alphaMap = tex;
          material.transparent = true;
        })
      );
    }
    if (this.envMap && this.envConfig.enabled) {
      material.envMap = this.envMap;
    }
    await Promise.all(texturePromises);
    material.needsUpdate = true;
    this.materialCache.set(config.id, material);
    return material;
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  /**
   * Create default PBR material config
   */
  static createDefaultConfig(id, name) {
    return {
      id,
      name,
      color: "#ffffff",
      opacity: 1,
      transparent: false,
      metalness: 0,
      roughness: 0.5,
      envMapIntensity: 1,
      emissive: "#000000",
      emissiveIntensity: 1,
      normalScale: 1,
      displacementScale: 0,
      displacementBias: 0,
      aoMapIntensity: 1,
      maps: {},
      textureRepeat: { x: 1, y: 1 },
      textureOffset: { x: 0, y: 0 },
      textureRotation: 0,
      side: "double",
      flatShading: false,
      wireframe: false,
      depthWrite: true,
      depthTest: true
    };
  }
  // ============================================================================
  // ENVIRONMENT MAPS (HDRI)
  // ============================================================================
  /**
   * Load an environment map (HDR/EXR)
   */
  async loadEnvironmentMap(urlOrAssetId) {
    if (!this.pmremGenerator) {
      throw new Error("MaterialSystem not initialized. Call initialize() with renderer first.");
    }
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    const isEXR = url.toLowerCase().endsWith(".exr");
    const loader = isEXR ? this.exrLoader : this.rgbeLoader;
    return new Promise((resolve, reject) => {
      loader.load(
        url,
        (texture) => {
          const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
          texture.dispose();
          this.envMap = envMap;
          this.envConfig.enabled = true;
          this.updateMaterialsEnvMap();
          resolve(envMap);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Set environment configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (config.intensity !== void 0) {
      for (const material of this.materialCache.values()) {
        material.envMapIntensity = config.intensity;
      }
    }
  }
  /**
   * Get current environment map for scene background
   */
  getEnvironmentMap() {
    return this.envMap;
  }
  /**
   * Get environment config
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Update all materials with current environment map
   */
  updateMaterialsEnvMap() {
    for (const material of this.materialCache.values()) {
      material.envMap = this.envConfig.enabled ? this.envMap : null;
      material.envMapIntensity = this.envConfig.intensity;
      material.needsUpdate = true;
    }
  }
  // ============================================================================
  // MATERIAL PRESETS
  // ============================================================================
  /**
   * Get built-in material presets
   */
  static getPresets() {
    return [
      // Metals
      {
        id: "chrome",
        name: "Chrome",
        category: "Metal",
        config: {
          color: "#ffffff",
          metalness: 1,
          roughness: 0.05,
          envMapIntensity: 1.5
        }
      },
      {
        id: "brushed_steel",
        name: "Brushed Steel",
        category: "Metal",
        config: {
          color: "#c0c0c0",
          metalness: 1,
          roughness: 0.4
        }
      },
      {
        id: "gold",
        name: "Gold",
        category: "Metal",
        config: {
          color: "#ffd700",
          metalness: 1,
          roughness: 0.2
        }
      },
      {
        id: "copper",
        name: "Copper",
        category: "Metal",
        config: {
          color: "#b87333",
          metalness: 1,
          roughness: 0.3
        }
      },
      // Plastics
      {
        id: "glossy_plastic",
        name: "Glossy Plastic",
        category: "Plastic",
        config: {
          color: "#ff0000",
          metalness: 0,
          roughness: 0.1
        }
      },
      {
        id: "matte_plastic",
        name: "Matte Plastic",
        category: "Plastic",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.8
        }
      },
      // Glass
      {
        id: "clear_glass",
        name: "Clear Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0,
          opacity: 0.2,
          transparent: true,
          envMapIntensity: 2
        }
      },
      {
        id: "frosted_glass",
        name: "Frosted Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.5,
          opacity: 0.5,
          transparent: true
        }
      },
      // Natural
      {
        id: "clay",
        name: "Clay",
        category: "Natural",
        config: {
          color: "#d4a574",
          metalness: 0,
          roughness: 0.9
        }
      },
      {
        id: "stone",
        name: "Stone",
        category: "Natural",
        config: {
          color: "#808080",
          metalness: 0,
          roughness: 0.7
        }
      },
      // Emissive
      {
        id: "neon_glow",
        name: "Neon Glow",
        category: "Emissive",
        config: {
          color: "#000000",
          emissive: "#00ffff",
          emissiveIntensity: 2,
          metalness: 0,
          roughness: 0.5
        }
      },
      {
        id: "hot_metal",
        name: "Hot Metal",
        category: "Emissive",
        config: {
          color: "#ff4400",
          emissive: "#ff2200",
          emissiveIntensity: 1,
          metalness: 0.8,
          roughness: 0.4
        }
      }
    ];
  }
  /**
   * Create material from preset
   */
  async createFromPreset(presetId, materialId, overrides) {
    const preset = MaterialSystem.getPresets().find((p) => p.id === presetId);
    if (!preset) {
      throw new Error(`Preset not found: ${presetId}`);
    }
    const config = {
      ...MaterialSystem.createDefaultConfig(materialId, preset.name),
      ...preset.config,
      ...overrides,
      id: materialId
    };
    return this.createPBRMaterial(config);
  }
  // ============================================================================
  // MATERIAL UPDATES
  // ============================================================================
  /**
   * Update an existing material's properties
   */
  updateMaterial(materialId, updates) {
    const material = this.materialCache.get(materialId);
    if (!material) return;
    if (updates.color !== void 0) {
      material.color.set(updates.color);
    }
    if (updates.metalness !== void 0) {
      material.metalness = updates.metalness;
    }
    if (updates.roughness !== void 0) {
      material.roughness = updates.roughness;
    }
    if (updates.opacity !== void 0) {
      material.opacity = updates.opacity;
    }
    if (updates.transparent !== void 0) {
      material.transparent = updates.transparent;
    }
    if (updates.emissive !== void 0) {
      material.emissive.set(updates.emissive);
    }
    if (updates.emissiveIntensity !== void 0) {
      material.emissiveIntensity = updates.emissiveIntensity;
    }
    if (updates.envMapIntensity !== void 0) {
      material.envMapIntensity = updates.envMapIntensity;
    }
    if (updates.normalScale !== void 0) {
      material.normalScale.set(updates.normalScale, updates.normalScale);
    }
    if (updates.wireframe !== void 0) {
      material.wireframe = updates.wireframe;
    }
    if (updates.flatShading !== void 0) {
      material.flatShading = updates.flatShading;
    }
    if (updates.side !== void 0) {
      material.side = this.getSide(updates.side);
    }
    material.needsUpdate = true;
  }
  /**
   * Get a cached material
   */
  getMaterial(materialId) {
    return this.materialCache.get(materialId);
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  /**
   * Dispose a material
   */
  disposeMaterial(materialId) {
    const material = this.materialCache.get(materialId);
    if (material) {
      material.dispose();
      this.materialCache.delete(materialId);
    }
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const texture of this.textureCache.values()) {
      texture.dispose();
    }
    this.textureCache.clear();
    for (const material of this.materialCache.values()) {
      material.dispose();
    }
    this.materialCache.clear();
    if (this.envMap) {
      this.envMap.dispose();
      this.envMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
  }
}
const materialSystem = new MaterialSystem();

const useAssetStore = defineStore("assets", {
  state: () => ({
    // Materials
    materials: /* @__PURE__ */ new Map(),
    selectedMaterialId: null,
    // SVG Documents
    svgDocuments: /* @__PURE__ */ new Map(),
    selectedSvgId: null,
    // Mesh Particles
    meshParticles: /* @__PURE__ */ new Map(),
    selectedMeshParticleId: null,
    // Sprite Sheets
    spriteSheets: /* @__PURE__ */ new Map(),
    selectedSpriteSheetId: null,
    // Environment
    environment: {
      enabled: false,
      url: null,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true
    },
    environmentTexture: null,
    // Loading states
    isLoadingMaterial: false,
    isLoadingSvg: false,
    isLoadingMesh: false,
    isLoadingSpriteSheet: false,
    isLoadingEnvironment: false,
    // Error states
    lastError: null
  }),
  getters: {
    // Materials
    materialList: (state) => Array.from(state.materials.values()),
    selectedMaterial: (state) => state.selectedMaterialId ? state.materials.get(state.selectedMaterialId) ?? null : null,
    // SVG Documents
    svgDocumentList: (state) => Array.from(state.svgDocuments.values()),
    selectedSvgDocument: (state) => state.selectedSvgId ? state.svgDocuments.get(state.selectedSvgId) ?? null : null,
    // Mesh Particles
    meshParticleList: (state) => Array.from(state.meshParticles.values()),
    selectedMeshParticle: (state) => state.selectedMeshParticleId ? state.meshParticles.get(state.selectedMeshParticleId) ?? null : null,
    // Sprite Sheets
    spriteSheetList: (state) => Array.from(state.spriteSheets.values()),
    selectedSpriteSheet: (state) => state.selectedSpriteSheetId ? state.spriteSheets.get(state.selectedSpriteSheetId) ?? null : null,
    // Combined loading state
    isLoading: (state) => state.isLoadingMaterial || state.isLoadingSvg || state.isLoadingMesh || state.isLoadingSpriteSheet || state.isLoadingEnvironment
  },
  actions: {
    // ========================================================================
    // MATERIALS
    // ========================================================================
    /**
     * Create a new material from preset
     */
    createMaterialFromPreset(presetName, customName) {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const presetConfigs = {
        chrome: { color: "#ffffff", metalness: 1, roughness: 0.1 },
        gold: { color: "#ffd700", metalness: 1, roughness: 0.2 },
        silver: { color: "#c0c0c0", metalness: 1, roughness: 0.15 },
        copper: { color: "#b87333", metalness: 1, roughness: 0.3 },
        brass: { color: "#b5a642", metalness: 0.9, roughness: 0.25 },
        glass: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true },
        plastic: { color: "#ffffff", metalness: 0, roughness: 0.4 },
        rubber: { color: "#222222", metalness: 0, roughness: 0.9 },
        wood: { color: "#8b4513", metalness: 0, roughness: 0.7 },
        concrete: { color: "#808080", metalness: 0, roughness: 0.9 },
        emissive: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2 },
        holographic: { color: "#88ffff", metalness: 0.8, roughness: 0.2, emissive: "#ff00ff", emissiveIntensity: 0.5 }
      };
      const presetConfig = presetConfigs[presetName] || {};
      const config = this.createDefaultMaterialConfig(id, customName || presetName, presetConfig);
      const stored = {
        id,
        name: customName || presetName,
        config,
        presetName,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      storeLogger.debug("Created material from preset:", presetName, id);
      return id;
    },
    /**
     * Create a new empty material
     */
    createEmptyMaterial(name = "New Material") {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const config = this.createDefaultMaterialConfig(id, name);
      const stored = {
        id,
        name,
        config,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      return id;
    },
    /**
     * Helper to create a full default material config
     */
    createDefaultMaterialConfig(id, name, overrides = {}) {
      return {
        id,
        name,
        color: "#ffffff",
        opacity: 1,
        transparent: false,
        metalness: 0,
        roughness: 0.5,
        envMapIntensity: 1,
        emissive: "#000000",
        emissiveIntensity: 0,
        normalScale: 1,
        displacementScale: 0,
        displacementBias: 0,
        aoMapIntensity: 1,
        maps: {},
        textureRepeat: { x: 1, y: 1 },
        textureOffset: { x: 0, y: 0 },
        textureRotation: 0,
        side: "front",
        flatShading: false,
        wireframe: false,
        depthWrite: true,
        depthTest: true,
        ...overrides
      };
    },
    /**
     * Update material configuration
     */
    updateMaterial(id, updates) {
      const stored = this.materials.get(id);
      if (!stored) return;
      stored.config = { ...stored.config, ...updates };
      stored.modifiedAt = Date.now();
      this.materials.set(id, stored);
    },
    /**
     * Set texture for material
     */
    async setMaterialTexture(materialId, textureType, file) {
      const stored = this.materials.get(materialId);
      if (!stored) return;
      this.isLoadingMaterial = true;
      try {
        const url = URL.createObjectURL(file);
        stored.config[textureType] = url;
        stored.modifiedAt = Date.now();
        this.materials.set(materialId, stored);
      } catch (error) {
        this.lastError = `Failed to load texture: ${error}`;
      } finally {
        this.isLoadingMaterial = false;
      }
    },
    /**
     * Delete a material
     */
    deleteMaterial(id) {
      this.materials.delete(id);
      if (this.selectedMaterialId === id) {
        this.selectedMaterialId = null;
      }
    },
    /**
     * Get Three.js material from stored config
     * Note: This creates a simple THREE.MeshStandardMaterial without async texture loading
     * For full PBR with textures, use materialSystem.createPBRMaterial()
     */
    getThreeMaterial(id) {
      const stored = this.materials.get(id);
      if (!stored) return null;
      const config = stored.config;
      const material = new MeshStandardMaterial({
        color: new Color(config.color),
        metalness: config.metalness,
        roughness: config.roughness,
        transparent: config.transparent,
        opacity: config.opacity,
        flatShading: config.flatShading,
        wireframe: config.wireframe,
        side: config.side === "double" ? DoubleSide : config.side === "back" ? BackSide : FrontSide
      });
      if (config.emissive && config.emissive !== "#000000") {
        material.emissive = new Color(config.emissive);
        material.emissiveIntensity = config.emissiveIntensity;
      }
      return material;
    },
    // ========================================================================
    // SVG DOCUMENTS
    // ========================================================================
    /**
     * Import SVG from file
     */
    async importSvgFromFile(file) {
      this.isLoadingSvg = true;
      try {
        const text = await file.text();
        const name = file.name.replace(/\.svg$/i, "");
        const document = svgExtrusionService.loadFromString(text, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          // baseDepth
          5,
          // depthIncrement between layers
          2
          // extrusionDepth per layer
        );
        const id = document.id;
        const stored = {
          id,
          name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        storeLogger.debug("Imported SVG:", name, `${document.paths.length} paths`);
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Import SVG from URL
     */
    async importSvgFromUrl(url, name) {
      this.isLoadingSvg = true;
      try {
        const document = await svgExtrusionService.loadFromURL(url, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          5,
          2
        );
        const id = document.id;
        const stored = {
          id,
          name: document.name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Update layer config for an SVG path
     */
    updateSvgLayerConfig(svgId, pathIndex, config) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.layerConfigs.length) return;
      stored.layerConfigs[pathIndex] = { ...stored.layerConfigs[pathIndex], ...config };
      this.svgDocuments.set(svgId, stored);
    },
    /**
     * Get extruded geometries for all paths in an SVG
     */
    getExtrudedGeometries(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return [];
      return stored.document.paths.map((path, i) => {
        const config = stored.layerConfigs[i];
        return svgExtrusionService.createExtrudedGeometry(path, {
          depth: config.extrusionDepth
        });
      });
    },
    /**
     * Create a Three.js Group with all extruded SVG paths
     */
    createExtrudedGroup(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return null;
      return svgExtrusionService.createLayeredMeshes(
        stored.document,
        stored.layerConfigs
      );
    },
    /**
     * Delete an SVG document
     */
    deleteSvgDocument(id) {
      this.svgDocuments.delete(id);
      if (this.selectedSvgId === id) {
        this.selectedSvgId = null;
      }
    },
    // ========================================================================
    // MESH PARTICLES
    // ========================================================================
    /**
     * Register a primitive shape as mesh particle
     */
    registerPrimitiveMesh(type, name, size = 1) {
      const registration = meshParticleManager.registerPrimitive(type, name, size);
      const stored = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "primitive"
      };
      this.meshParticles.set(registration.id, stored);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Register an SVG path as mesh particle
     */
    registerSvgPathAsMesh(svgId, pathIndex, name, options) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.document.paths.length) return null;
      const path = stored.document.paths[pathIndex];
      const registration = meshParticleManager.registerFromSVG(
        svgId,
        path.id,
        name || `${stored.name}_${pathIndex}`,
        options
      );
      if (!registration) return null;
      const storedMesh = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "svg",
        sourceId: path.id
      };
      this.meshParticles.set(registration.id, storedMesh);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Get emitter config for mesh-based emission
     */
    getMeshEmitterConfig(meshId) {
      return meshParticleManager.getEmitterShapeConfig(meshId);
    },
    /**
     * Create instanced mesh for particle rendering
     */
    createInstancedMesh(meshId, maxInstances, materialId) {
      const material = materialId ? this.getThreeMaterial(materialId) : void 0;
      const result = meshParticleManager.createInstancedMesh(meshId, maxInstances, material || void 0);
      return result?.mesh || null;
    },
    /**
     * Delete a mesh particle
     */
    deleteMeshParticle(id) {
      meshParticleManager.unregisterMesh(id);
      this.meshParticles.delete(id);
      if (this.selectedMeshParticleId === id) {
        this.selectedMeshParticleId = null;
      }
    },
    // ========================================================================
    // SPRITE SHEETS
    // ========================================================================
    /**
     * Import sprite sheet from file
     */
    async importSpriteSheet(file, columns, rows, options) {
      this.isLoadingSpriteSheet = true;
      try {
        const url = URL.createObjectURL(file);
        const config = await spriteSheetService.loadFromGrid(url, columns, rows, {
          name: options?.name || file.name.replace(/\.[^.]+$/, ""),
          frameRate: options?.frameRate
        });
        const stored = {
          id: config.id,
          name: config.name || config.id,
          config,
          textureUrl: url
        };
        this.spriteSheets.set(config.id, stored);
        this.selectedSpriteSheetId = config.id;
        return { success: true, assetId: config.id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Sprite sheet import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSpriteSheet = false;
      }
    },
    /**
     * Add animation to sprite sheet
     */
    addSpriteAnimation(sheetId, name, frames, options) {
      spriteSheetService.addAnimation(sheetId, {
        name,
        frames,
        frameRate: options?.frameRate ?? 24,
        loop: options?.loop ?? true,
        pingPong: options?.pingPong ?? false
      });
    },
    /**
     * Get particle texture config for GPU particles
     */
    getParticleTextureConfig(sheetId) {
      return spriteSheetService.getParticleTextureConfig(sheetId);
    },
    /**
     * Delete a sprite sheet
     */
    deleteSpriteSheet(id) {
      const stored = this.spriteSheets.get(id);
      if (stored?.textureUrl) {
        URL.revokeObjectURL(stored.textureUrl);
      }
      spriteSheetService.removeSheet(id);
      this.spriteSheets.delete(id);
      if (this.selectedSpriteSheetId === id) {
        this.selectedSpriteSheetId = null;
      }
    },
    // ========================================================================
    // ENVIRONMENT
    // ========================================================================
    /**
     * Load HDRI environment map
     */
    async loadEnvironment(file, options) {
      this.isLoadingEnvironment = true;
      try {
        const url = URL.createObjectURL(file);
        this.environment = {
          ...this.environment,
          url,
          intensity: options?.intensity ?? this.environment.intensity,
          rotation: options?.rotation ?? this.environment.rotation,
          useAsBackground: options?.useAsBackground ?? this.environment.useAsBackground,
          enabled: true
        };
        storeLogger.debug("Environment loaded:", file.name);
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Load environment from preset URL
     */
    async loadEnvironmentPreset(presetUrl, presetName) {
      this.isLoadingEnvironment = true;
      try {
        this.environment = {
          ...this.environment,
          url: presetUrl,
          presetName,
          enabled: true
        };
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment preset load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Update environment settings
     */
    updateEnvironment(settings) {
      this.environment = { ...this.environment, ...settings };
    },
    /**
     * Clear environment
     */
    clearEnvironment() {
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      this.environment = {
        enabled: false,
        url: null,
        intensity: 1,
        rotation: 0,
        backgroundBlur: 0,
        useAsBackground: true
      };
      this.environmentTexture = null;
    },
    // ========================================================================
    // UTILITIES
    // ========================================================================
    /**
     * Clear last error
     */
    clearError() {
      this.lastError = null;
    },
    /**
     * Dispose all assets and free resources
     */
    dispose() {
      for (const stored of this.materials.values()) {
        for (const key of Object.keys(stored.config)) {
          const value = stored.config[key];
          if (typeof value === "string" && value.startsWith("blob:")) {
            URL.revokeObjectURL(value);
          }
        }
      }
      for (const stored of this.spriteSheets.values()) {
        if (stored.textureUrl.startsWith("blob:")) {
          URL.revokeObjectURL(stored.textureUrl);
        }
      }
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      svgExtrusionService.dispose();
      meshParticleManager.dispose();
      spriteSheetService.dispose();
      materialSystem.dispose();
      this.materials.clear();
      this.svgDocuments.clear();
      this.meshParticles.clear();
      this.spriteSheets.clear();
      this.selectedMaterialId = null;
      this.selectedSvgId = null;
      this.selectedMeshParticleId = null;
      this.selectedSpriteSheetId = null;
      this.clearEnvironment();
    }
  }
});

const _hoisted_1$j = {
  key: 0,
  class: "texture-preview"
};
const _hoisted_2$j = ["src", "alt"];
const _hoisted_3$j = { class: "texture-info" };
const _hoisted_4$j = { class: "texture-name" };
const _hoisted_5$j = { class: "texture-size" };
const _hoisted_6$j = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_7$j = { class: "map-label" };
const _hoisted_8$j = {
  key: 0,
  class: "texture-settings"
};
const _hoisted_9$i = { class: "setting-row" };
const _hoisted_10$h = { class: "repeat-inputs" };
const _hoisted_11$g = { class: "setting-row" };
const _hoisted_12$e = { class: "offset-inputs" };
const _hoisted_13$d = {
  key: 0,
  class: "setting-row"
};
const acceptedFormats = "image/png,image/jpeg,image/webp,image/exr";
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "TextureUpload",
  props: {
    mapType: {},
    textureUrl: {},
    textureName: {},
    repeatX: {},
    repeatY: {},
    offsetX: {},
    offsetY: {},
    normalScale: {},
    showSettings: { type: Boolean }
  },
  emits: ["upload", "remove", "update:repeatX", "update:repeatY", "update:offsetX", "update:offsetY", "update:normalScale"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const previewUrl = ref(props.textureUrl || "");
    const textureSize = ref("");
    const mapLabels = {
      albedo: "Albedo / Color",
      normal: "Normal Map",
      roughness: "Roughness",
      metalness: "Metalness",
      ao: "Ambient Occlusion",
      emissive: "Emissive",
      height: "Height / Displacement",
      opacity: "Opacity / Alpha",
      specular: "Specular"
    };
    const mapLabel = computed(() => mapLabels[props.mapType] || props.mapType);
    const hasTexture = computed(() => !!previewUrl.value || !!props.textureUrl);
    function openFilePicker() {
      fileInput.value?.click();
    }
    function onDragOver(e) {
      isDragging.value = true;
    }
    function onDragLeave(e) {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        handleFile(input.files[0]);
      }
    }
    function handleFile(file) {
      if (!file.type.startsWith("image/")) {
        console.warn("Invalid file type:", file.type);
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target?.result;
        previewUrl.value = dataUrl;
        const img = new Image();
        img.onload = () => {
          textureSize.value = `${img.width} x ${img.height}`;
        };
        img.src = dataUrl;
        emit("upload", file, dataUrl);
      };
      reader.readAsDataURL(file);
    }
    function removeTexture() {
      previewUrl.value = "";
      textureSize.value = "";
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["texture-upload", { "has-texture": hasTexture.value, "drag-over": isDragging.value }])
      }, [
        createBaseVNode("div", {
          class: "upload-zone",
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasTexture.value ? (openBlock(), createElementBlock("div", _hoisted_1$j, [
            createBaseVNode("img", {
              src: previewUrl.value,
              alt: __props.mapType
            }, null, 8, _hoisted_2$j),
            createBaseVNode("div", _hoisted_3$j, [
              createBaseVNode("span", _hoisted_4$j, toDisplayString(__props.textureName), 1),
              createBaseVNode("span", _hoisted_5$j, toDisplayString(textureSize.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeTexture, ["stop"]),
              title: "Remove texture"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_6$j, [
            _cache[6] || (_cache[6] = createBaseVNode("i", { class: "pi pi-image" }, null, -1)),
            createBaseVNode("span", _hoisted_7$j, toDisplayString(mapLabel.value), 1),
            _cache[7] || (_cache[7] = createBaseVNode("span", { class: "hint" }, "Click or drop image", -1))
          ]))
        ], 32),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 544),
        hasTexture.value && __props.showSettings ? (openBlock(), createElementBlock("div", _hoisted_8$j, [
          createBaseVNode("div", _hoisted_9$i, [
            _cache[9] || (_cache[9] = createBaseVNode("label", null, "Repeat", -1)),
            createBaseVNode("div", _hoisted_10$h, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatX,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:repeatX", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"]),
              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "separator" }, "x", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatY,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:repeatY", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$g, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Offset", -1)),
            createBaseVNode("div", _hoisted_12$e, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetX,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:offsetX", $event)),
                step: 0.01
              }, null, 8, ["modelValue"]),
              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "separator" }, ",", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetY,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:offsetY", $event)),
                step: 0.01
              }, null, 8, ["modelValue"])
            ])
          ]),
          __props.mapType === "normal" ? (openBlock(), createElementBlock("div", _hoisted_13$d, [
            _cache[12] || (_cache[12] = createBaseVNode("label", null, "Strength", -1)),
            createVNode(unref(SliderInput), {
              modelValue: __props.normalScale,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:normalScale", $event)),
              min: 0,
              max: 2,
              step: 0.1
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const TextureUpload = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-692842d0"]]);

const _hoisted_1$i = { class: "material-editor" };
const _hoisted_2$i = { class: "editor-header" };
const _hoisted_3$i = ["value"];
const _hoisted_4$i = { class: "property-section" };
const _hoisted_5$i = { class: "section-content" };
const _hoisted_6$i = { class: "property-group" };
const _hoisted_7$i = { class: "property-group" };
const _hoisted_8$i = { class: "property-group" };
const _hoisted_9$h = { class: "property-group" };
const _hoisted_10$g = { class: "property-row checkbox-row" };
const _hoisted_11$f = ["checked"];
const _hoisted_12$d = { class: "property-section" };
const _hoisted_13$c = { class: "section-content" };
const _hoisted_14$c = { class: "property-group" };
const _hoisted_15$c = { class: "property-group" };
const _hoisted_16$c = { class: "property-section" };
const _hoisted_17$b = { class: "section-content" };
const _hoisted_18$a = { class: "texture-grid" };
const _hoisted_19$a = {
  key: 0,
  class: "texture-global-settings"
};
const _hoisted_20$a = { class: "setting-row" };
const _hoisted_21$9 = { class: "repeat-inputs" };
const _hoisted_22$9 = { class: "property-section" };
const _hoisted_23$9 = { class: "section-content" };
const _hoisted_24$7 = { class: "property-group" };
const _hoisted_25$7 = { class: "property-row checkbox-row" };
const _hoisted_26$7 = ["checked"];
const _hoisted_27$6 = { class: "property-row checkbox-row" };
const _hoisted_28$6 = ["checked"];
const _hoisted_29$6 = { class: "property-row" };
const _hoisted_30$6 = ["value"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "MaterialEditor",
  props: {
    modelValue: {},
    layerId: {},
    materialId: {},
    config: {}
  },
  emits: ["update:modelValue", "save-preset", "update", "texture-upload"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultMaterial = {
      color: "#ffffff",
      metalness: 0,
      roughness: 0.5,
      opacity: 1,
      transparent: false,
      emissive: "#000000",
      emissiveIntensity: 0,
      normalScale: 1,
      envMapIntensity: 1,
      flatShading: false,
      wireframe: false,
      side: "front",
      maps: {},
      textureRepeat: { x: 1, y: 1 }
    };
    const presets = [
      {
        id: "chrome",
        name: "Chrome",
        config: { color: "#ffffff", metalness: 1, roughness: 0.1 }
      },
      {
        id: "gold",
        name: "Gold",
        config: { color: "#ffd700", metalness: 1, roughness: 0.2 }
      },
      {
        id: "copper",
        name: "Copper",
        config: { color: "#b87333", metalness: 1, roughness: 0.3 }
      },
      {
        id: "plastic",
        name: "Plastic",
        config: { color: "#ffffff", metalness: 0, roughness: 0.4 }
      },
      {
        id: "rubber",
        name: "Rubber",
        config: { color: "#222222", metalness: 0, roughness: 0.9 }
      },
      {
        id: "glass",
        name: "Glass",
        config: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true }
      },
      {
        id: "emissive",
        name: "Emissive",
        config: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2, metalness: 0, roughness: 0.5 }
      },
      {
        id: "matte",
        name: "Matte",
        config: { color: "#cccccc", metalness: 0, roughness: 1 }
      }
    ];
    const material = reactive({ ...defaultMaterial, ...props.modelValue, ...props.config });
    const selectedPreset = ref("");
    const sections = reactive({
      basic: true,
      emissive: false,
      textures: true,
      environment: false
    });
    const hasAnyTexture = computed(() => {
      return Object.values(material.maps).some((url) => !!url);
    });
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    function toggleSection(section) {
      sections[section] = !sections[section];
    }
    function updateMaterial(key, value) {
      material[key] = value;
      selectedPreset.value = "";
      emitUpdate();
    }
    function updateTextureRepeat(axis, value) {
      material.textureRepeat[axis] = value;
      emitUpdate();
    }
    function uploadTexture(mapType, file, dataUrl) {
      material.maps[mapType] = dataUrl;
      emitUpdate();
      emit("texture-upload", mapType, file);
    }
    function removeTexture(mapType) {
      delete material.maps[mapType];
      emitUpdate();
    }
    function applyPreset() {
      if (!selectedPreset.value) return;
      const preset = presets.find((p) => p.id === selectedPreset.value);
      if (preset) {
        Object.assign(material, { ...defaultMaterial, ...preset.config });
        emitUpdate();
      }
    }
    function resetMaterial() {
      Object.assign(material, defaultMaterial);
      selectedPreset.value = "";
      emitUpdate();
    }
    function saveMaterial() {
      const name = prompt("Enter preset name:");
      if (name) {
        emit("save-preset", name, { ...material });
      }
    }
    function emitUpdate() {
      emit("update:modelValue", { ...material });
      emit("update", { ...material });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", _hoisted_2$i, [
          _cache[36] || (_cache[36] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-palette" }),
            createBaseVNode("span", null, "Material")
          ], -1)),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
            onChange: applyPreset,
            class: "preset-select"
          }, [
            _cache[35] || (_cache[35] = createBaseVNode("option", { value: "" }, "Custom", -1)),
            (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
              return createBaseVNode("option", {
                key: preset.id,
                value: preset.id
              }, toDisplayString(preset.name), 9, _hoisted_3$i);
            }), 64))
          ], 544), [
            [vModelSelect, selectedPreset.value]
          ])
        ]),
        createBaseVNode("div", _hoisted_4$i, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("basic"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.basic ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[37] || (_cache[37] = createBaseVNode("span", null, "Basic Properties", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_5$i, [
            createBaseVNode("div", _hoisted_6$i, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Base Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.color,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateMaterial("color", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$i, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Metalness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.metalness,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateMaterial("metalness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_8$i, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Roughness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.roughness,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => updateMaterial("roughness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_9$h, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.opacity,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateMaterial("opacity", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_10$g, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.transparent,
                  onChange: _cache[6] || (_cache[6] = ($event) => updateMaterial("transparent", $event.target.checked))
                }, null, 40, _hoisted_11$f),
                _cache[42] || (_cache[42] = createTextVNode(" Transparent ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.basic]
          ])
        ]),
        createBaseVNode("div", _hoisted_12$d, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("emissive"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.emissive ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[43] || (_cache[43] = createBaseVNode("span", null, "Emissive", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_13$c, [
            createBaseVNode("div", _hoisted_14$c, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Emissive Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.emissive,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => updateMaterial("emissive", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$c, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.emissiveIntensity,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => updateMaterial("emissiveIntensity", $event)),
                min: 0,
                max: 5,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ], 512), [
            [vShow, sections.emissive]
          ])
        ]),
        createBaseVNode("div", _hoisted_16$c, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("textures"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.textures ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[46] || (_cache[46] = createBaseVNode("span", null, "Texture Maps", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_17$b, [
            createBaseVNode("div", _hoisted_18$a, [
              createVNode(TextureUpload, {
                mapType: "albedo",
                textureUrl: material.maps?.albedo,
                onUpload: _cache[11] || (_cache[11] = (file, dataUrl) => uploadTexture("albedo", file, dataUrl)),
                onRemove: _cache[12] || (_cache[12] = ($event) => removeTexture("albedo"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "normal",
                textureUrl: material.maps?.normal,
                normalScale: material.normalScale,
                showSettings: !!material.maps?.normal,
                onUpload: _cache[13] || (_cache[13] = (file, dataUrl) => uploadTexture("normal", file, dataUrl)),
                onRemove: _cache[14] || (_cache[14] = ($event) => removeTexture("normal")),
                "onUpdate:normalScale": _cache[15] || (_cache[15] = ($event) => updateMaterial("normalScale", $event))
              }, null, 8, ["textureUrl", "normalScale", "showSettings"]),
              createVNode(TextureUpload, {
                mapType: "roughness",
                textureUrl: material.maps?.roughness,
                onUpload: _cache[16] || (_cache[16] = (file, dataUrl) => uploadTexture("roughness", file, dataUrl)),
                onRemove: _cache[17] || (_cache[17] = ($event) => removeTexture("roughness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "metalness",
                textureUrl: material.maps?.metalness,
                onUpload: _cache[18] || (_cache[18] = (file, dataUrl) => uploadTexture("metalness", file, dataUrl)),
                onRemove: _cache[19] || (_cache[19] = ($event) => removeTexture("metalness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "ao",
                textureUrl: material.maps?.ao,
                onUpload: _cache[20] || (_cache[20] = (file, dataUrl) => uploadTexture("ao", file, dataUrl)),
                onRemove: _cache[21] || (_cache[21] = ($event) => removeTexture("ao"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "emissive",
                textureUrl: material.maps?.emissive,
                onUpload: _cache[22] || (_cache[22] = (file, dataUrl) => uploadTexture("emissive", file, dataUrl)),
                onRemove: _cache[23] || (_cache[23] = ($event) => removeTexture("emissive"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "height",
                textureUrl: material.maps?.height,
                onUpload: _cache[24] || (_cache[24] = (file, dataUrl) => uploadTexture("height", file, dataUrl)),
                onRemove: _cache[25] || (_cache[25] = ($event) => removeTexture("height"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "opacity",
                textureUrl: material.maps?.opacity,
                onUpload: _cache[26] || (_cache[26] = (file, dataUrl) => uploadTexture("opacity", file, dataUrl)),
                onRemove: _cache[27] || (_cache[27] = ($event) => removeTexture("opacity"))
              }, null, 8, ["textureUrl"])
            ]),
            hasAnyTexture.value ? (openBlock(), createElementBlock("div", _hoisted_19$a, [
              createBaseVNode("div", _hoisted_20$a, [
                _cache[48] || (_cache[48] = createBaseVNode("label", null, "UV Repeat", -1)),
                createBaseVNode("div", _hoisted_21$9, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.x ?? 1,
                    "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => updateTextureRepeat("x", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"]),
                  _cache[47] || (_cache[47] = createBaseVNode("span", { class: "separator" }, "x", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.y ?? 1,
                    "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => updateTextureRepeat("y", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ])
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, sections.textures]
          ])
        ]),
        createBaseVNode("div", _hoisted_22$9, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[30] || (_cache[30] = ($event) => toggleSection("environment"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.environment ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[49] || (_cache[49] = createBaseVNode("span", null, "Environment", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_23$9, [
            createBaseVNode("div", _hoisted_24$7, [
              _cache[50] || (_cache[50] = createBaseVNode("label", null, "Environment Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.envMapIntensity,
                "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => updateMaterial("envMapIntensity", $event)),
                min: 0,
                max: 3,
                step: 0.1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$7, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.flatShading,
                  onChange: _cache[32] || (_cache[32] = ($event) => updateMaterial("flatShading", $event.target.checked))
                }, null, 40, _hoisted_26$7),
                _cache[51] || (_cache[51] = createTextVNode(" Flat Shading ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_27$6, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.wireframe,
                  onChange: _cache[33] || (_cache[33] = ($event) => updateMaterial("wireframe", $event.target.checked))
                }, null, 40, _hoisted_28$6),
                _cache[52] || (_cache[52] = createTextVNode(" Wireframe ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$6, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Side", -1)),
              createBaseVNode("select", {
                value: material.side,
                onChange: _cache[34] || (_cache[34] = ($event) => updateMaterial("side", $event.target.value)),
                class: "type-select"
              }, [..._cache[53] || (_cache[53] = [
                createBaseVNode("option", { value: "front" }, "Front", -1),
                createBaseVNode("option", { value: "back" }, "Back", -1),
                createBaseVNode("option", { value: "double" }, "Double", -1)
              ])], 40, _hoisted_30$6)
            ])
          ], 512), [
            [vShow, sections.environment]
          ])
        ]),
        createBaseVNode("div", { class: "editor-actions" }, [
          createBaseVNode("button", {
            class: "action-btn",
            onClick: resetMaterial
          }, [..._cache[55] || (_cache[55] = [
            createBaseVNode("i", { class: "pi pi-refresh" }, null, -1),
            createTextVNode(" Reset ", -1)
          ])]),
          createBaseVNode("button", {
            class: "action-btn primary",
            onClick: saveMaterial
          }, [..._cache[56] || (_cache[56] = [
            createBaseVNode("i", { class: "pi pi-save" }, null, -1),
            createTextVNode(" Save as Preset ", -1)
          ])])
        ])
      ]);
    };
  }
});

const MaterialEditor = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-9e49decb"]]);

const _hoisted_1$h = { class: "asset-uploader" };
const _hoisted_2$h = {
  key: 0,
  class: "asset-preview"
};
const _hoisted_3$h = { class: "preview-content" };
const _hoisted_4$h = ["src"];
const _hoisted_5$h = {
  key: 1,
  class: "preview-icon"
};
const _hoisted_6$h = { class: "asset-info" };
const _hoisted_7$h = { class: "asset-name" };
const _hoisted_8$h = { class: "asset-meta" };
const _hoisted_9$g = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_10$f = { class: "upload-label" };
const _hoisted_11$e = { class: "upload-hint" };
const _hoisted_12$c = { class: "upload-formats" };
const _hoisted_13$b = ["accept", "multiple"];
const _hoisted_14$b = {
  key: 0,
  class: "upload-progress"
};
const _hoisted_15$b = { class: "progress-bar" };
const _hoisted_16$b = { class: "progress-text" };
const _hoisted_17$a = {
  key: 1,
  class: "error-message"
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "AssetUploader",
  props: {
    assetType: { default: "image" },
    label: {},
    multiple: { type: Boolean, default: false },
    maxSizeMB: { default: 100 },
    accept: {},
    buttonText: {}
  },
  emits: ["upload", "upload-multiple", "remove", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const isLoading = ref(false);
    const progress = ref(0);
    const progressText = ref("");
    const errorMessage = ref("");
    const assetName = ref("");
    const assetMeta = ref("");
    const previewImage = ref(null);
    const hasAsset = ref(false);
    const assetConfigs = {
      model: {
        formats: [".gltf", ".glb", ".obj", ".fbx", ".dae", ".usdz"],
        icon: "pi-box",
        hint: "Drop 3D model file"
      },
      pointcloud: {
        formats: [".ply", ".pcd", ".xyz", ".pts", ".las"],
        icon: "pi-th-large",
        hint: "Drop point cloud file"
      },
      texture: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".exr", ".hdr"],
        icon: "pi-image",
        hint: "Drop texture image"
      },
      material: {
        formats: [".json", ".mtl"],
        icon: "pi-palette",
        hint: "Drop material file"
      },
      hdri: {
        formats: [".hdr", ".exr", ".jpg", ".png"],
        icon: "pi-globe",
        hint: "Drop HDRI environment"
      },
      svg: {
        formats: [".svg"],
        icon: "pi-star",
        hint: "Drop SVG file"
      },
      spritesheet: {
        formats: [".png", ".jpg", ".webp", ".json"],
        icon: "pi-th-large",
        hint: "Drop sprite sheet"
      },
      lut: {
        formats: [".cube", ".3dl", ".png"],
        icon: "pi-sliders-h",
        hint: "Drop LUT file"
      },
      depth_map: {
        formats: [".png", ".jpg", ".exr"],
        icon: "pi-map",
        hint: "Drop depth map"
      },
      image: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".gif"],
        icon: "pi-image",
        hint: "Drop image file"
      },
      video: {
        formats: [".mp4", ".webm", ".mov"],
        icon: "pi-video",
        hint: "Drop video file"
      },
      audio: {
        formats: [".mp3", ".wav", ".ogg", ".m4a"],
        icon: "pi-volume-up",
        hint: "Drop audio file"
      }
    };
    const config = computed(() => assetConfigs[props.assetType] || assetConfigs.image);
    const acceptedFormats = computed(() => {
      if (props.accept) {
        return props.accept;
      }
      const formats = config.value.formats;
      return formats.map((f) => {
        if (f === ".jpg") return "image/jpeg";
        if (f === ".png") return "image/png";
        if (f === ".webp") return "image/webp";
        if (f === ".gif") return "image/gif";
        if (f === ".svg") return "image/svg+xml";
        if (f === ".mp4") return "video/mp4";
        if (f === ".webm") return "video/webm";
        if (f === ".mp3") return "audio/mpeg";
        if (f === ".wav") return "audio/wav";
        if (f === ".ogg") return "audio/ogg";
        return f;
      }).join(",");
    });
    const acceptedFormatsDisplay = computed(() => {
      return config.value.formats.join(", ");
    });
    const placeholderIcon = computed(() => config.value.icon);
    const hint = computed(() => config.value.hint);
    const label = computed(() => props.buttonText || props.label || `Upload ${props.assetType}`);
    const assetTypeIcon = computed(() => {
      return config.value.icon;
    });
    function openFilePicker() {
      if (hasAsset.value) return;
      fileInput.value?.click();
    }
    function onDragOver() {
      isDragging.value = true;
    }
    function onDragLeave() {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(files));
        } else {
          handleFile(files[0]);
        }
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(input.files));
        } else {
          handleFile(input.files[0]);
        }
      }
    }
    async function handleFile(file) {
      errorMessage.value = "";
      const sizeMB = file.size / (1024 * 1024);
      if (sizeMB > props.maxSizeMB) {
        errorMessage.value = `File too large (max ${props.maxSizeMB}MB)`;
        emit("error", errorMessage.value);
        return;
      }
      const ext = "." + file.name.split(".").pop()?.toLowerCase();
      const validFormats = props.accept ? props.accept.split(",").map((f) => f.trim().toLowerCase()) : config.value.formats;
      const isValidExt = validFormats.some((f) => f === ext || f.includes("*") || f.includes("/"));
      if (!isValidExt && !props.accept) {
        errorMessage.value = `Invalid format. Accepted: ${acceptedFormatsDisplay.value}`;
        emit("error", errorMessage.value);
        return;
      }
      isLoading.value = true;
      progress.value = 0;
      progressText.value = "Loading...";
      try {
        let dataUrl;
        if (file.type.startsWith("image/")) {
          dataUrl = await readFileAsDataUrl(file);
          previewImage.value = dataUrl;
        } else {
          previewImage.value = null;
        }
        assetName.value = file.name;
        assetMeta.value = formatFileSize(file.size);
        hasAsset.value = true;
        emit("upload", file, dataUrl);
      } catch (err) {
        errorMessage.value = "Failed to load file";
        emit("error", errorMessage.value);
      } finally {
        isLoading.value = false;
      }
    }
    function handleMultipleFiles(files) {
      const validFiles = files.filter((file) => {
        const ext = "." + file.name.split(".").pop()?.toLowerCase();
        const sizeMB = file.size / (1024 * 1024);
        return config.value.formats.includes(ext) && sizeMB <= props.maxSizeMB;
      });
      if (validFiles.length === 0) {
        errorMessage.value = "No valid files found";
        emit("error", errorMessage.value);
        return;
      }
      emit("upload-multiple", validFiles);
      assetName.value = `${validFiles.length} files`;
      assetMeta.value = formatFileSize(validFiles.reduce((sum, f) => sum + f.size, 0));
      hasAsset.value = true;
    }
    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.onprogress = (e) => {
          if (e.lengthComputable) {
            progress.value = Math.round(e.loaded / e.total * 100);
            progressText.value = `${progress.value}%`;
          }
        };
        reader.readAsDataURL(file);
      });
    }
    function formatFileSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
    function removeAsset() {
      hasAsset.value = false;
      assetName.value = "";
      assetMeta.value = "";
      previewImage.value = null;
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", {
          class: normalizeClass(["drop-zone", { "drag-over": isDragging.value, "has-asset": hasAsset.value }]),
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasAsset.value ? (openBlock(), createElementBlock("div", _hoisted_2$h, [
            createBaseVNode("div", _hoisted_3$h, [
              previewImage.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: previewImage.value,
                class: "preview-image"
              }, null, 8, _hoisted_4$h)) : (openBlock(), createElementBlock("div", _hoisted_5$h, [
                createBaseVNode("i", {
                  class: normalizeClass(["pi", assetTypeIcon.value])
                }, null, 2)
              ]))
            ]),
            createBaseVNode("div", _hoisted_6$h, [
              createBaseVNode("span", _hoisted_7$h, toDisplayString(assetName.value), 1),
              createBaseVNode("span", _hoisted_8$h, toDisplayString(assetMeta.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeAsset, ["stop"]),
              title: "Remove"
            }, [..._cache[0] || (_cache[0] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_9$g, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", placeholderIcon.value])
            }, null, 2),
            createBaseVNode("span", _hoisted_10$f, toDisplayString(label.value), 1),
            createBaseVNode("span", _hoisted_11$e, toDisplayString(hint.value), 1),
            createBaseVNode("span", _hoisted_12$c, toDisplayString(acceptedFormatsDisplay.value), 1)
          ]))
        ], 34),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats.value,
          multiple: __props.multiple,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 40, _hoisted_13$b),
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_14$b, [
          createBaseVNode("div", _hoisted_15$b, [
            createBaseVNode("div", {
              class: "progress-fill",
              style: normalizeStyle({ width: `${progress.value}%` })
            }, null, 4)
          ]),
          createBaseVNode("span", _hoisted_16$b, toDisplayString(progressText.value), 1)
        ])) : createCommentVNode("", true),
        errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_17$a, [
          _cache[1] || (_cache[1] = createBaseVNode("i", { class: "pi pi-exclamation-triangle" }, null, -1)),
          createTextVNode(" " + toDisplayString(errorMessage.value), 1)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetUploader = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-b09796ed"]]);

const _hoisted_1$g = { class: "environment-settings" };
const _hoisted_2$g = { class: "settings-header" };
const _hoisted_3$g = { class: "enable-toggle" };
const _hoisted_4$g = ["checked"];
const _hoisted_5$g = {
  key: 0,
  class: "settings-content"
};
const _hoisted_6$g = { class: "setting-group" };
const _hoisted_7$g = {
  key: 0,
  class: "setting-group"
};
const _hoisted_8$g = { class: "preset-grid" };
const _hoisted_9$f = ["onClick"];
const _hoisted_10$e = { class: "setting-group" };
const _hoisted_11$d = { class: "setting-group" };
const _hoisted_12$b = { class: "rotation-control" };
const _hoisted_13$a = { class: "setting-group" };
const _hoisted_14$a = { class: "checkbox-label" };
const _hoisted_15$a = ["checked"];
const _hoisted_16$a = {
  key: 1,
  class: "setting-group"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "EnvironmentSettings",
  props: {
    modelValue: {},
    config: {}
  },
  emits: ["update:modelValue", "load-hdri", "update", "load", "clear"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultConfig = {
      enabled: false,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true,
      toneMapping: true
    };
    const configState = reactive({ ...defaultConfig, ...props.modelValue, ...props.config });
    const selectedPreset = ref(null);
    const config = configState;
    const presets = [
      { id: "studio", name: "Studio", color: "linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%)" },
      { id: "outdoor", name: "Outdoor", color: "linear-gradient(135deg, #87CEEB 0%, #98D8C8 100%)" },
      { id: "sunset", name: "Sunset", color: "linear-gradient(135deg, #ff6b6b 0%, #ffa600 100%)" },
      { id: "night", name: "Night", color: "linear-gradient(135deg, #1a1a3e 0%, #0d0d1a 100%)" }
    ];
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    function updateConfig(key, value) {
      configState[key] = value;
      emitUpdate();
    }
    function onHdriUpload(file, dataUrl) {
      if (dataUrl) {
        configState.url = dataUrl;
        selectedPreset.value = null;
        emitUpdate();
        emit("load-hdri", dataUrl);
        emit("load", file);
      }
    }
    function onHdriRemove() {
      configState.url = void 0;
      emitUpdate();
      emit("clear");
    }
    function applyPreset(preset) {
      selectedPreset.value = preset.id;
      if (preset.url) {
        configState.url = preset.url;
        emit("load-hdri", preset.url);
      }
      emitUpdate();
    }
    function emitUpdate() {
      emit("update:modelValue", { ...configState });
      emit("update", { ...configState });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$g, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-globe" }),
            createBaseVNode("span", null, "Environment")
          ], -1)),
          createBaseVNode("label", _hoisted_3$g, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: unref(config).enabled,
              onChange: _cache[0] || (_cache[0] = ($event) => updateConfig("enabled", $event.target.checked))
            }, null, 40, _hoisted_4$g),
            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "toggle-label" }, "Enabled", -1))
          ])
        ]),
        unref(config).enabled ? (openBlock(), createElementBlock("div", _hoisted_5$g, [
          createBaseVNode("div", _hoisted_6$g, [
            _cache[8] || (_cache[8] = createBaseVNode("label", { class: "group-label" }, "Environment Map (HDRI)", -1)),
            createVNode(AssetUploader, {
              assetType: "hdri",
              label: "Upload HDRI",
              onUpload: onHdriUpload,
              onRemove: onHdriRemove
            })
          ]),
          !unref(config).url ? (openBlock(), createElementBlock("div", _hoisted_7$g, [
            _cache[9] || (_cache[9] = createBaseVNode("label", { class: "group-label" }, "Quick Presets", -1)),
            createBaseVNode("div", _hoisted_8$g, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.id,
                  class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                  onClick: ($event) => applyPreset(preset)
                }, [
                  createBaseVNode("div", {
                    class: "preset-preview",
                    style: normalizeStyle({ background: preset.color })
                  }, null, 4),
                  createBaseVNode("span", null, toDisplayString(preset.name), 1)
                ], 10, _hoisted_9$f);
              }), 64))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_10$e, [
            _cache[10] || (_cache[10] = createBaseVNode("label", null, "Intensity", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).intensity,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => updateConfig("intensity", $event)),
              min: 0,
              max: 3,
              step: 0.1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_11$d, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Rotation", -1)),
            createBaseVNode("div", _hoisted_12$b, [
              createVNode(unref(AngleDial), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateConfig("rotation", $event)),
                size: 36
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateConfig("rotation", $event)),
                unit: "Â°"
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_13$a, [
            createBaseVNode("label", _hoisted_14$a, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: unref(config).useAsBackground,
                onChange: _cache[4] || (_cache[4] = ($event) => updateConfig("useAsBackground", $event.target.checked))
              }, null, 40, _hoisted_15$a),
              _cache[12] || (_cache[12] = createTextVNode(" Use as Background ", -1))
            ])
          ]),
          unref(config).useAsBackground ? (openBlock(), createElementBlock("div", _hoisted_16$a, [
            _cache[13] || (_cache[13] = createBaseVNode("label", null, "Background Blur", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).backgroundBlur,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateConfig("backgroundBlur", $event)),
              min: 0,
              max: 1,
              step: 0.05
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const EnvironmentSettings = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-5cfc9496"]]);

const _hoisted_1$f = { class: "assets-panel" };
const _hoisted_2$f = { class: "asset-tabs" };
const _hoisted_3$f = ["onClick", "title"];
const _hoisted_4$f = { class: "tab-icon" };
const _hoisted_5$f = { class: "tab-label" };
const _hoisted_6$f = { class: "asset-content" };
const _hoisted_7$f = {
  key: 0,
  class: "tab-panel"
};
const _hoisted_8$f = { class: "panel-toolbar" };
const _hoisted_9$e = ["value"];
const _hoisted_10$d = { class: "material-list" };
const _hoisted_11$c = ["onClick"];
const _hoisted_12$a = { class: "material-name" };
const _hoisted_13$9 = ["onClick"];
const _hoisted_14$9 = {
  key: 1,
  class: "tab-panel"
};
const _hoisted_15$9 = { class: "panel-toolbar" };
const _hoisted_16$9 = { class: "svg-list" };
const _hoisted_17$9 = ["onClick"];
const _hoisted_18$9 = { class: "svg-preview" };
const _hoisted_19$9 = { class: "path-count" };
const _hoisted_20$9 = { class: "svg-name" };
const _hoisted_21$8 = { class: "svg-actions" };
const _hoisted_22$8 = ["onClick"];
const _hoisted_23$8 = ["onClick"];
const _hoisted_24$6 = ["onClick"];
const _hoisted_25$6 = {
  key: 0,
  class: "svg-details"
};
const _hoisted_26$6 = { class: "path-list" };
const _hoisted_27$5 = { class: "path-name" };
const _hoisted_28$5 = { class: "path-config" };
const _hoisted_29$5 = ["value", "onInput"];
const _hoisted_30$5 = ["value", "onInput"];
const _hoisted_31$3 = {
  key: 2,
  class: "tab-panel"
};
const _hoisted_32$3 = { class: "panel-toolbar" };
const _hoisted_33$3 = { class: "mesh-list" };
const _hoisted_34$3 = ["onClick"];
const _hoisted_35$3 = { class: "mesh-icon" };
const _hoisted_36$3 = { key: 0 };
const _hoisted_37$3 = { key: 1 };
const _hoisted_38$3 = { key: 2 };
const _hoisted_39$3 = { class: "mesh-info" };
const _hoisted_40$2 = { class: "mesh-name" };
const _hoisted_41$1 = { class: "mesh-verts" };
const _hoisted_42$1 = ["onClick"];
const _hoisted_43$1 = {
  key: 0,
  class: "mesh-details"
};
const _hoisted_44$1 = { class: "detail-row" };
const _hoisted_45$1 = { class: "value" };
const _hoisted_46$1 = { class: "detail-row" };
const _hoisted_47$1 = { class: "value" };
const _hoisted_48$1 = { class: "detail-row" };
const _hoisted_49$1 = { class: "value" };
const _hoisted_50 = {
  key: 3,
  class: "tab-panel"
};
const _hoisted_51 = { class: "panel-toolbar" };
const _hoisted_52 = { class: "sprite-list" };
const _hoisted_53 = ["onClick"];
const _hoisted_54 = ["src"];
const _hoisted_55 = { class: "sprite-info" };
const _hoisted_56 = { class: "sprite-name" };
const _hoisted_57 = { class: "sprite-frames" };
const _hoisted_58 = ["onClick"];
const _hoisted_59 = {
  key: 0,
  class: "sprite-import-dialog"
};
const _hoisted_60 = {
  key: 0,
  class: "sprite-config"
};
const _hoisted_61 = {
  key: 4,
  class: "tab-panel"
};
const _hoisted_62 = {
  key: 0,
  class: "loading-overlay"
};
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "AssetsPanel",
  emits: ["create-layers-from-svg", "use-mesh-as-emitter", "environment-update", "environment-load", "environment-clear"],
  setup(__props, { emit: __emit }) {
    const assetStore = useAssetStore();
    useCompositorStore();
    const tabs = [
      { id: "materials", label: "Materials", icon: "â—‰", tooltip: "PBR Materials" },
      { id: "svg", label: "SVG", icon: "âœŽ", tooltip: "SVG Logos & Shapes" },
      { id: "meshes", label: "Meshes", icon: "â—‡", tooltip: "Mesh Particles" },
      { id: "sprites", label: "Sprites", icon: "â–¦", tooltip: "Sprite Sheets" },
      { id: "environment", label: "Env", icon: "â˜€", tooltip: "Environment Map" }
    ];
    const activeTab = ref("materials");
    const materialPresets = [
      "chrome",
      "gold",
      "silver",
      "copper",
      "brass",
      "glass",
      "plastic",
      "rubber",
      "wood",
      "concrete",
      "emissive",
      "holographic"
    ];
    const selectedPreset = ref("");
    const materials = computed(() => assetStore.materialList);
    const svgDocuments = computed(() => assetStore.svgDocumentList);
    const meshParticles = computed(() => assetStore.meshParticleList);
    const spriteSheets = computed(() => assetStore.spriteSheetList);
    const environment = computed(() => assetStore.environment);
    const selectedMaterial = computed(() => assetStore.selectedMaterial);
    const selectedSvg = computed(() => assetStore.selectedSvgDocument);
    const selectedMesh = computed(() => assetStore.selectedMeshParticle);
    const selectedPrimitive = ref("");
    const showSpriteImport = ref(false);
    const pendingSpriteFile = ref(null);
    const spriteColumns = ref(4);
    const spriteRows = ref(4);
    const spriteFrameRate = ref(24);
    function createMaterial() {
      assetStore.createEmptyMaterial("New Material");
    }
    function createFromPreset() {
      if (selectedPreset.value) {
        assetStore.createMaterialFromPreset(selectedPreset.value);
        selectedPreset.value = "";
      }
    }
    function selectMaterial(id) {
      assetStore.selectedMaterialId = id;
    }
    function deleteMaterial(id) {
      assetStore.deleteMaterial(id);
    }
    function onMaterialUpdate(updates) {
      if (assetStore.selectedMaterialId) {
        assetStore.updateMaterial(assetStore.selectedMaterialId, updates);
      }
    }
    function onTextureUpload(textureType, file) {
      if (assetStore.selectedMaterialId) {
        assetStore.setMaterialTexture(assetStore.selectedMaterialId, textureType, file);
      }
    }
    function getMaterialPreviewStyle(mat) {
      return {
        backgroundColor: mat.config.color || "#808080",
        backgroundImage: mat.config.albedoMap ? `url(${mat.config.albedoMap})` : "none",
        backgroundSize: "cover"
      };
    }
    async function onSvgUpload(file) {
      await assetStore.importSvgFromFile(file);
    }
    function selectSvg(id) {
      assetStore.selectedSvgId = id;
    }
    function deleteSvg(id) {
      assetStore.deleteSvgDocument(id);
    }
    function updatePathDepth(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 0;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { depth: value });
    }
    function updatePathExtrusion(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 2;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { extrusionDepth: value });
    }
    function createLayersFromSvg(svgId) {
      emit("create-layers-from-svg", svgId);
    }
    function registerSvgAsMesh(svgId) {
      const svg = assetStore.svgDocuments.get(svgId);
      if (!svg) return;
      svg.document.paths.forEach((_, i) => {
        assetStore.registerSvgPathAsMesh(svgId, i);
      });
      activeTab.value = "meshes";
    }
    function addPrimitiveMesh() {
      if (selectedPrimitive.value) {
        assetStore.registerPrimitiveMesh(selectedPrimitive.value);
        selectedPrimitive.value = "";
      }
    }
    function selectMesh(id) {
      assetStore.selectedMeshParticleId = id;
    }
    function deleteMesh(id) {
      assetStore.deleteMeshParticle(id);
    }
    function useAsEmitterShape() {
      if (assetStore.selectedMeshParticleId) {
        emit("use-mesh-as-emitter", assetStore.selectedMeshParticleId);
      }
    }
    function onSpriteFileSelect(file) {
      pendingSpriteFile.value = file;
    }
    async function importSpriteSheet() {
      if (!pendingSpriteFile.value) return;
      await assetStore.importSpriteSheet(
        pendingSpriteFile.value,
        spriteColumns.value,
        spriteRows.value,
        { frameRate: spriteFrameRate.value }
      );
      cancelSpriteImport();
    }
    function cancelSpriteImport() {
      showSpriteImport.value = false;
      pendingSpriteFile.value = null;
      spriteColumns.value = 4;
      spriteRows.value = 4;
      spriteFrameRate.value = 24;
    }
    function selectSprite(id) {
      assetStore.selectedSpriteSheetId = id;
    }
    function deleteSprite(id) {
      assetStore.deleteSpriteSheet(id);
    }
    function onEnvironmentUpdate(settings) {
      assetStore.updateEnvironment(settings);
      emit("environment-update", settings);
    }
    async function onEnvironmentLoad(file) {
      await assetStore.loadEnvironment(file);
      emit("environment-load", assetStore.environment);
    }
    function onEnvironmentClear() {
      assetStore.clearEnvironment();
      emit("environment-clear");
    }
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("div", _hoisted_2$f, [
          (openBlock(), createElementBlock(Fragment, null, renderList(tabs, (tab) => {
            return createBaseVNode("button", {
              key: tab.id,
              class: normalizeClass({ active: activeTab.value === tab.id }),
              onClick: ($event) => activeTab.value = tab.id,
              title: tab.tooltip
            }, [
              createBaseVNode("span", _hoisted_4$f, toDisplayString(tab.icon), 1),
              createBaseVNode("span", _hoisted_5$f, toDisplayString(tab.label), 1)
            ], 10, _hoisted_3$f);
          }), 64))
        ]),
        createBaseVNode("div", _hoisted_6$f, [
          activeTab.value === "materials" ? (openBlock(), createElementBlock("div", _hoisted_7$f, [
            createBaseVNode("div", _hoisted_8$f, [
              createBaseVNode("button", {
                onClick: createMaterial,
                title: "New Material"
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" New ", -1)
              ])]),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
                onChange: createFromPreset,
                class: "preset-select"
              }, [
                _cache[8] || (_cache[8] = createBaseVNode("option", { value: "" }, "From Preset...", -1)),
                (openBlock(), createElementBlock(Fragment, null, renderList(materialPresets, (preset) => {
                  return createBaseVNode("option", {
                    key: preset,
                    value: preset
                  }, toDisplayString(preset), 9, _hoisted_9$e);
                }), 64))
              ], 544), [
                [vModelSelect, selectedPreset.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_10$d, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(materials.value, (mat) => {
                return openBlock(), createElementBlock("div", {
                  key: mat.id,
                  class: normalizeClass(["material-item", { selected: mat.id === unref(assetStore).selectedMaterialId }]),
                  onClick: ($event) => selectMaterial(mat.id)
                }, [
                  createBaseVNode("div", {
                    class: "material-preview",
                    style: normalizeStyle(getMaterialPreviewStyle(mat))
                  }, null, 4),
                  createBaseVNode("span", _hoisted_12$a, toDisplayString(mat.name), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMaterial(mat.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[9] || (_cache[9] = [
                    createBaseVNode("span", { class: "icon" }, "Ã—", -1)
                  ])], 8, _hoisted_13$9)
                ], 10, _hoisted_11$c);
              }), 128))
            ]),
            selectedMaterial.value ? (openBlock(), createBlock(MaterialEditor, {
              key: 0,
              "material-id": selectedMaterial.value.id,
              config: selectedMaterial.value.config,
              onUpdate: onMaterialUpdate,
              onTextureUpload
            }, null, 8, ["material-id", "config"])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "svg" ? (openBlock(), createElementBlock("div", _hoisted_14$9, [
            createBaseVNode("div", _hoisted_15$9, [
              createVNode(AssetUploader, {
                accept: ".svg",
                "asset-type": "svg",
                onUpload: onSvgUpload,
                "button-text": "Import SVG"
              })
            ]),
            createBaseVNode("div", _hoisted_16$9, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(svgDocuments.value, (svg) => {
                return openBlock(), createElementBlock("div", {
                  key: svg.id,
                  class: normalizeClass(["svg-item", { selected: svg.id === unref(assetStore).selectedSvgId }]),
                  onClick: ($event) => selectSvg(svg.id)
                }, [
                  createBaseVNode("div", _hoisted_18$9, [
                    createBaseVNode("span", _hoisted_19$9, toDisplayString(svg.document.paths.length) + " paths", 1)
                  ]),
                  createBaseVNode("span", _hoisted_20$9, toDisplayString(svg.name), 1),
                  createBaseVNode("div", _hoisted_21$8, [
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => createLayersFromSvg(svg.id), ["stop"]),
                      title: "Create Layers"
                    }, [..._cache[10] || (_cache[10] = [
                      createBaseVNode("span", { class: "icon" }, "â†—", -1)
                    ])], 8, _hoisted_22$8),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => registerSvgAsMesh(svg.id), ["stop"]),
                      title: "Use as Particle"
                    }, [..._cache[11] || (_cache[11] = [
                      createBaseVNode("span", { class: "icon" }, "âœ¦", -1)
                    ])], 8, _hoisted_23$8),
                    createBaseVNode("button", {
                      class: "delete-btn",
                      onClick: withModifiers(($event) => deleteSvg(svg.id), ["stop"]),
                      title: "Delete"
                    }, [..._cache[12] || (_cache[12] = [
                      createBaseVNode("span", { class: "icon" }, "Ã—", -1)
                    ])], 8, _hoisted_24$6)
                  ])
                ], 10, _hoisted_17$9);
              }), 128))
            ]),
            selectedSvg.value ? (openBlock(), createElementBlock("div", _hoisted_25$6, [
              createBaseVNode("h4", null, toDisplayString(selectedSvg.value.name), 1),
              createBaseVNode("div", _hoisted_26$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(selectedSvg.value.document.paths, (path, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: path.id,
                    class: "path-item"
                  }, [
                    createBaseVNode("span", _hoisted_27$5, toDisplayString(path.id), 1),
                    createBaseVNode("div", {
                      class: "path-color",
                      style: normalizeStyle({ backgroundColor: path.fill || path.stroke || "#888" })
                    }, null, 4),
                    createBaseVNode("div", _hoisted_28$5, [
                      createBaseVNode("label", null, [
                        _cache[13] || (_cache[13] = createTextVNode(" Depth ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.depth || 0,
                          onInput: ($event) => updatePathDepth(i, $event),
                          step: "1"
                        }, null, 40, _hoisted_29$5)
                      ]),
                      createBaseVNode("label", null, [
                        _cache[14] || (_cache[14] = createTextVNode(" Extrusion ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.extrusionDepth || 2,
                          onInput: ($event) => updatePathExtrusion(i, $event),
                          step: "0.5"
                        }, null, 40, _hoisted_30$5)
                      ])
                    ])
                  ]);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "meshes" ? (openBlock(), createElementBlock("div", _hoisted_31$3, [
            createBaseVNode("div", _hoisted_32$3, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedPrimitive.value = $event),
                onChange: addPrimitiveMesh,
                class: "primitive-select"
              }, [..._cache[15] || (_cache[15] = [
                createStaticVNode('<option value="" data-v-e9a1d2d1>Add Primitive...</option><option value="cube" data-v-e9a1d2d1>Cube</option><option value="sphere" data-v-e9a1d2d1>Sphere</option><option value="cone" data-v-e9a1d2d1>Cone</option><option value="cylinder" data-v-e9a1d2d1>Cylinder</option><option value="torus" data-v-e9a1d2d1>Torus</option><option value="tetrahedron" data-v-e9a1d2d1>Tetrahedron</option><option value="octahedron" data-v-e9a1d2d1>Octahedron</option><option value="icosahedron" data-v-e9a1d2d1>Icosahedron</option>', 9)
              ])], 544), [
                [vModelSelect, selectedPrimitive.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_33$3, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(meshParticles.value, (mesh) => {
                return openBlock(), createElementBlock("div", {
                  key: mesh.id,
                  class: normalizeClass(["mesh-item", { selected: mesh.id === unref(assetStore).selectedMeshParticleId }]),
                  onClick: ($event) => selectMesh(mesh.id)
                }, [
                  createBaseVNode("div", _hoisted_35$3, [
                    mesh.source === "primitive" ? (openBlock(), createElementBlock("span", _hoisted_36$3, "â—‡")) : mesh.source === "svg" ? (openBlock(), createElementBlock("span", _hoisted_37$3, "â—ˆ")) : (openBlock(), createElementBlock("span", _hoisted_38$3, "â—†"))
                  ]),
                  createBaseVNode("div", _hoisted_39$3, [
                    createBaseVNode("span", _hoisted_40$2, toDisplayString(mesh.name), 1),
                    createBaseVNode("span", _hoisted_41$1, toDisplayString(mesh.registration.vertexCount) + " verts", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMesh(mesh.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[16] || (_cache[16] = [
                    createBaseVNode("span", { class: "icon" }, "Ã—", -1)
                  ])], 8, _hoisted_42$1)
                ], 10, _hoisted_34$3);
              }), 128))
            ]),
            selectedMesh.value ? (openBlock(), createElementBlock("div", _hoisted_43$1, [
              createBaseVNode("h4", null, toDisplayString(selectedMesh.value.name), 1),
              createBaseVNode("div", _hoisted_44$1, [
                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "label" }, "Source:", -1)),
                createBaseVNode("span", _hoisted_45$1, toDisplayString(selectedMesh.value.source), 1)
              ]),
              createBaseVNode("div", _hoisted_46$1, [
                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "label" }, "Vertices:", -1)),
                createBaseVNode("span", _hoisted_47$1, toDisplayString(selectedMesh.value.registration.vertexCount), 1)
              ]),
              createBaseVNode("div", _hoisted_48$1, [
                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "label" }, "Bounding Radius:", -1)),
                createBaseVNode("span", _hoisted_49$1, toDisplayString(selectedMesh.value.registration.boundingSphere.radius.toFixed(2)), 1)
              ]),
              createBaseVNode("button", {
                class: "action-btn",
                onClick: useAsEmitterShape
              }, " Use as Emitter Shape ")
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "sprites" ? (openBlock(), createElementBlock("div", _hoisted_50, [
            createBaseVNode("div", _hoisted_51, [
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => showSpriteImport.value = true),
                title: "Import Sprite Sheet"
              }, [..._cache[20] || (_cache[20] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" Import ", -1)
              ])])
            ]),
            createBaseVNode("div", _hoisted_52, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(spriteSheets.value, (sprite) => {
                return openBlock(), createElementBlock("div", {
                  key: sprite.id,
                  class: normalizeClass(["sprite-item", { selected: sprite.id === unref(assetStore).selectedSpriteSheetId }]),
                  onClick: ($event) => selectSprite(sprite.id)
                }, [
                  createBaseVNode("img", {
                    src: sprite.textureUrl,
                    class: "sprite-preview"
                  }, null, 8, _hoisted_54),
                  createBaseVNode("div", _hoisted_55, [
                    createBaseVNode("span", _hoisted_56, toDisplayString(sprite.name), 1),
                    createBaseVNode("span", _hoisted_57, toDisplayString(sprite.config.totalFrames) + " frames", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteSprite(sprite.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[21] || (_cache[21] = [
                    createBaseVNode("span", { class: "icon" }, "Ã—", -1)
                  ])], 8, _hoisted_58)
                ], 10, _hoisted_53);
              }), 128))
            ]),
            showSpriteImport.value ? (openBlock(), createElementBlock("div", _hoisted_59, [
              _cache[25] || (_cache[25] = createBaseVNode("h4", null, "Import Sprite Sheet", -1)),
              createVNode(AssetUploader, {
                accept: "image/*",
                "asset-type": "sprite",
                onUpload: onSpriteFileSelect,
                "button-text": "Select Image"
              }),
              pendingSpriteFile.value ? (openBlock(), createElementBlock("div", _hoisted_60, [
                createBaseVNode("label", null, [
                  _cache[22] || (_cache[22] = createTextVNode(" Columns ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => spriteColumns.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteColumns.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[23] || (_cache[23] = createTextVNode(" Rows ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => spriteRows.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteRows.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[24] || (_cache[24] = createTextVNode(" Frame Rate ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => spriteFrameRate.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteFrameRate.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("div", { class: "dialog-actions" }, [
                  createBaseVNode("button", {
                    onClick: importSpriteSheet,
                    class: "confirm-btn"
                  }, "Import"),
                  createBaseVNode("button", {
                    onClick: cancelSpriteImport,
                    class: "cancel-btn"
                  }, "Cancel")
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "environment" ? (openBlock(), createElementBlock("div", _hoisted_61, [
            createVNode(EnvironmentSettings, {
              config: environment.value,
              onUpdate: onEnvironmentUpdate,
              onLoad: onEnvironmentLoad,
              onClear: onEnvironmentClear
            }, null, 8, ["config"])
          ])) : createCommentVNode("", true)
        ]),
        unref(assetStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_62, [..._cache[26] || (_cache[26] = [
          createBaseVNode("div", { class: "spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(assetStore).lastError ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "error-toast",
          onClick: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(assetStore).clearError && unref(assetStore).clearError(...args))
        }, toDisplayString(unref(assetStore).lastError), 1)) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-e9a1d2d1"]]);

function isWebCodecsSupported() {
  return typeof VideoEncoder !== "undefined" && typeof VideoFrame !== "undefined";
}
async function getSupportedCodecs() {
  if (!isWebCodecsSupported()) return [];
  const codecs = [];
  const testConfigs = [
    { codec: "avc1.42E01F", name: "avc" },
    // H.264 Baseline
    { codec: "avc1.640028", name: "avc" },
    // H.264 High
    { codec: "vp9", name: "vp9" },
    { codec: "vp8", name: "vp8" }
  ];
  for (const { codec, name } of testConfigs) {
    try {
      const support = await VideoEncoder.isConfigSupported({
        codec,
        width: 1920,
        height: 1080,
        bitrate: 5e6
      });
      if (support.supported && !codecs.includes(name)) {
        codecs.push(name);
      }
    } catch {
    }
  }
  return codecs;
}
class WebCodecsVideoEncoder {
  config;
  encoder = null;
  webmMuxer = null;
  mp4Muxer = null;
  frameCount = 0;
  totalBytesWritten = 0;
  onProgress;
  constructor(config) {
    this.config = config;
  }
  /**
   * Initialize the encoder
   */
  async initialize(onProgress) {
    if (!isWebCodecsSupported()) {
      throw new Error("WebCodecs API is not supported in this browser");
    }
    this.onProgress = onProgress;
    this.frameCount = 0;
    this.totalBytesWritten = 0;
    this.webmMuxer = null;
    this.mp4Muxer = null;
    const codecString = this.getCodecString();
    const bitrate = this.getBitrate();
    const support = await VideoEncoder.isConfigSupported({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate
    });
    if (!support.supported) {
      throw new Error(`Unsupported encoder configuration: ${codecString}`);
    }
    if (this.config.codec === "avc") {
      this.mp4Muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: "avc",
          width: this.config.width,
          height: this.config.height
        },
        fastStart: "in-memory"
        // Moves moov atom to beginning for streaming
      });
    } else {
      const webmCodec = this.config.codec === "vp9" ? "V_VP9" : "V_VP8";
      this.webmMuxer = new Muxer$1({
        target: new ArrayBufferTarget$1(),
        video: {
          codec: webmCodec,
          width: this.config.width,
          height: this.config.height
        }
      });
    }
    this.encoder = new VideoEncoder({
      output: (chunk, metadata) => {
        this.handleChunk(chunk, metadata);
      },
      error: (error) => {
        exportLogger.error("VideoEncoder: Encoding error:", error);
        throw error;
      }
    });
    this.encoder.configure({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate,
      framerate: this.config.frameRate
    });
  }
  /**
   * Encode a single frame
   */
  async encodeFrame(imageData, frameIndex, totalFrames, keyFrame = false) {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    let frame;
    if (imageData instanceof ImageData) {
      frame = new VideoFrame(imageData.data, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate,
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        format: "RGBA"
      });
    } else {
      frame = new VideoFrame(imageData, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate
      });
    }
    const isKeyFrame = keyFrame || frameIndex === 0 || frameIndex % 30 === 0;
    this.encoder.encode(frame, { keyFrame: isKeyFrame });
    frame.close();
    this.frameCount++;
    if (this.onProgress) {
      this.onProgress({
        framesEncoded: this.frameCount,
        totalFrames,
        percentage: this.frameCount / totalFrames * 100,
        bytesWritten: this.totalBytesWritten
      });
    }
  }
  /**
   * Finish encoding and return the video blob
   */
  async finalize() {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    await this.encoder.flush();
    this.encoder.close();
    this.encoder = null;
    let blob;
    let mimeType;
    if (this.mp4Muxer) {
      this.mp4Muxer.finalize();
      const buffer = this.mp4Muxer.target.buffer;
      blob = new Blob([buffer], { type: "video/mp4" });
      mimeType = "video/mp4";
      this.mp4Muxer = null;
    } else if (this.webmMuxer) {
      this.webmMuxer.finalize();
      const buffer = this.webmMuxer.target.buffer;
      blob = new Blob([buffer], { type: "video/webm" });
      mimeType = "video/webm";
      this.webmMuxer = null;
    } else {
      throw new Error("No muxer initialized");
    }
    return {
      blob,
      mimeType,
      duration: this.frameCount / this.config.frameRate,
      frameCount: this.frameCount,
      size: blob.size
    };
  }
  /**
   * Cancel encoding
   */
  cancel() {
    if (this.encoder) {
      this.encoder.close();
      this.encoder = null;
    }
    this.webmMuxer = null;
    this.mp4Muxer = null;
  }
  // ============================================================================
  // Private Methods
  // ============================================================================
  handleChunk(chunk, metadata) {
    if (this.mp4Muxer) {
      this.mp4Muxer.addVideoChunk(chunk, metadata);
    } else if (this.webmMuxer) {
      this.webmMuxer.addVideoChunk(chunk, metadata);
    }
    this.totalBytesWritten += chunk.byteLength;
  }
  getCodecString() {
    switch (this.config.codec) {
      case "avc":
        return "avc1.640028";
      case "vp9":
        return "vp09.00.10.08";
      case "vp8":
        return "vp8";
      default:
        return "avc1.640028";
    }
  }
  getBitrate() {
    if (this.config.bitrate) {
      return this.config.bitrate;
    }
    const pixels = this.config.width * this.config.height;
    const baseRate = pixels * this.config.frameRate;
    switch (this.config.quality) {
      case "low":
        return Math.round(baseRate * 0.05);
      case "medium":
        return Math.round(baseRate * 0.1);
      case "high":
        return Math.round(baseRate * 0.2);
      case "lossless":
        return Math.round(baseRate * 0.5);
      default:
        return Math.round(baseRate * 0.1);
    }
  }
}
function downloadVideo(video, filename) {
  const extension = video.mimeType.includes("webm") ? "webm" : "mp4";
  const fullFilename = filename.includes(".") ? filename : `${filename}.${extension}`;
  const url = URL.createObjectURL(video.blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fullFilename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

const _hoisted_1$e = { class: "export-panel" };
const _hoisted_2$e = { class: "panel-content" };
const _hoisted_3$e = { class: "control-section" };
const _hoisted_4$e = { class: "control-row" };
const _hoisted_5$e = ["disabled"];
const _hoisted_6$e = ["value"];
const _hoisted_7$e = { class: "control-row" };
const _hoisted_8$e = ["disabled"];
const _hoisted_9$d = { class: "control-section" };
const _hoisted_10$c = { class: "info-grid" };
const _hoisted_11$b = { class: "info-item" };
const _hoisted_12$9 = { class: "info-value" };
const _hoisted_13$8 = { class: "info-item" };
const _hoisted_14$8 = { class: "info-value" };
const _hoisted_15$8 = { class: "info-item" };
const _hoisted_16$8 = { class: "info-value" };
const _hoisted_17$8 = { class: "info-item" };
const _hoisted_18$8 = { class: "info-value" };
const _hoisted_19$8 = {
  key: 0,
  class: "progress-section"
};
const _hoisted_20$8 = { class: "progress-header" };
const _hoisted_21$7 = { key: 0 };
const _hoisted_22$7 = { class: "progress-bar" };
const _hoisted_23$7 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_24$5 = { class: "actions-section" };
const _hoisted_25$5 = ["disabled"];
const _hoisted_26$5 = {
  key: 1,
  class: "warning-message"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ExportPanel",
  setup(__props) {
    const store = useCompositorStore();
    const webCodecsSupported = ref(false);
    const availableCodecs = ref([]);
    const selectedCodec = ref("avc");
    const selectedQuality = ref("high");
    const isExporting = ref(false);
    const exportComplete = ref(false);
    const encodedVideo = ref(null);
    const currentEncoder = ref(null);
    const exportProgress = ref({
      framesEncoded: 0,
      totalFrames: 0,
      percentage: 0,
      bytesWritten: 0
    });
    const activeComp = computed(() => store.getActiveComp());
    const outputWidth = computed(() => activeComp.value?.settings.width || 1024);
    const outputHeight = computed(() => activeComp.value?.settings.height || 1024);
    const frameRate = computed(() => activeComp.value?.settings.fps || 16);
    const totalFrames = computed(() => activeComp.value?.settings.frameCount || 81);
    const duration = computed(() => {
      const seconds = totalFrames.value / frameRate.value;
      const m = Math.floor(seconds / 60);
      const s = (seconds % 60).toFixed(2);
      return m > 0 ? `${m}m ${s}s` : `${s}s`;
    });
    const canExport = computed(() => webCodecsSupported.value && !isExporting.value && store.layers.length > 0);
    const exportStatusText = computed(() => {
      if (exportComplete.value) return "Export complete!";
      if (isExporting.value) return "Encoding...";
      return "Ready";
    });
    onMounted(async () => {
      webCodecsSupported.value = isWebCodecsSupported();
      if (webCodecsSupported.value) {
        const codecs = await getSupportedCodecs();
        availableCodecs.value = [];
        if (codecs.includes("avc")) {
          availableCodecs.value.push({ value: "avc", label: "H.264 (MP4)" });
        }
        if (codecs.includes("vp9")) {
          availableCodecs.value.push({ value: "vp9", label: "VP9 (WebM)" });
        }
        if (codecs.includes("vp8")) {
          availableCodecs.value.push({ value: "vp8", label: "VP8 (WebM)" });
        }
        if (availableCodecs.value.length > 0) {
          selectedCodec.value = availableCodecs.value[0].value;
        }
      }
    });
    async function startExport() {
      if (!canExport.value) return;
      isExporting.value = true;
      exportComplete.value = false;
      encodedVideo.value = null;
      const config = {
        width: outputWidth.value,
        height: outputHeight.value,
        frameRate: frameRate.value,
        codec: selectedCodec.value,
        quality: selectedQuality.value
      };
      const encoder = new WebCodecsVideoEncoder(config);
      currentEncoder.value = encoder;
      try {
        await encoder.initialize((progress) => {
          exportProgress.value = progress;
        });
        const canvas = new OffscreenCanvas(outputWidth.value, outputHeight.value);
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("Could not get 2D context");
        for (let frame = 0; frame < totalFrames.value; frame++) {
          if (!isExporting.value) break;
          store.setFrame(frame);
          await new Promise((resolve) => setTimeout(resolve, 10));
          const frameImage = await captureCurrentFrame(canvas, ctx);
          await encoder.encodeFrame(frameImage, frame, totalFrames.value);
        }
        if (isExporting.value) {
          encodedVideo.value = await encoder.finalize();
          exportComplete.value = true;
        }
      } catch (error) {
        console.error("Export failed:", error);
        alert(`Export failed: ${error.message}`);
      } finally {
        isExporting.value = false;
        currentEncoder.value = null;
      }
    }
    async function captureCurrentFrame(canvas, ctx) {
      const glCanvas = document.querySelector(".three-canvas canvas");
      if (glCanvas) {
        ctx.drawImage(glCanvas, 0, 0, canvas.width, canvas.height);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, "#1a1a2e");
        gradient.addColorStop(1, "#16213e");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Frame " + store.currentFrame, canvas.width / 2, canvas.height / 2);
      }
      return canvas;
    }
    function cancelExport() {
      isExporting.value = false;
      if (currentEncoder.value) {
        currentEncoder.value.cancel();
        currentEncoder.value = null;
      }
    }
    function downloadExport() {
      if (encodedVideo.value) {
        const compName = activeComp.value?.name || "composition";
        downloadVideo(encodedVideo.value, `${compName}-export`);
      }
    }
    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        _cache[12] || (_cache[12] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Export Video")
        ], -1)),
        createBaseVNode("div", _hoisted_2$e, [
          createBaseVNode("div", _hoisted_3$e, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Format")
            ], -1)),
            createBaseVNode("div", _hoisted_4$e, [
              _cache[2] || (_cache[2] = createBaseVNode("label", null, "Codec", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedCodec.value = $event),
                disabled: isExporting.value
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableCodecs.value, (codec) => {
                  return openBlock(), createElementBlock("option", {
                    key: codec.value,
                    value: codec.value
                  }, toDisplayString(codec.label), 9, _hoisted_6$e);
                }), 128))
              ], 8, _hoisted_5$e), [
                [vModelSelect, selectedCodec.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_7$e, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Quality", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedQuality.value = $event),
                disabled: isExporting.value
              }, [..._cache[3] || (_cache[3] = [
                createBaseVNode("option", { value: "low" }, "Low (smaller file)", -1),
                createBaseVNode("option", { value: "medium" }, "Medium", -1),
                createBaseVNode("option", { value: "high" }, "High", -1),
                createBaseVNode("option", { value: "lossless" }, "Lossless (largest)", -1)
              ])], 8, _hoisted_8$e), [
                [vModelSelect, selectedQuality.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_9$d, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Output")
            ], -1)),
            createBaseVNode("div", _hoisted_10$c, [
              createBaseVNode("div", _hoisted_11$b, [
                _cache[6] || (_cache[6] = createBaseVNode("span", { class: "info-label" }, "Size", -1)),
                createBaseVNode("span", _hoisted_12$9, toDisplayString(outputWidth.value) + " x " + toDisplayString(outputHeight.value), 1)
              ]),
              createBaseVNode("div", _hoisted_13$8, [
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
                createBaseVNode("span", _hoisted_14$8, toDisplayString(frameRate.value) + " fps", 1)
              ]),
              createBaseVNode("div", _hoisted_15$8, [
                _cache[8] || (_cache[8] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
                createBaseVNode("span", _hoisted_16$8, toDisplayString(duration.value), 1)
              ]),
              createBaseVNode("div", _hoisted_17$8, [
                _cache[9] || (_cache[9] = createBaseVNode("span", { class: "info-label" }, "Total Frames", -1)),
                createBaseVNode("span", _hoisted_18$8, toDisplayString(totalFrames.value), 1)
              ])
            ])
          ]),
          isExporting.value || exportComplete.value ? (openBlock(), createElementBlock("div", _hoisted_19$8, [
            createBaseVNode("div", _hoisted_20$8, [
              createBaseVNode("span", null, toDisplayString(exportStatusText.value), 1),
              isExporting.value ? (openBlock(), createElementBlock("span", _hoisted_21$7, toDisplayString(exportProgress.value.percentage.toFixed(1)) + "%", 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_22$7, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value.percentage}%` })
              }, null, 4)
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_23$7, [
              createBaseVNode("span", null, "Frame " + toDisplayString(exportProgress.value.framesEncoded) + " / " + toDisplayString(exportProgress.value.totalFrames), 1),
              createBaseVNode("span", null, toDisplayString(formatBytes(exportProgress.value.bytesWritten)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_24$5, [
            !isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "export-btn primary",
              disabled: !canExport.value,
              onClick: startExport
            }, " Export Video ", 8, _hoisted_25$5)) : createCommentVNode("", true),
            isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 1,
              class: "export-btn cancel",
              onClick: cancelExport
            }, " Cancel ")) : createCommentVNode("", true),
            exportComplete.value && encodedVideo.value ? (openBlock(), createElementBlock("button", {
              key: 2,
              class: "export-btn download",
              onClick: downloadExport
            }, " Download " + toDisplayString(formatBytes(encodedVideo.value.size)), 1)) : createCommentVNode("", true)
          ]),
          !webCodecsSupported.value ? (openBlock(), createElementBlock("div", _hoisted_26$5, [..._cache[11] || (_cache[11] = [
            createBaseVNode("span", { class: "warning-icon" }, "âš ï¸", -1),
            createBaseVNode("span", null, "WebCodecs API not supported in this browser. Video export unavailable.", -1)
          ])])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ExportPanel = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-d6322f9b"]]);

const CAMERA_BODY_SIZE = 40;
const CAMERA_LENS_LENGTH = 30;
function generateCameraBody(camera) {
  const lines = [];
  const color = "#ffcc00";
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const halfSize = CAMERA_BODY_SIZE / 2;
  const bodyBack = addVec3(pos, scaleVec3(forward, -CAMERA_BODY_SIZE));
  const corners = [];
  for (let z = 0; z < 2; z++) {
    const zOffset = z === 0 ? pos : bodyBack;
    for (let x = -1; x <= 1; x += 2) {
      for (let y = -1; y <= 1; y += 2) {
        corners.push(addVec3(
          addVec3(zOffset, scaleVec3(right, x * halfSize)),
          scaleVec3(up, y * halfSize)
        ));
      }
    }
  }
  lines.push({ start: corners[0], end: corners[1], color });
  lines.push({ start: corners[1], end: corners[3], color });
  lines.push({ start: corners[3], end: corners[2], color });
  lines.push({ start: corners[2], end: corners[0], color });
  lines.push({ start: corners[4], end: corners[5], color });
  lines.push({ start: corners[5], end: corners[7], color });
  lines.push({ start: corners[7], end: corners[6], color });
  lines.push({ start: corners[6], end: corners[4], color });
  lines.push({ start: corners[0], end: corners[4], color });
  lines.push({ start: corners[1], end: corners[5], color });
  lines.push({ start: corners[2], end: corners[6], color });
  lines.push({ start: corners[3], end: corners[7], color });
  const lensEnd = addVec3(pos, scaleVec3(forward, CAMERA_LENS_LENGTH));
  const lensPoints = 8;
  for (let i = 0; i < lensPoints; i++) {
    const angle = i / lensPoints * Math.PI * 2;
    const nextAngle = (i + 1) / lensPoints * Math.PI * 2;
    const p1 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(angle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(angle) * halfSize * 0.5)
    );
    const p2 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(nextAngle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(nextAngle) * halfSize * 0.5)
    );
    lines.push({ start: p1, end: p2, color });
    lines.push({ start: p1, end: lensEnd, color });
  }
  return lines;
}
function generateFrustum(camera, compWidth, compHeight, maxDistance = 2e3) {
  const lines = [];
  const color = "#7c9cff";
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  const aspect = compWidth / compHeight;
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const near = camera.nearClip;
  const far = Math.min(camera.farClip, maxDistance);
  const nearHalfHeight = near * Math.tan(fovY * Math.PI / 360);
  const nearHalfWidth = nearHalfHeight * aspect;
  const farHalfHeight = far * Math.tan(fovY * Math.PI / 360);
  const farHalfWidth = farHalfHeight * aspect;
  const nearCenter = addVec3(pos, scaleVec3(forward, near));
  const nearCorners = [
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, -nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, -nearHalfHeight))
  ];
  const farCenter = addVec3(pos, scaleVec3(forward, far));
  const farCorners = [
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, -farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, -farHalfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: nearCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: farCorners[i], end: farCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: farCorners[i], color });
  }
  return lines;
}
function generateCompositionBounds(compWidth, compHeight) {
  const color = "#00ff88";
  const corners = [
    vec3(0, 0, 0),
    vec3(compWidth, 0, 0),
    vec3(compWidth, compHeight, 0),
    vec3(0, compHeight, 0)
  ];
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  lines.push({ start: corners[0], end: corners[2], color: "#005533" });
  lines.push({ start: corners[1], end: corners[3], color: "#005533" });
  return lines;
}
function generatePOILine(camera) {
  if (camera.type !== "two-node") {
    return null;
  }
  return {
    start: camera.position,
    end: camera.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function generateFocalPlane(camera, compWidth, compHeight) {
  if (!camera.depthOfField.enabled) {
    return [];
  }
  const color = "#ff00ff";
  const lines = [];
  const pos = camera.position;
  const focusDist = camera.depthOfField.focusDistance;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const center = addVec3(pos, scaleVec3(forward, focusDist));
  const halfWidth = compWidth / 4;
  const halfHeight = compHeight / 4;
  const corners = [
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, -halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, -halfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  return lines;
}
function generateCameraVisualization(camera, compWidth, compHeight, showFrustum = true, showBounds = true, showFocalPlane = false) {
  return {
    body: generateCameraBody(camera),
    frustum: showFrustum ? generateFrustum(camera, compWidth, compHeight) : [],
    compositionBounds: showBounds ? generateCompositionBounds(compWidth, compHeight) : [],
    poiLine: generatePOILine(camera),
    focalPlane: showFocalPlane ? generateFocalPlane(camera, compWidth, compHeight) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function getCameraViewMatrices(camera, compWidth, compHeight) {
  const aspect = compWidth / compHeight;
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  let target;
  if (camera.type === "two-node") {
    target = camera.pointOfInterest;
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    const forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
    target = addVec3(camera.position, scaleVec3(forward, 1e3));
  }
  const view = lookAtMat4(camera.position, target, vec3(0, -1, 0));
  const projection = perspectiveMat4(fovY, aspect, camera.nearClip, camera.farClip);
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function getOrthoViewMatrices(viewType, compWidth, compHeight, customView) {
  const aspect = compWidth / compHeight;
  let view;
  let size = 1e3;
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  switch (viewType) {
    case "front":
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "back":
      view = lookAtMat4(
        vec3(centerX, centerY, 2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "left":
      view = lookAtMat4(
        vec3(-2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "right":
      view = lookAtMat4(
        vec3(centerX + 2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "top":
      view = lookAtMat4(
        vec3(centerX, -2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, 1)
      );
      break;
    case "bottom":
      view = lookAtMat4(
        vec3(centerX, centerY + 2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (customView) {
        const phi = customView.orbitPhi * Math.PI / 180;
        const theta = customView.orbitTheta * Math.PI / 180;
        const dist = customView.orbitDistance;
        const eye = vec3(
          customView.orbitCenter.x + dist * Math.sin(phi) * Math.sin(theta),
          customView.orbitCenter.y + dist * Math.cos(phi),
          customView.orbitCenter.z + dist * Math.sin(phi) * Math.cos(theta)
        );
        view = lookAtMat4(
          eye,
          customView.orbitCenter,
          vec3(0, -1, 0)
        );
        size = 1e3 / customView.orthoZoom;
      } else {
        view = lookAtMat4(
          vec3(centerX, centerY, -2e3),
          vec3(centerX, centerY, 0),
          vec3(0, -1, 0)
        );
      }
      break;
    default:
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
  }
  const projection = orthographicMat4(
    -size * aspect,
    size * aspect,
    -size,
    size,
    1,
    1e4
  );
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function multiplyMat4Local(a, b) {
  const ae = a.elements;
  const be = b.elements;
  const result = new Float32Array(16);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      let sum = 0;
      for (let i = 0; i < 4; i++) {
        sum += ae[row + i * 4] * be[i + col * 4];
      }
      result[row + col * 4] = sum;
    }
  }
  return { elements: result };
}
function projectToScreen(point, viewProjection, screenWidth, screenHeight) {
  const transformed = transformPoint(viewProjection, point);
  const vp = viewProjection.elements;
  const w = point.x * vp[3] + point.y * vp[7] + point.z * vp[11] + vp[15];
  if (w <= 0) {
    return { x: 0, y: 0, z: transformed.z, visible: false };
  }
  const x = (transformed.x / w * 0.5 + 0.5) * screenWidth;
  const y = (-transformed.y / w * 0.5 + 0.5) * screenHeight;
  return {
    x,
    y,
    z: transformed.z / w,
    visible: true
  };
}
function generate3DAxes(center, length = 100) {
  return [
    { start: center, end: addVec3(center, vec3(length, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: center, end: addVec3(center, vec3(0, length, 0)), color: "#00ff00" },
    // Y - Green
    { start: center, end: addVec3(center, vec3(0, 0, length)), color: "#0000ff" }
    // Z - Blue
  ];
}
function generateGrid(compWidth, compHeight, spacing = 100) {
  const lines = [];
  const color = "#333333";
  const centerColor = "#444444";
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  const extent = Math.max(compWidth, compHeight);
  for (let x = -extent; x <= extent + compWidth; x += spacing) {
    const isCenter = Math.abs(x - centerX) < spacing / 2;
    lines.push({
      start: vec3(x, -extent, 0),
      end: vec3(x, extent + compHeight, 0),
      color: isCenter ? centerColor : color
    });
  }
  for (let y = -extent; y <= extent + compHeight; y += spacing) {
    const isCenter = Math.abs(y - centerY) < spacing / 2;
    lines.push({
      start: vec3(-extent, y, 0),
      end: vec3(extent + compWidth, y, 0),
      color: isCenter ? centerColor : color
    });
  }
  return lines;
}

const _hoisted_1$d = ["onClick"];
const _hoisted_2$d = { class: "view-header" };
const _hoisted_3$d = ["value", "onChange"];
const _hoisted_4$d = { class: "view-tools" };
const _hoisted_5$d = ["onClick"];
const _hoisted_6$d = ["onMousedown", "onWheel"];
const _hoisted_7$d = { class: "view-info" };
const _hoisted_8$d = { class: "view-name" };
const _hoisted_9$c = {
  key: 0,
  class: "view-coords"
};
const _hoisted_10$b = { class: "layout-controls" };
const _hoisted_11$a = ["onClick", "title"];
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "ViewportRenderer",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => store.activeCamera);
    const compWidth = computed(() => store.width);
    const compHeight = computed(() => store.height);
    const viewportState = computed(() => store.viewportState);
    const viewOptions = computed(() => store.viewOptions);
    const layers = computed(() => {
      return store.layers.filter((l) => l.type !== "camera").map((l) => ({
        id: l.id,
        name: l.name,
        position: {
          x: l.transform.position.value.x,
          y: l.transform.position.value.y,
          z: 0
          // 2D layers at z=0
        },
        selected: store.selectedLayerIds.includes(l.id)
      }));
    });
    const canvasRefs = ref([null, null, null, null]);
    const contexts = ref([null, null, null, null]);
    const isDragging = ref(false);
    const dragStartPos = ref({ x: 0, y: 0 });
    const dragViewIndex = ref(0);
    const dragButton = ref(0);
    const layoutOptions = [
      { value: "1-view", label: "1 View", icon: "â–¡" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "â¬š" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "â¬›" },
      { value: "4-view", label: "4 Views", icon: "âŠž" }
    ];
    const layout = computed(() => viewportState.value.layout);
    const activeViewIndex = computed(() => viewportState.value.activeViewIndex);
    const customViews = computed(() => viewportState.value.customViews);
    const activeViews = computed(() => {
      switch (viewportState.value.layout) {
        case "1-view":
          return [viewportState.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return viewportState.value.views.slice(0, 2);
        case "4-view":
          return viewportState.value.views.slice(0, 4);
        default:
          return [viewportState.value.views[0]];
      }
    });
    function setCanvasRef(el, index) {
      canvasRefs.value[index] = el;
      if (el) {
        contexts.value[index] = el.getContext("2d");
      }
    }
    function isCustomView(viewType) {
      return viewType.startsWith("custom-");
    }
    function getViewDisplayName(viewType) {
      const names = {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        "front": "Front",
        "back": "Back",
        "left": "Left",
        "right": "Right",
        "top": "Top",
        "bottom": "Bottom"
      };
      return names[viewType];
    }
    function setActiveView(index) {
      store.updateViewportState({
        activeViewIndex: index
      });
    }
    function updateViewType(index, viewType) {
      const newViews = [...viewportState.value.views];
      newViews[index] = viewType;
      store.updateViewportState({
        views: newViews
      });
    }
    function setLayout(newLayout) {
      const defaultFourViews = ["active-camera", "top", "front", "right"];
      let newViews = [...viewportState.value.views];
      while (newViews.length < 4) {
        newViews.push(defaultFourViews[newViews.length] || "front");
      }
      store.updateViewportState({
        layout: newLayout,
        views: newViews,
        activeViewIndex: Math.min(viewportState.value.activeViewIndex, getViewCount(newLayout) - 1)
      });
    }
    function getViewCount(layout2) {
      switch (layout2) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function resetCustomView(viewType) {
      const defaultView = {
        orbitCenter: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      store.updateViewportState({
        customViews: {
          ...viewportState.value.customViews,
          [viewType]: defaultView
        }
      });
    }
    function onCanvasMouseDown(e, viewIndex) {
      isDragging.value = true;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      dragViewIndex.value = viewIndex;
      dragButton.value = e.button;
      document.addEventListener("mousemove", onCanvasMouseMove);
      document.addEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasMouseMove(e) {
      if (!isDragging.value) return;
      const dx = e.clientX - dragStartPos.value.x;
      const dy = e.clientY - dragStartPos.value.y;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      const viewType = activeViews.value[dragViewIndex.value];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        if (dragButton.value === 0) {
          const newTheta = customView.orbitTheta + dx * 0.5;
          const newPhi = Math.max(1, Math.min(179, customView.orbitPhi + dy * 0.5));
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orbitTheta: newTheta,
                orbitPhi: newPhi
              }
            }
          });
        } else if (dragButton.value === 1 || dragButton.value === 2) {
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orthoOffset: {
                  x: customView.orthoOffset.x + dx,
                  y: customView.orthoOffset.y + dy
                }
              }
            }
          });
        }
      }
    }
    function onCanvasMouseUp() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onCanvasMouseMove);
      document.removeEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasWheel(e, viewIndex) {
      e.preventDefault();
      const viewType = activeViews.value[viewIndex];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [viewType]: {
              ...customView,
              orbitDistance: customView.orbitDistance * zoomFactor
            }
          }
        });
      }
    }
    function render() {
      activeViews.value.forEach((viewType, index) => {
        const canvas = canvasRefs.value[index];
        const ctx = contexts.value[index];
        if (!canvas || !ctx) return;
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, rect.width, rect.height);
        let matrices;
        if (viewType === "active-camera" && camera.value) {
          matrices = getCameraViewMatrices(camera.value, compWidth.value, compHeight.value);
        } else if (isCustomView(viewType)) {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value, customViews.value[viewType]);
        } else {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value);
        }
        const lines = [];
        if (viewOptions.value.showGrid) {
          lines.push(...generateGrid(compWidth.value, compHeight.value));
        }
        if (viewOptions.value.show3DReferenceAxes) {
          lines.push(...generate3DAxes(vec3(compWidth.value / 2, compHeight.value / 2, 0)));
        }
        if (viewOptions.value.showCompositionBounds) {
          const viz = generateCameraVisualization(
            camera.value ?? createDummyCamera(),
            compWidth.value,
            compHeight.value,
            false,
            true,
            false
          );
          lines.push(...viz.compositionBounds);
        }
        if (viewType !== "active-camera" && camera.value) {
          const showWireframe = viewOptions.value.cameraWireframes === "always" || viewOptions.value.cameraWireframes === "selected";
          if (showWireframe) {
            const viz = generateCameraVisualization(
              camera.value,
              compWidth.value,
              compHeight.value,
              true,
              false,
              viewOptions.value.showFocalPlane
            );
            lines.push(...viz.body);
            lines.push(...viz.frustum);
            lines.push(...viz.focalPlane);
            if (viz.poiLine) {
              lines.push(viz.poiLine);
            }
          }
        }
        for (const line of lines) {
          const start = projectToScreen(line.start, matrices.viewProjection, rect.width, rect.height);
          const end = projectToScreen(line.end, matrices.viewProjection, rect.width, rect.height);
          if (!start.visible && !end.visible) continue;
          ctx.beginPath();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 1;
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
        if (viewOptions.value.showLayerHandles) {
          for (const layer of layers.value) {
            const pos = projectToScreen(layer.position, matrices.viewProjection, rect.width, rect.height);
            if (!pos.visible) continue;
            ctx.beginPath();
            ctx.fillStyle = layer.selected ? "#ffcc00" : "#888888";
            ctx.arc(pos.x, pos.y, layer.selected ? 6 : 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "10px sans-serif";
            ctx.fillText(layer.name, pos.x + 8, pos.y + 4);
          }
        }
      });
    }
    function createDummyCamera() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: compWidth.value / 2, y: compHeight.value / 2, z: -1500 },
        pointOfInterest: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: false,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let animationId;
    function animate() {
      render();
      animationId = requestAnimationFrame(animate);
    }
    function onKeyDown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA" || document.activeElement?.tagName === "SELECT") {
        return;
      }
      const activeView = activeViews.value[activeViewIndex.value];
      switch (e.code) {
        case "Numpad1":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "back");
          } else {
            updateViewType(activeViewIndex.value, "front");
          }
          e.preventDefault();
          break;
        case "Numpad3":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "left");
          } else {
            updateViewType(activeViewIndex.value, "right");
          }
          e.preventDefault();
          break;
        case "Numpad7":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "bottom");
          } else {
            updateViewType(activeViewIndex.value, "top");
          }
          e.preventDefault();
          break;
        case "Numpad0":
          updateViewType(activeViewIndex.value, "active-camera");
          e.preventDefault();
          break;
        case "Numpad5":
          if (!isCustomView(activeView)) {
            const targetView = "custom-1";
            let theta = 0;
            let phi = 90;
            switch (activeView) {
              case "front":
                theta = 0;
                phi = 90;
                break;
              case "back":
                theta = 180;
                phi = 90;
                break;
              case "left":
                theta = -90;
                phi = 90;
                break;
              case "right":
                theta = 90;
                phi = 90;
                break;
              case "top":
                theta = 0;
                phi = 1;
                break;
              case "bottom":
                theta = 0;
                phi = 179;
                break;
              default:
                theta = 45;
                phi = 60;
            }
            store.updateViewportState({
              customViews: {
                ...viewportState.value.customViews,
                [targetView]: {
                  ...viewportState.value.customViews[targetView],
                  orbitTheta: theta,
                  orbitPhi: phi
                }
              }
            });
            updateViewType(activeViewIndex.value, targetView);
          } else {
            const theta = customViews.value[activeView].orbitTheta % 360;
            const phi = customViews.value[activeView].orbitPhi;
            let closestView = "front";
            if (phi < 30) {
              closestView = "top";
            } else if (phi > 150) {
              closestView = "bottom";
            } else {
              const normalizedTheta = (theta % 360 + 360) % 360;
              if (normalizedTheta >= 315 || normalizedTheta < 45) {
                closestView = "front";
              } else if (normalizedTheta >= 45 && normalizedTheta < 135) {
                closestView = "right";
              } else if (normalizedTheta >= 135 && normalizedTheta < 225) {
                closestView = "back";
              } else {
                closestView = "left";
              }
            }
            updateViewType(activeViewIndex.value, closestView);
          }
          e.preventDefault();
          break;
        case "NumpadDecimal":
        case "Period":
          focusOnSelectedLayer();
          e.preventDefault();
          break;
        case "Home":
          if (isCustomView(activeView)) {
            resetCustomView(activeView);
          }
          e.preventDefault();
          break;
        case "KeyG":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showGrid: !viewOptions.value.showGrid
            });
            e.preventDefault();
          }
          break;
        case "KeyH":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showLayerHandles: !viewOptions.value.showLayerHandles
            });
            e.preventDefault();
          }
          break;
        case "KeyC":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            store.updateViewOptions({
              showCompositionBounds: !viewOptions.value.showCompositionBounds
            });
            e.preventDefault();
          }
          break;
        case "KeyA":
          if (!e.ctrlKey && !e.metaKey && e.shiftKey) {
            store.updateViewOptions({
              show3DReferenceAxes: !viewOptions.value.show3DReferenceAxes
            });
            e.preventDefault();
          }
          break;
      }
    }
    function focusOnSelectedLayer() {
      const selectedLayer = store.layers.find((l) => store.selectedLayerIds.includes(l.id));
      if (!selectedLayer) return;
      const pos = selectedLayer.transform.position.value;
      const width = 100;
      const height = 100;
      const activeView = activeViews.value[activeViewIndex.value];
      if (isCustomView(activeView)) {
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [activeView]: {
              ...customViews.value[activeView],
              orbitCenter: { x: pos.x + width / 2, y: pos.y + height / 2, z: 0 },
              orbitDistance: Math.max(width, height) * 3
              // Zoom to fit
            }
          }
        });
      }
    }
    onMounted(() => {
      animate();
      window.addEventListener("keydown", onKeyDown);
    });
    onUnmounted(() => {
      cancelAnimationFrame(animationId);
      window.removeEventListener("keydown", onKeyDown);
    });
    watch([camera, viewportState, viewOptions, layers], () => {
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["viewport-renderer", [`layout-${layout.value}`]])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(activeViews.value, (viewType, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass(["view-panel", { active: index === activeViewIndex.value }]),
            onClick: ($event) => setActiveView(index)
          }, [
            createBaseVNode("div", _hoisted_2$d, [
              createBaseVNode("select", {
                value: viewType,
                onChange: ($event) => updateViewType(index, $event.target.value),
                class: "view-select"
              }, [..._cache[1] || (_cache[1] = [
                createStaticVNode('<option value="active-camera" data-v-84bae3ba>Active Camera</option><option value="custom-1" data-v-84bae3ba>Custom View 1</option><option value="custom-2" data-v-84bae3ba>Custom View 2</option><option value="custom-3" data-v-84bae3ba>Custom View 3</option><option value="front" data-v-84bae3ba>Front</option><option value="back" data-v-84bae3ba>Back</option><option value="left" data-v-84bae3ba>Left</option><option value="right" data-v-84bae3ba>Right</option><option value="top" data-v-84bae3ba>Top</option><option value="bottom" data-v-84bae3ba>Bottom</option>', 10)
              ])], 40, _hoisted_3$d),
              createBaseVNode("div", _hoisted_4$d, [
                isCustomView(viewType) ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: withModifiers(($event) => resetCustomView(viewType), ["stop"]),
                  title: "Reset View"
                }, [..._cache[2] || (_cache[2] = [
                  createBaseVNode("span", { class: "icon" }, "â†º", -1)
                ])], 8, _hoisted_5$d)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("canvas", {
              ref_for: true,
              ref: (el) => setCanvasRef(el, index),
              class: "view-canvas",
              onMousedown: ($event) => onCanvasMouseDown($event, index),
              onWheel: ($event) => onCanvasWheel($event, index),
              onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, null, 40, _hoisted_6$d),
            createBaseVNode("div", _hoisted_7$d, [
              createBaseVNode("span", _hoisted_8$d, toDisplayString(getViewDisplayName(viewType)), 1),
              isCustomView(viewType) ? (openBlock(), createElementBlock("span", _hoisted_9$c, " Î¸: " + toDisplayString(Math.round(customViews.value[viewType]?.orbitTheta ?? 0)) + "Â° Ï†: " + toDisplayString(Math.round(customViews.value[viewType]?.orbitPhi ?? 0)) + "Â° ", 1)) : createCommentVNode("", true)
            ])
          ], 10, _hoisted_1$d);
        }), 128)),
        createBaseVNode("div", _hoisted_10$b, [
          (openBlock(), createElementBlock(Fragment, null, renderList(layoutOptions, (layoutOption) => {
            return createBaseVNode("button", {
              key: layoutOption.value,
              class: normalizeClass({ active: layout.value === layoutOption.value }),
              onClick: ($event) => setLayout(layoutOption.value),
              title: layoutOption.label
            }, toDisplayString(layoutOption.icon), 11, _hoisted_11$a);
          }), 64))
        ])
      ], 2);
    };
  }
});

const ViewportRenderer = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-84bae3ba"]]);

class SceneManager {
  /** The main Three.js scene */
  scene;
  /** Group for composition layers (rendered content) */
  compositionGroup;
  /** Group for UI overlay elements */
  overlayGroup;
  /** Group for debug helpers */
  debugGroup;
  /** Environment map texture */
  environmentMap = null;
  /** Environment map configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true,
    toneMapping: true
  };
  /** PMREM Generator for environment maps */
  pmremGenerator = null;
  /** HDRI loaders */
  rgbeLoader = null;
  exrLoader = null;
  /** Composition bounds frame */
  compositionBounds = null;
  /** Composition grid helper */
  compositionGrid = null;
  /** Dark overlay outside composition */
  outsideOverlay = null;
  /** Composition dimensions */
  compositionWidth = 1920;
  compositionHeight = 1080;
  /** O(1) layer lookup map - optimization for frequent ID-based lookups */
  layerLookupMap = /* @__PURE__ */ new Map();
  /** Track Z positions to avoid unnecessary sorting */
  zPositionCache = /* @__PURE__ */ new Map();
  needsZSort = false;
  constructor(backgroundColor = null) {
    this.scene = new Scene();
    this.scene.name = "WeylScene";
    if (backgroundColor) {
      this.scene.background = new Color(backgroundColor);
    } else {
      this.scene.background = null;
    }
    this.compositionGroup = new Group();
    this.compositionGroup.name = "composition";
    this.scene.add(this.compositionGroup);
    this.overlayGroup = new Group();
    this.overlayGroup.name = "overlay";
    this.overlayGroup.renderOrder = 1e3;
    this.scene.add(this.overlayGroup);
    this.debugGroup = new Group();
    this.debugGroup.name = "debug";
    this.debugGroup.visible = false;
    this.scene.add(this.debugGroup);
    this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const ambient = new AmbientLight(16777215, 0.6);
    ambient.name = "ambientLight";
    this.scene.add(ambient);
    const keyLight = new DirectionalLight(16777215, 0.8);
    keyLight.name = "keyLight";
    keyLight.position.set(1e3, -1e3, 2e3);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    this.scene.add(keyLight);
    const fillLight = new DirectionalLight(16777215, 0.3);
    fillLight.name = "fillLight";
    fillLight.position.set(-500, 500, 1e3);
    this.scene.add(fillLight);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(object) {
    this.compositionGroup.add(object);
    this.markNeedsZSort();
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.set(layerId, object);
    }
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(object) {
    this.compositionGroup.remove(object);
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.delete(layerId);
    }
    this.zPositionCache.delete(object);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let hasChanges = false;
      for (const child of this.compositionGroup.children) {
        const cachedZ = this.zPositionCache.get(child);
        const currentZ = child.position.z || 0;
        if (cachedZ === void 0 || cachedZ !== currentZ) {
          hasChanges = true;
          break;
        }
      }
      if (!hasChanges) {
        return;
      }
    }
    this.compositionGroup.children.sort((a, b) => {
      return (a.position.z || 0) - (b.position.z || 0);
    });
    for (const child of this.compositionGroup.children) {
      this.zPositionCache.set(child, child.position.z || 0);
    }
    this.needsZSort = false;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = true;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(object) {
    this.overlayGroup.add(object);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(object) {
    this.overlayGroup.remove(object);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    while (this.overlayGroup.children.length > 0) {
      const child = this.overlayGroup.children[0];
      this.overlayGroup.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(object) {
    this.scene.add(object);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(object) {
    this.scene.remove(object);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(visible) {
    this.debugGroup.visible = visible;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(size = 500) {
    const existing = this.debugGroup.getObjectByName("axisHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new AxesHelper(size);
    helper.name = "axisHelper";
    this.debugGroup.add(helper);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(size = 2e3, divisions = 40) {
    const existing = this.debugGroup.getObjectByName("gridHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new GridHelper(size, divisions, 4473924, 2236962);
    helper.name = "gridHelper";
    helper.rotation.x = Math.PI / 2;
    this.debugGroup.add(helper);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(color) {
    if (color) {
      this.scene.background = new Color(color);
    } else {
      this.scene.background = null;
    }
  }
  /**
   * Get current background color
   */
  getBackground() {
    if (this.scene.background instanceof Color) {
      return "#" + this.scene.background.getHexString();
    }
    return null;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize PMREM generator (requires WebGL renderer)
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport(renderer) {
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
    }
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Load and set an environment map from URL (HDR, EXR, or standard image)
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    if (!this.pmremGenerator) {
      throw new Error("Environment support not initialized. Call initializeEnvironmentSupport() first.");
    }
    if (config) {
      Object.assign(this.envConfig, config);
    }
    this.envConfig.url = url;
    this.envConfig.enabled = true;
    const isHDR = url.toLowerCase().endsWith(".hdr");
    const isEXR = url.toLowerCase().endsWith(".exr");
    return new Promise((resolve, reject) => {
      if (isHDR) {
        if (!this.rgbeLoader) {
          this.rgbeLoader = new RGBELoader();
        }
        this.rgbeLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else if (isEXR) {
        if (!this.exrLoader) {
          this.exrLoader = new EXRLoader();
        }
        this.exrLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else {
        const loader = new TextureLoader();
        loader.load(
          url,
          (texture) => {
            texture.mapping = EquirectangularReflectionMapping;
            this.processEnvironmentTexture(texture, resolve);
          },
          void 0,
          reject
        );
      }
    });
  }
  /**
   * Process loaded environment texture
   */
  processEnvironmentTexture(texture, resolve) {
    const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
    texture.dispose();
    this.setEnvironmentMapTexture(envMap);
    resolve(envMap);
  }
  /**
   * Set environment map from pre-loaded texture
   */
  setEnvironmentMapTexture(texture) {
    if (this.environmentMap && this.environmentMap !== texture) {
      this.environmentMap.dispose();
    }
    this.environmentMap = texture;
    if (texture && this.envConfig.enabled) {
      this.scene.environment = texture;
      if (this.envConfig.useAsBackground) {
        this.scene.background = texture;
        this.scene.backgroundIntensity = this.envConfig.intensity;
        this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
        this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
      }
      this.scene.environmentIntensity = this.envConfig.intensity;
      this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
    } else {
      this.scene.environment = null;
      if (this.envConfig.useAsBackground) {
        this.scene.background = null;
      }
    }
  }
  /**
   * Update environment map configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (this.environmentMap) {
      if (this.envConfig.enabled) {
        this.scene.environment = this.environmentMap;
        this.scene.environmentIntensity = this.envConfig.intensity;
        this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
        if (this.envConfig.useAsBackground) {
          this.scene.background = this.environmentMap;
          this.scene.backgroundIntensity = this.envConfig.intensity;
          this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
          this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
        }
      } else {
        this.scene.environment = null;
        if (this.envConfig.useAsBackground) {
          this.scene.background = null;
        }
      }
    }
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Get current environment map texture
   */
  getEnvironmentMap() {
    return this.environmentMap;
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.setEnvironmentConfig({ enabled });
  }
  /**
   * Set environment intensity
   */
  setEnvironmentIntensity(intensity) {
    this.setEnvironmentConfig({ intensity });
  }
  /**
   * Set environment rotation (degrees)
   */
  setEnvironmentRotation(rotation) {
    this.setEnvironmentConfig({ rotation });
  }
  /**
   * Set background blur amount (0-1)
   */
  setBackgroundBlur(blur) {
    this.setEnvironmentConfig({ backgroundBlur: blur });
  }
  /**
   * Toggle using HDRI as background
   */
  setUseAsBackground(use) {
    this.setEnvironmentConfig({ useAsBackground: use });
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(width, height) {
    this.compositionWidth = width;
    this.compositionHeight = height;
    this.updateCompositionBounds();
    this.updateCompositionGrid();
    this.updateOutsideOverlay();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    if (this.compositionBounds) {
      this.overlayGroup.remove(this.compositionBounds);
      this.compositionBounds.geometry.dispose();
      this.compositionBounds.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const points = [
      new Vector3(0, 0, 0),
      new Vector3(w, 0, 0),
      new Vector3(w, -h, 0),
      new Vector3(0, -h, 0)
    ];
    const geometry = new BufferGeometry().setFromPoints(points);
    const material = new LineBasicMaterial({
      color: 4886745,
      linewidth: 2,
      depthTest: false
    });
    this.compositionBounds = new LineLoop(geometry, material);
    this.compositionBounds.name = "compositionBounds";
    this.compositionBounds.renderOrder = 998;
    this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(visible) {
    if (this.compositionBounds) {
      this.compositionBounds.visible = visible;
    }
  }
  /**
   * Create or update composition grid
   * Shows a grid inside the composition area for spatial reference
   */
  updateCompositionGrid(divisions = 10) {
    if (this.compositionGrid) {
      this.overlayGroup.remove(this.compositionGrid);
      this.compositionGrid.traverse((obj) => {
        if (obj instanceof Line) {
          obj.geometry.dispose();
          obj.material.dispose();
        }
      });
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const gridGroup = new Group();
    gridGroup.name = "compositionGrid";
    const material = new LineBasicMaterial({
      color: 3355443,
      transparent: true,
      opacity: 0.5,
      depthTest: false
    });
    const stepX = w / divisions;
    for (let i = 0; i <= divisions; i++) {
      const x = i * stepX;
      const points = [
        new Vector3(x, 0, 0),
        new Vector3(x, -h, 0)
      ];
      const geometry = new BufferGeometry().setFromPoints(points);
      const line = new Line(geometry, material.clone());
      gridGroup.add(line);
    }
    const stepY = h / divisions;
    for (let i = 0; i <= divisions; i++) {
      const y = -i * stepY;
      const points = [
        new Vector3(0, y, 0),
        new Vector3(w, y, 0)
      ];
      const geometry = new BufferGeometry().setFromPoints(points);
      const line = new Line(geometry, material.clone());
      gridGroup.add(line);
    }
    const centerMaterial = new LineBasicMaterial({
      color: 5592405,
      transparent: true,
      opacity: 0.7,
      depthTest: false
    });
    const vCenterPoints = [
      new Vector3(w / 2, 0, 0),
      new Vector3(w / 2, -h, 0)
    ];
    const vCenterGeom = new BufferGeometry().setFromPoints(vCenterPoints);
    gridGroup.add(new Line(vCenterGeom, centerMaterial));
    const hCenterPoints = [
      new Vector3(0, -h / 2, 0),
      new Vector3(w, -h / 2, 0)
    ];
    const hCenterGeom = new BufferGeometry().setFromPoints(hCenterPoints);
    gridGroup.add(new Line(hCenterGeom, centerMaterial.clone()));
    gridGroup.renderOrder = 997;
    this.compositionGrid = gridGroup;
    this.overlayGroup.add(gridGroup);
  }
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    if (this.compositionGrid) {
      this.compositionGrid.visible = visible;
    }
  }
  /**
   * Create dark overlay outside composition bounds
   * Creates a large plane with a rectangular hole for the composition area
   */
  updateOutsideOverlay() {
    if (this.outsideOverlay) {
      this.overlayGroup.remove(this.outsideOverlay);
      this.outsideOverlay.geometry.dispose();
      this.outsideOverlay.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const size = Math.max(w, h) * 10;
    const outer = new Shape();
    outer.moveTo(-size, size);
    outer.lineTo(size + w, size);
    outer.lineTo(size + w, -size - h);
    outer.lineTo(-size, -size - h);
    outer.lineTo(-size, size);
    const hole = new Path();
    hole.moveTo(0, 0);
    hole.lineTo(0, -h);
    hole.lineTo(w, -h);
    hole.lineTo(w, 0);
    hole.lineTo(0, 0);
    outer.holes.push(hole);
    const geometry = new ShapeGeometry(outer);
    const material = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      opacity: 0.6,
      side: DoubleSide,
      depthTest: false
    });
    this.outsideOverlay = new Mesh(geometry, material);
    this.outsideOverlay.name = "outsideOverlay";
    this.outsideOverlay.position.z = -2;
    this.outsideOverlay.renderOrder = 996;
    this.overlayGroup.add(this.outsideOverlay);
  }
  /**
   * Show/hide outside overlay
   */
  setOutsideOverlayVisible(visible) {
    if (this.outsideOverlay) {
      this.outsideOverlay.visible = visible;
    }
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(raycaster) {
    return raycaster.intersectObjects(this.compositionGroup.children, true);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(layerId) {
    return this.layerLookupMap.get(layerId) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(object) {
    if (object instanceof Mesh) {
      object.geometry?.dispose();
      if (Array.isArray(object.material)) {
        object.material.forEach((m) => {
          this.disposeMaterial(m);
        });
      } else if (object.material) {
        this.disposeMaterial(object.material);
      }
    }
    while (object.children.length > 0) {
      const child = object.children[0];
      object.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(material) {
    const mat = material;
    mat.map?.dispose();
    mat.normalMap?.dispose();
    mat.roughnessMap?.dispose();
    mat.metalnessMap?.dispose();
    mat.aoMap?.dispose();
    mat.emissiveMap?.dispose();
    mat.alphaMap?.dispose();
    mat.envMap?.dispose();
    material.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    while (this.compositionGroup.children.length > 0) {
      const child = this.compositionGroup.children[0];
      this.compositionGroup.remove(child);
      this.disposeObject(child);
    }
    this.layerLookupMap.clear();
    this.zPositionCache.clear();
    this.clearOverlay();
    while (this.debugGroup.children.length > 0) {
      const child = this.debugGroup.children[0];
      this.debugGroup.remove(child);
      this.disposeObject(child);
    }
    if (this.environmentMap) {
      this.environmentMap.dispose();
      this.environmentMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
    this.scene.clear();
  }
}

function createDefaultMotionBlurSettings() {
  return {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16,
    pixelBlurLength: 50,
    vectorDetail: 50,
    direction: 0,
    blurLength: 10,
    radialMode: "zoom",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    adaptiveThreshold: 2,
    motionBlurQuality: "normal",
    useGPU: true
  };
}
class MotionBlurProcessor {
  settings;
  frameBuffer = [];
  maxBufferSize = 5;
  // Cached canvases for compositing
  workCanvas;
  workCtx;
  outputCanvas;
  outputCtx;
  constructor(width, height, settings) {
    this.settings = { ...createDefaultMotionBlurSettings(), ...settings };
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
  }
  // ============================================================================
  // SETTINGS
  // ============================================================================
  setSettings(settings) {
    this.settings = { ...this.settings, ...settings };
  }
  getSettings() {
    return { ...this.settings };
  }
  resize(width, height) {
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
    this.frameBuffer = [];
  }
  // ============================================================================
  // VELOCITY CALCULATION
  // ============================================================================
  /**
   * Calculate velocity from transform changes between frames
   */
  calculateVelocity(prevTransform, currTransform, deltaTime = 1) {
    return {
      x: (currTransform.x - prevTransform.x) / deltaTime,
      y: (currTransform.y - prevTransform.y) / deltaTime,
      rotation: (currTransform.rotation - prevTransform.rotation) / deltaTime,
      scale: (currTransform.scaleX - prevTransform.scaleX + (currTransform.scaleY - prevTransform.scaleY)) / 2 / deltaTime
    };
  }
  /**
   * Get velocity magnitude
   */
  getVelocityMagnitude(velocity) {
    return Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
  }
  // ============================================================================
  // BLUR APPLICATION
  // ============================================================================
  /**
   * Apply motion blur to a canvas based on current settings
   */
  applyMotionBlur(sourceCanvas, velocity, frame) {
    if (!this.settings.enabled || this.settings.type === "none") {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    this.addFrameToBuffer(sourceCanvas, velocity, frame);
    switch (this.settings.type) {
      case "standard":
        return this.applyStandardBlur(sourceCanvas, velocity);
      case "pixel":
        return this.applyPixelMotionBlur(sourceCanvas);
      case "directional":
        return this.applyDirectionalBlur(sourceCanvas);
      case "radial":
        return this.applyRadialBlur(sourceCanvas);
      case "vector":
        return this.applyVectorBlur(sourceCanvas, velocity);
      case "adaptive":
        return this.applyAdaptiveBlur(sourceCanvas, velocity);
      default:
        this.outputCtx.drawImage(sourceCanvas, 0, 0);
        return this.outputCanvas;
    }
  }
  /**
   * Add frame to circular buffer
   */
  addFrameToBuffer(canvas, velocity, frame) {
    const cloned = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = cloned.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    this.frameBuffer.push({
      canvas: cloned,
      velocity,
      timestamp: frame
    });
    while (this.frameBuffer.length > this.maxBufferSize) {
      this.frameBuffer.shift();
    }
  }
  // ============================================================================
  // STANDARD MOTION BLUR (Shutter-based)
  // ============================================================================
  /**
   * Standard After Effects motion blur using shutter angle
   * Simulates camera shutter open during frame exposure
   */
  applyStandardBlur(sourceCanvas, velocity) {
    const { shutterAngle, shutterPhase} = this.settings;
    const exposureRatio = shutterAngle / 360;
    const phaseOffset = shutterPhase / 360;
    const blurDistX = velocity.x * exposureRatio;
    const blurDistY = velocity.y * exposureRatio;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5 + phaseOffset;
      const offsetX = blurDistX * t;
      const offsetY = blurDistY * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // PIXEL MOTION BLUR
  // ============================================================================
  /**
   * Pixel Motion Blur - analyzes motion between frames
   * Creates blur based on pixel movement vectors
   */
  applyPixelMotionBlur(sourceCanvas) {
    if (this.frameBuffer.length < 2) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    const { pixelBlurLength, vectorDetail } = this.settings;
    const blurStrength = pixelBlurLength / 100;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const frameCount = Math.min(this.frameBuffer.length, Math.ceil(vectorDetail / 20) + 2);
    const alpha = 1 / frameCount;
    this.outputCtx.globalAlpha = alpha;
    for (let i = this.frameBuffer.length - frameCount; i < this.frameBuffer.length; i++) {
      if (i >= 0) {
        const frame = this.frameBuffer[i];
        const timeOffset = (this.frameBuffer.length - 1 - i) * blurStrength;
        this.outputCtx.save();
        this.outputCtx.translate(
          -frame.velocity.x * timeOffset * 0.5,
          -frame.velocity.y * timeOffset * 0.5
        );
        this.outputCtx.drawImage(frame.canvas, 0, 0);
        this.outputCtx.restore();
      }
    }
    this.outputCtx.globalAlpha = 0.5;
    this.outputCtx.drawImage(sourceCanvas, 0, 0);
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // DIRECTIONAL BLUR
  // ============================================================================
  /**
   * Directional blur - blur in a specific direction
   * Independent of actual motion
   */
  applyDirectionalBlur(sourceCanvas) {
    const { direction, blurLength } = this.settings;
    const angleRad = direction * Math.PI / 180;
    const dx = Math.cos(angleRad) * blurLength;
    const dy = Math.sin(angleRad) * blurLength;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      const offsetX = dx * t;
      const offsetY = dy * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // RADIAL BLUR
  // ============================================================================
  /**
   * Radial blur - zoom or spin blur from center point
   */
  applyRadialBlur(sourceCanvas) {
    const { radialMode, radialAmount, radialCenterX, radialCenterY } = this.settings;
    const centerX = this.outputCanvas.width * radialCenterX;
    const centerY = this.outputCanvas.height * radialCenterY;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    const amount = radialAmount / 100;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      if (radialMode === "spin") {
        const angle = t * amount * 0.2;
        this.outputCtx.rotate(angle);
      } else {
        const scale = 1 + t * amount * 0.1;
        this.outputCtx.scale(scale, scale);
      }
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // VECTOR MOTION BLUR
  // ============================================================================
  /**
   * Vector-based motion blur using velocity data
   * More accurate than pixel-based for known motion
   */
  applyVectorBlur(sourceCanvas, velocity) {
    const { shutterAngle, vectorDetail } = this.settings;
    const exposureRatio = shutterAngle / 360;
    const blurX = velocity.x * exposureRatio;
    const blurY = velocity.y * exposureRatio;
    const blurRotation = velocity.rotation * exposureRatio * 0.01;
    const blurScale = velocity.scale * exposureRatio * 1e-3;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = Math.ceil(vectorDetail / 100 * this.getSampleCount());
    const alpha = 1 / samples;
    const centerX = this.outputCanvas.width / 2;
    const centerY = this.outputCanvas.height / 2;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      this.outputCtx.translate(blurX * t, blurY * t);
      this.outputCtx.rotate(blurRotation * t);
      this.outputCtx.scale(1 + blurScale * t, 1 + blurScale * t);
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // ADAPTIVE BLUR
  // ============================================================================
  /**
   * Adaptive blur - automatically selects blur type based on motion
   */
  applyAdaptiveBlur(sourceCanvas, velocity) {
    const magnitude = this.getVelocityMagnitude(velocity);
    if (magnitude < this.settings.adaptiveThreshold) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    if (Math.abs(velocity.rotation) > magnitude * 0.5) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "spin";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.rotation) * 2);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    if (Math.abs(velocity.scale) > 0.1) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "zoom";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.scale) * 500);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    return this.applyVectorBlur(sourceCanvas, velocity);
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  /**
   * Get sample count based on quality setting
   */
  getSampleCount() {
    const base = this.settings.samplesPerFrame;
    switch (this.settings.motionBlurQuality) {
      case "draft":
        return Math.max(4, Math.floor(base / 2));
      case "high":
        return Math.min(64, base * 2);
      default:
        return base;
    }
  }
  /**
   * Clear frame buffer (call when seeking or starting new playback)
   */
  clearBuffer() {
    this.frameBuffer = [];
  }
  /**
   * Get motion blur intensity suggestion based on frame rate
   */
  static suggestSettings(fps) {
    const baseAngle = 180;
    const fpsRatio = 24 / fps;
    return {
      shutterAngle: Math.min(360, baseAngle * fpsRatio),
      samplesPerFrame: fps >= 60 ? 8 : fps >= 30 ? 12 : 16
    };
  }
}
const MOTION_BLUR_PRESETS = {
  // Film Standards
  "film_24fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_cinematic": {
    type: "standard",
    shutterAngle: 172.8,
    // 1/48s at 24fps
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_smooth": {
    type: "standard",
    shutterAngle: 270,
    shutterPhase: -90,
    samplesPerFrame: 24
  },
  // Video Standards
  "video_30fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 12
  },
  "video_60fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 8
  },
  // Stylized
  "action_crisp": {
    type: "standard",
    shutterAngle: 90,
    shutterPhase: -45,
    samplesPerFrame: 8
  },
  "dreamy": {
    type: "standard",
    shutterAngle: 360,
    shutterPhase: -180,
    samplesPerFrame: 32
  },
  "staccato": {
    type: "standard",
    shutterAngle: 45,
    shutterPhase: -22.5,
    samplesPerFrame: 4
  },
  // Directional Effects
  "speed_horizontal": {
    type: "directional",
    direction: 0,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "speed_vertical": {
    type: "directional",
    direction: 90,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "diagonal_streak": {
    type: "directional",
    direction: 45,
    blurLength: 30,
    samplesPerFrame: 24
  },
  // Radial Effects
  "zoom_impact": {
    type: "radial",
    radialMode: "zoom",
    radialAmount: 75,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  "spin_vortex": {
    type: "radial",
    radialMode: "spin",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  // Advanced
  "pixel_smooth": {
    type: "pixel",
    pixelBlurLength: 60,
    vectorDetail: 70,
    samplesPerFrame: 16
  },
  "vector_accurate": {
    type: "vector",
    shutterAngle: 180,
    vectorDetail: 90,
    samplesPerFrame: 24
  },
  "adaptive_auto": {
    type: "adaptive",
    shutterAngle: 180,
    adaptiveThreshold: 3,
    samplesPerFrame: 16
  }
};

class RenderPipeline {
  renderer;
  composer;
  scene;
  camera;
  // Render targets
  colorTarget;
  depthTarget;
  // Frame capture
  captureCanvas;
  captureCtx;
  // Depth capture material
  depthMaterial;
  // Normal material for normal pass
  normalMaterial;
  // Dimensions
  width;
  height;
  pixelRatio;
  // Render mode
  renderMode = "color";
  // DOF pass
  bokehPass = null;
  dofConfig = {
    enabled: false,
    focusDistance: 500,
    aperture: 0.025,
    maxBlur: 0.01
  };
  // SSAO pass
  ssaoPass = null;
  ssaoConfig = {
    enabled: false,
    kernelRadius: 8,
    minDistance: 5e-3,
    maxDistance: 0.1,
    intensity: 1,
    output: "default"
  };
  // Bloom pass (for emissive objects and lights)
  bloomPass = null;
  bloomConfig = {
    enabled: false,
    strength: 1.5,
    radius: 0.4,
    threshold: 0.85
  };
  // Motion blur processor (canvas-based, applied post-render)
  motionBlurProcessor;
  motionBlurConfig = {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  };
  previousFrameTransform = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1
  };
  constructor(config, scene, camera) {
    this.scene = scene;
    this.camera = camera;
    this.width = config.width;
    this.height = config.height;
    this.pixelRatio = config.pixelRatio ?? Math.min(window.devicePixelRatio, 2);
    this.renderer = new WebGLRenderer({
      canvas: config.canvas,
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      preserveDrawingBuffer: true,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: false,
      depth: true
    });
    this.renderer.setPixelRatio(this.pixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.renderer.toneMapping = ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1;
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer = new EffectComposer(this.renderer, this.colorTarget);
    this.setupDefaultPasses();
    this.captureCanvas = new OffscreenCanvas(scaledWidth, scaledHeight);
    this.captureCtx = this.captureCanvas.getContext("2d");
    this.depthMaterial = this.createDepthMaterial();
    this.normalMaterial = new MeshNormalMaterial();
    this.motionBlurProcessor = new MotionBlurProcessor(scaledWidth, scaledHeight);
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      type: HalfFloatType,
      colorSpace: SRGBColorSpace,
      depthBuffer: true,
      stencilBuffer: false,
      samples: 4
      // MSAA
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = UnsignedIntType;
    return target;
  }
  createDepthTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      depthBuffer: true,
      stencilBuffer: false
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = FloatType;
    return target;
  }
  createDepthMaterial() {
    return new ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: false,
      depthTest: false
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const renderPass = new RenderPass(this.scene.scene, this.camera.camera);
    this.composer.addPass(renderPass);
    const outputPass = new OutputPass();
    this.composer.addPass(outputPass);
  }
  /**
   * Add a post-processing pass
   */
  addPass(pass) {
    const outputIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "OutputPass"
    );
    if (outputIndex > -1) {
      this.composer.insertPass(pass, outputIndex);
    } else {
      this.composer.addPass(pass);
    }
  }
  /**
   * Remove a post-processing pass
   */
  removePass(pass) {
    this.composer.removePass(pass);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(config) {
    this.dofConfig = { ...this.dofConfig, ...config };
    if (this.dofConfig.enabled) {
      if (!this.bokehPass) {
        this.createBokehPass();
      }
      this.updateBokehPass();
    } else {
      if (this.bokehPass) {
        this.composer.removePass(this.bokehPass);
        this.bokehPass = null;
      }
    }
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    this.bokehPass = new BokehPass(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    );
    this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const uniforms = this.bokehPass.uniforms;
    if (uniforms) {
      uniforms.focus.value = this.dofConfig.focusDistance;
      uniforms.aperture.value = this.dofConfig.aperture;
      uniforms.maxblur.value = this.dofConfig.maxBlur;
    }
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(distance) {
    this.setDOF({ focusDistance: distance });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(aperture) {
    this.setDOF({ aperture });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(enabled) {
    this.setDOF({ enabled });
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   */
  setSSAO(config) {
    this.ssaoConfig = { ...this.ssaoConfig, ...config };
    if (this.ssaoConfig.enabled) {
      if (!this.ssaoPass) {
        this.createSSAOPass();
      }
      this.updateSSAOPass();
    } else {
      if (this.ssaoPass) {
        this.composer.removePass(this.ssaoPass);
        this.ssaoPass = null;
      }
    }
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return { ...this.ssaoConfig };
  }
  /**
   * Create the SSAO pass
   */
  createSSAOPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.ssaoPass = new SSAOPass(
      this.scene.scene,
      this.camera.camera,
      scaledWidth,
      scaledHeight
    );
    const renderPassIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "RenderPass"
    );
    if (renderPassIndex > -1) {
      this.composer.insertPass(this.ssaoPass, renderPassIndex + 1);
    } else {
      this.addPass(this.ssaoPass);
    }
  }
  /**
   * Update SSAO pass parameters
   */
  updateSSAOPass() {
    if (!this.ssaoPass) return;
    this.ssaoPass.kernelRadius = this.ssaoConfig.kernelRadius;
    this.ssaoPass.minDistance = this.ssaoConfig.minDistance;
    this.ssaoPass.maxDistance = this.ssaoConfig.maxDistance;
    const outputMap = {
      "default": SSAOPass.OUTPUT.Default,
      "ssao": SSAOPass.OUTPUT.SSAO,
      "blur": SSAOPass.OUTPUT.Blur,
      "depth": SSAOPass.OUTPUT.Depth,
      "normal": SSAOPass.OUTPUT.Normal
    };
    this.ssaoPass.output = outputMap[this.ssaoConfig.output];
  }
  /**
   * Enable/disable SSAO (convenience method)
   */
  setSSAOEnabled(enabled) {
    this.setSSAO({ enabled });
  }
  /**
   * Set SSAO intensity (convenience method)
   */
  setSSAOIntensity(intensity) {
    this.setSSAO({ intensity });
  }
  /**
   * Set SSAO kernel radius (convenience method)
   */
  setSSAORadius(radius) {
    this.setSSAO({ kernelRadius: radius });
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, particles) glow
   */
  setBloom(config) {
    this.bloomConfig = { ...this.bloomConfig, ...config };
    if (this.bloomConfig.enabled) {
      if (!this.bloomPass) {
        this.createBloomPass();
      }
      this.updateBloomPass();
    } else {
      if (this.bloomPass) {
        this.composer.removePass(this.bloomPass);
        this.bloomPass = null;
      }
    }
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return { ...this.bloomConfig };
  }
  /**
   * Create the bloom pass
   */
  createBloomPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.bloomPass = new UnrealBloomPass(
      new Vector2(scaledWidth, scaledHeight),
      this.bloomConfig.strength,
      this.bloomConfig.radius,
      this.bloomConfig.threshold
    );
    const ssaoIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "SSAOPass"
    );
    if (ssaoIndex > -1) {
      this.composer.insertPass(this.bloomPass, ssaoIndex + 1);
    } else {
      const renderIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "RenderPass"
      );
      if (renderIndex > -1) {
        this.composer.insertPass(this.bloomPass, renderIndex + 1);
      } else {
        this.addPass(this.bloomPass);
      }
    }
  }
  /**
   * Update bloom pass parameters
   */
  updateBloomPass() {
    if (!this.bloomPass) return;
    this.bloomPass.strength = this.bloomConfig.strength;
    this.bloomPass.radius = this.bloomConfig.radius;
    this.bloomPass.threshold = this.bloomConfig.threshold;
  }
  /**
   * Enable/disable bloom (convenience method)
   */
  setBloomEnabled(enabled) {
    this.setBloom({ enabled });
  }
  /**
   * Set bloom intensity (convenience method)
   */
  setBloomStrength(strength) {
    this.setBloom({ strength });
  }
  /**
   * Set bloom threshold (convenience method)
   */
  setBloomThreshold(threshold) {
    this.setBloom({ threshold });
  }
  // ============================================================================
  // MOTION BLUR CONFIGURATION
  // ============================================================================
  /**
   * Configure motion blur
   */
  setMotionBlur(config) {
    this.motionBlurConfig = { ...this.motionBlurConfig, ...config };
    this.motionBlurProcessor.setSettings({
      enabled: this.motionBlurConfig.enabled,
      type: this.motionBlurConfig.type,
      shutterAngle: this.motionBlurConfig.shutterAngle,
      shutterPhase: this.motionBlurConfig.shutterPhase,
      samplesPerFrame: this.motionBlurConfig.samplesPerFrame
    });
  }
  /**
   * Enable/disable motion blur
   */
  setMotionBlurEnabled(enabled) {
    this.setMotionBlur({ enabled });
  }
  /**
   * Set motion blur type
   */
  setMotionBlurType(type) {
    this.setMotionBlur({ type });
  }
  /**
   * Set shutter angle (0-720, 180 = standard film)
   */
  setMotionBlurShutterAngle(shutterAngle) {
    this.setMotionBlur({ shutterAngle });
  }
  /**
   * Apply a motion blur preset by name
   */
  setMotionBlurPreset(presetName) {
    const preset = MOTION_BLUR_PRESETS[presetName];
    if (preset) {
      this.setMotionBlur({
        enabled: true,
        type: preset.type || "standard",
        shutterAngle: preset.shutterAngle || 180,
        shutterPhase: preset.shutterPhase || -90,
        samplesPerFrame: preset.samplesPerFrame || 16,
        preset: presetName
      });
    }
  }
  /**
   * Get current motion blur configuration
   */
  getMotionBlurConfig() {
    return { ...this.motionBlurConfig };
  }
  /**
   * Get the motion blur processor (for advanced use)
   */
  getMotionBlurProcessor() {
    return this.motionBlurProcessor;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ();
    this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.render(this.scene.scene, this.camera.camera);
    this.renderer.setRenderTarget(prevTarget);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  // Depth visualization pass for post-processing
  depthVisualizationPass = null;
  // Normal visualization pass for post-processing
  normalVisualizationPass = null;
  /**
   * Set the render mode (color, depth, normal)
   * Uses post-processing to visualize depth/normals from the depth buffer
   * This works with ALL geometry including text since it reads from the depth buffer
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    if (this.depthVisualizationPass) {
      this.composer.removePass(this.depthVisualizationPass);
      this.depthVisualizationPass = null;
    }
    if (this.normalVisualizationPass) {
      this.composer.removePass(this.normalVisualizationPass);
      this.normalVisualizationPass = null;
    }
    this.scene.scene.overrideMaterial = null;
    if (mode === "depth") {
      this.depthVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          varying vec2 vUv;

          float readDepth(sampler2D depthSampler, vec2 coord) {
            float fragCoordZ = texture2D(depthSampler, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          void main() {
            float depth = readDepth(tDepth, vUv);
            // White = close, Black = far (standard depth map convention for AI video)
            gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.depthVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.depthVisualizationPass);
      }
    } else if (mode === "normal") {
      const scaledWidth = Math.floor(this.width * this.pixelRatio);
      const scaledHeight = Math.floor(this.height * this.pixelRatio);
      this.normalVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far },
          resolution: { value: new Vector2(scaledWidth, scaledHeight) },
          cameraProjectionMatrix: { value: this.camera.camera.projectionMatrix },
          cameraProjectionMatrixInverse: { value: this.camera.camera.projectionMatrixInverse }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          uniform vec2 resolution;
          uniform mat4 cameraProjectionMatrix;
          uniform mat4 cameraProjectionMatrixInverse;
          varying vec2 vUv;

          // Convert depth buffer value to linear depth
          float getLinearDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          // Reconstruct view-space position from depth
          vec3 getViewPosition(vec2 coord, float depth) {
            vec4 clipPos = vec4(coord * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
            vec4 viewPos = cameraProjectionMatrixInverse * clipPos;
            return viewPos.xyz / viewPos.w;
          }

          void main() {
            // Sample depth at current pixel and neighbors
            vec2 texelSize = 1.0 / resolution;

            float depthC = getLinearDepth(vUv);
            float depthL = getLinearDepth(vUv - vec2(texelSize.x, 0.0));
            float depthR = getLinearDepth(vUv + vec2(texelSize.x, 0.0));
            float depthU = getLinearDepth(vUv + vec2(0.0, texelSize.y));
            float depthD = getLinearDepth(vUv - vec2(0.0, texelSize.y));

            // Handle edges and background (depth = 1.0)
            if (depthC > 0.999) {
              gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0); // Default normal pointing at camera
              return;
            }

            // Reconstruct view-space positions
            vec3 posC = getViewPosition(vUv, depthC);
            vec3 posL = getViewPosition(vUv - vec2(texelSize.x, 0.0), depthL);
            vec3 posR = getViewPosition(vUv + vec2(texelSize.x, 0.0), depthR);
            vec3 posU = getViewPosition(vUv + vec2(0.0, texelSize.y), depthU);
            vec3 posD = getViewPosition(vUv - vec2(0.0, texelSize.y), depthD);

            // Calculate screen-space derivatives
            // Use the neighbor with smaller depth difference to reduce artifacts at edges
            vec3 ddx = abs(depthR - depthC) < abs(depthC - depthL) ? posR - posC : posC - posL;
            vec3 ddy = abs(depthU - depthC) < abs(depthC - depthD) ? posU - posC : posC - posD;

            // Calculate normal from cross product
            vec3 normal = normalize(cross(ddx, ddy));

            // Flip normal to face camera if needed
            if (normal.z < 0.0) normal = -normal;

            // Convert from view-space normal (-1 to 1) to color (0 to 1)
            // Standard normal map convention: RGB = (normal + 1) / 2
            gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.normalVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.normalVisualizationPass);
      }
    }
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    const buffer = new Uint8Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const flipped = new Uint8ClampedArray(buffer.length);
    const rowSize = width * 4;
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * rowSize;
      const dstRow = y * rowSize;
      flipped.set(buffer.subarray(srcRow, srcRow + rowSize), dstRow);
    }
    return new ImageData(flipped, width, height);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const buffer = new Float32Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const depth = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      depth[i] = buffer[i * 4];
    }
    const flipped = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width;
      const dstRow = y * width;
      flipped.set(depth.subarray(srcRow, srcRow + width), dstRow);
    }
    return flipped;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(width, height) {
    this.width = width;
    this.height = height;
    const scaledWidth = Math.floor(width * this.pixelRatio);
    const scaledHeight = Math.floor(height * this.pixelRatio);
    this.renderer.setSize(width, height);
    this.composer.setSize(scaledWidth, scaledHeight);
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer.renderTarget1.dispose();
    this.composer.renderTarget2.dispose();
    this.composer.renderTarget1 = this.colorTarget.clone();
    this.composer.renderTarget2 = this.colorTarget.clone();
    this.captureCanvas.width = scaledWidth;
    this.captureCanvas.height = scaledHeight;
    if (this.bokehPass && this.dofConfig.enabled) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
      this.createBokehPass();
    }
    if (this.ssaoPass && this.ssaoConfig.enabled) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
      this.createSSAOPass();
      this.updateSSAOPass();
    }
    if (this.bloomPass && this.bloomConfig.enabled) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
      this.createBloomPass();
      this.updateBloomPass();
    }
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // PRECOMP RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of render targets for precomps (keyed by compositionId) */
  precompTargets = /* @__PURE__ */ new Map();
  /**
   * Create or get a render target for a precomp composition
   */
  getPrecompRenderTarget(compositionId, width, height) {
    const key = `${compositionId}_${width}_${height}`;
    let target = this.precompTargets.get(key);
    if (!target) {
      target = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        type: UnsignedByteType,
        colorSpace: SRGBColorSpace,
        depthBuffer: true,
        stencilBuffer: false
      });
      this.precompTargets.set(key, target);
    }
    return target;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for precomp rendering
   */
  renderSceneToTexture(scene, camera, target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.clear();
    this.renderer.render(scene, camera);
    this.renderer.setRenderTarget(prevTarget);
    return target.texture;
  }
  /**
   * Dispose a precomp render target
   */
  disposePrecompTarget(compositionId) {
    for (const [key, target] of this.precompTargets.entries()) {
      if (key.startsWith(compositionId + "_")) {
        target.dispose();
        this.precompTargets.delete(key);
      }
    }
  }
  /**
   * Dispose all precomp render targets
   */
  disposeAllPrecompTargets() {
    for (const target of this.precompTargets.values()) {
      target.dispose();
    }
    this.precompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    if (this.bokehPass) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
    }
    if (this.ssaoPass) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
    }
    if (this.bloomPass) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
    }
    this.disposeAllPrecompTargets();
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.depthMaterial.dispose();
    this.normalMaterial.dispose();
    this.composer.dispose();
    this.renderer.dispose();
  }
}

class ImageLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  texture = null;
  /** Resource manager for texture loading */
  resources;
  /** Image dimensions */
  imageWidth = 100;
  imageHeight = 100;
  /** Source URL or asset ID */
  sourceUrl = null;
  /** Original (unprocessed) texture for effects source */
  originalTexture = null;
  /** Canvas for rendering texture to 2D for effect processing */
  textureCanvas = null;
  textureCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `image_${this.id}`;
    this.group.add(this.mesh);
    const imageData = this.extractImageData(layerData);
    if (imageData.source) {
      this.loadImage(imageData.source);
    }
    this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(layerData) {
    const data = layerData.data;
    return {
      source: data?.source ?? data?.url ?? data?.assetId ?? null,
      width: data?.width ?? 100,
      height: data?.height ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(url) {
    this.sourceUrl = url;
    try {
      const texture = await this.resources.loadTexture(url, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      });
      this.setTexture(texture);
    } catch (error) {
      layerLogger.error(`ImageLayer: Failed to load image: ${url}`, error);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(texture) {
    this.texture = texture;
    this.originalTexture = texture;
    this.material.map = texture;
    this.material.needsUpdate = true;
    if (texture.image) {
      this.imageWidth = texture.image.width || texture.image.videoWidth || 100;
      this.imageHeight = texture.image.height || texture.image.videoHeight || 100;
      this.updateMeshSize();
      this.textureCanvas = null;
      this.textureCanvasCtx = null;
      this.effectsDirty = true;
    }
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(imageData) {
    const texture = this.resources.createTextureFromImageData(
      imageData,
      `layer_${this.id}_imagedata`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(canvas) {
    const texture = this.resources.createTextureFromCanvas(
      canvas,
      `layer_${this.id}_canvas`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(this.imageWidth, this.imageHeight);
    this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(width, height) {
    this.imageWidth = width;
    this.imageHeight = height;
    this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(color) {
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215);
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.originalTexture?.image) {
      return null;
    }
    const image = this.originalTexture.image;
    if (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.width = this.imageWidth;
      this.textureCanvas.height = this.imageHeight;
      this.textureCanvasCtx = this.textureCanvas.getContext("2d");
    }
    if (!this.textureCanvasCtx) {
      return null;
    }
    this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight);
    this.textureCanvasCtx.drawImage(image, 0, 0, this.imageWidth, this.imageHeight);
    return this.textureCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.texture = processedTexture;
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    this.evaluateEffects(frame);
  }
  onApplyEvaluatedState(state) {
    if (state.properties["tint"] !== void 0) {
      this.setTint(state.properties["tint"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.source || data?.url || data?.assetId) {
      const newSource = data.source ?? data.url ?? data.assetId;
      if (newSource !== this.sourceUrl) {
        this.loadImage(newSource);
      }
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data.width ?? this.imageWidth,
        data.height ?? this.imageHeight
      );
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class SolidLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  /** Solid color */
  color;
  /** Solid dimensions */
  width;
  height;
  /** Animated color property */
  animatedColor;
  constructor(layerData) {
    super(layerData);
    const solidData = this.extractSolidData(layerData);
    this.color = solidData.color;
    this.width = solidData.width;
    this.height = solidData.height;
    this.animatedColor = solidData.animatedColor;
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new MeshBasicMaterial({
      color: this.color,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `solid_${this.id}`;
    this.group.add(this.mesh);
    this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(layerData) {
    const data = layerData.data;
    return {
      color: data?.color ?? "#808080",
      width: data?.width ?? 1920,
      height: data?.height ?? 1080,
      animatedColor: data?.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(color) {
    this.color = color;
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.animatedColor, frame);
      this.material.color.set(color);
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    if (state.properties["color"] !== void 0) {
      this.material.color.set(state.properties["color"]);
      this.material.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.color !== void 0) {
      this.setColor(data.color);
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data?.width ?? this.width,
        data?.height ?? this.height
      );
    }
    if (data?.animatedColor !== void 0) {
      this.animatedColor = data.animatedColor;
    }
    if (data === void 0 && properties.labelColor !== void 0) {
      this.setColor(properties.labelColor);
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class NullLayer extends BaseLayer {
  /** Visual indicator (crosshair) for editor visibility */
  indicator = null;
  /** Whether to show the null indicator */
  showIndicator;
  /** Indicator size */
  indicatorSize;
  constructor(layerData, showIndicator = true) {
    super(layerData);
    this.showIndicator = showIndicator;
    this.indicatorSize = 50;
    if (this.showIndicator) {
      this.createIndicator();
    }
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Group();
    this.indicator.name = `null_indicator_${this.id}`;
    const size = this.indicatorSize;
    const color = 16737792;
    const material = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const hPoints = [
      new Vector3(-size / 2, 0, 0),
      new Vector3(size / 2, 0, 0)
    ];
    const hGeometry = new BufferGeometry().setFromPoints(hPoints);
    const hLine = new Line(hGeometry, material);
    this.indicator.add(hLine);
    const vPoints = [
      new Vector3(0, -size / 2, 0),
      new Vector3(0, size / 2, 0)
    ];
    const vGeometry = new BufferGeometry().setFromPoints(vPoints);
    const vLine = new Line(vGeometry, material);
    this.indicator.add(vLine);
    if (this.threeD) {
      const zPoints = [
        new Vector3(0, 0, -size / 2),
        new Vector3(0, 0, size / 2)
      ];
      const zGeometry = new BufferGeometry().setFromPoints(zPoints);
      const zLine = new Line(zGeometry, material);
      this.indicator.add(zLine);
    }
    const centerGeometry = new CircleGeometry(3, 16);
    const centerMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false,
      side: DoubleSide
    });
    const centerPoint = new Mesh(centerGeometry, centerMaterial);
    this.indicator.add(centerPoint);
    this.group.add(this.indicator);
    this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(visible) {
    if (this.indicator) {
      this.indicator.visible = visible;
    }
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(size) {
    if (size === this.indicatorSize) return;
    this.indicatorSize = size;
    if (this.indicator) {
      this.group.remove(this.indicator);
      this.disposeIndicator();
      this.createIndicator();
    }
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    if (!this.indicator) return;
    this.indicator.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
      if (child instanceof Mesh) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.indicator.clear();
    this.indicator = null;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(_frame) {
  }
  onApplyEvaluatedState(_state) {
  }
  onUpdate(properties) {
    if (properties.threeD !== void 0 && properties.threeD !== this.threeD) {
      this.threeD = properties.threeD;
      if (this.indicator && this.showIndicator) {
        this.group.remove(this.indicator);
        this.disposeIndicator();
        this.createIndicator();
      }
    }
  }
  onDispose() {
    this.disposeIndicator();
  }
}

class ArcLengthTable {
  constructor(curve, resolution = 500) {
    this.curve = curve;
    this.build(resolution);
  }
  entries = [];
  totalLength = 0;
  build(resolution) {
    this.entries = [];
    let accumulatedLength = 0;
    let prevPoint = this.curve.getPointAt(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.getPointAt(t);
      const tangent = this.curve.getTangentAt(t);
      if (i > 0) {
        accumulatedLength += point.distanceTo(prevPoint);
      }
      this.entries.push({
        t,
        distance: accumulatedLength,
        position: point.clone(),
        tangent: tangent.clone().normalize()
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.entries.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.entries[mid].distance < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.entries[low];
    const prevEntry = this.entries[Math.max(0, low - 1)];
    if (entry.distance === prevEntry.distance) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.distance) / (entry.distance - prevEntry.distance);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    const position = this.curve.getPointAt(t);
    const tangent = this.curve.getTangentAt(t).normalize();
    const normal = new Vector3(-tangent.y, tangent.x, 0).normalize();
    return {
      position,
      tangent,
      normal,
      t,
      distance
    };
  }
}
class TextOnPathService {
  arcLengthTable = null;
  curve = null;
  /**
   * Set the path from control points
   */
  setPath(controlPoints, closed = false) {
    if (controlPoints.length < 2) {
      this.curve = null;
      this.arcLengthTable = null;
      return;
    }
    this.curve = new CurvePath();
    for (let i = 0; i < controlPoints.length - 1; i++) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (closed && controlPoints.length > 2) {
      const lastPoint = controlPoints[controlPoints.length - 1];
      const firstPoint = controlPoints[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    this.arcLengthTable = new ArcLengthTable(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(curve) {
    this.curve = curve;
    this.arcLengthTable = new ArcLengthTable(curve);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    return this.arcLengthTable?.totalLength ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(characterWidths, config, tracking = 0, fontSize = 72) {
    if (!this.arcLengthTable || characterWidths.length === 0) {
      return [];
    }
    const totalLength = this.arcLengthTable.totalLength;
    const placements = [];
    const trackingPx = tracking / 1e3 * fontSize;
    let totalTextWidth = 0;
    for (let i = 0; i < characterWidths.length; i++) {
      totalTextWidth += characterWidths[i];
      if (i < characterWidths.length - 1) {
        totalTextWidth += trackingPx;
      }
    }
    const availableLength = totalLength - config.firstMargin - config.lastMargin;
    let startDistance;
    switch (config.align) {
      case "center":
        startDistance = config.firstMargin + (availableLength - totalTextWidth) / 2;
        break;
      case "right":
        startDistance = config.firstMargin + availableLength - totalTextWidth;
        break;
      default:
        startDistance = config.firstMargin;
    }
    const offsetDistance = config.offset / 100 * availableLength;
    startDistance += offsetDistance;
    if (config.reversed) {
      startDistance = totalLength - startDistance - totalTextWidth;
    }
    let currentDistance = startDistance;
    for (let i = 0; i < characterWidths.length; i++) {
      const charWidth = characterWidths[i];
      const charCenterDistance = currentDistance + charWidth / 2;
      let actualDistance = charCenterDistance;
      let visible = true;
      if (actualDistance < 0 || actualDistance > totalLength) {
        if (config.forceAlignment) {
          actualDistance = (actualDistance % totalLength + totalLength) % totalLength;
        } else {
          visible = actualDistance >= -charWidth && actualDistance <= totalLength + charWidth;
          actualDistance = Math.max(0, Math.min(totalLength, actualDistance));
        }
      }
      const pathPoint = this.arcLengthTable.getPointAtDistance(actualDistance);
      let rotation;
      if (config.perpendicularToPath) {
        const angle = Math.atan2(pathPoint.tangent.y, pathPoint.tangent.x);
        rotation = new Euler(0, 0, config.reversed ? angle + Math.PI : angle);
      } else {
        rotation = new Euler(0, 0, 0);
      }
      placements.push({
        index: i,
        position: pathPoint.position.clone(),
        rotation,
        scale: 1,
        pathDistance: actualDistance,
        pathT: pathPoint.t,
        visible
      });
      currentDistance += charWidth + trackingPx;
    }
    return placements;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(percent) {
    if (!this.arcLengthTable) return null;
    const distance = percent / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(distance);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(count) {
    if (!this.arcLengthTable || count < 2) return [];
    const points = [];
    const spacing = this.arcLengthTable.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.arcLengthTable.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null;
    this.arcLengthTable = null;
  }
}
function createDefaultPathConfig() {
  return {
    pathLayerId: null,
    reversed: false,
    perpendicularToPath: true,
    forceAlignment: false,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}

class TextLayer extends BaseLayer {
  resources;
  // Text rendering
  textMesh;
  perCharacterGroup = null;
  characterMeshes = [];
  // Text data from layer
  textData;
  // Animatable text properties (from layer.properties)
  fontSizeProp;
  trackingProp;
  lineSpacingProp;
  fillColorProp;
  strokeColorProp;
  strokeWidthProp;
  pathOffsetProp;
  firstMarginProp;
  lastMarginProp;
  characterOffsetProp;
  // Per-character animation
  characterTransforms;
  // Path following service
  textOnPath;
  pathConfig;
  pathControlPoints = [];
  pathClosed = false;
  // Character width cache (recalculated when text/font changes)
  characterWidths = [];
  characterWidthsDirty = true;
  // Additional evaluator for text-specific properties
  textEvaluator;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.textEvaluator = new KeyframeEvaluator();
    this.textOnPath = new TextOnPathService();
    this.pathConfig = createDefaultPathConfig();
    this.textData = this.extractTextData(layerData);
    this.extractAnimatableProperties(layerData);
    this.textMesh = this.createTextMesh();
    this.group.add(this.textMesh);
    if (this.textData.perCharacter3D || this.textData.pathLayerId) {
      this.enablePerCharacter3D();
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(layerData) {
    const data = layerData.data;
    return {
      text: data?.text ?? "Text",
      fontFamily: data?.fontFamily ?? "Impact",
      fontSize: data?.fontSize ?? 72,
      fontWeight: data?.fontWeight ?? "400",
      fontStyle: data?.fontStyle ?? "normal",
      fill: data?.fill ?? "#ffffff",
      stroke: data?.stroke ?? "",
      strokeWidth: data?.strokeWidth ?? 0,
      // Character properties
      tracking: data?.tracking ?? 0,
      lineSpacing: data?.lineSpacing ?? 0,
      lineAnchor: data?.lineAnchor ?? 50,
      characterOffset: data?.characterOffset ?? 0,
      characterValue: data?.characterValue ?? 0,
      blur: data?.blur ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: data?.letterSpacing ?? data?.tracking ?? 0,
      lineHeight: data?.lineHeight ?? data?.lineSpacing ?? 1.2,
      textAlign: data?.textAlign ?? "left",
      // Path options (full AE parity)
      pathLayerId: data?.pathLayerId ?? null,
      pathReversed: data?.pathReversed ?? false,
      pathPerpendicularToPath: data?.pathPerpendicularToPath ?? true,
      pathForceAlignment: data?.pathForceAlignment ?? false,
      pathFirstMargin: data?.pathFirstMargin ?? 0,
      pathLastMargin: data?.pathLastMargin ?? 0,
      pathOffset: data?.pathOffset ?? 0,
      pathAlign: data?.pathAlign ?? "left",
      // More Options
      anchorPointGrouping: data?.anchorPointGrouping ?? "character",
      groupingAlignment: data?.groupingAlignment ?? { x: 0, y: 0 },
      fillAndStroke: data?.fillAndStroke ?? "fill-over-stroke",
      interCharacterBlending: data?.interCharacterBlending ?? "normal",
      // 3D
      perCharacter3D: data?.perCharacter3D ?? false
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(layerData) {
    if (!layerData.properties) return;
    for (const prop of layerData.properties) {
      switch (prop.name) {
        case "Font Size":
          this.fontSizeProp = prop;
          break;
        case "Tracking":
          this.trackingProp = prop;
          break;
        case "Line Spacing":
          this.lineSpacingProp = prop;
          break;
        case "Fill Color":
          this.fillColorProp = prop;
          break;
        case "Stroke Color":
          this.strokeColorProp = prop;
          break;
        case "Stroke Width":
          this.strokeWidthProp = prop;
          break;
        case "Path Offset":
          this.pathOffsetProp = prop;
          break;
        case "First Margin":
          this.firstMarginProp = prop;
          break;
        case "Last Margin":
          this.lastMarginProp = prop;
          break;
        case "Character Offset":
          this.characterOffsetProp = prop;
          break;
      }
    }
    this.syncPathConfig();
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId;
    this.pathConfig.reversed = this.textData.pathReversed;
    this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath;
    this.pathConfig.forceAlignment = this.textData.pathForceAlignment;
    this.pathConfig.firstMargin = this.textData.pathFirstMargin;
    this.pathConfig.lastMargin = this.textData.pathLastMargin;
    this.pathConfig.offset = this.textData.pathOffset;
    this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const text = new Text();
    text.text = this.textData.text;
    text.font = this.getFontUrl(this.textData.fontFamily) ?? null;
    text.fontSize = this.textData.fontSize;
    text.fontWeight = this.textData.fontWeight || "400";
    text.fontStyle = this.textData.fontStyle || "normal";
    text.color = this.textData.fill;
    if (this.textData.stroke && this.textData.strokeWidth > 0) {
      text.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
      text.outlineColor = this.textData.stroke;
    }
    text.letterSpacing = (this.textData.tracking || 0) / 1e3;
    text.lineHeight = this.textData.lineHeight || 1.2;
    text.textAlign = this.textData.textAlign;
    text.anchorX = this.getAnchorX();
    text.anchorY = "middle";
    text.depthOffset = 0;
    text.renderOrder = 0;
    text.sdfGlyphSize = 256;
    text.gpuAccelerateSDF = true;
    if (this.textData.strokeWidth > 0) {
      text.outlineBlur = 3e-3;
    }
    text.sync();
    return text;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(fontFamily) {
    const systemFonts = [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ];
    if (systemFonts.includes(fontFamily)) {
      return void 0;
    }
    const googleFonts = {
      "Roboto": "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      "Lato": "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      "Montserrat": "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      "Oswald": "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      "Poppins": "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    };
    return googleFonts[fontFamily];
  }
  /**
   * Get anchor X based on text alignment
   * Note: Swapped to match intuitive arrow button behavior:
   * - â—€ (left) button makes text appear on LEFT (anchor right edge)
   * - â–¶ (right) button makes text appear on RIGHT (anchor left edge)
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "right";
      case "right":
        return "left";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(controlPoints, closed = false) {
    this.pathControlPoints = controlPoints;
    this.pathClosed = closed;
    if (controlPoints.length >= 2) {
      this.textOnPath.setPath(controlPoints, closed);
      if (!this.perCharacterGroup) {
        this.enablePerCharacter3D();
      }
      this.updatePathLayout();
    } else {
      this.textOnPath.dispose();
      this.resetPathLayout();
    }
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(curve) {
    this.textOnPath.setCurve(curve);
    if (!this.perCharacterGroup) {
      this.enablePerCharacter3D();
    }
    this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null;
    this.pathConfig.pathLayerId = null;
    this.textOnPath.dispose();
    this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup) {
      return;
    }
    this.ensureCharacterWidths();
    const placements = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(placements);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(placements) {
    for (let i = 0; i < this.characterMeshes.length && i < placements.length; i++) {
      const mesh = this.characterMeshes[i];
      const placement = placements[i];
      mesh.position.copy(placement.position);
      mesh.rotation.copy(placement.rotation);
      mesh.scale.setScalar(placement.scale);
      mesh.visible = placement.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    if (this.textData.perCharacter3D) {
      this.createCharacterMeshes();
    } else {
      this.disablePerCharacter3D();
    }
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const text = this.textData.text;
    const avgCharWidth = this.textData.fontSize * 0.6;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (`iIl1|!.,;:'"`.includes(char)) {
        this.characterWidths.push(avgCharWidth * 0.4);
      } else if ("mwMW".includes(char)) {
        this.characterWidths.push(avgCharWidth * 1.3);
      } else if (char === " ") {
        this.characterWidths.push(avgCharWidth * 0.5);
      } else {
        this.characterWidths.push(avgCharWidth);
      }
    }
    this.characterWidthsDirty = false;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    if (this.perCharacterGroup) return;
    this.textMesh.visible = false;
    this.perCharacterGroup = new Group();
    this.perCharacterGroup.name = `text_chars_${this.id}`;
    this.group.add(this.perCharacterGroup);
    this.createCharacterMeshes();
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    if (!this.perCharacterGroup) return;
    this.textMesh.visible = true;
    this.disposeCharacterMeshes();
    this.group.remove(this.perCharacterGroup);
    this.perCharacterGroup = null;
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes();
    this.characterWidthsDirty = true;
    const text = this.textData.text;
    let xOffset = 0;
    this.ensureCharacterWidths();
    const totalWidth = this.characterWidths.reduce((a, b) => a + b, 0) + (text.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let startX = 0;
    switch (this.textData.textAlign) {
      case "center":
        startX = -totalWidth / 2;
        break;
      case "right":
        startX = -totalWidth;
        break;
      default:
        startX = 0;
    }
    xOffset = startX;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charMesh = new Text();
      charMesh.text = char;
      charMesh.font = this.getFontUrl(this.textData.fontFamily) ?? null;
      charMesh.fontSize = this.textData.fontSize;
      charMesh.fontWeight = this.textData.fontWeight || "400";
      charMesh.fontStyle = this.textData.fontStyle || "normal";
      charMesh.color = this.textData.fill;
      charMesh.anchorX = "center";
      charMesh.anchorY = "middle";
      if (this.textData.stroke && this.textData.strokeWidth > 0) {
        charMesh.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
        charMesh.outlineColor = this.textData.stroke;
        charMesh.outlineBlur = 5e-3;
      }
      charMesh.sdfGlyphSize = 128;
      const charWidth = this.characterWidths[i];
      charMesh.position.x = xOffset + charWidth / 2;
      charMesh.position.y = 0;
      charMesh.position.z = 0;
      xOffset += charWidth + this.textData.tracking / 1e3 * this.textData.fontSize;
      charMesh.sync();
      this.characterMeshes.push(charMesh);
      this.perCharacterGroup.add(charMesh);
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    for (const mesh of this.characterMeshes) {
      mesh.dispose();
      this.perCharacterGroup?.remove(mesh);
    }
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(text) {
    this.textData.text = text;
    this.textMesh.text = text;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    if (this.perCharacterGroup) {
      this.createCharacterMeshes();
    }
  }
  setFontFamily(family) {
    this.textData.fontFamily = family;
    const fontUrl = this.getFontUrl(family) ?? null;
    this.textMesh.font = fontUrl;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.font = fontUrl;
      charMesh.sync();
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setFontSize(size) {
    this.textData.fontSize = size;
    this.textMesh.fontSize = size;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.fontSize = size;
      charMesh.sync();
    }
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setFontWeight(weight) {
    this.textData.fontWeight = weight;
    this.textMesh.fontWeight = weight;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontWeight = weight;
      charMesh.sync();
    }
  }
  setFontStyle(style) {
    this.textData.fontStyle = style;
    this.textMesh.fontStyle = style;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontStyle = style;
      charMesh.sync();
    }
  }
  setFillColor(color) {
    this.textData.fill = color;
    this.textMesh.color = color;
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.color = color;
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setStroke(color, width) {
    this.textData.stroke = color;
    this.textData.strokeWidth = width;
    const outlineWidth = width > 0 ? width / this.textData.fontSize : 0;
    this.textMesh.outlineWidth = outlineWidth;
    this.textMesh.outlineColor = width > 0 ? color : "";
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.outlineWidth = outlineWidth;
      charMesh.outlineColor = width > 0 ? color : "";
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setTracking(tracking) {
    this.textData.tracking = tracking;
    this.textMesh.letterSpacing = tracking / 1e3;
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setTextAlign(align) {
    this.textData.textAlign = align;
    this.textMesh.textAlign = align;
    this.textMesh.anchorX = this.getAnchorX();
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.pathConfig.align = align;
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(offset) {
    this.textData.pathOffset = offset;
    this.pathConfig.offset = offset;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(margin) {
    this.textData.pathFirstMargin = margin;
    this.pathConfig.firstMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(margin) {
    this.textData.pathLastMargin = margin;
    this.pathConfig.lastMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set path reversed
   */
  setPathReversed(reversed) {
    this.textData.pathReversed = reversed;
    this.pathConfig.reversed = reversed;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(perpendicular) {
    this.textData.pathPerpendicularToPath = perpendicular;
    this.pathConfig.perpendicularToPath = perpendicular;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set force alignment
   */
  setForceAlignment(force) {
    this.textData.pathForceAlignment = force;
    this.pathConfig.forceAlignment = force;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setAnchorPointGrouping(grouping) {
    this.textData.anchorPointGrouping = grouping;
  }
  setFillAndStroke(order) {
    this.textData.fillAndStroke = order;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.fontSizeProp?.animated) {
      const size = this.textEvaluator.evaluate(this.fontSizeProp, frame);
      this.setFontSize(size);
    }
    if (this.trackingProp?.animated) {
      const tracking = this.textEvaluator.evaluate(this.trackingProp, frame);
      this.setTracking(tracking);
    }
    if (this.fillColorProp?.animated) {
      const color = this.textEvaluator.evaluate(this.fillColorProp, frame);
      this.setFillColor(color);
    }
    if (this.strokeColorProp?.animated && this.strokeWidthProp) {
      const color = this.textEvaluator.evaluate(this.strokeColorProp, frame);
      const width = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, frame) : this.textData.strokeWidth;
      this.setStroke(color, width);
    }
    if (this.pathOffsetProp) {
      const offset = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, frame) : this.textData.pathOffset;
      this.setPathOffset(offset);
    }
    if (this.firstMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.firstMarginProp, frame);
      this.setFirstMargin(margin);
    }
    if (this.lastMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.lastMarginProp, frame);
      this.setLastMargin(margin);
    }
    if (this.characterTransforms?.animated && this.perCharacterGroup) {
      this.applyCharacterTransforms(frame);
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["fontSize"] !== void 0) {
      this.setFontSize(props["fontSize"]);
    }
    if (props["tracking"] !== void 0) {
      this.setTracking(props["tracking"]);
    }
    if (props["fillColor"] !== void 0) {
      this.setFillColor(props["fillColor"]);
    }
    if (props["strokeColor"] !== void 0 || props["strokeWidth"] !== void 0) {
      this.setStroke(
        props["strokeColor"] ?? this.textData.stroke,
        props["strokeWidth"] ?? this.textData.strokeWidth
      );
    }
    if (props["pathOffset"] !== void 0) {
      this.setPathOffset(props["pathOffset"]);
    }
    if (props["firstMargin"] !== void 0) {
      this.setFirstMargin(props["firstMargin"]);
    }
    if (props["lastMargin"] !== void 0) {
      this.setLastMargin(props["lastMargin"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(frame) {
    if (!this.characterTransforms) return;
    const transforms = this.textEvaluator.evaluate(this.characterTransforms, frame);
    for (let i = 0; i < this.characterMeshes.length && i < transforms.length; i++) {
      const charMesh = this.characterMeshes[i];
      const t = transforms[i];
      charMesh.position.x += t.position.x;
      charMesh.position.y += t.position.y;
      charMesh.position.z += t.position.z;
      charMesh.rotation.x += MathUtils.degToRad(t.rotation.x);
      charMesh.rotation.y += MathUtils.degToRad(t.rotation.y);
      charMesh.rotation.z += MathUtils.degToRad(t.rotation.z);
      charMesh.scale.x *= t.scale.x;
      charMesh.scale.y *= t.scale.y;
      if (charMesh.material) {
        charMesh.material.opacity *= t.opacity;
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.text !== void 0) {
        this.setText(data.text);
      }
      if (data.fontFamily !== void 0) {
        this.setFontFamily(data.fontFamily);
      }
      if (data.fontSize !== void 0) {
        this.setFontSize(data.fontSize);
      }
      if (data.fontWeight !== void 0) {
        this.setFontWeight(data.fontWeight);
      }
      if (data.fontStyle !== void 0) {
        this.setFontStyle(data.fontStyle);
      }
      if (data.fill !== void 0) {
        this.setFillColor(data.fill);
      }
      if (data.stroke !== void 0 || data.strokeWidth !== void 0) {
        this.setStroke(
          data.stroke ?? this.textData.stroke,
          data.strokeWidth ?? this.textData.strokeWidth
        );
      }
      if (data.tracking !== void 0) {
        this.setTracking(data.tracking);
      }
      if (data.textAlign !== void 0) {
        this.setTextAlign(data.textAlign);
      }
      if (data.pathLayerId !== void 0) {
        this.textData.pathLayerId = data.pathLayerId;
        this.pathConfig.pathLayerId = data.pathLayerId;
      }
      if (data.pathOffset !== void 0) {
        this.setPathOffset(data.pathOffset);
      }
      if (data.pathFirstMargin !== void 0) {
        this.setFirstMargin(data.pathFirstMargin);
      }
      if (data.pathLastMargin !== void 0) {
        this.setLastMargin(data.pathLastMargin);
      }
      if (data.pathReversed !== void 0) {
        this.setPathReversed(data.pathReversed);
      }
      if (data.pathPerpendicularToPath !== void 0) {
        this.setPerpendicularToPath(data.pathPerpendicularToPath);
      }
      if (data.pathForceAlignment !== void 0) {
        this.setForceAlignment(data.pathForceAlignment);
      }
      if (data.perCharacter3D !== void 0) {
        if (data.perCharacter3D && !this.perCharacterGroup) {
          this.enablePerCharacter3D();
        } else if (!data.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup) {
          this.disablePerCharacter3D();
        }
      }
      if (data.anchorPointGrouping !== void 0) {
        this.setAnchorPointGrouping(data.anchorPointGrouping);
      }
      if (data.fillAndStroke !== void 0) {
        this.setFillAndStroke(data.fillAndStroke);
      }
    }
    if (properties.properties) {
      this.extractAnimatableProperties(properties);
    }
  }
  // ============================================================================
  // OPACITY OVERRIDE FOR TROIKA TEXT
  // ============================================================================
  /**
   * Override base class opacity to use Troika's fillOpacity
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.textMesh.fillOpacity = normalizedOpacity;
    this.textMesh.outlineOpacity = normalizedOpacity;
    for (const charMesh of this.characterMeshes) {
      charMesh.fillOpacity = normalizedOpacity;
      charMesh.outlineOpacity = normalizedOpacity;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    const bounds = this.textMesh.textRenderInfo?.blockBounds;
    if (bounds) {
      return {
        width: bounds[2] - bounds[0],
        height: bounds[3] - bounds[1]
      };
    }
    return { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose();
    this.disposeCharacterMeshes();
    this.textOnPath.dispose();
    if (this.perCharacterGroup) {
      this.group.remove(this.perCharacterGroup);
    }
  }
}

class SplineLayer extends BaseLayer {
  /** The line mesh for the spline */
  lineMesh = null;
  /** The fill mesh (if closed path with fill) */
  fillMesh = null;
  /** Spline data */
  splineData;
  /** Cached curve for path calculations */
  curve = null;
  /** Animated control points (if spline is animated) */
  animatedPoints = null;
  /** Last evaluated frame for cache invalidation */
  lastEvaluatedFrame = -1;
  /** Cached evaluated points for the current frame */
  cachedEvaluatedPoints = null;
  /** Hash of last evaluated points for change detection */
  lastPointsHash = "";
  constructor(layerData) {
    super(layerData);
    this.splineData = this.extractSplineData(layerData);
    if (this.splineData.animated && this.splineData.animatedControlPoints) {
      this.animatedPoints = this.splineData.animatedControlPoints;
    }
    this.buildSpline();
    this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(layerData) {
    const data = layerData.data;
    return {
      controlPoints: data?.controlPoints ?? [],
      closed: data?.closed ?? false,
      stroke: data?.stroke ?? "#00ff00",
      strokeWidth: data?.strokeWidth ?? 2,
      fill: data?.fill ?? "",
      pathData: data?.pathData ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    this.clearMeshes();
    const points = this.splineData.controlPoints;
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const lineGeometry = new BufferGeometry().setFromPoints(curvePoints);
    const lineMaterial = new LineBasicMaterial({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: true
    });
    this.lineMesh = new Line(lineGeometry, lineMaterial);
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(curvePoints) {
    if (curvePoints.length < 3) return;
    const shape = new Shape();
    shape.moveTo(curvePoints[0].x, curvePoints[0].y);
    for (let i = 1; i < curvePoints.length; i++) {
      shape.lineTo(curvePoints[i].x, curvePoints[i].y);
    }
    shape.closePath();
    const fillGeometry = new ShapeGeometry(shape);
    const fillMaterial = new MeshBasicMaterial({
      color: this.splineData.fill,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.fillMesh = new Mesh(fillGeometry, fillMaterial);
    this.fillMesh.name = `spline_fill_${this.id}`;
    this.fillMesh.position.z = -0.1;
    this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    if (this.lineMesh) {
      this.group.remove(this.lineMesh);
      this.lineMesh.geometry.dispose();
      this.lineMesh.material.dispose();
      this.lineMesh = null;
    }
    if (this.fillMesh) {
      this.group.remove(this.fillMesh);
      this.fillMesh.geometry.dispose();
      this.fillMesh.material.dispose();
      this.fillMesh = null;
    }
    this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(t) {
    if (!this.curve) return null;
    return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(t) {
    if (!this.curve) return null;
    return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    if (!this.curve) return 0;
    return this.curve.getLength();
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(t) {
    const point = this.getPointAt(t);
    const tangent = this.getTangentAt(t);
    if (!point || !tangent) return null;
    const rotation = Math.atan2(tangent.y, tangent.x) * (180 / Math.PI);
    return { position: point, rotation };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(color) {
    this.splineData.stroke = color;
    if (this.lineMesh) {
      this.lineMesh.material.color.set(color);
    }
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(width) {
    this.splineData.strokeWidth = width;
    if (this.lineMesh) {
      this.lineMesh.material.linewidth = width;
    }
  }
  /**
   * Set fill color
   */
  setFill(color) {
    this.splineData.fill = color;
    if (this.fillMesh) {
      this.fillMesh.material.color.set(color);
    } else if (color && this.splineData.closed && this.curve) {
      const curvePoints = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(curvePoints);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(points) {
    this.splineData.controlPoints = points;
    this.animatedPoints = null;
    this.splineData.animated = false;
    this.buildSpline();
  }
  /**
   * Set animated control points
   * Enables animation mode for this spline
   */
  setAnimatedControlPoints(points) {
    this.animatedPoints = points;
    this.splineData.animatedControlPoints = points;
    this.splineData.animated = true;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
  }
  /**
   * Enable animation on this spline by converting static control points
   * to AnimatableControlPoint format
   */
  enableAnimation() {
    if (this.animatedPoints) {
      return this.animatedPoints;
    }
    const { controlPointToAnimatable } = require("@/types/project");
    const animatedPoints = this.splineData.controlPoints.map(
      (cp) => controlPointToAnimatable(cp)
    );
    this.setAnimatedControlPoints(animatedPoints);
    return animatedPoints;
  }
  /**
   * Disable animation and convert back to static control points
   */
  disableAnimation() {
    if (!this.animatedPoints) return;
    const { animatableToControlPoint } = require("@/types/project");
    this.splineData.controlPoints = this.animatedPoints.map(
      (acp) => animatableToControlPoint(acp)
    );
    this.animatedPoints = null;
    this.splineData.animatedControlPoints = void 0;
    this.splineData.animated = false;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
    this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(closed) {
    if (this.splineData.closed === closed) return;
    this.splineData.closed = closed;
    this.buildSpline();
  }
  /**
   * Check if the spline path is closed
   */
  isClosed() {
    return this.splineData.closed;
  }
  // ============================================================================
  // ANIMATED SPLINE EVALUATION
  // ============================================================================
  /**
   * Check if this spline has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   * Uses interpolateProperty from interpolation.ts
   * Driven values override interpolated values
   */
  evaluateControlPointAtFrame(acp, frame, index) {
    const interpolatedX = interpolateProperty(acp.x, frame);
    const interpolatedY = interpolateProperty(acp.y, frame);
    const interpolatedDepth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    return {
      id: acp.id,
      x: this.getDrivenControlPointValue(index, "x", interpolatedX),
      y: this.getDrivenControlPointValue(index, "y", interpolatedY),
      depth: this.getDrivenControlPointValue(index, "depth", interpolatedDepth),
      handleIn: acp.handleIn ? {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      } : null,
      handleOut: acp.handleOut ? {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      } : null,
      type: acp.type
    };
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer and other consumers
   *
   * For static splines, returns the static control points converted to EvaluatedControlPoint
   * For animated splines, interpolates all control points at the given frame
   * Driven values (from PropertyDriverSystem) override interpolated values
   *
   * DETERMINISM: Same frame + same drivers = same output (pure function)
   */
  getEvaluatedControlPoints(frame) {
    const hasDrivenValues = this.hasSplineDrivers();
    if (frame === this.lastEvaluatedFrame && this.cachedEvaluatedPoints && !hasDrivenValues) {
      return this.cachedEvaluatedPoints;
    }
    let points;
    if (this.animatedPoints && this.animatedPoints.length > 0) {
      points = this.animatedPoints.map(
        (acp, index) => this.evaluateControlPointAtFrame(acp, frame, index)
      );
    } else {
      points = this.splineData.controlPoints.map((cp, index) => ({
        id: cp.id,
        x: this.getDrivenControlPointValue(index, "x", cp.x),
        y: this.getDrivenControlPointValue(index, "y", cp.y),
        depth: this.getDrivenControlPointValue(index, "depth", cp.depth ?? 0),
        handleIn: cp.handleIn,
        handleOut: cp.handleOut,
        type: cp.type
      }));
    }
    this.lastEvaluatedFrame = frame;
    if (!hasDrivenValues) {
      this.cachedEvaluatedPoints = points;
    }
    return points;
  }
  /**
   * Check if any spline control point drivers are active
   */
  hasSplineDrivers() {
    for (const key of this.drivenValues.keys()) {
      if (isSplineControlPointPath(key)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get a driven control point value, falling back to base value
   */
  getDrivenControlPointValue(index, property, baseValue) {
    const path = createSplineControlPointPath(index, property);
    return this.getDrivenOrBase(path, baseValue);
  }
  /**
   * Compute a hash of control point positions for change detection
   * Used to avoid rebuilding geometry when positions haven't changed
   */
  computePointsHash(points) {
    return points.map(
      (p) => `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.depth.toFixed(2)}`
    ).join("|");
  }
  /**
   * Build spline geometry from evaluated control points
   * Called when control points change during animation
   */
  buildSplineFromEvaluatedPoints(points) {
    this.clearMeshes();
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth;
      const z1 = p1.depth;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth;
      const zFirst = firstPoint.depth;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const lineGeometry = new BufferGeometry().setFromPoints(curvePoints);
    const lineMaterial = new LineBasicMaterial({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: true
    });
    this.lineMesh = new Line(lineGeometry, lineMaterial);
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.isAnimated()) {
      return;
    }
    const evaluatedPoints = this.getEvaluatedControlPoints(frame);
    const pointsHash = this.computePointsHash(evaluatedPoints);
    if (pointsHash !== this.lastPointsHash) {
      this.buildSplineFromEvaluatedPoints(evaluatedPoints);
      this.lastPointsHash = pointsHash;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["controlPoints"] !== void 0) {
      const points = props["controlPoints"];
      const pointsHash = this.computePointsHash(points);
      if (pointsHash !== this.lastPointsHash) {
        this.buildSplineFromEvaluatedPoints(points);
        this.lastPointsHash = pointsHash;
      }
    }
    if (props["strokeWidth"] !== void 0) {
      this.setStrokeWidth(props["strokeWidth"]);
    }
    if (props["strokeColor"] !== void 0) {
      this.setStroke(props["strokeColor"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      let needsRebuild = false;
      if (data.animatedControlPoints !== void 0) {
        this.setAnimatedControlPoints(data.animatedControlPoints);
        needsRebuild = false;
      } else if (data.controlPoints !== void 0) {
        this.splineData.controlPoints = data.controlPoints;
        if (!data.animated) {
          this.animatedPoints = null;
          this.splineData.animated = false;
        }
        needsRebuild = true;
      }
      if (data.animated !== void 0) {
        if (data.animated && !this.animatedPoints) {
          this.enableAnimation();
          needsRebuild = false;
        } else if (!data.animated && this.animatedPoints) {
          this.disableAnimation();
          needsRebuild = false;
        }
      }
      if (data.closed !== void 0 && data.closed !== this.splineData.closed) {
        this.splineData.closed = data.closed;
        needsRebuild = true;
      }
      if (data.stroke !== void 0) {
        this.setStroke(data.stroke);
      }
      if (data.strokeWidth !== void 0) {
        this.setStrokeWidth(data.strokeWidth);
      }
      if (data.fill !== void 0) {
        this.setFill(data.fill);
      }
      if (needsRebuild) {
        this.buildSpline();
      }
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}

const PARTICLE_STRIDE = 16;
const MAX_FORCE_FIELDS = 16;
const SPATIAL_CELL_SIZE = 50;
const TF_VARYINGS = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function createDefaultEmitter(id) {
  return {
    id: id || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: true,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: false,
    beatEmissionMultiplier: 5
  };
}
function createDefaultForceField(type, id) {
  const base = {
    id: id || `force_${Date.now()}`,
    name: type.charAt(0).toUpperCase() + type.slice(1),
    type,
    enabled: true,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (type) {
    case "gravity":
      base.direction = { x: 0, y: 1, z: 0 };
      base.strength = 98;
      break;
    case "vortex":
      base.vortexAxis = { x: 0, y: 0, z: 1 };
      base.inwardForce = 20;
      break;
    case "turbulence":
      base.noiseScale = 5e-3;
      base.noiseSpeed = 0.5;
      base.noiseOctaves = 3;
      base.noiseLacunarity = 2;
      base.noiseGain = 0.5;
      break;
    case "drag":
      base.linearDrag = 0.1;
      base.quadraticDrag = 0.01;
      break;
    case "wind":
      base.windDirection = { x: 1, y: 0, z: 0 };
      base.gustStrength = 50;
      base.gustFrequency = 0.1;
      break;
    case "lorenz":
      base.lorenzSigma = 10;
      base.lorenzRho = 28;
      base.lorenzBeta = 2.667;
      break;
  }
  return base;
}
function createDefaultConfig() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: true,
      depthWrite: false,
      depthTest: true,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: false,
        receiveShadows: false,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: false,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: false,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: false,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: false,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: false,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: SPATIAL_CELL_SIZE,
    updateFrequency: 1,
    cullOffscreen: true
  };
}
class GPUParticleSystem {
  config;
  gl = null;
  renderer = null;
  // Double-buffered particle data
  particleBufferA;
  particleBufferB;
  currentBuffer = "A";
  // WebGL resources
  transformFeedbackProgram = null;
  renderProgram = null;
  vaoA = null;
  vaoB = null;
  particleVboA = null;
  particleVboB = null;
  transformFeedbackA = null;
  transformFeedbackB = null;
  // Three.js integration
  particleMesh = null;
  instancedGeometry = null;
  material = null;
  // Textures for modulation curves
  sizeOverLifetimeTexture = null;
  opacityOverLifetimeTexture = null;
  colorOverLifetimeTexture = null;
  // Emitter state
  emitters = /* @__PURE__ */ new Map();
  forceFields = /* @__PURE__ */ new Map();
  subEmitters = /* @__PURE__ */ new Map();
  // Runtime state
  state = {
    particleCount: 0,
    activeEmitters: 0,
    simulationTime: 0,
    frameCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0,
    gpuMemoryBytes: 0,
    currentAudioFeatures: /* @__PURE__ */ new Map()
  };
  // Audio reactivity
  audioFeatures = /* @__PURE__ */ new Map();
  // Spatial hash for neighbor queries (flocking)
  spatialHash = /* @__PURE__ */ new Map();
  // Event system
  eventHandlers = /* @__PURE__ */ new Map();
  // Pool of free particle indices
  freeIndices = [];
  nextParticleIndex = 0;
  // Random number generator with seed
  rng;
  constructor(config = {}) {
    this.config = { ...createDefaultConfig(), ...config };
    const bufferSize = this.config.maxParticles * PARTICLE_STRIDE;
    this.particleBufferA = new Float32Array(bufferSize);
    this.particleBufferB = new Float32Array(bufferSize);
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now());
    this.config.emitters.forEach((e) => this.addEmitter(e));
    this.config.forceFields.forEach((f) => this.addForceField(f));
    this.config.subEmitters.forEach((s) => this.addSubEmitter(s));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  // GPU physics mode flag
  useGPUPhysics = false;
  gpuPhysicsInitialized = false;
  // Force field uniform buffer for GPU physics
  forceFieldBuffer = null;
  forceFieldTexture = null;
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(renderer) {
    this.renderer = renderer;
    this.gl = renderer.getContext();
    if (!this.gl) {
      throw new Error("WebGL2 context required for GPU particle system");
    }
    this.createModulationTextures();
    this.createParticleMesh();
    this.initializeGPUPhysics();
    this.state.gpuMemoryBytes = this.config.maxParticles * PARTICLE_STRIDE * 4 * 2;
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    const tfExtension = gl.getExtension("EXT_color_buffer_float");
    if (!tfExtension) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback");
      this.useGPUPhysics = false;
      return;
    }
    try {
      this.transformFeedbackProgram = this.createTransformFeedbackProgram(gl);
      if (!this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics");
        this.useGPUPhysics = false;
        return;
      }
      this.particleVboA = gl.createBuffer();
      this.particleVboB = gl.createBuffer();
      if (!this.particleVboA || !this.particleVboB) {
        throw new Error("Failed to create particle VBOs");
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboA);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferA, gl.DYNAMIC_COPY);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboB);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferB, gl.DYNAMIC_COPY);
      this.vaoA = gl.createVertexArray();
      this.vaoB = gl.createVertexArray();
      if (!this.vaoA || !this.vaoB) {
        throw new Error("Failed to create VAOs");
      }
      this.setupParticleVAO(gl, this.vaoA, this.particleVboA);
      this.setupParticleVAO(gl, this.vaoB, this.particleVboB);
      this.transformFeedbackA = gl.createTransformFeedback();
      this.transformFeedbackB = gl.createTransformFeedback();
      if (!this.transformFeedbackA || !this.transformFeedbackB) {
        throw new Error("Failed to create transform feedback objects");
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackA);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackB);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      this.forceFieldBuffer = new Float32Array(MAX_FORCE_FIELDS * 16);
      this.forceFieldTexture = new DataTexture(
        this.forceFieldBuffer,
        MAX_FORCE_FIELDS,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        RGBAFormat,
        FloatType
      );
      this.useGPUPhysics = true;
      this.gpuPhysicsInitialized = true;
      console.log("GPU physics initialized with Transform Feedback");
    } catch (error) {
      console.warn("GPU physics initialization failed:", error);
      this.useGPUPhysics = false;
      this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(gl, vao, vbo) {
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const stride = PARTICLE_STRIDE * 4;
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 2, gl.FLOAT, false, stride, 32);
    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 2, gl.FLOAT, false, stride, 40);
    gl.enableVertexAttribArray(5);
    gl.vertexAttribPointer(5, 4, gl.FLOAT, false, stride, 48);
    gl.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(gl) {
    const vsSource = this.getTransformFeedbackVertexShader();
    const fsSource = this.getTransformFeedbackFragmentShader();
    const vs = gl.createShader(gl.VERTEX_SHADER);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    if (!vs || !fs) return null;
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback vertex shader error:", gl.getShaderInfoLog(vs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback fragment shader error:", gl.getShaderInfoLog(fs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    const program = gl.createProgram();
    if (!program) {
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.transformFeedbackVaryings(program, TF_VARYINGS, gl.INTERLEAVED_ATTRIBS);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Transform feedback program link error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.deleteShader(vs);
    gl.deleteShader(fs);
    return program;
  }
  /**
   * Get the vertex shader for transform feedback GPU physics
   */
  getTransformFeedbackVertexShader() {
    return `#version 300 es
      precision highp float;

      // Input particle attributes
      layout(location = 0) in vec3 a_position;
      layout(location = 1) in vec3 a_velocity;
      layout(location = 2) in vec2 a_life;      // age, lifetime
      layout(location = 3) in vec2 a_physical;  // mass, size
      layout(location = 4) in vec2 a_rotation;  // rotation, angularVelocity
      layout(location = 5) in vec4 a_color;

      // Output (transform feedback)
      out vec3 tf_position;
      out vec3 tf_velocity;
      out vec2 tf_life;
      out vec2 tf_physical;
      out vec2 tf_rotation;
      out vec4 tf_color;

      // Uniforms
      uniform float u_deltaTime;
      uniform float u_time;
      uniform int u_forceFieldCount;
      uniform sampler2D u_forceFields;

      // Noise functions for turbulence
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      // Calculate force from a single force field
      vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
        // Read force field data from texture
        // Row 0: position.xyz, type
        // Row 1: strength, falloffStart, falloffEnd, falloffType
        // Row 2: direction/axis.xyz, extra param
        // Row 3: extra params (noise scale, speed, etc)

        vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
        vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
        vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
        vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);

        vec3 fieldPos = row0.xyz;
        int fieldType = int(row0.w);
        float strength = row1.x;
        float falloffStart = row1.y;
        float falloffEnd = row1.z;
        int falloffType = int(row1.w);

        // Calculate distance and falloff
        vec3 toField = fieldPos - pos;
        float dist = length(toField);

        float falloff = 1.0;
        if (dist > falloffStart && falloffEnd > falloffStart) {
          float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
          if (falloffType == 1) falloff = 1.0 - t; // Linear
          else if (falloffType == 2) falloff = 1.0 - t * t; // Quadratic
          else if (falloffType == 3) falloff = exp(-t * 3.0); // Exponential
          else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t); // Smoothstep
        }

        vec3 force = vec3(0.0);
        float effectiveStrength = strength * falloff;

        // Force field types
        if (fieldType == 0) {
          // Gravity - directional
          force = row2.xyz * effectiveStrength;
        }
        else if (fieldType == 1) {
          // Point attractor
          if (dist > 0.001) {
            vec3 dir = normalize(toField);
            force = dir * effectiveStrength / max(mass, 0.1);
          }
        }
        else if (fieldType == 2) {
          // Vortex
          if (dist > 0.001) {
            vec3 axis = normalize(row2.xyz);
            vec3 tangent = normalize(cross(axis, toField));
            float inward = row2.w;
            force = tangent * effectiveStrength + normalize(toField) * inward;
          }
        }
        else if (fieldType == 3) {
          // Turbulence
          float noiseScale = row3.x;
          float noiseSpeed = row3.y;
          vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
          force.x = snoise(noisePos) * effectiveStrength;
          force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
          force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
        }
        else if (fieldType == 4) {
          // Drag
          float linearDrag = row3.x;
          float quadDrag = row3.y;
          float speed = length(vel);
          if (speed > 0.001) {
            float dragMag = linearDrag * speed + quadDrag * speed * speed;
            force = -normalize(vel) * dragMag * effectiveStrength;
          }
        }
        else if (fieldType == 5) {
          // Wind
          vec3 windDir = normalize(row2.xyz);
          float gustStrength = row3.x;
          float gustFreq = row3.y;
          float gust = sin(u_time * gustFreq) * gustStrength;
          force = windDir * (effectiveStrength + gust);
        }

        return force;
      }

      void main() {
        // Pass through dead particles unchanged
        if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
          tf_position = a_position;
          tf_velocity = a_velocity;
          tf_life = a_life;
          tf_physical = a_physical;
          tf_rotation = a_rotation;
          tf_color = a_color;
          return;
        }

        // Read particle state
        vec3 pos = a_position;
        vec3 vel = a_velocity;
        float age = a_life.x;
        float lifetime = a_life.y;
        float mass = a_physical.x;
        float size = a_physical.y;
        float rotation = a_rotation.x;
        float angularVel = a_rotation.y;

        // Accumulate forces
        vec3 totalForce = vec3(0.0);
        for (int i = 0; i < u_forceFieldCount; i++) {
          totalForce += calculateForce(i, pos, vel, mass);
        }

        // Apply acceleration (F = ma)
        vec3 acceleration = totalForce / max(mass, 0.1);
        vel += acceleration * u_deltaTime;

        // Integrate position
        pos += vel * u_deltaTime;

        // Update rotation
        rotation += angularVel * u_deltaTime;

        // Update age
        age += u_deltaTime;

        // Life ratio for modulation
        float lifeRatio = age / lifetime;

        // Apply size over lifetime (simple linear fade for now)
        // More complex curves should be done via texture lookup
        float sizeMod = 1.0 - lifeRatio * 0.5;
        size = a_physical.y * sizeMod;

        // Apply opacity over lifetime
        float opacityMod = 1.0 - lifeRatio;

        // Output
        tf_position = pos;
        tf_velocity = vel;
        tf_life = vec2(age, lifetime);
        tf_physical = vec2(mass, size);
        tf_rotation = vec2(rotation, angularVel);
        tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
      }
    `;
  }
  /**
   * Get the fragment shader for transform feedback (must exist but won't output)
   */
  getTransformFeedbackFragmentShader() {
    return `#version 300 es
      precision highp float;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(0.0);
      }
    `;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    if (this.transformFeedbackProgram) {
      gl.deleteProgram(this.transformFeedbackProgram);
      this.transformFeedbackProgram = null;
    }
    if (this.particleVboA) {
      gl.deleteBuffer(this.particleVboA);
      this.particleVboA = null;
    }
    if (this.particleVboB) {
      gl.deleteBuffer(this.particleVboB);
      this.particleVboB = null;
    }
    if (this.vaoA) {
      gl.deleteVertexArray(this.vaoA);
      this.vaoA = null;
    }
    if (this.vaoB) {
      gl.deleteVertexArray(this.vaoB);
      this.vaoB = null;
    }
    if (this.transformFeedbackA) {
      gl.deleteTransformFeedback(this.transformFeedbackA);
      this.transformFeedbackA = null;
    }
    if (this.transformFeedbackB) {
      gl.deleteTransformFeedback(this.transformFeedbackB);
      this.transformFeedbackB = null;
    }
    this.forceFieldTexture?.dispose();
    this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(enabled) {
    if (enabled && !this.gpuPhysicsInitialized) {
      this.initializeGPUPhysics();
    }
    this.useGPUPhysics = enabled && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const resolution = 256;
    const sizeData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, sizeData);
    this.sizeOverLifetimeTexture = new DataTexture(
      sizeData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.sizeOverLifetimeTexture.needsUpdate = true;
    const opacityData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, opacityData);
    this.opacityOverLifetimeTexture = new DataTexture(
      opacityData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.opacityOverLifetimeTexture.needsUpdate = true;
    const colorStops = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ];
    const colorData = new Float32Array(resolution * 4);
    for (let i = 0; i < resolution; i++) {
      const t = i / (resolution - 1);
      const color = this.sampleColorGradient(colorStops, t);
      colorData[i * 4] = color[0];
      colorData[i * 4 + 1] = color[1];
      colorData[i * 4 + 2] = color[2];
      colorData[i * 4 + 3] = color[3];
    }
    this.colorOverLifetimeTexture = new DataTexture(
      colorData,
      resolution,
      1,
      RGBAFormat,
      FloatType
    );
    this.colorOverLifetimeTexture.needsUpdate = true;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(curve, output) {
    const len = output.length;
    if (!curve) {
      output.fill(1);
      return;
    }
    for (let i = 0; i < len; i++) {
      const t = i / (len - 1);
      output[i] = this.evaluateModulationCurve(curve, t);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(curve, t) {
    switch (curve.type) {
      case "constant":
        return curve.value;
      case "linear":
        return curve.start + (curve.end - curve.start) * t;
      case "curve": {
        const points = curve.points;
        if (points.length === 0) return 1;
        if (points.length === 1) return points[0].value;
        let p0 = points[0];
        let p1 = points[points.length - 1];
        for (let i = 0; i < points.length - 1; i++) {
          if (t >= points[i].time && t <= points[i + 1].time) {
            p0 = points[i];
            p1 = points[i + 1];
            break;
          }
        }
        const localT = (t - p0.time) / (p1.time - p0.time);
        const t2 = localT * localT;
        const t3 = t2 * localT;
        const h1 = 2 * t3 - 3 * t2 + 1;
        const h2 = -2 * t3 + 3 * t2;
        const h3 = t3 - 2 * t2 + localT;
        const h4 = t3 - t2;
        return h1 * p0.value + h2 * p1.value + h3 * (p0.outTangent ?? 0) + h4 * (p1.inTangent ?? 0);
      }
      case "random":
        return curve.min + this.rng() * (curve.max - curve.min);
      case "randomCurve": {
        const min = this.evaluateModulationCurve(curve.minCurve, t);
        const max = this.evaluateModulationCurve(curve.maxCurve, t);
        return min + this.rng() * (max - min);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(stops, t) {
    if (stops.length === 0) return [1, 1, 1, 1];
    if (stops.length === 1) return stops[0].color;
    let s0 = stops[0];
    let s1 = stops[stops.length - 1];
    for (let i = 0; i < stops.length - 1; i++) {
      if (t >= stops[i].time && t <= stops[i + 1].time) {
        s0 = stops[i];
        s1 = stops[i + 1];
        break;
      }
    }
    const localT = (t - s0.time) / (s1.time - s0.time);
    return [
      s0.color[0] + (s1.color[0] - s0.color[0]) * localT,
      s0.color[1] + (s1.color[1] - s0.color[1]) * localT,
      s0.color[2] + (s1.color[2] - s0.color[2]) * localT,
      s0.color[3] + (s1.color[3] - s0.color[3]) * localT
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const quadVertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    const quadUVs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new InstancedBufferGeometry();
    this.instancedGeometry.setAttribute("position", new BufferAttribute(quadVertices, 2));
    this.instancedGeometry.setAttribute("uv", new BufferAttribute(quadUVs, 2));
    const positionAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const velocityAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const lifeAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const physicalAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const rotationAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const colorAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    positionAttr.setUsage(DynamicDrawUsage);
    velocityAttr.setUsage(DynamicDrawUsage);
    lifeAttr.setUsage(DynamicDrawUsage);
    physicalAttr.setUsage(DynamicDrawUsage);
    rotationAttr.setUsage(DynamicDrawUsage);
    colorAttr.setUsage(DynamicDrawUsage);
    this.instancedGeometry.setAttribute("i_position", positionAttr);
    this.instancedGeometry.setAttribute("i_velocity", velocityAttr);
    this.instancedGeometry.setAttribute("i_life", lifeAttr);
    this.instancedGeometry.setAttribute("i_physical", physicalAttr);
    this.instancedGeometry.setAttribute("i_rotation", rotationAttr);
    this.instancedGeometry.setAttribute("i_color", colorAttr);
    this.material = new ShaderMaterial({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: true,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    });
    this.particleMesh = new Mesh(this.instancedGeometry, this.material);
    this.particleMesh.frustumCulled = false;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, {
      ...config,
      accumulator: 0,
      velocity: new Vector3()
    });
    this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(config) {
    this.forceFields.set(config.id, config);
  }
  updateForceField(id, updates) {
    const field = this.forceFields.get(id);
    if (field) {
      Object.assign(field, updates);
    }
  }
  removeForceField(id) {
    this.forceFields.delete(id);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(config) {
    this.subEmitters.set(config.id, config);
  }
  removeSubEmitter(id) {
    this.subEmitters.delete(id);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(deltaTime) {
    const startTime = performance.now();
    const dt = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : deltaTime * this.config.timeScale;
    this.emitParticles(dt);
    if (this.useGPUPhysics && this.gl) {
      this.updatePhysicsGPU(dt);
    } else {
      this.updatePhysics(dt);
    }
    this.processSubEmitters();
    if (this.config.flocking?.enabled) {
      this.updateSpatialHash();
      this.applyFlocking(dt);
    }
    this.applyAudioModulation();
    this.updateInstanceBuffers();
    this.state.simulationTime += dt;
    this.state.frameCount++;
    this.state.updateTimeMs = performance.now() - startTime;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(dt) {
    for (const emitter of this.emitters.values()) {
      if (!emitter.enabled) continue;
      let emissionRate = emitter.emissionRate;
      const audioMod = this.getAudioModulation("emitter", emitter.id, "emissionRate");
      if (audioMod !== void 0) {
        emissionRate *= audioMod;
      }
      if (emitter.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const burstCount = Math.floor(emitter.burstCount * emitter.beatEmissionMultiplier);
        for (let i = 0; i < burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
      emitter.accumulator += emissionRate * dt;
      while (emitter.accumulator >= 1) {
        this.spawnParticle(emitter);
        emitter.accumulator -= 1;
      }
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(emitter) {
    if (this.freeIndices.length === 0) {
      let oldestIndex = 0;
      let oldestAge = 0;
      const buffer2 = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let i = 0; i < this.config.maxParticles; i++) {
        const age = buffer2[i * PARTICLE_STRIDE + 6];
        if (age > oldestAge) {
          oldestAge = age;
          oldestIndex = i;
        }
      }
      this.freeIndices.push(oldestIndex);
    }
    const index = this.freeIndices.pop();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const offset = index * PARTICLE_STRIDE;
    const pos = this.getEmitterPosition(emitter);
    const dir = this.getEmissionDirection(emitter);
    const speed = emitter.initialSpeed + (this.rng() - 0.5) * 2 * emitter.speedVariance;
    const inheritVel = emitter.velocity.clone().multiplyScalar(emitter.inheritEmitterVelocity);
    buffer[offset + 0] = pos.x;
    buffer[offset + 1] = pos.y;
    buffer[offset + 2] = pos.z;
    buffer[offset + 3] = dir.x * speed + inheritVel.x;
    buffer[offset + 4] = dir.y * speed + inheritVel.y;
    buffer[offset + 5] = dir.z * speed + inheritVel.z;
    buffer[offset + 6] = 0;
    buffer[offset + 7] = emitter.lifetime + (this.rng() - 0.5) * 2 * emitter.lifetimeVariance;
    buffer[offset + 8] = emitter.initialMass + (this.rng() - 0.5) * 2 * emitter.massVariance;
    buffer[offset + 9] = emitter.initialSize + (this.rng() - 0.5) * 2 * emitter.sizeVariance;
    buffer[offset + 10] = emitter.initialRotation + this.rng() * emitter.rotationVariance;
    buffer[offset + 11] = emitter.initialAngularVelocity + (this.rng() - 0.5) * 2 * emitter.angularVelocityVariance;
    const colorT = this.rng() * emitter.colorVariance;
    buffer[offset + 12] = emitter.colorStart[0] + (emitter.colorEnd[0] - emitter.colorStart[0]) * colorT;
    buffer[offset + 13] = emitter.colorStart[1] + (emitter.colorEnd[1] - emitter.colorStart[1]) * colorT;
    buffer[offset + 14] = emitter.colorStart[2] + (emitter.colorEnd[2] - emitter.colorStart[2]) * colorT;
    buffer[offset + 15] = emitter.colorStart[3];
    this.state.particleCount++;
    this.emit("particleBirth", { index, emitterId: emitter.id });
    return index;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(emitter) {
    const shape = emitter.shape;
    const base = new Vector3(emitter.position.x, emitter.position.y, emitter.position.z);
    switch (shape.type) {
      case "point":
        return base;
      case "circle": {
        const angle = this.rng() * Math.PI * 2;
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.sqrt(this.rng());
        }
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          0
        ));
      }
      case "sphere": {
        const theta = this.rng() * Math.PI * 2;
        const phi = Math.acos(2 * this.rng() - 1);
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.cbrt(this.rng());
        }
        return base.add(new Vector3(
          Math.sin(phi) * Math.cos(theta) * radius,
          Math.sin(phi) * Math.sin(theta) * radius,
          Math.cos(phi) * radius
        ));
      }
      case "box": {
        const size = shape.boxSize ?? { x: 100, y: 100, z: 100 };
        return base.add(new Vector3(
          (this.rng() - 0.5) * size.x,
          (this.rng() - 0.5) * size.y,
          (this.rng() - 0.5) * size.z
        ));
      }
      case "line": {
        const start = shape.lineStart ?? { x: -50, y: 0, z: 0 };
        const end = shape.lineEnd ?? { x: 50, y: 0, z: 0 };
        const t = this.rng();
        return base.add(new Vector3(
          start.x + (end.x - start.x) * t,
          start.y + (end.y - start.y) * t,
          start.z + (end.z - start.z) * t
        ));
      }
      case "cone": {
        const angle = this.rng() * Math.PI * 2;
        const t = this.rng();
        const radius = t * (shape.coneRadius ?? 50);
        const height = t * (shape.coneLength ?? 100);
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        ));
      }
      case "image": {
        if (!shape.imageData) return base;
        const { width, height, data } = shape.imageData;
        const threshold = shape.emissionThreshold ?? 0.1;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * width);
          const py = Math.floor(this.rng() * height);
          const idx = (py * width + px) * 4;
          const alpha = data[idx + 3] / 255;
          if (alpha > threshold) {
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              0
            ));
          }
        }
        return base;
      }
      case "depthEdge": {
        if (!shape.depthData || !shape.imageData) return base;
        const { width, height } = shape.imageData;
        const depthData = shape.depthData;
        const threshold = shape.emissionThreshold ?? 0.05;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * (width - 2)) + 1;
          const py = Math.floor(this.rng() * (height - 2)) + 1;
          const idx = py * width + px;
          const d = depthData[idx];
          const dLeft = depthData[idx - 1];
          const dRight = depthData[idx + 1];
          const dUp = depthData[idx - width];
          const dDown = depthData[idx + width];
          const gradX = Math.abs(dRight - dLeft);
          const gradY = Math.abs(dDown - dUp);
          const gradient = Math.sqrt(gradX * gradX + gradY * gradY);
          if (gradient > threshold) {
            const z = d * 500;
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              z
            ));
          }
        }
        return base;
      }
      default:
        return base;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(emitter) {
    const baseDir = new Vector3(
      emitter.emissionDirection.x,
      emitter.emissionDirection.y,
      emitter.emissionDirection.z
    ).normalize();
    if (emitter.emissionSpread <= 0) {
      return baseDir;
    }
    const spreadRad = emitter.emissionSpread * Math.PI / 180;
    const theta = this.rng() * Math.PI * 2;
    const phi = Math.acos(1 - this.rng() * (1 - Math.cos(spreadRad)));
    const up = Math.abs(baseDir.y) < 0.99 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0);
    const right = new Vector3().crossVectors(up, baseDir).normalize();
    const realUp = new Vector3().crossVectors(baseDir, right);
    return new Vector3().addScaledVector(baseDir, Math.cos(phi)).addScaledVector(right, Math.sin(phi) * Math.cos(theta)).addScaledVector(realUp, Math.sin(phi) * Math.sin(theta)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(dt) {
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = buffer[offset + 6];
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0 || age >= lifetime) continue;
      let px = buffer[offset + 0];
      let py = buffer[offset + 1];
      let pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      const mass = buffer[offset + 8];
      let fx = 0, fy = 0, fz = 0;
      for (const field of this.forceFields.values()) {
        if (!field.enabled) continue;
        const force = this.calculateForceField(field, px, py, pz, vx, vy, vz, mass);
        fx += force.x;
        fy += force.y;
        fz += force.z;
      }
      const ax = fx / Math.max(mass, 0.1);
      const ay = fy / Math.max(mass, 0.1);
      const az = fz / Math.max(mass, 0.1);
      vx += ax * dt;
      vy += ay * dt;
      vz += az * dt;
      px += vx * dt;
      py += vy * dt;
      pz += vz * dt;
      const lifeRatio = age / lifetime;
      const sizeMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const opacityMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const rotation = buffer[offset + 10] + buffer[offset + 11] * dt;
      buffer[offset + 0] = px;
      buffer[offset + 1] = py;
      buffer[offset + 2] = pz;
      buffer[offset + 3] = vx;
      buffer[offset + 4] = vy;
      buffer[offset + 5] = vz;
      buffer[offset + 6] = age + dt;
      buffer[offset + 9] *= sizeMod;
      buffer[offset + 10] = rotation;
      buffer[offset + 15] *= opacityMod;
      if (age + dt >= lifetime) {
        this.freeIndices.push(i);
        this.state.particleCount--;
        this.emit("particleDeath", { index: i });
      }
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(dt) {
    if (!this.gl || !this.transformFeedbackProgram) return;
    const gl = this.gl;
    this.updateForceFieldTexture();
    gl.useProgram(this.transformFeedbackProgram);
    const dtLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime");
    const timeLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_time");
    const ffCountLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount");
    const ffTexLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    gl.uniform1f(dtLoc, dt);
    gl.uniform1f(timeLoc, this.state.simulationTime);
    gl.uniform1i(ffCountLoc, Math.min(this.forceFields.size, MAX_FORCE_FIELDS));
    if (this.forceFieldTexture) {
      gl.activeTexture(gl.TEXTURE0);
      const textureProps = this.renderer?.properties.get(this.forceFieldTexture);
      const tex = textureProps?.__webglTexture;
      if (tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(ffTexLoc, 0);
      }
    }
    const readVAO = this.currentBuffer === "A" ? this.vaoA : this.vaoB;
    const writeTF = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB;
    const writeVBO = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    gl.bindVertexArray(readVAO);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, writeTF);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, this.config.maxParticles);
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    this.currentBuffer = this.currentBuffer === "A" ? "B" : "A";
    if (this.state.frameCount % 10 === 0) {
      this.readBackParticleData(writeVBO);
    }
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let fieldIndex = 0;
    for (const field of this.forceFields.values()) {
      if (fieldIndex >= MAX_FORCE_FIELDS) break;
      if (!field.enabled) continue;
      const baseOffset = fieldIndex * 16;
      this.forceFieldBuffer[baseOffset + 0] = field.position.x;
      this.forceFieldBuffer[baseOffset + 1] = field.position.y;
      this.forceFieldBuffer[baseOffset + 2] = field.position.z;
      this.forceFieldBuffer[baseOffset + 3] = this.getForceFieldTypeIndex(field.type);
      this.forceFieldBuffer[baseOffset + 4] = field.strength;
      this.forceFieldBuffer[baseOffset + 5] = field.falloffStart;
      this.forceFieldBuffer[baseOffset + 6] = field.falloffEnd;
      this.forceFieldBuffer[baseOffset + 7] = this.getFalloffTypeIndex(field.falloffType);
      this.forceFieldBuffer[baseOffset + 8] = field.direction?.x ?? field.vortexAxis?.x ?? field.windDirection?.x ?? 0;
      this.forceFieldBuffer[baseOffset + 9] = field.direction?.y ?? field.vortexAxis?.y ?? field.windDirection?.y ?? 0;
      this.forceFieldBuffer[baseOffset + 10] = field.direction?.z ?? field.vortexAxis?.z ?? field.windDirection?.z ?? 0;
      this.forceFieldBuffer[baseOffset + 11] = field.inwardForce ?? 0;
      this.forceFieldBuffer[baseOffset + 12] = field.noiseScale ?? field.linearDrag ?? field.gustStrength ?? 0;
      this.forceFieldBuffer[baseOffset + 13] = field.noiseSpeed ?? field.quadraticDrag ?? field.gustFrequency ?? 0;
      this.forceFieldBuffer[baseOffset + 14] = 0;
      this.forceFieldBuffer[baseOffset + 15] = 0;
      fieldIndex++;
    }
    this.forceFieldTexture.needsUpdate = true;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(type) {
    switch (type) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(type) {
    switch (type) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(vbo) {
    if (!this.gl || !vbo) return;
    const gl = this.gl;
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, targetBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    let activeCount = 0;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = targetBuffer[offset + 6];
      const lifetime = targetBuffer[offset + 7];
      if (lifetime > 0 && age < lifetime) {
        activeCount++;
      } else if (lifetime > 0 && age >= lifetime) {
        if (!this.freeIndices.includes(i)) {
          this.freeIndices.push(i);
          this.emit("particleDeath", { index: i });
        }
      }
    }
    this.state.particleCount = activeCount;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(field, px, py, pz, vx, vy, vz, mass) {
    const force = new Vector3();
    const dx = px - field.position.x;
    const dy = py - field.position.y;
    const dz = pz - field.position.z;
    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let falloff = 1;
    if (dist > field.falloffStart) {
      const t = Math.min((dist - field.falloffStart) / (field.falloffEnd - field.falloffStart), 1);
      switch (field.falloffType) {
        case "linear":
          falloff = 1 - t;
          break;
        case "quadratic":
          falloff = 1 - t * t;
          break;
        case "exponential":
          falloff = Math.exp(-t * 3);
          break;
        case "smoothstep":
          falloff = 1 - (3 * t * t - 2 * t * t * t);
          break;
      }
    }
    const strength = field.strength * falloff;
    switch (field.type) {
      case "gravity":
        force.set(
          (field.direction?.x ?? 0) * strength,
          (field.direction?.y ?? 1) * strength,
          (field.direction?.z ?? 0) * strength
        );
        break;
      case "point":
        if (dist > 1e-3) {
          const dir = new Vector3(-dx, -dy, -dz).normalize();
          force.copy(dir).multiplyScalar(strength / mass);
        }
        break;
      case "vortex":
        if (dist > 1e-3) {
          const axis = new Vector3(
            field.vortexAxis?.x ?? 0,
            field.vortexAxis?.y ?? 0,
            field.vortexAxis?.z ?? 1
          ).normalize();
          const toParticle = new Vector3(dx, dy, dz);
          const tangent = new Vector3().crossVectors(axis, toParticle).normalize();
          const inward = toParticle.normalize().multiplyScalar(-(field.inwardForce ?? 0));
          force.copy(tangent).multiplyScalar(strength).add(inward);
        }
        break;
      case "turbulence": {
        const scale = field.noiseScale ?? 0.01;
        const speed = field.noiseSpeed ?? 0.5;
        const time = this.state.simulationTime * speed;
        const nx = Math.sin(px * scale + time) * Math.cos(py * scale * 1.3) * strength;
        const ny = Math.sin(py * scale + time * 1.1) * Math.cos(pz * scale * 1.2) * strength;
        const nz = Math.sin(pz * scale + time * 0.9) * Math.cos(px * scale * 1.1) * strength;
        force.set(nx, ny, nz);
        break;
      }
      case "drag": {
        const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
        if (speed > 1e-3) {
          const dragMag = (field.linearDrag ?? 0.1) * speed + (field.quadraticDrag ?? 0.01) * speed * speed;
          force.set(-vx, -vy, -vz).normalize().multiplyScalar(-dragMag * strength);
        }
        break;
      }
      case "wind": {
        const windDir = new Vector3(
          field.windDirection?.x ?? 1,
          field.windDirection?.y ?? 0,
          field.windDirection?.z ?? 0
        ).normalize();
        const gust = Math.sin(this.state.simulationTime * (field.gustFrequency ?? 0.5)) * (field.gustStrength ?? 0);
        force.copy(windDir).multiplyScalar(strength + gust);
        break;
      }
      case "lorenz": {
        const sigma = field.lorenzSigma ?? 10;
        const rho = field.lorenzRho ?? 28;
        const beta = field.lorenzBeta ?? 2.667;
        force.set(
          sigma * (dy - dx),
          dx * (rho - dz) - dy,
          dx * dy - beta * dz
        ).multiplyScalar(strength * 0.01);
        break;
      }
    }
    return force;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const key = `${cellX},${cellY},${cellZ}`;
      if (!this.spatialHash.has(key)) {
        this.spatialHash.set(key, []);
      }
      this.spatialHash.get(key).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(dt) {
    const config = this.config.flocking;
    if (!config?.enabled) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const separation = new Vector3();
      const alignment = new Vector3();
      const cohesion = new Vector3();
      let separationCount = 0;
      let alignmentCount = 0;
      let cohesionCount = 0;
      for (let cx = cellX - 1; cx <= cellX + 1; cx++) {
        for (let cy = cellY - 1; cy <= cellY + 1; cy++) {
          for (let cz = cellZ - 1; cz <= cellZ + 1; cz++) {
            const neighbors = this.spatialHash.get(`${cx},${cy},${cz}`);
            if (!neighbors) continue;
            for (const j of neighbors) {
              if (j === i) continue;
              const jOffset = j * PARTICLE_STRIDE;
              const jx = buffer[jOffset + 0];
              const jy = buffer[jOffset + 1];
              const jz = buffer[jOffset + 2];
              const dx = px - jx;
              const dy = py - jy;
              const dz = pz - jz;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (dist < config.separationRadius && dist > 0) {
                separation.add(new Vector3(dx, dy, dz).divideScalar(dist));
                separationCount++;
              }
              if (dist < config.alignmentRadius) {
                alignment.add(new Vector3(
                  buffer[jOffset + 3],
                  buffer[jOffset + 4],
                  buffer[jOffset + 5]
                ));
                alignmentCount++;
              }
              if (dist < config.cohesionRadius) {
                cohesion.add(new Vector3(jx, jy, jz));
                cohesionCount++;
              }
            }
          }
        }
      }
      if (separationCount > 0) {
        separation.divideScalar(separationCount).normalize().multiplyScalar(config.separationWeight);
      }
      if (alignmentCount > 0) {
        alignment.divideScalar(alignmentCount).normalize().multiplyScalar(config.alignmentWeight);
      }
      if (cohesionCount > 0) {
        cohesion.divideScalar(cohesionCount);
        cohesion.sub(new Vector3(px, py, pz)).normalize().multiplyScalar(config.cohesionWeight);
      }
      const steering = separation.add(alignment).add(cohesion);
      if (steering.length() > config.maxForce) {
        steering.normalize().multiplyScalar(config.maxForce);
      }
      buffer[offset + 3] += steering.x * dt;
      buffer[offset + 4] += steering.y * dt;
      buffer[offset + 5] += steering.z * dt;
      const speed = Math.sqrt(
        buffer[offset + 3] ** 2 + buffer[offset + 4] ** 2 + buffer[offset + 5] ** 2
      );
      if (speed > config.maxSpeed) {
        const scale = config.maxSpeed / speed;
        buffer[offset + 3] *= scale;
        buffer[offset + 4] *= scale;
        buffer[offset + 5] *= scale;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const binding of this.config.audioBindings) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      const smoothed = featureValue;
      const t = (smoothed - binding.min) / (binding.max - binding.min);
      let output = binding.outputMin + t * (binding.outputMax - binding.outputMin);
      if (binding.curve === "exponential") {
        output = binding.outputMin + Math.pow(t, 2) * (binding.outputMax - binding.outputMin);
      } else if (binding.curve === "logarithmic") {
        output = binding.outputMin + Math.sqrt(t) * (binding.outputMax - binding.outputMin);
      }
      if (binding.target === "emitter") {
        const emitter = this.emitters.get(binding.targetId);
        if (emitter) {
          emitter[binding.parameter] = output;
        }
      } else if (binding.target === "forceField") {
        const field = this.forceFields.get(binding.targetId);
        if (field) {
          field[binding.parameter] = output;
        }
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(target, targetId, parameter) {
    for (const binding of this.config.audioBindings) {
      if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
        const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
        const t = (featureValue - binding.min) / (binding.max - binding.min);
        return binding.outputMin + t * (binding.outputMax - binding.outputMin);
      }
    }
    return void 0;
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.instancedGeometry.getAttribute("i_position");
    const velAttr = this.instancedGeometry.getAttribute("i_velocity");
    const lifeAttr = this.instancedGeometry.getAttribute("i_life");
    const physAttr = this.instancedGeometry.getAttribute("i_physical");
    const rotAttr = this.instancedGeometry.getAttribute("i_rotation");
    const colAttr = this.instancedGeometry.getAttribute("i_color");
    for (let i = 0; i < this.config.maxParticles; i++) {
      const src = i * PARTICLE_STRIDE;
      posAttr.setXYZ(i, buffer[src + 0], buffer[src + 1], buffer[src + 2]);
      velAttr.setXYZ(i, buffer[src + 3], buffer[src + 4], buffer[src + 5]);
      lifeAttr.setXY(i, buffer[src + 6], buffer[src + 7]);
      physAttr.setXY(i, buffer[src + 8], buffer[src + 9]);
      rotAttr.setXY(i, buffer[src + 10], buffer[src + 11]);
      colAttr.setXYZW(i, buffer[src + 12], buffer[src + 13], buffer[src + 14], buffer[src + 15]);
    }
    posAttr.needsUpdate = true;
    velAttr.needsUpdate = true;
    lifeAttr.needsUpdate = true;
    physAttr.needsUpdate = true;
    rotAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(feature, value) {
    this.audioFeatures.set(feature, value);
    this.state.currentAudioFeatures.set(feature, value);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1);
    requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(emitterId) {
    if (emitterId) {
      const emitter = this.emitters.get(emitterId);
      if (emitter) {
        for (let i = 0; i < emitter.burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
    } else {
      for (const emitter of this.emitters.values()) {
        if (emitter.burstOnBeat && emitter.enabled) {
          for (let i = 0; i < emitter.burstCount; i++) {
            this.spawnParticle(emitter);
          }
        }
      }
    }
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return AdditiveBlending;
      case "multiply":
        return MultiplyBlending;
      case "screen":
        return CustomBlending;
      default:
        return NormalBlending;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(event, handler) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(event).add(handler);
  }
  off(event, handler) {
    this.eventHandlers.get(event)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => handler(event));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(seed) {
    let s = seed;
    return () => {
      s = s * 1103515245 + 12345 & 2147483647;
      return s / 2147483647;
    };
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    const emitters = Array.from(this.emitters.values()).map((e) => {
      const { accumulator, velocity, ...config } = e;
      return config;
    });
    return {
      emitters,
      forceFields: Array.from(this.forceFields.values())
    };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets RNG to initial seed for reproducible simulation
   */
  reset() {
    this.particleBufferA.fill(0);
    this.particleBufferB.fill(0);
    this.freeIndices = [];
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.state.particleCount = 0;
    this.state.simulationTime = 0;
    this.state.frameCount = 0;
    this.spatialHash.clear();
    this.rng = this.createSeededRandom(this.config.randomSeed ?? 12345);
  }
  /**
   * Get the current seed
   */
  getSeed() {
    return this.config.randomSeed ?? 12345;
  }
  /**
   * Set a new seed and reset the system
   * DETERMINISM: Used to ensure layer-specific reproducible seeds
   */
  setSeed(seed) {
    this.config.randomSeed = seed;
    this.reset();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.instancedGeometry?.dispose();
    this.material?.dispose();
    this.sizeOverLifetimeTexture?.dispose();
    this.opacityOverLifetimeTexture?.dispose();
    this.colorOverLifetimeTexture?.dispose();
    this.cleanupGPUPhysics();
    this.emitters.clear();
    this.forceFields.clear();
    this.subEmitters.clear();
    this.eventHandlers.clear();
  }
}

class ParticleLayer extends BaseLayer {
  /** The GPU particle system instance */
  particleSystem;
  /** Particle system configuration */
  systemConfig;
  /** Whether the system has been initialized with a renderer */
  initialized = false;
  /** Stored renderer reference for reinitialization */
  rendererRef = null;
  /** Composition FPS for time calculation */
  fps = 60;
  /** Deterministic seed derived from layer ID */
  layerSeed;
  /** Last evaluated frame (for scrub detection) */
  lastEvaluatedFrame = -1;
  /** Performance stats */
  stats = {
    particleCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0
  };
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /** Emitter visualization icons */
  emitterGizmos = /* @__PURE__ */ new Map();
  /** Force field visualization icons */
  forceFieldGizmos = /* @__PURE__ */ new Map();
  /** Whether emitter gizmos are visible */
  showEmitterGizmos = true;
  /** Whether force field gizmos are visible */
  showForceFieldGizmos = true;
  constructor(layerData) {
    super(layerData);
    this.layerSeed = this.generateSeedFromId(layerData.id);
    this.systemConfig = this.buildSystemConfig(layerData);
    this.systemConfig.randomSeed = this.layerSeed;
    this.particleSystem = new GPUParticleSystem(this.systemConfig);
    this.initializeBlendMode();
  }
  /**
   * Generate deterministic seed from layer ID
   * DETERMINISM: Same layer ID always produces identical seed
   */
  generateSeedFromId(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash) || 12345;
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(layerData) {
    const data = layerData.data;
    const config = createDefaultConfig();
    if (!data) {
      config.emitters = [createDefaultEmitter("default")];
      return config;
    }
    if (data.systemConfig) {
      config.maxParticles = data.systemConfig.maxParticles ?? 1e5;
      config.timeScale = 1;
      if (data.systemConfig.gravity !== 0) {
        config.forceFields.push({
          id: "global_gravity",
          name: "Gravity",
          type: "gravity",
          enabled: true,
          strength: data.systemConfig.gravity * 10,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          direction: { x: 0, y: 1, z: 0 }
        });
      }
      if (data.systemConfig.windStrength !== 0) {
        const windAngle = (data.systemConfig.windDirection ?? 0) * Math.PI / 180;
        config.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: true,
          strength: data.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(windAngle),
            y: Math.sin(windAngle),
            z: 0
          },
          gustStrength: data.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (data.systemConfig.friction > 0) {
        config.forceFields.push({
          id: "global_drag",
          name: "Friction",
          type: "drag",
          enabled: true,
          strength: 1,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          linearDrag: data.systemConfig.friction,
          quadraticDrag: data.systemConfig.friction * 0.1
        });
      }
      if (data.systemConfig.turbulenceFields) {
        for (const turbField of data.systemConfig.turbulenceFields) {
          if (turbField.enabled) {
            config.forceFields.push({
              id: turbField.id,
              name: "Turbulence",
              type: "turbulence",
              enabled: true,
              strength: turbField.strength,
              position: { x: 0, y: 0, z: 0 },
              falloffStart: 0,
              falloffEnd: 1e4,
              falloffType: "none",
              noiseScale: turbField.scale,
              noiseSpeed: turbField.evolutionSpeed,
              noiseOctaves: 3,
              noiseLacunarity: 2,
              noiseGain: 0.5
            });
          }
        }
      }
    }
    if (data.emitters) {
      for (const emitter of data.emitters) {
        if (!emitter.enabled) continue;
        const dirRad = (emitter.direction ?? 0) * Math.PI / 180;
        const gpuEmitter = {
          id: emitter.id,
          name: emitter.name,
          enabled: true,
          position: { x: emitter.x, y: emitter.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: emitter.emissionRate,
          emissionRateVariance: 0,
          burstCount: emitter.burstCount,
          burstInterval: 0,
          initialSpeed: emitter.speed,
          speedVariance: emitter.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: emitter.size,
          sizeVariance: emitter.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: emitter.particleLifetime,
          lifetimeVariance: emitter.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            1
          ],
          colorEnd: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(dirRad),
            y: Math.sin(dirRad),
            z: 0
          },
          emissionSpread: emitter.spread,
          burstOnBeat: emitter.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        config.emitters.push(gpuEmitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        if (!well.enabled) continue;
        config.forceFields.push({
          id: well.id,
          name: well.name,
          type: "point",
          enabled: true,
          strength: well.strength,
          position: { x: well.x, y: well.y, z: 0 },
          falloffStart: 0,
          falloffEnd: well.radius,
          falloffType: well.falloff === "linear" ? "linear" : well.falloff === "quadratic" ? "quadratic" : "none"
        });
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        if (!vortex.enabled) continue;
        config.forceFields.push({
          id: vortex.id,
          name: vortex.name,
          type: "vortex",
          enabled: true,
          strength: vortex.strength * vortex.rotationSpeed,
          position: { x: vortex.x, y: vortex.y, z: 0 },
          falloffStart: 0,
          falloffEnd: vortex.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: vortex.inwardPull
        });
      }
    }
    if (data.modulations) {
      const sizeModulations = data.modulations.filter((m) => m.property === "size");
      if (sizeModulations.length > 0) {
        const mod = sizeModulations[0];
        config.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
      const opacityModulations = data.modulations.filter((m) => m.property === "opacity");
      if (opacityModulations.length > 0) {
        const mod = opacityModulations[0];
        config.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
    }
    if (data.renderOptions) {
      config.render.blendMode = data.renderOptions.blendMode ?? "normal";
      config.render.motionBlur = data.renderOptions.motionBlur ?? false;
      config.render.motionBlurStrength = data.renderOptions.motionBlurStrength ?? 0.5;
      config.render.motionBlurSamples = data.renderOptions.motionBlurSamples ?? 4;
      if (data.renderOptions.renderTrails) {
        config.render.mode = "trail";
        config.render.trailLength = data.renderOptions.trailLength;
        config.render.trailWidthEnd = 1 - (data.renderOptions.trailOpacityFalloff ?? 0.8);
      }
      config.render.texture.proceduralType = data.renderOptions.particleShape === "star" ? "star" : data.renderOptions.particleShape === "square" ? "square" : "circle";
    }
    return config;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(renderer) {
    if (this.initialized) return;
    this.rendererRef = renderer;
    this.particleSystem.initialize(renderer);
    this.initialized = true;
    const mesh = this.particleSystem.getMesh();
    if (mesh) {
      this.group.add(mesh);
    }
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    if (!this.initialized) {
      this.initializeWithRenderer(renderer);
    }
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(config) {
    const emitter = createDefaultEmitter();
    if (config) {
      Object.assign(emitter, config);
    }
    this.particleSystem.addEmitter(emitter);
    return emitter.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(id, updates) {
    this.particleSystem.updateEmitter(id, updates);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(id) {
    this.particleSystem.removeEmitter(id);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(type, config) {
    const field = createDefaultForceField(type);
    if (config) {
      Object.assign(field, config);
    }
    this.particleSystem.addForceField(field);
    return field.id;
  }
  /**
   * Update a force field
   */
  updateForceField(id, updates) {
    this.particleSystem.updateForceField(id, updates);
  }
  /**
   * Remove a force field
   */
  removeForceField(id) {
    this.particleSystem.removeForceField(id);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(feature, value) {
    this.particleSystem.setAudioFeature(feature, value);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(emitterId) {
    this.particleSystem.triggerBurst(emitterId);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(deltaTime) {
    if (!this.initialized) return;
    this.particleSystem.step(deltaTime);
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets to initial state with original seed
   */
  reset() {
    this.particleSystem.reset();
    this.lastEvaluatedFrame = -1;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const isSequential = frame === this.lastEvaluatedFrame + 1;
    const needsReplay = !isSequential && frame !== this.lastEvaluatedFrame;
    if (needsReplay) {
      this.particleSystem.reset();
      const deltaTime = 1 / this.fps;
      for (let f = 0; f < frame; f++) {
        this.particleSystem.step(deltaTime);
      }
    } else if (isSequential) {
      const deltaTime = 1 / this.fps;
      this.particleSystem.step(deltaTime);
    }
    this.lastEvaluatedFrame = frame;
    this.applyAudioReactivity();
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  onApplyEvaluatedState(state) {
    this.applyAudioReactivity();
  }
  /**
   * Evaluate particles at a specific frame (scrub-safe)
   * DETERMINISM: Returns identical results regardless of evaluation order
   */
  evaluateAtFrame(frame) {
    this.particleSystem.reset();
    const deltaTime = 1 / this.fps;
    for (let f = 0; f < frame; f++) {
      this.particleSystem.step(deltaTime);
    }
    this.lastEvaluatedFrame = frame;
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const emissionRate = this.getAudioReactiveValue("particle.emissionRate");
    const speed = this.getAudioReactiveValue("particle.speed");
    const size = this.getAudioReactiveValue("particle.size");
    const gravity = this.getAudioReactiveValue("particle.gravity");
    const windStrength = this.getAudioReactiveValue("particle.windStrength");
    if (emissionRate !== 0) {
      this.particleSystem.setAudioFeature("amplitude", emissionRate);
    }
    if (speed !== 0 || size !== 0 || emissionRate !== 0) {
      const emitters = this.particleSystem.getConfig().emitters;
      for (const emitter of emitters) {
        if (speed !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSpeed: emitter.initialSpeed * (0.5 + speed)
          });
        }
        if (size !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSize: emitter.initialSize * (0.5 + size)
          });
        }
      }
    }
    if (gravity !== 0 || windStrength !== 0) {
      const forceFields = this.particleSystem.getConfig().forceFields;
      for (const field of forceFields) {
        if (field.type === "gravity" && gravity !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + gravity)
          });
        }
        if (field.type === "wind" && windStrength !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + windStrength)
          });
        }
      }
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      const oldMesh = this.particleSystem.getMesh();
      if (oldMesh) {
        this.group.remove(oldMesh);
      }
      this.systemConfig = this.buildSystemConfig({
        ...properties,
        id: this.id,
        type: "particles"
      });
      this.systemConfig.randomSeed = this.layerSeed;
      this.particleSystem.dispose();
      this.particleSystem = new GPUParticleSystem(this.systemConfig);
      this.lastEvaluatedFrame = -1;
      if (this.rendererRef) {
        this.initialized = false;
        this.initializeWithRenderer(this.rendererRef);
      }
    }
  }
  onDispose() {
    this.particleSystem.dispose();
    this.disposeGizmos();
  }
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /**
   * Create visual gizmos for all emitters and force fields
   */
  createGizmos() {
    this.disposeGizmos();
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      this.createEmitterGizmo(emitter);
    }
    for (const field of config.forceFields) {
      this.createForceFieldGizmo(field);
    }
  }
  /**
   * Create a visual gizmo for an emitter
   */
  createEmitterGizmo(emitter) {
    const gizmo = new Group();
    gizmo.name = `emitter_gizmo_${emitter.id}`;
    const size = 30;
    switch (emitter.shape.type) {
      case "point": {
        const coneGeom = new ConeGeometry(8, 20, 8);
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.7,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        cone.rotation.x = Math.PI;
        gizmo.add(cone);
        const sphereGeom = new SphereGeometry(5, 8, 8);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.9,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "circle": {
        const ringGeom = new RingGeometry(
          (emitter.shape.radius ?? 50) * 0.8,
          emitter.shape.radius ?? 50,
          32
        );
        const ringMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.5,
          side: DoubleSide,
          depthTest: false
        });
        const ring = new Mesh(ringGeom, ringMat);
        gizmo.add(ring);
        break;
      }
      case "sphere": {
        const sphereGeom = new SphereGeometry(emitter.shape.radius ?? 50, 16, 16);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "box": {
        const boxGeom = new BoxGeometry(
          emitter.shape.boxSize?.x ?? 100,
          emitter.shape.boxSize?.y ?? 100,
          emitter.shape.boxSize?.z ?? 100
        );
        const boxMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const box = new Mesh(boxGeom, boxMat);
        gizmo.add(box);
        break;
      }
      case "cone": {
        const coneGeom = new ConeGeometry(
          emitter.shape.coneRadius ?? 30,
          emitter.shape.coneLength ?? 100,
          16,
          1,
          true
        );
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        gizmo.add(cone);
        break;
      }
      default: {
        const lineMat = new LineBasicMaterial({
          color: 65416,
          depthTest: false
        });
        const hPoints = [new Vector3(-size, 0, 0), new Vector3(size, 0, 0)];
        const vPoints = [new Vector3(0, -size, 0), new Vector3(0, size, 0)];
        const hLine = new Line(
          new BufferGeometry().setFromPoints(hPoints),
          lineMat
        );
        const vLine = new Line(
          new BufferGeometry().setFromPoints(vPoints),
          lineMat.clone()
        );
        gizmo.add(hLine, vLine);
      }
    }
    const dir = emitter.emissionDirection;
    if (dir) {
      const arrowLength = 40;
      const arrowGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
      ]);
      const arrowMat = new LineBasicMaterial({
        color: 16776960,
        depthTest: false
      });
      const arrow = new Line(arrowGeom, arrowMat);
      gizmo.add(arrow);
    }
    const pos = emitter.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showEmitterGizmos;
    gizmo.renderOrder = 997;
    this.emitterGizmos.set(emitter.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Create a visual gizmo for a force field
   */
  createForceFieldGizmo(field) {
    const gizmo = new Group();
    gizmo.name = `forcefield_gizmo_${field.id}`;
    const radius = field.falloffEnd || 100;
    switch (field.type) {
      case "gravity":
      case "wind": {
        const dir = field.type === "wind" && field.windDirection ? field.windDirection : field.direction ?? { x: 0, y: 1, z: 0 };
        const arrowLength = 60;
        const arrowPoints = [
          new Vector3(0, 0, 0),
          new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
        ];
        const arrowGeom = new BufferGeometry().setFromPoints(arrowPoints);
        const arrowMat = new LineBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          linewidth: 2,
          depthTest: false
        });
        const arrow = new Line(arrowGeom, arrowMat);
        gizmo.add(arrow);
        const headGeom = new ConeGeometry(5, 15, 6);
        const headMat = new MeshBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          depthTest: false
        });
        const head = new Mesh(headGeom, headMat);
        head.position.set(
          dir.x * arrowLength,
          -dir.y * arrowLength,
          dir.z * arrowLength
        );
        head.lookAt(0, 0, 0);
        gizmo.add(head);
        break;
      }
      case "vortex": {
        const spiralPoints = [];
        for (let t = 0; t < Math.PI * 4; t += 0.2) {
          const r = t / (Math.PI * 4) * radius * 0.5;
          spiralPoints.push(new Vector3(
            Math.cos(t) * r,
            Math.sin(t) * r,
            t * 2
          ));
        }
        const spiralGeom = new BufferGeometry().setFromPoints(spiralPoints);
        const spiralMat = new LineBasicMaterial({
          color: 16711935,
          depthTest: false
        });
        const spiral = new Line(spiralGeom, spiralMat);
        gizmo.add(spiral);
        break;
      }
      case "turbulence": {
        const waveMat = new LineBasicMaterial({
          color: 16755200,
          depthTest: false
        });
        for (let i = 0; i < 3; i++) {
          const wavePoints = [];
          for (let t = 0; t < Math.PI * 2; t += 0.3) {
            wavePoints.push(new Vector3(
              t * 10,
              Math.sin(t * 3 + i) * 10,
              (i - 1) * 15
            ));
          }
          const waveGeom = new BufferGeometry().setFromPoints(wavePoints);
          const wave = new Line(waveGeom, waveMat.clone());
          wave.position.x = -30;
          gizmo.add(wave);
        }
        break;
      }
      case "point": {
        const sphereGeom = new SphereGeometry(15, 12, 12);
        const sphereMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.5,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        const rangeGeom = new RingGeometry(radius * 0.9, radius, 32);
        const rangeMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.2,
          side: DoubleSide,
          depthTest: false
        });
        const range = new Mesh(rangeGeom, rangeMat);
        gizmo.add(range);
        break;
      }
      case "drag": {
        const lineMat = new LineBasicMaterial({
          color: 8947848,
          depthTest: false
        });
        for (let i = -2; i <= 2; i++) {
          const linePoints = [
            new Vector3(-20, i * 8, 0),
            new Vector3(20, i * 8, 0)
          ];
          const lineGeom = new BufferGeometry().setFromPoints(linePoints);
          const line = new Line(lineGeom, lineMat.clone());
          gizmo.add(line);
        }
        break;
      }
    }
    const pos = field.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showForceFieldGizmos;
    gizmo.renderOrder = 996;
    this.forceFieldGizmos.set(field.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Update gizmo positions from current config
   */
  updateGizmoPositions() {
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      const gizmo = this.emitterGizmos.get(emitter.id);
      if (gizmo) {
        gizmo.position.set(emitter.position.x, -emitter.position.y, emitter.position.z);
      }
    }
    for (const field of config.forceFields) {
      const gizmo = this.forceFieldGizmos.get(field.id);
      if (gizmo) {
        gizmo.position.set(field.position.x, -field.position.y, field.position.z);
      }
    }
  }
  /**
   * Set emitter gizmo visibility
   */
  setEmitterGizmosVisible(visible) {
    this.showEmitterGizmos = visible;
    for (const gizmo of this.emitterGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Set force field gizmo visibility
   */
  setForceFieldGizmosVisible(visible) {
    this.showForceFieldGizmos = visible;
    for (const gizmo of this.forceFieldGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Dispose all gizmos
   */
  disposeGizmos() {
    for (const gizmo of this.emitterGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.emitterGizmos.clear();
    for (const gizmo of this.forceFieldGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.forceFieldGizmos.clear();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}

class PrecompLayer extends BaseLayer {
  // Precomp data
  precompData;
  // Render context (provided by LayerManager)
  renderContext = null;
  // Display mesh
  mesh = null;
  material = null;
  // Cached render texture
  renderTexture = null;
  // Animation evaluator for time remap
  precompEvaluator;
  // Cached composition reference
  cachedComposition = null;
  // Parent composition FPS for frame rate conversion
  parentFPS = 30;
  constructor(layerData) {
    super(layerData);
    this.precompEvaluator = new KeyframeEvaluator();
    this.precompData = this.extractPrecompData(layerData);
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(layerData) {
    const data = layerData.data;
    return {
      compositionId: data?.compositionId ?? "",
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      collapseTransformations: data?.collapseTransformations ?? false,
      overrideFrameRate: data?.overrideFrameRate ?? false,
      frameRate: data?.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 4473924,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `precomp_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(context) {
    this.renderContext = context;
    this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(fps) {
    this.parentFPS = fps;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    if (!this.renderContext || !this.precompData.compositionId) {
      return;
    }
    this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    );
    if (this.cachedComposition) {
      this.resizeMesh(
        this.cachedComposition.settings.width,
        this.cachedComposition.settings.height
      );
    }
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(parentFrame) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const remappedTime = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, parentFrame) : this.precompData.timeRemap.value;
      const fps = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(remappedTime * fps);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const parentFps = this.parentFPS;
      const childFps = this.precompData.frameRate;
      return Math.floor(parentFrame * (childFps / parentFps));
    }
    return parentFrame;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.renderContext || !this.cachedComposition) {
      return;
    }
    const nestedFrame = this.calculateNestedFrame(frame);
    const clampedFrame = Math.max(
      0,
      Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      clampedFrame
    );
    if (this.material) {
      if (this.renderTexture) {
        this.material.map = this.renderTexture;
        this.material.color.setHex(16777215);
      } else {
        this.material.map = null;
        this.material.color.setHex(4473924);
      }
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      this.precompData.timeRemap.value = props["timeRemap"];
    }
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(compositionId) {
    this.precompData.compositionId = compositionId;
    this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(enabled) {
    this.precompData.timeRemapEnabled = enabled;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(timeRemap) {
    this.precompData.timeRemap = timeRemap;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(collapse) {
    this.precompData.collapseTransformations = collapse;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(override, fps) {
    this.precompData.overrideFrameRate = override;
    this.precompData.frameRate = fps;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.compositionId !== void 0) {
        this.setComposition(data.compositionId);
      }
      if (data.timeRemapEnabled !== void 0) {
        this.setTimeRemapEnabled(data.timeRemapEnabled);
      }
      if (data.timeRemap !== void 0) {
        this.setTimeRemap(data.timeRemap);
      }
      if (data.collapseTransformations !== void 0) {
        this.setCollapseTransformations(data.collapseTransformations);
      }
      if (data.overrideFrameRate !== void 0 || data.frameRate !== void 0) {
        this.setFrameRateOverride(
          data.overrideFrameRate ?? this.precompData.overrideFrameRate,
          data.frameRate ?? this.precompData.frameRate
        );
      }
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
    this.renderTexture = null;
    this.cachedComposition = null;
  }
}

class CameraLayer extends BaseLayer {
  // Camera data reference
  cameraData;
  // Callbacks to store
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Track current frame for interpolation
  currentFrame = 0;
  // Visual wireframe (shown in editor)
  wireframe = null;
  wireframeVisible = true;
  // Frustum visualization
  frustumHelper = null;
  showFrustum = true;
  // Track last camera state for frustum updates
  lastFrustumState = null;
  // Spline provider for path following
  splineProvider = null;
  // Auto-advance parameter (for autoAdvance mode)
  autoAdvanceT = 0;
  constructor(layerData) {
    super(layerData);
    this.threeD = true;
    this.cameraData = this.extractCameraData(layerData);
    this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(layerData) {
    const data = layerData.data;
    return {
      cameraId: data?.cameraId ?? "",
      isActiveCamera: data?.isActiveCamera ?? false,
      pathFollowing: data?.pathFollowing
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
  }
  /**
   * Set the spline provider for path following
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get path following configuration
   */
  getPathFollowing() {
    return this.cameraData.pathFollowing;
  }
  /**
   * Check if path following is active
   */
  isFollowingPath() {
    return this.cameraData.pathFollowing?.enabled ?? false;
  }
  /**
   * Reset auto-advance parameter (for deterministic scrubbing)
   */
  resetAutoAdvance() {
    this.autoAdvanceT = 0;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Group();
    this.wireframe.name = `camera_wireframe_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const bodySize = 40;
    const bodyGeometry = new BoxGeometry(bodySize, bodySize * 0.6, bodySize * 0.8);
    const bodyMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    this.wireframe.add(body);
    const coneGeometry = new ConeGeometry(bodySize * 0.3, bodySize * 0.6, 8);
    const coneMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.6,
      depthTest: false
    });
    const cone = new Mesh(coneGeometry, coneMaterial);
    cone.rotation.x = Math.PI / 2;
    cone.position.z = bodySize * 0.7;
    this.wireframe.add(cone);
    const planeGeometry = new PlaneGeometry(bodySize * 0.8, bodySize * 0.5);
    const planeMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.2,
      side: DoubleSide,
      depthTest: false
    });
    const plane = new Mesh(planeGeometry, planeMaterial);
    plane.position.z = -bodySize * 0.4;
    this.wireframe.add(plane);
    const upPoints = [
      new Vector3(0, bodySize * 0.4, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(-bodySize * 0.1, bodySize * 0.55, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(bodySize * 0.1, bodySize * 0.55, 0)
    ];
    const upGeometry = new BufferGeometry().setFromPoints(upPoints);
    const upMaterial = new LineBasicMaterial({
      color: 65280,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const upLine = new Line(upGeometry, upMaterial);
    this.wireframe.add(upLine);
    this.group.add(this.wireframe);
    this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const camera = this.getCamera();
    if (!camera) return;
    this.frustumHelper = new Group();
    this.frustumHelper.name = `camera_frustum_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const near = camera.nearClip;
    const far = Math.min(camera.farClip, 2e3);
    const fov = camera.angleOfView * (Math.PI / 180);
    const aspect = 16 / 9;
    const nearHeight = 2 * Math.tan(fov / 2) * near;
    const nearWidth = nearHeight * aspect;
    const farHeight = 2 * Math.tan(fov / 2) * far;
    const farWidth = farHeight * aspect;
    const frustumMaterial = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.3,
      depthTest: false
    });
    const nearTL = new Vector3(-nearWidth / 2, nearHeight / 2, near);
    const nearTR = new Vector3(nearWidth / 2, nearHeight / 2, near);
    const nearBL = new Vector3(-nearWidth / 2, -nearHeight / 2, near);
    const nearBR = new Vector3(nearWidth / 2, -nearHeight / 2, near);
    const farTL = new Vector3(-farWidth / 2, farHeight / 2, far);
    const farTR = new Vector3(farWidth / 2, farHeight / 2, far);
    const farBL = new Vector3(-farWidth / 2, -farHeight / 2, far);
    const farBR = new Vector3(farWidth / 2, -farHeight / 2, far);
    const nearPlane = new BufferGeometry().setFromPoints([
      nearTL,
      nearTR,
      nearBR,
      nearBL,
      nearTL
    ]);
    this.frustumHelper.add(new Line(nearPlane, frustumMaterial));
    const farPlane = new BufferGeometry().setFromPoints([
      farTL,
      farTR,
      farBR,
      farBL,
      farTL
    ]);
    this.frustumHelper.add(new Line(farPlane, frustumMaterial));
    const edges = [
      [nearTL, farTL],
      [nearTR, farTR],
      [nearBL, farBL],
      [nearBR, farBR]
    ];
    for (const [start, end] of edges) {
      const edgeGeom = new BufferGeometry().setFromPoints([start, end]);
      this.frustumHelper.add(new Line(edgeGeom, frustumMaterial));
    }
    this.group.add(this.frustumHelper);
    this.frustumHelper.renderOrder = 997;
    this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        const material = child.material;
        if (material.color.getHex() === 65280) return;
        material.color.setHex(color);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    if (!this.cameraGetter || !this.cameraData.cameraId) return null;
    return this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    if (!this.cameraData.cameraId) return null;
    if (this.cameraAtFrameGetter) {
      return this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame);
    }
    return this.getCamera();
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(active) {
    this.cameraData.isActiveCamera = active;
    this.updateWireframeColor();
    if (this.frustumHelper) {
      this.group.remove(this.frustumHelper);
      this.disposeFrustum();
      this.createFrustum();
    }
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(visible) {
    this.wireframeVisible = visible;
    if (this.wireframe) {
      this.wireframe.visible = visible;
    }
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(visible) {
    this.showFrustum = visible;
    if (this.frustumHelper) {
      this.frustumHelper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return;
    const degToRad = Math.PI / 180;
    const pathFollowing = this.cameraData.pathFollowing;
    const usePathFollowing = pathFollowing?.enabled && pathFollowing.pathLayerId && this.splineProvider;
    if (usePathFollowing && pathFollowing) {
      this.applyPathFollowing(frame, pathFollowing, camera);
    } else {
      this.group.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
      );
      if (camera.type === "two-node" && camera.pointOfInterest) {
        const poi = new Vector3(
          camera.pointOfInterest.x,
          camera.pointOfInterest.y,
          camera.pointOfInterest.z
        );
        this.group.lookAt(poi);
        this.group.rotation.z += camera.zRotation * degToRad;
      } else {
        this.group.rotation.set(
          (camera.orientation.x + camera.xRotation) * degToRad,
          (camera.orientation.y + camera.yRotation) * degToRad,
          (camera.orientation.z + camera.zRotation) * degToRad,
          "YXZ"
          // Standard After Effects rotation order
        );
      }
    }
    const currentState = {
      fov: camera.angleOfView,
      near: camera.nearClip,
      far: camera.farClip
    };
    const needsFrustumUpdate = !this.lastFrustumState || this.lastFrustumState.fov !== currentState.fov || this.lastFrustumState.near !== currentState.near || this.lastFrustumState.far !== currentState.far;
    if (needsFrustumUpdate) {
      if (this.frustumHelper) {
        this.group.remove(this.frustumHelper);
        this.disposeFrustum();
      }
      this.createFrustum();
      this.lastFrustumState = currentState;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pathParameter"] !== void 0 && this.cameraData.pathFollowing?.enabled) {
      this.cameraData.pathFollowing.parameter.value = props["pathParameter"];
    }
  }
  /**
   * Apply path following to camera position and orientation
   * DETERMINISM: Uses interpolateProperty for animated parameter
   */
  applyPathFollowing(frame, pathFollowing, camera) {
    if (!this.splineProvider) return;
    let t;
    if (pathFollowing.autoAdvance) {
      t = frame * pathFollowing.autoAdvanceSpeed % 1;
    } else {
      t = interpolateProperty(pathFollowing.parameter, frame);
    }
    t = Math.max(0, Math.min(1, t));
    const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);
    if (!pathResult) {
      this.group.position.set(camera.position.x, camera.position.y, camera.position.z);
      return;
    }
    let lookTarget = null;
    if (pathFollowing.alignToPath && pathFollowing.lookAhead > 0) {
      const lookAheadT = Math.min(1, t + pathFollowing.lookAhead);
      lookTarget = this.splineProvider(pathFollowing.pathLayerId, lookAheadT, frame);
    }
    const position = new Vector3(
      pathResult.point.x,
      pathResult.point.y + pathFollowing.offsetY,
      pathResult.point.z
    );
    this.group.position.copy(position);
    if (pathFollowing.alignToPath) {
      if (lookTarget) {
        const target = new Vector3(
          lookTarget.point.x,
          lookTarget.point.y + pathFollowing.offsetY,
          lookTarget.point.z
        );
        this.group.lookAt(target);
      } else {
        const tangent = new Vector3(
          pathResult.tangent.x,
          pathResult.tangent.y,
          0
        ).normalize();
        const forward = new Vector3(0, 0, 1);
        const quaternion = new Quaternion();
        quaternion.setFromUnitVectors(forward, tangent);
        this.group.quaternion.copy(quaternion);
      }
      if (pathFollowing.bankingStrength > 0) {
        const epsilon = 0.01;
        const tBefore = Math.max(0, t - epsilon);
        const tAfter = Math.min(1, t + epsilon);
        const before = this.splineProvider(pathFollowing.pathLayerId, tBefore, frame);
        const after = this.splineProvider(pathFollowing.pathLayerId, tAfter, frame);
        if (before && after) {
          const tangent1 = new Vector2(before.tangent.x, before.tangent.y).normalize();
          const tangent2 = new Vector2(after.tangent.x, after.tangent.y).normalize();
          const cross = tangent1.x * tangent2.y - tangent1.y * tangent2.x;
          const bankAngle = cross * pathFollowing.bankingStrength * Math.PI / 4;
          this.group.rotateZ(bankAngle);
        }
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.cameraId !== void 0) {
        this.cameraData.cameraId = data.cameraId;
        if (this.frustumHelper) {
          this.group.remove(this.frustumHelper);
          this.disposeFrustum();
        }
        this.createFrustum();
      }
      if (data.isActiveCamera !== void 0) {
        this.setActiveCamera(data.isActiveCamera);
      }
      if (data.pathFollowing !== void 0) {
        this.cameraData.pathFollowing = data.pathFollowing;
        if (data.pathFollowing?.autoAdvance) {
          this.autoAdvanceT = 0;
        }
      }
    }
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return null;
    return {
      position: { ...camera.position },
      rotation: {
        x: camera.orientation.x + camera.xRotation,
        y: camera.orientation.y + camera.yRotation,
        z: camera.orientation.z + camera.zRotation
      },
      fov: camera.angleOfView,
      focalLength: camera.focalLength,
      nearClip: camera.nearClip,
      farClip: camera.farClip
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    if (!this.wireframe) return;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.wireframe.clear();
    this.wireframe = null;
  }
  disposeFrustum() {
    if (!this.frustumHelper) return;
    this.frustumHelper.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.frustumHelper.clear();
    this.frustumHelper = null;
  }
  onDispose() {
    this.disposeWireframe();
    this.disposeFrustum();
  }
}

let rectAreaLightInitialized = false;
function initRectAreaLight() {
  if (!rectAreaLightInitialized) {
    RectAreaLightUniformsLib.init();
    rectAreaLightInitialized = true;
  }
}
function kelvinToRGB(kelvin) {
  const temp = kelvin / 100;
  let r, g, b;
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  return { r: r / 255, g: g / 255, b: b / 255 };
}
class LightLayer extends BaseLayer {
  light;
  helper = null;
  lightData;
  // Point of Interest
  poiTarget = new Vector3();
  smoothedPOI = new Vector3();
  // Path following callback (set by LayerManager)
  pathProvider = null;
  // Layer position getter for POI layer tracking
  layerPositionGetter = null;
  constructor(layerData) {
    super(layerData);
    this.lightData = this.extractLightData(layerData);
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(0);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // DATA EXTRACTION
  // ============================================================================
  extractLightData(layerData) {
    const data = layerData.data;
    return {
      lightType: data?.lightType ?? "point",
      color: data?.color ?? "#ffffff",
      colorTemperature: data?.colorTemperature,
      useColorTemperature: data?.useColorTemperature ?? false,
      intensity: data?.intensity ?? 100,
      physicalIntensity: data?.physicalIntensity,
      usePhysicalIntensity: data?.usePhysicalIntensity ?? false,
      radius: data?.radius ?? 500,
      falloff: data?.falloff ?? "none",
      falloffDistance: data?.falloffDistance ?? 500,
      coneAngle: data?.coneAngle ?? 90,
      coneFeather: data?.coneFeather ?? 50,
      areaWidth: data?.areaWidth ?? 100,
      areaHeight: data?.areaHeight ?? 100,
      pointOfInterest: {
        enabled: data?.pointOfInterest?.enabled ?? false,
        targetType: data?.pointOfInterest?.targetType ?? "position",
        position: data?.pointOfInterest?.position ?? {
          id: "poi_pos",
          name: "POI Position",
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: []
        },
        targetLayerId: data?.pointOfInterest?.targetLayerId,
        offset: data?.pointOfInterest?.offset ?? { x: 0, y: 0, z: 0 },
        smoothing: data?.pointOfInterest?.smoothing ?? 0
      },
      pathFollowing: {
        enabled: data?.pathFollowing?.enabled ?? false,
        splineLayerId: data?.pathFollowing?.splineLayerId,
        progress: data?.pathFollowing?.progress ?? {
          id: "path_progress",
          name: "Path Progress",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        autoOrient: data?.pathFollowing?.autoOrient ?? true,
        bankAngle: data?.pathFollowing?.bankAngle ?? {
          id: "bank_angle",
          name: "Bank Angle",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        }
      },
      shadow: {
        enabled: data?.shadow?.enabled ?? data?.castShadows ?? false,
        type: data?.shadow?.type ?? "pcf",
        mapSize: data?.shadow?.mapSize ?? 1024,
        darkness: data?.shadow?.darkness ?? data?.shadowDarkness ?? 100,
        radius: data?.shadow?.radius ?? data?.shadowDiffusion ?? 1,
        bias: data?.shadow?.bias ?? -1e-4,
        normalBias: data?.shadow?.normalBias ?? 0,
        cameraNear: data?.shadow?.cameraNear ?? 1,
        cameraFar: data?.shadow?.cameraFar ?? 1e3,
        cameraSize: data?.shadow?.cameraSize ?? 500
      },
      lightLinking: {
        mode: data?.lightLinking?.mode ?? "include",
        layers: data?.lightLinking?.layers ?? []
      },
      animatedIntensity: data?.animatedIntensity,
      animatedConeAngle: data?.animatedConeAngle,
      animatedColor: data?.animatedColor,
      animatedColorTemperature: data?.animatedColorTemperature
    };
  }
  // ============================================================================
  // LIGHT CREATION
  // ============================================================================
  createLight() {
    const color = this.getEffectiveColor();
    const intensity = this.getEffectiveIntensity();
    switch (this.lightData.lightType) {
      case "point": {
        const light = new PointLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        this.configureShadows(light);
        return light;
      }
      case "spot": {
        const light = new SpotLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        light.angle = MathUtils.degToRad((this.lightData.coneAngle ?? 90) / 2);
        light.penumbra = (this.lightData.coneFeather ?? 50) / 100;
        this.configureShadows(light);
        return light;
      }
      case "parallel": {
        const light = new DirectionalLight(color, intensity);
        this.configureShadows(light);
        return light;
      }
      case "ambient": {
        return new AmbientLight(color, intensity);
      }
      case "area": {
        initRectAreaLight();
        const light = new RectAreaLight(
          color,
          intensity,
          this.lightData.areaWidth ?? 100,
          this.lightData.areaHeight ?? 100
        );
        return light;
      }
      default:
        layerLogger.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`);
        return new PointLight(color, intensity);
    }
  }
  getEffectiveColor() {
    if (this.lightData.useColorTemperature && this.lightData.colorTemperature) {
      const rgb = kelvinToRGB(this.lightData.colorTemperature);
      return new Color(rgb.r, rgb.g, rgb.b);
    }
    return new Color(this.lightData.color);
  }
  getEffectiveIntensity() {
    if (this.lightData.usePhysicalIntensity && this.lightData.physicalIntensity) {
      return this.lightData.physicalIntensity / 100;
    }
    return this.lightData.intensity / 100;
  }
  // ============================================================================
  // SHADOW CONFIGURATION
  // ============================================================================
  configureShadows(light) {
    const shadowConfig = this.lightData.shadow;
    light.castShadow = shadowConfig.enabled;
    if (!light.castShadow) return;
    light.shadow.mapSize.width = shadowConfig.mapSize;
    light.shadow.mapSize.height = shadowConfig.mapSize;
    switch (shadowConfig.type) {
      case "basic":
        break;
      case "pcf":
        light.shadow.radius = 1;
        break;
      case "pcfSoft":
        light.shadow.radius = shadowConfig.radius;
        break;
      case "vsm":
        light.shadow.radius = shadowConfig.radius;
        break;
    }
    light.shadow.bias = shadowConfig.bias;
    light.shadow.normalBias = shadowConfig.normalBias;
    if (light instanceof DirectionalLight) {
      const camera = light.shadow.camera;
      camera.near = shadowConfig.cameraNear;
      camera.far = shadowConfig.cameraFar;
      camera.left = -shadowConfig.cameraSize / 2;
      camera.right = shadowConfig.cameraSize / 2;
      camera.top = shadowConfig.cameraSize / 2;
      camera.bottom = -shadowConfig.cameraSize / 2;
      camera.updateProjectionMatrix();
    } else if (light instanceof SpotLight) {
      light.shadow.camera.near = shadowConfig.cameraNear;
      light.shadow.camera.far = shadowConfig.cameraFar;
      light.shadow.camera.updateProjectionMatrix();
    }
  }
  // ============================================================================
  // HELPER VISUALIZATION
  // ============================================================================
  createHelper() {
    if (this.helper) {
      this.group.remove(this.helper);
      if (this.helper.dispose) {
        this.helper.dispose();
      }
    }
    switch (this.lightData.lightType) {
      case "point": {
        const helper = new PointLightHelper(this.light, this.lightData.radius / 10);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "spot": {
        const helper = new SpotLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "parallel": {
        const helper = new DirectionalLightHelper(this.light, 50);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "area": {
        const helper = new RectAreaLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
    }
  }
  // ============================================================================
  // POINT OF INTEREST
  // ============================================================================
  /**
   * Set callback for getting layer positions (for POI layer tracking)
   */
  setLayerPositionGetter(getter) {
    this.layerPositionGetter = getter;
  }
  /**
   * Update point of interest target
   */
  updatePointOfInterest(frame) {
    const poi = this.lightData.pointOfInterest;
    if (!poi.enabled) return;
    if (this.lightData.lightType !== "spot" && this.lightData.lightType !== "parallel") {
      return;
    }
    if (poi.targetType === "layer" && poi.targetLayerId && this.layerPositionGetter) {
      const layerPos = this.layerPositionGetter(poi.targetLayerId);
      if (layerPos) {
        this.poiTarget.copy(layerPos);
        this.poiTarget.x += poi.offset.x;
        this.poiTarget.y += poi.offset.y;
        this.poiTarget.z += poi.offset.z;
      }
    } else {
      const pos = this.evaluator.evaluate(poi.position, frame);
      this.poiTarget.set(pos.x, pos.y, pos.z);
    }
    if (poi.smoothing > 0) {
      this.smoothedPOI.lerp(this.poiTarget, 1 - poi.smoothing);
    } else {
      this.smoothedPOI.copy(this.poiTarget);
    }
    if (this.light instanceof SpotLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    } else if (this.light instanceof DirectionalLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    }
  }
  // ============================================================================
  // PATH FOLLOWING
  // ============================================================================
  /**
   * Set path provider callback (from LayerManager's spline provider)
   */
  setPathProvider(provider) {
    this.pathProvider = provider;
  }
  /**
   * Update position and orientation from path
   */
  updatePathFollowing(frame) {
    const path = this.lightData.pathFollowing;
    if (!path.enabled || !path.splineLayerId || !this.pathProvider) return;
    const progress = this.evaluator.evaluate(path.progress, frame);
    const result = this.pathProvider(path.splineLayerId, progress, frame);
    if (!result) return;
    this.group.position.set(result.point.x, -result.point.y, result.point.z);
    if (path.autoOrient) {
      const angle = Math.atan2(result.tangent.y, result.tangent.x);
      this.group.rotation.z = -angle;
      const bankAngle = this.evaluator.evaluate(path.bankAngle, frame);
      this.group.rotation.x = MathUtils.degToRad(bankAngle);
    }
  }
  // ============================================================================
  // PUBLIC SETTERS
  // ============================================================================
  setLightType(type) {
    if (type === this.lightData.lightType) return;
    this.lightData.lightType = type;
    this.group.remove(this.light);
    if (this.light.dispose) {
      this.light.dispose();
    }
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
  }
  setColor(color) {
    this.lightData.color = color;
    this.lightData.useColorTemperature = false;
    this.light.color.set(color);
  }
  setColorTemperature(kelvin) {
    this.lightData.colorTemperature = kelvin;
    this.lightData.useColorTemperature = true;
    const rgb = kelvinToRGB(kelvin);
    this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
  }
  setIntensity(intensity) {
    this.lightData.intensity = intensity;
    this.lightData.usePhysicalIntensity = false;
    this.light.intensity = intensity / 100;
  }
  setFalloffDistance(distance) {
    this.lightData.falloffDistance = distance;
    if (this.light instanceof PointLight || this.light instanceof SpotLight) {
      this.light.distance = this.lightData.falloff === "none" ? 0 : distance;
    }
  }
  setConeAngle(angle) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneAngle = angle;
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
  }
  setConeFeather(feather) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneFeather = feather;
      this.light.penumbra = feather / 100;
    }
  }
  setAreaSize(width, height) {
    if (this.light instanceof RectAreaLight) {
      this.lightData.areaWidth = width;
      this.lightData.areaHeight = height;
      this.light.width = width;
      this.light.height = height;
    }
  }
  setShadowEnabled(enabled) {
    this.lightData.shadow.enabled = enabled;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.light.castShadow = enabled;
    }
  }
  setShadowType(type) {
    this.lightData.shadow.type = type;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.configureShadows(this.light);
    }
  }
  setPointOfInterestEnabled(enabled) {
    this.lightData.pointOfInterest.enabled = enabled;
  }
  setPointOfInterestTarget(layerId) {
    if (layerId) {
      this.lightData.pointOfInterest.targetType = "layer";
      this.lightData.pointOfInterest.targetLayerId = layerId;
    } else {
      this.lightData.pointOfInterest.targetType = "position";
      this.lightData.pointOfInterest.targetLayerId = void 0;
    }
  }
  setPathFollowingEnabled(enabled) {
    this.lightData.pathFollowing.enabled = enabled;
  }
  setPathSpline(splineLayerId) {
    this.lightData.pathFollowing.splineLayerId = splineLayerId ?? void 0;
  }
  // ============================================================================
  // DRIVER PROPERTY ACCESS
  // ============================================================================
  /**
   * Get a light property value by driver property path
   * Used by PropertyDriverSystem for property-to-property linking
   */
  getDriverPropertyValue(path) {
    switch (path) {
      case "light.intensity":
        return this.lightData.intensity;
      case "light.color.r":
        return this.light.color.r * 255;
      case "light.color.g":
        return this.light.color.g * 255;
      case "light.color.b":
        return this.light.color.b * 255;
      case "light.colorTemperature":
        return this.lightData.colorTemperature ?? 6500;
      case "light.coneAngle":
        return this.lightData.coneAngle ?? 90;
      case "light.penumbra":
        return this.lightData.coneFeather ?? 50;
      case "light.falloff":
        return this.lightData.falloffDistance;
      case "light.shadow.intensity":
        return this.lightData.shadow.darkness;
      case "light.shadow.softness":
        return this.lightData.shadow.radius;
      case "light.shadow.bias":
        return this.lightData.shadow.bias * 1e4;
      case "light.poi.x":
        return this.poiTarget.x;
      case "light.poi.y":
        return this.poiTarget.y;
      case "light.poi.z":
        return this.poiTarget.z;
      case "light.areaSize.width":
        return this.lightData.areaWidth ?? 100;
      case "light.areaSize.height":
        return this.lightData.areaHeight ?? 100;
      case "light.physicalIntensity":
        return this.lightData.physicalIntensity ?? this.lightData.intensity * 100;
      default:
        return null;
    }
  }
  /**
   * Set a light property value by driver property path
   * Used by PropertyDriverSystem for driven values
   */
  setDriverPropertyValue(path, value) {
    switch (path) {
      case "light.intensity":
        this.light.intensity = value / 100;
        this.lightData.intensity = value;
        break;
      case "light.color.r":
        this.light.color.r = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.g":
        this.light.color.g = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.b":
        this.light.color.b = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.colorTemperature":
        this.setColorTemperature(value);
        break;
      case "light.coneAngle":
        this.setConeAngle(value);
        break;
      case "light.penumbra":
        this.setConeFeather(value);
        break;
      case "light.falloff":
        this.setFalloffDistance(value);
        break;
      case "light.shadow.intensity":
        this.lightData.shadow.darkness = value;
        break;
      case "light.shadow.softness":
        this.lightData.shadow.radius = value;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.radius = value;
        }
        break;
      case "light.shadow.bias":
        this.lightData.shadow.bias = value / 1e4;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.bias = value / 1e4;
        }
        break;
      case "light.poi.x":
        this.poiTarget.x = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.y":
        this.poiTarget.y = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.z":
        this.poiTarget.z = value;
        this.updatePointOfInterest(0);
        break;
      case "light.areaSize.width":
        this.setAreaSize(value, this.lightData.areaHeight ?? 100);
        break;
      case "light.areaSize.height":
        this.setAreaSize(this.lightData.areaWidth ?? 100, value);
        break;
      case "light.physicalIntensity":
        this.lightData.physicalIntensity = value;
        if (this.lightData.usePhysicalIntensity) {
          this.light.intensity = value / 100;
        }
        break;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getLight() {
    return this.light;
  }
  getLightData() {
    return { ...this.lightData };
  }
  getLightLinking() {
    return { ...this.lightData.lightLinking };
  }
  /**
   * Check if this light should affect a given layer
   */
  shouldAffectLayer(layerId) {
    const linking = this.lightData.lightLinking;
    if (linking.layers.length === 0) {
      return true;
    }
    const isInList = linking.layers.includes(layerId);
    if (linking.mode === "include") {
      return isInList;
    } else {
      return !isInList;
    }
  }
  setHelperVisible(visible) {
    if (this.helper) {
      this.helper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.lightData.pathFollowing.enabled) {
      this.updatePathFollowing(frame);
    }
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(frame);
    }
    if (this.lightData.animatedIntensity?.animated) {
      const intensity = this.evaluator.evaluate(this.lightData.animatedIntensity, frame);
      this.light.intensity = intensity / 100;
    }
    if (this.lightData.animatedConeAngle?.animated && this.light instanceof SpotLight) {
      const angle = this.evaluator.evaluate(this.lightData.animatedConeAngle, frame);
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (this.lightData.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.lightData.animatedColor, frame);
      this.light.color.set(color);
    }
    if (this.lightData.animatedColorTemperature?.animated && this.lightData.useColorTemperature) {
      const kelvin = this.evaluator.evaluate(this.lightData.animatedColorTemperature, frame);
      const rgb = kelvinToRGB(kelvin);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (this.helper) {
      if (this.helper instanceof PointLightHelper || this.helper instanceof SpotLightHelper || this.helper instanceof DirectionalLightHelper) {
        this.helper.update();
      }
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["intensity"] !== void 0) {
      this.light.intensity = props["intensity"] / 100;
    }
    if (props["coneAngle"] !== void 0 && this.light instanceof SpotLight) {
      this.light.angle = MathUtils.degToRad(props["coneAngle"] / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (props["color"] !== void 0) {
      this.light.color.set(props["color"]);
    }
    if (props["colorTemperature"] !== void 0 && this.lightData.useColorTemperature) {
      const rgb = kelvinToRGB(props["colorTemperature"]);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (props["falloffDistance"] !== void 0) {
      if (this.light instanceof PointLight || this.light instanceof SpotLight) {
        this.light.distance = this.lightData.falloff === "none" ? 0 : props["falloffDistance"];
      }
    }
    if (props["poi.x"] !== void 0 || props["poi.y"] !== void 0 || props["poi.z"] !== void 0) {
      this.poiTarget.set(
        props["poi.x"] ?? this.poiTarget.x,
        props["poi.y"] ?? this.poiTarget.y,
        props["poi.z"] ?? this.poiTarget.z
      );
      this.updatePointOfInterest(0);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.lightType !== void 0 && data.lightType !== this.lightData.lightType) {
      this.setLightType(data.lightType);
    }
    if (data.color !== void 0) {
      this.setColor(data.color);
    }
    if (data.colorTemperature !== void 0) {
      this.setColorTemperature(data.colorTemperature);
    }
    if (data.intensity !== void 0) {
      this.setIntensity(data.intensity);
    }
    if (data.falloffDistance !== void 0) {
      this.setFalloffDistance(data.falloffDistance);
    }
    if (data.falloff !== void 0) {
      this.lightData.falloff = data.falloff;
      this.setFalloffDistance(this.lightData.falloffDistance);
    }
    if (data.coneAngle !== void 0) {
      this.setConeAngle(data.coneAngle);
    }
    if (data.coneFeather !== void 0) {
      this.setConeFeather(data.coneFeather);
    }
    if (data.areaWidth !== void 0 || data.areaHeight !== void 0) {
      this.setAreaSize(
        data.areaWidth ?? this.lightData.areaWidth ?? 100,
        data.areaHeight ?? this.lightData.areaHeight ?? 100
      );
    }
    if (data.shadow !== void 0) {
      Object.assign(this.lightData.shadow, data.shadow);
      if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
        this.configureShadows(this.light);
      }
    }
    if (data.pointOfInterest !== void 0) {
      Object.assign(this.lightData.pointOfInterest, data.pointOfInterest);
    }
    if (data.pathFollowing !== void 0) {
      Object.assign(this.lightData.pathFollowing, data.pathFollowing);
    }
    if (data.lightLinking !== void 0) {
      Object.assign(this.lightData.lightLinking, data.lightLinking);
    }
    if (data.animatedIntensity !== void 0) {
      this.lightData.animatedIntensity = data.animatedIntensity;
    }
    if (data.animatedConeAngle !== void 0) {
      this.lightData.animatedConeAngle = data.animatedConeAngle;
    }
    if (data.animatedColor !== void 0) {
      this.lightData.animatedColor = data.animatedColor;
    }
    if (data.animatedColorTemperature !== void 0) {
      this.lightData.animatedColorTemperature = data.animatedColorTemperature;
    }
  }
  onDispose() {
    if (this.light.dispose) {
      this.light.dispose();
    }
    if (this.helper && this.helper.dispose) {
      this.helper.dispose();
    }
  }
}

const depthflowVertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const depthflowFragmentShader = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class DepthflowLayer extends BaseLayer {
  resources;
  // Textures
  sourceTexture = null;
  depthTexture = null;
  // Mesh and material
  mesh;
  geometry;
  material;
  // Layer data
  depthflowData;
  // Dimensions
  width = 1920;
  height = 1080;
  // Animation state
  animationTime = 0;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.depthflowData = this.extractDepthflowData(layerData);
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new ShaderMaterial({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new Vector2(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: depthflowVertexShader,
      fragmentShader: depthflowFragmentShader,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `depthflow_${this.id}`;
    this.group.add(this.mesh);
    this.loadTextures();
    this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(layerData) {
    const data = layerData.data;
    return {
      sourceLayerId: data?.sourceLayerId ?? "",
      depthLayerId: data?.depthLayerId ?? "",
      config: {
        preset: data?.config?.preset ?? "static",
        zoom: data?.config?.zoom ?? 1,
        offsetX: data?.config?.offsetX ?? 0,
        offsetY: data?.config?.offsetY ?? 0,
        rotation: data?.config?.rotation ?? 0,
        depthScale: data?.config?.depthScale ?? 0.1,
        focusDepth: data?.config?.focusDepth ?? 0.5,
        dollyZoom: data?.config?.dollyZoom ?? 0,
        orbitRadius: data?.config?.orbitRadius ?? 0.1,
        orbitSpeed: data?.config?.orbitSpeed ?? 1,
        swingAmplitude: data?.config?.swingAmplitude ?? 0.05,
        swingFrequency: data?.config?.swingFrequency ?? 1,
        edgeDilation: data?.config?.edgeDilation ?? 0,
        inpaintEdges: data?.config?.inpaintEdges ?? false
      },
      animatedZoom: data?.animatedZoom,
      animatedOffsetX: data?.animatedOffsetX,
      animatedOffsetY: data?.animatedOffsetY,
      animatedRotation: data?.animatedRotation,
      animatedDepthScale: data?.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const sourceTexture = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      if (sourceTexture) {
        this.sourceTexture = sourceTexture;
        this.material.uniforms.sourceTexture.value = sourceTexture;
        if (sourceTexture.image) {
          this.setDimensions(sourceTexture.image.width, sourceTexture.image.height);
        }
      }
    }
    if (this.depthflowData.depthLayerId) {
      const depthTexture = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      if (depthTexture) {
        this.depthTexture = depthTexture;
        this.material.uniforms.depthTexture.value = depthTexture;
      }
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(layerId) {
    const texture = this.resources.getLayerTexture(layerId);
    if (texture) return texture;
    layerLogger.warn(`DepthflowLayer: Could not load texture for layer ${layerId}`);
    return null;
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) return;
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Set source layer
   */
  async setSourceLayer(layerId) {
    this.depthflowData.sourceLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.sourceTexture?.dispose();
      this.sourceTexture = texture;
      this.material.uniforms.sourceTexture.value = texture;
    }
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(layerId) {
    this.depthflowData.depthLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.depthTexture?.dispose();
      this.depthTexture = texture;
      this.material.uniforms.depthTexture.value = texture;
    }
  }
  /**
   * Update config values
   */
  updateConfig(config) {
    Object.assign(this.depthflowData.config, config);
    if (config.depthScale !== void 0) {
      this.material.uniforms.depthScale.value = config.depthScale;
    }
    if (config.focusDepth !== void 0) {
      this.material.uniforms.focusDepth.value = config.focusDepth;
    }
    if (config.zoom !== void 0) {
      this.material.uniforms.zoom.value = config.zoom;
    }
    if (config.rotation !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(config.rotation);
    }
    if (config.edgeDilation !== void 0) {
      this.material.uniforms.edgeDilation.value = config.edgeDilation;
    }
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(frame, fps = 30) {
    const config = this.depthflowData.config;
    const duration = this.outPoint - this.inPoint;
    const progress = duration > 0 ? (frame - this.inPoint) / duration : 0;
    const time = frame / fps;
    let zoom = config.zoom;
    let offsetX = config.offsetX;
    let offsetY = config.offsetY;
    let rotation = config.rotation;
    switch (config.preset) {
      case "static":
        break;
      case "zoom_in":
        zoom = 1 + progress * 0.5;
        break;
      case "zoom_out":
        zoom = 1.5 - progress * 0.5;
        break;
      case "dolly_zoom_in":
        zoom = 1 + progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * progress);
        break;
      case "dolly_zoom_out":
        zoom = 1.5 - progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * (1 - progress));
        break;
      case "pan_left":
        offsetX = progress * 0.2;
        break;
      case "pan_right":
        offsetX = -progress * 0.2;
        break;
      case "pan_up":
        offsetY = progress * 0.2;
        break;
      case "pan_down":
        offsetY = -progress * 0.2;
        break;
      case "circle_cw":
        offsetX = Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "circle_ccw":
        offsetX = -Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "horizontal_swing":
        offsetX = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
      case "vertical_swing":
        offsetY = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
    }
    return { zoom, offsetX, offsetY, rotation };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const presetValues = this.calculatePresetValues(frame);
    let zoom = presetValues.zoom;
    let offsetX = presetValues.offsetX;
    let offsetY = presetValues.offsetY;
    let rotation = presetValues.rotation;
    if (this.depthflowData.animatedZoom) {
      zoom = this.evaluator.evaluate(this.depthflowData.animatedZoom, frame);
    }
    if (this.depthflowData.animatedOffsetX) {
      offsetX = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, frame);
    }
    if (this.depthflowData.animatedOffsetY) {
      offsetY = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, frame);
    }
    if (this.depthflowData.animatedRotation) {
      rotation = this.evaluator.evaluate(this.depthflowData.animatedRotation, frame);
    }
    if (this.depthflowData.animatedDepthScale) {
      this.material.uniforms.depthScale.value = this.evaluator.evaluate(
        this.depthflowData.animatedDepthScale,
        frame
      );
    }
    zoom = this.getDrivenOrBase("depthflow.zoom", zoom);
    offsetX = this.getDrivenOrBase("depthflow.offsetX", offsetX);
    offsetY = this.getDrivenOrBase("depthflow.offsetY", offsetY);
    rotation = this.getDrivenOrBase("depthflow.rotation", rotation);
    this.material.uniforms.zoom.value = zoom;
    this.material.uniforms.offset.value.set(offsetX, offsetY);
    this.material.uniforms.rotation.value = MathUtils.degToRad(rotation);
    this.material.uniforms.time.value = frame / 30;
    this.material.needsUpdate = true;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["zoom"] !== void 0) {
      this.material.uniforms.zoom.value = props["zoom"];
    }
    if (props["offsetX"] !== void 0 || props["offsetY"] !== void 0) {
      const offsetX = props["offsetX"] ?? this.material.uniforms.offset.value.x;
      const offsetY = props["offsetY"] ?? this.material.uniforms.offset.value.y;
      this.material.uniforms.offset.value.set(offsetX, offsetY);
    }
    if (props["rotation"] !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(props["rotation"]);
    }
    if (props["depthScale"] !== void 0) {
      this.material.uniforms.depthScale.value = props["depthScale"];
    }
    this.material.needsUpdate = true;
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.sourceLayerId !== void 0 && data.sourceLayerId !== this.depthflowData.sourceLayerId) {
      this.setSourceLayer(data.sourceLayerId);
    }
    if (data.depthLayerId !== void 0 && data.depthLayerId !== this.depthflowData.depthLayerId) {
      this.setDepthLayer(data.depthLayerId);
    }
    if (data.config) {
      this.updateConfig(data.config);
    }
    if (data.animatedZoom !== void 0) {
      this.depthflowData.animatedZoom = data.animatedZoom;
    }
    if (data.animatedOffsetX !== void 0) {
      this.depthflowData.animatedOffsetX = data.animatedOffsetX;
    }
    if (data.animatedOffsetY !== void 0) {
      this.depthflowData.animatedOffsetY = data.animatedOffsetY;
    }
    if (data.animatedRotation !== void 0) {
      this.depthflowData.animatedRotation = data.animatedRotation;
    }
    if (data.animatedDepthScale !== void 0) {
      this.depthflowData.animatedDepthScale = data.animatedDepthScale;
    }
  }
  onDispose() {
    this.sourceTexture?.dispose();
    this.depthTexture?.dispose();
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ProceduralMatteLayer extends BaseLayer {
  // Matte data
  matteData;
  // Display mesh
  mesh = null;
  material = null;
  texture = null;
  // Rendering canvas (grayscale output)
  renderCanvas;
  renderCtx;
  // Animation evaluator
  matteEvaluator;
  // Dimensions
  width = 512;
  height = 512;
  // Noise seed for deterministic noise
  noiseSeed;
  constructor(layerData) {
    super(layerData);
    this.matteEvaluator = new KeyframeEvaluator();
    this.matteData = this.extractMatteData(layerData);
    this.noiseSeed = this.matteData.parameters.seed ?? Math.random() * 65536;
    this.renderCanvas = document.createElement("canvas");
    this.renderCanvas.width = this.width;
    this.renderCanvas.height = this.height;
    this.renderCtx = this.renderCanvas.getContext("2d");
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract matte data with defaults
   */
  extractMatteData(layerData) {
    const data = layerData.data;
    if (!data) {
      return {
        patternType: "linear_gradient",
        parameters: {},
        animation: {
          enabled: false,
          speed: { id: "speed", name: "Speed", type: "number", value: 1, animated: false, keyframes: [] },
          phase: { id: "phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
          direction: { id: "dir", name: "Direction", type: "number", value: 0, animated: false, keyframes: [] }
        },
        inverted: false,
        levels: {
          inputBlack: { id: "ib", name: "Input Black", type: "number", value: 0, animated: false, keyframes: [] },
          inputWhite: { id: "iw", name: "Input White", type: "number", value: 255, animated: false, keyframes: [] },
          gamma: { id: "g", name: "Gamma", type: "number", value: 1, animated: false, keyframes: [] },
          outputBlack: { id: "ob", name: "Output Black", type: "number", value: 0, animated: false, keyframes: [] },
          outputWhite: { id: "ow", name: "Output White", type: "number", value: 255, animated: false, keyframes: [] }
        }
      };
    }
    return data;
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(this.width, this.height);
    this.texture = new CanvasTexture(this.renderCanvas);
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    this.material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `matte_${this.id}`;
    this.group.add(this.mesh);
  }
  /**
   * Set dimensions
   */
  setDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.renderCanvas.width = width;
    this.renderCanvas.height = height;
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh.geometry = new PlaneGeometry(width, height);
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.renderPattern(frame);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    if (properties.data) {
      this.matteData = this.extractMatteData({ ...properties, data: properties.data });
    }
  }
  // ============================================================================
  // PATTERN RENDERING
  // ============================================================================
  /**
   * Render the pattern to the canvas
   */
  renderPattern(frame) {
    const ctx = this.renderCtx;
    const w = this.width;
    const h = this.height;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);
    const speed = this.matteEvaluator.evaluate(this.matteData.animation.speed, frame);
    const phase = this.matteEvaluator.evaluate(this.matteData.animation.phase, frame);
    const time = this.matteData.animation.enabled ? frame * speed / 60 + phase : 0;
    switch (this.matteData.patternType) {
      case "linear_gradient":
        this.renderLinearGradient(ctx, w, h, frame, time);
        break;
      case "radial_gradient":
        this.renderRadialGradient(ctx, w, h, frame, time);
        break;
      case "angular_gradient":
        this.renderAngularGradient(ctx, w, h, frame, time);
        break;
      case "ramp":
        this.renderRamp(ctx, w, h, frame, time);
        break;
      case "noise":
        this.renderNoise(ctx, w, h, frame, time);
        break;
      case "checkerboard":
        this.renderCheckerboard(ctx, w, h, frame, time);
        break;
      case "circle":
        this.renderCircle(ctx, w, h, frame, time);
        break;
      case "rectangle":
        this.renderRectangle(ctx, w, h, frame, time);
        break;
      case "iris":
        this.renderIris(ctx, w, h, frame, time);
        break;
      case "radial_wipe":
        this.renderRadialWipe(ctx, w, h, frame, time);
        break;
      case "venetian_blinds":
        this.renderVenetianBlinds(ctx, w, h, frame, time);
        break;
      case "dissolve":
        this.renderDissolve(ctx, w, h, frame, time);
        break;
      case "wave":
        this.renderWave(ctx, w, h, frame, time);
        break;
      default:
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);
    }
    this.applyLevels(frame);
    if (this.matteData.inverted) {
      this.invertCanvas();
    }
  }
  // ============================================================================
  // PATTERN IMPLEMENTATIONS
  // ============================================================================
  renderLinearGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const angle = this.matteEvaluator.evaluate(params.angle, frame) + time * 360;
    const blend = this.matteEvaluator.evaluate(params.blend, frame);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const blendHalf = Math.max(1e-3, blend / 2);
    gradient.addColorStop(Math.max(0, 0.5 - blendHalf), "black");
    gradient.addColorStop(Math.min(1, 0.5 + blendHalf), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = this.matteEvaluator.evaluate(params.centerX, frame);
    const centerY = this.matteEvaluator.evaluate(params.centerY, frame);
    const radius = this.matteEvaluator.evaluate(params.radius, frame) + time * 0.5;
    const blend = params.blend ? this.matteEvaluator.evaluate(params.blend, frame) : 0.3;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = radius * Math.max(w, h) / 2;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    gradient.addColorStop(Math.max(0, 1 - blend), "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderAngularGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rotation = (params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0) + time * 360;
    const cx = centerX * w;
    const cy = centerY * h;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI + rotation;
        angle = (angle % 360 + 360) % 360;
        const value = Math.round(angle / 360 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderRamp(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = this.matteEvaluator.evaluate(params.progress, frame);
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.1;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const soft = Math.max(1e-3, softness / 2);
    gradient.addColorStop(Math.max(0, animProgress - soft), "black");
    gradient.addColorStop(Math.min(1, animProgress + soft), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderNoise(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const scale = params.scale ? this.matteEvaluator.evaluate(params.scale, frame) : 50;
    const octaves = params.octaves ?? 4;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const timeOffset = time * 10;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let noise = 0;
        let amp = 1;
        let freq = 1 / scale;
        for (let o = 0; o < octaves; o++) {
          noise += this.perlinNoise(x * freq + timeOffset, y * freq) * amp;
          amp *= 0.5;
          freq *= 2;
        }
        const value = Math.round((noise + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderCheckerboard(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const tilesX = params.tilesX ? this.matteEvaluator.evaluate(params.tilesX, frame) : 8;
    const tilesY = params.tilesY ? this.matteEvaluator.evaluate(params.tilesY, frame) : 8;
    const rotation = params.rotation ? this.matteEvaluator.evaluate(params.rotation, frame) : 0;
    const tileW = w / tilesX;
    const tileH = h / tilesY;
    const offset = time * tileW;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.translate(-w / 2 - offset, -h / 2);
    for (let y = -1; y <= tilesY + 1; y++) {
      for (let x = -1; x <= tilesX + 1; x++) {
        const isWhite = (x + y) % 2 === 0;
        ctx.fillStyle = isWhite ? "white" : "black";
        ctx.fillRect(x * tileW, y * tileH, tileW, tileH);
      }
    }
    ctx.restore();
  }
  renderCircle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const radius = params.radius ? this.matteEvaluator.evaluate(params.radius, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = (radius + time * 0.5) * Math.min(w, h) / 2;
    if (feather > 0) {
      const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 50), cx, cy, r);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, "black");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  renderRectangle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rectWidth = params.width ? this.matteEvaluator.evaluate(params.width, frame) : 0.5;
    const rectHeight = params.height ? this.matteEvaluator.evaluate(params.height, frame) : 0.5;
    const cornerRadius = params.cornerRadius ? this.matteEvaluator.evaluate(params.cornerRadius, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const rw = (rectWidth + time * 0.2) * w;
    const rh = (rectHeight + time * 0.2) * h;
    const cr = cornerRadius * Math.min(rw, rh) / 2;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.roundRect(cx - rw / 2, cy - rh / 2, rw, rh, cr);
    ctx.fill();
  }
  renderIris(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0.1;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const maxRadius = Math.sqrt(w * w + h * h) / 2;
    const r = animProgress * maxRadius;
    const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 100), cx, cy, r);
    gradient.addColorStop(0, "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialWipe(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.05;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const angle = animProgress * Math.PI * 2;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let pixelAngle = Math.atan2(dy, dx) + Math.PI;
        const diff = pixelAngle - angle;
        const dist = Math.abs((diff + Math.PI * 3) % (Math.PI * 2) - Math.PI) / Math.PI;
        let value = dist < 0.5 ? 255 : 0;
        if (softness > 0) {
          const soft = softness * Math.PI;
          if (Math.abs(dist - 0.5) < soft) {
            value = Math.round(255 * (1 - (dist - 0.5 + soft) / (soft * 2)));
          }
        }
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderVenetianBlinds(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const slats = params.slats ? this.matteEvaluator.evaluate(params.slats, frame) : 10;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const slatHeight = h / slats;
    const openAmount = animProgress * slatHeight;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle * Math.PI / 180);
    ctx.translate(-w / 2, -h / 2);
    for (let i = 0; i < slats; i++) {
      ctx.fillStyle = "white";
      ctx.fillRect(0, i * slatHeight, w, openAmount);
    }
    ctx.restore();
  }
  renderDissolve(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const blockSize = params.blockSize ? this.matteEvaluator.evaluate(params.blockSize, frame) : 4;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const blocksX = Math.ceil(w / blockSize);
    const blocksY = Math.ceil(h / blockSize);
    for (let by = 0; by < blocksY; by++) {
      for (let bx = 0; bx < blocksX; bx++) {
        const random = this.hash(bx + by * blocksX + this.noiseSeed);
        const isVisible = random < animProgress;
        const value = isVisible ? 255 : 0;
        for (let dy = 0; dy < blockSize && by * blockSize + dy < h; dy++) {
          for (let dx = 0; dx < blockSize && bx * blockSize + dx < w; dx++) {
            const x = bx * blockSize + dx;
            const y = by * blockSize + dy;
            const idx = (y * w + x) * 4;
            data[idx] = data[idx + 1] = data[idx + 2] = value;
            data[idx + 3] = 255;
          }
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderWave(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const frequency = params.frequency ? this.matteEvaluator.evaluate(params.frequency, frame) : 4;
    const amplitude = params.amplitude ? this.matteEvaluator.evaluate(params.amplitude, frame) : 0.5;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const waveType = params.waveType ?? "sine";
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const rad = angle * Math.PI / 180;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const rx = (x - w / 2) * Math.cos(rad) - (y - h / 2) * Math.sin(rad);
        const phase = (rx / w * frequency + time) * Math.PI * 2;
        let wave;
        switch (waveType) {
          case "triangle":
            wave = Math.abs(phase / Math.PI % 2 - 1) * 2 - 1;
            break;
          case "square":
            wave = Math.sin(phase) >= 0 ? 1 : -1;
            break;
          case "sawtooth":
            wave = phase / Math.PI % 2 - 1;
            break;
          default:
            wave = Math.sin(phase);
        }
        const value = Math.round((wave * amplitude + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  /**
   * Apply levels adjustment
   */
  applyLevels(frame) {
    const levels = this.matteData.levels;
    const inputBlack = this.matteEvaluator.evaluate(levels.inputBlack, frame);
    const inputWhite = this.matteEvaluator.evaluate(levels.inputWhite, frame);
    const gamma = this.matteEvaluator.evaluate(levels.gamma, frame);
    const outputBlack = this.matteEvaluator.evaluate(levels.outputBlack, frame);
    const outputWhite = this.matteEvaluator.evaluate(levels.outputWhite, frame);
    if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
      return;
    }
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    const inputRange = inputWhite - inputBlack;
    const outputRange = outputWhite - outputBlack;
    for (let i = 0; i < data.length; i += 4) {
      let value = data[i];
      value = Math.max(0, Math.min(255, (value - inputBlack) / inputRange * 255));
      value = Math.pow(value / 255, 1 / gamma) * 255;
      value = outputBlack + value / 255 * outputRange;
      data[i] = data[i + 1] = data[i + 2] = Math.round(value);
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  /**
   * Invert the canvas
   */
  invertCanvas() {
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];
      data[i + 1] = 255 - data[i + 1];
      data[i + 2] = 255 - data[i + 2];
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  /**
   * Simple deterministic hash function
   */
  hash(n) {
    const x = Math.sin(n) * 43758.5453123;
    return x - Math.floor(x);
  }
  /**
   * Simple 2D Perlin noise approximation
   */
  perlinNoise(x, y) {
    const xi = Math.floor(x);
    const yi = Math.floor(y);
    const xf = x - xi;
    const yf = y - yi;
    const tl = this.hash(xi + yi * 57 + this.noiseSeed);
    const tr = this.hash(xi + 1 + yi * 57 + this.noiseSeed);
    const bl = this.hash(xi + (yi + 1) * 57 + this.noiseSeed);
    const br = this.hash(xi + 1 + (yi + 1) * 57 + this.noiseSeed);
    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);
    return (tl + u * (tr - tl) + v * (bl - tl) + u * v * (tl - tr - bl + br)) * 2 - 1;
  }
  // ============================================================================
  // SOURCE CANVAS (for effects and track mattes)
  // ============================================================================
  getSourceCanvas() {
    return this.renderCanvas;
  }
  applyProcessedEffects(processedCanvas) {
    this.renderCtx.clearRect(0, 0, this.width, this.height);
    this.renderCtx.drawImage(processedCanvas, 0, 0);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
  }
}

function distance(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerpPoint(a, b, t) {
  return {
    x: a.x + (b.x - a.x) * t,
    y: a.y + (b.y - a.y) * t
  };
}
function addPoints(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function normalize(p) {
  const len = Math.sqrt(p.x * p.x + p.y * p.y);
  if (len < 1e-4) return { x: 0, y: 0 };
  return { x: p.x / len, y: p.y / len };
}
function perpendicular(p) {
  return { x: -p.y, y: p.x };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function rotatePoint(p, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: p.x * cos - p.y * sin,
    y: p.x * sin + p.y * cos
  };
}
function rotateAround(p, center, angle) {
  const translated = subtractPoints(p, center);
  const rotated = rotatePoint(translated, angle);
  return addPoints(rotated, center);
}
function clonePoint(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex(v) {
  return {
    point: clonePoint(v.point),
    inHandle: clonePoint(v.inHandle),
    outHandle: clonePoint(v.outHandle)
  };
}
function clonePath(path) {
  return {
    vertices: path.vertices.map(cloneVertex),
    closed: path.closed
  };
}
function cubicBezierPoint(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function cubicBezierDerivative(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const t2 = t * t;
  return {
    x: 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x),
    y: 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y)
  };
}
function splitCubicBezier(p0, p1, p2, p3, t) {
  const q0 = lerpPoint(p0, p1, t);
  const q1 = lerpPoint(p1, p2, t);
  const q2 = lerpPoint(p2, p3, t);
  const r0 = lerpPoint(q0, q1, t);
  const r1 = lerpPoint(q1, q2, t);
  const s = lerpPoint(r0, r1, t);
  return [
    [p0, q0, r0, s],
    [s, r1, q2, p3]
  ];
}
function cubicBezierLength(p0, p1, p2, p3, subdivisions = 32) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= subdivisions; i++) {
    const t = i / subdivisions;
    const curr = cubicBezierPoint(p0, p1, p2, p3, t);
    length += distance(prev, curr);
    prev = curr;
  }
  return length;
}
function getPathLength(path) {
  if (path.vertices.length < 2) return 0;
  let totalLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    totalLength += cubicBezierLength(p0, p1, p2, p3);
  }
  return totalLength;
}
function getPointAtDistance(path, targetDistance, totalLength) {
  if (path.vertices.length < 2) return null;
  const pathLength = totalLength ?? getPathLength(path);
  if (pathLength < 1e-4) return null;
  targetDistance = Math.max(0, Math.min(pathLength, targetDistance));
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    if (accumulatedLength + segmentLength >= targetDistance) {
      const remainingDistance = targetDistance - accumulatedLength;
      const localT = remainingDistance / segmentLength;
      const point = cubicBezierPoint(p0, p1, p2, p3, localT);
      const tangent = normalize(cubicBezierDerivative(p0, p1, p2, p3, localT));
      const globalT = (i + localT) / numSegments;
      return { point, tangent, t: globalT };
    }
    accumulatedLength += segmentLength;
  }
  const lastVertex = path.vertices[path.closed ? 0 : path.vertices.length - 1];
  return {
    point: clonePoint(lastVertex.point),
    tangent: { x: 1, y: 0 },
    t: 1
  };
}
function trimPath(path, startPercent, endPercent, offsetDegrees = 0) {
  if (path.vertices.length < 2) return clonePath(path);
  const totalLength = getPathLength(path);
  if (totalLength < 1e-4) return clonePath(path);
  const offsetPercent = offsetDegrees / 360 * 100;
  let start = ((startPercent + offsetPercent) % 100 + 100) % 100;
  let end = ((endPercent + offsetPercent) % 100 + 100) % 100;
  if (start > end && path.closed) {
    const part1 = trimPathSimple(path, start, 100, totalLength);
    const part2 = trimPathSimple(path, 0, end, totalLength);
    return joinPaths(part1, part2);
  }
  if (start > end) {
    [start, end] = [end, start];
  }
  return trimPathSimple(path, start, end, totalLength);
}
function trimPathSimple(path, startPercent, endPercent, totalLength) {
  const startDist = startPercent / 100 * totalLength;
  const endDist = endPercent / 100 * totalLength;
  if (endDist - startDist < 1e-3) {
    return { vertices: [], closed: false };
  }
  const result = [];
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  let inTrimRegion = false;
  let lastPoint = null;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    const segmentStart = accumulatedLength;
    const segmentEnd = accumulatedLength + segmentLength;
    if (segmentEnd > startDist && segmentStart < endDist) {
      const tStart = Math.max(0, (startDist - segmentStart) / segmentLength);
      const tEnd = Math.min(1, (endDist - segmentStart) / segmentLength);
      let trimmedPoints;
      if (tStart > 0 && tEnd < 1) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        const newTEnd = (tEnd - tStart) / (1 - tStart);
        const [left] = splitCubicBezier(right[0], right[1], right[2], right[3], newTEnd);
        trimmedPoints = left;
      } else if (tStart > 0) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        trimmedPoints = right;
      } else if (tEnd < 1) {
        const [left] = splitCubicBezier(p0, p1, p2, p3, tEnd);
        trimmedPoints = left;
      } else {
        trimmedPoints = [p0, p1, p2, p3];
      }
      if (!inTrimRegion || result.length === 0) {
        result.push({
          point: trimmedPoints[0],
          inHandle: { x: 0, y: 0 },
          outHandle: subtractPoints(trimmedPoints[1], trimmedPoints[0])
        });
        inTrimRegion = true;
      } else if (lastPoint && distance(lastPoint, trimmedPoints[0]) > 0.01) {
        if (result.length > 0) {
          result[result.length - 1].outHandle = subtractPoints(trimmedPoints[1], result[result.length - 1].point);
        }
      }
      result.push({
        point: trimmedPoints[3],
        inHandle: subtractPoints(trimmedPoints[2], trimmedPoints[3]),
        outHandle: { x: 0, y: 0 }
      });
      lastPoint = trimmedPoints[3];
    }
    accumulatedLength += segmentLength;
  }
  return { vertices: result, closed: false };
}
function joinPaths(path1, path2) {
  if (path1.vertices.length === 0) return clonePath(path2);
  if (path2.vertices.length === 0) return clonePath(path1);
  const result = clonePath(path1);
  const p2Verts = path2.vertices.map(cloneVertex);
  const lastP1 = result.vertices[result.vertices.length - 1];
  const firstP2 = p2Verts[0];
  if (distance(lastP1.point, firstP2.point) < 0.01) {
    lastP1.outHandle = firstP2.outHandle;
    result.vertices.push(...p2Verts.slice(1));
  } else {
    result.vertices.push(...p2Verts);
  }
  return result;
}
function mergePaths(paths, mode) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const polygons = paths.map(pathToPolygon);
  let result = [polygons[0]];
  for (let i = 1; i < polygons.length; i++) {
    const newPolygons = [];
    for (const existing of result) {
      switch (mode) {
        case "add":
          newPolygons.push(...polygonUnion(existing, polygons[i]));
          break;
        case "subtract":
        case "minusFront":
          newPolygons.push(...polygonDifference(existing));
          break;
        case "minusBack":
          newPolygons.push(...polygonDifference(polygons[i]));
          break;
        case "intersect":
          newPolygons.push(...polygonIntersection(existing));
          break;
        case "exclude":
          newPolygons.push(...polygonXor(existing, polygons[i]));
          break;
      }
    }
    result = newPolygons;
  }
  return result.map(polygonToPath);
}
function pathToPolygon(path, segments = 16) {
  const points = [];
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    for (let j = 0; j < segments; j++) {
      const t = j / segments;
      points.push(cubicBezierPoint(p0, p1, p2, p3, t));
    }
  }
  return points;
}
function polygonToPath(polygon) {
  const vertices = polygon.map((p) => ({
    point: clonePoint(p),
    inHandle: { x: 0, y: 0 },
    outHandle: { x: 0, y: 0 }
  }));
  return { vertices, closed: true };
}
function polygonUnion(a, b) {
  return [a, b];
}
function polygonDifference(a, b) {
  return [a];
}
function polygonIntersection(a, b) {
  return [a];
}
function polygonXor(a, b) {
  return [a, b];
}
function offsetPath(path, amount, join = "miter", miterLimit = 4) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  const isClosed = path.closed;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    let inDir;
    let outDir;
    if (i === 0 && !isClosed) {
      inDir = { x: 0, y: 0 };
      outDir = normalize(subtractPoints(
        addPoints(next.point, next.inHandle),
        addPoints(curr.point, curr.outHandle)
      ));
    } else if (i === numVertices - 1 && !isClosed) {
      inDir = normalize(subtractPoints(
        addPoints(curr.point, curr.inHandle),
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = { x: 0, y: 0 };
    } else {
      inDir = normalize(subtractPoints(
        curr.point,
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = normalize(subtractPoints(
        addPoints(curr.point, curr.outHandle),
        curr.point
      ));
    }
    let offsetDir;
    if (Math.abs(inDir.x) < 1e-3 && Math.abs(inDir.y) < 1e-3) {
      offsetDir = perpendicular(outDir);
    } else if (Math.abs(outDir.x) < 1e-3 && Math.abs(outDir.y) < 1e-3) {
      offsetDir = perpendicular(inDir);
    } else {
      const perpIn = perpendicular(inDir);
      const perpOut = perpendicular(outDir);
      offsetDir = normalize(addPoints(perpIn, perpOut));
      const angle = Math.acos(Math.max(-1, Math.min(1, dot(inDir, outDir))));
      if (angle > 0.01) {
        const miterFactor = 1 / Math.cos(angle / 2);
        if (join === "miter" && miterFactor <= miterLimit) {
          offsetDir = scalePoint(offsetDir, miterFactor);
        }
      }
    }
    const newPoint = addPoints(curr.point, scalePoint(offsetDir, amount));
    const handleScale = 1;
    result.push({
      point: newPoint,
      inHandle: scalePoint(curr.inHandle, handleScale),
      outHandle: scalePoint(curr.outHandle, handleScale)
    });
  }
  return { vertices: result, closed: isClosed };
}
function offsetPathMultiple(path, baseAmount, copies, copyOffset, join = "miter", miterLimit = 4) {
  const results = [clonePath(path)];
  for (let i = 1; i < copies; i++) {
    const amount = baseAmount + copyOffset * i;
    results.push(offsetPath(path, amount, join, miterLimit));
  }
  return results;
}
function puckerBloat(path, amount) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const centroid = { x: 0, y: 0 };
  for (const v of path.vertices) {
    centroid.x += v.point.x;
    centroid.y += v.point.y;
  }
  centroid.x /= path.vertices.length;
  centroid.y /= path.vertices.length;
  const factor = amount / 100;
  const result = path.vertices.map((v) => {
    const dir = subtractPoints(v.point, centroid);
    const dist = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
    if (dist < 1e-3) return cloneVertex(v);
    const moveAmount = dist * factor;
    const newPoint = addPoints(v.point, scalePoint(normalize(dir), moveAmount));
    const handleFactor = 1 + factor * 0.5;
    return {
      point: newPoint,
      inHandle: scalePoint(v.inHandle, handleFactor),
      outHandle: scalePoint(v.outHandle, handleFactor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function wigglePath(path, size, detail, pointType, correlation, temporalPhase, spatialPhase, seed) {
  if (path.vertices.length < 2 || size < 1e-3) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  for (let i = 0; i < Math.floor(temporalPhase * 100); i++) {
    rng.next();
  }
  const correlationFactor = correlation / 100;
  const result = [];
  const subdividedPath = subdividePath(path, Math.max(1, Math.floor(detail)));
  let prevOffset = { x: 0, y: 0 };
  for (let i = 0; i < subdividedPath.vertices.length; i++) {
    const v = subdividedPath.vertices[i];
    const angle = rng.next() * Math.PI * 2 + spatialPhase;
    const magnitude = rng.next() * size;
    const newOffset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const offset = {
      x: prevOffset.x * correlationFactor + newOffset.x * (1 - correlationFactor),
      y: prevOffset.y * correlationFactor + newOffset.y * (1 - correlationFactor)
    };
    prevOffset = offset;
    const newVertex = {
      point: addPoints(v.point, offset),
      inHandle: pointType === "smooth" ? clonePoint(v.inHandle) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? clonePoint(v.outHandle) : { x: 0, y: 0 }
    };
    result.push(newVertex);
  }
  return { vertices: result, closed: path.closed };
}
function subdividePath(path, levels = 1) {
  if (levels <= 0) return clonePath(path);
  let current = clonePath(path);
  for (let level = 0; level < levels; level++) {
    const result = [];
    const numSegments = current.closed ? current.vertices.length : current.vertices.length - 1;
    for (let i = 0; i < numSegments; i++) {
      const v0 = current.vertices[i];
      const v1 = current.vertices[(i + 1) % current.vertices.length];
      const p0 = v0.point;
      const p1 = addPoints(v0.point, v0.outHandle);
      const p2 = addPoints(v1.point, v1.inHandle);
      const p3 = v1.point;
      const [left, right] = splitCubicBezier(p0, p1, p2, p3, 0.5);
      result.push({
        point: left[0],
        inHandle: i === 0 ? v0.inHandle : subtractPoints(left[1], left[0]),
        outHandle: subtractPoints(left[1], left[0])
      });
      result.push({
        point: left[3],
        inHandle: subtractPoints(left[2], left[3]),
        outHandle: subtractPoints(right[1], right[0])
      });
    }
    if (!current.closed) {
      const lastV = current.vertices[current.vertices.length - 1];
      result.push(cloneVertex(lastV));
    }
    current = { vertices: result, closed: current.closed };
  }
  return current;
}
function zigZagPath(path, size, ridgesPerSegment, pointType) {
  if (path.vertices.length < 2 || size < 1e-3 || ridgesPerSegment < 1) {
    return clonePath(path);
  }
  const result = [];
  const totalLength = getPathLength(path);
  const ridgeLength = totalLength / (ridgesPerSegment * (path.vertices.length - (path.closed ? 0 : 1)));
  let currentDistance = 0;
  let zigDirection = 1;
  while (currentDistance < totalLength) {
    const pointData = getPointAtDistance(path, currentDistance, totalLength);
    if (!pointData) break;
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint(perp, size * zigDirection);
    const vertex = {
      point: addPoints(pointData.point, offset),
      inHandle: pointType === "smooth" ? scalePoint(pointData.tangent, -ridgeLength * 0.3) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? scalePoint(pointData.tangent, ridgeLength * 0.3) : { x: 0, y: 0 }
    };
    result.push(vertex);
    currentDistance += ridgeLength;
    zigDirection *= -1;
  }
  if (result.length > 0 && !path.closed) {
    const lastVertex = path.vertices[path.vertices.length - 1];
    result.push({
      point: clonePoint(lastVertex.point),
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function twistPath(path, angle, center) {
  if (path.vertices.length < 2 || Math.abs(angle) < 1e-3) {
    return clonePath(path);
  }
  let minY = Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minY = Math.min(minY, v.point.y);
    maxY = Math.max(maxY, v.point.y);
  }
  const height = maxY - minY;
  if (height < 1e-3) return clonePath(path);
  const angleRad = angle * Math.PI / 180;
  const result = path.vertices.map((v) => {
    const yNorm = (v.point.y - minY) / height;
    const localAngle = angleRad * yNorm;
    const rotatedPoint = rotateAround(v.point, center, localAngle);
    const absInHandle = addPoints(v.point, v.inHandle);
    const absOutHandle = addPoints(v.point, v.outHandle);
    const rotatedIn = rotateAround(absInHandle, center, localAngle);
    const rotatedOut = rotateAround(absOutHandle, center, localAngle);
    return {
      point: rotatedPoint,
      inHandle: subtractPoints(rotatedIn, rotatedPoint),
      outHandle: subtractPoints(rotatedOut, rotatedPoint)
    };
  });
  return { vertices: result, closed: path.closed };
}
function roundCorners(path, radius) {
  if (path.vertices.length < 2 || radius < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    if (!path.closed && (i === 0 || i === numVertices - 1)) {
      result.push(cloneVertex(curr));
      continue;
    }
    const toPrev = normalize(subtractPoints(prev.point, curr.point));
    const toNext = normalize(subtractPoints(next.point, curr.point));
    const dotProduct = dot(toPrev, toNext);
    if (dotProduct > 0.99) {
      result.push(cloneVertex(curr));
      continue;
    }
    const distPrev = distance(curr.point, prev.point);
    const distNext = distance(curr.point, next.point);
    const maxRadius = Math.min(radius, distPrev / 2, distNext / 2);
    const startPoint = addPoints(curr.point, scalePoint(toPrev, maxRadius));
    const endPoint = addPoints(curr.point, scalePoint(toNext, maxRadius));
    const kappa = 0.5522847498;
    const handleLength = maxRadius * kappa;
    result.push({
      point: startPoint,
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint(toPrev, -handleLength)
    });
    result.push({
      point: endPoint,
      inHandle: scalePoint(toNext, -handleLength),
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function generateRectangle(position, size, roundness = 0, direction = 1) {
  const hw = size.x / 2;
  const hh = size.y / 2;
  const r = Math.min(roundness, hw, hh);
  const corners = [
    { x: position.x - hw, y: position.y - hh },
    // TL
    { x: position.x + hw, y: position.y - hh },
    // TR
    { x: position.x + hw, y: position.y + hh },
    // BR
    { x: position.x - hw, y: position.y + hh }
    // BL
  ];
  if (direction === -1) {
    corners.reverse();
  }
  if (r < 0.01) {
    return {
      vertices: corners.map((p) => ({
        point: p,
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      })),
      closed: true
    };
  }
  const kappa = 0.5522847498 * r;
  const vertices = [];
  for (let i = 0; i < 4; i++) {
    const curr = corners[i];
    const next = corners[(i + 1) % 4];
    const dir = normalize(subtractPoints(next, curr));
    vertices.push({
      point: addPoints(curr, scalePoint(dir, r)),
      inHandle: scalePoint(dir, -kappa),
      outHandle: { x: 0, y: 0 }
    });
    vertices.push({
      point: subtractPoints(next, scalePoint(dir, r)),
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint(dir, kappa)
    });
  }
  return { vertices, closed: true };
}
function generateEllipse(position, size, direction = 1) {
  const rx = size.x / 2;
  const ry = size.y / 2;
  const kappa = 0.5522847498;
  let vertices = [
    {
      // Top
      point: { x: position.x, y: position.y - ry },
      inHandle: { x: -rx * kappa, y: 0 },
      outHandle: { x: rx * kappa, y: 0 }
    },
    {
      // Right
      point: { x: position.x + rx, y: position.y },
      inHandle: { x: 0, y: -ry * kappa },
      outHandle: { x: 0, y: ry * kappa }
    },
    {
      // Bottom
      point: { x: position.x, y: position.y + ry },
      inHandle: { x: rx * kappa, y: 0 },
      outHandle: { x: -rx * kappa, y: 0 }
    },
    {
      // Left
      point: { x: position.x - rx, y: position.y },
      inHandle: { x: 0, y: ry * kappa },
      outHandle: { x: 0, y: -ry * kappa }
    }
  ];
  if (direction === -1) {
    vertices = vertices.reverse().map((v) => ({
      point: v.point,
      inHandle: v.outHandle,
      outHandle: v.inHandle
    }));
  }
  return { vertices, closed: true };
}
function generatePolygon(position, points, radius, roundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI * 2 / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints; i++) {
    const idx = direction === 1 ? i : numPoints - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.5;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function generateStar(position, points, outerRadius, innerRadius, outerRoundness = 0, innerRoundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints * 2; i++) {
    const idx = direction === 1 ? i : numPoints * 2 - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const isOuter = idx % 2 === 0;
    const radius = isOuter ? outerRadius : innerRadius;
    const roundness = isOuter ? outerRoundness : innerRoundness;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.3;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function simplifyPath(path, tolerance, straightLines = false) {
  if (path.vertices.length <= 2) return clonePath(path);
  const points = pathToPolygon(path, 32);
  const simplified = douglasPeucker(points, tolerance);
  if (straightLines) {
    return polygonToPath(simplified);
  } else {
    return fitBezierToPoints(simplified, path.closed);
  }
}
function douglasPeucker(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDistance(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeucker(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function perpendicularDistance(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (length < 1e-4) return distance(point, lineStart);
  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
  const closest = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return distance(point, closest);
}
function fitBezierToPoints(points, closed) {
  const vertices = [];
  for (let i = 0; i < points.length; i++) {
    const prev = points[(i - 1 + points.length) % points.length];
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const handleLength = Math.min(
      distance(curr, prev) * 0.3,
      distance(curr, next) * 0.3
    );
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    vertices.push({
      point: clonePoint(curr),
      inHandle: scalePoint(avgDir, -handleLength),
      outHandle: scalePoint(avgDir, handleLength)
    });
  }
  return { vertices, closed };
}
function smoothPath(path, amount) {
  if (path.vertices.length < 2) return clonePath(path);
  const factor = amount / 100;
  const result = path.vertices.map((v, i) => {
    const prev = path.vertices[(i - 1 + path.vertices.length) % path.vertices.length];
    const next = path.vertices[(i + 1) % path.vertices.length];
    const toPrev = subtractPoints(prev.point, v.point);
    const toNext = subtractPoints(next.point, v.point);
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    const idealHandleLength = (distance(v.point, prev.point) + distance(v.point, next.point)) / 6;
    const idealIn = scalePoint(avgDir, -idealHandleLength);
    const idealOut = scalePoint(avgDir, idealHandleLength);
    return {
      point: clonePoint(v.point),
      inHandle: lerpPoint(v.inHandle, idealIn, factor),
      outHandle: lerpPoint(v.outHandle, idealOut, factor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function applyRepeater(paths, copies, offset, anchorPoint, position, scale, rotation, startOpacity, endOpacity) {
  const results = [];
  for (let i = 0; i < copies; i++) {
    const t = copies > 1 ? i / (copies - 1) : 0;
    const copyRotation = rotation * i;
    const copyScale = {
      x: 100 + (scale.x - 100) * i,
      y: 100 + (scale.y - 100) * i
    };
    const copyPosition = {
      x: position.x * i,
      y: position.y * i
    };
    const copyOpacity = startOpacity + (endOpacity - startOpacity) * t;
    const transformedPaths = paths.map((path) => {
      return transformPath(path, anchorPoint, copyPosition, copyScale, copyRotation);
    });
    results.push({
      paths: transformedPaths,
      opacities: paths.map(() => copyOpacity / 100)
    });
  }
  return results;
}
function transformPath(path, anchorPoint, position, scale, rotation) {
  const rotRad = rotation * Math.PI / 180;
  const cos = Math.cos(rotRad);
  const sin = Math.sin(rotRad);
  const transformPoint = (p) => {
    let x = p.x - anchorPoint.x;
    let y = p.y - anchorPoint.y;
    x *= scale.x / 100;
    y *= scale.y / 100;
    const rx = x * cos - y * sin;
    const ry = x * sin + y * cos;
    return {
      x: rx + anchorPoint.x + position.x,
      y: ry + anchorPoint.y + position.y
    };
  };
  const vertices = path.vertices.map((v) => {
    const newPoint = transformPoint(v.point);
    const absIn = addPoints(v.point, v.inHandle);
    const absOut = addPoints(v.point, v.outHandle);
    const newIn = transformPoint(absIn);
    const newOut = transformPoint(absOut);
    return {
      point: newPoint,
      inHandle: subtractPoints(newIn, newPoint),
      outHandle: subtractPoints(newOut, newPoint)
    };
  });
  return { vertices, closed: path.closed };
}
const ShapeOperations = {
  // Utilities
  distance,
  lerpPoint,
  addPoints,
  subtractPoints,
  scalePoint,
  normalize,
  perpendicular,
  clonePath,
  // Bezier
  cubicBezierPoint,
  cubicBezierLength,
  getPathLength,
  getPointAtDistance,
  splitCubicBezier,
  // Path operators
  trimPath,
  mergePaths,
  offsetPath,
  offsetPathMultiple,
  puckerBloat,
  wigglePath,
  zigZagPath,
  twistPath,
  roundCorners,
  // Generators
  generateRectangle,
  generateEllipse,
  generatePolygon,
  generateStar,
  // Illustrator features
  simplifyPath,
  smoothPath,
  // Repeater
  applyRepeater,
  transformPath
};

class ShapeLayer extends BaseLayer {
  type = "shape";
  // Shape data
  shapeData;
  // Rendering
  canvas;
  ctx;
  texture;
  mesh;
  // Canvas size (matches composition)
  canvasWidth = 1920;
  canvasHeight = 1080;
  // 3D extrusion (if any)
  extrudedMeshes = [];
  extrudeGroup;
  // Current frame for animation
  currentFrame = 0;
  constructor(layerData) {
    super(layerData);
    this.shapeData = layerData.data || {
      contents: [],
      blendMode: "normal",
      quality: "normal",
      gpuAccelerated: true
    };
    this.canvas = new OffscreenCanvas(this.canvasWidth, this.canvasHeight);
    this.ctx = this.canvas.getContext("2d");
    this.texture = new CanvasTexture(this.canvas);
    this.texture.colorSpace = SRGBColorSpace;
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    const geometry = new PlaneGeometry(this.canvasWidth, this.canvasHeight);
    const material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, material);
    this.mesh.position.set(this.canvasWidth / 2, this.canvasHeight / 2, 0);
    this.group.add(this.mesh);
    this.extrudeGroup = new Group();
    this.group.add(this.extrudeGroup);
    this.renderShape();
  }
  // ============================================================================
  // SIZE MANAGEMENT
  // ============================================================================
  /**
   * Set canvas size (should match composition)
   */
  setSize(width, height) {
    if (width === this.canvasWidth && height === this.canvasHeight) return;
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.canvas = new OffscreenCanvas(width, height);
    this.ctx = this.canvas.getContext("2d");
    this.texture.image = this.canvas;
    this.texture.needsUpdate = true;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
    this.mesh.position.set(width / 2, height / 2, 0);
    this.renderShape();
  }
  // ============================================================================
  // SHAPE DATA ACCESS
  // ============================================================================
  getShapeData() {
    return this.shapeData;
  }
  setShapeData(data) {
    this.shapeData = data;
    this.renderShape();
  }
  addContent(content) {
    this.shapeData.contents.push(content);
    this.renderShape();
  }
  removeContent(index) {
    this.shapeData.contents.splice(index, 1);
    this.renderShape();
  }
  updateContent(index, content) {
    if (index >= 0 && index < this.shapeData.contents.length) {
      this.shapeData.contents[index] = content;
      this.renderShape();
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  evaluateFrame(frame) {
    this.currentFrame = frame;
    super.evaluateFrame(frame);
    this.renderShape();
  }
  /**
   * Called during frame evaluation to update shape-specific properties
   */
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
  }
  /**
   * Called when layer properties are updated
   */
  onUpdate(properties) {
    if (properties.data) {
      this.shapeData = properties.data;
      this.renderShape();
    }
  }
  onApplyEvaluatedState(state) {
    if (state.shapeData) {
      this.shapeData = state.shapeData;
    }
    this.renderShape();
  }
  // ============================================================================
  // SHAPE RENDERING
  // ============================================================================
  /**
   * Main render function
   */
  renderShape() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    const evaluatedPaths = this.evaluateContents(this.shapeData.contents);
    for (const evalPath of evaluatedPaths) {
      this.renderPath(evalPath);
    }
    this.texture.needsUpdate = true;
  }
  /**
   * Evaluate all shape contents into renderable paths
   */
  evaluateContents(contents) {
    const generators = [];
    const operators = [];
    const modifiers = [];
    const repeaters = [];
    const transforms = [];
    const groups = [];
    const illustratorOps = [];
    for (const content of contents) {
      switch (content.type) {
        case "rectangle":
        case "ellipse":
        case "polygon":
        case "star":
        case "path":
          generators.push(content);
          break;
        case "fill":
        case "stroke":
        case "gradientFill":
        case "gradientStroke":
          modifiers.push(content);
          break;
        case "trimPaths":
        case "mergePaths":
        case "offsetPaths":
        case "puckerBloat":
        case "wigglePaths":
        case "zigZag":
        case "twist":
        case "roundedCorners":
          operators.push(content);
          break;
        case "repeater":
          repeaters.push(content);
          break;
        case "transform":
          transforms.push(content);
          break;
        case "group":
          groups.push(content);
          break;
        case "simplifyPath":
        case "smoothPath":
        case "extrude":
        case "trace":
          illustratorOps.push(content);
          break;
      }
    }
    let paths = generators.map((gen) => this.generatePath(gen));
    for (const op of operators) {
      paths = this.applyOperator(paths, op);
    }
    for (const op of illustratorOps) {
      paths = this.applyIllustratorOperator(paths, op);
    }
    for (const transform of transforms) {
      paths = paths.map((p) => this.applyShapeTransform(p, transform));
    }
    for (const repeater of repeaters) {
      paths = this.applyRepeater(paths, repeater);
    }
    const result = [];
    for (const path of paths) {
      const evalPath = { path };
      for (const mod of modifiers) {
        this.applyModifier(evalPath, mod);
      }
      result.push(evalPath);
    }
    for (const group of groups) {
      const groupPaths = this.evaluateContents(group.contents);
      result.push(...groupPaths);
    }
    return result;
  }
  /**
   * Generate a path from a shape generator
   */
  generatePath(generator) {
    switch (generator.type) {
      case "rectangle": {
        const rect = generator;
        const pos = this.getAnimatedValue(rect.position);
        const size = this.getAnimatedValue(rect.size);
        const roundness = this.getAnimatedValue(rect.roundness);
        return generateRectangle(pos, size, roundness, rect.direction);
      }
      case "ellipse": {
        const ellipse = generator;
        const pos = this.getAnimatedValue(ellipse.position);
        const size = this.getAnimatedValue(ellipse.size);
        return generateEllipse(pos, size, ellipse.direction);
      }
      case "polygon": {
        const poly = generator;
        const pos = this.getAnimatedValue(poly.position);
        const points = this.getAnimatedValue(poly.points);
        const radius = this.getAnimatedValue(poly.outerRadius);
        const roundness = this.getAnimatedValue(poly.outerRoundness);
        const rotation = this.getAnimatedValue(poly.rotation);
        return generatePolygon(pos, points, radius, roundness, rotation, poly.direction);
      }
      case "star": {
        const star = generator;
        const pos = this.getAnimatedValue(star.position);
        const points = this.getAnimatedValue(star.points);
        const outerR = this.getAnimatedValue(star.outerRadius);
        const innerR = this.getAnimatedValue(star.innerRadius);
        const outerRound = this.getAnimatedValue(star.outerRoundness);
        const innerRound = this.getAnimatedValue(star.innerRoundness);
        const rotation = this.getAnimatedValue(star.rotation);
        return generateStar(pos, points, outerR, innerR, outerRound, innerRound, rotation, star.direction);
      }
      case "path": {
        const pathShape = generator;
        return clonePath(this.getAnimatedValue(pathShape.path));
      }
      default:
        return { vertices: [], closed: false };
    }
  }
  /**
   * Apply a path operator to paths
   */
  applyOperator(paths, operator) {
    switch (operator.type) {
      case "trimPaths": {
        const trim = operator;
        const start = this.getAnimatedValue(trim.start);
        const end = this.getAnimatedValue(trim.end);
        const offset = this.getAnimatedValue(trim.offset);
        if (trim.mode === "simultaneously") {
          return paths.map((p) => trimPath(p, start, end, offset));
        } else {
          return paths.map((p, i) => {
            const pathStart = (start + 100 / paths.length * i) % 100;
            const pathEnd = (end + 100 / paths.length * i) % 100;
            return trimPath(p, pathStart, pathEnd, offset);
          });
        }
      }
      case "mergePaths": {
        const merge = operator;
        return mergePaths(paths, merge.mode);
      }
      case "offsetPaths": {
        const offset = operator;
        const amount = this.getAnimatedValue(offset.amount);
        const copies = this.getAnimatedValue(offset.copies);
        const copyOff = this.getAnimatedValue(offset.copyOffset);
        const miter = this.getAnimatedValue(offset.miterLimit);
        if (copies <= 1) {
          return paths.map((p) => offsetPath(p, amount, offset.lineJoin, miter));
        } else {
          return paths.flatMap(
            (p) => ShapeOperations.offsetPathMultiple(p, amount, copies, copyOff, offset.lineJoin, miter)
          );
        }
      }
      case "puckerBloat": {
        const pb = operator;
        const amount = this.getAnimatedValue(pb.amount);
        return paths.map((p) => puckerBloat(p, amount));
      }
      case "wigglePaths": {
        const wiggle = operator;
        const size = this.getAnimatedValue(wiggle.size);
        const detail = this.getAnimatedValue(wiggle.detail);
        const correlation = this.getAnimatedValue(wiggle.correlation);
        const temporal = this.getAnimatedValue(wiggle.temporalPhase) + this.currentFrame * 0.1;
        const spatial = this.getAnimatedValue(wiggle.spatialPhase);
        return paths.map(
          (p, i) => wigglePath(p, size, detail, wiggle.points, correlation, temporal, spatial, wiggle.randomSeed + i)
        );
      }
      case "zigZag": {
        const zz = operator;
        const size = this.getAnimatedValue(zz.size);
        const ridges = this.getAnimatedValue(zz.ridgesPerSegment);
        return paths.map((p) => zigZagPath(p, size, ridges, zz.points));
      }
      case "twist": {
        const twist = operator;
        const angle = this.getAnimatedValue(twist.angle);
        const center = this.getAnimatedValue(twist.center);
        return paths.map((p) => twistPath(p, angle, center));
      }
      case "roundedCorners": {
        const rc = operator;
        const radius = this.getAnimatedValue(rc.radius);
        return paths.map((p) => roundCorners(p, radius));
      }
      default:
        return paths;
    }
  }
  /**
   * Apply Illustrator-specific operators
   */
  applyIllustratorOperator(paths, operator) {
    switch (operator.type) {
      case "simplifyPath": {
        const simp = operator;
        const tolerance = this.getAnimatedValue(simp.tolerance);
        return paths.map((p) => simplifyPath(p, tolerance, simp.straightLines));
      }
      case "smoothPath": {
        const smooth = operator;
        const amount = this.getAnimatedValue(smooth.amount);
        return paths.map((p) => smoothPath(p, amount));
      }
      case "extrude": {
        this.createExtrudedGeometry(paths, operator);
        return paths;
      }
      case "trace": {
        return paths;
      }
      default:
        return paths;
    }
  }
  /**
   * Apply a shape transform
   */
  applyShapeTransform(path, transform) {
    const anchor = this.getAnimatedValue(transform.anchorPoint);
    const position = this.getAnimatedValue(transform.position);
    const scale = this.getAnimatedValue(transform.scale);
    const rotation = this.getAnimatedValue(transform.rotation);
    return transformPath(path, anchor, position, scale, rotation);
  }
  /**
   * Apply repeater operator
   */
  applyRepeater(paths, repeater) {
    const copies = Math.floor(this.getAnimatedValue(repeater.copies));
    if (copies <= 1) return paths;
    const offset = this.getAnimatedValue(repeater.offset);
    const anchor = this.getAnimatedValue(repeater.transform.anchorPoint);
    const position = this.getAnimatedValue(repeater.transform.position);
    const scale = this.getAnimatedValue(repeater.transform.scale);
    const rotation = this.getAnimatedValue(repeater.transform.rotation);
    const startOp = this.getAnimatedValue(repeater.transform.startOpacity);
    const endOp = this.getAnimatedValue(repeater.transform.endOpacity);
    const repeated = applyRepeater(
      paths,
      copies,
      offset,
      anchor,
      position,
      scale,
      rotation,
      startOp,
      endOp
    );
    const result = [];
    if (repeater.composite === "below") {
      result.push(...paths);
      for (const rep of repeated.slice(1)) {
        result.push(...rep.paths);
      }
    } else {
      for (let i = repeated.length - 1; i >= 1; i--) {
        result.push(...repeated[i].paths);
      }
      result.push(...paths);
    }
    return result;
  }
  /**
   * Apply a modifier (fill/stroke) to an evaluated path
   */
  applyModifier(evalPath, modifier) {
    switch (modifier.type) {
      case "fill": {
        const fill = modifier;
        evalPath.fill = {
          color: this.getAnimatedValue(fill.color),
          opacity: this.getAnimatedValue(fill.opacity),
          rule: fill.fillRule
        };
        break;
      }
      case "stroke": {
        const stroke = modifier;
        evalPath.stroke = {
          color: this.getAnimatedValue(stroke.color),
          opacity: this.getAnimatedValue(stroke.opacity),
          width: this.getAnimatedValue(stroke.width),
          lineCap: stroke.lineCap,
          lineJoin: stroke.lineJoin,
          dashPattern: this.getAnimatedValue(stroke.dashPattern),
          dashOffset: this.getAnimatedValue(stroke.dashOffset)
        };
        break;
      }
      case "gradientFill": {
        const grad = modifier;
        const gradDef = this.getAnimatedValue(grad.gradient);
        evalPath.gradientFill = {
          type: gradDef.type,
          stops: gradDef.stops,
          startPoint: gradDef.startPoint,
          endPoint: gradDef.endPoint,
          opacity: this.getAnimatedValue(grad.opacity)
        };
        break;
      }
    }
  }
  /**
   * Get animated value at current frame
   */
  getAnimatedValue(prop) {
    return prop.value;
  }
  /**
   * Render a single evaluated path to canvas
   */
  renderPath(evalPath) {
    const { path, fill, stroke, gradientFill } = evalPath;
    if (path.vertices.length < 2) return;
    this.ctx.save();
    const path2d = this.buildPath2D(path);
    if (gradientFill) {
      const gradient = this.createGradient(gradientFill);
      this.ctx.globalAlpha = gradientFill.opacity / 100;
      this.ctx.fillStyle = gradient;
      this.ctx.fill(path2d, "nonzero");
    } else if (fill) {
      this.ctx.globalAlpha = fill.opacity / 100;
      this.ctx.fillStyle = this.colorToCSS(fill.color);
      this.ctx.fill(path2d, fill.rule);
    }
    if (stroke && stroke.width > 0) {
      this.ctx.globalAlpha = stroke.opacity / 100;
      this.ctx.strokeStyle = this.colorToCSS(stroke.color);
      this.ctx.lineWidth = stroke.width;
      this.ctx.lineCap = stroke.lineCap;
      this.ctx.lineJoin = stroke.lineJoin;
      if (stroke.dashPattern.length > 0) {
        this.ctx.setLineDash(stroke.dashPattern);
        this.ctx.lineDashOffset = stroke.dashOffset;
      }
      this.ctx.stroke(path2d);
    }
    this.ctx.restore();
  }
  /**
   * Build a Path2D from a BezierPath
   */
  buildPath2D(path) {
    const p = new Path2D();
    if (path.vertices.length === 0) return p;
    const v0 = path.vertices[0];
    p.moveTo(v0.point.x, v0.point.y);
    for (let i = 0; i < path.vertices.length; i++) {
      const curr = path.vertices[i];
      const next = path.vertices[(i + 1) % path.vertices.length];
      if (!path.closed && i === path.vertices.length - 1) break;
      const cp1x = curr.point.x + curr.outHandle.x;
      const cp1y = curr.point.y + curr.outHandle.y;
      const cp2x = next.point.x + next.inHandle.x;
      const cp2y = next.point.y + next.inHandle.y;
      p.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
    }
    if (path.closed) {
      p.closePath();
    }
    return p;
  }
  /**
   * Convert ShapeColor to CSS color string
   */
  colorToCSS(color) {
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
  }
  /**
   * Create canvas gradient
   */
  createGradient(gradDef) {
    if (!gradDef) {
      return this.ctx.createLinearGradient(0, 0, 0, 0);
    }
    const startX = gradDef.startPoint.x * this.canvasWidth;
    const startY = gradDef.startPoint.y * this.canvasHeight;
    const endX = gradDef.endPoint.x * this.canvasWidth;
    const endY = gradDef.endPoint.y * this.canvasHeight;
    let gradient;
    if (gradDef.type === "linear") {
      gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
    } else {
      const radius = Math.sqrt(
        Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
      );
      gradient = this.ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
    }
    for (const stop of gradDef.stops) {
      gradient.addColorStop(stop.position, this.colorToCSS(stop.color));
    }
    return gradient;
  }
  /**
   * Create extruded 3D geometry from paths
   */
  createExtrudedGeometry(paths, extrude) {
    for (const mesh of this.extrudedMeshes) {
      this.extrudeGroup.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    this.extrudedMeshes = [];
    const depth = this.getAnimatedValue(extrude.depth);
    const bevelDepth = this.getAnimatedValue(extrude.bevelDepth);
    const frontColor = this.getAnimatedValue(extrude.material.frontColor);
    this.getAnimatedValue(extrude.material.sideColor);
    for (const path of paths) {
      if (path.vertices.length < 3 || !path.closed) continue;
      const shape = new Shape();
      const v0 = path.vertices[0];
      shape.moveTo(v0.point.x, v0.point.y);
      for (let i = 0; i < path.vertices.length; i++) {
        const curr = path.vertices[i];
        const next = path.vertices[(i + 1) % path.vertices.length];
        const cp1x = curr.point.x + curr.outHandle.x;
        const cp1y = curr.point.y + curr.outHandle.y;
        const cp2x = next.point.x + next.inHandle.x;
        const cp2y = next.point.y + next.inHandle.y;
        shape.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
      }
      const geometry = new ExtrudeGeometry(shape, {
        depth,
        bevelEnabled: bevelDepth > 0,
        bevelThickness: bevelDepth,
        bevelSize: bevelDepth,
        bevelSegments: extrude.bevelSegments
      });
      const material = new MeshStandardMaterial({
        color: new Color(frontColor.r / 255, frontColor.g / 255, frontColor.b / 255),
        metalness: 0.1,
        roughness: 0.8
      });
      const mesh = new Mesh(geometry, material);
      this.extrudeGroup.add(mesh);
      this.extrudedMeshes.push(mesh);
    }
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  dispose() {
    this.texture.dispose();
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    for (const mesh of this.extrudedMeshes) {
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    super.dispose();
  }
}

class ModelLayer extends BaseLayer {
  /** The loaded 3D model */
  model = null;
  /** Original materials (for restoring after override) */
  originalMaterials = /* @__PURE__ */ new Map();
  /** Animation mixer for animated models */
  mixer = null;
  /** Available animation clips */
  animationClips = [];
  /** Currently playing animation action */
  currentAction = null;
  /** Skeleton helper for bone visualization */
  skeletonHelper = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  modelData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders (static for efficiency) */
  static gltfLoader = null;
  static objLoader = null;
  static fbxLoader = null;
  static colladaLoader = null;
  static dracoLoader = null;
  /** Composition FPS for animation sync */
  fps = 30;
  constructor(layerData) {
    super(layerData);
    this.modelData = this.extractModelData(layerData);
    this.initializeLoaders();
    this.loadModel();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!ModelLayer.gltfLoader) {
      ModelLayer.gltfLoader = new GLTFLoader();
      ModelLayer.dracoLoader = new DRACOLoader();
      ModelLayer.dracoLoader.setDecoderPath("/draco/");
      ModelLayer.gltfLoader.setDRACOLoader(ModelLayer.dracoLoader);
      ModelLayer.gltfLoader.setMeshoptDecoder(MeshoptDecoder);
    }
    if (!ModelLayer.objLoader) {
      ModelLayer.objLoader = new OBJLoader();
    }
    if (!ModelLayer.fbxLoader) {
      ModelLayer.fbxLoader = new FBXLoader();
    }
    if (!ModelLayer.colladaLoader) {
      ModelLayer.colladaLoader = new ColladaLoader();
    }
  }
  /**
   * Extract model data from layer
   */
  extractModelData(layerData) {
    const data = layerData.data;
    const defaultScale = {
      id: `${layerData.id}_scale`,
      name: "Scale",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "gltf",
      scale: data?.scale ?? defaultScale,
      uniformScale: data?.uniformScale ?? true,
      materialOverride: data?.materialOverride,
      animation: data?.animation,
      boundingBox: data?.boundingBox,
      castShadow: data?.castShadow ?? true,
      receiveShadow: data?.receiveShadow ?? true,
      frustumCulled: data?.frustumCulled ?? true,
      renderOrder: data?.renderOrder ?? 0,
      showBoundingBox: data?.showBoundingBox ?? false,
      showSkeleton: data?.showSkeleton ?? false,
      envMapIntensity: data?.envMapIntensity ?? 1,
      lod: data?.lod
    };
  }
  /**
   * Load the 3D model from asset
   */
  async loadModel() {
    if (!this.modelData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.modelData.assetId);
      let loadedObject;
      switch (this.modelData.format) {
        case "gltf":
        case "glb":
          loadedObject = await this.loadGLTF(url);
          break;
        case "obj":
          loadedObject = await this.loadOBJ(url);
          break;
        case "fbx":
          loadedObject = await this.loadFBX(url);
          break;
        case "dae":
          loadedObject = await this.loadCollada(url);
          break;
        case "usd":
        case "usda":
        case "usdc":
        case "usdz":
          loadedObject = await this.loadUSD(url);
          break;
        default:
          throw new Error(`Unsupported model format: ${this.modelData.format}`);
      }
      this.setModel(loadedObject);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[ModelLayer] Failed to load model: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load GLTF/GLB model
   */
  loadGLTF(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.gltfLoader.load(
        url,
        (gltf) => {
          if (gltf.animations && gltf.animations.length > 0) {
            this.animationClips = gltf.animations;
            this.setupAnimations(gltf.scene);
          }
          resolve(gltf.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load OBJ model
   */
  loadOBJ(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.objLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load FBX model
   */
  loadFBX(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.fbxLoader.load(
        url,
        (object) => {
          if (object.animations && object.animations.length > 0) {
            this.animationClips = object.animations;
            this.setupAnimations(object);
          }
          resolve(object);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load Collada (DAE) model
   */
  loadCollada(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.colladaLoader.load(
        url,
        (collada) => {
          if (collada.scene.animations && collada.scene.animations.length > 0) {
            this.animationClips = collada.scene.animations;
            this.setupAnimations(collada.scene);
          }
          resolve(collada.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load USD/USDZ model
   * Note: USD support in Three.js is limited. This is a placeholder for future implementation.
   */
  async loadUSD(url) {
    try {
      const { USDZLoader } = await import('./weyl-three-vendor.js').then(n => n.bg);
      const loader = new USDZLoader();
      return new Promise((resolve, reject) => {
        loader.load(url, resolve, void 0, reject);
      });
    } catch {
      console.warn("[ModelLayer] USD/USDZ loader not available. Creating placeholder.");
      return this.createUSDPlaceholder();
    }
  }
  /**
   * Create placeholder for USD when loader unavailable
   */
  createUSDPlaceholder() {
    const group = new Group();
    group.name = "usd_placeholder";
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshStandardMaterial({
      color: 4886745,
      wireframe: true
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    return group;
  }
  /**
   * Create placeholder model when loading fails or no asset
   */
  createPlaceholder() {
    const group = new Group();
    group.name = `model_placeholder_${this.id}`;
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshBasicMaterial({
      color: 16737792,
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    const axisHelper = new AxesHelper(75);
    group.add(axisHelper);
    this.setModel(group);
  }
  /**
   * Set the loaded model
   */
  setModel(object) {
    if (this.model) {
      this.group.remove(this.model);
      this.disposeModel();
    }
    this.model = object;
    this.model.name = `model_${this.id}`;
    this.storeOriginalMaterials();
    this.applyShadowSettings();
    if (this.modelData.materialOverride) {
      this.applyMaterialOverride(this.modelData.materialOverride);
    }
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.updateSkeletonHelper();
    this.group.add(this.model);
  }
  /**
   * Store original materials for later restoration
   */
  storeOriginalMaterials() {
    this.originalMaterials.clear();
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        this.originalMaterials.set(child, child.material);
      }
    });
  }
  /**
   * Apply shadow settings to model
   */
  applyShadowSettings() {
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.castShadow = this.modelData.castShadow;
        child.receiveShadow = this.modelData.receiveShadow;
        child.frustumCulled = this.modelData.frustumCulled;
        child.renderOrder = this.modelData.renderOrder;
      }
    });
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.model) return;
    const box = new Box3().setFromObject(this.model);
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.modelData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Setup animation mixer and actions
   */
  setupAnimations(object) {
    this.mixer = new AnimationMixer(object);
    if (!this.modelData.animation) {
      this.modelData.animation = {
        clips: [],
        time: {
          id: `${this.id}_anim_time`,
          name: "Animation Time",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        speed: 1,
        loop: true,
        autoPlay: false
      };
    }
    this.modelData.animation.clips = this.animationClips.map((clip) => ({
      name: clip.name,
      duration: clip.duration,
      frameCount: Math.round(clip.duration * this.fps)
    }));
    if (this.modelData.animation.autoPlay && this.animationClips.length > 0) {
      this.playAnimation(this.animationClips[0].name);
    }
  }
  /**
   * Play an animation clip by name
   */
  playAnimation(clipName) {
    if (!this.mixer) return;
    const clip = this.animationClips.find((c) => c.name === clipName);
    if (!clip) return;
    if (this.currentAction) {
      this.currentAction.stop();
    }
    this.currentAction = this.mixer.clipAction(clip);
    this.currentAction.setLoop(
      this.modelData.animation?.loop ? LoopRepeat : LoopOnce,
      Infinity
    );
    this.currentAction.play();
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = clipName;
    }
  }
  /**
   * Stop current animation
   */
  stopAnimation() {
    if (this.currentAction) {
      this.currentAction.stop();
      this.currentAction = null;
    }
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = void 0;
    }
  }
  /**
   * Set animation time directly (for scrubbing)
   */
  setAnimationTime(time) {
    if (!this.mixer || !this.currentAction) return;
    this.currentAction.time = time;
    this.mixer.update(0);
  }
  /**
   * Update animation mixer
   */
  updateAnimation(deltaTime) {
    if (!this.mixer) return;
    const speed = this.modelData.animation?.speed ?? 1;
    this.mixer.update(deltaTime * speed);
  }
  // ============================================================================
  // MATERIAL OVERRIDES
  // ============================================================================
  /**
   * Apply material override to all meshes
   */
  applyMaterialOverride(override) {
    if (!this.model) return;
    this.model.traverse((child) => {
      if (child instanceof Mesh) {
        this.applyMaterialOverrideToMesh(child, override);
      }
    });
  }
  /**
   * Apply material override to a single mesh
   */
  applyMaterialOverrideToMesh(mesh, override) {
    if (override.useDepthMaterial) {
      mesh.material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
      });
      return;
    }
    if (override.useNormalMaterial) {
      mesh.material = new MeshNormalMaterial();
      return;
    }
    let material = Array.isArray(mesh.material) ? mesh.material[0].clone() : mesh.material.clone();
    if (override.wireframe !== void 0) {
      material.wireframe = override.wireframe;
    }
    if (override.wireframeColor && override.wireframe) {
      material = new MeshBasicMaterial({
        color: override.wireframeColor,
        wireframe: true
      });
    } else if (override.colorOverride) {
      material.color = new Color(override.colorOverride);
    }
    if (override.opacityOverride !== void 0) {
      material.transparent = override.opacityOverride < 1;
      material.opacity = override.opacityOverride;
    }
    if (override.flatShading !== void 0 && "flatShading" in material) {
      material.flatShading = override.flatShading;
      material.needsUpdate = true;
    }
    if (material instanceof MeshStandardMaterial) {
      if (override.metalness !== void 0) {
        material.metalness = override.metalness;
      }
      if (override.roughness !== void 0) {
        material.roughness = override.roughness;
      }
      if (override.emissive) {
        material.emissive = new Color(override.emissive);
      }
      if (override.emissiveIntensity !== void 0) {
        material.emissiveIntensity = override.emissiveIntensity;
      }
    }
    mesh.material = material;
  }
  /**
   * Restore original materials
   */
  restoreOriginalMaterials() {
    this.originalMaterials.forEach((material, mesh) => {
      mesh.material = material;
    });
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper visibility
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.modelData.showBoundingBox && this.model) {
      this.boundingBoxHelper = new BoxHelper(this.model, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  /**
   * Update skeleton helper visibility
   */
  updateSkeletonHelper() {
    if (this.skeletonHelper) {
      this.group.remove(this.skeletonHelper);
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    if (this.modelData.showSkeleton && this.model) {
      let skeleton = null;
      this.model.traverse((child) => {
        if (child instanceof SkinnedMesh && child.skeleton) {
          skeleton = child.skeleton;
        }
      });
      if (skeleton) {
        this.skeletonHelper = new SkeletonHelper(this.model);
        this.skeletonHelper.name = `skeleton_helper_${this.id}`;
        this.skeletonHelper.material.linewidth = 2;
        this.group.add(this.skeletonHelper);
      }
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set model scale
   */
  setScale(scale) {
    if (!this.model) return;
    if (typeof scale === "number") {
      this.model.scale.setScalar(scale);
    } else {
      this.model.scale.set(scale.x, scale.y, scale.z);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.modelData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  /**
   * Set skeleton visibility
   */
  setShowSkeleton(show) {
    this.modelData.showSkeleton = show;
    this.updateSkeletonHelper();
  }
  /**
   * Set FPS for animation sync
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the loaded model object
   */
  getModel() {
    return this.model;
  }
  /**
   * Get available animation clips
   */
  getAnimationClips() {
    return this.modelData.animation?.clips ?? [];
  }
  /**
   * Get model-specific bounding box data
   */
  getModelBoundingBox() {
    return this.modelData.boundingBox;
  }
  /**
   * Check if model is loading
   */
  isModelLoading() {
    return this.isLoading;
  }
  /**
   * Get load error if any
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    let scale;
    if (typeof this.modelData.scale === "object" && "value" in this.modelData.scale) {
      scale = interpolateProperty(this.modelData.scale, frame);
      this.setScale(scale);
    }
    if (this.modelData.animation?.time) {
      const time = interpolateProperty(this.modelData.animation.time, frame);
      this.setAnimationTime(time);
    }
    if (this.mixer && this.modelData.animation?.autoPlay) {
      const deltaTime = 1 / this.fps;
      this.updateAnimation(deltaTime);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["scale"] !== void 0) {
      this.setScale(props["scale"]);
    }
    if (props["animationTime"] !== void 0) {
      this.setAnimationTime(props["animationTime"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.modelData.assetId) {
        this.modelData.assetId = data.assetId;
        if (data.format) {
          this.modelData.format = data.format;
        }
        this.loadModel();
      }
      if (data.materialOverride !== void 0) {
        this.modelData.materialOverride = data.materialOverride;
        if (data.materialOverride) {
          this.applyMaterialOverride(data.materialOverride);
        } else {
          this.restoreOriginalMaterials();
        }
      }
      if (data.castShadow !== void 0 || data.receiveShadow !== void 0) {
        if (data.castShadow !== void 0) {
          this.modelData.castShadow = data.castShadow;
        }
        if (data.receiveShadow !== void 0) {
          this.modelData.receiveShadow = data.receiveShadow;
        }
        this.applyShadowSettings();
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.showSkeleton !== void 0) {
        this.setShowSkeleton(data.showSkeleton);
      }
      if (data.animation !== void 0) {
        Object.assign(this.modelData.animation ?? {}, data.animation);
        if (data.animation.activeClip) {
          this.playAnimation(data.animation.activeClip);
        }
      }
    }
  }
  onDispose() {
    this.disposeModel();
  }
  /**
   * Dispose model resources
   */
  disposeModel() {
    if (this.mixer) {
      this.mixer.stopAllAction();
      this.mixer = null;
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.skeletonHelper) {
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else {
          child.material.dispose();
        }
      }
    });
    this.originalMaterials.clear();
    this.animationClips = [];
    this.currentAction = null;
    this.model = null;
  }
}

class PointCloudLayer extends BaseLayer {
  /** The point cloud mesh */
  pointCloud = null;
  /** Point cloud geometry */
  geometry = null;
  /** Point cloud material */
  material = null;
  /** Original point data (for color mode switching) */
  originalAttributes = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  cloudData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders */
  static plyLoader = null;
  static pcdLoader = null;
  constructor(layerData) {
    super(layerData);
    this.cloudData = this.extractCloudData(layerData);
    this.initializeLoaders();
    this.loadPointCloud();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!PointCloudLayer.plyLoader) {
      PointCloudLayer.plyLoader = new PLYLoader();
    }
    if (!PointCloudLayer.pcdLoader) {
      PointCloudLayer.pcdLoader = new PCDLoader();
    }
  }
  /**
   * Extract point cloud data from layer
   */
  extractCloudData(layerData) {
    const data = layerData.data;
    const defaultPointSize = {
      id: `${layerData.id}_pointSize`,
      name: "Point Size",
      type: "number",
      value: 2,
      animated: false,
      keyframes: []
    };
    const defaultOpacity = {
      id: `${layerData.id}_opacity`,
      name: "Opacity",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "ply",
      pointCount: data?.pointCount ?? 0,
      pointSize: data?.pointSize ?? defaultPointSize,
      sizeAttenuation: data?.sizeAttenuation ?? true,
      minPointSize: data?.minPointSize ?? 1,
      maxPointSize: data?.maxPointSize ?? 64,
      colorMode: data?.colorMode ?? "rgb",
      uniformColor: data?.uniformColor ?? "#ffffff",
      colorGradient: data?.colorGradient,
      renderMode: data?.renderMode ?? "circles",
      opacity: data?.opacity ?? defaultOpacity,
      depthTest: data?.depthTest ?? true,
      depthWrite: data?.depthWrite ?? true,
      boundingBox: data?.boundingBox,
      showBoundingBox: data?.showBoundingBox ?? false,
      lod: data?.lod,
      octree: data?.octree,
      pointBudget: data?.pointBudget ?? 1e6,
      edl: data?.edl,
      clipPlanes: data?.clipPlanes,
      classificationFilter: data?.classificationFilter,
      intensityRange: data?.intensityRange
    };
  }
  /**
   * Load the point cloud from asset
   */
  async loadPointCloud() {
    if (!this.cloudData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.cloudData.assetId);
      let geometry;
      switch (this.cloudData.format) {
        case "ply":
          geometry = await this.loadPLY(url);
          break;
        case "pcd":
          geometry = await this.loadPCD(url);
          break;
        case "xyz":
        case "pts":
          geometry = await this.loadXYZ(url);
          break;
        case "las":
        case "laz":
          geometry = await this.loadLAS(url);
          break;
        default:
          throw new Error(`Unsupported point cloud format: ${this.cloudData.format}`);
      }
      this.setGeometry(geometry);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[PointCloudLayer] Failed to load point cloud: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load PLY point cloud
   */
  loadPLY(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.plyLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load PCD point cloud
   */
  loadPCD(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.pcdLoader.load(
        url,
        (points) => {
          resolve(points.geometry);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load XYZ/PTS point cloud (ASCII format)
   */
  async loadXYZ(url) {
    const response = await fetch(url);
    const text = await response.text();
    const lines = text.trim().split("\n");
    const positions = [];
    const colors = [];
    for (const line of lines) {
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        positions.push(
          parseFloat(parts[0]),
          parseFloat(parts[1]),
          parseFloat(parts[2])
        );
        if (parts.length >= 6) {
          colors.push(
            parseFloat(parts[3]) / 255,
            parseFloat(parts[4]) / 255,
            parseFloat(parts[5]) / 255
          );
        } else {
          colors.push(1, 1, 1);
        }
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Load LAS/LAZ point cloud
   * Note: LAS support requires additional libraries. This is a placeholder.
   */
  async loadLAS(url) {
    console.warn("[PointCloudLayer] LAS/LAZ format requires additional libraries. Creating placeholder.");
    return this.createPlaceholderGeometry();
  }
  /**
   * Create placeholder geometry
   */
  createPlaceholderGeometry() {
    const positions = [];
    const colors = [];
    const size = 100;
    const count = 1e3;
    for (let i = 0; i < count; i++) {
      positions.push(
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size
      );
      colors.push(Math.random(), Math.random(), Math.random());
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Create placeholder point cloud
   */
  createPlaceholder() {
    const geometry = this.createPlaceholderGeometry();
    this.setGeometry(geometry);
  }
  /**
   * Set the point cloud geometry
   */
  setGeometry(geometry) {
    if (this.pointCloud) {
      this.group.remove(this.pointCloud);
      this.disposePointCloud();
    }
    this.geometry = geometry;
    this.storeOriginalAttributes();
    const positionAttr = geometry.getAttribute("position");
    this.cloudData.pointCount = positionAttr ? positionAttr.count : 0;
    this.createMaterial();
    this.pointCloud = new Points(this.geometry, this.material);
    this.pointCloud.name = `pointcloud_${this.id}`;
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.applyColorMode(this.cloudData.colorMode);
    this.group.add(this.pointCloud);
  }
  /**
   * Store original point attributes
   */
  storeOriginalAttributes() {
    if (!this.geometry) return;
    const position = this.geometry.getAttribute("position");
    const color = this.geometry.getAttribute("color");
    const normal = this.geometry.getAttribute("normal");
    this.originalAttributes = {
      positions: position ? new Float32Array(position.array) : new Float32Array(),
      colors: color ? new Float32Array(color.array) : void 0,
      normals: normal ? new Float32Array(normal.array) : void 0
    };
  }
  /**
   * Create point cloud material
   */
  createMaterial() {
    this.material = new ShaderMaterial({
      uniforms: {
        pointSize: { value: 2 },
        minPointSize: { value: this.cloudData.minPointSize },
        maxPointSize: { value: this.cloudData.maxPointSize },
        opacity: { value: 1 },
        sizeAttenuation: { value: this.cloudData.sizeAttenuation ? 1 : 0 },
        uniformColor: { value: new Color(this.cloudData.uniformColor) },
        useUniformColor: { value: 0 },
        heightMin: { value: 0 },
        heightMax: { value: 100 },
        gradientColors: { value: this.getGradientTexture() },
        renderMode: { value: this.getRenderModeValue() }
      },
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      transparent: true,
      depthTest: this.cloudData.depthTest,
      depthWrite: this.cloudData.depthWrite,
      vertexColors: true
    });
  }
  /**
   * Get vertex shader for point cloud rendering
   */
  getVertexShader() {
    return `
      uniform float pointSize;
      uniform float minPointSize;
      uniform float maxPointSize;
      uniform float sizeAttenuation;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vColor = color;
        vPosition = position;
        vNormal = normal;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // Size attenuation
        float size = pointSize;
        if (sizeAttenuation > 0.5) {
          size = pointSize * (300.0 / -mvPosition.z);
        }

        // Clamp size
        gl_PointSize = clamp(size, minPointSize, maxPointSize);
      }
    `;
  }
  /**
   * Get fragment shader for point cloud rendering
   */
  getFragmentShader() {
    return `
      uniform float opacity;
      uniform vec3 uniformColor;
      uniform float useUniformColor;
      uniform float renderMode;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);

        // Render mode: 0 = points, 1 = circles, 2 = squares, 3 = splats
        if (renderMode > 0.5 && renderMode < 1.5) {
          // Circle
          float dist = length(coord);
          if (dist > 0.5) discard;
        } else if (renderMode > 2.5) {
          // Gaussian splat
          float dist = length(coord);
          float alpha = exp(-dist * dist * 8.0);
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(mix(vColor, uniformColor, useUniformColor), alpha * opacity);
          return;
        }
        // Squares (mode 2) use full point

        vec3 color = mix(vColor, uniformColor, useUniformColor);
        gl_FragColor = vec4(color, opacity);
      }
    `;
  }
  /**
   * Get render mode value for shader
   */
  getRenderModeValue() {
    switch (this.cloudData.renderMode) {
      case "points":
        return 0;
      case "circles":
        return 1;
      case "squares":
        return 2;
      case "splats":
        return 3;
      default:
        return 1;
    }
  }
  /**
   * Create gradient texture for color mapping
   */
  getGradientTexture() {
    const size = 256;
    const data = new Uint8Array(size * 4);
    const stops = this.cloudData.colorGradient?.stops ?? [
      { position: 0, color: "#0000ff" },
      { position: 0.5, color: "#00ff00" },
      { position: 1, color: "#ff0000" }
    ];
    for (let i = 0; i < size; i++) {
      const t = i / (size - 1);
      let stop1 = stops[0];
      let stop2 = stops[stops.length - 1];
      for (let j = 0; j < stops.length - 1; j++) {
        if (t >= stops[j].position && t <= stops[j + 1].position) {
          stop1 = stops[j];
          stop2 = stops[j + 1];
          break;
        }
      }
      const localT = (t - stop1.position) / (stop2.position - stop1.position);
      const color1 = new Color(stop1.color);
      const color2 = new Color(stop2.color);
      const color = color1.lerp(color2, localT);
      data[i * 4] = Math.floor(color.r * 255);
      data[i * 4 + 1] = Math.floor(color.g * 255);
      data[i * 4 + 2] = Math.floor(color.b * 255);
      data[i * 4 + 3] = 255;
    }
    const texture = new DataTexture(data, size, 1, RGBAFormat);
    texture.needsUpdate = true;
    return texture;
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.geometry) return;
    this.geometry.computeBoundingBox();
    const box = this.geometry.boundingBox;
    if (!box) return;
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.cloudData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
    if (this.material) {
      this.material.uniforms.heightMin.value = box.min.y;
      this.material.uniforms.heightMax.value = box.max.y;
    }
  }
  // ============================================================================
  // COLOR MODES
  // ============================================================================
  /**
   * Apply color mode to point cloud
   */
  applyColorMode(mode) {
    if (!this.geometry || !this.material || !this.originalAttributes) return;
    this.cloudData.colorMode = mode;
    switch (mode) {
      case "rgb":
        if (this.originalAttributes.colors) {
          this.geometry.setAttribute(
            "color",
            new Float32BufferAttribute(this.originalAttributes.colors, 3)
          );
        }
        this.material.uniforms.useUniformColor.value = 0;
        break;
      case "uniform":
        this.material.uniforms.useUniformColor.value = 1;
        this.material.uniforms.uniformColor.value.set(this.cloudData.uniformColor);
        break;
      case "height":
        this.applyHeightColoring();
        break;
      case "depth":
        this.applyDepthColoring();
        break;
      case "normal":
        this.applyNormalColoring();
        break;
      case "intensity":
        this.applyIntensityColoring();
        break;
      case "classification":
        this.applyClassificationColoring();
        break;
    }
    this.geometry.attributes.color.needsUpdate = true;
  }
  /**
   * Apply height-based coloring
   */
  applyHeightColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minY = this.cloudData.boundingBox.min.y;
    const maxY = this.cloudData.boundingBox.max.y;
    const range = maxY - minY || 1;
    for (let i = 0; i < count; i++) {
      const y = positions[i * 3 + 1];
      const t = (y - minY) / range;
      const color = new Color();
      color.setHSL((1 - t) * 0.7, 1, 0.5);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply depth-based coloring (distance from camera)
   */
  applyDepthColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minZ = this.cloudData.boundingBox.min.z;
    const maxZ = this.cloudData.boundingBox.max.z;
    const range = maxZ - minZ || 1;
    for (let i = 0; i < count; i++) {
      const z = positions[i * 3 + 2];
      const t = (z - minZ) / range;
      const value = 1 - t;
      colors[i * 3] = value;
      colors[i * 3 + 1] = value;
      colors[i * 3 + 2] = value;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply normal-based coloring
   */
  applyNormalColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.normals) {
      const normals = this.originalAttributes.normals;
      const count = normals.length / 3;
      const colors = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        colors[i * 3] = normals[i * 3] * 0.5 + 0.5;
        colors[i * 3 + 1] = normals[i * 3 + 1] * 0.5 + 0.5;
        colors[i * 3 + 2] = normals[i * 3 + 2] * 0.5 + 0.5;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    } else {
      console.warn("[PointCloudLayer] No normals available for normal coloring");
      this.material.uniforms.useUniformColor.value = 1;
      this.material.uniforms.uniformColor.value.set("#8080ff");
    }
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply intensity-based coloring
   */
  applyIntensityColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.intensities) {
      const intensities = this.originalAttributes.intensities;
      const count = intensities.length;
      const colors = new Float32Array(count * 3);
      let min = Infinity, max = -Infinity;
      for (let i = 0; i < count; i++) {
        min = Math.min(min, intensities[i]);
        max = Math.max(max, intensities[i]);
      }
      if (this.cloudData.intensityRange) {
        min = Math.max(min, this.cloudData.intensityRange.min);
        max = Math.min(max, this.cloudData.intensityRange.max);
      }
      const range = max - min || 1;
      for (let i = 0; i < count; i++) {
        const t = (intensities[i] - min) / range;
        colors[i * 3] = t;
        colors[i * 3 + 1] = t;
        colors[i * 3 + 2] = t;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No intensity data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  /**
   * Apply classification-based coloring (for LAS files)
   */
  applyClassificationColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.classifications) {
      const classifications = this.originalAttributes.classifications;
      const count = classifications.length;
      const colors = new Float32Array(count * 3);
      const classColors = {
        0: [0.5, 0.5, 0.5],
        // Never classified
        1: [0.5, 0.5, 0.5],
        // Unclassified
        2: [0.6, 0.4, 0.2],
        // Ground
        3: [0.2, 0.8, 0.2],
        // Low vegetation
        4: [0.1, 0.6, 0.1],
        // Medium vegetation
        5: [0, 0.4, 0],
        // High vegetation
        6: [0.9, 0.2, 0.2],
        // Building
        7: [0.5, 0.5, 0.5],
        // Low point (noise)
        8: [0.5, 0.5, 0.5],
        // Reserved
        9: [0.2, 0.4, 0.8],
        // Water
        10: [0.8, 0.6, 0.4],
        // Rail
        11: [0.3, 0.3, 0.3],
        // Road surface
        12: [0.5, 0.5, 0.5],
        // Reserved
        13: [0.8, 0.8, 0.2],
        // Wire - Guard
        14: [0.8, 0.6, 0.2],
        // Wire - Conductor
        15: [0.9, 0.9, 0.9],
        // Transmission Tower
        16: [0.6, 0.6, 0.8],
        // Wire - Connector
        17: [0.4, 0.4, 0.6],
        // Bridge Deck
        18: [0.9, 0.1, 0.1]
        // High Noise
      };
      for (let i = 0; i < count; i++) {
        const classId = classifications[i];
        const color = classColors[classId] ?? [0.5, 0.5, 0.5];
        colors[i * 3] = color[0];
        colors[i * 3 + 1] = color[1];
        colors[i * 3 + 2] = color[2];
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No classification data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.cloudData.showBoundingBox && this.pointCloud) {
      this.boundingBoxHelper = new BoxHelper(this.pointCloud, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set point size
   */
  setPointSize(size) {
    if (this.material) {
      this.material.uniforms.pointSize.value = size;
    }
  }
  /**
   * Set opacity
   */
  setOpacity(opacity) {
    if (this.material) {
      this.material.uniforms.opacity.value = opacity;
    }
  }
  /**
   * Set uniform color
   */
  setUniformColor(color) {
    this.cloudData.uniformColor = color;
    if (this.material) {
      this.material.uniforms.uniformColor.value.set(color);
    }
  }
  /**
   * Set render mode
   */
  setRenderMode(mode) {
    this.cloudData.renderMode = mode;
    if (this.material) {
      this.material.uniforms.renderMode.value = this.getRenderModeValue();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.cloudData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get point count
   */
  getPointCount() {
    return this.cloudData.pointCount;
  }
  /**
   * Get point cloud-specific bounding box data
   */
  getPointCloudBoundingBox() {
    return this.cloudData.boundingBox;
  }
  /**
   * Check if loading
   */
  isPointCloudLoading() {
    return this.isLoading;
  }
  /**
   * Get load error
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const size = interpolateProperty(this.cloudData.pointSize, frame);
    this.setPointSize(size);
    const opacity = interpolateProperty(this.cloudData.opacity, frame);
    this.setOpacity(opacity);
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pointSize"] !== void 0) {
      this.setPointSize(props["pointSize"]);
    }
    if (props["opacity"] !== void 0) {
      this.setOpacity(props["opacity"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.cloudData.assetId) {
        this.cloudData.assetId = data.assetId;
        if (data.format) {
          this.cloudData.format = data.format;
        }
        this.loadPointCloud();
      }
      if (data.colorMode !== void 0) {
        this.applyColorMode(data.colorMode);
      }
      if (data.uniformColor !== void 0) {
        this.setUniformColor(data.uniformColor);
      }
      if (data.renderMode !== void 0) {
        this.setRenderMode(data.renderMode);
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.depthTest !== void 0 || data.depthWrite !== void 0) {
        if (this.material) {
          if (data.depthTest !== void 0) {
            this.material.depthTest = data.depthTest;
            this.cloudData.depthTest = data.depthTest;
          }
          if (data.depthWrite !== void 0) {
            this.material.depthWrite = data.depthWrite;
            this.cloudData.depthWrite = data.depthWrite;
          }
        }
      }
    }
  }
  onDispose() {
    this.disposePointCloud();
  }
  /**
   * Dispose point cloud resources
   */
  disposePointCloud() {
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.geometry) {
      this.geometry.dispose();
      this.geometry = null;
    }
    this.originalAttributes = null;
    this.pointCloud = null;
  }
}

class LayerManager {
  scene;
  resources;
  layers;
  // Callbacks
  onVideoMetadataLoaded;
  precompRenderContext = null;
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Renderer reference for particle systems
  rendererRef = null;
  // Composition FPS for particle timing
  compositionFPS = 60;
  // Camera reference for particles
  cameraRef = null;
  // Audio reactive callback
  audioReactiveGetter = null;
  // Track matte canvas cache - stores rendered canvases for layers used as track mattes
  trackMatteCanvases = /* @__PURE__ */ new Map();
  // Ordered layer list for render order (respects track matte dependencies)
  renderOrder = [];
  // Callback to get cross-composition matte canvas
  crossCompMatteGetter = null;
  constructor(scene, resources) {
    this.scene = scene;
    this.resources = resources;
    this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(callback) {
    this.onVideoMetadataLoaded = callback;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(context) {
    this.precompRenderContext = context;
    for (const layer of this.layers.values()) {
      if (layer.type === "precomp") {
        layer.setRenderContext(context);
      }
    }
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
    for (const layer of this.layers.values()) {
      if (layer.type === "camera") {
        layer.setCameraCallbacks(getter, updater, atFrameGetter);
      }
    }
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setRenderer(renderer);
      }
    }
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(fps) {
    this.compositionFPS = fps;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setFPS(fps);
      }
      if (layer.type === "video") {
        layer.setFPS(fps);
      }
      if (layer.type === "precomp") {
        layer.setFPS(fps);
      }
    }
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(camera) {
    this.cameraRef = camera;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(layerData) {
    if (this.layers.has(layerData.id)) {
      layerLogger.warn(`LayerManager: Layer ${layerData.id} already exists, updating instead`);
      this.update(layerData.id, layerData);
      return this.layers.get(layerData.id);
    }
    const layer = this.createLayerInstance(layerData);
    this.layers.set(layerData.id, layer);
    this.setupLayerCallbacks(layer, layerData);
    if (layerData.parentId) {
      const parentLayer = this.layers.get(layerData.parentId);
      if (parentLayer) {
        layer.setParent(parentLayer);
      }
    }
    if (!layer.hasParent()) {
      this.scene.addToComposition(layer.getObject());
    }
    return layer;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(layer, layerData) {
    if (layer.type === "video" && this.onVideoMetadataLoaded) {
      const videoLayer = layer;
      videoLayer.setMetadataCallback((metadata) => {
        this.onVideoMetadataLoaded(layerData.id, metadata);
      });
    }
    if (layer.type === "precomp" && this.precompRenderContext) {
      const precompLayer = layer;
      precompLayer.setRenderContext(this.precompRenderContext);
    }
    if (layer.type === "camera" && this.cameraGetter && this.cameraUpdater) {
      const cameraLayer = layer;
      cameraLayer.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter);
      cameraLayer.setSplineProvider(this.createSplineProvider());
    }
    if (layer.type === "particles") {
      const particleLayer = layer;
      if (this.rendererRef) {
        particleLayer.setRenderer(this.rendererRef);
      }
      particleLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "video") {
      const videoLayer = layer;
      videoLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "precomp") {
      const precompLayer = layer;
      precompLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "light") {
      const lightLayer = layer;
      lightLayer.setLayerPositionGetter((layerId) => {
        const targetLayer = this.layers.get(layerId);
        if (targetLayer) {
          const obj = targetLayer.getObject();
          return new Vector3(obj.position.x, obj.position.y, obj.position.z);
        }
        return null;
      });
      lightLayer.setPathProvider(this.createSplineProvider());
    }
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(layerData) {
    switch (layerData.type) {
      case "image":
        return new ImageLayer(layerData, this.resources);
      case "solid":
        return new SolidLayer(layerData);
      case "null":
        return new NullLayer(layerData);
      case "text":
        return new TextLayer(layerData, this.resources);
      case "spline":
        return new SplineLayer(layerData);
      case "particles":
        return new ParticleLayer(layerData);
      case "video":
        return new VideoLayer(layerData, this.resources);
      case "precomp":
        return new PrecompLayer(layerData);
      case "camera":
        return new CameraLayer(layerData);
      case "light":
        return new LightLayer(layerData);
      case "depthflow":
        return new DepthflowLayer(layerData, this.resources);
      case "matte":
        return new ProceduralMatteLayer(layerData);
      case "shape":
        return new ShapeLayer(layerData);
      case "model":
        return new ModelLayer(layerData);
      case "pointcloud":
        return new PointCloudLayer(layerData);
      default:
        layerLogger.warn(`LayerManager: Unknown layer type: ${layerData.type}, creating NullLayer`);
        return new NullLayer(layerData);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(layerId, properties) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for update`);
      return;
    }
    layer.update(properties);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(updates) {
    for (const { id, properties } of updates) {
      this.update(id, properties);
    }
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(layerId) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(layer.getObject());
    layer.dispose();
    this.layers.delete(layerId);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(layerIds) {
    for (const id of layerIds) {
      this.remove(id);
    }
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [id, layer] of this.layers) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer state.
   * Layers receive already-computed values and only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * Rendering order:
   * 1. Spline layers (for text-on-path dependencies)
   * 2. Text-on-path connections
   * 3. Track matte source layers (render to canvas)
   * 4. All other layers (with track mattes applied)
   *
   * @param evaluatedLayers - Pre-evaluated layer states from MotionEngine
   * @param frame - Optional frame number for animated spline/mask evaluation
   */
  applyEvaluatedState(evaluatedLayers, frame) {
    const currentFrame = frame ?? 0;
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type === "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.updateTextPathConnections(frame);
    this.processTrackMattes(currentFrame);
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type !== "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.scene.sortByZ();
  }
  /**
   * Evaluate all layers at a given frame
   *
   * @deprecated Use applyEvaluatedState() with pre-evaluated state from MotionEngine.
   * This method causes layers to internally call interpolateProperty(), violating
   * the single-source-of-truth principle.
   *
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(frame, audioReactiveGetter) {
    this.updateTextPathConnections(frame);
    this.processTrackMattes(frame);
    const getter = audioReactiveGetter ?? this.audioReactiveGetter;
    for (const layer of this.layers.values()) {
      if (getter) {
        const audioValues = getter(layer.id, frame);
        if (audioValues.size > 0) {
          layer.setAudioReactiveValues(audioValues);
        }
      }
      layer.evaluateFrame(frame);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setDrivenValues(values);
    }
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const layer of this.layers.values()) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   *
   * For animated splines, this must be called with the current frame
   * to get properly evaluated control points.
   *
   * @param frame - Optional frame number for animated spline evaluation
   */
  updateTextPathConnections(frame) {
    for (const layer of this.layers.values()) {
      if (layer.type === "text") {
        const textLayer = layer;
        const textData = textLayer.getTextData();
        if (textData.pathLayerId) {
          const splineLayer = this.layers.get(textData.pathLayerId);
          if (splineLayer && splineLayer.type === "spline") {
            if (splineLayer.isAnimated() && frame !== void 0) {
              const evaluatedPoints = splineLayer.getEvaluatedControlPoints(frame);
              const controlPoints = evaluatedPoints.map((ep) => ({
                id: ep.id,
                x: ep.x,
                y: ep.y,
                depth: ep.depth,
                handleIn: ep.handleIn,
                handleOut: ep.handleOut,
                type: ep.type
              }));
              textLayer.setPathFromControlPoints(controlPoints, splineLayer.isClosed());
            } else {
              const curve = splineLayer.getCurve();
              if (curve) {
                textLayer.setPathFromCurve(curve);
              }
            }
          }
        }
      }
    }
  }
  // ============================================================================
  // SPLINE PATH PROVIDER (for Particle Systems)
  // ============================================================================
  /**
   * Create a SplinePathProvider that can be used by particle systems
   * to query spline positions for path-based emission
   *
   * USAGE:
   * ```typescript
   * const provider = layerManager.createSplineProvider();
   * particleSystem.setSplineProvider(provider);
   * ```
   */
  createSplineProvider() {
    return (layerId, t, frame) => {
      return this.querySplinePath(layerId, t, frame);
    };
  }
  /**
   * Query a spline layer for position and tangent at parameter t
   *
   * @param layerId - ID of the spline layer
   * @param t - Parameter along the path (0-1)
   * @param frame - Current frame for animated splines
   * @returns Position, tangent, and length or null if spline not found
   */
  querySplinePath(layerId, t, frame) {
    const layer = this.layers.get(layerId);
    if (!layer || layer.type !== "spline") {
      return null;
    }
    const splineLayer = layer;
    if (splineLayer.isAnimated()) {
      splineLayer.getEvaluatedControlPoints(frame);
    }
    const point = splineLayer.getPointAt(t);
    const tangent = splineLayer.getTangentAt(t);
    const length = splineLayer.getLength();
    if (!point || !tangent) {
      return null;
    }
    return {
      point: {
        x: point.x,
        y: -point.y,
        // Negate back from Three.js coordinate system
        z: point.z
      },
      tangent: {
        x: tangent.x,
        y: -tangent.y
        // Negate back
      },
      length
    };
  }
  /**
   * Get all spline layer IDs (useful for UI to list available paths)
   */
  getSplineLayerIds() {
    const ids = [];
    for (const [id, layer] of this.layers) {
      if (layer.type === "spline") {
        ids.push(id);
      }
    }
    return ids;
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(textLayerId, splineLayerId) {
    const textLayer = this.layers.get(textLayerId);
    if (!textLayer || textLayer.type !== "text") {
      layerLogger.warn(`LayerManager: Text layer ${textLayerId} not found`);
      return;
    }
    if (!splineLayerId) {
      textLayer.clearPath();
      return;
    }
    const splineLayer = this.layers.get(splineLayerId);
    if (!splineLayer || splineLayer.type !== "spline") {
      layerLogger.warn(`LayerManager: Spline layer ${splineLayerId} not found`);
      return;
    }
    const curve = splineLayer.getCurve();
    if (curve) {
      textLayer.setPathFromCurve(curve);
    }
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(layerId) {
    return this.layers.get(layerId)?.getObject() ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(layerId) {
    return this.layers.get(layerId) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(type) {
    return Array.from(this.layers.values()).filter(
      (layer) => layer.type === type
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(layerId) {
    return this.layers.has(layerId);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const layer of this.layers.values()) {
      if (layer.hasParent()) {
        const parent = layer.getParent();
        if (parent) {
          parent.getObject().remove(layer.getObject());
        }
      }
    }
    for (const layer of this.layers.values()) {
      const parentId = layer.getParentId();
      if (parentId) {
        const parentLayer = this.layers.get(parentId);
        if (parentLayer) {
          layer.setParent(parentLayer);
        } else {
          layer.setParent(null);
          this.scene.addToComposition(layer.getObject());
        }
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(layerId, parentId) {
    const layer = this.layers.get(layerId);
    if (!layer) return;
    if (layer.hasParent()) {
      const oldParent = layer.getParent();
      if (oldParent) {
        oldParent.getObject().remove(layer.getObject());
      }
    } else {
      this.scene.removeFromComposition(layer.getObject());
    }
    if (parentId) {
      const newParent = this.layers.get(parentId);
      if (newParent) {
        layer.setParent(newParent);
      } else {
        layer.setParent(null);
        this.scene.addToComposition(layer.getObject());
      }
    } else {
      layer.setParent(null);
      this.scene.addToComposition(layer.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(layerId, z) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.getObject().position.z = z;
      this.scene.sortByZ();
    }
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(layerId, visible) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setVisible(visible);
    }
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      const newVisible = !layer.getObject().visible;
      layer.setVisible(newVisible);
      return newVisible;
    }
    return false;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(layerId) {
    for (const [id, layer] of this.layers) {
      layer.setVisible(id === layerId);
    }
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const layer of this.layers.values()) {
      layer.setVisible(true);
    }
  }
  // ============================================================================
  // TRACK MATTE PROCESSING
  // ============================================================================
  /**
   * Set callback for retrieving cross-composition matte canvases
   *
   * This enables track mattes from other compositions (precomps)
   * to be used as matte sources.
   */
  setCrossCompMatteGetter(getter) {
    this.crossCompMatteGetter = getter;
  }
  /**
   * Process track mattes for all layers
   *
   * Track mattes use one layer's rendered output to control
   * another layer's visibility (alpha or luma).
   *
   * This method:
   * 1. Identifies layers that are used as track mattes
   * 2. Collects their rendered canvases (from same comp or cross-comp)
   * 3. Passes the canvas to layers that use them as mattes
   *
   * @param frame - Current frame number for animated evaluation
   */
  processTrackMattes(frame) {
    this.trackMatteCanvases.clear();
    for (const layer of this.layers.values()) {
      const matteLayerId = layer.getTrackMatteLayerId();
      const matteType = layer.getTrackMatteType();
      if (!matteLayerId || matteType === "none") {
        continue;
      }
      let matteCanvas = null;
      if (layer.hasCrossCompMatte() && this.crossCompMatteGetter) {
        const compositionId = layer.getTrackMatteCompositionId();
        matteCanvas = this.crossCompMatteGetter(compositionId, matteLayerId, frame);
        if (!matteCanvas) {
          layerLogger.warn(
            `Cross-comp track matte not found: composition=${compositionId}, layer=${matteLayerId}`
          );
        }
      } else {
        const matteLayer = this.layers.get(matteLayerId);
        if (matteLayer) {
          if (this.trackMatteCanvases.has(matteLayerId)) {
            matteCanvas = this.trackMatteCanvases.get(matteLayerId);
          } else {
            matteCanvas = this.getLayerRenderedCanvas(matteLayer, frame);
            if (matteCanvas) {
              this.trackMatteCanvases.set(matteLayerId, matteCanvas);
            }
          }
        } else {
          layerLogger.warn(`Track matte source layer ${matteLayerId} not found`);
        }
      }
      layer.setTrackMatteCanvas(matteCanvas);
    }
  }
  /**
   * Get the rendered canvas from a layer (for use as track matte)
   *
   * This gets the layer's visual output as a canvas that can be used
   * for track matte operations.
   *
   * @param layer - The layer to get canvas from
   * @param frame - Current frame for animated content
   * @returns Canvas with layer's rendered content, or null if unavailable
   */
  getLayerRenderedCanvas(layer, frame) {
    const sourceCanvas = layer.getSourceCanvas?.();
    if (sourceCanvas) {
      const canvas = document.createElement("canvas");
      canvas.width = sourceCanvas.width;
      canvas.height = sourceCanvas.height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        return canvas;
      }
    }
    return null;
  }
  /**
   * Update masks for a specific layer
   */
  setLayerMasks(layerId, masks) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setMasks(masks);
    }
  }
  /**
   * Clear track matte assignment for a layer
   */
  clearTrackMatte(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setTrackMatteCanvas(null);
    }
  }
  /**
   * Compute render order respecting track matte dependencies
   *
   * Matte layers must be rendered before the layers that use them.
   * This returns a topologically sorted list of layer IDs.
   */
  computeRenderOrder() {
    const order = [];
    const visited = /* @__PURE__ */ new Set();
    const visiting = /* @__PURE__ */ new Set();
    const visit = (layerId) => {
      if (visited.has(layerId)) return;
      if (visiting.has(layerId)) {
        layerLogger.warn(`Circular track matte dependency detected involving layer ${layerId}`);
        return;
      }
      visiting.add(layerId);
      const layer = this.layers.get(layerId);
      if (layer) {
        const matteLayerId = layer.getTrackMatteLayerId();
        if (matteLayerId && this.layers.has(matteLayerId)) {
          visit(matteLayerId);
        }
        const parentId = layer.getParentId();
        if (parentId && this.layers.has(parentId)) {
          visit(parentId);
        }
      }
      visiting.delete(layerId);
      visited.add(layerId);
      order.push(layerId);
    };
    for (const layerId of this.layers.keys()) {
      visit(layerId);
    }
    this.renderOrder = order;
    return order;
  }
  /**
   * Get the computed render order
   */
  getRenderOrder() {
    return this.renderOrder;
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(x, y, camera) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, camera);
    const intersects = this.scene.raycastComposition(raycaster);
    const layerIds = /* @__PURE__ */ new Set();
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          layerIds.add(obj.userData.layerId);
          break;
        }
        obj = obj.parent;
      }
    }
    return Array.from(layerIds).map((id) => this.layers.get(id)).filter((layer) => layer !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const layer of this.layers.values()) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
}

class CameraController {
  /** The main camera */
  camera;
  /** OrbitControls for 3D navigation */
  orbitControls = null;
  /** Keyframe evaluator for animations */
  evaluator;
  /** Composition dimensions */
  width;
  height;
  /** Default camera state for reset */
  defaultPosition;
  defaultTarget;
  defaultFov = 50;
  /** Animation properties */
  positionProp;
  targetProp;
  fovProp;
  /** Current target position (for lookAt) */
  target;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.evaluator = new KeyframeEvaluator();
    console.log(`[CameraController] constructor: comp=${width}x${height}`);
    this.camera = new PerspectiveCamera(
      this.defaultFov,
      // Field of view
      width / height,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = height / 2 / Math.tan(fovRad / 2);
    this.defaultPosition = new Vector3(width / 2, -height / 2, distance);
    this.defaultTarget = new Vector3(width / 2, -height / 2, 0);
    this.camera.position.copy(this.defaultPosition);
    this.target = this.defaultTarget.clone();
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORBIT CONTROLS (3D Navigation)
  // ============================================================================
  /**
   * Enable orbit controls for 3D navigation
   * @param domElement The canvas element to attach controls to
   */
  enableOrbitControls(domElement) {
    if (this.orbitControls) {
      this.orbitControls.dispose();
    }
    this.orbitControls = new OrbitControls(this.camera, domElement);
    this.orbitControls.mouseButtons = {
      LEFT: void 0,
      // Reserved for selection/tools
      MIDDLE: MOUSE.PAN,
      RIGHT: MOUSE.ROTATE
    };
    this.orbitControls.target.copy(this.target);
    this.orbitControls.enableDamping = false;
    this.orbitControls.enableZoom = false;
    this.orbitControls.minDistance = 10;
    this.orbitControls.maxDistance = 5e4;
    this.orbitControls.enablePan = true;
    this.orbitControls.panSpeed = 1;
    this.orbitControls.screenSpacePanning = true;
    this.orbitControls.enableRotate = true;
    this.orbitControls.rotateSpeed = 0.5;
    this.orbitControls.autoRotate = false;
    this.resetToDefault();
    console.log("[CameraController] Orbit controls enabled (scroll=zoom only, right-click=orbit)");
  }
  /**
   * Disable orbit controls
   */
  disableOrbitControls() {
    if (this.orbitControls) {
      this.orbitControls.dispose();
      this.orbitControls = null;
    }
  }
  /**
   * Update orbit controls (call in animation loop)
   */
  updateOrbitControls() {
    if (this.orbitControls) {
      this.orbitControls.update();
      this.target.copy(this.orbitControls.target);
    }
  }
  /**
   * Reset camera to default viewing position - PERFECT 2D FRONT VIEW
   * Camera looks straight at composition center, no rotation/tilt
   * This is the "Sync to Home" state - as if there's no 3D at all
   */
  resetToDefault() {
    const fovRad = MathUtils.degToRad(this.defaultFov);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    const centerX = this.width / 2;
    const centerY = -this.height / 2;
    this.camera.position.set(centerX, centerY, distance);
    this.target.set(centerX, centerY, 0);
    this.camera.fov = this.defaultFov;
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
    if (this.orbitControls) {
      this.orbitControls.target.copy(this.target);
      this.orbitControls.update();
    }
    this.zoomLevel = 1;
    this.panOffset.set(0, 0);
    console.log(`[CameraController] resetToDefault: comp=${this.width}x${this.height}, center=(${centerX}, ${centerY}), cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${distance.toFixed(1)}), fov=${this.defaultFov}, aspect=${this.camera.aspect.toFixed(3)}`);
  }
  /**
   * Check if orbit controls are enabled
   */
  hasOrbitControls() {
    return this.orbitControls !== null;
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera position directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setPositionDirect(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera target directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setTargetDirect(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(x, y, z) {
    this.camera.rotation.set(
      MathUtils.degToRad(x),
      MathUtils.degToRad(y),
      MathUtils.degToRad(z)
    );
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(fov) {
    this.camera.fov = MathUtils.clamp(fov, 1, 179);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(near, far) {
    this.camera.near = Math.max(1e-3, near);
    this.camera.far = Math.max(this.camera.near + 1, far);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEWPORT ZOOM/PAN
  // ============================================================================
  /** Pan offset for viewport navigation */
  panOffset = new Vector2(0, 0);
  zoomLevel = 1;
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(zoom) {
    this.zoomLevel = Math.max(0.1, Math.min(10, zoom));
    this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation (in WORLD units, not screen pixels)
   * Positive X pans right (camera moves left), positive Y pans down (camera moves up)
   */
  setPan(x, y) {
    this.panOffset.set(x, y);
    this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   * Camera always looks straight at the composition plane (perfect 2D front view)
   */
  updateCameraForViewport() {
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const baseDistance = this.height / 2 / Math.tan(fovRad / 2);
    const distance = baseDistance / this.zoomLevel;
    const compositionCenterX = this.width / 2;
    const compositionCenterY = -this.height / 2;
    const cameraPosX = compositionCenterX + this.panOffset.x;
    const cameraPosY = compositionCenterY - this.panOffset.y;
    this.camera.position.set(cameraPosX, cameraPosY, distance);
    this.target.set(cameraPosX, cameraPosY, 0);
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.rotation.z = 0;
    this.camera.updateProjectionMatrix();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the primary method for centering - calculates the right zoom to fit
   * @param viewportWidth - The viewport width in pixels
   * @param viewportHeight - The viewport height in pixels
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitToViewport(viewportWidth, viewportHeight, padding = 40) {
    const availableWidth = viewportWidth - padding * 2;
    const availableHeight = viewportHeight - padding * 2;
    const scaleX = availableWidth / this.width;
    const scaleY = availableHeight / this.height;
    const fitZoom = Math.min(scaleX, scaleY, 1);
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
    this.zoomLevel = fitZoom;
    this.panOffset.set(0, 0);
    this.updateCameraForViewport();
    console.log(`[CameraController] fitToViewport: viewport=${viewportWidth}x${viewportHeight}, comp=${this.width}x${this.height}, zoom=${fitZoom.toFixed(3)}, cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)})`);
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(props) {
    this.positionProp = props.position;
    this.targetProp = props.target;
    this.fovProp = props.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0;
    this.targetProp = void 0;
    this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(frame) {
    if (this.positionProp) {
      const pos = this.evaluator.evaluate(this.positionProp, frame);
      this.setPosition(pos.x, pos.y, pos.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const target = this.evaluator.evaluate(this.targetProp, frame);
      this.setTarget(target.x, target.y, target.z ?? 0);
    }
    if (this.fovProp) {
      const fov = this.evaluator.evaluate(this.fovProp, frame);
      this.setFOV(fov);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new COMPOSITION dimensions
   * Note: The aspect ratio should be set separately using setViewportAspect()
   */
  resize(width, height) {
    console.log(`[CameraController] resize: NEW comp=${width}x${height} (was ${this.width}x${this.height})`);
    this.width = width;
    this.height = height;
    this.resetToDefault();
  }
  /**
   * Set camera aspect ratio to match viewport dimensions
   * This should be called with VIEWPORT dimensions, not composition
   */
  setViewportAspect(viewportWidth, viewportHeight) {
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(screenX, screenY, z = 0) {
    const ndcX = screenX / this.width * 2 - 1;
    const ndcY = -(screenY / this.height) * 2 + 1;
    const vector = new Vector3(ndcX, ndcY, 0.5);
    vector.unproject(this.camera);
    const dir = vector.sub(this.camera.position).normalize();
    const distance = (z - this.camera.position.z) / dir.z;
    return this.camera.position.clone().add(dir.multiplyScalar(distance));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(worldX, worldY, worldZ = 0) {
    const vector = new Vector3(worldX, -worldY, worldZ);
    vector.project(this.camera);
    return {
      x: (vector.x + 1) / 2 * this.width,
      y: (-vector.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(state) {
    if (state.position) {
      this.setPosition(state.position.x, state.position.y, state.position.z);
    }
    if (state.target) {
      this.setTarget(state.target.x, state.target.y, state.target.z);
    }
    if (state.fov !== void 0) {
      this.setFOV(state.fov);
    }
    if (state.near !== void 0 || state.far !== void 0) {
      this.setClipPlanes(
        state.near ?? this.camera.near,
        state.far ?? this.camera.far
      );
    }
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const fovRad = MathUtils.degToRad(50);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    this.camera.fov = 50;
    this.camera.position.set(this.width / 2, -this.height / 2, distance);
    this.target.set(this.width / 2, -this.height / 2, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const ortho = new OrthographicCamera(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    ortho.position.set(0, 0, 1e3);
    ortho.lookAt(0, 0, 0);
    return ortho;
  }
  // ============================================================================
  // 3D ORBIT CONTROLS
  // ============================================================================
  /** Current spherical coordinates for orbit mode */
  spherical = { radius: 1e3, theta: 0, phi: Math.PI / 2 };
  /** Whether orbit mode is enabled */
  orbitEnabled = false;
  /**
   * Enable orbit mode for 3D navigation
   * In orbit mode, the camera orbits around the target point
   */
  enableOrbitMode() {
    this.orbitEnabled = true;
    const offset = new Vector3().subVectors(this.camera.position, this.target);
    this.spherical.radius = offset.length();
    this.spherical.theta = Math.atan2(offset.x - this.target.x, offset.z);
    this.spherical.phi = Math.acos(MathUtils.clamp(offset.y / this.spherical.radius, -1, 1));
  }
  /**
   * Disable orbit mode (return to pan/zoom mode)
   */
  disableOrbitMode() {
    this.orbitEnabled = false;
  }
  /**
   * Check if orbit mode is active
   */
  isOrbitMode() {
    return this.orbitEnabled;
  }
  /**
   * Orbit camera around target point
   * @param deltaTheta - Horizontal rotation in radians (around Y axis)
   * @param deltaPhi - Vertical rotation in radians (around X axis)
   */
  orbit(deltaTheta, deltaPhi) {
    if (!this.orbitEnabled) return;
    this.spherical.theta -= deltaTheta;
    this.spherical.phi = MathUtils.clamp(
      this.spherical.phi - deltaPhi,
      0.01,
      // Prevent flipping at poles
      Math.PI - 0.01
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Dolly (zoom in/out) in orbit mode
   * @param delta - Positive to zoom in, negative to zoom out
   */
  dolly(delta) {
    if (!this.orbitEnabled) {
      this.setZoom(this.zoomLevel * (1 + delta * 0.1));
      return;
    }
    this.spherical.radius = MathUtils.clamp(
      this.spherical.radius * (1 - delta * 0.1),
      10,
      // Minimum distance
      5e4
      // Maximum distance
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Pan camera in orbit mode (move target point)
   * @param deltaX - Horizontal pan in screen pixels
   * @param deltaY - Vertical pan in screen pixels
   */
  orbitPan(deltaX, deltaY) {
    if (!this.orbitEnabled) {
      this.setPan(this.panOffset.x + deltaX, this.panOffset.y + deltaY);
      return;
    }
    const panSpeed = this.spherical.radius * 1e-3;
    const right = new Vector3();
    const up = new Vector3();
    right.setFromMatrixColumn(this.camera.matrix, 0);
    up.setFromMatrixColumn(this.camera.matrix, 1);
    const panOffset = new Vector3();
    panOffset.addScaledVector(right, -deltaX * panSpeed);
    panOffset.addScaledVector(up, deltaY * panSpeed);
    this.target.add(panOffset);
    this.updateCameraFromSpherical();
  }
  /**
   * Update camera position from spherical coordinates
   */
  updateCameraFromSpherical() {
    const x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
    const y = this.spherical.radius * Math.cos(this.spherical.phi);
    const z = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
    this.camera.position.set(
      this.target.x + x,
      this.target.y + y,
      this.target.z + z
    );
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEW PRESETS
  // ============================================================================
  /**
   * Available orthographic view presets
   */
  static VIEW_PRESETS = {
    front: { theta: 0, phi: Math.PI / 2, name: "Front" },
    back: { theta: Math.PI, phi: Math.PI / 2, name: "Back" },
    left: { theta: -Math.PI / 2, phi: Math.PI / 2, name: "Left" },
    right: { theta: Math.PI / 2, phi: Math.PI / 2, name: "Right" },
    top: { theta: 0, phi: 0.01, name: "Top" },
    bottom: { theta: 0, phi: Math.PI - 0.01, name: "Bottom" },
    perspective: { theta: Math.PI / 4, phi: Math.PI / 3, name: "Perspective" }
  };
  /**
   * Switch to a predefined view preset
   * @param preset - Name of the view preset
   * @param animate - Whether to animate the transition (default: false)
   */
  setViewPreset(preset, animate = false) {
    const view = CameraController.VIEW_PRESETS[preset];
    if (!view) return;
    if (!this.orbitEnabled) {
      this.enableOrbitMode();
    }
    if (animate) {
      const startTheta = this.spherical.theta;
      const startPhi = this.spherical.phi;
      const targetTheta = view.theta;
      const targetPhi = view.phi;
      const duration = 300;
      const startTime = performance.now();
      const animateView = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.spherical.theta = startTheta + (targetTheta - startTheta) * eased;
        this.spherical.phi = startPhi + (targetPhi - startPhi) * eased;
        this.updateCameraFromSpherical();
        if (t < 1) {
          requestAnimationFrame(animateView);
        }
      };
      requestAnimationFrame(animateView);
    } else {
      this.spherical.theta = view.theta;
      this.spherical.phi = view.phi;
      this.updateCameraFromSpherical();
    }
  }
  /**
   * Reset camera to default 2D view (centered on composition)
   */
  resetTo2DView() {
    this.disableOrbitMode();
    this.panOffset.set(0, 0);
    this.zoomLevel = 1;
    this.reset();
  }
  /**
   * Reset orbit to center on composition
   */
  resetOrbit() {
    this.target.set(this.width / 2, -this.height / 2, 0);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    this.spherical.radius = this.height / 2 / Math.tan(fovRad / 2);
    this.spherical.theta = 0;
    this.spherical.phi = Math.PI / 2;
    if (this.orbitEnabled) {
      this.updateCameraFromSpherical();
    } else {
      this.reset();
    }
  }
  // ============================================================================
  // FOCUS & FRAMING
  // ============================================================================
  /**
   * Focus camera on a bounding box, framing it in view
   * @param bounds - { min: {x, y, z}, max: {x, y, z} }
   */
  focusOnBounds(bounds) {
    const center = new Vector3(
      (bounds.min.x + bounds.max.x) / 2,
      -(bounds.min.y + bounds.max.y) / 2,
      // Negate for screen coords
      (bounds.min.z + bounds.max.z) / 2
    );
    const size = new Vector3(
      bounds.max.x - bounds.min.x,
      bounds.max.y - bounds.min.y,
      bounds.max.z - bounds.min.z
    );
    const maxDim = Math.max(size.x, size.y, size.z);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = maxDim / 2 / Math.tan(fovRad / 2) * 1.5;
    this.target.copy(center);
    if (this.orbitEnabled) {
      this.spherical.radius = distance;
      this.updateCameraFromSpherical();
    } else {
      this.camera.position.set(center.x, center.y, center.z + distance);
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
  }
  /**
   * Focus on a layer by its bounding rect
   * @param x - Layer X position
   * @param y - Layer Y position
   * @param width - Layer width
   * @param height - Layer height
   * @param z - Layer Z position (default 0)
   */
  focusOnLayer(x, y, width, height, z = 0) {
    this.focusOnBounds({
      min: { x, y, z: z - 10 },
      max: { x: x + width, y: y + height, z: z + 10 }
    });
  }
  // ============================================================================
  // CAMERA BOOKMARKS
  // ============================================================================
  /** Stored camera bookmarks */
  bookmarks = /* @__PURE__ */ new Map();
  /**
   * Save current camera state as a bookmark
   * @param name - Name for the bookmark
   */
  saveBookmark(name) {
    this.bookmarks.set(name, {
      position: this.camera.position.clone(),
      target: this.target.clone(),
      spherical: { ...this.spherical },
      fov: this.camera.fov,
      orbitEnabled: this.orbitEnabled
    });
  }
  /**
   * Load a saved camera bookmark
   * @param name - Name of the bookmark
   * @param animate - Whether to animate transition
   */
  loadBookmark(name, animate = false) {
    const bookmark = this.bookmarks.get(name);
    if (!bookmark) return false;
    if (animate) {
      const startPos = this.camera.position.clone();
      const startTarget = this.target.clone();
      const startFov = this.camera.fov;
      const duration = 500;
      const startTime = performance.now();
      const animateBookmark = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.camera.position.lerpVectors(startPos, bookmark.position, eased);
        this.target.lerpVectors(startTarget, bookmark.target, eased);
        this.camera.fov = startFov + (bookmark.fov - startFov) * eased;
        this.camera.lookAt(this.target);
        this.camera.updateProjectionMatrix();
        if (t < 1) {
          requestAnimationFrame(animateBookmark);
        } else {
          this.spherical = { ...bookmark.spherical };
          this.orbitEnabled = bookmark.orbitEnabled;
        }
      };
      requestAnimationFrame(animateBookmark);
    } else {
      this.camera.position.copy(bookmark.position);
      this.target.copy(bookmark.target);
      this.camera.fov = bookmark.fov;
      this.spherical = { ...bookmark.spherical };
      this.orbitEnabled = bookmark.orbitEnabled;
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
    return true;
  }
  /**
   * Delete a bookmark
   * @param name - Name of the bookmark
   */
  deleteBookmark(name) {
    return this.bookmarks.delete(name);
  }
  /**
   * Get list of bookmark names
   */
  getBookmarkNames() {
    return Array.from(this.bookmarks.keys());
  }
  /**
   * Export all bookmarks as JSON-serializable data
   */
  exportBookmarks() {
    const result = {};
    this.bookmarks.forEach((value, key) => {
      result[key] = {
        position: { x: value.position.x, y: value.position.y, z: value.position.z },
        target: { x: value.target.x, y: value.target.y, z: value.target.z },
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      };
    });
    return result;
  }
  /**
   * Import bookmarks from JSON data
   */
  importBookmarks(data) {
    Object.entries(data).forEach(([name, value]) => {
      this.bookmarks.set(name, {
        position: new Vector3(value.position.x, value.position.y, value.position.z),
        target: new Vector3(value.target.x, value.target.y, value.target.z),
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      });
    });
  }
}

class ResourceManager {
  // Texture cache (keyed by URL or ID)
  textures;
  // Geometry cache (keyed by type and parameters)
  geometries;
  // Material cache (keyed by configuration hash)
  materials;
  // Texture loader
  textureLoader;
  // Asset getter callback (set by WeylEngine)
  assetGetter;
  // Statistics
  stats = {
    texturesLoaded: 0,
    texturesFromCache: 0,
    geometriesCreated: 0,
    geometriesFromCache: 0
  };
  constructor() {
    this.textures = /* @__PURE__ */ new Map();
    this.geometries = /* @__PURE__ */ new Map();
    this.materials = /* @__PURE__ */ new Map();
    this.textureLoader = new TextureLoader();
    this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(assetId) {
    return this.assetGetter?.(assetId);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const plane = new PlaneGeometry(1, 1, 1, 1);
    this.geometries.set("plane:1:1", plane);
    const quad = new PlaneGeometry(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", quad);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(url, options) {
    const cacheKey = this.getTextureCacheKey(url, options);
    const cached = this.textures.get(cacheKey);
    if (cached) {
      this.stats.texturesFromCache++;
      return cached;
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.applyTextureOptions(texture, options);
          this.textures.set(cacheKey, texture);
          this.stats.texturesLoaded++;
          resolve(texture);
        },
        void 0,
        // Progress callback
        (error) => {
          renderLogger.error("ResourceManager: Failed to load texture:", url, error);
          reject(error);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(imageData, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof DataTexture) {
      cached.image = imageData;
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new DataTexture(
      imageData.data,
      imageData.width,
      imageData.height,
      RGBAFormat,
      UnsignedByteType
    );
    this.applyTextureOptions(texture, options);
    texture.needsUpdate = true;
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(canvas, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof CanvasTexture) {
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new CanvasTexture(canvas);
    this.applyTextureOptions(texture, options);
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Get a cached texture
   */
  getTexture(key) {
    return this.textures.get(key);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(texture, options) {
    if (!options) {
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.colorSpace = SRGBColorSpace;
      return;
    }
    if (options.wrapS !== void 0) texture.wrapS = options.wrapS;
    if (options.wrapT !== void 0) texture.wrapT = options.wrapT;
    if (options.minFilter !== void 0) texture.minFilter = options.minFilter;
    if (options.magFilter !== void 0) texture.magFilter = options.magFilter;
    if (options.generateMipmaps !== void 0) texture.generateMipmaps = options.generateMipmaps;
    if (options.flipY !== void 0) texture.flipY = options.flipY;
    if (options.colorSpace !== void 0) texture.colorSpace = options.colorSpace;
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(url, options) {
    if (!options) return url;
    return `${url}:${JSON.stringify(options)}`;
  }
  /**
   * Release a texture
   */
  releaseTexture(key) {
    const texture = this.textures.get(key);
    if (texture) {
      texture.dispose();
      this.textures.delete(key);
    }
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(layerId) {
    const layerKey = `layer:${layerId}`;
    const layerTexture = this.textures.get(layerKey);
    if (layerTexture) {
      return layerTexture;
    }
    return null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(layerId, texture) {
    const key = `layer:${layerId}`;
    this.textures.set(key, texture);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(width = 1, height = 1) {
    const key = `plane:${width}:${height}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new PlaneGeometry(width, height, 1, 1);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(radius = 1, segments = 32) {
    const key = `circle:${radius}:${segments}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new CircleGeometry(radius, segments);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(width = 1, height = 1, depth = 1) {
    const key = `box:${width}:${height}:${depth}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new BoxGeometry(width, height, depth);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(options) {
    const key = `basic:${JSON.stringify(options)}`;
    let material = this.materials.get(key);
    if (material) {
      return material;
    }
    material = new MeshBasicMaterial({
      color: options.color ?? 16777215,
      transparent: options.transparent ?? true,
      opacity: options.opacity ?? 1,
      map: options.map,
      side: options.side ?? DoubleSide
    });
    this.materials.set(key, material);
    return material;
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(type) {
    switch (type) {
      case "basic":
        return new MeshBasicMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "standard":
        return new MeshStandardMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "shader":
        return new ShaderMaterial();
      default:
        return new MeshBasicMaterial();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const texture of this.textures.values()) {
      texture.dispose();
    }
    this.textures.clear();
    for (const geometry of this.geometries.values()) {
      geometry.dispose();
    }
    this.geometries.clear();
    for (const material of this.materials.values()) {
      material.dispose();
    }
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    renderLogger.debug("ResourceManager: Resource stats:", this.getStats());
  }
}

class PerformanceMonitor {
  // Frame timing
  frameCount = 0;
  lastTime = 0;
  frameTimes = [];
  maxFrameTimes = 60;
  // FPS calculation
  fps = 0;
  fpsUpdateInterval = 500;
  // ms
  lastFpsUpdate = 0;
  framesInInterval = 0;
  // Frame start time (for measuring frame duration)
  frameStartTime = 0;
  // Last captured stats
  lastStats = {
    fps: 0,
    frameTime: 0,
    drawCalls: 0,
    triangles: 0,
    textures: 0,
    geometries: 0,
    memoryUsed: 0
  };
  constructor() {
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(renderer) {
    const now = performance.now();
    const frameTime = now - this.frameStartTime;
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxFrameTimes) {
      this.frameTimes.shift();
    }
    this.frameCount++;
    this.framesInInterval++;
    const timeSinceUpdate = now - this.lastFpsUpdate;
    if (timeSinceUpdate >= this.fpsUpdateInterval) {
      this.fps = Math.round(this.framesInInterval * 1e3 / timeSinceUpdate);
      this.framesInInterval = 0;
      this.lastFpsUpdate = now;
    }
    const info = renderer.info;
    const memory = performance.memory;
    const memoryUsed = memory?.usedJSHeapSize ?? 0;
    const avgFrameTime = this.frameTimes.length > 0 ? this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length : 0;
    this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(avgFrameTime * 100) / 100,
      drawCalls: info.render.calls,
      triangles: info.render.triangles,
      textures: info.memory.textures,
      geometries: info.memory.geometries,
      memoryUsed
    };
    this.lastTime = now;
    return this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    if (this.frameTimes.length === 0) return 0;
    return this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    if (this.frameTimes.length === 0) {
      return { min: 0, max: 0 };
    }
    return {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0;
    this.frameTimes = [];
    this.fps = 0;
    this.framesInInterval = 0;
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
    this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(targetFps = 30) {
    return this.fps > 0 && this.fps < targetFps;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const stats = this.lastStats;
    const range = this.getFrameTimeRange();
    return [
      `FPS: ${stats.fps}`,
      `Frame Time: ${stats.frameTime.toFixed(2)}ms (min: ${range.min.toFixed(2)}, max: ${range.max.toFixed(2)})`,
      `Draw Calls: ${stats.drawCalls}`,
      `Triangles: ${stats.triangles.toLocaleString()}`,
      `Textures: ${stats.textures}`,
      `Geometries: ${stats.geometries}`,
      `Memory: ${(stats.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join("\n");
  }
}

class WeylEngine {
  // Core subsystems
  scene;
  renderer;
  layers;
  camera;
  resources;
  performance;
  // State
  state;
  animationFrameId = null;
  // Background and overlay images
  backgroundImage = null;
  depthMapMesh = null;
  depthMapSettings = { colormap: "viridis", opacity: 0.5, visible: false };
  // Viewport transform for pan/zoom
  viewportTransform = [1, 0, 0, 1, 0, 0];
  // Render mode
  renderMode = "color";
  // Audio reactivity
  audioReactiveGetter = null;
  // Transform controls for layer manipulation
  transformControls = null;
  selectedLayerId = null;
  transformMode = "translate";
  // Transform change callback
  onTransformChange = null;
  // Event system
  eventHandlers;
  // Configuration
  config;
  constructor(config) {
    this.validateConfig(config);
    this.config = {
      canvas: config.canvas,
      width: config.width,
      height: config.height,
      compositionWidth: config.compositionWidth ?? config.width,
      compositionHeight: config.compositionHeight ?? config.height,
      pixelRatio: config.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      backgroundColor: config.backgroundColor ?? null,
      debug: config.debug ?? false,
      powerPreference: config.powerPreference ?? "high-performance"
    };
    this.state = {
      currentFrame: 0,
      // DEPRECATED: Use MotionEngine as time authority
      isRendering: false,
      isDisposed: false,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    };
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.resources = new ResourceManager();
    this.scene = new SceneManager(this.config.backgroundColor);
    this.camera = new CameraController(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.camera.setViewportAspect(this.config.width, this.config.height);
    this.renderer = new RenderPipeline({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera);
    this.layers = new LayerManager(this.scene, this.resources);
    this.performance = new PerformanceMonitor();
    this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.setupContextLossHandling();
    if (this.config.debug) {
      engineLogger.debug("Initialized", this.config);
    }
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(config) {
    if (!(config.canvas instanceof HTMLCanvasElement)) {
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    }
    if (config.width <= 0 || config.height <= 0) {
      throw new Error("WeylEngine requires positive width and height");
    }
    if (config.width > 8192 || config.height > 8192) {
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
    }
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(layerData) {
    this.assertNotDisposed();
    this.layers.create(layerData);
    this.emit("layerAdded", { layerId: layerData.id });
    if (this.config.debug) {
      engineLogger.debug("Layer added:", layerData.id, layerData.type);
    }
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(layerId, properties) {
    this.assertNotDisposed();
    this.layers.update(layerId, properties);
    this.emit("layerUpdated", { layerId, properties });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(layerId) {
    this.assertNotDisposed();
    this.layers.remove(layerId);
    this.emit("layerRemoved", { layerId });
    if (this.config.debug) {
      engineLogger.debug("Layer removed:", layerId);
    }
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(layerId) {
    return this.layers.getObject(layerId);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(layers) {
    this.assertNotDisposed();
    const existingIds = new Set(this.layers.getLayerIds());
    const newIds = new Set(layers.map((l) => l.id));
    for (const id of existingIds) {
      if (!newIds.has(id)) {
        this.layers.remove(id);
      }
    }
    for (const layer of layers) {
      if (existingIds.has(layer.id)) {
        this.layers.update(layer.id, layer);
      } else {
        this.layers.create(layer);
      }
    }
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(getter) {
    this.resources.setAssetGetter(getter);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(callback) {
    this.layers.setVideoMetadataCallback(callback);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(context) {
    this.layers.setPrecompRenderContext(context);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.layers.setCameraCallbacks(getter, updater, atFrameGetter);
    this.activeCameraGetter = getter;
  }
  // Active camera tracking
  activeCameraGetter;
  activeCameraId = null;
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(cameraLayerId) {
    this.activeCameraId = cameraLayerId;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter) {
      return;
    }
    const cameraLayer = this.layers.getLayer(this.activeCameraId);
    if (!cameraLayer || cameraLayer.type !== "camera") {
      return;
    }
    const typedLayer = cameraLayer;
    const exportData = typedLayer.getExportData();
    if (!exportData) {
      return;
    }
    this.camera.setPosition(exportData.position.x, exportData.position.y, exportData.position.z);
    this.camera.setRotation(exportData.rotation.x, exportData.rotation.y, exportData.rotation.z);
    this.camera.setFOV(exportData.fov);
    this.camera.setClipPlanes(exportData.nearClip, exportData.farClip);
    const camera3d = typedLayer.getCameraAtCurrentFrame();
    if (camera3d && camera3d.depthOfField) {
      this.setDOFFromCamera(camera3d.depthOfField);
    }
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(fps) {
    this.layers.setCompositionFPS(fps);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer());
    this.layers.setCamera(this.camera.camera);
  }
  /**
   * Initialize all 3D services with WebGL renderer
   * This enables:
   * - Material system PMREM for environment map prefiltering
   * - Environment map support in SceneManager
   * Call this after engine construction for full 3D pipeline support
   */
  initialize3DServices() {
    const renderer = this.renderer.getWebGLRenderer();
    materialSystem.initialize(renderer);
    this.scene.initializeEnvironmentSupport(renderer);
    if (this.config.debug) {
      engineLogger.debug("3D services initialized");
    }
  }
  // ============================================================================
  // 3D SERVICE ACCESS
  // ============================================================================
  /**
   * Get the material system for PBR material management
   */
  getMaterialSystem() {
    return materialSystem;
  }
  /**
   * Get the SVG extrusion service for logo workflows
   */
  getSVGExtrusionService() {
    return svgExtrusionService;
  }
  /**
   * Get the mesh particle manager for custom particle shapes
   */
  getMeshParticleManager() {
    return meshParticleManager;
  }
  /**
   * Get the sprite sheet service for particle animations
   */
  getSpriteSheetService() {
    return spriteSheetService;
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const cam = this.camera.camera;
    return {
      projectionMatrix: cam.projectionMatrix.clone(),
      viewMatrix: cam.matrixWorldInverse.clone(),
      projectionMatrixInverse: cam.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    this.layers.setLayerDrivenValues(layerId, values);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    this.layers.clearLayerDrivenValues(layerId);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Apply a pre-evaluated FrameState from MotionEngine
   *
   * This is the CANONICAL way to update the rendering state.
   * FrameState is computed by MotionEngine.evaluate() which is PURE.
   *
   * ARCHITECTURAL RULE:
   * - Layers receive already-evaluated values via applyEvaluatedState()
   * - NO interpolation or time sampling happens here
   * - Single source of truth: MotionEngine
   *
   * @param frameState - Pre-evaluated state from MotionEngine.evaluate()
   */
  applyFrameState(frameState) {
    this.assertNotDisposed();
    this.state.currentFrame = frameState.frame;
    this.layers.applyEvaluatedState(frameState.layers, frameState.frame);
    if (frameState.camera) {
      this.applyCameraState(frameState.camera);
    } else {
      this.syncActiveCamera();
      if (!this.activeCameraId) {
        this.camera.evaluateFrame(frameState.frame);
      }
    }
  }
  /**
   * Apply evaluated camera state directly
   */
  applyCameraState(cameraState) {
    if (!cameraState) return;
    this.camera.setPositionDirect(
      cameraState.position.x,
      cameraState.position.y,
      cameraState.position.z
    );
    this.camera.setTargetDirect(
      cameraState.target.x,
      cameraState.target.y,
      cameraState.target.z
    );
    this.camera.setFOV(cameraState.fov);
  }
  /**
   * Set the current frame for animation evaluation
   *
   * @deprecated Use applyFrameState() with MotionEngine.evaluate() instead.
   * This method evaluates frames directly, bypassing the single time authority.
   * It is kept for backwards compatibility but should be phased out.
   *
   * @param frame - The frame number (0-indexed)
   */
  setFrame(frame) {
    this.assertNotDisposed();
    this.state.currentFrame = frame;
    this.layers.evaluateFrame(frame, this.audioReactiveGetter);
    this.syncActiveCamera();
    if (!this.activeCameraId) {
      this.camera.evaluateFrame(frame);
    }
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
    this.layers.setAudioReactiveCallback(getter);
  }
  /**
   * Get the current frame
   * @deprecated Frame authority is now MotionEngine. This returns cached value.
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed();
    this.performance.beginFrame();
    this.emit("frameStart", { frame: this.state.currentFrame });
    this.camera.updateOrbitControls();
    this.renderer.render();
    this.emit("frameEnd", { frame: this.state.currentFrame });
    this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    this.assertNotDisposed();
    if (this.animationFrameId !== null) {
      return;
    }
    this.state.isRendering = true;
    const loop = () => {
      if (!this.state.isRendering || this.state.isDisposed) {
        return;
      }
      this.render();
      this.animationFrameId = requestAnimationFrame(loop);
    };
    this.animationFrameId = requestAnimationFrame(loop);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = false;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(width, height, compositionWidth, compositionHeight) {
    this.assertNotDisposed();
    if (width <= 0 || height <= 0) {
      engineLogger.warn("Invalid resize dimensions:", width, height);
      return;
    }
    console.log(`[WeylEngine] resize: viewport=${width}x${height}, comp=${compositionWidth ?? "undefined"}x${compositionHeight ?? "undefined"}`);
    this.state.viewport = { width, height };
    this.renderer.resize(width, height);
    if (compositionWidth !== void 0 && compositionHeight !== void 0) {
      this.camera.resize(compositionWidth, compositionHeight);
    }
    this.camera.setViewportAspect(width, height);
    this.emit("resize", { width, height, compositionWidth, compositionHeight });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Enable 3D orbit controls for camera navigation
   * Right-click = orbit, middle-click = pan, scroll = dolly
   */
  enableOrbitControls() {
    const domElement = this.renderer.getDomElement();
    this.camera.enableOrbitControls(domElement);
  }
  /**
   * Disable 3D orbit controls
   */
  disableOrbitControls() {
    this.camera.disableOrbitControls();
  }
  /**
   * Reset camera to default viewing position
   */
  resetCameraToDefault() {
    this.camera.resetToDefault();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the canonical method for centering the view on initial load
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitCompositionToViewport(padding = 40) {
    const { width, height } = this.state.viewport;
    this.camera.fitToViewport(width, height, padding);
  }
  /**
   * Check if orbit controls are enabled
   */
  hasOrbitControls() {
    return this.camera.hasOrbitControls();
  }
  /**
   * Set camera position
   */
  setCameraPosition(x, y, z) {
    this.camera.setPosition(x, y, z);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(x, y, z) {
    this.camera.setTarget(x, y, z);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(fov) {
    this.camera.setFOV(fov);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(dof) {
    this.renderer.setDOF({
      enabled: dof.enabled,
      focusDistance: dof.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: dof.aperture * 1e-4,
      maxBlur: dof.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(enabled) {
    this.renderer.setDOFEnabled(enabled);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(distance) {
    this.renderer.setFocusDistance(distance);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(aperture) {
    this.renderer.setAperture(aperture * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   * @param config - SSAO configuration options
   */
  setSSAO(config) {
    this.renderer.setSSAO(config);
  }
  /**
   * Enable or disable SSAO
   */
  setSSAOEnabled(enabled) {
    this.renderer.setSSAOEnabled(enabled);
  }
  /**
   * Set SSAO intensity
   * @param intensity - Occlusion intensity multiplier
   */
  setSSAOIntensity(intensity) {
    this.renderer.setSSAOIntensity(intensity);
  }
  /**
   * Set SSAO sampling radius
   * @param radius - Kernel radius for occlusion sampling
   */
  setSSAORadius(radius) {
    this.renderer.setSSAORadius(radius);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return this.renderer.getSSAO();
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, bright particles) glow
   * @param config - Bloom configuration options
   */
  setBloom(config) {
    this.renderer.setBloom(config);
  }
  /**
   * Enable or disable bloom
   */
  setBloomEnabled(enabled) {
    this.renderer.setBloomEnabled(enabled);
  }
  /**
   * Set bloom intensity
   * @param strength - Bloom strength multiplier
   */
  setBloomStrength(strength) {
    this.renderer.setBloomStrength(strength);
  }
  /**
   * Set bloom threshold
   * @param threshold - Brightness threshold for bloom (0-1)
   */
  setBloomThreshold(threshold) {
    this.renderer.setBloomThreshold(threshold);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return this.renderer.getBloom();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(transform) {
    this.viewportTransform = [...transform];
    const scale = transform[0];
    const tx = transform[4];
    const ty = transform[5];
    this.camera.setZoom(scale);
    this.camera.setPan(tx, ty);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(image) {
    this.assertNotDisposed();
    if (this.backgroundImage) {
      this.scene.removeFromComposition(this.backgroundImage);
      this.backgroundImage.geometry.dispose();
      this.backgroundImage.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    texture.colorSpace = SRGBColorSpace;
    const geometry = new PlaneGeometry(image.width, image.height);
    const material = new MeshBasicMaterial({
      map: texture,
      transparent: true,
      depthWrite: false
    });
    this.backgroundImage = new Mesh(geometry, material);
    this.backgroundImage.position.set(image.width / 2, image.height / 2, -1e3);
    this.backgroundImage.userData.isBackground = true;
    this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(image, options) {
    this.assertNotDisposed();
    this.depthMapSettings = {
      colormap: options.colormap ?? this.depthMapSettings.colormap,
      opacity: options.opacity ?? this.depthMapSettings.opacity,
      visible: options.visible ?? this.depthMapSettings.visible
    };
    if (this.depthMapMesh) {
      this.scene.removeFromComposition(this.depthMapMesh);
      this.depthMapMesh.geometry.dispose();
      this.depthMapMesh.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    const material = this.createColormapMaterial(texture, this.depthMapSettings);
    const geometry = new PlaneGeometry(image.width, image.height);
    this.depthMapMesh = new Mesh(geometry, material);
    this.depthMapMesh.position.set(image.width / 2, image.height / 2, -999);
    this.depthMapMesh.visible = this.depthMapSettings.visible;
    this.depthMapMesh.userData.isDepthOverlay = true;
    this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(texture, settings) {
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `;
    const colormapIndex = settings.colormap === "viridis" ? 0 : settings.colormap === "plasma" ? 1 : 2;
    return new ShaderMaterial({
      uniforms: {
        depthMap: { value: texture },
        opacity: { value: settings.opacity },
        colormap: { value: colormapIndex }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(visible) {
    this.depthMapSettings.visible = visible;
    if (this.depthMapMesh) {
      this.depthMapMesh.visible = visible;
    }
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(colormap) {
    this.depthMapSettings.colormap = colormap;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      const colormapIndex = colormap === "viridis" ? 0 : colormap === "plasma" ? 1 : 2;
      material.uniforms.colormap.value = colormapIndex;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(opacity) {
    this.depthMapSettings.opacity = opacity;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      material.uniforms.opacity.value = opacity;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    this.renderer.setRenderMode(mode);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize environment map support
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport() {
    this.scene.initializeEnvironmentSupport(this.renderer.getWebGLRenderer());
  }
  /**
   * Load and set an environment map from URL
   * Supports HDR, EXR, and standard image formats
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    this.initializeEnvironmentSupport();
    return this.scene.loadEnvironmentMap(url, config);
  }
  /**
   * Set environment map configuration
   * @param config - Partial configuration to update
   */
  setEnvironmentConfig(config) {
    this.scene.setEnvironmentConfig(config);
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return this.scene.getEnvironmentConfig();
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.scene.setEnvironmentEnabled(enabled);
  }
  /**
   * Set environment map intensity
   * @param intensity - Intensity multiplier (0-2 typical range)
   */
  setEnvironmentIntensity(intensity) {
    this.scene.setEnvironmentIntensity(intensity);
  }
  /**
   * Set environment map rotation
   * @param degrees - Y-axis rotation in degrees
   */
  setEnvironmentRotation(degrees) {
    this.scene.setEnvironmentRotation(degrees);
  }
  /**
   * Set background blur amount for HDRI background
   * @param blur - Blur amount (0-1)
   */
  setEnvironmentBackgroundBlur(blur) {
    this.scene.setBackgroundBlur(blur);
  }
  /**
   * Toggle whether to use HDRI as scene background
   */
  setEnvironmentAsBackground(use) {
    this.scene.setUseAsBackground(use);
  }
  /**
   * Get the current environment map texture
   */
  getEnvironmentMap() {
    return this.scene.getEnvironmentMap();
  }
  // ============================================================================
  // COMPOSITION GUIDES
  // ============================================================================
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    this.scene.setCompositionGridVisible(visible);
  }
  /**
   * Show/hide dark overlay outside composition
   */
  setOutsideOverlayVisible(visible) {
    this.scene.setOutsideOverlayVisible(visible);
  }
  /**
   * Show/hide composition bounds frame
   */
  setCompositionBoundsVisible(visible) {
    this.scene.setCompositionBoundsVisible(visible);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(x, y) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, this.camera.getCamera());
    const intersects = this.scene.raycastComposition(raycaster);
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          return obj.userData.layerId;
        }
        if (obj.userData.isBackground || obj.userData.isDepthOverlay) {
          break;
        }
        obj = obj.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    this.assertNotDisposed();
    if (this.transformControls) {
      return;
    }
    const camera = this.camera.getCamera();
    const domElement = this.renderer.getDomElement();
    this.transformControls = new TransformControls(camera, domElement);
    this.transformControls.setMode(this.transformMode);
    this.transformControls.setSpace("world");
    this.transformControls.setSize(1);
    this.scene.addUIElement(this.transformControls);
    this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const object = this.transformControls.object;
      if (!object) return;
      const transform = {
        position: {
          x: object.position.x,
          y: object.position.y,
          z: object.position.z
        },
        rotationX: MathUtils.radToDeg(object.rotation.x),
        rotationY: MathUtils.radToDeg(object.rotation.y),
        rotationZ: MathUtils.radToDeg(object.rotation.z),
        scale: {
          x: object.scale.x * 100,
          // Convert back to percentage
          y: object.scale.y * 100,
          z: object.scale.z * 100
        }
      };
      transform.rotation = transform.rotationZ;
      if (this.onTransformChange) {
        this.onTransformChange(this.selectedLayerId, transform);
      }
    });
    this.transformControls.addEventListener("dragging-changed", (event) => {
      this.emit("transform-dragging", { dragging: event.value });
    });
    this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(callback) {
    this.onTransformChange = callback;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(layerId) {
    this.assertNotDisposed();
    if (!this.transformControls) {
      this.initializeTransformControls();
    }
    if (this.selectedLayerId && this.transformControls) {
      this.transformControls.detach();
    }
    this.selectedLayerId = layerId;
    if (!layerId || !this.transformControls) {
      return;
    }
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      this.transformControls.attach(layerObject);
    }
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(mode) {
    this.transformMode = mode;
    if (this.transformControls) {
      this.transformControls.setMode(mode);
    }
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(visible) {
    if (this.transformControls) {
      this.transformControls.visible = visible;
      this.transformControls.enabled = visible;
    }
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    return this.transformControls?.dragging ?? false;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const imageData = this.renderer.captureFrame();
    return {
      imageData,
      width: imageData.width,
      height: imageData.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(format = "png", quality = 0.95) {
    this.assertNotDisposed();
    const { imageData, width, height } = this.captureFrame();
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: `image/${format}`,
      quality
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const depthBuffer = this.renderer.captureDepth();
    const cameraState = this.camera.getState();
    return {
      depthBuffer,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: cameraState.near,
      far: cameraState.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(type, handler) {
    if (!this.eventHandlers.has(type)) {
      this.eventHandlers.set(type, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(type).add(handler);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(type, handler) {
    this.eventHandlers.get(type)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => {
      try {
        handler(event);
      } catch (error) {
        engineLogger.error(`Event handler error for ${type}:`, error);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const canvas = this.config.canvas;
    canvas.addEventListener("webglcontextlost", (event) => {
      event.preventDefault();
      this.stopRenderLoop();
      this.emit("contextLost", null);
      engineLogger.warn("WebGL context lost");
    });
    canvas.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null);
      engineLogger.info("WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed) {
      throw new Error("WeylEngine has been disposed");
    }
  }
  // ============================================================================
  // PRECOMP RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of layer managers for precomp compositions */
  precompLayerManagers = /* @__PURE__ */ new Map();
  /** Cache of scenes for precomp compositions */
  precompScenes = /* @__PURE__ */ new Map();
  /** Cache of last rendered frame per composition (for texture caching) */
  precompLastFrame = /* @__PURE__ */ new Map();
  /**
   * Render a composition to a texture
   * Used by PrecompLayer to render nested compositions
   *
   * @param compositionId - The composition ID to render
   * @param layers - The layers in that composition
   * @param settings - Composition settings (width, height, fps)
   * @param frame - The frame to render
   * @returns The rendered texture, or null if rendering fails
   */
  renderCompositionToTexture(compositionId, layers, settings, frame) {
    this.assertNotDisposed();
    try {
      const lastFrame = this.precompLastFrame.get(compositionId);
      const target = this.renderer.getPrecompRenderTarget(
        compositionId,
        settings.width,
        settings.height
      );
      if (lastFrame === frame) {
        return target.texture;
      }
      let precompScene = this.precompScenes.get(compositionId);
      if (!precompScene) {
        precompScene = new SceneManager(null);
        precompScene.setCompositionSize(settings.width, settings.height);
        this.precompScenes.set(compositionId, precompScene);
      }
      let precompLayers = this.precompLayerManagers.get(compositionId);
      if (!precompLayers) {
        precompLayers = new LayerManager(precompScene, this.resources);
        precompLayers.setRenderer(this.renderer.getWebGLRenderer());
        precompLayers.setCompositionFPS(settings.fps);
        precompLayers.setCamera(this.camera.camera);
        this.precompLayerManagers.set(compositionId, precompLayers);
      }
      const currentLayerIds = new Set(precompLayers.getLayerIds());
      const targetLayerIds = new Set(layers.map((l) => l.id));
      for (const id of currentLayerIds) {
        if (!targetLayerIds.has(id)) {
          precompLayers.remove(id);
        }
      }
      for (const layerData of layers) {
        if (currentLayerIds.has(layerData.id)) {
          precompLayers.update(layerData.id, layerData);
        } else {
          precompLayers.create(layerData);
        }
      }
      precompLayers.evaluateFrame(frame, this.audioReactiveGetter);
      const precompCamera = new OrthographicCamera(
        -settings.width / 2,
        settings.width / 2,
        settings.height / 2,
        -settings.height / 2,
        0.1,
        1e4
      );
      precompCamera.position.set(0, 0, 1e3);
      precompCamera.lookAt(0, 0, 0);
      const texture = this.renderer.renderSceneToTexture(
        precompScene.scene,
        precompCamera,
        target
      );
      this.precompLastFrame.set(compositionId, frame);
      return texture;
    } catch (error) {
      engineLogger.error("Failed to render composition to texture:", compositionId, error);
      return null;
    }
  }
  /**
   * Clear precomp cache for a specific composition
   * Call when a composition is deleted or significantly changed
   */
  clearPrecompCache(compositionId) {
    const precompLayers = this.precompLayerManagers.get(compositionId);
    if (precompLayers) {
      precompLayers.dispose();
      this.precompLayerManagers.delete(compositionId);
    }
    const precompScene = this.precompScenes.get(compositionId);
    if (precompScene) {
      precompScene.dispose();
      this.precompScenes.delete(compositionId);
    }
    this.precompLastFrame.delete(compositionId);
    this.renderer.disposePrecompTarget(compositionId);
  }
  /**
   * Clear all precomp caches
   */
  clearAllPrecompCaches() {
    for (const [id] of this.precompLayerManagers) {
      this.clearPrecompCache(id);
    }
    this.renderer.disposeAllPrecompTargets();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    if (this.state.isDisposed) {
      return;
    }
    this.stopRenderLoop();
    this.clearAllPrecompCaches();
    this.layers.dispose();
    this.renderer.dispose();
    this.scene.dispose();
    this.resources.dispose();
    this.eventHandlers.clear();
    this.state.isDisposed = true;
    this.emit("dispose", null);
    if (this.config.debug) {
      engineLogger.debug("Disposed");
    }
  }
}

const _hoisted_1$c = { class: "spline-editor" };
const _hoisted_2$c = ["viewBox"];
const _hoisted_3$c = ["x1", "y1", "x2", "y2"];
const _hoisted_4$c = ["x1", "y1", "x2", "y2"];
const _hoisted_5$c = ["cx", "cy", "onMousedown"];
const _hoisted_6$c = ["cx", "cy", "onMousedown"];
const _hoisted_7$c = ["cx", "cy", "onMousedown"];
const _hoisted_8$c = ["cx", "cy"];
const _hoisted_9$b = ["cx", "cy"];
const CLOSE_THRESHOLD = 15;
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated", "pathClosed"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const selectedPointId = ref(null);
    const previewPoint = ref(null);
    const closePathPreview = ref(false);
    const dragTarget = ref(null);
    const visibleControlPoints = computed(() => {
      if (!props.layerId) return [];
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return [];
      const splineData = layer.data;
      return splineData.controlPoints || [];
    });
    const canClosePath = computed(() => {
      if (!props.layerId || visibleControlPoints.value.length < 3) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return false;
      const splineData = layer.data;
      return !splineData.closed;
    });
    function screenToCanvas(screenX, screenY) {
      const vt = props.viewportTransform;
      const x = (screenX - vt[4]) / vt[0];
      const y = (screenY - vt[5]) / vt[3];
      return { x, y };
    }
    function getMousePos(event) {
      const svg = event.currentTarget;
      const rect = svg.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;
      return screenToCanvas(screenX, screenY);
    }
    function handleMouseDown(event) {
      if (!props.isPenMode) return;
      const pos = getMousePos(event);
      if (props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && layer.type === "spline") {
          const newPoint = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: pos.x,
            y: pos.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          store.addSplineControlPoint(props.layerId, newPoint);
          selectedPointId.value = newPoint.id;
          dragTarget.value = {
            type: "handleOut",
            pointId: newPoint.id,
            startX: pos.x,
            startY: pos.y
          };
          emit("pointAdded", newPoint);
          emit("pathUpdated");
        }
      }
    }
    function handleMouseMove(event) {
      const pos = getMousePos(event);
      if (props.isPenMode) {
        previewPoint.value = pos;
      }
      if (canClosePath.value && visibleControlPoints.value.length > 0) {
        const firstPoint = visibleControlPoints.value[0];
        const dx = pos.x - firstPoint.x;
        const dy = pos.y - firstPoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        closePathPreview.value = dist < CLOSE_THRESHOLD;
      } else {
        closePathPreview.value = false;
      }
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (!layer || layer.type !== "spline") return;
        const splineData = layer.data;
        const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
        if (!point) return;
        if (dragTarget.value.type === "point") {
          const dx = pos.x - point.x;
          const dy = pos.y - point.y;
          const updates = { x: pos.x, y: pos.y };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + dx, y: point.handleIn.y + dy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + dx, y: point.handleOut.y + dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, pos.x, pos.y);
        } else if (dragTarget.value.type === "handleIn") {
          const updates = { handleIn: { x: pos.x, y: pos.y } };
          if (point.type === "smooth") {
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            updates.handleOut = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "in", pos.x, pos.y);
        } else if (dragTarget.value.type === "handleOut") {
          const updates = { handleOut: { x: pos.x, y: pos.y } };
          if (point.type === "smooth") {
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            updates.handleIn = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "out", pos.x, pos.y);
        }
        emit("pathUpdated");
      }
    }
    function handleMouseUp() {
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && layer.type === "spline") {
          const splineData = layer.data;
          const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
          if (point && point.handleOut) {
            const dx = point.handleOut.x - point.x;
            const dy = point.handleOut.y - point.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) {
              store.updateSplineControlPoint(props.layerId, point.id, {
                type: "smooth",
                handleIn: { x: point.x - dx, y: point.y - dy }
              });
            } else {
              store.updateSplineControlPoint(props.layerId, point.id, {
                handleOut: null
              });
            }
          }
        }
        dragTarget.value = null;
        emit("pathUpdated");
      }
    }
    function handleRightClick(event) {
      event.preventDefault();
      event.stopPropagation();
      if (!props.layerId || !canClosePath.value) return;
      const pos = getMousePos(event);
      if (visibleControlPoints.value.length > 0) {
        const firstPoint = visibleControlPoints.value[0];
        const dx = pos.x - firstPoint.x;
        const dy = pos.y - firstPoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < CLOSE_THRESHOLD) {
          closePath();
          return;
        }
      }
      if (props.isPenMode && visibleControlPoints.value.length >= 3) {
        closePath();
      }
    }
    function closePath() {
      if (!props.layerId) return;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return;
      store.updateLayerData(props.layerId, { closed: true });
      emit("pathClosed");
      emit("pathUpdated");
    }
    function startDragPoint(pointId, event) {
      selectedPointId.value = pointId;
      if (!props.isPenMode) {
        const pos = getMousePos(event);
        dragTarget.value = {
          type: "point",
          pointId,
          startX: pos.x,
          startY: pos.y
        };
      }
    }
    function startDragHandle(pointId, handleType, event) {
      const pos = getMousePos(event);
      dragTarget.value = {
        type: handleType === "in" ? "handleIn" : "handleOut",
        pointId,
        startX: pos.x,
        startY: pos.y
      };
    }
    function handleKeyDown(event) {
      if (event.key === "Delete" || event.key === "Backspace") {
        if (selectedPointId.value && props.layerId) {
          const layer = store.layers.find((l) => l.id === props.layerId);
          if (layer && layer.type === "spline") {
            const pointId = selectedPointId.value;
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
          }
        }
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    __expose({
      selectedPointId,
      clearSelection: () => {
        selectedPointId.value = null;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        (openBlock(), createElementBlock("svg", {
          class: "control-overlay",
          viewBox: `0 0 ${__props.canvasWidth} ${__props.canvasHeight}`,
          onMousedown: handleMouseDown,
          onMousemove: handleMouseMove,
          onMouseup: handleMouseUp,
          onMouseleave: handleMouseUp,
          onContextmenu: handleRightClick
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handles-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 0,
                x1: point.x,
                y1: point.y,
                x2: point.handleIn.x,
                y2: point.handleIn.y,
                class: "handle-line"
              }, null, 8, _hoisted_3$c)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 1,
                x1: point.x,
                y1: point.y,
                x2: point.handleOut.x,
                y2: point.handleOut.y,
                class: "handle-line"
              }, null, 8, _hoisted_4$c)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handle-points-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.handleIn.x,
                cy: point.handleIn.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleIn" && dragTarget.value.pointId === point.id }]),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "in", $event), ["stop"])
              }, null, 42, _hoisted_5$c)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 1,
                cx: point.handleOut.x,
                cy: point.handleOut.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleOut" && dragTarget.value.pointId === point.id }]),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "out", $event), ["stop"])
              }, null, 42, _hoisted_6$c)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock("circle", {
              key: `point-${point.id}`,
              cx: point.x,
              cy: point.y,
              r: "6",
              class: normalizeClass(["control-point", {
                selected: selectedPointId.value === point.id,
                corner: point.type === "corner",
                smooth: point.type === "smooth"
              }]),
              onMousedown: withModifiers(($event) => startDragPoint(point.id, $event), ["stop"])
            }, null, 42, _hoisted_7$c);
          }), 128)),
          previewPoint.value && __props.isPenMode ? (openBlock(), createElementBlock("circle", {
            key: 0,
            cx: previewPoint.value.x,
            cy: previewPoint.value.y,
            r: "4",
            class: "preview-point"
          }, null, 8, _hoisted_8$c)) : createCommentVNode("", true),
          canClosePath.value && closePathPreview.value ? (openBlock(), createElementBlock("circle", {
            key: 1,
            cx: visibleControlPoints.value[0].x,
            cy: visibleControlPoints.value[0].y,
            r: "10",
            class: "close-indicator"
          }, null, 8, _hoisted_9$b)) : createCommentVNode("", true)
        ], 40, _hoisted_2$c))
      ]);
    };
  }
});

const SplineEditor = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-20914073"]]);

const _hoisted_1$b = {
  key: 1,
  class: "overlay-controls"
};
const _hoisted_2$b = { class: "render-mode-controls" };
const _hoisted_3$b = {
  key: 2,
  class: "transform-mode-controls"
};
const _hoisted_4$b = {
  key: 3,
  class: "performance-overlay"
};
const _hoisted_5$b = {
  key: 4,
  class: "loading-overlay"
};
const _hoisted_6$b = ["src"];
const _hoisted_7$b = {
  key: 7,
  class: "segment-loading"
};
const _hoisted_8$b = {
  key: 8,
  class: "safe-frame-container"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "ThreeCanvas",
  setup(__props, { expose: __expose }) {
    const store = useCompositorStore();
    const containerRef = ref(null);
    const canvasRef = ref(null);
    const splineEditorRef = ref(null);
    const engine = shallowRef(null);
    const loading = ref(false);
    const zoom = ref(1);
    const canvasWidth = ref(800);
    const canvasHeight = ref(600);
    const showDepthOverlay = ref(false);
    const depthColormap = ref("viridis");
    const depthOpacity = ref(50);
    const renderMode = ref("color");
    const showPerformance = ref(false);
    const performanceStats = ref({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    const viewportTransform = ref([1, 0, 0, 1, 0, 0]);
    const transformMode = ref("translate");
    const showGrid = ref(true);
    const showOutsideOverlay = ref(false);
    const showSafeFrameGuides = ref(false);
    const isDrawingSegmentBox = ref(false);
    const segmentBoxEnd = ref(null);
    const maskOverlayStyle = computed(() => {
      const mask = store.segmentPendingMask;
      if (!mask) return {};
      const vpt = viewportTransform.value;
      const screenX = mask.bounds.x * vpt[0] + vpt[4];
      const screenY = mask.bounds.y * vpt[3] + vpt[5];
      const screenWidth = mask.bounds.width * vpt[0];
      const screenHeight = mask.bounds.height * vpt[3];
      return {
        left: `${screenX}px`,
        top: `${screenY}px`,
        width: `${screenWidth}px`,
        height: `${screenHeight}px`
      };
    });
    const segmentBoxStyle = computed(() => {
      const start = store.segmentBoxStart;
      const end = segmentBoxEnd.value;
      if (!start || !end) return {};
      const vpt = viewportTransform.value;
      const x1 = start.x * vpt[0] + vpt[4];
      const y1 = start.y * vpt[3] + vpt[5];
      const x2 = end.x * vpt[0] + vpt[4];
      const y2 = end.y * vpt[3] + vpt[5];
      return {
        left: `${Math.min(x1, x2)}px`,
        top: `${Math.min(y1, y2)}px`,
        width: `${Math.abs(x2 - x1)}px`,
        height: `${Math.abs(y2 - y1)}px`
      };
    });
    const safeFrameBounds = computed(() => {
      if (!containerRef.value || !engine.value) {
        return { left: 0, top: 0, right: 0, bottom: 0 };
      }
      const container = containerRef.value;
      const containerRect = container.getBoundingClientRect();
      const compWidth = store.width || 1920;
      const compHeight = store.height || 1080;
      const camera = engine.value.getCameraController().camera;
      const topLeft = new Vector3(0, 0, 0);
      const bottomRight = new Vector3(compWidth, -compHeight, 0);
      topLeft.project(camera);
      bottomRight.project(camera);
      const left = (topLeft.x + 1) / 2 * containerRect.width;
      const top = (-topLeft.y + 1) / 2 * containerRect.height;
      const right = (bottomRight.x + 1) / 2 * containerRect.width;
      const bottom = (-bottomRight.y + 1) / 2 * containerRect.height;
      return { left, top, right, bottom };
    });
    const safeFrameLeftStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: "0",
        top: "0",
        width: `${Math.max(0, bounds.left)}px`,
        height: "100%"
      };
    });
    const safeFrameRightStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${bounds.right}px`,
        top: "0",
        width: `calc(100% - ${bounds.right}px)`,
        height: "100%"
      };
    });
    const safeFrameTopStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: "0",
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `${Math.max(0, bounds.top)}px`
      };
    });
    const safeFrameBottomStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: `${bounds.bottom}px`,
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `calc(100% - ${bounds.bottom}px)`
      };
    });
    const hasDepthMap = computed(() => store.depthMap !== null);
    const isPenMode = computed(() => store.currentTool === "pen");
    const activeSplineLayerId = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "spline") {
        return selectedLayer.id;
      }
      if (isPenMode.value) {
        const splines = store.layers.filter((l) => l.type === "spline");
        return splines.length > 0 ? splines[splines.length - 1].id : null;
      }
      return null;
    });
    const viewportTransformArray = computed(() => viewportTransform.value);
    onMounted(async () => {
      if (!canvasRef.value || !containerRef.value) return;
      const container = containerRef.value;
      const rect = container.getBoundingClientRect();
      canvasWidth.value = rect.width;
      canvasHeight.value = rect.height;
      const config = {
        canvas: canvasRef.value,
        width: rect.width,
        height: rect.height,
        compositionWidth: store.width || 1920,
        compositionHeight: store.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      };
      try {
        loading.value = true;
        engine.value = new WeylEngine(config);
        engine.value.setAssetGetter((assetId) => store.assets[assetId]);
        engine.value.setVideoMetadataCallback((layerId, metadata) => {
          store.onVideoMetadataLoaded(layerId, metadata);
        });
        engine.value.setCameraCallbacks(
          (cameraId) => store.getCamera(cameraId),
          (cameraId, updates) => store.updateCamera(cameraId, updates),
          (cameraId, frame) => store.getCameraAtFrame(cameraId, frame)
        );
        engine.value.setPrecompRenderContext({
          renderComposition: (compositionId, frame) => {
            const comp = store.getComposition(compositionId);
            if (!comp) {
              console.warn("[ThreeCanvas] Precomp composition not found:", compositionId);
              return null;
            }
            if (!comp.layers || comp.layers.length === 0) {
              return null;
            }
            return engine.value.renderCompositionToTexture(
              compositionId,
              comp.layers,
              {
                width: comp.settings.width,
                height: comp.settings.height,
                fps: comp.settings.fps
              },
              frame
            );
          },
          getComposition: (compositionId) => store.getComposition(compositionId)
        });
        engine.value.setAudioReactiveCallback(
          (layerId, frame) => store.getAudioReactiveValuesForLayer(layerId, frame)
        );
        engine.value.initializeTransformControls();
        engine.value.setTransformChangeCallback((layerId, transform) => {
          handleTransformChange(layerId, transform);
        });
        engine.value.initializeParticleSystems();
        engine.value.setCompositionFPS(store.fps || 60);
        engine.value.initialize3DServices();
        engine.value.resetCameraToDefault();
        engine.value.start();
        await nextTick();
        syncLayersToEngine();
        store.initializePropertyDriverSystem();
        const initialFrameState = store.getFrameState(store.currentFrame);
        engine.value.applyFrameState(initialFrameState);
        setupInputHandlers();
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(container);
        centerOnComposition();
      } catch (err) {
        console.error("[ThreeCanvas] Failed to initialize engine:", err);
      } finally {
        loading.value = false;
      }
      setupWatchers();
    });
    onUnmounted(() => {
      if (engine.value) {
        engine.value.stop();
        engine.value.dispose();
        engine.value = null;
      }
    });
    function setupWatchers() {
      watch(
        () => store.layers,
        () => {
          syncLayersToEngine();
          if (engine.value) {
            const frameState = store.getFrameState(store.currentFrame);
            engine.value.applyFrameState(frameState);
          }
        },
        { deep: true }
      );
      watch(
        () => store.currentFrame,
        (frame) => {
          if (engine.value) {
            applyPropertyDrivers();
            const frameState = store.getFrameState(frame);
            engine.value.applyFrameState(frameState);
          }
        }
      );
      watch(
        () => [store.width, store.height],
        ([width, height]) => {
          if (engine.value) {
            engine.value.resize(canvasWidth.value, canvasHeight.value, width, height);
            centerOnComposition();
          }
        }
      );
      watch(
        () => store.sourceImage,
        async (imageData) => {
          if (engine.value && imageData) {
            await loadSourceImage(imageData);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.depthMap,
        async (depthData) => {
          if (engine.value && depthData) {
            await loadDepthMap(depthData);
          }
        },
        { immediate: true }
      );
      watch(
        () => engine.value?.getPerformanceStats(),
        (stats) => {
          if (stats) {
            performanceStats.value = stats;
          }
        }
      );
      watch(
        () => store.activeCameraId,
        (activeCameraId) => {
          if (!engine.value) return;
          if (!activeCameraId) {
            engine.value.setActiveCameraLayer(null);
            return;
          }
          const cameraLayer = store.layers.find(
            (l) => l.type === "camera" && l.data?.cameraId === activeCameraId
          );
          if (cameraLayer) {
            engine.value.setActiveCameraLayer(cameraLayer.id);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.selectedLayerIds,
        (selectedIds) => {
          if (!engine.value) return;
          const selectedId = selectedIds.length > 0 ? selectedIds[0] : null;
          engine.value.selectLayer(selectedId);
        },
        { deep: true }
      );
    }
    function syncLayersToEngine() {
      if (!engine.value) return;
      const engineLayerIds = new Set(engine.value.getLayerIds());
      const storeLayerIds = new Set(store.layers.map((l) => l.id));
      for (const id of engineLayerIds) {
        if (!storeLayerIds.has(id)) {
          engine.value.removeLayer(id);
        }
      }
      for (const layer of store.layers) {
        if (engineLayerIds.has(layer.id)) {
          engine.value.updateLayer(layer.id, layer);
        } else {
          engine.value.addLayer(layer);
        }
      }
    }
    function applyPropertyDrivers() {
      if (!engine.value) return;
      engine.value.clearAllDrivenValues();
      for (const layer of store.layers) {
        const drivenValues = store.getDrivenValuesForLayer(layer.id);
        if (drivenValues.size > 0) {
          engine.value.setLayerDrivenValues(layer.id, drivenValues);
        }
      }
    }
    async function loadSourceImage(imageData) {
      if (!engine.value) return;
      try {
        loading.value = true;
        const img = await loadImage(imageData);
        engine.value.setBackgroundImage(img);
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load source image:", err);
      } finally {
        loading.value = false;
      }
    }
    async function loadDepthMap(depthData) {
      if (!engine.value) return;
      try {
        const img = await loadImage(depthData);
        engine.value.setDepthMap(img, {
          colormap: depthColormap.value,
          opacity: depthOpacity.value / 100,
          visible: showDepthOverlay.value
        });
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load depth map:", err);
      }
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
      });
    }
    function setupInputHandlers() {
      const container = containerRef.value;
      const canvas = canvasRef.value;
      if (!container || !canvas) return;
      let isPanning = false;
      let isZooming = false;
      let lastPosX = 0;
      let lastPosY = 0;
      let zoomStartY = 0;
      let zoomStartLevel = 1;
      container.addEventListener("mousedown", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("auxclick", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        let newZoom = zoom.value * (delta > 0 ? 0.9 : 1.1);
        newZoom = Math.min(Math.max(newZoom, 0.1), 10);
        zoom.value = newZoom;
        viewportTransform.value[0] = newZoom;
        viewportTransform.value[3] = newZoom;
        if (engine.value) {
          engine.value.getCameraController().setZoom(newZoom);
        }
      }, { passive: false });
      canvas.addEventListener("mousedown", (e) => {
        const currentTool = store.currentTool;
        if (e.button === 1 || currentTool === "hand" || e.button === 0 && e.altKey) {
          isPanning = true;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          canvas.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }
        if (currentTool === "zoom") {
          if (e.shiftKey) {
            const newZoom = Math.max(zoom.value * 0.7, 0.1);
            zoom.value = newZoom;
            viewportTransform.value[0] = newZoom;
            viewportTransform.value[3] = newZoom;
            if (engine.value) {
              engine.value.setViewportTransform(viewportTransform.value);
            }
          } else {
            isZooming = true;
            zoomStartY = e.clientY;
            zoomStartLevel = zoom.value;
          }
          return;
        }
        if (currentTool === "text") {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          const newLayer = store.createLayer("text");
          if (newLayer.transform?.position) {
            newLayer.transform.position.value = { x: scenePos.x, y: scenePos.y, z: 0 };
          }
          store.updateLayer(newLayer.id, {
            transform: {
              ...newLayer.transform,
              position: {
                ...newLayer.transform.position,
                value: { x: scenePos.x, y: scenePos.y, z: 0 }
              }
            }
          });
          store.selectLayer(newLayer.id);
          store.setTool("select");
          return;
        }
        if (currentTool === "segment" && e.button === 0) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          if (store.segmentMode === "point") {
            handleSegmentPoint(scenePos.x, scenePos.y);
          } else {
            store.setSegmentBoxStart({ x: scenePos.x, y: scenePos.y });
            segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
            isDrawingSegmentBox.value = true;
          }
          return;
        }
        if (currentTool === "select" && e.button === 0) {
          if (engine.value?.isTransformDragging()) {
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          if (engine.value) {
            const hitLayer = engine.value.raycastLayers(x, y);
            if (hitLayer) {
              store.selectLayer(hitLayer);
              engine.value.selectLayer(hitLayer);
            } else {
              store.clearSelection();
              engine.value.selectLayer(null);
            }
          }
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isPanning && engine.value) {
          const dx = e.clientX - lastPosX;
          const dy = e.clientY - lastPosY;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          const camera = engine.value.getCameraController();
          const currentPan = camera.getPan();
          const compHeight = store.height || 1080;
          const fovRad = Math.PI * camera.getFOV() / 180;
          const distance = compHeight / 2 / Math.tan(fovRad / 2) / zoom.value;
          const viewHeight = 2 * distance * Math.tan(fovRad / 2);
          const container2 = containerRef.value;
          if (container2) {
            const rect = container2.getBoundingClientRect();
            const worldPerPixel = viewHeight / rect.height;
            camera.setPan(
              currentPan.x - dx * worldPerPixel,
              currentPan.y - dy * worldPerPixel
              // Positive dy should move camera up (view shifts down)
            );
          }
          return;
        }
        if (isZooming && engine.value) {
          const dy = zoomStartY - e.clientY;
          const zoomFactor = 1 + dy * 0.01;
          const newZoom = Math.max(0.1, Math.min(10, zoomStartLevel * zoomFactor));
          zoom.value = newZoom;
          viewportTransform.value[0] = newZoom;
          viewportTransform.value[3] = newZoom;
          engine.value.getCameraController().setZoom(newZoom);
          return;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
          return;
        }
        const currentTool = store.currentTool;
        if (currentTool === "hand") canvas.style.cursor = "grab";
        else if (currentTool === "zoom") canvas.style.cursor = "zoom-in";
        else if (currentTool === "text") canvas.style.cursor = "text";
        else if (currentTool === "pen") canvas.style.cursor = "crosshair";
        else if (currentTool === "segment") canvas.style.cursor = "crosshair";
        else canvas.style.cursor = "default";
      });
      canvas.addEventListener("mouseup", (e) => {
        if (isPanning) {
          isPanning = false;
          canvas.style.cursor = store.currentTool === "hand" ? "grab" : "default";
        }
        if (isZooming) {
          isZooming = false;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart && segmentBoxEnd.value) {
          isDrawingSegmentBox.value = false;
          handleSegmentBox(
            store.segmentBoxStart.x,
            store.segmentBoxStart.y,
            segmentBoxEnd.value.x,
            segmentBoxEnd.value.y
          );
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
        isZooming = false;
        if (isDrawingSegmentBox.value) {
          isDrawingSegmentBox.value = false;
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
    }
    function screenToScene(screenX, screenY) {
      const vpt = viewportTransform.value;
      return {
        x: (screenX - vpt[4]) / vpt[0],
        y: (screenY - vpt[5]) / vpt[3]
      };
    }
    async function handleSegmentPoint(x, y) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      store.setSegmentLoading(true);
      try {
        const result = await segmentByPoint(store.sourceImage, { x, y });
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    async function handleSegmentBox(x1, y1, x2, y2) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      const box = [
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.max(x1, x2),
        Math.max(y1, y2)
      ];
      store.setSegmentLoading(true);
      try {
        const result = await segmentByBox(store.sourceImage, box);
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Box segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Box segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Box segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    function handleTransformChange(layerId, transform) {
      const layer = store.layers.find((l) => l.id === layerId);
      if (!layer) return;
      const updates = {};
      if (transform.position && layer.transform) {
        updates.transform = {
          ...layer.transform,
          position: {
            ...layer.transform.position,
            value: {
              x: transform.position.x,
              y: transform.position.y,
              z: transform.position.z ?? layer.transform.position?.value?.z ?? 0
            }
          }
        };
      }
      if (layer.threeD) {
        if (transform.rotationX !== void 0 || transform.rotationY !== void 0 || transform.rotationZ !== void 0) {
          if (!updates.transform && layer.transform) {
            updates.transform = { ...layer.transform };
          }
          if (updates.transform) {
            if (transform.rotationX !== void 0) {
              updates.transform.rotationX = { ...layer.transform.rotationX, value: transform.rotationX };
            }
            if (transform.rotationY !== void 0) {
              updates.transform.rotationY = { ...layer.transform.rotationY, value: transform.rotationY };
            }
            if (transform.rotationZ !== void 0) {
              updates.transform.rotationZ = { ...layer.transform.rotationZ, value: transform.rotationZ };
            }
          }
        }
      } else {
        if (transform.rotation !== void 0 && layer.transform) {
          if (!updates.transform) {
            updates.transform = { ...layer.transform };
          }
          updates.transform.rotation = { ...layer.transform.rotation, value: transform.rotation };
        }
      }
      if (transform.scale && layer.transform) {
        if (!updates.transform) {
          updates.transform = { ...layer.transform };
        }
        updates.transform.scale = {
          ...layer.transform.scale,
          value: {
            x: transform.scale.x,
            y: transform.scale.y,
            z: transform.scale.z ?? layer.transform.scale?.value?.z ?? 100
          }
        };
      }
      if (Object.keys(updates).length > 0) {
        store.updateLayer(layerId, updates);
      }
    }
    function setTransformModeTo(mode) {
      transformMode.value = mode;
      if (engine.value) {
        engine.value.setTransformMode(mode);
      }
    }
    function handleResize(entries) {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          canvasWidth.value = width;
          canvasHeight.value = height;
          if (engine.value) {
            engine.value.resize(width, height);
            centerOnComposition();
          }
        }
      }
    }
    function centerOnComposition() {
      const container = containerRef.value;
      if (!container || !engine.value) return;
      container.getBoundingClientRect();
      const padding = 40;
      engine.value.fitCompositionToViewport(padding);
      const camera = engine.value.getCameraController();
      const calculatedZoom = camera.getZoom();
      zoom.value = calculatedZoom;
      viewportTransform.value = [calculatedZoom, 0, 0, calculatedZoom, 0, 0];
    }
    function setRenderMode(mode) {
      renderMode.value = mode;
      if (engine.value) {
        engine.value.setRenderMode(mode);
      }
    }
    function onPointAdded(_point) {
      if (!activeSplineLayerId.value) {
        const newLayer = store.createLayer("spline");
        store.selectLayer(newLayer.id);
      }
    }
    function onPathUpdated() {
      syncLayersToEngine();
    }
    function zoomIn() {
      const newZoom = Math.min(zoom.value * 1.2, 10);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function zoomOut() {
      const newZoom = Math.max(zoom.value * 0.8, 0.1);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function fitToView() {
      centerOnComposition();
    }
    function resetCamera() {
      if (engine.value) {
        engine.value.resetCameraToDefault();
      }
    }
    function toggleGrid() {
      showGrid.value = !showGrid.value;
      if (engine.value) {
        engine.value.setCompositionGridVisible(showGrid.value);
      }
    }
    function toggleOutsideOverlay() {
      showOutsideOverlay.value = !showOutsideOverlay.value;
      showSafeFrameGuides.value = showOutsideOverlay.value;
    }
    function setZoom(newZoom) {
      newZoom = Math.max(0.1, Math.min(10, newZoom));
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    async function captureFrame() {
      if (!engine.value) return null;
      const result = engine.value.captureFrame();
      if (!result?.imageData) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      ctx.putImageData(result.imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    async function captureDepth() {
      if (!engine.value) return null;
      const result = engine.value.captureDepth();
      if (!result?.depthBuffer) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const imageData = ctx.createImageData(result.width, result.height);
      for (let i = 0; i < result.depthBuffer.length; i++) {
        const value = Math.floor(result.depthBuffer[i] * 255);
        const idx = i * 4;
        imageData.data[idx] = value;
        imageData.data[idx + 1] = value;
        imageData.data[idx + 2] = value;
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    watch(showDepthOverlay, (visible) => {
      if (engine.value) {
        engine.value.setDepthOverlayVisible(visible);
      }
    });
    watch(depthColormap, (colormap) => {
      if (engine.value) {
        engine.value.setDepthColormap(colormap);
      }
    });
    watch(depthOpacity, (opacity) => {
      if (engine.value) {
        engine.value.setDepthOpacity(opacity / 100);
      }
    });
    __expose({
      engine,
      fitToView,
      zoomIn,
      zoomOut,
      zoom,
      setZoom,
      captureFrame,
      captureDepth,
      showPerformance,
      performanceStats,
      renderMode,
      setRenderMode,
      transformMode,
      setTransformModeTo,
      resetCamera
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "three-canvas",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("canvas", {
          ref_key: "canvasRef",
          ref: canvasRef
        }, null, 512),
        activeSplineLayerId.value || isPenMode.value ? (openBlock(), createBlock(SplineEditor, {
          key: 0,
          layerId: activeSplineLayerId.value,
          canvasWidth: canvasWidth.value,
          canvasHeight: canvasHeight.value,
          zoom: zoom.value,
          viewportTransform: viewportTransformArray.value,
          isPenMode: isPenMode.value,
          onPointAdded,
          onPathUpdated,
          ref_key: "splineEditorRef",
          ref: splineEditorRef
        }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : createCommentVNode("", true),
        hasDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
          createBaseVNode("label", null, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showDepthOverlay.value = $event)
            }, null, 512), [
              [vModelCheckbox, showDepthOverlay.value]
            ]),
            _cache[9] || (_cache[9] = createTextVNode(" Depth Overlay ", -1))
          ]),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => depthColormap.value = $event),
            class: "colormap-select"
          }, [..._cache[10] || (_cache[10] = [
            createBaseVNode("option", { value: "viridis" }, "Viridis", -1),
            createBaseVNode("option", { value: "plasma" }, "Plasma", -1),
            createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1)
          ])], 512), [
            [vModelSelect, depthColormap.value]
          ]),
          withDirectives(createBaseVNode("input", {
            type: "range",
            min: "0",
            max: "100",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => depthOpacity.value = $event),
            class: "opacity-slider"
          }, null, 512), [
            [
              vModelText,
              depthOpacity.value,
              void 0,
              { number: true }
            ]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$b, [
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "color" }),
            onClick: _cache[3] || (_cache[3] = ($event) => setRenderMode("color")),
            title: "Color View"
          }, [..._cache[11] || (_cache[11] = [
            createBaseVNode("i", { class: "pi pi-image" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "depth" }),
            onClick: _cache[4] || (_cache[4] = ($event) => setRenderMode("depth")),
            title: "Depth View"
          }, [..._cache[12] || (_cache[12] = [
            createBaseVNode("i", { class: "pi pi-box" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "normal" }),
            onClick: _cache[5] || (_cache[5] = ($event) => setRenderMode("normal")),
            title: "Normal View"
          }, [..._cache[13] || (_cache[13] = [
            createBaseVNode("i", { class: "pi pi-compass" }, null, -1)
          ])], 2),
          _cache[17] || (_cache[17] = createBaseVNode("div", { class: "controls-divider" }, null, -1)),
          createBaseVNode("button", {
            onClick: resetCamera,
            title: "Reset Camera (Home)"
          }, [..._cache[14] || (_cache[14] = [
            createBaseVNode("i", { class: "pi pi-home" }, null, -1)
          ])]),
          _cache[18] || (_cache[18] = createBaseVNode("div", { class: "controls-divider" }, null, -1)),
          createBaseVNode("button", {
            class: normalizeClass({ active: showGrid.value }),
            onClick: toggleGrid,
            title: "Toggle Grid"
          }, [..._cache[15] || (_cache[15] = [
            createBaseVNode("i", { class: "pi pi-th-large" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: showOutsideOverlay.value }),
            onClick: toggleOutsideOverlay,
            title: "Toggle Safe Area Overlay"
          }, [..._cache[16] || (_cache[16] = [
            createBaseVNode("i", { class: "pi pi-stop" }, null, -1)
          ])], 2)
        ]),
        unref(store).selectedLayerIds.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "translate" }),
            onClick: _cache[6] || (_cache[6] = ($event) => setTransformModeTo("translate")),
            title: "Move (V)"
          }, [..._cache[19] || (_cache[19] = [
            createBaseVNode("i", { class: "pi pi-arrows-alt" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "rotate" }),
            onClick: _cache[7] || (_cache[7] = ($event) => setTransformModeTo("rotate")),
            title: "Rotate (R)"
          }, [..._cache[20] || (_cache[20] = [
            createBaseVNode("i", { class: "pi pi-sync" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "scale" }),
            onClick: _cache[8] || (_cache[8] = ($event) => setTransformModeTo("scale")),
            title: "Scale (S)"
          }, [..._cache[21] || (_cache[21] = [
            createBaseVNode("i", { class: "pi pi-expand" }, null, -1)
          ])], 2)
        ])) : createCommentVNode("", true),
        showPerformance.value ? (openBlock(), createElementBlock("div", _hoisted_4$b, [
          createBaseVNode("span", null, "FPS: " + toDisplayString(performanceStats.value.fps), 1),
          createBaseVNode("span", null, "Draw: " + toDisplayString(performanceStats.value.drawCalls), 1),
          createBaseVNode("span", null, "Tris: " + toDisplayString(performanceStats.value.triangles), 1)
        ])) : createCommentVNode("", true),
        loading.value ? (openBlock(), createElementBlock("div", _hoisted_5$b, [..._cache[22] || (_cache[22] = [
          createBaseVNode("div", { class: "loading-spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(store).segmentPendingMask ? (openBlock(), createElementBlock("div", {
          key: 5,
          class: "segment-mask-overlay",
          style: normalizeStyle(maskOverlayStyle.value)
        }, [
          createBaseVNode("img", {
            src: "data:image/png;base64," + unref(store).segmentPendingMask.mask,
            class: "mask-preview",
            alt: "Segmentation mask"
          }, null, 8, _hoisted_6$b)
        ], 4)) : createCommentVNode("", true),
        isDrawingSegmentBox.value && unref(store).segmentBoxStart && segmentBoxEnd.value ? (openBlock(), createElementBlock("div", {
          key: 6,
          class: "segment-box-preview",
          style: normalizeStyle(segmentBoxStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        unref(store).segmentIsLoading ? (openBlock(), createElementBlock("div", _hoisted_7$b, [..._cache[23] || (_cache[23] = [
          createBaseVNode("div", { class: "segment-spinner" }, null, -1),
          createBaseVNode("span", null, "Segmenting...", -1)
        ])])) : createCommentVNode("", true),
        showSafeFrameGuides.value ? (openBlock(), createElementBlock("div", _hoisted_8$b, [
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-left",
            style: normalizeStyle(safeFrameLeftStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-right",
            style: normalizeStyle(safeFrameRightStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-top",
            style: normalizeStyle(safeFrameTopStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-bottom",
            style: normalizeStyle(safeFrameBottomStyle.value)
          }, null, 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const ThreeCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-6239a0ec"]]);

const _hoisted_1$a = { class: "prop-wrapper" };
const _hoisted_2$a = { class: "prop-content" };
const _hoisted_3$a = { class: "prop-name" };
const _hoisted_4$a = { class: "prop-inputs" };
const _hoisted_5$a = {
  key: 0,
  class: "vec-item"
};
const _hoisted_6$a = {
  key: 1,
  class: "color-input-wrapper"
};
const _hoisted_7$a = ["value"];
const _hoisted_8$a = { class: "color-hex" };
const _hoisted_9$a = { class: "vec-item" };
const _hoisted_10$a = { class: "vec-item" };
const _hoisted_11$9 = ["onMousedown", "onDblclick", "onContextmenu"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const store = useCompositorStore();
    const selectedKeyframeIds = ref(/* @__PURE__ */ new Set());
    const trackRef = ref(null);
    const isBoxSelecting = ref(false);
    const boxStartX = ref(0);
    const boxCurrentX = ref(0);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      keyframe: null
    });
    const contextMenuStyle = computed(() => ({
      left: `${contextMenu.value.x}px`,
      top: `${contextMenu.value.y}px`
    }));
    const selectionBoxStyle = computed(() => {
      const left = Math.min(boxStartX.value, boxCurrentX.value);
      const width = Math.abs(boxCurrentX.value - boxStartX.value);
      return {
        left: `${left}px`,
        width: `${width}px`
      };
    });
    const hasKeyframeAtCurrent = computed(() => props.property.keyframes?.some((k) => k.frame === store.currentFrame));
    const isSelected = computed(() => store.selectedPropertyPath === props.propertyPath);
    function toggleAnim() {
      store.setPropertyAnimated(props.layerId, props.propertyPath, !props.property.animated);
    }
    function addKeyframeAtCurrent() {
      store.addKeyframe(props.layerId, props.propertyPath, props.property.value);
    }
    function updateValDirect(v) {
      store.setPropertyValue(props.layerId, props.propertyPath, v);
    }
    function updateValByIndex(axis, v) {
      const newVal = { ...props.property.value, [axis]: v };
      store.setPropertyValue(props.layerId, props.propertyPath, newVal);
    }
    function selectProp() {
      store.selectProperty(props.propertyPath);
    }
    function handleTrackMouseDown(e) {
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      isBoxSelecting.value = true;
      boxStartX.value = x;
      boxCurrentX.value = x;
      if (!e.shiftKey) {
        selectedKeyframeIds.value.clear();
      }
      const onMove = (ev) => {
        const currentX = ev.clientX - rect.left;
        boxCurrentX.value = Math.max(0, currentX);
        const minFrame = Math.min(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        const maxFrame = Math.max(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        if (!ev.shiftKey) {
          selectedKeyframeIds.value.clear();
        }
        for (const kf of props.property.keyframes || []) {
          if (kf.frame >= minFrame && kf.frame <= maxFrame) {
            selectedKeyframeIds.value.add(kf.id);
          }
        }
      };
      const onUp = (ev) => {
        isBoxSelecting.value = false;
        const dragDistance = Math.abs(boxCurrentX.value - boxStartX.value);
        if (dragDistance < 5) {
          const frame = Math.round(boxStartX.value / props.pixelsPerFrame);
          store.setFrame(Math.max(0, Math.min(store.frameCount - 1, frame)));
        }
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function startKeyframeDrag(e, kf) {
      if (e.shiftKey) {
        if (selectedKeyframeIds.value.has(kf.id)) {
          selectedKeyframeIds.value.delete(kf.id);
        } else {
          selectedKeyframeIds.value.add(kf.id);
        }
      } else {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const startX = e.clientX;
      const startFrame = kf.frame;
      const onMove = (ev) => {
        const dx = ev.clientX - startX;
        const frameDelta = Math.round(dx / props.pixelsPerFrame);
        let newFrame = Math.max(0, Math.min(store.frameCount - 1, startFrame + frameDelta));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(newFrame, store.snapConfig, props.pixelsPerFrame, {
            layers: store.layers,
            selectedLayerId: props.layerId,
            currentFrame: store.currentFrame,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            newFrame = snap.frame;
          }
        }
        if (newFrame !== kf.frame) {
          store.moveKeyframe(props.layerId, props.propertyPath, kf.id, newFrame);
        }
      };
      const onUp = () => {
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function deleteKeyframe(kfId) {
      store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      selectedKeyframeIds.value.delete(kfId);
    }
    function showContextMenu(e, kf) {
      if (!selectedKeyframeIds.value.has(kf.id)) {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const trackRect = trackRef.value?.getBoundingClientRect();
      if (trackRect) {
        contextMenu.value = {
          visible: true,
          x: e.clientX - trackRect.left,
          y: e.clientY - trackRect.top,
          keyframe: kf
        };
      }
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.keyframe = null;
    }
    function setInterpolation(type) {
      for (const kfId of selectedKeyframeIds.value) {
        store.setKeyframeInterpolation(props.layerId, props.propertyPath, kfId, type);
      }
      hideContextMenu();
    }
    function goToKeyframe() {
      if (contextMenu.value.keyframe) {
        store.setFrame(contextMenu.value.keyframe.frame);
      }
      hideContextMenu();
    }
    function deleteSelectedKeyframes() {
      for (const kfId of selectedKeyframeIds.value) {
        store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      }
      selectedKeyframeIds.value.clear();
      hideContextMenu();
    }
    function handleGlobalClick(e) {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleGlobalClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleGlobalClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["prop-sidebar", { selected: isSelected.value }]),
          style: normalizeStyle(__props.gridStyle),
          onClick: selectProp
        }, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "indent-spacer" }, null, -1)),
          createBaseVNode("div", {
            class: "icon-box",
            onClick: withModifiers(addKeyframeAtCurrent, ["stop"])
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["kf-btn", { active: hasKeyframeAtCurrent.value }])
            }, "â—‡", 2)
          ]),
          createBaseVNode("div", {
            class: "icon-box",
            onClick: withModifiers(toggleAnim, ["stop"])
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["stopwatch", { active: __props.property.animated }])
            }, "â±", 2)
          ]),
          createBaseVNode("div", _hoisted_2$a, [
            createBaseVNode("span", _hoisted_3$a, toDisplayString(__props.name), 1),
            createBaseVNode("div", _hoisted_4$a, [
              __props.name === "Z Position" ? (openBlock(), createElementBlock("div", _hoisted_5$a, [
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "label z-label" }, "Z", -1)),
                createVNode(ScrubableNumber, {
                  modelValue: __props.property.value?.z ?? 0,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => updateValByIndex("z", v))
                }, null, 8, ["modelValue"])
              ])) : __props.property.type === "color" ? (openBlock(), createElementBlock("div", _hoisted_6$a, [
                createBaseVNode("input", {
                  type: "color",
                  value: __props.property.value,
                  onInput: _cache[1] || (_cache[1] = (e) => updateValDirect(e.target.value))
                }, null, 40, _hoisted_7$a),
                createBaseVNode("span", _hoisted_8$a, toDisplayString(__props.property.value), 1)
              ])) : typeof __props.property.value === "object" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("div", _hoisted_9$a, [
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "label x-label" }, "X", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateValByIndex("x", v))
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_10$a, [
                  _cache[9] || (_cache[9] = createBaseVNode("span", { class: "label y-label" }, "Y", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateValByIndex("y", v))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof __props.property.value === "number" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 3,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 1
              }, null, 8, ["modelValue"])) : createCommentVNode("", true)
            ])
          ])
        ], 6)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "prop-track",
          onMousedown: handleTrackMouseDown,
          ref_key: "trackRef",
          ref: trackRef
        }, [
          isBoxSelecting.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "selection-box",
            style: normalizeStyle(selectionBoxStyle.value)
          }, null, 4)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.property.keyframes, (kf) => {
            return openBlock(), createElementBlock("div", {
              key: kf.id,
              class: normalizeClass(["keyframe", { selected: selectedKeyframeIds.value.has(kf.id), [kf.interpolation || "linear"]: true }]),
              style: normalizeStyle({ left: `${kf.frame * __props.pixelsPerFrame}px` }),
              onMousedown: withModifiers(($event) => startKeyframeDrag($event, kf), ["stop"]),
              onDblclick: withModifiers(($event) => deleteKeyframe(kf.id), ["stop"]),
              onContextmenu: withModifiers(($event) => showContextMenu($event, kf), ["prevent", "stop"])
            }, null, 46, _hoisted_11$9);
          }), 128)),
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: normalizeStyle(contextMenuStyle.value)
          }, [
            _cache[16] || (_cache[16] = createBaseVNode("div", { class: "menu-header" }, "Interpolation", -1)),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "linear" }]),
              onClick: _cache[4] || (_cache[4] = ($event) => setInterpolation("linear"))
            }, [..._cache[11] || (_cache[11] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ“ˆ", -1),
              createTextVNode(" Linear ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "bezier" }]),
              onClick: _cache[5] || (_cache[5] = ($event) => setInterpolation("bezier"))
            }, [..._cache[12] || (_cache[12] = [
              createBaseVNode("span", { class: "icon" }, "ã€°ï¸", -1),
              createTextVNode(" Bezier ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "hold" }]),
              onClick: _cache[6] || (_cache[6] = ($event) => setInterpolation("hold"))
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("span", { class: "icon" }, "â¸ï¸", -1),
              createTextVNode(" Hold ", -1)
            ])], 2),
            _cache[17] || (_cache[17] = createBaseVNode("div", { class: "menu-divider" }, null, -1)),
            createBaseVNode("div", {
              class: "menu-item",
              onClick: goToKeyframe
            }, [..._cache[14] || (_cache[14] = [
              createBaseVNode("span", { class: "icon" }, "âž¡ï¸", -1),
              createTextVNode(" Go to Frame ", -1)
            ])]),
            createBaseVNode("div", {
              class: "menu-item delete",
              onClick: deleteSelectedKeyframes
            }, [..._cache[15] || (_cache[15] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ—‘ï¸", -1),
              createTextVNode(" Delete ", -1)
            ])])
          ], 4)) : createCommentVNode("", true)
        ], 544))
      ]);
    };
  }
});

const PropertyTrack = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-32aca4cb"]]);

const _hoisted_1$9 = {
  key: 0,
  class: "track-wrapper"
};
const _hoisted_2$9 = { class: "arrow" };
const _hoisted_3$9 = { class: "layer-id" };
const _hoisted_4$9 = { class: "type-icon" };
const _hoisted_5$9 = {
  key: 0,
  class: "name-text"
};
const _hoisted_6$9 = { class: "col-mode" };
const _hoisted_7$9 = ["value"];
const _hoisted_8$9 = { class: "col-parent" };
const _hoisted_9$9 = ["value"];
const _hoisted_10$9 = ["value"];
const _hoisted_11$8 = {
  key: 0,
  class: "children-container"
};
const _hoisted_12$8 = ["onMousedown"];
const _hoisted_13$7 = { class: "arrow-col" };
const _hoisted_14$7 = { class: "arrow" };
const _hoisted_15$7 = { class: "group-label" };
const _hoisted_16$7 = { key: 0 };
const _hoisted_17$7 = {
  key: 0,
  class: "children-container"
};
const _hoisted_18$7 = { key: 0 };
const _hoisted_19$7 = { class: "color-grid" };
const _hoisted_20$7 = ["onClick"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const localExpanded = ref(false);
    const isExpanded = computed(() => props.isExpandedExternal ?? localExpanded.value);
    const isSelected = computed(() => store.selectedLayerIds.includes(props.layer.id));
    const expandedGroups = ref(["Transform", "Text", "More Options"]);
    const isRenaming = ref(false);
    const renameVal = ref("");
    const renameInput = ref(null);
    const contextMenuVisible = ref(false);
    const contextMenuX = ref(0);
    const contextMenuY = ref(0);
    const showColorPicker = ref(false);
    const colorPickerX = ref(0);
    const colorPickerY = ref(0);
    const labelColors = [
      "#999999",
      // None (gray)
      "#e24b4b",
      // Red
      "#f5c343",
      // Yellow
      "#c8e04d",
      // Lime
      "#4be08e",
      // Sea Green
      "#4bcde0",
      // Aqua
      "#5b8ef0",
      // Blue
      "#9d70e8",
      // Purple
      "#e070d0",
      // Pink
      "#e0a070",
      // Peach
      "#e07070",
      // Light Red
      "#70e0a0",
      // Mint
      "#7090e0",
      // Sky Blue
      "#a070e0",
      // Violet
      "#e07090",
      // Rose
      "#90c8e0"
      // Pale Blue
    ];
    const availableParents = computed(() => props.allLayers?.filter((l) => l.id !== props.layer.id) || []);
    const groupedProperties = computed(() => {
      const groups = {};
      const t = props.layer.transform;
      const transformProps = [];
      const add = (path, name, prop) => {
        if (prop) transformProps.push({ path, name, property: prop });
      };
      add("transform.anchorPoint", "Anchor Point", t.anchorPoint);
      add("transform.position", "Position", t.position);
      if (props.layer.threeD) {
        transformProps.push({
          path: "transform.position.z",
          name: "Z Position",
          property: t.position
          // Pass full position property, PropertyTrack handles .z
        });
      }
      add("transform.scale", "Scale", t.scale);
      if (props.layer.threeD) {
        if (t.orientation) transformProps.push({ path: "transform.orientation", name: "Orientation", property: t.orientation });
        if (t.rotationX) transformProps.push({ path: "transform.rotationX", name: "X Rotation", property: t.rotationX });
        if (t.rotationY) transformProps.push({ path: "transform.rotationY", name: "Y Rotation", property: t.rotationY });
        if (t.rotationZ) transformProps.push({ path: "transform.rotationZ", name: "Z Rotation", property: t.rotationZ });
      } else {
        if (t.rotation) transformProps.push({ path: "transform.rotation", name: "Rotation", property: t.rotation });
      }
      if (props.layer.opacity) transformProps.push({ path: "opacity", name: "Opacity", property: props.layer.opacity });
      groups["Transform"] = transformProps;
      if (props.layer.properties) {
        props.layer.properties.forEach((p) => {
          const g = p.group || "Properties";
          if (!groups[g]) groups[g] = [];
          groups[g].push({ path: p.name, name: p.name, property: p });
        });
      }
      return groups;
    });
    const barStyle = computed(() => {
      const frameCount = props.frameCount || 81;
      const leftPct = props.layer.inPoint / frameCount * 100;
      const widthPct = (props.layer.outPoint - props.layer.inPoint + 1) / frameCount * 100;
      return {
        left: `${leftPct}%`,
        width: `${widthPct}%`
      };
    });
    function selectLayer() {
      emit("select", props.layer.id);
    }
    function toggleExpand() {
      emit("toggleExpand", props.layer.id, !isExpanded.value);
    }
    function toggleGroup(g) {
      if (expandedGroups.value.includes(g)) expandedGroups.value = expandedGroups.value.filter((x) => x !== g);
      else expandedGroups.value.push(g);
    }
    function getLayerIcon(t) {
      return { text: "T", solid: "â– ", camera: "ðŸ“·" }[t] || "â€¢";
    }
    function startRename() {
      isRenaming.value = true;
      renameVal.value = props.layer.name;
      nextTick(() => renameInput.value?.focus());
    }
    function saveRename() {
      emit("updateLayer", props.layer.id, { name: renameVal.value });
      isRenaming.value = false;
    }
    function setParent(e) {
      emit("updateLayer", props.layer.id, { parentId: e.target.value || null });
    }
    function setBlendMode(e) {
      emit("updateLayer", props.layer.id, { blendMode: e.target.value });
    }
    function startDrag() {
    }
    function toggleVis() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
    }
    function toggleLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
    }
    function toggleColorPicker(e) {
      const rect = e.target.getBoundingClientRect();
      colorPickerX.value = rect.left;
      colorPickerY.value = rect.bottom + 4;
      showColorPicker.value = !showColorPicker.value;
    }
    function setLabelColor(color) {
      emit("updateLayer", props.layer.id, { labelColor: color });
      showColorPicker.value = false;
    }
    function closeColorPicker() {
      showColorPicker.value = false;
    }
    function resetTransform() {
      const comp = store.getActiveComp();
      if (!comp) return;
      const defaultTransform = {
        anchorPoint: { x: comp.settings.width / 2, y: comp.settings.height / 2 },
        position: { x: comp.settings.width / 2, y: comp.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100},
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      };
      const t = props.layer.transform;
      if (t.anchorPoint) t.anchorPoint.value = { ...defaultTransform.anchorPoint };
      if (t.position) t.position.value = props.layer.threeD ? { ...defaultTransform.position } : { x: defaultTransform.position.x, y: defaultTransform.position.y };
      if (t.scale) t.scale.value = { x: defaultTransform.scale.x, y: defaultTransform.scale.y };
      if (t.rotation) t.rotation.value = defaultTransform.rotation;
      if (t.rotationX) t.rotationX.value = defaultTransform.rotationX;
      if (t.rotationY) t.rotationY.value = defaultTransform.rotationY;
      if (t.rotationZ) t.rotationZ.value = defaultTransform.rotationZ;
      if (t.orientation) t.orientation.value = { ...defaultTransform.orientation };
      if (props.layer.opacity) props.layer.opacity.value = defaultTransform.opacity;
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      console.log("[EnhancedLayerTrack] Reset transform for layer:", props.layer.name);
    }
    function showContextMenu(e) {
      contextMenuX.value = e.clientX;
      contextMenuY.value = e.clientY;
      contextMenuVisible.value = true;
      if (!isSelected.value) {
        emit("select", props.layer.id);
      }
    }
    function hideContextMenu() {
      contextMenuVisible.value = false;
    }
    function duplicateLayer() {
      store.duplicateLayer(props.layer.id);
      hideContextMenu();
    }
    function renameFromMenu() {
      hideContextMenu();
      nextTick(() => {
        isRenaming.value = true;
        renameVal.value = props.layer.name;
        nextTick(() => renameInput.value?.focus());
      });
    }
    function toggleLayerVisibility() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
      hideContextMenu();
    }
    function toggleLayerLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
      hideContextMenu();
    }
    function toggleLayer3D() {
      store.toggleLayer3D(props.layer.id);
      hideContextMenu();
    }
    function precomposeLayer() {
      store.selectLayer(props.layer.id);
      store.precomposeSelectedLayers(props.layer.name + " Precomp");
      hideContextMenu();
    }
    function deleteLayer() {
      store.deleteLayer(props.layer.id);
      hideContextMenu();
    }
    function handleOutsideClick(e) {
      if (contextMenuVisible.value) {
        hideContextMenu();
      }
      if (showColorPicker.value) {
        closeColorPicker();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return __props.layer ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(["sidebar-row", { selected: isSelected.value }]),
            style: normalizeStyle(__props.gridStyle),
            onMousedown: selectLayer,
            onContextmenu: withModifiers(showContextMenu, ["prevent"])
          }, [
            createBaseVNode("div", {
              class: "arrow-col",
              onMousedown: withModifiers(toggleExpand, ["stop"])
            }, [
              createBaseVNode("span", _hoisted_2$9, toDisplayString(isExpanded.value ? "â–¼" : "â–¶"), 1)
            ], 32),
            createBaseVNode("div", {
              class: "label-box",
              onMousedown: withModifiers(toggleColorPicker, ["stop"]),
              style: normalizeStyle({ background: __props.layer.labelColor || "#999" })
            }, null, 36),
            createBaseVNode("div", _hoisted_3$9, toDisplayString(__props.index), 1),
            createBaseVNode("div", {
              class: "icon-col",
              onMousedown: withModifiers(toggleVis, ["stop"])
            }, toDisplayString(__props.layer.visible ? "ðŸ‘" : "â€¢"), 33),
            createBaseVNode("div", {
              class: "icon-col",
              onMousedown: withModifiers(toggleLock, ["stop"])
            }, toDisplayString(__props.layer.locked ? "ðŸ”’" : "ðŸ”“"), 33),
            createBaseVNode("div", {
              class: normalizeClass(["icon-col cube-icon", { active: __props.layer.threeD }]),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(store).toggleLayer3D(__props.layer.id), ["stop"]))
            }, "â¬¡", 34),
            createBaseVNode("div", {
              class: "layer-name-col",
              onDblclick: withModifiers(startRename, ["stop"])
            }, [
              createBaseVNode("span", _hoisted_4$9, toDisplayString(getLayerIcon(__props.layer.type)), 1),
              !isRenaming.value ? (openBlock(), createElementBlock("span", _hoisted_5$9, toDisplayString(__props.layer.name), 1)) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => renameVal.value = $event),
                onBlur: saveRename,
                onKeydown: withKeys(saveRename, ["enter"]),
                class: "rename-input",
                ref_key: "renameInput",
                ref: renameInput
              }, null, 544)), [
                [vModelText, renameVal.value]
              ])
            ], 32),
            createBaseVNode("div", _hoisted_6$9, [
              createBaseVNode("select", {
                value: __props.layer.blendMode,
                class: "mini-select",
                onChange: setBlendMode,
                onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"]))
              }, [..._cache[6] || (_cache[6] = [
                createStaticVNode('<optgroup label="Normal" data-v-13808488><option value="normal" data-v-13808488>Normal</option><option value="dissolve" data-v-13808488>Dissolve</option></optgroup><optgroup label="Darken" data-v-13808488><option value="darken" data-v-13808488>Darken</option><option value="multiply" data-v-13808488>Multiply</option><option value="colorBurn" data-v-13808488>Color Burn</option><option value="linearBurn" data-v-13808488>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-13808488><option value="add" data-v-13808488>Add</option><option value="lighten" data-v-13808488>Lighten</option><option value="screen" data-v-13808488>Screen</option><option value="colorDodge" data-v-13808488>Color Dodge</option><option value="linearDodge" data-v-13808488>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-13808488><option value="overlay" data-v-13808488>Overlay</option><option value="softLight" data-v-13808488>Soft Light</option><option value="hardLight" data-v-13808488>Hard Light</option><option value="vividLight" data-v-13808488>Vivid Light</option><option value="linearLight" data-v-13808488>Linear Light</option><option value="pinLight" data-v-13808488>Pin Light</option><option value="hardMix" data-v-13808488>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-13808488><option value="difference" data-v-13808488>Difference</option><option value="exclusion" data-v-13808488>Exclusion</option><option value="subtract" data-v-13808488>Subtract</option><option value="divide" data-v-13808488>Divide</option></optgroup><optgroup label="Component" data-v-13808488><option value="hue" data-v-13808488>Hue</option><option value="saturation" data-v-13808488>Saturation</option><option value="color" data-v-13808488>Color</option><option value="luminosity" data-v-13808488>Luminosity</option></optgroup>', 6)
              ])], 40, _hoisted_7$9)
            ]),
            createBaseVNode("div", _hoisted_8$9, [
              createBaseVNode("select", {
                value: __props.layer.parentId || "",
                class: "mini-select",
                onChange: setParent,
                onMousedown: _cache[3] || (_cache[3] = withModifiers(() => {
                }, ["stop"]))
              }, [
                _cache[7] || (_cache[7] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (p) => {
                  return openBlock(), createElementBlock("option", {
                    key: p.id,
                    value: p.id
                  }, toDisplayString(p.index), 9, _hoisted_10$9);
                }), 128))
              ], 40, _hoisted_9$9)
            ])
          ], 38),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_11$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                createBaseVNode("div", {
                  class: "group-header sidebar-row",
                  style: normalizeStyle(__props.gridStyle),
                  onMousedown: withModifiers(($event) => toggleGroup(groupName), ["stop"])
                }, [
                  createBaseVNode("div", _hoisted_13$7, [
                    createBaseVNode("span", _hoisted_14$7, toDisplayString(expandedGroups.value.includes(groupName) ? "â–¼" : "â–¶"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_15$7, [
                    createTextVNode(toDisplayString(groupName) + " ", 1),
                    groupName === "Transform" ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: "reset-link",
                      onClick: withModifiers(resetTransform, ["stop"])
                    }, "Reset")) : createCommentVNode("", true)
                  ])
                ], 44, _hoisted_12$8),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_16$7, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "sidebar",
                      gridStyle: __props.gridStyle,
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "layer-row track-bg",
            onMousedown: selectLayer
          }, [
            createBaseVNode("div", {
              class: "duration-bar",
              style: normalizeStyle(barStyle.value),
              onMousedown: withModifiers(startDrag, ["stop"])
            }, [
              createBaseVNode("div", {
                class: "bar-fill",
                style: normalizeStyle({ background: __props.layer.labelColor || "#777" })
              }, null, 4)
            ], 36)
          ], 32),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_17$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                _cache[8] || (_cache[8] = createBaseVNode("div", { class: "group-header track-bg" }, null, -1)),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_18$7, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "track",
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenuVisible.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-context-menu",
            style: normalizeStyle({ left: contextMenuX.value + "px", top: contextMenuY.value + "px" }),
            onClick: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: duplicateLayer }, "Duplicate Layer"),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            _cache[9] || (_cache[9] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: toggleLayerVisibility }, toDisplayString(__props.layer.visible ? "Hide" : "Show") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayerLock }, toDisplayString(__props.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayer3D }, toDisplayString(__props.layer.threeD ? "Make 2D" : "Make 3D"), 1),
            _cache[10] || (_cache[10] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: precomposeLayer }, "Pre-compose..."),
            _cache[11] || (_cache[11] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteLayer,
              class: "danger"
            }, "Delete Layer")
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showColorPicker.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-color-picker",
            style: normalizeStyle({ left: colorPickerX.value + "px", top: colorPickerY.value + "px" }),
            onClick: _cache[5] || (_cache[5] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("div", _hoisted_19$7, [
              (openBlock(), createElementBlock(Fragment, null, renderList(labelColors, (color) => {
                return createBaseVNode("button", {
                  key: color,
                  class: normalizeClass(["color-swatch", { active: __props.layer.labelColor === color }]),
                  style: normalizeStyle({ backgroundColor: color }),
                  onClick: ($event) => setLabelColor(color)
                }, null, 14, _hoisted_20$7);
              }), 64))
            ])
          ], 4)) : createCommentVNode("", true)
        ]))
      ])) : createCommentVNode("", true);
    };
  }
});

const EnhancedLayerTrack = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-13808488"]]);

const _hoisted_1$8 = { class: "composition-tabs" };
const _hoisted_2$8 = { class: "tabs-container" };
const _hoisted_3$8 = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_4$8 = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
};
const _hoisted_5$8 = {
  key: 1,
  class: "tab-name"
};
const _hoisted_6$8 = {
  key: 2,
  class: "tab-name"
};
const _hoisted_7$8 = { class: "tab-info" };
const _hoisted_8$8 = ["onClick"];
const _hoisted_9$8 = ["disabled"];
const _hoisted_10$8 = ["disabled"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const editingId = ref(null);
    const editingName = ref("");
    const renameInput = ref(null);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      comp: null
    });
    const openCompositions = computed(() => store.openCompositions);
    const activeCompositionId = computed(() => store.activeCompositionId);
    const mainCompositionId = computed(() => store.project.mainCompositionId);
    function switchToComposition(compId) {
      store.switchComposition(compId);
    }
    function closeTab(compId) {
      store.closeCompositionTab(compId);
    }
    function formatCompInfo(comp) {
      const s = comp.settings;
      return `${s.width}x${s.height} ${s.fps}fps`;
    }
    function startRename(comp) {
      editingId.value = comp.id;
      editingName.value = comp.name;
      nextTick(() => {
        renameInput.value?.focus();
        renameInput.value?.select();
      });
    }
    function finishRename() {
      if (editingId.value && editingName.value.trim()) {
        store.renameComposition(editingId.value, editingName.value.trim());
      }
      editingId.value = null;
      editingName.value = "";
    }
    function cancelRename() {
      editingId.value = null;
      editingName.value = "";
    }
    function showContextMenu(event, comp) {
      contextMenu.value = {
        visible: true,
        x: event.clientX,
        y: event.clientY,
        comp
      };
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.comp = null;
    }
    function renameFromMenu() {
      if (contextMenu.value.comp) {
        startRename(contextMenu.value.comp);
      }
      hideContextMenu();
    }
    function duplicateComposition() {
      if (contextMenu.value.comp) {
        const original = contextMenu.value.comp;
        const newComp = store.createComposition(
          `${original.name} Copy`,
          original.settings,
          original.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", newComp.name);
      }
      hideContextMenu();
    }
    function openInNewTab() {
      if (contextMenu.value.comp) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function setAsMainComp() {
      if (contextMenu.value.comp) {
        store.project.mainCompositionId = contextMenu.value.comp.id;
        console.log("[CompositionTabs] Set main composition:", contextMenu.value.comp.name);
      }
      hideContextMenu();
    }
    function deleteComposition() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== mainCompositionId.value) {
        store.deleteComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function handleOutsideClick() {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createBaseVNode("div", _hoisted_2$8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(openCompositions.value, (comp) => {
            return openBlock(), createElementBlock("div", {
              key: comp.id,
              class: normalizeClass(["tab", {
                active: comp.id === activeCompositionId.value,
                precomp: comp.isPrecomp
              }]),
              onClick: ($event) => switchToComposition(comp.id),
              onDblclick: ($event) => startRename(comp),
              onContextmenu: withModifiers(($event) => showContextMenu($event, comp), ["prevent"])
            }, [
              comp.isPrecomp ? (openBlock(), createElementBlock("span", _hoisted_4$8, "â– ")) : createCommentVNode("", true),
              editingId.value === comp.id ? (openBlock(), createElementBlock("span", _hoisted_5$8, [
                withDirectives(createBaseVNode("input", {
                  ref_for: true,
                  ref_key: "renameInput",
                  ref: renameInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editingName.value = $event),
                  type: "text",
                  class: "rename-input",
                  onBlur: finishRename,
                  onKeydown: [
                    withKeys(finishRename, ["enter"]),
                    withKeys(cancelRename, ["escape"])
                  ],
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 544), [
                  [vModelText, editingName.value]
                ])
              ])) : (openBlock(), createElementBlock("span", _hoisted_6$8, toDisplayString(comp.name), 1)),
              createBaseVNode("span", _hoisted_7$8, toDisplayString(formatCompInfo(comp)), 1),
              openCompositions.value.length > 1 ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "close-btn",
                onClick: withModifiers(($event) => closeTab(comp.id), ["stop"]),
                title: "Close tab"
              }, " Ã— ", 8, _hoisted_8$8)) : createCommentVNode("", true)
            ], 42, _hoisted_3$8);
          }), 128)),
          createBaseVNode("button", {
            class: "new-comp-btn",
            onClick: _cache[2] || (_cache[2] = ($event) => emit("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "context-menu",
            style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            createBaseVNode("button", { onClick: duplicateComposition }, "Duplicate"),
            createBaseVNode("button", { onClick: openInNewTab }, "Open in New Tab"),
            _cache[4] || (_cache[4] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: setAsMainComp,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value
            }, " Set as Main Composition ", 8, _hoisted_9$8),
            _cache[5] || (_cache[5] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteComposition,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value,
              class: "danger"
            }, " Delete Composition ", 8, _hoisted_10$8)
          ], 4)) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const CompositionTabs = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-c032dfe4"]]);

const _hoisted_1$7 = { class: "timeline-header" };
const _hoisted_2$7 = { class: "header-left" };
const _hoisted_3$7 = { class: "timecode" };
const _hoisted_4$7 = { class: "frame-display" };
const _hoisted_5$7 = ["value"];
const _hoisted_6$7 = { class: "fps-label" };
const _hoisted_7$7 = { class: "header-center" };
const _hoisted_8$7 = {
  key: 0,
  class: "add-layer-menu"
};
const _hoisted_9$7 = { class: "tool-group" };
const _hoisted_10$7 = ["disabled"];
const _hoisted_11$7 = { class: "header-right" };
const _hoisted_12$7 = { class: "timeline-content" };
const MAX_PPF = 80;
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const zoomPercent = ref(0);
    const sidebarWidth = ref(450);
    const expandedLayers = ref({});
    const showAddLayerMenu = ref(false);
    const addLayerContainer = ref(null);
    const trackViewportRef = ref(null);
    const rulerCanvas = ref(null);
    const sidebarScrollRef = ref(null);
    const trackScrollRef = ref(null);
    const rulerScrollRef = ref(null);
    let isScrollingSidebar = false;
    let isScrollingTrack = false;
    const viewportWidth = ref(1e3);
    const filteredLayers = computed(() => store.layers || []);
    const playheadPositionPct = computed(() => store.currentFrame / store.frameCount * 100);
    const effectivePpf = computed(() => {
      const minPpf = viewportWidth.value / store.frameCount;
      return minPpf + zoomPercent.value / 100 * (MAX_PPF - minPpf);
    });
    const timelineWidth = computed(() => {
      if (zoomPercent.value === 0) {
        return viewportWidth.value;
      }
      return store.frameCount * effectivePpf.value;
    });
    const computedWidthStyle = computed(() => timelineWidth.value + "px");
    const sidebarGridStyle = computed(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function toggleAddLayerMenu() {
      showAddLayerMenu.value = !showAddLayerMenu.value;
    }
    function addLayer(type) {
      if (type === "text") store.createTextLayer();
      else if (type === "video") store.createLayer("video");
      else if (type === "camera") store.createCameraLayer();
      else if (type === "particles") store.createParticleLayer();
      else store.createLayer(type);
      showAddLayerMenu.value = false;
    }
    function selectLayer(id) {
      store.selectLayer(id);
    }
    function updateLayer(id, u) {
      store.updateLayer(id, u);
    }
    function deleteSelectedLayers() {
      store.selectedLayerIds.forEach((id) => store.deleteLayer(id));
    }
    function setFrame(e) {
      store.setFrame(parseInt(e.target.value) || 0);
    }
    function togglePlayback() {
      store.togglePlayback();
    }
    function handleToggleExpand(id, val) {
      expandedLayers.value[id] = val;
    }
    function formatTimecode(frame) {
      const fps = store.fps;
      const totalSeconds = Math.floor(frame / fps);
      const frames = Math.floor(frame % fps);
      const seconds = totalSeconds % 60;
      const minutes = Math.floor(totalSeconds / 60) % 60;
      const hours = Math.floor(totalSeconds / 3600);
      const pad = (n, len = 2) => String(n).padStart(len, "0");
      return `${pad(hours)};${pad(minutes)};${pad(seconds)};${pad(frames)}`;
    }
    function drawRuler() {
      const cvs = rulerCanvas.value;
      if (!cvs) return;
      const ctx = cvs.getContext("2d");
      if (!ctx) return;
      const width = timelineWidth.value;
      cvs.width = width;
      cvs.height = 30;
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, cvs.width, cvs.height);
      ctx.strokeStyle = "#666";
      ctx.fillStyle = "#aaa";
      ctx.font = "11px sans-serif";
      const labelMinWidth = 40;
      const maxLabels = Math.max(1, Math.floor(width / labelMinWidth));
      const idealStep = Math.ceil(store.frameCount / maxLabels);
      const niceSteps = [1, 2, 5, 10, 20, 25, 50, 100, 200];
      const majorStep = niceSteps.find((s) => s >= idealStep) || 200;
      const minorStep = majorStep > 1 ? Math.floor(majorStep / 2) : 0;
      const frameCount = store.frameCount;
      for (let f = 0; f <= frameCount; f++) {
        const x = f / frameCount * width;
        if (f % majorStep === 0) {
          ctx.strokeStyle = "#888";
          ctx.beginPath();
          ctx.moveTo(x, 12);
          ctx.lineTo(x, 30);
          ctx.stroke();
          ctx.fillStyle = "#ccc";
          ctx.fillText(String(f), x + 3, 10);
        } else if (minorStep > 0 && f % minorStep === 0) {
          ctx.strokeStyle = "#555";
          ctx.beginPath();
          ctx.moveTo(x, 22);
          ctx.lineTo(x, 30);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = "#444";
      ctx.beginPath();
      ctx.moveTo(0, 29.5);
      ctx.lineTo(cvs.width, 29.5);
      ctx.stroke();
    }
    function startRulerScrub(e) {
      const rect = rulerCanvas.value.getBoundingClientRect();
      const update = (ev) => {
        const currentScrollX = rulerScrollRef.value?.scrollLeft || trackScrollRef.value?.scrollLeft || 0;
        const x = ev.clientX - rect.left + currentScrollX;
        let f = Math.max(0, Math.min(store.frameCount - 1, x / timelineWidth.value * store.frameCount));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(Math.round(f), store.snapConfig, effectivePpf.value, {
            layers: store.layers,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            f = snap.frame;
          }
        }
        store.setFrame(Math.round(f));
      };
      update(e);
      window.addEventListener("mousemove", update);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", update), { once: true });
    }
    function startResize(e) {
      const startX = e.clientX;
      const startW = sidebarWidth.value;
      const onMove = (ev) => {
        sidebarWidth.value = Math.max(300, startW + (ev.clientX - startX));
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", onMove), { once: true });
    }
    function syncSidebarScroll(e) {
      if (isScrollingTrack) return;
      isScrollingSidebar = true;
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollTop = target.scrollTop;
      }
      requestAnimationFrame(() => {
        isScrollingSidebar = false;
      });
    }
    function handleTrackScroll(e) {
      const target = e.target;
      if (!isScrollingSidebar) {
        isScrollingTrack = true;
        if (sidebarScrollRef.value) {
          sidebarScrollRef.value.scrollTop = target.scrollTop;
        }
        requestAnimationFrame(() => {
          isScrollingTrack = false;
        });
      }
      if (rulerScrollRef.value) {
        rulerScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function syncRulerScroll(e) {
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function handleKeydown(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      if (e.code === "Space") {
        e.preventDefault();
        togglePlayback();
      }
      if (e.code === "Delete" || e.code === "Backspace") {
        e.preventDefault();
        deleteSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyC") {
        e.preventDefault();
        store.copySelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyX") {
        e.preventDefault();
        store.cutSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyV") {
        e.preventDefault();
        store.pasteLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyA") {
        e.preventDefault();
        store.selectedLayerIds = store.layers.map((l) => l.id);
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyD") {
        e.preventDefault();
        for (const id of store.selectedLayerIds) {
          store.duplicateLayer(id);
        }
      }
    }
    let resizeObserver = null;
    onMounted(() => {
      window.addEventListener("mousedown", (e) => {
        if (addLayerContainer.value && !addLayerContainer.value.contains(e.target)) {
          showAddLayerMenu.value = false;
        }
      });
      const elementToObserve = trackScrollRef.value || trackViewportRef.value;
      if (elementToObserve) {
        viewportWidth.value = elementToObserve.clientWidth || 1e3;
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            viewportWidth.value = entry.contentRect.width || elementToObserve.clientWidth || 1e3;
            drawRuler();
          }
        });
        resizeObserver.observe(elementToObserve);
      }
      setTimeout(() => {
        if (trackScrollRef.value) {
          viewportWidth.value = trackScrollRef.value.clientWidth || viewportWidth.value;
        }
        drawRuler();
      }, 50);
    });
    onUnmounted(() => {
      if (resizeObserver) resizeObserver.disconnect();
    });
    watch(() => [computedWidthStyle.value, zoomPercent.value, store.frameCount], () => nextTick(drawRuler));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "timeline-panel",
        tabindex: "0",
        onKeydown: handleKeydown
      }, [
        createVNode(CompositionTabs, {
          onNewComposition: _cache[0] || (_cache[0] = ($event) => emit("openCompositionSettings"))
        }),
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("div", _hoisted_2$7, [
            createBaseVNode("span", _hoisted_3$7, toDisplayString(formatTimecode(unref(store).currentFrame)), 1),
            createBaseVNode("div", _hoisted_4$7, [
              createBaseVNode("input", {
                type: "number",
                value: unref(store).currentFrame,
                onChange: setFrame,
                class: "frame-input"
              }, null, 40, _hoisted_5$7),
              createBaseVNode("span", _hoisted_6$7, toDisplayString(unref(store).fps) + " fps", 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$7, [
            createBaseVNode("div", {
              class: "tool-group add-layer-wrapper",
              ref_key: "addLayerContainer",
              ref: addLayerContainer
            }, [
              createBaseVNode("button", {
                class: normalizeClass(["add-layer-btn", { active: showAddLayerMenu.value }]),
                onMousedown: withModifiers(toggleAddLayerMenu, ["stop", "prevent"])
              }, [..._cache[10] || (_cache[10] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" Layer ", -1)
              ])], 34),
              showAddLayerMenu.value ? (openBlock(), createElementBlock("div", _hoisted_8$7, [
                createBaseVNode("button", {
                  onMousedown: _cache[1] || (_cache[1] = ($event) => addLayer("solid"))
                }, [..._cache[11] || (_cache[11] = [
                  createBaseVNode("span", { class: "icon" }, "â– ", -1),
                  createTextVNode(" Solid", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[2] || (_cache[2] = ($event) => addLayer("text"))
                }, [..._cache[12] || (_cache[12] = [
                  createBaseVNode("span", { class: "icon" }, "T", -1),
                  createTextVNode(" Text", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[3] || (_cache[3] = ($event) => addLayer("spline"))
                }, [..._cache[13] || (_cache[13] = [
                  createBaseVNode("span", { class: "icon" }, "~", -1),
                  createTextVNode(" Shape", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[4] || (_cache[4] = ($event) => addLayer("particles"))
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("span", { class: "icon" }, "âœ¨", -1),
                  createTextVNode(" Particles", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[5] || (_cache[5] = ($event) => addLayer("null"))
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("span", { class: "icon" }, "â–¡", -1),
                  createTextVNode(" Null", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[6] || (_cache[6] = ($event) => addLayer("camera"))
                }, [..._cache[16] || (_cache[16] = [
                  createBaseVNode("span", { class: "icon" }, "ðŸ“·", -1),
                  createTextVNode(" Camera", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[7] || (_cache[7] = ($event) => addLayer("light"))
                }, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("span", { class: "icon" }, "ðŸ’¡", -1),
                  createTextVNode(" Light", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[8] || (_cache[8] = ($event) => addLayer("video"))
                }, [..._cache[18] || (_cache[18] = [
                  createBaseVNode("span", { class: "icon" }, "ðŸŽžï¸", -1),
                  createTextVNode(" Video", -1)
                ])], 32)
              ])) : createCommentVNode("", true)
            ], 512),
            createBaseVNode("div", _hoisted_9$7, [
              createBaseVNode("button", {
                class: "delete-btn",
                onClick: deleteSelectedLayers,
                disabled: unref(store).selectedLayerIds.length === 0
              }, "ðŸ—‘ï¸", 8, _hoisted_10$7)
            ])
          ]),
          createBaseVNode("div", _hoisted_11$7, [
            withDirectives(createBaseVNode("input", {
              type: "range",
              min: "0",
              max: "100",
              step: "1",
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => zoomPercent.value = $event),
              class: "zoom-slider",
              title: "Zoom Timeline"
            }, null, 512), [
              [
                vModelText,
                zoomPercent.value,
                void 0,
                { number: true }
              ]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_12$7, [
          createBaseVNode("div", {
            class: "timeline-sidebar",
            style: normalizeStyle({ width: sidebarWidth.value + "px" })
          }, [
            _cache[19] || (_cache[19] = createStaticVNode('<div class="sidebar-header-row" data-v-0e53325f><div class="col-header col-arrow" data-v-0e53325f></div><div class="col-header col-name" data-v-0e53325f>Layer Name</div><div class="col-header col-mode" data-v-0e53325f>Mode</div><div class="col-header col-parent" data-v-0e53325f>Parent</div></div>', 1)),
            createBaseVNode("div", {
              class: "sidebar-scroll-area",
              ref_key: "sidebarScrollRef",
              ref: sidebarScrollRef,
              onScroll: syncSidebarScroll
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer, idx) => {
                return openBlock(), createBlock(EnhancedLayerTrack, {
                  key: layer.id,
                  layer,
                  index: idx + 1,
                  layoutMode: "sidebar",
                  isExpandedExternal: expandedLayers.value[layer.id],
                  allLayers: unref(store).layers,
                  gridStyle: sidebarGridStyle.value,
                  onToggleExpand: handleToggleExpand,
                  onSelect: selectLayer,
                  onUpdateLayer: updateLayer
                }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]);
              }), 128))
            ], 544)
          ], 4),
          createBaseVNode("div", {
            class: "sidebar-resizer",
            onMousedown: startResize
          }, null, 32),
          createBaseVNode("div", {
            class: "track-viewport",
            ref_key: "trackViewportRef",
            ref: trackViewportRef
          }, [
            createBaseVNode("div", {
              class: "ruler-scroll-wrapper",
              onScroll: syncRulerScroll,
              ref_key: "rulerScrollRef",
              ref: rulerScrollRef
            }, [
              createBaseVNode("div", {
                class: "time-ruler",
                style: normalizeStyle({ width: computedWidthStyle.value }),
                onMousedown: startRulerScrub
              }, [
                createBaseVNode("canvas", {
                  ref_key: "rulerCanvas",
                  ref: rulerCanvas,
                  height: "30"
                }, null, 512),
                createBaseVNode("div", {
                  class: "playhead-head",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4),
                createBaseVNode("div", {
                  class: "playhead-hit-area",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" }),
                  onMousedown: withModifiers(startRulerScrub, ["stop"])
                }, null, 36)
              ], 36)
            ], 544),
            createBaseVNode("div", {
              class: "track-scroll-area",
              ref_key: "trackScrollRef",
              ref: trackScrollRef,
              onScroll: handleTrackScroll
            }, [
              createBaseVNode("div", {
                class: "layer-bars-container",
                style: normalizeStyle({ width: computedWidthStyle.value })
              }, [
                _cache[20] || (_cache[20] = createBaseVNode("div", { class: "grid-background" }, null, -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer) => {
                  return openBlock(), createBlock(EnhancedLayerTrack, {
                    key: layer.id,
                    layer,
                    layoutMode: "track",
                    frameCount: unref(store).frameCount,
                    pixelsPerFrame: effectivePpf.value,
                    isExpandedExternal: expandedLayers.value[layer.id],
                    onSelect: selectLayer,
                    onUpdateLayer: updateLayer
                  }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]);
                }), 128)),
                createBaseVNode("div", {
                  class: "playhead-line",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4)
              ], 4)
            ], 544)
          ], 512)
        ])
      ], 32);
    };
  }
});

const TimelinePanel = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-0e53325f"]]);

const _hoisted_1$6 = { class: "graph-editor" };
const _hoisted_2$6 = { class: "graph-header" };
const _hoisted_3$6 = { class: "mode-toggle" };
const _hoisted_4$6 = { class: "preset-buttons" };
const _hoisted_5$6 = ["onClick", "title"];
const _hoisted_6$6 = { class: "toolbar" };
const _hoisted_7$6 = { class: "graph-content" };
const _hoisted_8$6 = { class: "property-list" };
const _hoisted_9$6 = { class: "property-list-header" };
const _hoisted_10$6 = ["title"];
const _hoisted_11$6 = ["onClick"];
const _hoisted_12$6 = ["onClick"];
const _hoisted_13$6 = { class: "property-name" };
const _hoisted_14$6 = {
  key: 0,
  class: "keyframe-count"
};
const _hoisted_15$6 = {
  key: 0,
  class: "dimension-toggles"
};
const _hoisted_16$6 = ["onClick"];
const _hoisted_17$6 = {
  key: 0,
  class: "no-properties"
};
const _hoisted_18$6 = { class: "graph-main" };
const _hoisted_19$6 = ["viewBox"];
const _hoisted_20$6 = ["onMousedown"];
const _hoisted_21$6 = ["x", "y", "fill", "transform"];
const _hoisted_22$6 = {
  key: 1,
  class: "bezier-handles"
};
const _hoisted_23$6 = {
  key: 0,
  class: "handle out-handle"
};
const _hoisted_24$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$4 = ["cx", "cy", "onMousedown"];
const _hoisted_26$4 = {
  key: 1,
  class: "handle in-handle"
};
const _hoisted_27$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_28$4 = ["cx", "cy", "onMousedown"];
const _hoisted_29$4 = ["x1", "x2", "y2"];
const _hoisted_30$4 = {
  key: 0,
  class: "keyframe-info-panel"
};
const _hoisted_31$2 = { class: "info-row" };
const _hoisted_32$2 = ["value"];
const _hoisted_33$2 = { class: "info-row" };
const _hoisted_34$2 = ["value"];
const _hoisted_35$2 = { class: "info-row" };
const _hoisted_36$2 = ["value"];
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$2 = ["disabled"];
const _hoisted_39$2 = ["disabled"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "GraphEditor",
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const canvasRef = ref(null);
    const canvasContainerRef = ref(null);
    const timeRulerRef = ref(null);
    const timeRulerCanvas = ref(null);
    const valueAxisRef = ref(null);
    const valueAxisCanvas = ref(null);
    const canvasWidth = ref(400);
    const canvasHeight = ref(200);
    const mode = ref("value");
    const viewState = reactive({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    });
    const selectedPropertyIds = ref([]);
    const visiblePropertyIds = ref([]);
    const visibleDimensions = ref({});
    const selectedKeyframes = ref([]);
    const hoveredKeyframe = ref(null);
    const dragTarget = ref(null);
    const selectionBox = ref(null);
    const contextMenu = ref(null);
    const clipboard = ref(null);
    const snapEnabled = ref(false);
    const autoSelectNearby = ref(true);
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const propertyColors = {
      "Position": "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      "Scale": "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      "Rotation": "#bb8fce",
      "Opacity": "#f8b739",
      "default": "#7c9cff"
    };
    const presetList = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ];
    const animatableProperties = computed(() => {
      const layer = store.selectedLayer;
      if (!layer) return [];
      const props = [];
      props.push(layer.transform.position);
      props.push(layer.transform.scale);
      props.push(layer.transform.rotation);
      props.push(layer.opacity);
      props.push(...layer.properties);
      return props;
    });
    const visibleProperties = computed(() => {
      return animatableProperties.value.filter(
        (p) => visiblePropertyIds.value.includes(p.id) && p.animated
      );
    });
    const allPropertiesVisible = computed(() => {
      return animatableProperties.value.every((p) => visiblePropertyIds.value.includes(p.id));
    });
    const currentFrameScreenX = computed(() => {
      return frameToScreenX(store.currentFrame);
    });
    function frameToScreenX(frame) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (frame - viewState.frameStart) / (viewState.frameEnd - viewState.frameStart);
      return margin.left + t * graphWidth;
    }
    function screenXToFrame(screenX) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (screenX - margin.left) / graphWidth;
      return viewState.frameStart + t * (viewState.frameEnd - viewState.frameStart);
    }
    function valueToScreenY(value) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (value - viewState.valueMin) / (viewState.valueMax - viewState.valueMin);
      return canvasHeight.value - margin.bottom - t * graphHeight;
    }
    function screenYToValue(screenY) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (canvasHeight.value - margin.bottom - screenY) / graphHeight;
      return viewState.valueMin + t * (viewState.valueMax - viewState.valueMin);
    }
    function getKeyframeScreenX(kf) {
      return frameToScreenX(kf.frame);
    }
    function getKeyframeScreenY(prop, kf) {
      const value = typeof kf.value === "number" ? kf.value : typeof kf.value === "object" ? kf.value.x ?? kf.value : 0;
      return valueToScreenY(value);
    }
    function getKeyframeDisplayValue(selection) {
      if (!selection) return 0;
      const value = selection.keyframe.value;
      return typeof value === "number" ? value : typeof value === "object" ? value.x ?? 0 : 0;
    }
    function getOutHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.outHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getOutHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.outHandle.value;
      return valueToScreenY(handleValue);
    }
    function getInHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.inHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getInHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.inHandle.value;
      return valueToScreenY(handleValue);
    }
    function getNumericValue(value) {
      if (typeof value === "number") return value;
      if (typeof value === "object") return value.x ?? value.y ?? value.z ?? 0;
      return 0;
    }
    function getPropertyColor(propId) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return propertyColors.default;
      return propertyColors[prop.name] ?? propertyColors.default;
    }
    function isKeyframeInView(kf) {
      return kf.frame >= viewState.frameStart && kf.frame <= viewState.frameEnd;
    }
    function isKeyframeSelected(propId, index) {
      return selectedKeyframes.value.some((sk) => sk.propId === propId && sk.index === index);
    }
    function hasDimension(prop, dim) {
      if (!prop.animated || prop.keyframes.length === 0) return false;
      const value = prop.keyframes[0].value;
      return typeof value === "object" && dim in value;
    }
    function toggleProperty(propId) {
      const index = selectedPropertyIds.value.indexOf(propId);
      if (index === -1) {
        selectedPropertyIds.value.push(propId);
      } else {
        selectedPropertyIds.value.splice(index, 1);
      }
    }
    function togglePropertyVisibility(propId) {
      const index = visiblePropertyIds.value.indexOf(propId);
      if (index === -1) {
        visiblePropertyIds.value.push(propId);
      } else {
        visiblePropertyIds.value.splice(index, 1);
      }
      updateViewBounds();
    }
    function toggleAllProperties() {
      if (allPropertiesVisible.value) {
        visiblePropertyIds.value = [];
      } else {
        visiblePropertyIds.value = animatableProperties.value.map((p) => p.id);
      }
      updateViewBounds();
    }
    function toggleDimension(propId, dim) {
      if (!visibleDimensions.value[propId]) {
        visibleDimensions.value[propId] = [];
      }
      const dims = visibleDimensions.value[propId];
      const index = dims.indexOf(dim);
      if (index === -1) {
        dims.push(dim);
      } else {
        dims.splice(index, 1);
      }
    }
    function fitToView() {
      const visible = visibleProperties.value;
      if (visible.length === 0) return;
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const prop of visible) {
        for (const kf of prop.keyframes) {
          minFrame = Math.min(minFrame, kf.frame);
          maxFrame = Math.max(maxFrame, kf.frame);
          const value = getNumericValue(kf.value);
          minValue = Math.min(minValue, value);
          maxValue = Math.max(maxValue, value);
        }
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
    }
    function updateViewBounds() {
      fitToView();
    }
    function toggleAutoSelect() {
      autoSelectNearby.value = !autoSelectNearby.value;
    }
    function isPresetActive(presetKey) {
      if (selectedKeyframes.value.length === 0) return false;
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return false;
      if (presetKey === "linear") {
        return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "linear");
      }
      return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "bezier");
    }
    function applyPreset(presetKey) {
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const propertyPath = getPropertyPath(prop);
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? sk.keyframe.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - sk.keyframe.frame : 10;
        if (presetKey === "linear") {
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "linear");
          sk.keyframe.interpolation = "linear";
          sk.keyframe.outHandle = { frame: outDuration * 0.33, value: 0, enabled: false };
          sk.keyframe.inHandle = { frame: -inDuration * 0.33, value: 0, enabled: false };
        } else {
          const outHandle = {
            frame: preset.outHandle.x * outDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          const inHandle = {
            frame: -preset.inHandle.x * inDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "bezier");
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "out", outHandle);
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "in", inHandle);
          sk.keyframe.interpolation = "bezier";
          sk.keyframe.outHandle = outHandle;
          sk.keyframe.inHandle = inHandle;
        }
      }
      drawGraph();
    }
    function handleMouseDown(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 1 || event.button === 0 && event.altKey) {
        dragTarget.value = { type: "pan", startX: x, startY: y };
      } else if (event.button === 0) {
        if (!event.shiftKey) {
          selectedKeyframes.value = [];
        }
        selectionBox.value = { x, y, width: 0, height: 0 };
        dragTarget.value = { type: "select", startX: x, startY: y };
      }
    }
    function handleMouseMove(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      updateHoveredKeyframe(x, y);
      if (!dragTarget.value) return;
      if (dragTarget.value.type === "pan") {
        const dx = x - (dragTarget.value.startX ?? 0);
        const dy = y - (dragTarget.value.startY ?? 0);
        const graphWidth = canvasWidth.value - margin.left - margin.right;
        const graphHeight = canvasHeight.value - margin.top - margin.bottom;
        const frameShift = -dx / graphWidth * (viewState.frameEnd - viewState.frameStart);
        const valueShift = dy / graphHeight * (viewState.valueMax - viewState.valueMin);
        viewState.frameStart += frameShift;
        viewState.frameEnd += frameShift;
        viewState.valueMin += valueShift;
        viewState.valueMax += valueShift;
        dragTarget.value.startX = x;
        dragTarget.value.startY = y;
        drawGraph();
      } else if (dragTarget.value.type === "select" && selectionBox.value) {
        const startX = dragTarget.value.startX ?? 0;
        const startY = dragTarget.value.startY ?? 0;
        selectionBox.value = {
          x: Math.min(x, startX),
          y: Math.min(y, startY),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY)
        };
      } else if (dragTarget.value.type === "keyframe") {
        moveSelectedKeyframes(x, y);
      } else if (dragTarget.value.type === "outHandle" || dragTarget.value.type === "inHandle") {
        moveHandle(x, y);
      }
    }
    function handleMouseUp() {
      if (dragTarget.value?.type === "select" && selectionBox.value) {
        selectKeyframesInBox();
      }
      dragTarget.value = null;
      selectionBox.value = null;
    }
    function handleWheel(event) {
      event.preventDefault();
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
      const frameAtCursor = screenXToFrame(x);
      const newFrameStart = frameAtCursor - (frameAtCursor - viewState.frameStart) * zoomFactor;
      const newFrameEnd = frameAtCursor + (viewState.frameEnd - frameAtCursor) * zoomFactor;
      if (event.shiftKey) {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
      } else {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
        const y = event.clientY - rect.top;
        const valueAtCursor = screenYToValue(y);
        viewState.valueMin = valueAtCursor - (valueAtCursor - viewState.valueMin) * zoomFactor;
        viewState.valueMax = valueAtCursor + (viewState.valueMax - valueAtCursor) * zoomFactor;
      }
      drawGraph();
    }
    function updateHoveredKeyframe(x, y) {
      hoveredKeyframe.value = null;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const kfX = getKeyframeScreenX(kf);
          const kfY = getKeyframeScreenY(prop, kf);
          const dist = Math.sqrt((x - kfX) ** 2 + (y - kfY) ** 2);
          if (dist < 10) {
            hoveredKeyframe.value = { propId: prop.id, index: i };
            return;
          }
        }
      }
    }
    function onKeyframeMouseDown(propId, index, event) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return;
      const kf = prop.keyframes[index];
      if (!event.shiftKey) {
        selectedKeyframes.value = [];
      }
      if (!isKeyframeSelected(propId, index)) {
        selectedKeyframes.value.push({ propId, index, keyframe: kf });
      }
      dragTarget.value = { type: "keyframe", propId, index };
    }
    function selectKeyframesInBox() {
      if (!selectionBox.value) return;
      const box = selectionBox.value;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const x = getKeyframeScreenX(kf);
          const y = getKeyframeScreenY(prop, kf);
          if (x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height) {
            if (!isKeyframeSelected(prop.id, i)) {
              selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: kf });
            }
          }
        }
      }
    }
    function moveSelectedKeyframes(screenX, screenY) {
      const newFrame = Math.round(screenXToFrame(screenX));
      const newValue = screenYToValue(screenY);
      const layer = store.selectedLayer;
      if (!layer) return;
      if (selectedKeyframes.value.length > 0) {
        const sk = selectedKeyframes.value[0];
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) return;
        const frame = snapEnabled.value ? Math.round(newFrame / 5) * 5 : newFrame;
        const propertyPath = getPropertyPath(prop);
        store.updateKeyframe(layer.id, propertyPath, sk.keyframe.id, {
          frame,
          value: typeof sk.keyframe.value === "number" ? newValue : void 0
        });
        sk.keyframe.frame = frame;
        if (typeof sk.keyframe.value === "number") {
          sk.keyframe.value = newValue;
        }
      }
      drawGraph();
    }
    function getPropertyPath(prop) {
      const name = prop.name.toLowerCase();
      if (name === "position") return "transform.position";
      if (name === "scale") return "transform.scale";
      if (name === "rotation") return "transform.rotation";
      if (name === "opacity") return "opacity";
      if (name === "anchor point") return "transform.anchorPoint";
      return prop.id;
    }
    function startDragHandle(type, propId, index, event) {
      dragTarget.value = { type, propId, index };
      document.addEventListener("mousemove", onDragHandle);
      document.addEventListener("mouseup", stopDragHandle);
    }
    function onDragHandle(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect || !dragTarget.value) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      moveHandle(x, y);
    }
    function moveHandle(screenX, screenY) {
      if (!dragTarget.value || !dragTarget.value.propId) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = animatableProperties.value.find((p) => p.id === dragTarget.value.propId);
      if (!prop) return;
      const kfIndex = dragTarget.value.index;
      const kf = prop.keyframes[kfIndex];
      if (!kf) return;
      const handleFrame = screenXToFrame(screenX);
      const handleValue = screenYToValue(screenY);
      const propertyPath = getPropertyPath(prop);
      if (dragTarget.value.type === "outHandle") {
        const nextKf = prop.keyframes[kfIndex + 1];
        let frameOffset = handleFrame - kf.frame;
        if (nextKf) {
          frameOffset = Math.max(0, Math.min(nextKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.max(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", newHandle);
        kf.outHandle = newHandle;
        kf.interpolation = "bezier";
        applyControlModeConstraints(kf, "out", propertyPath);
      } else if (dragTarget.value.type === "inHandle") {
        const prevKf = prop.keyframes[kfIndex - 1];
        let frameOffset = handleFrame - kf.frame;
        if (prevKf) {
          frameOffset = Math.min(0, Math.max(prevKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.min(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", newHandle);
        kf.inHandle = newHandle;
        applyControlModeConstraints(kf, "in", propertyPath);
      }
      drawGraph();
    }
    function applyControlModeConstraints(kf, changedHandle, propertyPath) {
      if (!kf.controlMode || kf.controlMode === "corner") {
        return;
      }
      const layer = store.selectedLayer;
      if (!layer) return;
      if (kf.controlMode === "symmetric") {
        if (changedHandle === "in") {
          kf.outHandle.frame = -kf.inHandle.frame;
          kf.outHandle.value = -kf.inHandle.value;
          kf.outHandle.enabled = kf.inHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", { ...kf.outHandle });
        } else {
          kf.inHandle.frame = -kf.outHandle.frame;
          kf.inHandle.value = -kf.outHandle.value;
          kf.inHandle.enabled = kf.outHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", { ...kf.inHandle });
        }
      }
      if (kf.controlMode === "smooth") {
        const changed = changedHandle === "in" ? kf.inHandle : kf.outHandle;
        const other = changedHandle === "in" ? kf.outHandle : kf.inHandle;
        const otherType = changedHandle === "in" ? "out" : "in";
        if (changed.frame !== 0 || changed.value !== 0) {
          const angle = Math.atan2(changed.value, changed.frame);
          const oppositeAngle = angle + Math.PI;
          const otherLength = Math.hypot(other.frame, other.value);
          other.frame = Math.cos(oppositeAngle) * otherLength;
          other.value = Math.sin(oppositeAngle) * otherLength;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, otherType, { ...other });
        }
      }
    }
    function stopDragHandle() {
      dragTarget.value = null;
      document.removeEventListener("mousemove", onDragHandle);
      document.removeEventListener("mouseup", stopDragHandle);
    }
    function showContextMenu(event) {
      contextMenu.value = { x: event.offsetX, y: event.offsetY };
    }
    function addKeyframeAtPosition() {
      if (!contextMenu.value) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const frame = Math.round(screenXToFrame(contextMenu.value.x));
      const value = screenYToValue(contextMenu.value.y);
      if (visibleProperties.value.length > 0) {
        const prop = visibleProperties.value[0];
        const propertyPath = getPropertyPath(prop);
        const keyframeValue = typeof prop.value === "number" ? value : { x: value, y: value };
        store.addKeyframe(layer.id, propertyPath, keyframeValue, frame);
        drawGraph();
      }
      contextMenu.value = null;
    }
    function deleteSelectedKeyframes() {
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (prop) {
          const propertyPath = getPropertyPath(prop);
          store.removeKeyframe(layer.id, propertyPath, sk.keyframe.id);
        }
      }
      selectedKeyframes.value = [];
      drawGraph();
    }
    function copyKeyframes() {
      clipboard.value = selectedKeyframes.value.map((sk) => ({ ...sk.keyframe }));
    }
    function pasteKeyframes() {
      if (!clipboard.value || visibleProperties.value.length === 0) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = visibleProperties.value[0];
      const propertyPath = getPropertyPath(prop);
      const offset = store.currentFrame - clipboard.value[0].frame;
      for (const kf of clipboard.value) {
        const newFrame = kf.frame + offset;
        const newKeyframe = store.addKeyframe(layer.id, propertyPath, kf.value, newFrame);
        if (newKeyframe) {
          if (kf.interpolation !== "linear") {
            store.setKeyframeInterpolation(layer.id, propertyPath, newKeyframe.id, kf.interpolation);
          }
          if (kf.inHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "in", kf.inHandle);
          }
          if (kf.outHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "out", kf.outHandle);
          }
        }
      }
      drawGraph();
    }
    function selectAllKeyframes() {
      selectedKeyframes.value = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
        }
      }
    }
    function invertSelection() {
      const newSelection = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          if (!isKeyframeSelected(prop.id, i)) {
            newSelection.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
          }
        }
      }
      selectedKeyframes.value = newSelection;
    }
    function updateSelectedKeyframeFrame(event) {
      const value = parseInt(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        selectedKeyframes.value[0].keyframe.frame = value;
        drawGraph();
      }
    }
    function updateSelectedKeyframeValue(event) {
      const value = parseFloat(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        const kf = selectedKeyframes.value[0].keyframe;
        if (typeof kf.value === "number") {
          kf.value = value;
        } else if (typeof kf.value === "object") {
          kf.value.x = value;
        }
        drawGraph();
      }
    }
    function updateSelectedKeyframeInterpolation(event) {
      const value = event.target.value;
      if (selectedKeyframes.value.length > 0) {
        selectedKeyframes.value[0].keyframe.interpolation = value;
        drawGraph();
      }
    }
    function onTimeRulerClick(event) {
      const rect = timeRulerCanvas.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const frame = Math.round(screenXToFrame(x));
      store.setFrame(frame);
    }
    function drawGraph() {
      drawMainCanvas();
      drawTimeRuler();
      drawValueAxis();
    }
    function drawMainCanvas() {
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = canvasWidth.value;
      canvas.height = canvasHeight.value;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
      drawGrid(ctx);
      for (const prop of visibleProperties.value) {
        drawPropertyCurve(ctx, prop);
      }
    }
    function drawGrid(ctx) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, graphWidth, 50);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, graphHeight, 30);
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
      ctx.strokeStyle = "#3a3a3a";
      ctx.lineWidth = 1;
      if (viewState.frameStart <= 0 && viewState.frameEnd >= 0) {
        const x = frameToScreenX(0);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      if (viewState.valueMin <= 0 && viewState.valueMax >= 0) {
        const y = valueToScreenY(0);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
    }
    function calculateGridStep(range, pixelSize, targetSpacing) {
      const rawStep = range * targetSpacing / pixelSize;
      const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const normalized = rawStep / magnitude;
      if (normalized <= 1) return magnitude;
      if (normalized <= 2) return 2 * magnitude;
      if (normalized <= 5) return 5 * magnitude;
      return 10 * magnitude;
    }
    function drawPropertyCurve(ctx, prop) {
      if (prop.keyframes.length < 2) return;
      const color = getPropertyColor(prop.id);
      for (let pass = 0; pass < 2; pass++) {
        if (pass === 0) {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < prop.keyframes.length - 1; i++) {
          const kf1 = prop.keyframes[i];
          const kf2 = prop.keyframes[i + 1];
          if (kf2.frame < viewState.frameStart || kf1.frame > viewState.frameEnd) continue;
          const x1 = getKeyframeScreenX(kf1);
          const y1 = getKeyframeScreenY(prop, kf1);
          const x2 = getKeyframeScreenX(kf2);
          const y2 = getKeyframeScreenY(prop, kf2);
          if (!started) {
            ctx.moveTo(x1, y1);
            started = true;
          }
          if (kf1.interpolation === "hold") {
            ctx.lineTo(x2, y1);
            ctx.lineTo(x2, y2);
          } else if (kf1.interpolation === "linear" || !kf1.outHandle.enabled && !kf2.inHandle.enabled) {
            ctx.lineTo(x2, y2);
          } else {
            const cp1x = frameToScreenX(kf1.frame + kf1.outHandle.frame);
            const cp1y = valueToScreenY(getNumericValue(kf1.value) + kf1.outHandle.value);
            const cp2x = frameToScreenX(kf2.frame + kf2.inHandle.frame);
            const cp2y = valueToScreenY(getNumericValue(kf2.value) + kf2.inHandle.value);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
          }
        }
        ctx.stroke();
      }
    }
    function drawTimeRuler() {
      const canvas = timeRulerCanvas.value;
      if (!canvas) return;
      const rect = timeRulerRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = rect.width;
      canvas.height = 24;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, canvas.width, 60);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.fillText(frame.toString(), x, 16);
        ctx.strokeStyle = "#444";
        ctx.beginPath();
        ctx.moveTo(x, 20);
        ctx.lineTo(x, 24);
        ctx.stroke();
      }
      const ctfX = frameToScreenX(store.currentFrame);
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.moveTo(ctfX - 5, 0);
      ctx.lineTo(ctfX + 5, 0);
      ctx.lineTo(ctfX, 8);
      ctx.closePath();
      ctx.fill();
    }
    function drawValueAxis() {
      const canvas = valueAxisCanvas.value;
      if (!canvas) return;
      const rect = valueAxisRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = 40;
      canvas.height = rect.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, canvas.height, 30);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.fillText(value.toFixed(0), 36, y + 4);
      }
    }
    function applyEasyEase(direction = "both") {
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const kf = sk.keyframe;
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? kf.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - kf.frame : 10;
        const influence = 0.3333;
        if (direction === "both" || direction === "in") {
          kf.inHandle = {
            frame: -inDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        if (direction === "both" || direction === "out") {
          kf.outHandle = {
            frame: outDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        kf.interpolation = "bezier";
        kf.controlMode = "smooth";
      }
      drawGraph();
    }
    function goToPreviousKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const prev = [...allKeyframes].reverse().find((f) => f < currentFrame);
      if (prev !== void 0) {
        store.setFrame(prev);
      }
    }
    function goToNextKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const next = allKeyframes.find((f) => f > currentFrame);
      if (next !== void 0) {
        store.setFrame(next);
      }
    }
    function handleKeyDown(event) {
      if (event.key === "F9") {
        event.preventDefault();
        if (event.ctrlKey && event.shiftKey) {
          applyEasyEase("out");
        } else if (event.shiftKey) {
          applyEasyEase("in");
        } else {
          applyEasyEase("both");
        }
        return;
      }
      if (event.key.toLowerCase() === "j") {
        event.preventDefault();
        goToPreviousKeyframe();
        return;
      }
      if (event.key.toLowerCase() === "k") {
        event.preventDefault();
        goToNextKeyframe();
        return;
      }
      if (event.key === "Delete" || event.key === "Backspace") {
        event.preventDefault();
        deleteSelectedKeyframes();
        return;
      }
      if (event.key.toLowerCase() === "f" && !event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          fitToView();
        } else if (selectedKeyframes.value.length > 0) {
          fitSelectionToView();
        } else {
          fitToView();
        }
        return;
      }
      if (event.key === "=" || event.key === "+") {
        event.preventDefault();
        zoomIn();
        return;
      }
      if (event.key === "-" || event.key === "_") {
        event.preventDefault();
        zoomOut();
        return;
      }
    }
    function fitSelectionToView() {
      if (selectedKeyframes.value.length === 0) {
        fitToView();
        return;
      }
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const sk of selectedKeyframes.value) {
        minFrame = Math.min(minFrame, sk.keyframe.frame);
        maxFrame = Math.max(maxFrame, sk.keyframe.frame);
        const value = getNumericValue(sk.keyframe.value);
        minValue = Math.min(minValue, value);
        maxValue = Math.max(maxValue, value);
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
      drawGraph();
    }
    function zoomIn() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.4;
      viewState.frameEnd = centerFrame + frameRange * 0.4;
      drawGraph();
    }
    function zoomOut() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.6;
      viewState.frameEnd = centerFrame + frameRange * 0.6;
      drawGraph();
    }
    let resizeObserver = null;
    onMounted(() => {
      if (canvasContainerRef.value) {
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            canvasWidth.value = entry.contentRect.width;
            canvasHeight.value = entry.contentRect.height;
            drawGraph();
          }
        });
        resizeObserver.observe(canvasContainerRef.value);
      }
      visiblePropertyIds.value = animatableProperties.value.filter((p) => p.animated).map((p) => p.id);
      window.addEventListener("keydown", handleKeyDown);
      fitToView();
      drawGraph();
    });
    onUnmounted(() => {
      resizeObserver?.disconnect();
      window.removeEventListener("keydown", handleKeyDown);
    });
    watch([() => store.currentFrame, visiblePropertyIds, mode], () => {
      drawGraph();
    });
    watch(animatableProperties, () => {
      fitToView();
      drawGraph();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$6, [
          _cache[9] || (_cache[9] = createBaseVNode("span", { class: "graph-title" }, "Graph Editor", -1)),
          createBaseVNode("div", _hoisted_3$6, [
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "value" }),
              onClick: _cache[0] || (_cache[0] = ($event) => mode.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "speed" }),
              onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          createBaseVNode("div", _hoisted_4$6, [
            (openBlock(), createElementBlock(Fragment, null, renderList(presetList, (preset) => {
              return createBaseVNode("button", {
                key: preset.key,
                class: normalizeClass(["preset-btn", { active: isPresetActive(preset.key) }]),
                onClick: ($event) => applyPreset(preset.key),
                title: preset.label
              }, toDisplayString(preset.shortLabel), 11, _hoisted_5$6);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_6$6, [
            createBaseVNode("button", {
              onClick: fitToView,
              title: "Fit to View"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("span", { class: "icon" }, "[ ]", -1)
            ])]),
            createBaseVNode("button", {
              onClick: toggleAutoSelect,
              class: normalizeClass({ active: autoSelectNearby.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("span", { class: "icon" }, "A", -1)
            ])], 2),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => snapEnabled.value = !snapEnabled.value),
              class: normalizeClass({ active: snapEnabled.value }),
              title: "Snap to Grid"
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          createBaseVNode("button", {
            class: "close-btn",
            onClick: _cache[3] || (_cache[3] = ($event) => emit("close"))
          }, [..._cache[8] || (_cache[8] = [
            createBaseVNode("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        createBaseVNode("div", _hoisted_7$6, [
          createBaseVNode("div", _hoisted_8$6, [
            createBaseVNode("div", _hoisted_9$6, [
              _cache[10] || (_cache[10] = createTextVNode(" Properties ", -1)),
              createBaseVNode("button", {
                class: "toggle-all-btn",
                onClick: toggleAllProperties,
                title: allPropertiesVisible.value ? "Hide All" : "Show All"
              }, toDisplayString(allPropertiesVisible.value ? "Hide" : "Show"), 9, _hoisted_10$6)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(animatableProperties.value, (prop) => {
              return openBlock(), createElementBlock("div", {
                key: prop.id,
                class: normalizeClass(["property-item", {
                  selected: selectedPropertyIds.value.includes(prop.id),
                  animated: prop.animated
                }])
              }, [
                createBaseVNode("div", {
                  class: "property-row",
                  onClick: ($event) => toggleProperty(prop.id)
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(["visibility-toggle", { visible: visiblePropertyIds.value.includes(prop.id) }]),
                    onClick: withModifiers(($event) => togglePropertyVisibility(prop.id), ["stop"])
                  }, null, 10, _hoisted_12$6),
                  createBaseVNode("span", {
                    class: "property-color",
                    style: normalizeStyle({ background: getPropertyColor(prop.id) })
                  }, null, 4),
                  createBaseVNode("span", _hoisted_13$6, toDisplayString(prop.name), 1),
                  prop.animated ? (openBlock(), createElementBlock("span", _hoisted_14$6, toDisplayString(prop.keyframes.length), 1)) : createCommentVNode("", true)
                ], 8, _hoisted_11$6),
                prop.name === "Position" || prop.name === "Scale" ? (openBlock(), createElementBlock("div", _hoisted_15$6, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(["x", "y", "z"], (dim) => {
                    return createBaseVNode("button", {
                      key: dim,
                      class: normalizeClass({
                        active: visibleDimensions.value[prop.id]?.includes(dim),
                        hasValue: hasDimension(prop, dim)
                      }),
                      onClick: ($event) => toggleDimension(prop.id, dim)
                    }, toDisplayString(dim.toUpperCase()), 11, _hoisted_16$6);
                  }), 64))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128)),
            animatableProperties.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_17$6, " No animated properties ")) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$6, [
            createBaseVNode("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: timeRulerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "timeRulerCanvas",
                ref: timeRulerCanvas,
                onClick: onTimeRulerClick
              }, null, 512)
            ], 512),
            createBaseVNode("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "canvasRef",
                ref: canvasRef,
                onMousedown: handleMouseDown,
                onMousemove: handleMouseMove,
                onMouseup: handleMouseUp,
                onMouseleave: handleMouseUp,
                onWheel: handleWheel,
                onContextmenu: withModifiers(showContextMenu, ["prevent"])
              }, null, 544),
              selectionBox.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "selection-box",
                style: normalizeStyle({
                  left: selectionBox.value.x + "px",
                  top: selectionBox.value.y + "px",
                  width: selectionBox.value.width + "px",
                  height: selectionBox.value.height + "px"
                })
              }, null, 4)) : createCommentVNode("", true),
              (openBlock(), createElementBlock("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleProperties.value, (prop) => {
                  return openBlock(), createElementBlock("g", {
                    key: prop.id,
                    class: "property-handles"
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(prop.keyframes, (kf, kfIndex) => {
                      return openBlock(), createElementBlock(Fragment, { key: kfIndex }, [
                        isKeyframeInView(kf) ? (openBlock(), createElementBlock("g", {
                          key: 0,
                          class: normalizeClass(["keyframe-marker", {
                            selected: isKeyframeSelected(prop.id, kfIndex),
                            hovered: hoveredKeyframe.value?.propId === prop.id && hoveredKeyframe.value?.index === kfIndex
                          }]),
                          onMousedown: withModifiers(($event) => onKeyframeMouseDown(prop.id, kfIndex, $event), ["stop"])
                        }, [
                          createBaseVNode("rect", {
                            x: getKeyframeScreenX(kf) - 5,
                            y: getKeyframeScreenY(prop, kf) - 5,
                            width: "10",
                            height: "10",
                            fill: getPropertyColor(prop.id),
                            "transform-origin": "center",
                            transform: `rotate(45, ${getKeyframeScreenX(kf)}, ${getKeyframeScreenY(prop, kf)})`
                          }, null, 8, _hoisted_21$6)
                        ], 42, _hoisted_20$6)) : createCommentVNode("", true),
                        isKeyframeSelected(prop.id, kfIndex) && kf.interpolation !== "hold" ? (openBlock(), createElementBlock("g", _hoisted_22$6, [
                          prop.keyframes[kfIndex + 1] && (kf.outHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_23$6, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getOutHandleX(prop, kfIndex),
                              y2: getOutHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_24$4),
                            createBaseVNode("circle", {
                              cx: getOutHandleX(prop, kfIndex),
                              cy: getOutHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "outHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("outHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_25$4)
                          ])) : createCommentVNode("", true),
                          kfIndex > 0 && (kf.inHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_26$4, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getInHandleX(prop, kfIndex),
                              y2: getInHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_27$4),
                            createBaseVNode("circle", {
                              cx: getInHandleX(prop, kfIndex),
                              cy: getInHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "inHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("inHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_28$4)
                          ])) : createCommentVNode("", true)
                        ])) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]);
                }), 128)),
                createBaseVNode("line", {
                  x1: currentFrameScreenX.value,
                  y1: 0,
                  x2: currentFrameScreenX.value,
                  y2: canvasHeight.value,
                  class: "current-time-line"
                }, null, 8, _hoisted_29$4)
              ], 8, _hoisted_19$6))
            ], 512),
            createBaseVNode("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: valueAxisRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "valueAxisCanvas",
                ref: valueAxisCanvas
              }, null, 512)
            ], 512)
          ])
        ]),
        selectedKeyframes.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$4, [
          createBaseVNode("div", _hoisted_31$2, [
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "info-label" }, "Frame:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: selectedKeyframes.value[0]?.keyframe.frame,
              onChange: updateSelectedKeyframeFrame,
              class: "info-input"
            }, null, 40, _hoisted_32$2)
          ]),
          createBaseVNode("div", _hoisted_33$2, [
            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "info-label" }, "Value:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: getKeyframeDisplayValue(selectedKeyframes.value[0]),
              onChange: updateSelectedKeyframeValue,
              class: "info-input",
              step: "0.1"
            }, null, 40, _hoisted_34$2)
          ]),
          createBaseVNode("div", _hoisted_35$2, [
            _cache[14] || (_cache[14] = createBaseVNode("span", { class: "info-label" }, "Interpolation:", -1)),
            createBaseVNode("select", {
              value: selectedKeyframes.value[0]?.keyframe.interpolation,
              onChange: updateSelectedKeyframeInterpolation,
              class: "info-select"
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "linear" }, "Linear", -1),
              createBaseVNode("option", { value: "bezier" }, "Bezier", -1),
              createBaseVNode("option", { value: "hold" }, "Hold", -1)
            ])], 40, _hoisted_36$2)
          ])
        ])) : createCommentVNode("", true),
        contextMenu.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "context-menu",
          style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
          onClick: _cache[4] || (_cache[4] = ($event) => contextMenu.value = null)
        }, [
          createBaseVNode("button", { onClick: addKeyframeAtPosition }, "Add Keyframe"),
          createBaseVNode("button", {
            onClick: deleteSelectedKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Delete Keyframe(s)", 8, _hoisted_37$2),
          _cache[15] || (_cache[15] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", {
            onClick: copyKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Copy", 8, _hoisted_38$2),
          createBaseVNode("button", {
            onClick: pasteKeyframes,
            disabled: !clipboard.value
          }, "Paste", 8, _hoisted_39$2),
          _cache[16] || (_cache[16] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", { onClick: selectAllKeyframes }, "Select All"),
          createBaseVNode("button", { onClick: invertSelection }, "Invert Selection")
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
});

const GraphEditor = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-70deec8d"]]);

// math-inlining.
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;

// cube root function yielding real roots
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}

// trig constants
const pi$1 = Math.PI,
  tau = 2 * pi$1,
  quart = pi$1 / 2,
  // float precision significant decimal
  epsilon = 0.000001,
  // extremas used in bbox calculation and similar algorithms
  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,
  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,
  // a zero coordinate, which is surprisingly useful
  ZERO = { x: 0, y: 0, z: 0 };

// Bezier utility functions
const utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.0640568928626056260850430826247450385909,
    -0.1911188674736163,
    0.1911188674736163091586398207570696318404,
    -0.3150426796961634,
    0.3150426796961633743867932913198102407864,
    -0.4337935076260451,
    0.4337935076260451384870842319133497124524,
    -0.5454214713888396,
    0.5454214713888395356583756172183723700107,
    -0.6480936519369755,
    0.6480936519369755692524957869107476266696,
    -0.7401241915785544,
    0.7401241915785543642438281030999784255232,
    -0.820001985973903,
    0.8200019859739029219539498726697452080761,
    -0.8864155270044011,
    0.8864155270044010342131543419821967550873,
    -0.9382745520027328,
    0.9382745520027327585236490017087214496548,
    -0.9747285559713095,
    0.9747285559713094981983919930081690617411,
    -0.9951872199970213,
    0.9951872199970213601799974097007368118745,
  ],

  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.1279381953467521569740561652246953718517,
    0.1279381953467521569740561652246953718517,
    0.1258374563468282961213753825111836887264,
    0.1258374563468282961213753825111836887264,
    0.121670472927803391204463153476262425607,
    0.121670472927803391204463153476262425607,
    0.1155056680537256013533444839067835598622,
    0.1155056680537256013533444839067835598622,
    0.1074442701159656347825773424466062227946,
    0.1074442701159656347825773424466062227946,
    0.0976186521041138882698806644642471544279,
    0.0976186521041138882698806644642471544279,
    0.086190161531953275917185202983742667185,
    0.086190161531953275917185202983742667185,
    0.0733464814110803057340336152531165181193,
    0.0733464814110803057340336152531165181193,
    0.0592985849154367807463677585001085845412,
    0.0592985849154367807463677585001085845412,
    0.0442774388174198061686027482113382288593,
    0.0442774388174198061686027482113382288593,
    0.0285313886289336631813078159518782864491,
    0.0285313886289336631813078159518782864491,
    0.0123412297999871995468056670700372915759,
    0.0123412297999871995468056670700372915759,
  ],

  arcfn: function (t, derivativeFn) {
    const d = derivativeFn(t);
    let l = d.x * d.x + d.y * d.y;
    if (typeof d.z !== "undefined") {
      l += d.z * d.z;
    }
    return sqrt$1(l);
  },

  compute: function (t, points, _3d) {
    // shortcuts
    if (t === 0) {
      points[0].t = 0;
      return points[0];
    }

    const order = points.length - 1;

    if (t === 1) {
      points[order].t = 1;
      return points[order];
    }

    const mt = 1 - t;
    let p = points;

    // constant?
    if (order === 0) {
      points[0].t = t;
      return points[0];
    }

    // linear?
    if (order === 1) {
      const ret = {
        x: mt * p[0].x + t * p[1].x,
        y: mt * p[0].y + t * p[1].y,
        t: t,
      };
      if (_3d) {
        ret.z = mt * p[0].z + t * p[1].z;
      }
      return ret;
    }

    // quadratic/cubic curve?
    if (order < 4) {
      let mt2 = mt * mt,
        t2 = t * t,
        a,
        b,
        c,
        d = 0;
      if (order === 2) {
        p = [p[0], p[1], p[2], ZERO];
        a = mt2;
        b = mt * t * 2;
        c = t2;
      } else if (order === 3) {
        a = mt2 * mt;
        b = mt2 * t * 3;
        c = mt * t2 * 3;
        d = t * t2;
      }
      const ret = {
        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t,
      };
      if (_3d) {
        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
      }
      return ret;
    }

    // higher order curves: use de Casteljau's computation
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i = 0; i < dCpts.length - 1; i++) {
        dCpts[i] = {
          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,
        };
        if (typeof dCpts[i].z !== "undefined") {
          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t;
    return dCpts[0];
  },

  computeWithRatios: function (t, points, ratios, _3d) {
    const mt = 1 - t,
      r = ratios,
      p = points;

    let f1 = r[0],
      f2 = r[1],
      f3 = r[2],
      f4 = r[3],
      d;

    // spec for linear
    f1 *= mt;
    f2 *= t;

    if (p.length === 2) {
      d = f1 + f2;
      return {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
        t: t,
      };
    }

    // upgrade to quadratic
    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t * t;

    if (p.length === 3) {
      d = f1 + f2 + f3;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
        t: t,
      };
    }

    // upgrade to cubic
    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t * t * t;

    if (p.length === 4) {
      d = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: !_3d
          ? false
          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
        t: t,
      };
    }
  },

  derive: function (points, _3d) {
    const dpoints = [];
    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list = [];
      for (let j = 0, dpt; j < c; j++) {
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y),
        };
        if (_3d) {
          dpt.z = c * (p[j + 1].z - p[j].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p = list;
    }
    return dpoints;
  },

  between: function (v, m, M) {
    return (
      (m <= v && v <= M) ||
      utils.approximately(v, m) ||
      utils.approximately(v, M)
    );
  },

  approximately: function (a, b, precision) {
    return abs$1(a - b) <= (precision || epsilon);
  },

  length: function (derivativeFn) {
    const z = 0.5,
      len = utils.Tvalues.length;

    let sum = 0;

    for (let i = 0, t; i < len; i++) {
      t = z * utils.Tvalues[i] + z;
      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);
    }
    return z * sum;
  },

  map: function (v, ds, de, ts, te) {
    const d1 = de - ds,
      d2 = te - ts,
      v2 = v - ds,
      r = v2 / d1;
    return ts + d2 * r;
  },

  lerp: function (r, v1, v2) {
    const ret = {
      x: v1.x + r * (v2.x - v1.x),
      y: v1.y + r * (v2.y - v1.y),
    };
    if (v1.z !== undefined && v2.z !== undefined) {
      ret.z = v1.z + r * (v2.z - v1.z);
    }
    return ret;
  },

  pointToString: function (p) {
    let s = p.x + "/" + p.y;
    if (typeof p.z !== "undefined") {
      s += "/" + p.z;
    }
    return s;
  },

  pointsToString: function (points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },

  copy: function (obj) {
    return JSON.parse(JSON.stringify(obj));
  },

  angle: function (o, v1, v2) {
    const dx1 = v1.x - o.x,
      dy1 = v1.y - o.y,
      dx2 = v2.x - o.x,
      dy2 = v2.y - o.y,
      cross = dx1 * dy2 - dy1 * dx2,
      dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },

  // round as string, to avoid rounding errors
  round: function (v, d) {
    const s = "" + v;
    const pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },

  dist: function (p1, p2) {
    const dx = p1.x - p2.x,
      dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },

  closest: function (LUT, point) {
    let mdist = pow(2, 63),
      mpos,
      d;
    LUT.forEach(function (p, idx) {
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        mpos = idx;
      }
    });
    return { mdist: mdist, mpos: mpos };
  },

  abcratio: function (t, n) {
    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const bottom = pow(t, n) + pow(1 - t, n),
      top = bottom - 1;
    return abs$1(top / bottom);
  },

  projectionratio: function (t, n) {
    // see u(t) note on http://pomax.github.io/bezierinfo/#abc
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t === "undefined") {
      t = 0.5;
    } else if (t === 0 || t === 1) {
      return t;
    }
    const top = pow(1 - t, n),
      bottom = pow(t, n) + top;
    return top / bottom;
  },

  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx =
        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d == 0) {
      return false;
    }
    return { x: nx / d, y: ny / d };
  },

  lli4: function (p1, p2, p3, p4) {
    const x1 = p1.x,
      y1 = p1.y,
      x2 = p2.x,
      y2 = p2.y,
      x3 = p3.x,
      y3 = p3.y,
      x4 = p4.x,
      y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },

  lli: function (v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },

  makeline: function (p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },

  findbbox: function (sections) {
    let mx = nMax,
      my = nMax,
      MX = nMin,
      MY = nMin;
    sections.forEach(function (s) {
      const bbox = s.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },
    };
  },

  shapeintersections: function (
    s1,
    bbox1,
    s2,
    bbox2,
    curveIntersectionThreshold
  ) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function (l1) {
      if (l1.virtual) return;
      a2.forEach(function (l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },

  makeshape: function (forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward: forward,
      back: back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end]),
    };
    shape.intersections = function (s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },

  getminmax: function (curve, d, list) {
    if (!list) return { min: 0, max: 0 };
    let min = nMax,
      max = nMin,
      t,
      c;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i = 0, len = list.length; i < len; i++) {
      t = list[i];
      c = curve.get(t);
      if (c[d] < min) {
        min = c[d];
      }
      if (c[d] > max) {
        max = c[d];
      }
    }
    return { min: min, mid: (min + max) / 2, max: max, size: max - min };
  },

  align: function (points, line) {
    const tx = line.p1.x,
      ty = line.p1.y,
      a = -atan2(line.p2.y - ty, line.p2.x - tx),
      d = function (v) {
        return {
          x: (v.x - tx) * cos$1(a) - (v.y - ty) * sin$1(a),
          y: (v.x - tx) * sin$1(a) + (v.y - ty) * cos$1(a),
        };
      };
    return points.map(d);
  },

  roots: function (points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };

    const order = points.length - 1;
    const aligned = utils.align(points, line);
    const reduce = function (t) {
      return 0 <= t && t <= 1;
    };

    if (order === 2) {
      const a = aligned[0].y,
        b = aligned[1].y,
        c = aligned[2].y,
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2].filter(reduce);
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);
      }
      return [];
    }

    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm
    const pa = aligned[0].y,
      pb = aligned[1].y,
      pc = aligned[2].y,
      pd = aligned[3].y;

    let d = -pa + 3 * pb - 3 * pc + pd,
      a = 3 * pa - 6 * pb + 3 * pc,
      b = -3 * pa + 3 * pb,
      c = pa;

    if (utils.approximately(d, 0)) {
      // this is not a cubic curve.
      if (utils.approximately(a, 0)) {
        // in fact, this is not a quadratic curve either.
        if (utils.approximately(b, 0)) {
          // in fact in fact, there are no solutions.
          return [];
        }
        // linear solution:
        return [-c / b].filter(reduce);
      }
      // quadratic solution:
      const q = sqrt$1(b * b - 4 * a * c),
        a2 = 2 * a;
      return [(q - b) / a2, (-b - q) / a2].filter(reduce);
    }

    // at this point, we know we need a cubic solution:

    a /= d;
    b /= d;
    c /= d;

    const p = (3 * b - a * a) / 3,
      p3 = p / 3,
      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
      q2 = q / 2,
      discriminant = q2 * q2 + p3 * p3 * p3;

    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p / 3,
        mp33 = mp3 * mp3 * mp3,
        r = sqrt$1(mp33),
        t = -q / (2 * r),
        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
        phi = acos$1(cosphi),
        crtr = crt(r),
        t1 = 2 * crtr;
      x1 = t1 * cos$1(phi / 3) - a / 3;
      x2 = t1 * cos$1((phi + tau) / 3) - a / 3;
      x3 = t1 * cos$1((phi + 2 * tau) / 3) - a / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q2 < 0 ? crt(-q2) : -crt(q2);
      x1 = 2 * u1 - a / 3;
      x2 = -u1 - a / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt$1(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      return [u1 - v1 - a / 3].filter(reduce);
    }
  },

  droots: function (p) {
    // quadratic roots are easy
    if (p.length === 3) {
      const a = p[0],
        b = p[1],
        c = p[2],
        d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a * c),
          m2 = -a + b,
          v1 = -(m1 + m2) / d,
          v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * (b - c))];
      }
      return [];
    }

    // linear roots are even easier
    if (p.length === 2) {
      const a = p[0],
        b = p[1];
      if (a !== b) {
        return [a / (a - b)];
      }
      return [];
    }

    return [];
  },

  curvature: function (t, d1, d2, _3d, kOnly) {
    let num,
      dnm,
      adk,
      dk,
      k = 0,
      r = 0;

    //
    // We're using the following formula for curvature:
    //
    //              x'y" - y'x"
    //   k(t) = ------------------
    //           (x'Â² + y'Â²)^(3/2)
    //
    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition
    //
    // With it corresponding 3D counterpart:
    //
    //          sqrt( (y'z" - y"z')Â² + (z'x" - z"x')Â² + (x'y" - x"y')Â²)
    //   k(t) = -------------------------------------------------------
    //                     (x'Â² + y'Â² + z'Â²)^(3/2)
    //

    const d = utils.compute(t, d1);
    const dd = utils.compute(t, d2);
    const qdsum = d.x * d.x + d.y * d.y;

    if (_3d) {
      num = sqrt$1(
        pow(d.y * dd.z - dd.y * d.z, 2) +
          pow(d.z * dd.x - dd.z * d.x, 2) +
          pow(d.x * dd.y - dd.x * d.y, 2)
      );
      dnm = pow(qdsum + d.z * d.z, 3 / 2);
    } else {
      num = d.x * dd.y - d.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }

    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }

    k = num / dnm;
    r = dnm / num;

    // We're also computing the derivative of kappa, because
    // there is value in knowing the rate of change for the
    // curvature along the curve. And we're just going to
    // ballpark it based on an epsilon.
    if (!kOnly) {
      // compute k'(t) based on the interval before, and after it,
      // to at least try to not introduce forward/backward pass bias.
      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;
      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;
      dk = (nk - k + (k - pk)) / 2;
      adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }

    return { k: k, r: r, dk: dk, adk: adk };
  },

  inflections: function (points) {
    if (points.length < 4) return [];

    // FIXME: TODO: add in inflection abstraction for quartic+ curves?

    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),
      a = p[2].x * p[1].y,
      b = p[3].x * p[1].y,
      c = p[1].x * p[2].y,
      d = p[3].x * p[2].y,
      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),
      v2 = 18 * (3 * a - b - 3 * c),
      v3 = 18 * (c - a);

    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t = -v3 / v2;
        if (0 <= t && t <= 1) return [t];
      }
      return [];
    }

    const d2 = 2 * v1;

    if (utils.approximately(d2, 0)) return [];

    const trm = v2 * v2 - 4 * v1 * v3;

    if (trm < 0) return [];

    const sq = Math.sqrt(trm);

    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {
      return 0 <= r && r <= 1;
    });
  },

  bboxoverlap: function (b1, b2) {
    const dims = ["x", "y"],
      len = dims.length;

    for (let i = 0, dim, l, t, d; i < len; i++) {
      dim = dims[i];
      l = b1[dim].mid;
      t = b2[dim].mid;
      d = (b1[dim].size + b2[dim].size) / 2;
      if (abs$1(l - t) >= d) return false;
    }
    return true;
  },

  expandbox: function (bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },

  pairiteration: function (c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(),
      c2b = c2.bbox(),
      r = 100000,
      threshold = curveIntersectionThreshold || 0.5;

    if (
      c1b.x.size + c1b.y.size < threshold &&
      c2b.x.size + c2b.y.size < threshold
    ) {
      return [
        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +
          "/" +
          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,
      ];
    }

    let cc1 = c1.split(0.5),
      cc2 = c2.split(0.5),
      pairs = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left },
      ];

    pairs = pairs.filter(function (pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });

    let results = [];

    if (pairs.length === 0) return results;

    pairs.forEach(function (pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    });

    results = results.filter(function (v, i) {
      return results.indexOf(v) === i;
    });

    return results;
  },

  getccenter: function (p1, p2, p3) {
    const dx1 = p2.x - p1.x,
      dy1 = p2.y - p1.y,
      dx2 = p3.x - p2.x,
      dy2 = p3.y - p2.y,
      dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart),
      dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart),
      dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart),
      dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart),
      // chord midpoints
      mx1 = (p1.x + p2.x) / 2,
      my1 = (p1.y + p2.y) / 2,
      mx2 = (p2.x + p3.x) / 2,
      my2 = (p2.y + p3.y) / 2,
      // midpoint offsets
      mx1n = mx1 + dx1p,
      my1n = my1 + dy1p,
      mx2n = mx2 + dx2p,
      my2n = my2 + dy2p,
      // intersection of these lines:
      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),
      r = utils.dist(arc, p1);

    // arc start/end values, over mid point:
    let s = atan2(p1.y - arc.y, p1.x - arc.x),
      m = atan2(p2.y - arc.y, p2.x - arc.x),
      e = atan2(p3.y - arc.y, p3.x - arc.x),
      _;

    // determine arc direction (cw/ccw correction)
    if (s < e) {
      // if s<m<e, arc(s, e)
      // if m<s<e, arc(e, s + tau)
      // if s<e<m, arc(e, s + tau)
      if (s > m || m > e) {
        s += tau;
      }
      if (s > e) {
        _ = e;
        e = s;
        s = _;
      }
    } else {
      // if e<m<s, arc(e, s)
      // if m<e<s, arc(s, e + tau)
      // if e<s<m, arc(s, e + tau)
      if (e < m && m < s) {
        _ = e;
        e = s;
        s = _;
      } else {
        e += tau;
      }
    }
    // assign and done.
    arc.s = s;
    arc.e = e;
    arc.r = r;
    return arc;
  },

  numberSort: function (a, b) {
    return a - b;
  },
};

/**
 * Poly Bezier
 * @param {[type]} curves [description]
 */
class PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return (
      "[" +
      this.curves
        .map(function (curve) {
          return utils.pointsToString(curve.points);
        })
        .join(", ") +
      "]"
    );
  }

  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }

  length() {
    return this.curves
      .map(function (v) {
        return v.length();
      })
      .reduce(function (a, b) {
        return a + b;
      });
  }

  curve(idx) {
    return this.curves[idx];
  }

  bbox() {
    const c = this.curves;
    var bbox = c[0].bbox();
    for (var i = 1; i < c.length; i++) {
      utils.expandbox(bbox, c[i].bbox());
    }
    return bbox;
  }

  offset(d) {
    const offset = [];
    this.curves.forEach(function (v) {
      offset.push(...v.offset(d));
    });
    return new PolyBezier(offset);
  }
}

/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/


// math-inlining.
const { abs, min, max, cos, sin, acos, sqrt } = Math;
const pi = Math.PI;

/**
 * Bezier curve constructor.
 *
 * ...docs pending...
 */
class Bezier {
  constructor(coords) {
    let args =
      coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;

    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function (point) {
        ["x", "y", "z"].forEach(function (d) {
          if (typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }

    let higher = false;
    const len = args.length;

    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }

    const _3d = (this._3d =
      (!higher && (len === 9 || len === 12)) ||
      (coords && coords[0] && typeof coords[0].z !== "undefined"));

    const points = (this.points = []);
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1],
      };
      if (_3d) {
        point.z = args[idx + 2];
      }
      points.push(point);
    }
    const order = (this.order = points.length - 1);

    const dims = (this.dims = ["x", "y"]);
    if (_3d) dims.push("z");
    this.dimlen = dims.length;

    // is this curve, practically speaking, a straight line?
    const aligned = utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;

    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }

  static quadraticFromPoints(p1, p2, p3, t) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    // shortcuts, although they're really dumb
    if (t === 0) {
      return new Bezier(p2, p2, p3);
    }
    if (t === 1) {
      return new Bezier(p1, p2, p2);
    }
    // real fitting.
    const abc = Bezier.getABC(2, p1, p2, p3, t);
    return new Bezier(p1, abc.A, p3);
  }

  static cubicFromPoints(S, B, E, t, d1) {
    if (typeof t === "undefined") {
      t = 0.5;
    }
    const abc = Bezier.getABC(3, S, B, E, t);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B, abc.C);
    }
    const d2 = (d1 * (1 - t)) / t;

    const selen = utils.dist(S, E),
      lx = (E.x - S.x) / selen,
      ly = (E.y - S.y) / selen,
      bx1 = d1 * lx,
      by1 = d1 * ly,
      bx2 = d2 * lx,
      by2 = d2 * ly;
    // derivation of new hull coordinates
    const e1 = { x: B.x - bx1, y: B.y - by1 },
      e2 = { x: B.x + bx2, y: B.y + by2 },
      A = abc.A,
      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },
      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },
      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },
      nc2 = {
        x: E.x + (v2.x - E.x) / (1 - t),
        y: E.y + (v2.y - E.y) / (1 - t),
      };
    // ...done
    return new Bezier(S, nc1, nc2, E);
  }

  static getUtils() {
    return utils;
  }

  getUtils() {
    return Bezier.getUtils();
  }

  static get PolyBezier() {
    return PolyBezier;
  }

  valueOf() {
    return this.toString();
  }

  toString() {
    return utils.pointsToString(this.points);
  }

  toSVG() {
    if (this._3d) return false;
    const p = this.points,
      x = p[0].x,
      y = p[0].y,
      s = ["M", x, y, this.order === 2 ? "Q" : "C"];
    for (let i = 1, last = p.length; i < last; i++) {
      s.push(p[i].x);
      s.push(p[i].y);
    }
    return s.join(" ");
  }

  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = []; //  invalidate any precomputed LUT
  }

  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }

  coordDigest() {
    return this.points
      .map(function (c, pos) {
        return "" + pos + c.x + c.y + (c.z ? c.z : 0);
      })
      .join("");
  }

  update() {
    // invalidate any precomputed LUT
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }

  computedirection() {
    const points = this.points;
    const angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }

  length() {
    return utils.length(this.derivative.bind(this));
  }

  static getABC(order = 2, S, B, E, t = 0.5) {
    const u = utils.projectionratio(t, order),
      um = 1 - u,
      C = {
        x: u * S.x + um * E.x,
        y: u * S.y + um * E.y,
      },
      s = utils.abcratio(t, order),
      A = {
        x: B.x + (B.x - C.x) / s,
        y: B.y + (B.y - C.y) / s,
      };
    return { A, B, C, S, E };
  }

  getABC(t, B) {
    B = B || this.get(t);
    let S = this.points[0];
    let E = this.points[this.order];
    return Bezier.getABC(this.order, S, B, E, t);
  }

  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) {
      return this._lut;
    }
    this._lut = [];
    // n steps means n+1 points
    steps++;
    this._lut = [];
    for (let i = 0, p, t; i < steps; i++) {
      t = i / (steps - 1);
      p = this.compute(t);
      p.t = t;
      this._lut.push(p);
    }
    return this._lut;
  }

  on(point, error) {
    error = error || 5;
    const lut = this.getLUT(),
      hits = [];
    for (let i = 0, c, t = 0; i < lut.length; i++) {
      c = lut[i];
      if (utils.dist(c, point) < error) {
        hits.push(c);
        t += i / lut.length;
      }
    }
    if (!hits.length) return false;
    return (t /= hits.length);
  }

  project(point) {
    // step 1: coarse check
    const LUT = this.getLUT(),
      l = LUT.length - 1,
      closest = utils.closest(LUT, point),
      mpos = closest.mpos,
      t1 = (mpos - 1) / l,
      t2 = (mpos + 1) / l,
      step = 0.1 / l;

    // step 2: fine check
    let mdist = closest.mdist,
      t = t1,
      ft = t,
      p;
    mdist += 1;
    for (let d; t < t2 + step; t += step) {
      p = this.compute(t);
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        ft = t;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p = this.compute(ft);
    p.t = ft;
    p.d = mdist;
    return p;
  }

  get(t) {
    return this.compute(t);
  }

  point(idx) {
    return this.points[idx];
  }

  compute(t) {
    if (this.ratios) {
      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);
    }
    return utils.compute(t, this.points, this._3d, this.ratios);
  }

  raise() {
    const p = this.points,
      np = [p[0]],
      k = p.length;
    for (let i = 1, pi, pim; i < k; i++) {
      pi = p[i];
      pim = p[i - 1];
      np[i] = {
        x: ((k - i) / k) * pi.x + (i / k) * pim.x,
        y: ((k - i) / k) * pi.y + (i / k) * pim.y,
      };
    }
    np[k] = p[k - 1];
    return new Bezier(np);
  }

  derivative(t) {
    return utils.compute(t, this.dpoints[0], this._3d);
  }

  dderivative(t) {
    return utils.compute(t, this.dpoints[1], this._3d);
  }

  align() {
    let p = this.points;
    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
  }

  curvature(t) {
    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);
  }

  inflections() {
    return utils.inflections(this.points);
  }

  normal(t) {
    return this._3d ? this.__normal3(t) : this.__normal2(t);
  }

  __normal2(t) {
    const d = this.derivative(t);
    const q = sqrt(d.x * d.x + d.y * d.y);
    return { t, x: -d.y / q, y: d.x / q };
  }

  __normal3(t) {
    // see http://stackoverflow.com/questions/25453159
    const r1 = this.derivative(t),
      r2 = this.derivative(t + 0.01),
      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),
      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    // cross product
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x,
    };
    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m;
    c.y /= m;
    c.z /= m;
    // rotation matrix
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z,
    ];
    // normal vector:
    const n = {
      t,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,
    };
    return n;
  }

  hull(t) {
    let p = this.points,
      _p = [],
      q = [],
      idx = 0;
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];
    if (this.order === 3) {
      q[idx++] = p[3];
    }
    // we lerp between all points at each iteration, until we have 1 point left.
    while (p.length > 1) {
      _p = [];
      for (let i = 0, pt, l = p.length - 1; i < l; i++) {
        pt = utils.lerp(t, p[i], p[i + 1]);
        q[idx++] = pt;
        _p.push(pt);
      }
      p = _p;
    }
    return q;
  }

  split(t1, t2) {
    // shortcuts
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }
    if (t2 === 1) {
      return this.split(t1).right;
    }

    // no shortcut: use "de Casteljau" iteration.
    const q = this.hull(t1);
    const result = {
      left:
        this.order === 2
          ? new Bezier([q[0], q[3], q[5]])
          : new Bezier([q[0], q[4], q[7], q[9]]),
      right:
        this.order === 2
          ? new Bezier([q[5], q[4], q[2]])
          : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q,
    };

    // make sure we bind _t1/_t2 information!
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);

    // if we have no t2, we're done
    if (!t2) {
      return result;
    }

    // if we have a t2, split again:
    t2 = utils.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }

  extrema() {
    const result = {};
    let roots = [];

    this.dims.forEach(
      function (dim) {
        let mfn = function (v) {
          return v[dim];
        };
        let p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if (this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function (t) {
          return t >= 0 && t <= 1;
        });
        roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    );

    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {
      return roots.indexOf(v) === idx;
    });

    return result;
  }

  bbox() {
    const extrema = this.extrema(),
      result = {};
    this.dims.forEach(
      function (d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this)
    );
    return result;
  }

  overlaps(curve) {
    const lbbox = this.bbox(),
      tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }

  offset(t, d) {
    if (typeof d !== "undefined") {
      const c = this.get(t),
        n = this.normal(t);
      const ret = {
        c: c,
        n: n,
        x: c.x + n.x * d,
        y: c.y + n.y * d,
      };
      if (this._3d) {
        ret.z = c.z + n.z * d;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0),
        coords = this.points.map(function (p) {
          const ret = {
            x: p.x + t * nv.x,
            y: p.y + t * nv.y,
          };
          if (p.z && nv.z) {
            ret.z = p.z + t * nv.z;
          }
          return ret;
        });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function (s) {
      if (s._linear) {
        return s.offset(t)[0];
      }
      return s.scale(t);
    });
  }

  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s += n1.z * n2.z;
    }
    return abs(acos(s)) < pi / 3;
  }

  reduce() {
    // TODO: examine these var types in more detail...
    let i,
      t1 = 0,
      t2 = 0,
      step = 0.01,
      segment,
      pass1 = [],
      pass2 = [];
    // first pass: split on extrema
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }

    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
      t2 = extrema[i];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    }

    // second pass: further reduce these segments to simple segments
    pass1.forEach(function (p1) {
      t1 = 0;
      t2 = 0;
      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);
          if (!segment.simple()) {
            t2 -= step;
            if (abs(t1 - t2) < step) {
              // we can never form a reduction
              return [];
            }
            segment = p1.split(t1, t2);
            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }

  translate(v, d1, d2) {
    d2 = typeof d2 === "number" ? d2 : d1;

    // TODO: make this take curves with control points outside
    //       of the start-end interval into account

    const o = this.order;
    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);
    return new Bezier(
      this.points.map((p, i) => ({
        x: p.x + v.x * d[i],
        y: p.y + v.y * d[i],
      }))
    );
  }

  scale(d) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d === "function") {
      distanceFn = d;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }

    // TODO: add special handling for non-linear degenerate curves.

    const clockwise = this.clockwise;
    const points = this.points;

    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d,
        distanceFn ? distanceFn(1) : d
      );
    }

    const r1 = distanceFn ? distanceFn(0) : d;
    const r2 = distanceFn ? distanceFn(1) : d;
    const v = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);

    if (!o) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }

    // move all points by distance 'd' wrt the origin 'o',
    // and move end points by fixed distance along normal.
    [0, 1].forEach(function (t) {
      const p = (np[t * order] = utils.copy(points[t * order]));
      p.x += (t ? r2 : r1) * v[t].n.x;
      p.y += (t ? r2 : r1) * v[t].n.y;
    });

    if (!distanceFn) {
      // move control points to lie on the intersection of the offset
      // derivative vector, and the origin-through-control vector
      [0, 1].forEach((t) => {
        if (order === 2 && !!t) return;
        const p = np[t * order];
        const d = this.derivative(t);
        const p2 = { x: p.x + d.x, y: p.y + d.y };
        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);
      });
      return new Bezier(np);
    }

    // move control points by "however much necessary to
    // ensure the correct tangent to endpoint".
    [0, 1].forEach(function (t) {
      if (order === 2 && !!t) return;
      var p = points[t + 1];
      var ov = {
        x: p.x - o.x,
        y: p.y - o.y,
      };
      var rc = distanceFn ? distanceFn((t + 1) / order) : d;
      if (distanceFn && !clockwise) rc = -rc;
      var m = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m;
      ov.y /= m;
      np[t + 1] = {
        x: p.x + rc * ov.x,
        y: p.y + rc * ov.y,
      };
    });
    return new Bezier(np);
  }

  outline(d1, d2, d3, d4) {
    d2 = d2 === undefined ? d1 : d2;

    if (this._linear) {
      // TODO: find the actual extrema, because they might
      //       be before the start, or past the end.

      const n = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s, mid, e;

      if (d3 === undefined) {
        d3 = d1;
        d4 = d2;
      }

      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };
      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const fline = [s, mid, e];

      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };
      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const bline = [e, mid, s];

      const ls = utils.makeline(bline[2], fline[0]);
      const le = utils.makeline(fline[2], bline[0]);
      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];
      return new PolyBezier(segments);
    }

    const reduced = this.reduce(),
      len = reduced.length,
      fcurves = [];

    let bcurves = [],
      p,
      alen = 0,
      tlen = this.length();

    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";

    function linearDistanceFunction(s, e, tlen, alen, slen) {
      return function (v) {
        const f1 = alen / tlen,
          f2 = (alen + slen) / tlen,
          d = e - s;
        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    }

    // form curve oulines
    reduced.forEach(function (segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }
      alen += slen;
    });

    // reverse the "return" outline
    bcurves = bcurves
      .map(function (s) {
        p = s.points;
        if (p[3]) {
          s.points = [p[3], p[2], p[1], p[0]];
        } else {
          s.points = [p[2], p[1], p[0]];
        }
        return s;
      })
      .reverse();

    // form the endcaps as lines
    const fs = fcurves[0].points[0],
      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],
      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],
      be = bcurves[0].points[0],
      ls = utils.makeline(bs, fs),
      le = utils.makeline(fe, be),
      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);

    return new PolyBezier(segments);
  }

  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];
    for (let i = 1, len = outline.length; i < len / 2; i++) {
      const shape = utils.makeshape(
        outline[i],
        outline[len - i],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i > 1;
      shape.endcap.virtual = i < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }

  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }

  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x),
      my = min(line.p1.y, line.p2.y),
      MX = max(line.p1.x, line.p2.x),
      MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t) => {
      var p = this.get(t);
      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
    });
  }

  selfintersects(curveIntersectionThreshold) {
    // "simple" curves cannot intersect with their direct
    // neighbour, so for each segment X we check whether
    // it intersects [0:x-2][x+2:last].

    const reduced = this.reduce(),
      len = reduced.length - 2,
      results = [];

    for (let i = 0, result, left, right; i < len; i++) {
      left = reduced.slice(i, i + 1);
      right = reduced.slice(i + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }

  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    // step 1: pair off any overlapping segments
    c1.forEach(function (l) {
      c2.forEach(function (r) {
        if (l.overlaps(r)) {
          pairs.push({ left: l, right: r });
        }
      });
    });
    // step 2: for each pairing, run through the convergence algorithm.
    let intersections = [];
    pairs.forEach(function (pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }

  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }

  _error(pc, np1, s, e) {
    const q = (e - s) / 4,
      c1 = this.get(s + q),
      c2 = this.get(e - q),
      ref = utils.dist(pc, np1),
      d1 = utils.dist(pc, c1),
      d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }

  _iterate(errorThreshold, circles) {
    let t_s = 0,
      t_e = 1,
      safety;
    // we do a binary search to find the "good `t` closest to no-longer-good"
    do {
      safety = 0;

      // step 1: start with the maximum possible arc
      t_e = 1;

      // points:
      let np1 = this.get(t_s),
        np2,
        np3,
        arc,
        prev_arc;

      // booleans:
      let curr_good = false,
        prev_good = false,
        done;

      // numbers:
      let t_m = t_e,
        prev_e = 1;

      // step 2: find the best possible arc
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;

        np2 = this.get(t_m);
        np3 = this.get(t_e);

        arc = utils.getccenter(np1, np2, np3);

        //also save the t values
        arc.interval = {
          start: t_s,
          end: t_e,
        };

        let error = this._error(arc, np1, t_s, t_e);
        curr_good = error <= errorThreshold;

        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;

        // this arc is fine: we can move 'e' up to see if we can find a wider arc
        if (curr_good) {
          // if e is already at max, then we're done for this arc.
          if (t_e >= 1) {
            // make sure we cap at t=1
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            // if we capped the arc segment to t=1 we also need to make sure that
            // the arc's end angle is correct with respect to the bezier end point.
            if (t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e),
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
            }
            break;
          }
          // if not, move it up by half the iteration distance
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          // this is a bad arc: we need to move 'e' down to find a good arc
          t_e = t_m;
        }
      } while (!done && safety++ < 100);

      if (safety >= 100) {
        break;
      }

      // console.log("L835: [F] arc found", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);

      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}

class ArcLengthParameterizer {
  curve;
  lut;
  totalLength;
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(curve, resolution = 1e3) {
    this.curve = curve;
    this.lut = [];
    this.totalLength = 0;
    this.buildLUT(resolution);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(resolution) {
    let accumulatedLength = 0;
    let prevPoint = this.curve.get(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.get(t);
      if (i > 0) {
        const dx = point.x - prevPoint.x;
        const dy = point.y - prevPoint.y;
        accumulatedLength += Math.sqrt(dx * dx + dy * dy);
      }
      this.lut.push({
        t,
        length: accumulatedLength
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.lut.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.lut[mid].length < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.lut[low];
    const prevEntry = this.lut[Math.max(0, low - 1)];
    if (entry.length === prevEntry.length) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.length) / (entry.length - prevEntry.length);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    return {
      point: this.curve.get(t),
      tangent: this.curve.derivative(t),
      t
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(count) {
    const points = [];
    const spacing = this.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.getPointAtDistance(distance));
    }
    return points;
  }
}
function pathCommandsToBezier(pathCommands) {
  if (!pathCommands || pathCommands.length < 2) {
    return null;
  }
  let startPoint = null;
  for (const cmd of pathCommands) {
    const [command, ...coords] = cmd;
    if (command === "M") {
      startPoint = { x: coords[0], y: coords[1] };
    } else if (command === "C" && startPoint) {
      return new Bezier(
        startPoint.x,
        startPoint.y,
        coords[0],
        coords[1],
        // control point 1
        coords[2],
        coords[3],
        // control point 2
        coords[4],
        coords[5]
        // end point
      );
    } else if (command === "Q" && startPoint) {
      return new Bezier(
        startPoint.x,
        startPoint.y,
        coords[0],
        coords[1],
        // control point
        coords[2],
        coords[3]
        // end point
      );
    }
  }
  return null;
}

class MatteExporter {
  offscreenCanvas = null;
  ctx = null;
  particleSystems = /* @__PURE__ */ new Map();
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(width, height) {
    const correctedWidth = Math.round(width / 8) * 8;
    const correctedHeight = Math.round(height / 8) * 8;
    const finalWidth = Math.max(256, correctedWidth);
    const finalHeight = Math.max(256, correctedHeight);
    const valid = width === finalWidth && height === finalHeight;
    return {
      valid,
      correctedWidth: finalWidth,
      correctedHeight: finalHeight,
      message: valid ? void 0 : `Adjusted to ${finalWidth}x${finalHeight} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(project, options, onProgress) {
    const { frameCount } = project.composition;
    const { width, height } = options;
    this.offscreenCanvas = new OffscreenCanvas(width, height);
    this.ctx = this.offscreenCanvas.getContext("2d");
    this.initializeParticleSystems(project);
    const frames = [];
    for (let frame = 0; frame < frameCount; frame++) {
      if (onProgress) {
        onProgress({
          frame,
          total: frameCount,
          percent: Math.round(frame / frameCount * 100)
        });
      }
      this.stepParticleSystemsToFrame(project, frame);
      const frameBlob = await this.generateFrame(project, frame, options);
      frames.push(frameBlob);
    }
    this.particleSystems.clear();
    if (onProgress) {
      onProgress({
        frame: frameCount,
        total: frameCount,
        percent: 100
      });
    }
    return frames;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(project, frame, options) {
    const ctx = this.ctx;
    const { width, height } = options;
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    if (options.matteMode === "include_all") {
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    }
    ctx.fillStyle = "#000000";
    const scaleX = width / project.composition.width;
    const scaleY = height / project.composition.height;
    const textLayers = project.layers.filter(
      (layer) => layer.type === "text" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of textLayers) {
      await this.renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY);
    }
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of particleLayers) {
      this.renderParticleLayerToMatte(ctx, layer, width, height);
    }
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(project, frame, options) {
    if (!this.offscreenCanvas || this.offscreenCanvas.width !== options.width || this.offscreenCanvas.height !== options.height) {
      this.offscreenCanvas = new OffscreenCanvas(options.width, options.height);
      this.ctx = this.offscreenCanvas.getContext("2d");
    }
    const blob = await this.generateFrame(project, frame, options);
    return URL.createObjectURL(blob);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY) {
    const textData = layer.data;
    if (!textData) return;
    const fontSizeProp = layer.properties.find((p) => p.name === "fontSize");
    const fontSize = fontSizeProp ? interpolateProperty(fontSizeProp, frame) : textData.fontSize;
    const scaledFontSize = fontSize * Math.min(scaleX, scaleY);
    ctx.font = `${textData.fontWeight} ${scaledFontSize}px "${textData.fontFamily}"`;
    if (textData.pathLayerId) {
      await this.renderTextOnPathToMatte(ctx, layer, textData, project, frame, scaledFontSize, scaleX, scaleY);
    } else {
      this.renderTextBlockToMatte(ctx, layer, textData, frame, scaledFontSize, scaleX, scaleY);
    }
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(ctx, layer, textData, project, frame, fontSize, scaleX, scaleY) {
    const pathLayer = project.layers.find((l) => l.id === textData.pathLayerId);
    if (!pathLayer || pathLayer.type !== "spline") return;
    const splineData = pathLayer.data;
    if (!splineData?.controlPoints || splineData.controlPoints.length < 2) return;
    const pathCommands = this.buildPathCommands(splineData);
    if (!pathCommands || pathCommands.length < 2) return;
    const bezierCurve = pathCommandsToBezier(pathCommands);
    if (!bezierCurve) return;
    const parameterizer = new ArcLengthParameterizer(bezierCurve);
    const offsetProp = layer.properties.find((p) => p.name === "pathOffset");
    const pathOffset = offsetProp ? interpolateProperty(offsetProp, frame) : textData.pathOffset;
    const totalLength = parameterizer.totalLength;
    let currentDistance = pathOffset * totalLength;
    const padding = 4 * Math.min(scaleX, scaleY);
    for (const char of textData.text) {
      if (char === " ") {
        const spaceWidth = ctx.measureText(" ").width;
        currentDistance += spaceWidth + textData.letterSpacing;
        continue;
      }
      const charWidth = ctx.measureText(char).width;
      const clampedDistance = Math.max(0, Math.min(currentDistance, totalLength));
      const { point, tangent } = parameterizer.getPointAtDistance(clampedDistance);
      const angle = Math.atan2(tangent.y, tangent.x);
      const scaledX = point.x * scaleX;
      const scaledY = point.y * scaleY;
      ctx.save();
      ctx.translate(scaledX, scaledY);
      ctx.rotate(angle);
      ctx.fillRect(
        -padding,
        -fontSize - padding,
        charWidth + padding * 2,
        fontSize + padding * 2
      );
      ctx.restore();
      currentDistance += charWidth + textData.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(splineData) {
    const cp = splineData.controlPoints;
    if (!cp || cp.length < 2) return null;
    const pathCommands = [];
    pathCommands.push(["M", cp[0].x, cp[0].y]);
    for (let i = 0; i < cp.length - 1; i++) {
      const p1 = cp[i];
      const p2 = cp[i + 1];
      const h1 = p1.handleOut || { x: p1.x, y: p1.y };
      const h2 = p2.handleIn || { x: p2.x, y: p2.y };
      pathCommands.push([
        "C",
        h1.x,
        h1.y,
        h2.x,
        h2.y,
        p2.x,
        p2.y
      ]);
    }
    return pathCommands;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(ctx, layer, textData, frame, fontSize, scaleX, scaleY) {
    const positionProp = layer.transform.position;
    const position = interpolateProperty(positionProp, frame);
    const rotationProp = layer.transform.rotation;
    const rotation = interpolateProperty(rotationProp, frame);
    const scaleProp = layer.transform.scale;
    const scale = interpolateProperty(scaleProp, frame);
    ctx.save();
    ctx.translate(position.x * scaleX, position.y * scaleY);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scale.x, scale.y);
    const metrics = ctx.measureText(textData.text);
    const textWidth = metrics.width;
    const textHeight = fontSize;
    const padding = 4;
    ctx.fillRect(
      -padding,
      -textHeight - padding,
      textWidth + padding * 2,
      textHeight + padding * 2
    );
    ctx.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(frames, filename = "matte_sequence", onProgress) {
    const JSZip = (await import('./weyl-export-vendor.js').then(n => n.j)).default;
    const zip = new JSZip();
    frames.forEach((blob, index) => {
      const frameName = `${filename}_${String(index).padStart(4, "0")}.png`;
      zip.file(frameName, blob);
    });
    const content = await zip.generateAsync(
      { type: "blob" },
      (metadata) => {
        if (onProgress) {
          onProgress(Math.round(metadata.percent));
        }
      }
    );
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${filename}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(project) {
    this.particleSystems.clear();
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles"
    );
    for (const layer of particleLayers) {
      const data = layer.data;
      if (!data) continue;
      const system = new ParticleSystem(data.systemConfig);
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
      const warmupFrames = data.systemConfig.warmupPeriod || 0;
      for (let i = 0; i < warmupFrames; i++) {
        system.step();
      }
      this.particleSystems.set(layer.id, system);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(project, frame) {
    if (frame === 0) return;
    for (const layer of project.layers) {
      if (layer.type !== "particles") continue;
      const system = this.particleSystems.get(layer.id);
      if (!system) continue;
      if (layer.visible && frame >= layer.inPoint && frame <= layer.outPoint) {
        system.step();
      }
    }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(ctx, layer, width, height) {
    const system = this.particleSystems.get(layer.id);
    if (!system) return;
    const maskData = system.renderToMask(width, height);
    const tempCanvas = new OffscreenCanvas(width, height);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.putImageData(maskData, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null;
    this.ctx = null;
    this.particleSystems.clear();
  }
}
const matteExporter = new MatteExporter();

const _hoisted_1$5 = { class: "export-dialog" };
const _hoisted_2$5 = { class: "dialog-header" };
const _hoisted_3$5 = { class: "dialog-content" };
const _hoisted_4$5 = { class: "form-group" };
const _hoisted_5$5 = { class: "resolution-presets" };
const _hoisted_6$5 = ["onClick"];
const _hoisted_7$5 = { class: "custom-resolution" };
const _hoisted_8$5 = { class: "dimension-input" };
const _hoisted_9$5 = { class: "dimension-input" };
const _hoisted_10$5 = {
  key: 0,
  class: "dimension-warning"
};
const _hoisted_11$5 = { class: "form-group" };
const _hoisted_12$5 = { class: "matte-mode-options" };
const _hoisted_13$5 = { class: "form-group" };
const _hoisted_14$5 = { class: "preview-container" };
const _hoisted_15$5 = ["src"];
const _hoisted_16$5 = {
  key: 1,
  class: "preview-placeholder"
};
const _hoisted_17$5 = {
  key: 0,
  class: "progress-section"
};
const _hoisted_18$5 = { class: "progress-bar" };
const _hoisted_19$5 = { class: "progress-text" };
const _hoisted_20$5 = { class: "dialog-footer" };
const _hoisted_21$5 = { class: "export-info" };
const _hoisted_22$5 = ["disabled"];
const _hoisted_23$5 = ["disabled"];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const resolutionPresets = matteExporter.getResolutionPresets();
    const selectedPreset = ref("720p (1280x720)");
    const customWidth = ref(1280);
    const customHeight = ref(720);
    const dimensionWarning = ref();
    const matteMode = ref("exclude_text");
    const previewUrl = ref(null);
    const isExporting = ref(false);
    const exportProgress = ref(0);
    const progressMessage = ref("");
    const exportWidth = computed(() => customWidth.value);
    const exportHeight = computed(() => customHeight.value);
    function selectPreset(preset) {
      selectedPreset.value = preset.label;
      customWidth.value = preset.width;
      customHeight.value = preset.height;
      dimensionWarning.value = void 0;
    }
    function validateCustomDimensions() {
      const validation = matteExporter.validateDimensions(customWidth.value, customHeight.value);
      if (!validation.valid) {
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        dimensionWarning.value = validation.message;
        selectedPreset.value = "";
      } else {
        dimensionWarning.value = void 0;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
      }
    }
    async function generatePreview() {
      if (!store.hasProject) return;
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
        previewUrl.value = null;
      }
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      previewUrl.value = await matteExporter.generatePreviewFrame(
        store.project,
        0,
        options
      );
    }
    async function startExport() {
      if (isExporting.value || !store.hasProject) return;
      isExporting.value = true;
      exportProgress.value = 0;
      progressMessage.value = "Generating frames...";
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      try {
        const frames = await matteExporter.generateMatteSequence(
          store.project,
          options,
          (progress) => {
            exportProgress.value = progress.percent;
            progressMessage.value = `Generating frame ${progress.frame + 1} of ${progress.total}...`;
          }
        );
        progressMessage.value = "Creating ZIP archive...";
        await matteExporter.downloadAsZip(
          frames,
          `matte_${Date.now()}`,
          (percent) => {
            progressMessage.value = `Compressing... ${percent}%`;
          }
        );
        progressMessage.value = "Export complete!";
        emit("exported");
        setTimeout(() => {
          emit("close");
        }, 1e3);
      } catch (err) {
        console.error("[ExportDialog] Export failed:", err);
        progressMessage.value = `Export failed: ${err instanceof Error ? err.message : "Unknown error"}`;
      } finally {
        isExporting.value = false;
      }
    }
    watch(
      [exportWidth, exportHeight, matteMode],
      () => {
        generatePreview();
      },
      { immediate: false }
    );
    onMounted(() => {
      if (store.hasProject) {
        const validation = matteExporter.validateDimensions(store.width, store.height);
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
        if (!validation.valid) {
          dimensionWarning.value = validation.message;
        }
      }
      generatePreview();
    });
    onUnmounted(() => {
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
      }
      matteExporter.dispose();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$5, [
          createBaseVNode("div", _hoisted_2$5, [
            _cache[8] || (_cache[8] = createBaseVNode("h3", null, "Export Matte Sequence", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_3$5, [
            createBaseVNode("div", _hoisted_4$5, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Resolution", -1)),
              createBaseVNode("div", _hoisted_5$5, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(resolutionPresets), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.label,
                    class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.label }]),
                    onClick: ($event) => selectPreset(preset)
                  }, toDisplayString(preset.label), 11, _hoisted_6$5);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_7$5, [
                createBaseVNode("div", _hoisted_8$5, [
                  _cache[9] || (_cache[9] = createBaseVNode("label", null, "Width", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => customWidth.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customWidth.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                _cache[11] || (_cache[11] = createBaseVNode("span", { class: "dimension-x" }, "Ã—", -1)),
                createBaseVNode("div", _hoisted_9$5, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", null, "Height", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customHeight.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customHeight.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ])
              ]),
              dimensionWarning.value ? (openBlock(), createElementBlock("p", _hoisted_10$5, [
                _cache[12] || (_cache[12] = createBaseVNode("i", { class: "pi pi-info-circle" }, null, -1)),
                createTextVNode(" " + toDisplayString(dimensionWarning.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_11$5, [
              _cache[16] || (_cache[16] = createBaseVNode("label", null, "Matte Mode", -1)),
              createBaseVNode("div", _hoisted_12$5, [
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "exclude_text" }]),
                  onClick: _cache[3] || (_cache[3] = ($event) => matteMode.value = "exclude_text")
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("i", { class: "pi pi-ban" }, null, -1),
                  createBaseVNode("span", null, "Exclude Text", -1),
                  createBaseVNode("small", null, "Text regions are BLACK (excluded from generation)", -1)
                ])], 2),
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "include_all" }]),
                  onClick: _cache[4] || (_cache[4] = ($event) => matteMode.value = "include_all")
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("i", { class: "pi pi-check-circle" }, null, -1),
                  createBaseVNode("span", null, "Include All", -1),
                  createBaseVNode("small", null, "Entire frame is WHITE (generate everything)", -1)
                ])], 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$5, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Preview (Frame 0)", -1)),
              createBaseVNode("div", _hoisted_14$5, [
                previewUrl.value ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: previewUrl.value,
                  alt: "Matte preview",
                  class: "preview-image"
                }, null, 8, _hoisted_15$5)) : (openBlock(), createElementBlock("div", _hoisted_16$5, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-image" }, null, -1),
                  createBaseVNode("span", null, "Generating preview...", -1)
                ])]))
              ]),
              _cache[19] || (_cache[19] = createBaseVNode("p", { class: "preview-info" }, [
                createTextVNode(" White = Keep original / generate content"),
                createBaseVNode("br"),
                createTextVNode(" Black = Exclude from generation ")
              ], -1))
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_17$5, [
              createBaseVNode("div", _hoisted_18$5, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: `${exportProgress.value}%` })
                }, null, 4)
              ]),
              createBaseVNode("p", _hoisted_19$5, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_20$5, [
            createBaseVNode("div", _hoisted_21$5, [
              createBaseVNode("span", null, toDisplayString(unref(store).frameCount) + " frames @ " + toDisplayString(exportWidth.value) + "Ã—" + toDisplayString(exportHeight.value), 1)
            ]),
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[5] || (_cache[5] = ($event) => emit("close")),
              disabled: isExporting.value
            }, " Cancel ", 8, _hoisted_22$5),
            createBaseVNode("button", {
              class: "export-btn",
              onClick: startExport,
              disabled: isExporting.value || !unref(store).hasProject
            }, [
              _cache[20] || (_cache[20] = createBaseVNode("i", { class: "pi pi-download" }, null, -1)),
              createTextVNode(" " + toDisplayString(isExporting.value ? "Exporting..." : "Export ZIP"), 1)
            ], 8, _hoisted_23$5)
          ])
        ])
      ]);
    };
  }
});

const ExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-34eee532"]]);

const EXPORT_PRESETS = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: false,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "motionctrl": {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 3
  },
  "cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ati": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ttm": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-wan": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 50,
    cfgScale: 6
  },
  "ttm-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  }
};
const DEPTH_FORMAT_SPECS = {
  "midas": {
    format: "midas",
    bitDepth: 8,
    invert: true,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "zoe": {
    format: "zoe",
    bitDepth: 16,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: false,
    normalize: false,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  "normalized": {
    format: "normalized",
    bitDepth: 8,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
};
const RESOLUTION_PRESETS = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
];
const FRAME_COUNT_PRESETS = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
];
const EXPORT_TARGET_INFO = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  "motionctrl": {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  "cogvideox": {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  "ati": {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  "ttm": {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "ttm-wan": {
    name: "TTM (Wan 2.1 Backend)",
    description: "Time-to-Move with Wan 2.1 model for high-quality generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControl", "TTM_TrajectoryFromPoints", "WanImageToVideo"]
  },
  "ttm-cogvideox": {
    name: "TTM (CogVideoX Backend)",
    description: "Time-to-Move with CogVideoX model for longer sequences",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlCogVideo", "TTM_TrajectoryFromPoints", "CogVideoImageToVideo"]
  },
  "ttm-svd": {
    name: "TTM (SVD Backend)",
    description: "Time-to-Move with Stable Video Diffusion for fast generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlSVD", "TTM_TrajectoryFromPoints", "SVDEncode"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};

function renderDepthFrame(options) {
  const { width, height, nearClip, farClip, camera, layers, frame } = options;
  const depthBuffer = new Float32Array(width * height);
  depthBuffer.fill(farClip);
  let minDepth = farClip;
  let maxDepth = nearClip;
  const sortedLayers = [...layers].filter((l) => l.visible).sort((a, b) => {
    const aZ = getLayerDepth(a, frame);
    const bZ = getLayerDepth(b, frame);
    return aZ - bZ;
  });
  for (const layer of sortedLayers) {
    const layerDepth = getLayerDepth(layer, frame);
    const layerOpacity = getLayerOpacity(layer, frame);
    if (layerOpacity < 0.01) continue;
    const bounds = getLayerScreenBounds(layer, frame, camera, width, height);
    if (!bounds) continue;
    const cameraZ = camera.position.z;
    const relativeDepth = Math.abs(layerDepth - cameraZ);
    const clampedDepth = Math.max(nearClip, Math.min(farClip, relativeDepth));
    minDepth = Math.min(minDepth, clampedDepth);
    maxDepth = Math.max(maxDepth, clampedDepth);
    if (layer.type === "depthflow" && hasDepthData(layer)) {
      fillDepthFromDepthflow(depthBuffer, layer, bounds, width, height, nearClip, farClip);
    } else {
      fillUniformDepth(depthBuffer, bounds, clampedDepth, layerOpacity, width, height);
    }
  }
  return {
    depthBuffer,
    width,
    height,
    minDepth,
    maxDepth
  };
}
function getLayerDepth(layer, frame) {
  const position = layer.transform?.position;
  if (!position) return 0;
  if (position.keyframes && position.keyframes.length > 0) {
    return interpolateValue(position.keyframes, frame, 2) || 0;
  }
  if (position.value) {
    const value = position.value;
    if (typeof value === "object" && "z" in value) {
      return value.z ?? 0;
    }
  }
  return 0;
}
function getLayerOpacity(layer, frame) {
  if (layer.opacity && "keyframes" in layer.opacity && layer.opacity.keyframes?.length > 0) {
    return (interpolateValue(layer.opacity.keyframes, frame) || 100) / 100;
  }
  if (layer.opacity && "value" in layer.opacity) {
    return (layer.opacity.value || 100) / 100;
  }
  return 1;
}
function getLayerScreenBounds(layer, frame, camera, screenWidth, screenHeight) {
  let x = 0, y = 0;
  const position = layer.transform?.position;
  if (position && "value" in position) {
    const value = position.value;
    if (Array.isArray(value)) {
      x = value[0] || 0;
      y = value[1] || 0;
    }
  }
  const layerWidth = layer.width || screenWidth;
  const layerHeight = layer.height || screenHeight;
  let scaleX = 1, scaleY = 1;
  const scale = layer.transform?.scale;
  if (scale && "value" in scale) {
    const value = scale.value;
    if (Array.isArray(value)) {
      scaleX = (value[0] || 100) / 100;
      scaleY = (value[1] || 100) / 100;
    }
  }
  const finalWidth = layerWidth * scaleX;
  const finalHeight = layerHeight * scaleY;
  let anchorX = 0.5, anchorY = 0.5;
  const anchorPoint = layer.transform?.anchorPoint;
  if (anchorPoint && "value" in anchorPoint) {
    const value = anchorPoint.value;
    if (Array.isArray(value)) {
      anchorX = (value[0] || 0) / layerWidth + 0.5;
      anchorY = (value[1] || 0) / layerHeight + 0.5;
    }
  }
  const screenX = x - finalWidth * anchorX + screenWidth / 2;
  const screenY = y - finalHeight * anchorY + screenHeight / 2;
  const clippedX = Math.max(0, Math.min(screenWidth, screenX));
  const clippedY = Math.max(0, Math.min(screenHeight, screenY));
  const clippedWidth = Math.max(0, Math.min(screenWidth - clippedX, finalWidth - (clippedX - screenX)));
  const clippedHeight = Math.max(0, Math.min(screenHeight - clippedY, finalHeight - (clippedY - screenY)));
  if (clippedWidth <= 0 || clippedHeight <= 0) return null;
  return {
    x: clippedX,
    y: clippedY,
    width: clippedWidth,
    height: clippedHeight
  };
}
function hasDepthData(layer) {
  return layer.type === "depthflow" && !!layer.depthMapData;
}
function fillDepthFromDepthflow(depthBuffer, layer, bounds, screenWidth, screenHeight, nearClip, farClip) {
  const depthData = layer.depthMapData;
  const depthWidth = layer.depthWidth || bounds.width;
  const depthHeight = layer.depthHeight || bounds.height;
  for (let y = 0; y < bounds.height; y++) {
    for (let x = 0; x < bounds.width; x++) {
      const screenX = Math.floor(bounds.x + x);
      const screenY = Math.floor(bounds.y + y);
      if (screenX < 0 || screenX >= screenWidth || screenY < 0 || screenY >= screenHeight) continue;
      const sampleX = Math.floor(x / bounds.width * depthWidth);
      const sampleY = Math.floor(y / bounds.height * depthHeight);
      const sampleIdx = sampleY * depthWidth + sampleX;
      let depthValue;
      if (depthData instanceof Float32Array) {
        depthValue = depthData[sampleIdx];
      } else {
        depthValue = depthData[sampleIdx] / 255;
      }
      const worldDepth = nearClip + depthValue * (farClip - nearClip);
      const bufferIdx = screenY * screenWidth + screenX;
      if (worldDepth < depthBuffer[bufferIdx]) {
        depthBuffer[bufferIdx] = worldDepth;
      }
    }
  }
}
function fillUniformDepth(depthBuffer, bounds, depth, opacity, screenWidth, screenHeight) {
  const startX = Math.floor(bounds.x);
  const startY = Math.floor(bounds.y);
  const endX = Math.min(screenWidth, Math.ceil(bounds.x + bounds.width));
  const endY = Math.min(screenHeight, Math.ceil(bounds.y + bounds.height));
  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      const idx = y * screenWidth + x;
      if (opacity > 0.5 && depth < depthBuffer[idx]) {
        depthBuffer[idx] = depth;
      }
    }
  }
}
function interpolateValue(keyframes, frame, index) {
  if (!keyframes || keyframes.length === 0) return null;
  let prev = keyframes[0];
  let next = keyframes[keyframes.length - 1];
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i].frame <= frame) {
      prev = keyframes[i];
    }
    if (keyframes[i].frame >= frame && i < keyframes.length) {
      next = keyframes[i];
      break;
    }
  }
  if (prev.frame === next.frame) {
    const value = prev.value;
    return index !== void 0 && Array.isArray(value) ? value[index] : value;
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevValue = index !== void 0 && Array.isArray(prev.value) ? prev.value[index] : prev.value;
  const nextValue = index !== void 0 && Array.isArray(next.value) ? next.value[index] : next.value;
  return prevValue + (nextValue - prevValue) * t;
}
function convertDepthToFormat(result, format) {
  const spec = DEPTH_FORMAT_SPECS[format];
  const { depthBuffer, width, height, minDepth, maxDepth } = result;
  const pixelCount = width * height;
  if (spec.bitDepth === 16) {
    const output = new Uint16Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized;
      if (spec.normalize) {
        normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      } else {
        normalized = depthBuffer[i] / spec.farClip;
      }
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(65535, Math.round(normalized * 65535)));
    }
    return output;
  } else {
    const output = new Uint8Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(255, Math.round(normalized * 255)));
    }
    return output;
  }
}
function depthToImageData(depthData, width, height) {
  const imageData = new ImageData(width, height);
  const is16bit = depthData instanceof Uint16Array;
  for (let i = 0; i < width * height; i++) {
    const value = is16bit ? Math.floor(depthData[i] / 256) : depthData[i];
    const pixelIdx = i * 4;
    imageData.data[pixelIdx] = value;
    imageData.data[pixelIdx + 1] = value;
    imageData.data[pixelIdx + 2] = value;
    imageData.data[pixelIdx + 3] = 255;
  }
  return imageData;
}

const comfyLogger = createLogger("ComfyUI");
class ComfyUIClient {
  serverAddress;
  clientId;
  ws = null;
  messageHandlers = /* @__PURE__ */ new Map();
  constructor(config) {
    this.serverAddress = config.serverAddress.replace(/\/$/, "");
    this.clientId = config.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      });
      return response.ok;
    } catch {
      return false;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const response = await fetch(`http://${this.serverAddress}/prompt`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(imageData, filename, type = "input", subfolder, overwrite = true) {
    const formData = new FormData();
    formData.append("image", imageData, filename);
    formData.append("type", type);
    formData.append("overwrite", overwrite.toString());
    if (subfolder) {
      formData.append("subfolder", subfolder);
    }
    const response = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to upload image: ${error}`);
    }
    return response.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(maskData, filename, originalRef) {
    const formData = new FormData();
    formData.append("image", maskData, filename);
    formData.append("original_ref", JSON.stringify(originalRef));
    formData.append("type", "input");
    const response = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Failed to upload mask: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(workflow, extraData) {
    const payload = {
      prompt: workflow,
      client_id: this.clientId,
      extra_data: extraData
    };
    const response = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to queue prompt: ${error}`);
    }
    return response.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(promptId) {
    const url = promptId ? `http://${this.serverAddress}/history/${promptId}` : `http://${this.serverAddress}/history`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to get history: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(filename, subfolder = "", type = "output") {
    const params = new URLSearchParams({
      filename,
      subfolder,
      type
    });
    const response = await fetch(`http://${this.serverAddress}/view?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to get output: ${await response.text()}`);
    }
    return response.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(filename, subfolder = "", type = "output") {
    const blob = await this.getOutput(filename, subfolder, type);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const response = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`Failed to interrupt: ${await response.text()}`);
    }
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const response = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: true })
    });
    if (!response.ok) {
      throw new Error(`Failed to clear queue: ${await response.text()}`);
    }
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(deleteType, ids) {
    const response = await fetch(`http://${this.serverAddress}/${deleteType}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: ids })
    });
    if (!response.ok) {
      throw new Error(`Failed to delete from ${deleteType}: ${await response.text()}`);
    }
  }
  /**
   * Get available models
   */
  async getModels(type) {
    const folderMap = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    };
    const response = await fetch(
      `http://${this.serverAddress}/models/${folderMap[type]}`
    );
    if (!response.ok) {
      return [];
    }
    return response.json();
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const wsUrl = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(wsUrl);
      this.ws.onopen = () => {
        comfyLogger.debug("WebSocket connected");
        resolve();
      };
      this.ws.onerror = (event) => {
        comfyLogger.error("WebSocket error:", event);
        reject(new Error("WebSocket connection failed"));
      };
      this.ws.onclose = () => {
        comfyLogger.debug("WebSocket disconnected");
        this.ws = null;
      };
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (e) {
          comfyLogger.error("Failed to parse WebSocket message:", e);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  /**
   * Remove a message handler
   */
  offMessage(type) {
    this.messageHandlers.delete(type);
  }
  handleWebSocketMessage(data) {
    const { type } = data;
    const handler = this.messageHandlers.get(type);
    if (handler) {
      handler(data);
    }
    const allHandler = this.messageHandlers.get("all");
    if (allHandler) {
      allHandler(data);
    }
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(imageData, filename, subfolder) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(canvas, filename, subfolder) {
    let blob;
    if (canvas instanceof OffscreenCanvas) {
      blob = await canvas.convertToBlob({ type: "image/png" });
    } else {
      blob = await new Promise((resolve, reject) => {
        canvas.toBlob((b) => {
          if (b) resolve(b);
          else reject(new Error("Failed to convert canvas to blob"));
        }, "image/png");
      });
    }
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(promptId, onProgress, timeoutMs = 3e5) {
    const startTime = Date.now();
    if (!this.isWebSocketConnected()) {
      await this.connectWebSocket();
    }
    return new Promise((resolve, reject) => {
      let completed = false;
      const cleanup = () => {
        this.offMessage("progress");
        this.offMessage("executing");
        this.offMessage("executed");
        this.offMessage("execution_error");
      };
      const checkTimeout = () => {
        if (Date.now() - startTime > timeoutMs) {
          cleanup();
          reject(new Error("Prompt execution timed out"));
        }
      };
      this.onMessage("progress", (data) => {
        checkTimeout();
        onProgress?.({
          status: "executing",
          currentStep: data.data.value,
          totalSteps: data.data.max,
          percentage: data.data.value / data.data.max * 100
        });
      });
      this.onMessage("executing", (data) => {
        checkTimeout();
        if (data.data.prompt_id === promptId) {
          onProgress?.({
            status: "executing",
            currentNode: data.data.node,
            percentage: 10
            // Approximate
          });
        }
      });
      this.onMessage("executed", async (data) => {
        if (data.data.prompt_id === promptId && !completed) {
          completed = true;
          cleanup();
          onProgress?.({
            status: "completed",
            percentage: 100
          });
          const history = await this.getHistory(promptId);
          resolve(history[promptId]);
        }
      });
      this.onMessage("execution_error", (data) => {
        if (data.data.prompt_id === promptId) {
          cleanup();
          onProgress?.({
            status: "error",
            percentage: 0
          });
          reject(new Error(data.data.exception_message || "Execution failed"));
        }
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(workflow, onProgress) {
    const { prompt_id } = await this.queuePrompt(workflow);
    onProgress?.({
      status: "queued",
      percentage: 0
    });
    const history = await this.waitForPrompt(prompt_id, onProgress);
    const outputs = [];
    for (const nodeOutputs of Object.values(history.outputs)) {
      if (nodeOutputs.images) {
        outputs.push(...nodeOutputs.images);
      }
      if (nodeOutputs.gifs) {
        outputs.push(...nodeOutputs.gifs);
      }
    }
    return {
      promptId: prompt_id,
      history,
      outputs
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let defaultClient = null;
function getComfyUIClient(serverAddress) {
  if (!defaultClient || serverAddress && serverAddress !== defaultClient.server) {
    defaultClient = new ComfyUIClient({
      serverAddress: serverAddress || "127.0.0.1:8188"
    });
  }
  return defaultClient;
}

let nodeIdCounter = 1;
function resetNodeIds() {
  nodeIdCounter = 1;
}
function nextNodeId() {
  return String(nodeIdCounter++);
}
function createNode(classType, inputs, title) {
  const node = {
    class_type: classType,
    inputs
  };
  if (title) {
    node._meta = { title };
  }
  return node;
}
function conn(nodeId, outputIndex = 0) {
  return [nodeId, outputIndex];
}
function addCheckpointLoader(workflow, checkpoint) {
  const id = nextNodeId();
  workflow[id] = createNode("CheckpointLoaderSimple", {
    ckpt_name: checkpoint
  }, "Load Checkpoint");
  return id;
}
function addCLIPTextEncode(workflow, clipConnection, text, title) {
  const id = nextNodeId();
  workflow[id] = createNode("CLIPTextEncode", {
    clip: clipConnection,
    text
  }, title);
  return id;
}
function addLoadImage(workflow, imageName, title) {
  const id = nextNodeId();
  workflow[id] = createNode("LoadImage", {
    image: imageName
  }, title || "Load Image");
  return id;
}
function addImageResize(workflow, imageConnection, width, height) {
  const id = nextNodeId();
  workflow[id] = createNode("ImageResize", {
    image: imageConnection,
    width,
    height,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image");
  return id;
}
function addVAEEncode(workflow, imageConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEEncode", {
    pixels: imageConnection,
    vae: vaeConnection
  }, "VAE Encode");
  return id;
}
function addVAEDecode(workflow, samplesConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEDecode", {
    samples: samplesConnection,
    vae: vaeConnection
  }, "VAE Decode");
  return id;
}
function addKSampler(workflow, modelConnection, positiveConnection, negativeConnection, latentConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("KSampler", {
    model: modelConnection,
    positive: positiveConnection,
    negative: negativeConnection,
    latent_image: latentConnection,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    steps: params.steps ?? 20,
    cfg: params.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: params.denoise ?? 1
  }, "KSampler");
  return id;
}
function addVideoOutput(workflow, imagesConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("VHS_VideoCombine", {
    images: imagesConnection,
    frame_rate: params.fps,
    loop_count: 0,
    filename_prefix: params.filename || "weyl_output",
    format: params.format || "video/h264-mp4",
    pingpong: false,
    save_output: true,
    audio: null,
    meta_batch: null
  }, "Video Output");
  return id;
}
function generateWan22I2VWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const isHD = params.width > 640 || params.height > 640;
  const wanModel = params.wanModel || (isHD ? "i2v_720p" : "i2v_480p");
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${wanModel}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanImageToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: params.denoise || 1
  }, "I2V Generation");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_i2v"
  });
  return workflow;
}
function generateWan22FunCameraWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("WanFunCameraMotion", {
    motion_type: params.cameraMotion || "Static",
    length: params.frameCount
  }, "Camera Motion");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFunCameraI2V", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    camera_motion: conn(cameraCtrlId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_fun_camera"
  });
  return workflow;
}
function generateWan22FirstLastWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const firstImageId = addLoadImage(workflow, params.referenceImage || "first.png", "First Frame");
  const lastImageId = addLoadImage(workflow, params.lastFrameImage || "last.png", "Last Frame");
  const resizeFirstId = addImageResize(workflow, conn(firstImageId), params.width, params.height);
  const resizeLastId = addImageResize(workflow, conn(lastImageId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFirstLastFrameToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    first_frame: conn(resizeFirstId),
    last_frame: conn(resizeLastId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_flf"
  });
  return workflow;
}
function generateUni3CWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const uni3cLoaderId = nextNodeId();
  workflow[uni3cLoaderId] = createNode("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const trajId = nextNodeId();
  if (params.trajType === "custom" && params.cameraData?.trajectory) {
    workflow[trajId] = createNode("Uni3CCustomTrajectory", {
      trajectory_data: JSON.stringify(params.cameraData.trajectory),
      length: params.frameCount
    }, "Custom Trajectory");
  } else {
    workflow[trajId] = createNode("Uni3CPresetTrajectory", {
      traj_type: params.trajType || "orbit",
      length: params.frameCount
    }, "Preset Trajectory");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyUni3CCameraControl", {
    model: conn(baseModelId),
    uni3c: conn(uni3cLoaderId),
    trajectory: conn(trajId),
    image: conn(resizeId),
    control_strength: 1
  }, "Apply Camera Control");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "uni3c_output"
  });
  return workflow;
}
function generateMotionCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const motionCtrlId = nextNodeId();
  workflow[motionCtrlId] = createNode("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("MotionCtrlCameraPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("MotionCtrlPresetPoses", {
      preset: params.motionPreset || "static",
      length: params.frameCount
    }, "Preset Poses");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyMotionCtrl", {
    model: conn(baseModelId),
    motion_ctrl: conn(motionCtrlId),
    camera_poses: conn(posesId),
    control_strength: 1
  }, "Apply MotionCtrl");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "motionctrl_output"
  });
  return workflow;
}
function generateControlNetDepthWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "sd_xl_base_1.0.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const depthLoaderId = nextNodeId();
  workflow[depthLoaderId] = createNode("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const refImageId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeRefId = addImageResize(workflow, conn(refImageId), params.width, params.height);
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(depthLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const encodeRefId = addVAEEncode(workflow, conn(resizeRefId), conn(checkpointId, 2));
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(encodeRefId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7, denoise: params.denoise || 0.75 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "controlnet_depth"
  });
  return workflow;
}
function generateAnimateDiffCameraCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "dreamshaper_8.safetensors");
  const animateDiffId = nextNodeId();
  workflow[animateDiffId] = createNode("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("ADE_CameraCtrlPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("ADE_CameraCtrlPreset", {
      motion_type: params.cameraMotion || "Static",
      speed: 1,
      frame_length: params.frameCount
    }, "Camera Preset");
  }
  const applyADId = nextNodeId();
  workflow[applyADId] = createNode("ADE_ApplyAnimateDiffModel", {
    model: conn(checkpointId),
    motion_model: conn(animateDiffId)
  }, "Apply AnimateDiff");
  const applyCamId = nextNodeId();
  workflow[applyCamId] = createNode("ADE_ApplyCameraCtrl", {
    model: conn(applyADId),
    cameractrl: conn(cameraCtrlId),
    poses: conn(posesId)
  }, "Apply CameraCtrl");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(applyCamId),
    conn(positiveId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "animatediff_cameractrl"
  });
  return workflow;
}
function generateCogVideoXWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const cogVideoId = nextNodeId();
  workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const t5Id = nextNodeId();
  workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const vaeId = nextNodeId();
  workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const encodePromptId = nextNodeId();
  workflow[encodePromptId] = createNode("CogVideoTextEncode", {
    text_encoder: conn(t5Id),
    prompt: params.prompt,
    force_offload: true
  }, "Encode Prompt");
  const generateId = nextNodeId();
  workflow[generateId] = createNode("CogVideoImageToVideo", {
    model: conn(cogVideoId),
    positive: conn(encodePromptId),
    image: conn(resizeId),
    vae: conn(vaeId),
    width: params.width,
    height: params.height,
    num_frames: params.frameCount,
    steps: params.steps || 50,
    cfg: params.cfgScale || 6,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("CogVideoDecode", {
    vae: conn(vaeId),
    samples: conn(generateId),
    enable_vae_tiling: true
  }, "Decode Video");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "cogvideox_output"
  });
  return workflow;
}
function generateTTMWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const ttmModel = params.ttmModel || "wan";
  const layers = params.ttmLayers || [];
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const combinedMaskId = nextNodeId();
  workflow[combinedMaskId] = createNode("LoadImage", {
    image: params.ttmCombinedMask || "combined_motion_mask.png"
  }, "Combined Motion Mask");
  const layerMaskIds = [];
  const trajectoryIds = [];
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];
    const maskId = nextNodeId();
    workflow[maskId] = createNode("LoadImage", {
      image: layer.motionMask
    }, `Layer ${i + 1} Mask: ${layer.layerName}`);
    layerMaskIds.push(maskId);
    const trajId = nextNodeId();
    workflow[trajId] = createNode("TTM_TrajectoryFromPoints", {
      points: JSON.stringify(layer.trajectory.map((t) => [t.x, t.y])),
      frames: JSON.stringify(layer.trajectory.map((t) => t.frame)),
      total_frames: params.frameCount,
      interpolation: "linear"
    }, `Trajectory: ${layer.layerName}`);
    trajectoryIds.push(trajId);
  }
  let combinedLayerDataId = null;
  if (layers.length > 0) {
    combinedLayerDataId = nextNodeId();
    workflow[combinedLayerDataId] = createNode("TTM_CombineLayers", {
      masks: layerMaskIds.map((id) => conn(id)),
      trajectories: trajectoryIds.map((id) => conn(id)),
      blend_mode: "additive"
    }, "Combine Layer Data");
  }
  if (ttmModel === "wan") {
    const wanLoaderId = nextNodeId();
    workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
      model: "wan2.1_i2v_480p_bf16.safetensors",
      base_precision: "bf16",
      quantization: "disabled"
    }, "Load Wan Model");
    const vaeLoaderId = nextNodeId();
    workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
      vae: "wan_2.1_vae.safetensors",
      precision: "bf16"
    }, "Load Wan VAE");
    const clipLoaderId = nextNodeId();
    workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
      text_encoder: "umt5-xxl-enc-bf16.safetensors",
      precision: "bf16"
    }, "Load Text Encoder");
    const positiveId = nextNodeId();
    workflow[positiveId] = createNode("WanTextEncode", {
      text_encoder: conn(clipLoaderId),
      prompt: params.prompt,
      force_offload: true
    }, "Positive Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControl", {
      wan_model: conn(wanLoaderId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const latentId = nextNodeId();
    workflow[latentId] = createNode("WanImageToVideo", {
      wan_model: conn(ttmControlId),
      positive: conn(positiveId),
      image: conn(resizeId),
      vae: conn(vaeLoaderId),
      width: params.width,
      height: params.height,
      length: params.frameCount,
      steps: params.steps || 30,
      cfg: params.cfgScale || 5,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "DPM++ 2M SDE",
      denoise_strength: params.denoise || 1
    }, "TTM I2V Generation");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("WanVAEDecode", {
      vae: conn(vaeLoaderId),
      samples: conn(latentId),
      enable_vae_tiling: true,
      tile_sample_min_height: 240,
      tile_sample_min_width: 240,
      tile_overlap_factor_height: 0.2,
      tile_overlap_factor_width: 0.2
    }, "VAE Decode");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_output"
    });
  } else if (ttmModel === "cogvideox") {
    const cogVideoId = nextNodeId();
    workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
      model: "CogVideoX-5b-I2V",
      precision: "bf16"
    }, "Load CogVideoX");
    const t5Id = nextNodeId();
    workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
      model: "t5-v1_1-xxl-encoder-bf16",
      precision: "bf16"
    }, "Load T5 Encoder");
    const vaeId = nextNodeId();
    workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
      model: "cogvideox_vae",
      precision: "bf16"
    }, "Load CogVideo VAE");
    const encodePromptId = nextNodeId();
    workflow[encodePromptId] = createNode("CogVideoTextEncode", {
      text_encoder: conn(t5Id),
      prompt: params.prompt,
      force_offload: true
    }, "Encode Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlCogVideo", {
      model: conn(cogVideoId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const generateId = nextNodeId();
    workflow[generateId] = createNode("CogVideoImageToVideo", {
      model: conn(ttmControlId),
      positive: conn(encodePromptId),
      image: conn(resizeId),
      vae: conn(vaeId),
      width: params.width,
      height: params.height,
      num_frames: params.frameCount,
      steps: params.steps || 50,
      cfg: params.cfgScale || 6,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "CogVideoX DDIM"
    }, "CogVideoX I2V");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("CogVideoDecode", {
      vae: conn(vaeId),
      samples: conn(generateId),
      enable_vae_tiling: true
    }, "Decode Video");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_cogvideo_output"
    });
  } else {
    const baseModelId = nextNodeId();
    workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
      ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
    }, "Load SVD");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlSVD", {
      model: conn(baseModelId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const encodeId = nextNodeId();
    workflow[encodeId] = createNode("SVDEncode", {
      model: conn(ttmControlId),
      image: conn(resizeId),
      vae: conn(baseModelId, 2),
      width: params.width,
      height: params.height,
      video_frames: params.frameCount,
      motion_bucket_id: 127,
      fps: params.fps,
      augmentation_level: 0
    }, "SVD Encode");
    const sampleId = addKSampler(
      workflow,
      conn(ttmControlId),
      conn(encodeId, 1),
      conn(encodeId, 2),
      conn(encodeId),
      { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
    );
    const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_svd_output"
    });
  }
  return workflow;
}
function generateControlNetWorkflow(params, controlType) {
  resetNodeIds();
  const workflow = {};
  const controlnetModels = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  };
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "v1-5-pruned-emaonly.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || controlnetModels[controlType]
  }, `Load ControlNet ${controlType}`);
  const controlLoaderId = nextNodeId();
  workflow[controlLoaderId] = createNode("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(controlLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || `controlnet_${controlType}`
  });
  return workflow;
}
function generateWorkflowForTarget(target, params) {
  switch (target) {
    case "wan22-i2v":
      return generateWan22I2VWorkflow(params);
    case "wan22-t2v":
      return generateWan22I2VWorkflow({ ...params, referenceImage: void 0 });
    case "wan22-fun-camera":
      return generateWan22FunCameraWorkflow(params);
    case "wan22-first-last":
      return generateWan22FirstLastWorkflow(params);
    case "uni3c-camera":
    case "uni3c-motion":
      return generateUni3CWorkflow(params);
    case "motionctrl":
    case "motionctrl-svd":
      return generateMotionCtrlWorkflow(params);
    case "cogvideox":
      return generateCogVideoXWorkflow(params);
    case "controlnet-depth":
      return generateControlNetDepthWorkflow(params);
    case "controlnet-canny":
      return generateControlNetWorkflow(params, "canny");
    case "controlnet-lineart":
      return generateControlNetWorkflow(params, "lineart");
    case "animatediff-cameractrl":
      return generateAnimateDiffCameraCtrlWorkflow(params);
    case "ttm":
    case "ttm-wan":
    case "ttm-cogvideox":
    case "ttm-svd":
      return generateTTMWorkflow(params);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${target}`);
  }
}
function validateWorkflow(workflow) {
  const errors = [];
  const warnings = [];
  const nodeIds = Object.keys(workflow);
  for (const [nodeId, node] of Object.entries(workflow)) {
    if (!node.class_type) {
      errors.push(`Node ${nodeId}: missing class_type`);
    }
    for (const [inputName, inputValue] of Object.entries(node.inputs)) {
      if (Array.isArray(inputValue) && inputValue.length === 2) {
        const [refNodeId] = inputValue;
        if (typeof refNodeId === "string" && !nodeIds.includes(refNodeId)) {
          errors.push(`Node ${nodeId}.${inputName}: references non-existent node ${refNodeId}`);
        }
      }
    }
  }
  const hasOutput = Object.values(workflow).some(
    (node) => node.class_type.includes("Save") || node.class_type.includes("Output") || node.class_type.includes("Preview")
  );
  if (!hasOutput) {
    warnings.push("Workflow has no output/save nodes");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

class ExportPipeline {
  layers;
  cameraKeyframes;
  config;
  onProgress;
  abortSignal;
  aborted = false;
  constructor(options) {
    this.layers = options.layers;
    this.cameraKeyframes = options.cameraKeyframes;
    this.config = options.config;
    this.onProgress = options.onProgress || (() => {
    });
    this.abortSignal = options.abortSignal;
    if (this.abortSignal) {
      this.abortSignal.addEventListener("abort", () => {
        this.aborted = true;
      });
    }
  }
  checkAborted() {
    if (this.aborted) {
      throw new Error("Export aborted");
    }
  }
  updateProgress(progress) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...progress
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const startTime = Date.now();
    const result = {
      success: false,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const configErrors = this.validateConfig();
      if (configErrors.length > 0) {
        result.errors = configErrors;
        return result;
      }
      if (this.config.exportReferenceFrame) {
        this.checkAborted();
        await this.renderReferenceFrame(result);
      }
      if (this.config.exportLastFrame) {
        this.checkAborted();
        await this.renderLastFrame(result);
      }
      if (this.config.exportDepthMap) {
        this.checkAborted();
        await this.renderDepthSequence(result);
      }
      if (this.config.exportControlImages) {
        this.checkAborted();
        await this.renderControlSequence(result);
      }
      if (this.config.exportCameraData) {
        this.checkAborted();
        await this.exportCameraData(result);
      }
      this.checkAborted();
      await this.generateWorkflow(result);
      if (this.config.autoQueueWorkflow && this.config.comfyuiServer) {
        this.checkAborted();
        await this.queueWorkflow(result);
      }
      result.success = result.errors.length === 0;
    } catch (error) {
      if (error instanceof Error && error.message === "Export aborted") {
        result.errors.push("Export was cancelled");
      } else {
        result.errors.push(error instanceof Error ? error.message : "Unknown error");
      }
    }
    result.duration = Date.now() - startTime;
    return result;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const errors = [];
    if (this.config.width < 64 || this.config.width > 4096) {
      errors.push("Width must be between 64 and 4096");
    }
    if (this.config.height < 64 || this.config.height > 4096) {
      errors.push("Height must be between 64 and 4096");
    }
    if (this.config.frameCount < 1 || this.config.frameCount > 1e3) {
      errors.push("Frame count must be between 1 and 1000");
    }
    if (this.config.fps < 1 || this.config.fps > 120) {
      errors.push("FPS must be between 1 and 120");
    }
    if (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) {
      errors.push("Invalid start frame");
    }
    if (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) {
      errors.push("Invalid end frame");
    }
    if (!this.config.prompt && this.needsPrompt()) {
      errors.push("Prompt is required for this export target");
    }
    return errors;
  }
  needsPrompt() {
    const noPromptTargets = ["controlnet-depth", "controlnet-canny", "controlnet-lineart"];
    return !noPromptTargets.includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.startFrame);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.referenceImage = uploadResult.name;
    } else {
      result.outputFiles.referenceImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.endFrame - 1);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.lastImage = uploadResult.name;
    } else {
      result.outputFiles.lastImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(ctx, frameIndex) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    const sortedLayers = [...this.layers].filter((layer) => layer.visible).sort((a, b) => {
      const az = a.transform?.position?.value?.z ?? 0;
      const bz = b.transform?.position?.value?.z ?? 0;
      return az - bz;
    });
    for (const layer of sortedLayers) {
      await this.renderLayerToCanvas(ctx, layer, frameIndex);
    }
  }
  async renderLayerToCanvas(ctx, layer, _frameIndex) {
    const pos = layer.transform?.position?.value ?? { x: 0, y: 0 };
    const scaleVal = layer.transform?.scale?.value ?? { x: 100, y: 100 };
    const rotation = layer.transform?.rotation?.value ?? 0;
    const opacity = typeof layer.opacity?.value === "number" ? layer.opacity.value : 100;
    ctx.save();
    ctx.globalAlpha = opacity / 100;
    ctx.translate(pos.x, pos.y);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scaleVal.x / 100, scaleVal.y / 100);
    const layerData = layer.data;
    if (layer.type === "image" && layerData?.src) {
      const img = await this.loadImage(layerData.src);
      ctx.drawImage(img, -img.width / 2, -img.height / 2);
    } else if (layer.type === "solid" && layerData?.color) {
      ctx.fillStyle = layerData.color || "#000000";
      const width = layerData.width ?? 100;
      const height = layerData.height ?? 100;
      ctx.fillRect(-width / 2, -height / 2, width, height);
    }
    ctx.restore();
  }
  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const depthFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: progress,
        overallProgress: 15 + progress * 0.25,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering depth frame ${i + 1}/${frameCount}`
      });
      const defaultCamera = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: false,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      };
      const depthResult = renderDepthFrame({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: defaultCamera,
        layers: this.layers,
        frame: frameIndex
      });
      const convertedDepth = convertDepthToFormat(
        depthResult,
        this.config.depthFormat
      );
      const imageData = depthToImageData(
        convertedDepth,
        this.config.width,
        this.config.height
      );
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      const blob = await canvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_depth_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "depth_sequence");
        depthFiles.push(uploadResult.name);
      } else {
        depthFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.depthSequence = depthFiles;
    this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const controlFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: progress,
        overallProgress: 40 + progress * 0.2,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering control frame ${i + 1}/${frameCount}`
      });
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      await this.renderFrameToCanvas(ctx, frameIndex);
      const controlCanvas = await this.applyControlPreprocessing(canvas, this.config.controlType || "depth");
      const blob = await controlCanvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_control_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "control_sequence");
        controlFiles.push(uploadResult.name);
      } else {
        controlFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.controlSequence = controlFiles;
    this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(input, controlType) {
    const output = new OffscreenCanvas(input.width, input.height);
    const ctx = output.getContext("2d");
    const inputCtx = input.getContext("2d");
    const imageData = inputCtx.getImageData(0, 0, input.width, input.height);
    const data = imageData.data;
    switch (controlType) {
      case "canny":
        this.applyEdgeDetection(data, input.width, input.height);
        break;
      case "lineart":
        this.applyLineart(data);
        break;
      case "softedge":
        this.applySoftEdge(data, input.width, input.height);
        break;
    }
    ctx.putImageData(imageData, 0, 0);
    return output;
  }
  applyEdgeDetection(data, width, height) {
    const grayscale = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      grayscale[i] = (data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114) / 255;
    }
    const edges = new Float32Array(width * height);
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = y * width + x;
        const gx = -grayscale[idx - width - 1] + grayscale[idx - width + 1] + -2 * grayscale[idx - 1] + 2 * grayscale[idx + 1] + -grayscale[idx + width - 1] + grayscale[idx + width + 1];
        const gy = -grayscale[idx - width - 1] - 2 * grayscale[idx - width] - grayscale[idx - width + 1] + grayscale[idx + width - 1] + 2 * grayscale[idx + width] + grayscale[idx + width + 1];
        edges[idx] = Math.min(1, Math.sqrt(gx * gx + gy * gy) * 2);
      }
    }
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      const val = Math.floor(edges[i] * 255);
      data[idx] = val;
      data[idx + 1] = val;
      data[idx + 2] = val;
    }
  }
  applyLineart(data) {
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      const val = gray > 128 ? 255 : 0;
      data[i] = val;
      data[i + 1] = val;
      data[i + 2] = val;
    }
  }
  applySoftEdge(data, width, height) {
    this.applyEdgeDetection(data, width, height);
    const temp = new Uint8ClampedArray(data);
    const kernel = 2;
    for (let y = kernel; y < height - kernel; y++) {
      for (let x = kernel; x < width - kernel; x++) {
        let sum = 0;
        let count = 0;
        for (let ky = -kernel; ky <= kernel; ky++) {
          for (let kx = -kernel; kx <= kernel; kx++) {
            const idx2 = ((y + ky) * width + (x + kx)) * 4;
            sum += temp[idx2];
            count++;
          }
        }
        const idx = (y * width + x) * 4;
        const val = Math.floor(sum / count);
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
    }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(result) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const exportCamera = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: false,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: false
      }};
    const cameraData = exportCameraForTarget(
      this.config.target,
      exportCamera,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    );
    const filename = `${this.config.filenamePrefix}_camera.json`;
    const blob = new Blob([JSON.stringify(cameraData, null, 2)], { type: "application/json" });
    if (this.config.comfyuiServer) {
      result.outputFiles.cameraData = filename;
    } else {
      result.outputFiles.cameraData = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(result) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const params = {
      referenceImage: result.outputFiles.referenceImage,
      lastFrameImage: result.outputFiles.lastImage,
      depthSequence: result.outputFiles.depthSequence,
      controlImages: result.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    if (result.outputFiles.cameraData) {
      params.cameraData = result.outputFiles.cameraData;
    }
    const workflow = generateWorkflowForTarget(this.config.target, params);
    const validation = validateWorkflow(workflow);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
    }
    result.warnings.push(...validation.warnings);
    const filename = `${this.config.filenamePrefix}_workflow.json`;
    const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: "application/json" });
    result.outputFiles.workflowJson = await this.saveBlobLocally(blob, filename);
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(result) {
    if (!this.config.comfyuiServer || !result.outputFiles.workflowJson) {
      return;
    }
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const client = getComfyUIClient(this.config.comfyuiServer);
    const connected = await client.checkConnection();
    if (!connected) {
      result.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const response = await fetch(result.outputFiles.workflowJson);
    const workflow = await response.json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const promptResult = await client.queuePrompt(workflow);
    result.outputFiles.promptId = promptResult.prompt_id;
    if (promptResult.node_errors && Object.keys(promptResult.node_errors).length > 0) {
      result.errors.push("Workflow has node errors: " + JSON.stringify(promptResult.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await client.waitForPrompt(promptResult.prompt_id, (progress) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: progress.percentage,
          overallProgress: 80 + progress.percentage * 0.15,
          message: `Generating: ${progress.percentage.toFixed(0)}%`,
          preview: progress.preview
        });
      });
      this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return url;
  }
}
async function exportToComfyUI(layers, cameraKeyframes, config, onProgress) {
  const pipeline = new ExportPipeline({
    layers,
    cameraKeyframes,
    config,
    onProgress
  });
  return pipeline.execute();
}

const _hoisted_1$4 = { class: "export-dialog" };
const _hoisted_2$4 = { class: "dialog-tabs" };
const _hoisted_3$4 = { class: "dialog-content" };
const _hoisted_4$4 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_5$4 = { class: "target-grid" };
const _hoisted_6$4 = { class: "target-buttons" };
const _hoisted_7$4 = ["onClick"];
const _hoisted_8$4 = {
  key: 0,
  class: "target-info"
};
const _hoisted_9$4 = { class: "info-row" };
const _hoisted_10$4 = { class: "info-row" };
const _hoisted_11$4 = { class: "info-row" };
const _hoisted_12$4 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_13$4 = { class: "settings-section" };
const _hoisted_14$4 = { class: "preset-buttons" };
const _hoisted_15$4 = ["onClick"];
const _hoisted_16$4 = { class: "input-row" };
const _hoisted_17$4 = { class: "settings-section" };
const _hoisted_18$4 = { class: "preset-buttons" };
const _hoisted_19$4 = ["onClick"];
const _hoisted_20$4 = { class: "input-row" };
const _hoisted_21$4 = { class: "input-row" };
const _hoisted_22$4 = { class: "settings-section" };
const _hoisted_23$4 = { class: "checkbox-grid" };
const _hoisted_24$3 = {
  key: 0,
  class: "settings-section"
};
const _hoisted_25$3 = ["value"];
const _hoisted_26$3 = {
  key: 1,
  class: "settings-section"
};
const _hoisted_27$3 = ["value"];
const _hoisted_28$3 = {
  key: 2,
  class: "tab-content"
};
const _hoisted_29$3 = { class: "settings-section" };
const _hoisted_30$3 = { class: "settings-section" };
const _hoisted_31$1 = { class: "settings-section" };
const _hoisted_32$1 = { class: "input-row" };
const _hoisted_33$1 = { class: "input-row seed-row" };
const _hoisted_34$1 = {
  key: 3,
  class: "tab-content"
};
const _hoisted_35$1 = { class: "settings-section" };
const _hoisted_36$1 = { class: "server-row" };
const _hoisted_37$1 = { key: 0 };
const _hoisted_38$1 = { key: 1 };
const _hoisted_39$1 = { key: 2 };
const _hoisted_40$1 = { key: 3 };
const _hoisted_41 = { class: "settings-section" };
const _hoisted_42 = { class: "checkbox-large" };
const _hoisted_43 = {
  key: 0,
  class: "export-progress"
};
const _hoisted_44 = { class: "progress-header" };
const _hoisted_45 = { class: "progress-bar" };
const _hoisted_46 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_47 = {
  key: 1,
  class: "export-error"
};
const _hoisted_48 = { class: "dialog-footer" };
const _hoisted_49 = ["disabled"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const activeTab = ref("target");
    const selectedTarget = ref("wan22-i2v");
    const width = ref(832);
    const height = ref(480);
    const frameCount = ref(81);
    const fps = ref(24);
    const startFrame = ref(0);
    const endFrame = ref(81);
    const exportDepthMap = ref(true);
    const exportControlImages = ref(false);
    const exportCameraData = ref(true);
    const exportReferenceFrame = ref(true);
    const exportLastFrame = ref(false);
    const depthFormat = ref("midas");
    const controlType = ref("depth");
    const prompt = ref("");
    const negativePrompt = ref("blurry, low quality, distorted");
    const seed = ref(void 0);
    const steps = ref(30);
    const cfgScale = ref(5);
    const comfyuiServer = ref("127.0.0.1:8188");
    const autoQueueWorkflow = ref(false);
    const connectionStatus = ref("disconnected");
    const isExporting = ref(false);
    const exportProgress = ref(null);
    const exportError = ref(null);
    const abortController = ref(null);
    const targetInfo = computed(() => EXPORT_TARGET_INFO[selectedTarget.value]);
    const targetCategories = computed(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      "Uni3C": ["uni3c-camera", "uni3c-motion"],
      "MotionCtrl": ["motionctrl", "motionctrl-svd"],
      "Camera": ["animatediff-cameractrl", "camera-comfyui", "ati"],
      "Advanced": ["light-x", "ttm", "cogvideox"],
      "ControlNet": ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      "Custom": ["custom-workflow"]
    }));
    const targetDisplayName = computed(() => {
      const names = {
        "wan22-i2v": "Image to Video",
        "wan22-t2v": "Text to Video",
        "wan22-fun-camera": "Fun Camera",
        "wan22-first-last": "First + Last Frame",
        "wan-move": "Point Trajectories",
        "uni3c-camera": "Camera Control",
        "uni3c-motion": "Motion + Camera",
        "motionctrl": "MotionCtrl",
        "motionctrl-svd": "MotionCtrl SVD",
        "cogvideox": "CogVideoX I2V",
        "animatediff-cameractrl": "CameraCtrl",
        "camera-comfyui": "4x4 Matrices",
        "ati": "Any Trajectory",
        "light-x": "Relighting",
        "ttm": "Cut & Drag",
        "controlnet-depth": "Depth",
        "controlnet-canny": "Canny Edge",
        "controlnet-lineart": "Line Art",
        "custom-workflow": "Custom Workflow"
      };
      return names;
    });
    const depthFormats = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ];
    const controlTypes = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function selectTarget(target) {
      selectedTarget.value = target;
      const preset = EXPORT_PRESETS[target];
      if (preset) {
        width.value = preset.width ?? 832;
        height.value = preset.height ?? 480;
        frameCount.value = preset.frameCount ?? 81;
        fps.value = preset.fps ?? 24;
        endFrame.value = frameCount.value;
      }
      const info = EXPORT_TARGET_INFO[target];
      if (info) {
        exportDepthMap.value = info.requiredInputs.includes("depth_sequence") || info.requiredInputs.includes("depth_map");
        exportCameraData.value = info.requiredInputs.includes("camera_data") || info.requiredInputs.includes("camera_trajectory") || info.requiredInputs.includes("camera_poses");
        exportReferenceFrame.value = info.requiredInputs.includes("reference_image") || info.requiredInputs.includes("first_frame");
        exportLastFrame.value = info.requiredInputs.includes("last_frame");
        exportControlImages.value = target.startsWith("controlnet-");
      }
    }
    async function checkConnection() {
      connectionStatus.value = "connecting";
      try {
        const client = getComfyUIClient(comfyuiServer.value);
        const connected = await client.checkConnection();
        connectionStatus.value = connected ? "connected" : "error";
      } catch {
        connectionStatus.value = "error";
      }
    }
    function applyResolutionPreset(preset) {
      width.value = preset.width;
      height.value = preset.height;
    }
    function applyFrameCountPreset(count) {
      frameCount.value = count;
      endFrame.value = Math.min(endFrame.value, count);
    }
    function randomizeSeed() {
      seed.value = Math.floor(Math.random() * 2147483647);
    }
    async function startExport() {
      isExporting.value = true;
      exportError.value = null;
      abortController.value = new AbortController();
      const config = {
        target: selectedTarget.value,
        width: width.value,
        height: height.value,
        frameCount: frameCount.value,
        fps: fps.value,
        startFrame: startFrame.value,
        endFrame: endFrame.value,
        outputDir: "",
        filenamePrefix: `weyl_${selectedTarget.value}_${Date.now()}`,
        exportDepthMap: exportDepthMap.value,
        exportControlImages: exportControlImages.value,
        exportCameraData: exportCameraData.value,
        exportReferenceFrame: exportReferenceFrame.value,
        exportLastFrame: exportLastFrame.value,
        depthFormat: depthFormat.value,
        controlType: controlType.value,
        prompt: prompt.value,
        negativePrompt: negativePrompt.value,
        seed: seed.value,
        steps: steps.value,
        cfgScale: cfgScale.value,
        comfyuiServer: comfyuiServer.value,
        autoQueueWorkflow: autoQueueWorkflow.value
      };
      try {
        const result = await exportToComfyUI(
          props.layers,
          props.cameraKeyframes,
          config,
          (progress) => {
            exportProgress.value = progress;
          }
        );
        if (result.success) {
          emit("exported", result);
        } else {
          exportError.value = result.errors.join("\n");
        }
      } catch (error) {
        exportError.value = error instanceof Error ? error.message : "Export failed";
      } finally {
        isExporting.value = false;
        abortController.value = null;
      }
    }
    function cancelExport() {
      if (abortController.value) {
        abortController.value.abort();
      }
    }
    function close() {
      if (isExporting.value) {
        cancelExport();
      }
      emit("close");
    }
    onMounted(() => {
      endFrame.value = Math.min(frameCount.value, props.totalFrames);
      checkConnection();
    });
    watch(selectedTarget, () => {
      selectTarget(selectedTarget.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: withModifiers(close, ["self"])
      }, [
        createBaseVNode("div", _hoisted_1$4, [
          createBaseVNode("header", { class: "dialog-header" }, [
            _cache[24] || (_cache[24] = createBaseVNode("h2", null, "Export to ComfyUI", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: close
            }, "Ã—")
          ]),
          createBaseVNode("nav", _hoisted_2$4, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "target" }),
              onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "target")
            }, " Target ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "output" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "output")
            }, " Output ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "generation" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "generation")
            }, " Generation ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "comfyui" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          createBaseVNode("div", _hoisted_3$4, [
            activeTab.value === "target" ? (openBlock(), createElementBlock("div", _hoisted_4$4, [
              createBaseVNode("div", _hoisted_5$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(targetCategories.value, (targets, category) => {
                  return openBlock(), createElementBlock("div", {
                    key: category,
                    class: "target-category"
                  }, [
                    createBaseVNode("h3", null, toDisplayString(category), 1),
                    createBaseVNode("div", _hoisted_6$4, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                        return openBlock(), createElementBlock("button", {
                          key: target,
                          class: normalizeClass({ selected: selectedTarget.value === target }),
                          onClick: ($event) => selectTarget(target)
                        }, toDisplayString(targetDisplayName.value[target]), 11, _hoisted_7$4);
                      }), 128))
                    ])
                  ]);
                }), 128))
              ]),
              targetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
                createBaseVNode("h4", null, toDisplayString(targetDisplayName.value[selectedTarget.value]), 1),
                createBaseVNode("div", _hoisted_9$4, [
                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "label" }, "Required:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_10$4, [
                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "label" }, "Optional:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_11$4, [
                  _cache[27] || (_cache[27] = createBaseVNode("span", { class: "label" }, "Outputs:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.outputTypes.join(", ")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "output" ? (openBlock(), createElementBlock("div", _hoisted_12$4, [
              createBaseVNode("div", _hoisted_13$4, [
                _cache[28] || (_cache[28] = createBaseVNode("h3", null, "Resolution", -1)),
                createBaseVNode("div", _hoisted_14$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(RESOLUTION_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyResolutionPreset(preset)
                    }, toDisplayString(preset.name), 9, _hoisted_15$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_16$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: width.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => width.value = $event),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: height.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => height.value = $event),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$4, [
                _cache[29] || (_cache[29] = createBaseVNode("h3", null, "Frames", -1)),
                createBaseVNode("div", _hoisted_18$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(FRAME_COUNT_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyFrameCountPreset(preset.frameCount)
                    }, toDisplayString(preset.name), 9, _hoisted_19$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_20$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: frameCount.value,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => frameCount.value = $event),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: fps.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => fps.value = $event),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: startFrame.value,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => startFrame.value = $event),
                    label: "Start",
                    min: 0,
                    max: endFrame.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  createVNode(ScrubableNumber, {
                    modelValue: endFrame.value,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => endFrame.value = $event),
                    label: "End",
                    min: startFrame.value + 1,
                    max: frameCount.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              createBaseVNode("div", _hoisted_22$4, [
                _cache[35] || (_cache[35] = createBaseVNode("h3", null, "Export Options", -1)),
                createBaseVNode("div", _hoisted_23$4, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => exportReferenceFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportReferenceFrame.value]
                    ]),
                    _cache[30] || (_cache[30] = createTextVNode(" Reference Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => exportLastFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportLastFrame.value]
                    ]),
                    _cache[31] || (_cache[31] = createTextVNode(" Last Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => exportDepthMap.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportDepthMap.value]
                    ]),
                    _cache[32] || (_cache[32] = createTextVNode(" Depth Maps ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => exportControlImages.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportControlImages.value]
                    ]),
                    _cache[33] || (_cache[33] = createTextVNode(" Control Images ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => exportCameraData.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportCameraData.value]
                    ]),
                    _cache[34] || (_cache[34] = createTextVNode(" Camera Data ", -1))
                  ])
                ])
              ]),
              exportDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_24$3, [
                _cache[36] || (_cache[36] = createBaseVNode("h3", null, "Depth Format", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => depthFormat.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(depthFormats, (fmt) => {
                    return createBaseVNode("option", {
                      key: fmt.value,
                      value: fmt.value
                    }, toDisplayString(fmt.label), 9, _hoisted_25$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, depthFormat.value]
                ])
              ])) : createCommentVNode("", true),
              exportControlImages.value ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                _cache[37] || (_cache[37] = createBaseVNode("h3", null, "Control Type", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => controlType.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(controlTypes, (ct) => {
                    return createBaseVNode("option", {
                      key: ct.value,
                      value: ct.value
                    }, toDisplayString(ct.label), 9, _hoisted_27$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, controlType.value]
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "generation" ? (openBlock(), createElementBlock("div", _hoisted_28$3, [
              createBaseVNode("div", _hoisted_29$3, [
                _cache[38] || (_cache[38] = createBaseVNode("h3", null, "Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => prompt.value = $event),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_30$3, [
                _cache[39] || (_cache[39] = createBaseVNode("h3", null, "Negative Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => negativePrompt.value = $event),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [vModelText, negativePrompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_31$1, [
                _cache[40] || (_cache[40] = createBaseVNode("h3", null, "Parameters", -1)),
                createBaseVNode("div", _hoisted_32$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: steps.value,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => steps.value = $event),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: cfgScale.value,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => cfgScale.value = $event),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_33$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: seed.value ?? 0,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => seed.value = v),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("button", {
                    class: "randomize-btn",
                    onClick: randomizeSeed
                  }, "Random")
                ])
              ])
            ])) : createCommentVNode("", true),
            activeTab.value === "comfyui" ? (openBlock(), createElementBlock("div", _hoisted_34$1, [
              createBaseVNode("div", _hoisted_35$1, [
                _cache[41] || (_cache[41] = createBaseVNode("h3", null, "Server", -1)),
                createBaseVNode("div", _hoisted_36$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => comfyuiServer.value = $event),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [vModelText, comfyuiServer.value]
                  ]),
                  createBaseVNode("button", { onClick: checkConnection }, toDisplayString(connectionStatus.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["connection-status", connectionStatus.value])
                }, [
                  connectionStatus.value === "connected" ? (openBlock(), createElementBlock("span", _hoisted_37$1, "Connected")) : connectionStatus.value === "error" ? (openBlock(), createElementBlock("span", _hoisted_38$1, "Connection failed")) : connectionStatus.value === "connecting" ? (openBlock(), createElementBlock("span", _hoisted_39$1, "Connecting...")) : (openBlock(), createElementBlock("span", _hoisted_40$1, "Not connected"))
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_41, [
                _cache[43] || (_cache[43] = createBaseVNode("h3", null, "Workflow", -1)),
                createBaseVNode("label", _hoisted_42, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => autoQueueWorkflow.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, autoQueueWorkflow.value]
                  ]),
                  _cache[42] || (_cache[42] = createBaseVNode("span", null, [
                    createBaseVNode("strong", null, "Auto-queue workflow"),
                    createBaseVNode("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : createCommentVNode("", true)
          ]),
          isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_43, [
            createBaseVNode("div", _hoisted_44, [
              createBaseVNode("span", null, toDisplayString(exportProgress.value?.message || "Exporting..."), 1),
              createBaseVNode("button", { onClick: cancelExport }, "Cancel")
            ]),
            createBaseVNode("div", _hoisted_45, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value?.overallProgress || 0}%` })
              }, null, 4)
            ]),
            exportProgress.value?.currentFrame ? (openBlock(), createElementBlock("div", _hoisted_46, " Frame " + toDisplayString(exportProgress.value.currentFrame) + " / " + toDisplayString(exportProgress.value.totalFrames), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          exportError.value ? (openBlock(), createElementBlock("div", _hoisted_47, toDisplayString(exportError.value), 1)) : createCommentVNode("", true),
          createBaseVNode("footer", _hoisted_48, [
            createBaseVNode("button", {
              class: "secondary",
              onClick: close
            }, "Cancel"),
            createBaseVNode("button", {
              class: "primary",
              disabled: isExporting.value,
              onClick: startExport
            }, toDisplayString(isExporting.value ? "Exporting..." : "Export"), 9, _hoisted_49)
          ])
        ])
      ]);
    };
  }
});

const ComfyUIExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-784836ff"]]);

const _hoisted_1$3 = { class: "dialog-container" };
const _hoisted_2$3 = { class: "dialog-content" };
const _hoisted_3$3 = { class: "form-row" };
const _hoisted_4$3 = { class: "tabs" };
const _hoisted_5$3 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_6$3 = { class: "form-row" };
const _hoisted_7$3 = { class: "form-row dimensions-row" };
const _hoisted_8$3 = { class: "dimension-group" };
const _hoisted_9$3 = { class: "dimension-group" };
const _hoisted_10$3 = { class: "form-row" };
const _hoisted_11$3 = { class: "aspect-info" };
const _hoisted_12$3 = { class: "form-row" };
const _hoisted_13$3 = { class: "form-row" };
const _hoisted_14$3 = { class: "resolution-info" };
const _hoisted_15$3 = { class: "form-row" };
const _hoisted_16$3 = { class: "duration-inputs" };
const _hoisted_17$3 = { class: "duration-helper" };
const _hoisted_18$3 = { class: "form-row" };
const _hoisted_19$3 = { class: "color-picker-row" };
const _hoisted_20$3 = { class: "color-label" };
const _hoisted_21$3 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_22$3 = { class: "form-row" };
const _hoisted_23$3 = { class: "form-row" };
const _hoisted_24$2 = { class: "form-row" };
const _hoisted_25$2 = { class: "motion-blur-settings" };
const _hoisted_26$2 = {
  key: 0,
  class: "motion-blur-params"
};
const _hoisted_27$2 = { class: "param-row" };
const _hoisted_28$2 = { class: "param-row" };
const _hoisted_29$2 = { class: "dialog-footer" };
const _hoisted_30$2 = { class: "preview-toggle" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const activeTab = ref("basic");
    const selectedPreset = ref("custom");
    const lockAspectRatio = ref(false);
    const aspectRatio = ref(16 / 9);
    const previewChanges = ref(false);
    const settings = ref({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: true,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: false,
      shutterAngle: 180,
      shutterPhase: -90
    });
    const frameAspectRatio = computed(() => {
      const ratio = settings.value.width / settings.value.height * settings.value.pixelAspectRatio;
      if (Math.abs(ratio - 16 / 9) < 0.01) return "16:9 (1.78)";
      if (Math.abs(ratio - 4 / 3) < 0.01) return "4:3 (1.33)";
      if (Math.abs(ratio - 1) < 0.01) return "1:1 (1.0)";
      if (Math.abs(ratio - 9 / 16) < 0.01) return "9:16 (0.56)";
      if (Math.abs(ratio - 21 / 9) < 0.01) return "21:9 (2.33)";
      return `${ratio.toFixed(2)}`;
    });
    const durationSeconds = computed(() => {
      return settings.value.frameCount / settings.value.fps;
    });
    const durationTimecode = ref("00:00:10:00");
    const resolutionInfo = computed(() => {
      const divisors = { full: 1, half: 2, third: 3, quarter: 4 };
      const d = divisors[settings.value.resolution];
      const w = Math.floor(settings.value.width / d);
      const h = Math.floor(settings.value.height / d);
      const mb = (w * h * 4 / (1024 * 1024)).toFixed(1);
      return `${w} x ${h}, ${mb} MB per 8bpc frame`;
    });
    const presets = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      "instagram_square": { width: 1080, height: 1080, fps: 30 },
      "instagram_story": { width: 1080, height: 1920, fps: 30 },
      "tiktok": { width: 1080, height: 1920, fps: 30 },
      "youtube_short": { width: 1080, height: 1920, fps: 60 },
      "sd15_512": { width: 512, height: 512, fps: 8 },
      "sd15_768": { width: 768, height: 512, fps: 8 },
      "sdxl_1024": { width: 1024, height: 1024, fps: 8 },
      "wan_480p": { width: 832, height: 480, fps: 16 },
      "wan_720p": { width: 1280, height: 720, fps: 16 }
    };
    function applyPreset() {
      const preset = presets[selectedPreset.value];
      if (preset) {
        if (preset.width) settings.value.width = preset.width;
        if (preset.height) settings.value.height = preset.height;
        if (preset.fps) settings.value.fps = preset.fps;
        aspectRatio.value = settings.value.width / settings.value.height;
        updateDurationTimecode();
      }
    }
    function onDimensionChange(changed) {
      settings.value.width = Math.round(settings.value.width / 8) * 8;
      settings.value.height = Math.round(settings.value.height / 8) * 8;
      if (lockAspectRatio.value) {
        if (changed === "width") {
          settings.value.height = Math.round(settings.value.width / aspectRatio.value / 8) * 8;
        } else {
          settings.value.width = Math.round(settings.value.height * aspectRatio.value / 8) * 8;
        }
      } else {
        aspectRatio.value = settings.value.width / settings.value.height;
      }
      selectedPreset.value = "custom";
    }
    function parseDuration() {
      const parts = durationTimecode.value.split(":").map((p) => parseInt(p) || 0);
      if (parts.length === 4) {
        const [hours, minutes, seconds, frames] = parts;
        const totalSeconds = hours * 3600 + minutes * 60 + seconds;
        settings.value.frameCount = Math.round(totalSeconds * settings.value.fps) + frames;
      } else if (parts.length === 1) {
        settings.value.frameCount = parts[0];
      }
    }
    function updateDurationTimecode() {
      const totalFrames = settings.value.frameCount;
      const fps = settings.value.fps;
      const totalSeconds = Math.floor(totalFrames / fps);
      const frames = totalFrames % Math.round(fps);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor(totalSeconds % 3600 / 60);
      const seconds = totalSeconds % 60;
      durationTimecode.value = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}:${pad(frames)}`;
    }
    function pad(n) {
      return n.toString().padStart(2, "0");
    }
    function loadCurrentSettings() {
      settings.value = {
        name: store.project?.meta?.name || "Main Comp",
        width: store.width,
        height: store.height,
        pixelAspectRatio: 1,
        fps: store.fps,
        frameCount: store.frameCount,
        resolution: "full",
        backgroundColor: store.project?.composition?.backgroundColor || "#000000",
        autoResizeToContent: store.project?.composition?.autoResizeToContent ?? true,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: false,
        shutterAngle: 180,
        shutterPhase: -90
      };
      aspectRatio.value = settings.value.width / settings.value.height;
      updateDurationTimecode();
    }
    function cancel() {
      emit("close");
    }
    function confirm() {
      emit("confirm", { ...settings.value });
      emit("close");
    }
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && !e.shiftKey) {
        confirm();
      }
    }
    watch(() => props.visible, (visible) => {
      if (visible) {
        loadCurrentSettings();
      }
    });
    watch(settings, () => {
      if (previewChanges.value && props.visible) {
        store.resizeComposition(settings.value.width, settings.value.height, settings.value.frameCount);
      }
    }, { deep: true });
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$3, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[20] || (_cache[20] = createBaseVNode("span", { class: "dialog-title" }, "Composition Settings", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "Ã—")
            ]),
            createBaseVNode("div", _hoisted_2$3, [
              createBaseVNode("div", _hoisted_3$3, [
                _cache[21] || (_cache[21] = createBaseVNode("label", null, "Composition Name:", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => settings.value.name = $event),
                  class: "text-input full-width"
                }, null, 512), [
                  [vModelText, settings.value.name]
                ])
              ]),
              createBaseVNode("div", _hoisted_4$3, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "basic" }),
                  onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "basic")
                }, "Basic", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "advanced" }),
                  onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "advanced")
                }, "Advanced", 2)
              ]),
              activeTab.value === "basic" ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
                createBaseVNode("div", _hoisted_6$3, [
                  _cache[23] || (_cache[23] = createBaseVNode("label", null, "Preset:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedPreset.value = $event),
                    onChange: applyPreset,
                    class: "select-input"
                  }, [..._cache[22] || (_cache[22] = [
                    createBaseVNode("option", { value: "custom" }, "Custom", -1),
                    createBaseVNode("optgroup", { label: "Video" }, [
                      createBaseVNode("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                      createBaseVNode("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                      createBaseVNode("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                      createBaseVNode("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Social Media" }, [
                      createBaseVNode("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                      createBaseVNode("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                      createBaseVNode("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                      createBaseVNode("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "AI Video (ComfyUI)" }, [
                      createBaseVNode("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                      createBaseVNode("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                      createBaseVNode("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                      createBaseVNode("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                      createBaseVNode("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                    ], -1)
                  ])], 544), [
                    [vModelSelect, selectedPreset.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_7$3, [
                  createBaseVNode("div", _hoisted_8$3, [
                    _cache[24] || (_cache[24] = createBaseVNode("label", null, "Width:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => settings.value.width = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[5] || (_cache[5] = ($event) => onDimensionChange("width"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.width,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[25] || (_cache[25] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["lock-btn", { locked: lockAspectRatio.value }]),
                    onClick: _cache[6] || (_cache[6] = ($event) => lockAspectRatio.value = !lockAspectRatio.value),
                    title: "Lock Aspect Ratio"
                  }, toDisplayString(lockAspectRatio.value ? "ðŸ”’" : "ðŸ”“"), 3),
                  createBaseVNode("div", _hoisted_9$3, [
                    _cache[26] || (_cache[26] = createBaseVNode("label", null, "Height:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => settings.value.height = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[8] || (_cache[8] = ($event) => onDimensionChange("height"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.height,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[27] || (_cache[27] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_10$3, [
                  _cache[29] || (_cache[29] = createBaseVNode("label", null, "Pixel Aspect Ratio:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => settings.value.pixelAspectRatio = $event),
                    class: "select-input"
                  }, [..._cache[28] || (_cache[28] = [
                    createBaseVNode("option", { value: "1" }, "Square Pixels (1.0)", -1),
                    createBaseVNode("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                    createBaseVNode("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                    createBaseVNode("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.pixelAspectRatio]
                  ]),
                  createBaseVNode("span", _hoisted_11$3, "Frame Aspect Ratio: " + toDisplayString(frameAspectRatio.value), 1)
                ]),
                createBaseVNode("div", _hoisted_12$3, [
                  _cache[31] || (_cache[31] = createBaseVNode("label", null, "Frame Rate:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => settings.value.fps = $event),
                    class: "select-input short"
                  }, [..._cache[30] || (_cache[30] = [
                    createBaseVNode("option", { value: 8 }, "8", -1),
                    createBaseVNode("option", { value: 12 }, "12", -1),
                    createBaseVNode("option", { value: 15 }, "15", -1),
                    createBaseVNode("option", { value: 16 }, "16", -1),
                    createBaseVNode("option", { value: 23.976 }, "23.976", -1),
                    createBaseVNode("option", { value: 24 }, "24", -1),
                    createBaseVNode("option", { value: 25 }, "25", -1),
                    createBaseVNode("option", { value: 29.97 }, "29.97", -1),
                    createBaseVNode("option", { value: 30 }, "30", -1),
                    createBaseVNode("option", { value: 50 }, "50", -1),
                    createBaseVNode("option", { value: 59.94 }, "59.94", -1),
                    createBaseVNode("option", { value: 60 }, "60", -1)
                  ])], 512), [
                    [
                      vModelSelect,
                      settings.value.fps,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("span", { class: "unit" }, "frames per second", -1))
                ]),
                createBaseVNode("div", _hoisted_13$3, [
                  _cache[34] || (_cache[34] = createBaseVNode("label", null, "Resolution:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => settings.value.resolution = $event),
                    class: "select-input short"
                  }, [..._cache[33] || (_cache[33] = [
                    createBaseVNode("option", { value: "full" }, "Full", -1),
                    createBaseVNode("option", { value: "half" }, "Half", -1),
                    createBaseVNode("option", { value: "third" }, "Third", -1),
                    createBaseVNode("option", { value: "quarter" }, "Quarter", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.resolution]
                  ]),
                  createBaseVNode("span", _hoisted_14$3, toDisplayString(resolutionInfo.value), 1)
                ]),
                createBaseVNode("div", _hoisted_15$3, [
                  _cache[35] || (_cache[35] = createBaseVNode("label", null, "Duration:", -1)),
                  createBaseVNode("div", _hoisted_16$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => durationTimecode.value = $event),
                      class: "timecode-input",
                      placeholder: "00:00:00:00",
                      onBlur: parseDuration
                    }, null, 544), [
                      [vModelText, durationTimecode.value]
                    ]),
                    createBaseVNode("span", _hoisted_17$3, toDisplayString(settings.value.frameCount) + " frames = " + toDisplayString(durationSeconds.value.toFixed(2)) + "s ", 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$3, [
                  _cache[36] || (_cache[36] = createBaseVNode("label", null, "Background Color:", -1)),
                  createBaseVNode("div", _hoisted_19$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "color",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => settings.value.backgroundColor = $event),
                      class: "color-input"
                    }, null, 512), [
                      [vModelText, settings.value.backgroundColor]
                    ]),
                    createBaseVNode("span", _hoisted_20$3, toDisplayString(settings.value.backgroundColor), 1)
                  ])
                ])
              ])) : createCommentVNode("", true),
              activeTab.value === "advanced" ? (openBlock(), createElementBlock("div", _hoisted_21$3, [
                createBaseVNode("div", _hoisted_22$3, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => settings.value.autoResizeToContent = $event)
                    }, null, 512), [
                      [vModelCheckbox, settings.value.autoResizeToContent]
                    ]),
                    _cache[37] || (_cache[37] = createTextVNode(" Auto-resize composition when importing video ", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_23$3, [
                  _cache[38] || (_cache[38] = createBaseVNode("label", null, "Start Timecode:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => settings.value.startTimecode = $event),
                    class: "timecode-input",
                    placeholder: "00:00:00:00"
                  }, null, 512), [
                    [vModelText, settings.value.startTimecode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$2, [
                  _cache[44] || (_cache[44] = createBaseVNode("label", null, "Motion Blur:", -1)),
                  createBaseVNode("div", _hoisted_25$2, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => settings.value.motionBlurEnabled = $event)
                      }, null, 512), [
                        [vModelCheckbox, settings.value.motionBlurEnabled]
                      ]),
                      _cache[39] || (_cache[39] = createTextVNode(" Enable Motion Blur ", -1))
                    ]),
                    settings.value.motionBlurEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$2, [
                      createBaseVNode("div", _hoisted_27$2, [
                        _cache[40] || (_cache[40] = createBaseVNode("label", null, "Shutter Angle:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => settings.value.shutterAngle = $event),
                          min: "0",
                          max: "720",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterAngle,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[41] || (_cache[41] = createBaseVNode("span", { class: "unit" }, "Â°", -1))
                      ]),
                      createBaseVNode("div", _hoisted_28$2, [
                        _cache[42] || (_cache[42] = createBaseVNode("label", null, "Shutter Phase:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => settings.value.shutterPhase = $event),
                          min: "-360",
                          max: "360",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterPhase,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[43] || (_cache[43] = createBaseVNode("span", { class: "unit" }, "Â°", -1))
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_29$2, [
              createBaseVNode("div", _hoisted_30$2, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => previewChanges.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, previewChanges.value]
                  ]),
                  _cache[45] || (_cache[45] = createTextVNode(" Preview ", -1))
                ])
              ]),
              createBaseVNode("div", { class: "dialog-actions" }, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: confirm
                }, "OK")
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const CompositionSettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-76356b13"]]);

const logger$1 = createLogger("MotionIntentResolver");
const SYSTEM_PROMPT = `You are a motion graphics expert analyzing images for camera movements and animation paths.

Given an image, suggest motion paths and camera trajectories that would create compelling visual effects.

ALWAYS respond in valid JSON format with this structure:
{
  "description": "Brief description of suggested motion",
  "confidence": 0.0-1.0,
  "cameraIntents": [...],
  "splineIntents": [...],
  "particleIntents": [...],
  "layerIntents": [...]
}

For spline/path suggestions, provide control points as:
{
  "suggestedPoints": [
    { "id": "p1", "x": 100, "y": 200, "depth": 0.5, "handleIn": null, "handleOut": null, "type": "smooth" }
  ]
}

Consider:
- Depth information if available (closer = lower depth values)
- Subject positions and focal points
- Natural motion paths that follow scene geometry
- Parallax opportunities based on depth layers
`;
const PATH_SUGGESTION_PROMPT = `Analyze this image and suggest camera/motion paths.

Consider:
1. Main subjects and their positions
2. Depth layers (foreground, midground, background)
3. Natural movement paths that would be visually interesting
4. Points of interest to orbit around or move between

Suggest 2-3 different trajectory options with varying complexity.`;
class MotionIntentResolver {
  config;
  lastResult = null;
  constructor(config) {
    this.config = {
      modelId: config?.modelId ?? "rule-based",
      apiEndpoint: config?.apiEndpoint,
      apiKey: config?.apiKey,
      maxTokens: config?.maxTokens ?? 2048,
      temperature: config?.temperature ?? 0.7
    };
  }
  /**
   * Resolve a user prompt into structured motion intents
   */
  async resolve(prompt, context, modelOverride) {
    const modelId = modelOverride ?? this.config.modelId;
    logger$1.info(`Resolving motion intent with ${modelId}:`, prompt);
    try {
      let result;
      switch (modelId) {
        case "rule-based":
          result = await this.resolveWithRules(prompt, context);
          break;
        case "gpt-4v":
        case "gpt-4o":
          result = await this.resolveWithOpenAI(prompt, context, modelId);
          break;
        case "claude-vision":
          result = await this.resolveWithClaude(prompt, context);
          break;
        case "qwen-vl":
        case "qwen2-vl":
        case "llava":
        case "local-vlm":
          result = await this.resolveWithLocalVLM(prompt, context, modelId);
          break;
        default:
          result = await this.resolveWithRules(prompt, context);
      }
      this.lastResult = result;
      return result;
    } catch (error) {
      logger$1.error("Motion intent resolution failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  /**
   * Suggest paths based on image analysis
   * This is the main entry point for "suggest trajectories across image"
   */
  async suggestPaths(context, modelOverride) {
    return this.resolve(PATH_SUGGESTION_PROMPT, context, modelOverride);
  }
  // ============================================================================
  // RULE-BASED FALLBACK
  // ============================================================================
  async resolveWithRules(prompt, context) {
    const lowerPrompt = prompt.toLowerCase();
    const intents = {
      description: "Rule-based motion suggestion",
      confidence: 0.6,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: []
    };
    const cameraIntents = [];
    if (lowerPrompt.includes("dolly") || lowerPrompt.includes("push in") || lowerPrompt.includes("pull out")) {
      cameraIntents.push({
        type: "dolly",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "z",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("pan") || lowerPrompt.includes("sweep")) {
      cameraIntents.push({
        type: "pan",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "y",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("orbit") || lowerPrompt.includes("around")) {
      cameraIntents.push({
        type: "orbit",
        intensity: this.extractIntensity(lowerPrompt),
        durationFrames: context.frameCount,
        orbitCenter: { x: context.width / 2, y: context.height / 2, z: 0 },
        suggestedEasing: "linear"
      });
    }
    if (lowerPrompt.includes("drift") || lowerPrompt.includes("float") || lowerPrompt.includes("subtle")) {
      cameraIntents.push({
        type: "drift",
        intensity: "very_subtle",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("handheld") || lowerPrompt.includes("shake")) {
      cameraIntents.push({
        type: "handheld",
        intensity: this.extractIntensity(lowerPrompt),
        noiseAmount: lowerPrompt.includes("light") ? 0.3 : 0.6,
        durationFrames: context.frameCount
      });
    }
    const splineIntents = [];
    if (context.depthMap || lowerPrompt.includes("path") || lowerPrompt.includes("trajectory")) {
      const defaultPath = this.generateDefaultPath(context);
      splineIntents.push({
        usage: "camera_path",
        smoothness: 0.8,
        complexity: defaultPath.length,
        worldSpace: true,
        suggestedPoints: defaultPath,
        closed: false
      });
      if (context.depthMap) {
        const depthPath = this.generateDepthBasedPath(context);
        splineIntents.push({
          usage: "camera_path",
          smoothness: 0.9,
          complexity: depthPath.length,
          worldSpace: true,
          suggestedPoints: depthPath,
          closed: false
        });
      }
    }
    const particleIntents = [];
    if (lowerPrompt.includes("particle") || lowerPrompt.includes("dust") || lowerPrompt.includes("snow")) {
      particleIntents.push({
        behavior: lowerPrompt.includes("snow") ? "snow" : lowerPrompt.includes("dust") ? "dust" : "drift",
        intensity: 0.5,
        spread: 45,
        lifetime: 120
      });
    }
    return {
      ...intents,
      cameraIntents,
      splineIntents,
      particleIntents
    };
  }
  extractIntensity(prompt) {
    if (prompt.includes("very subtle") || prompt.includes("barely")) return "very_subtle";
    if (prompt.includes("subtle") || prompt.includes("gentle") || prompt.includes("soft")) return "subtle";
    if (prompt.includes("dramatic") || prompt.includes("intense") || prompt.includes("strong")) return "dramatic";
    if (prompt.includes("bold") || prompt.includes("dynamic")) return "strong";
    return "medium";
  }
  generateDefaultPath(context) {
    const { width, height } = context;
    const padding = Math.min(width, height) * 0.1;
    return [
      this.createControlPoint("p1", padding, height / 2, 0),
      this.createControlPoint("p2", width * 0.33, height * 0.3, 0.3),
      this.createControlPoint("p3", width * 0.66, height * 0.7, 0.6),
      this.createControlPoint("p4", width - padding, height / 2, 1)
    ];
  }
  generateDepthBasedPath(context) {
    const { width, height, depthMap } = context;
    if (!depthMap) {
      return this.generateDefaultPath(context);
    }
    const points = [];
    const numPoints = 5;
    for (let i = 0; i < numPoints; i++) {
      const t = i / (numPoints - 1);
      const x = width * (0.2 + t * 0.6);
      const y = height * (0.3 + Math.sin(t * Math.PI) * 0.4);
      const pixelIndex = Math.floor(y) * width + Math.floor(x);
      const depth = depthMap[pixelIndex] ?? 0.5;
      points.push(this.createControlPoint(`dp${i}`, x, y, depth));
    }
    return points;
  }
  createControlPoint(id, x, y, depth) {
    return {
      id,
      x,
      y,
      depth,
      handleIn: null,
      handleOut: null,
      type: "smooth"
    };
  }
  // ============================================================================
  // OPENAI GPT-4V / GPT-4o
  // ============================================================================
  async resolveWithOpenAI(prompt, context, model) {
    if (!this.config.apiKey) {
      logger$1.warn("OpenAI API key not configured, falling back to rule-based");
      return this.resolveWithRules(prompt, context);
    }
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: imageBase64 ? [
          { type: "text", text: prompt },
          { type: "image_url", image_url: { url: `data:image/png;base64,${imageBase64}` } }
        ] : prompt
      }
    ];
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: model === "gpt-4o" ? "gpt-4o" : "gpt-4-vision-preview",
          messages,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      return this.parseAIResponse(content, prompt);
    } catch (error) {
      logger$1.error("OpenAI API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // CLAUDE VISION
  // ============================================================================
  async resolveWithClaude(prompt, context) {
    if (!this.config.apiKey) {
      logger$1.warn("Anthropic API key not configured, falling back to rule-based");
      return this.resolveWithRules(prompt, context);
    }
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const content = imageBase64 ? [
      { type: "image", source: { type: "base64", media_type: "image/png", data: imageBase64 } },
      { type: "text", text: prompt }
    ] : [{ type: "text", text: prompt }];
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.config.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: this.config.maxTokens,
          system: SYSTEM_PROMPT,
          messages: [{ role: "user", content }]
        })
      });
      if (!response.ok) {
        throw new Error(`Anthropic API error: ${response.status}`);
      }
      const data = await response.json();
      const responseContent = data.content[0]?.text;
      return this.parseAIResponse(responseContent, prompt);
    } catch (error) {
      logger$1.error("Anthropic API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // LOCAL VLM (via ComfyUI or local endpoint)
  // ============================================================================
  async resolveWithLocalVLM(prompt, context, model) {
    const endpoint = this.config.apiEndpoint ?? "http://localhost:8188/api/vlm";
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model,
          prompt: `${SYSTEM_PROMPT}

User request: ${prompt}`,
          image: imageBase64,
          max_tokens: this.config.maxTokens
        })
      });
      if (!response.ok) {
        throw new Error(`Local VLM API error: ${response.status}`);
      }
      const data = await response.json();
      return this.parseAIResponse(data.response ?? data.text ?? data.content, prompt);
    } catch (error) {
      logger$1.error("Local VLM API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // RESPONSE PARSING
  // ============================================================================
  parseAIResponse(content, originalPrompt) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          description: parsed.description ?? "AI-generated motion suggestion",
          confidence: parsed.confidence ?? 0.8,
          cameraIntents: parsed.cameraIntents ?? [],
          splineIntents: parsed.splineIntents ?? [],
          particleIntents: parsed.particleIntents ?? [],
          layerIntents: parsed.layerIntents ?? [],
          rawResponse: content
        };
      }
    } catch (error) {
      logger$1.warn("Failed to parse AI response as JSON:", error);
    }
    return {
      description: content.slice(0, 200),
      confidence: 0.5,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: [],
      rawResponse: content
    };
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  imageDataToBase64(imageData) {
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL("image/png").split(",")[1];
  }
  /**
   * Get last resolution result
   */
  getLastResult() {
    return this.lastResult;
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
const motionIntentResolver = new MotionIntentResolver();

const logger = createLogger("MotionIntentTranslator");
const INTENSITY_TO_DISTANCE = {
  very_subtle: 10,
  subtle: 30,
  medium: 80,
  strong: 200,
  dramatic: 500
};
const INTENSITY_TO_ROTATION = {
  very_subtle: 2,
  subtle: 5,
  medium: 15,
  strong: 45,
  dramatic: 90
};
function getEasingHandles(easing, duration) {
  const third = duration / 3;
  switch (easing) {
    case "linear":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeIn":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "easeOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeInOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "bounce":
      return {
        inHandle: { frame: -third * 0.5, value: 0, enabled: true },
        outHandle: { frame: third * 0.5, value: 0, enabled: true }
      };
    case "elastic":
      return {
        inHandle: { frame: -third * 0.3, value: 0, enabled: true },
        outHandle: { frame: third * 0.3, value: 0, enabled: true }
      };
    default:
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
  }
}
class MotionIntentTranslator {
  /**
   * Translate a camera motion intent to keyframes
   */
  translateCameraIntent(intent, cameraLayerId, currentPosition, compositionFrameCount) {
    const duration = intent.durationFrames ?? compositionFrameCount;
    const distance = INTENSITY_TO_DISTANCE[intent.intensity];
    const rotation = INTENSITY_TO_ROTATION[intent.intensity];
    const easing = intent.suggestedEasing ?? "easeInOut";
    const batches = [];
    switch (intent.type) {
      case "dolly":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.z",
            currentPosition.z,
            currentPosition.z + (intent.axis === "z" ? distance : 0),
            0,
            duration,
            easing
          )
        );
        break;
      case "truck":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.x",
            currentPosition.x,
            currentPosition.x + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pedestal":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.y",
            currentPosition.y,
            currentPosition.y + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pan":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.y",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "tilt":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.x",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "roll":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.z",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "zoom":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "camera.fov",
            60,
            60 - distance * 0.5,
            // Narrower FOV = zoom in
            0,
            duration,
            easing
          )
        );
        break;
      case "drift":
        batches.push(
          ...this.createDriftKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "handheld":
        batches.push(
          ...this.createHandheldKeyframes(
            cameraLayerId,
            currentPosition,
            duration,
            intent.noiseAmount ?? 0.5
          )
        );
        break;
      case "orbit":
        if (intent.orbitCenter) {
          batches.push(
            ...this.createOrbitKeyframes(
              cameraLayerId,
              currentPosition,
              intent.orbitCenter,
              duration,
              intent.intensity
            )
          );
        }
        break;
      case "crane":
        batches.push(
          ...this.createCraneKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "follow_path":
        if (intent.suggestedPath) {
          logger.info("Camera path following requires spline layer creation");
        }
        break;
    }
    return batches;
  }
  /**
   * Translate a spline intent to a spline layer configuration
   */
  translateSplineIntent(intent, compositionWidth, compositionHeight) {
    const controlPoints = intent.suggestedPoints.map((p, i) => ({
      id: p.id ?? `sp_${i}`,
      x: p.x,
      y: p.y,
      depth: p.depth ?? 0,
      handleIn: this.generateHandle(intent.suggestedPoints, i, -1, intent.smoothness),
      handleOut: this.generateHandle(intent.suggestedPoints, i, 1, intent.smoothness),
      type: p.type ?? "smooth"
    }));
    return {
      keyframeBatches: [],
      newSplines: [
        {
          name: `AI Path - ${intent.usage}`,
          points: controlPoints,
          closed: intent.closed
        }
      ]
    };
  }
  /**
   * Translate a particle intent to emitter configuration
   */
  translateParticleIntent(intent, compositionWidth, compositionHeight) {
    const baseConfig = {
      emissionRate: intent.intensity * 20,
      particleLifetime: intent.lifetime ?? 60,
      spread: intent.spread ?? 30
    };
    switch (intent.behavior) {
      case "snow":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 50,
          speedVariance: 20,
          gravity: 0.1
        });
        break;
      case "rain":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 200,
          speedVariance: 30,
          gravity: 0.5
        });
        break;
      case "dust":
        Object.assign(baseConfig, {
          direction: 0,
          speed: 20,
          speedVariance: 15,
          gravity: 0
        });
        break;
      case "fireflies":
        Object.assign(baseConfig, {
          direction: 90,
          speed: 30,
          speedVariance: 20,
          gravity: -0.05
        });
        break;
      case "explosion":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 300,
          speedVariance: 100,
          initialBurst: 50,
          emissionRate: 0
        });
        break;
      case "vortex":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 100
          // Would need vortex force field
        });
        break;
    }
    return {
      keyframeBatches: [],
      newLayers: [
        {
          type: "particles",
          name: `AI Particles - ${intent.behavior}`,
          config: baseConfig
        }
      ]
    };
  }
  /**
   * Translate a layer motion intent to keyframes
   */
  translateLayerIntent(intent, layer, compositionFrameCount) {
    const duration = compositionFrameCount;
    const amplitude = intent.amplitude;
    const frequency = intent.frequency ?? 1;
    const batches = [];
    switch (intent.motionType) {
      case "parallax":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 50,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "float":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.y",
            0,
            amplitude * 30,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "sway":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 40,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "breathe":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.x",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          ),
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.y",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "pulse":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "opacity",
            100,
            100 - amplitude * 30,
            duration,
            frequency * 2,
            intent.phase ?? 0
          )
        );
        break;
      case "rotate":
        batches.push(
          this.createPositionKeyframes(
            layer.id,
            "transform.rotation.z",
            0,
            360 * frequency,
            0,
            duration,
            "linear"
          )
        );
        break;
    }
    return batches;
  }
  // ============================================================================
  // KEYFRAME GENERATORS
  // ============================================================================
  createPositionKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    const handles = getEasingHandles(easing, endFrame - startFrame);
    return {
      layerId,
      propertyPath,
      keyframes: [
        {
          id: `kf_${layerId}_${propertyPath}_0`,
          frame: startFrame,
          value: startValue,
          interpolation: easing === "linear" ? "linear" : "bezier",
          ...handles,
          controlMode: "smooth"
        },
        {
          id: `kf_${layerId}_${propertyPath}_1`,
          frame: endFrame,
          value: endValue,
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: false },
          outHandle: { frame: 0, value: 0, enabled: false },
          controlMode: "smooth"
        }
      ]
    };
  }
  createRotationKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    return this.createPositionKeyframes(
      layerId,
      propertyPath,
      startValue,
      endValue,
      startFrame,
      endFrame,
      easing
    );
  }
  createOscillatingKeyframes(layerId, propertyPath, centerValue, amplitude, duration, cycles, phase) {
    const keyframes = [];
    const framesPerCycle = duration / cycles;
    const quarterCycle = framesPerCycle / 4;
    for (let i = 0; i <= cycles * 4; i++) {
      const frame = Math.round(i * quarterCycle);
      if (frame > duration) break;
      const sinePhase = (i + phase * 4) % 4;
      let value;
      switch (sinePhase) {
        case 0:
          value = centerValue;
          break;
        case 1:
          value = centerValue + amplitude;
          break;
        case 2:
          value = centerValue;
          break;
        case 3:
          value = centerValue - amplitude;
          break;
        default:
          value = centerValue;
      }
      keyframes.push({
        id: `kf_${layerId}_${propertyPath}_${i}`,
        frame,
        value,
        interpolation: "bezier",
        inHandle: { frame: -quarterCycle * 0.5, value: 0, enabled: true },
        outHandle: { frame: quarterCycle * 0.5, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return { layerId, propertyPath, keyframes };
  }
  createDriftKeyframes(layerId, startPosition, duration, intensity) {
    const distance = INTENSITY_TO_DISTANCE[intensity] * 0.3;
    return [
      this.createOscillatingKeyframes(layerId, "transform.position.x", startPosition.x, distance, duration, 0.5, 0),
      this.createOscillatingKeyframes(layerId, "transform.position.y", startPosition.y, distance * 0.7, duration, 0.3, 0.25),
      this.createOscillatingKeyframes(layerId, "transform.position.z", startPosition.z, distance * 0.5, duration, 0.4, 0.5)
    ];
  }
  createHandheldKeyframes(layerId, startPosition, duration, noiseAmount) {
    const seed = this.hashString(layerId);
    const amplitude = noiseAmount * 5;
    const keyframes = [];
    for (const axis of ["x", "y", "z"]) {
      const axisKeyframes = [];
      const baseValue = startPosition[axis];
      const numKeyframes = Math.floor(duration / 4);
      for (let i = 0; i <= numKeyframes; i++) {
        const frame = Math.min(i * 4, duration);
        const noise = this.deterministicNoise(seed, axis, frame) * amplitude;
        axisKeyframes.push({
          id: `kf_${layerId}_handheld_${axis}_${i}`,
          frame,
          value: baseValue + noise,
          interpolation: "bezier",
          inHandle: { frame: -1, value: 0, enabled: true },
          outHandle: { frame: 1, value: 0, enabled: true },
          controlMode: "smooth"
        });
      }
      keyframes.push({
        layerId,
        propertyPath: `transform.position.${axis}`,
        keyframes: axisKeyframes
      });
    }
    return keyframes;
  }
  createOrbitKeyframes(layerId, startPosition, center, duration, intensity) {
    const radius = Math.sqrt(
      Math.pow(startPosition.x - center.x, 2) + Math.pow(startPosition.z - center.z, 2)
    ) || INTENSITY_TO_DISTANCE[intensity];
    const numKeyframes = 8;
    const xKeyframes = [];
    const zKeyframes = [];
    for (let i = 0; i <= numKeyframes; i++) {
      const frame = Math.round(i / numKeyframes * duration);
      const angle = i / numKeyframes * Math.PI * 2;
      xKeyframes.push({
        id: `kf_${layerId}_orbit_x_${i}`,
        frame,
        value: center.x + Math.cos(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
      zKeyframes.push({
        id: `kf_${layerId}_orbit_z_${i}`,
        frame,
        value: center.z + Math.sin(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return [
      { layerId, propertyPath: "transform.position.x", keyframes: xKeyframes },
      { layerId, propertyPath: "transform.position.z", keyframes: zKeyframes }
    ];
  }
  createCraneKeyframes(layerId, startPosition, duration, intensity) {
    const height = INTENSITY_TO_DISTANCE[intensity];
    return [
      this.createPositionKeyframes(
        layerId,
        "transform.position.y",
        startPosition.y,
        startPosition.y + height,
        0,
        duration / 2,
        "easeOut"
      ),
      this.createPositionKeyframes(
        layerId,
        "transform.position.z",
        startPosition.z,
        startPosition.z + height * 0.5,
        0,
        duration,
        "easeInOut"
      )
    ];
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  generateHandle(points, index, direction, smoothness) {
    const prevPoint = points[index - 1];
    const nextPoint = points[index + 1];
    const currentPoint = points[index];
    if (!currentPoint) return null;
    let tangentX = 0;
    let tangentY = 0;
    if (prevPoint && nextPoint) {
      tangentX = (nextPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else if (nextPoint) {
      tangentX = (nextPoint.x - currentPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - currentPoint.y) * 0.25 * smoothness;
    } else if (prevPoint) {
      tangentX = (currentPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (currentPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else {
      return null;
    }
    return {
      x: tangentX * direction,
      y: tangentY * direction
    };
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  deterministicNoise(seed, axis, frame) {
    const axisOffset = axis === "x" ? 0 : axis === "y" ? 1e3 : 2e3;
    const combined = seed + axisOffset + frame * 13;
    const x = Math.sin(combined) * 1e4;
    return x - Math.floor(x) - 0.5;
  }
}
const motionIntentTranslator = new MotionIntentTranslator();

const _hoisted_1$2 = { class: "dialog-container" };
const _hoisted_2$2 = { class: "dialog-content" };
const _hoisted_3$2 = { class: "form-section" };
const _hoisted_4$2 = { class: "form-row" };
const _hoisted_5$2 = {
  key: 0,
  class: "form-row api-key-row"
};
const _hoisted_6$2 = ["placeholder"];
const _hoisted_7$2 = {
  key: 1,
  class: "form-row"
};
const _hoisted_8$2 = { class: "form-section" };
const _hoisted_9$2 = { class: "prompt-presets" };
const _hoisted_10$2 = ["onClick"];
const _hoisted_11$2 = {
  key: 0,
  class: "form-section"
};
const _hoisted_12$2 = {
  key: 0,
  class: "spinner"
};
const _hoisted_13$2 = { class: "status-text" };
const _hoisted_14$2 = {
  key: 1,
  class: "form-section"
};
const _hoisted_15$2 = { class: "suggestions-list" };
const _hoisted_16$2 = ["onClick"];
const _hoisted_17$2 = { class: "suggestion-header" };
const _hoisted_18$2 = { class: "suggestion-type" };
const _hoisted_19$2 = { class: "suggestion-confidence" };
const _hoisted_20$2 = { class: "suggestion-description" };
const _hoisted_21$2 = { class: "suggestion-details" };
const _hoisted_22$2 = { key: 0 };
const _hoisted_23$2 = { key: 1 };
const _hoisted_24$1 = { class: "form-section preview-section" };
const _hoisted_25$1 = { class: "dialog-footer" };
const _hoisted_26$1 = { class: "footer-left" };
const _hoisted_27$1 = ["disabled"];
const _hoisted_28$1 = {
  key: 0,
  class: "spinner-small"
};
const _hoisted_29$1 = { class: "dialog-actions" };
const _hoisted_30$1 = ["disabled"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "PathSuggestionDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "accept", "preview"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectedModel = ref("rule-based");
    const apiKey = ref("");
    const localEndpoint = ref("http://localhost:8188/api/vlm");
    const prompt = ref("");
    const selectedPreset = ref(null);
    const status = ref("idle");
    const statusMessage = ref("");
    const suggestions = ref([]);
    const selectedSuggestion = ref(null);
    const showPreview = ref(true);
    const promptPresets = [
      { id: "dolly", label: "Dolly", prompt: "Gentle dolly in towards the subject" },
      { id: "orbit", label: "Orbit", prompt: "Slow orbit around the center point" },
      { id: "drift", label: "Drift", prompt: "Subtle floating drift movement" },
      { id: "handheld", label: "Handheld", prompt: "Organic handheld camera shake" },
      { id: "pan", label: "Pan", prompt: "Smooth horizontal pan across the scene" },
      { id: "crane", label: "Crane", prompt: "Vertical crane movement" }
    ];
    const requiresApiKey = computed(() => {
      return ["gpt-4v", "gpt-4o", "claude-vision"].includes(selectedModel.value);
    });
    const isLocalModel = computed(() => {
      return ["qwen-vl", "qwen2-vl", "llava", "local-vlm"].includes(selectedModel.value);
    });
    const apiKeyPlaceholder = computed(() => {
      if (selectedModel.value.startsWith("gpt-")) return "sk-...";
      if (selectedModel.value === "claude-vision") return "sk-ant-...";
      return "API Key";
    });
    function selectPreset(preset) {
      selectedPreset.value = preset.id;
      prompt.value = preset.prompt;
    }
    async function testConnection() {
      status.value = "loading";
      statusMessage.value = "Testing connection...";
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiKey: apiKey.value || void 0,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const testContext = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: [],
          currentFrame: store.currentFrame
        };
        await motionIntentResolver.resolve("test", testContext, selectedModel.value);
        status.value = "success";
        statusMessage.value = "Connection successful!";
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Connection failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    async function loadDepthMapAsFloat32Array(depthMapUrl) {
      if (!depthMapUrl) return void 0;
      try {
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = reject;
          img.src = depthMapUrl;
        });
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) return void 0;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const depthArray = new Float32Array(img.width * img.height);
        for (let i = 0; i < depthArray.length; i++) {
          const r = imageData.data[i * 4];
          const g = imageData.data[i * 4 + 1];
          const b = imageData.data[i * 4 + 2];
          depthArray[i] = (r + g + b) / (3 * 255);
        }
        return depthArray;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to load depth map:", error);
        return void 0;
      }
    }
    async function captureCurrentFrameImage() {
      try {
        const canvas = document.querySelector(".viewport-content canvas");
        if (!canvas) return void 0;
        const ctx = canvas.getContext("2d") || canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!ctx) return void 0;
        if (ctx instanceof WebGLRenderingContext || ctx instanceof WebGL2RenderingContext) {
          const width = canvas.width;
          const height = canvas.height;
          const pixels = new Uint8Array(width * height * 4);
          ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
          const imageData = new ImageData(width, height);
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const srcIdx = ((height - 1 - y) * width + x) * 4;
              const dstIdx = (y * width + x) * 4;
              imageData.data[dstIdx] = pixels[srcIdx];
              imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
              imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
              imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
          }
          return imageData;
        }
        if (ctx instanceof CanvasRenderingContext2D) {
          return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        return void 0;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to capture frame:", error);
        return void 0;
      }
    }
    async function suggestPaths() {
      if (!prompt.value.trim()) {
        status.value = "error";
        statusMessage.value = "Please enter a motion description";
        return;
      }
      status.value = "loading";
      statusMessage.value = "Analyzing scene and generating suggestions...";
      suggestions.value = [];
      selectedSuggestion.value = null;
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiKey: apiKey.value || void 0,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const depthMap = await loadDepthMapAsFloat32Array(store.depthMap);
        const frameImage = await captureCurrentFrameImage();
        const context = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: store.selectedLayerIds,
          currentFrame: store.currentFrame,
          depthMap,
          frameImage
        };
        const result = await motionIntentResolver.resolve(prompt.value, context, selectedModel.value);
        const items = [];
        if (result.cameraIntents) {
          for (const intent of result.cameraIntents) {
            items.push({
              type: "camera",
              description: `${intent.type} motion - ${intent.intensity}`,
              confidence: 0.8,
              duration: intent.durationFrames,
              intent
            });
          }
        }
        if (result.splineIntents) {
          for (const intent of result.splineIntents) {
            items.push({
              type: "spline",
              description: `${intent.usage} - ${intent.suggestedPoints.length} point path`,
              confidence: 0.9,
              points: intent.suggestedPoints.map((p) => ({ x: p.x, y: p.y, depth: p.depth })),
              intent
            });
          }
        }
        suggestions.value = items;
        status.value = "success";
        statusMessage.value = `Found ${items.length} suggestion${items.length !== 1 ? "s" : ""}`;
        if (items.length > 0) {
          selectedSuggestion.value = 0;
        }
        if (showPreview.value) {
          emit("preview", suggestions.value);
        }
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    function acceptSuggestion() {
      if (selectedSuggestion.value === null) return;
      const suggestion = suggestions.value[selectedSuggestion.value];
      const result = {
        keyframes: [],
        splines: []
      };
      if (suggestion.type === "camera") {
        const translation = motionIntentTranslator.translateCameraIntent(
          suggestion.intent,
          store.width,
          store.height,
          store.frameCount
        );
        result.keyframes = translation.keyframeBatches;
      } else if (suggestion.type === "spline") {
        const translation = motionIntentTranslator.translateSplineIntent(
          suggestion.intent,
          store.width,
          store.height
        );
        result.splines = translation.newSplines || [];
      }
      emit("accept", result);
      emit("close");
    }
    function cancel() {
      emit("close");
    }
    watch(showPreview, (show) => {
      if (show && suggestions.value.length > 0) {
        emit("preview", suggestions.value);
      } else {
        emit("preview", []);
      }
    });
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && e.ctrlKey) {
        suggestPaths();
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$2, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "dialog-title" }, "AI Path Suggestion", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "Ã—")
            ]),
            createBaseVNode("div", _hoisted_2$2, [
              createBaseVNode("div", _hoisted_3$2, [
                _cache[9] || (_cache[9] = createBaseVNode("label", { class: "section-label" }, "Vision Model", -1)),
                createBaseVNode("div", _hoisted_4$2, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
                    class: "select-input"
                  }, [..._cache[6] || (_cache[6] = [
                    createBaseVNode("option", { value: "rule-based" }, "Rule-Based (Offline)", -1),
                    createBaseVNode("optgroup", { label: "Cloud Models" }, [
                      createBaseVNode("option", { value: "gpt-4o" }, "OpenAI GPT-4o"),
                      createBaseVNode("option", { value: "gpt-4v" }, "OpenAI GPT-4V"),
                      createBaseVNode("option", { value: "claude-vision" }, "Claude Vision")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Local Models" }, [
                      createBaseVNode("option", { value: "qwen2-vl" }, "Qwen2-VL"),
                      createBaseVNode("option", { value: "qwen-vl" }, "Qwen-VL"),
                      createBaseVNode("option", { value: "llava" }, "LLaVA"),
                      createBaseVNode("option", { value: "local-vlm" }, "Custom Local VLM")
                    ], -1)
                  ])], 512), [
                    [vModelSelect, selectedModel.value]
                  ])
                ]),
                requiresApiKey.value ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
                  _cache[7] || (_cache[7] = createBaseVNode("label", null, "API Key:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "password",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => apiKey.value = $event),
                    class: "text-input",
                    placeholder: apiKeyPlaceholder.value
                  }, null, 8, _hoisted_6$2), [
                    [vModelText, apiKey.value]
                  ]),
                  createBaseVNode("button", {
                    class: "btn btn-small",
                    onClick: testConnection
                  }, "Test")
                ])) : createCommentVNode("", true),
                isLocalModel.value ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                  _cache[8] || (_cache[8] = createBaseVNode("label", null, "Endpoint:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => localEndpoint.value = $event),
                    class: "text-input",
                    placeholder: "http://localhost:8188/api/vlm"
                  }, null, 512), [
                    [vModelText, localEndpoint.value]
                  ])
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_8$2, [
                _cache[10] || (_cache[10] = createBaseVNode("label", { class: "section-label" }, "Motion Description", -1)),
                createBaseVNode("div", _hoisted_9$2, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(promptPresets, (preset) => {
                    return createBaseVNode("button", {
                      key: preset.id,
                      class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                      onClick: ($event) => selectPreset(preset)
                    }, toDisplayString(preset.label), 11, _hoisted_10$2);
                  }), 64))
                ]),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => prompt.value = $event),
                  class: "prompt-input",
                  rows: "3",
                  placeholder: "Describe the motion you want, e.g., 'dolly in slowly' or 'orbit around the subject'"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              status.value !== "idle" ? (openBlock(), createElementBlock("div", _hoisted_11$2, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-bar", status.value])
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_12$2)) : createCommentVNode("", true),
                  createBaseVNode("span", _hoisted_13$2, toDisplayString(statusMessage.value), 1)
                ], 2)
              ])) : createCommentVNode("", true),
              suggestions.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
                _cache[11] || (_cache[11] = createBaseVNode("label", { class: "section-label" }, "Suggested Paths", -1)),
                createBaseVNode("div", _hoisted_15$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(suggestions.value, (suggestion, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["suggestion-item", { selected: selectedSuggestion.value === index }]),
                      onClick: ($event) => selectedSuggestion.value = index
                    }, [
                      createBaseVNode("div", _hoisted_17$2, [
                        createBaseVNode("span", _hoisted_18$2, toDisplayString(suggestion.type), 1),
                        createBaseVNode("span", _hoisted_19$2, toDisplayString(Math.round(suggestion.confidence * 100)) + "% ", 1)
                      ]),
                      createBaseVNode("div", _hoisted_20$2, toDisplayString(suggestion.description), 1),
                      createBaseVNode("div", _hoisted_21$2, [
                        suggestion.points ? (openBlock(), createElementBlock("span", _hoisted_22$2, toDisplayString(suggestion.points.length) + " points", 1)) : createCommentVNode("", true),
                        suggestion.duration ? (openBlock(), createElementBlock("span", _hoisted_23$2, toDisplayString(suggestion.duration) + " frames", 1)) : createCommentVNode("", true)
                      ])
                    ], 10, _hoisted_16$2);
                  }), 128))
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_24$1, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showPreview.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, showPreview.value]
                  ]),
                  _cache[12] || (_cache[12] = createTextVNode(" Show preview on canvas ", -1))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_25$1, [
              createBaseVNode("div", _hoisted_26$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: suggestPaths,
                  disabled: status.value === "loading"
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_28$1)) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(status.value === "loading" ? "Analyzing..." : "Suggest Paths"), 1)
                ], 8, _hoisted_27$1)
              ]),
              createBaseVNode("div", _hoisted_29$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: acceptSuggestion,
                  disabled: selectedSuggestion.value === null
                }, " Accept ", 8, _hoisted_30$1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const PathSuggestionDialog = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-f14ac83f"]]);

const _hoisted_1$1 = ["viewBox"];
const _hoisted_2$1 = ["width", "height"];
const _hoisted_3$1 = ["d"];
const _hoisted_4$1 = {
  key: 0,
  width: "100%",
  height: "100%",
  fill: "url(#preview-grid)"
};
const _hoisted_5$1 = ["onClick"];
const _hoisted_6$1 = ["d", "stroke"];
const _hoisted_7$1 = ["d", "stroke", "stroke-dasharray"];
const _hoisted_8$1 = { key: 2 };
const _hoisted_9$1 = ["cx", "cy", "stroke"];
const _hoisted_10$1 = ["cx", "cy", "fill"];
const _hoisted_11$1 = ["x", "y", "fill"];
const _hoisted_12$1 = ["x", "y"];
const _hoisted_13$1 = ["x", "y", "fill"];
const _hoisted_14$1 = ["cx", "cy", "stroke"];
const _hoisted_15$1 = ["x1", "y1", "x2", "y2", "stroke"];
const _hoisted_16$1 = ["x", "y", "fill"];
const _hoisted_17$1 = { key: 1 };
const _hoisted_18$1 = ["cx", "cy"];
const _hoisted_19$1 = ["cx", "cy"];
const _hoisted_20$1 = {
  key: 0,
  class: "legend"
};
const _hoisted_21$1 = ["onClick"];
const _hoisted_22$1 = { class: "legend-text" };
const _hoisted_23$1 = {
  key: 1,
  class: "instructions"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "PathPreviewOverlay",
  props: {
    width: {},
    height: {},
    suggestions: {},
    selectedIndex: {},
    showGrid: { type: Boolean, default: true },
    showPoints: { type: Boolean, default: true },
    showLabels: { type: Boolean, default: true },
    showDepth: { type: Boolean, default: true },
    showLegend: { type: Boolean, default: true },
    showAnimation: { type: Boolean, default: true },
    gridSize: { default: 50 }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const overlayRef = ref(null);
    const animatedPosition = ref(null);
    let animationFrame = 0;
    let animationId = null;
    const pathColors = [
      "#4a90d9",
      // Blue
      "#d94a4a",
      // Red
      "#4ad94a",
      // Green
      "#d9d94a",
      // Yellow
      "#d94ad9",
      // Magenta
      "#4ad9d9"
      // Cyan
    ];
    const overlayStyle = computed(() => ({
      width: `${props.width}px`,
      height: `${props.height}px`
    }));
    const cameraSuggestions = computed(() => {
      return props.suggestions.filter((s) => s.type === "camera" && s.points && s.points.length >= 2).map((s) => ({
        type: s.description?.split(" ")[0] || "Camera",
        startX: s.points[0].x,
        startY: s.points[0].y,
        endX: s.points[s.points.length - 1].x,
        endY: s.points[s.points.length - 1].y
      }));
    });
    function getPathColor(index, opacity) {
      const baseColor = pathColors[index % pathColors.length];
      if (opacity === 1) return baseColor;
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    function pointsToPathData(points) {
      if (points.length < 2) return "";
      let d = `M ${points[0].x} ${points[0].y}`;
      if (points.length === 2) {
        d += ` L ${points[1].x} ${points[1].y}`;
      } else {
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[Math.max(0, i - 1)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(points.length - 1, i + 2)];
          const tension = 0.3;
          const cp1x = p1.x + (p2.x - p0.x) * tension;
          const cp1y = p1.y + (p2.y - p0.y) * tension;
          const cp2x = p2.x - (p3.x - p1.x) * tension;
          const cp2y = p2.y - (p3.y - p1.y) * tension;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
        }
      }
      return d;
    }
    function startAnimation() {
      if (props.selectedIndex === null) {
        animatedPosition.value = null;
        return;
      }
      const suggestion = props.suggestions[props.selectedIndex];
      if (!suggestion.points || suggestion.points.length < 2) {
        animatedPosition.value = null;
        return;
      }
      const points = suggestion.points;
      const totalLength = points.length - 1;
      function animate() {
        animationFrame = (animationFrame + 0.5) % (totalLength * 60);
        const t = animationFrame / (totalLength * 60);
        const segmentIndex = Math.min(Math.floor(t * totalLength), totalLength - 1);
        const segmentT = t * totalLength - segmentIndex;
        const p1 = points[segmentIndex];
        const p2 = points[segmentIndex + 1];
        animatedPosition.value = {
          x: p1.x + (p2.x - p1.x) * segmentT,
          y: p1.y + (p2.y - p1.y) * segmentT
        };
        animationId = requestAnimationFrame(animate);
      }
      animate();
    }
    function stopAnimation() {
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      animatedPosition.value = null;
    }
    watch(() => props.suggestions, (newSuggestions) => {
      for (const suggestion of newSuggestions) {
        if (suggestion.points && !suggestion.pathData) {
          suggestion.pathData = pointsToPathData(suggestion.points);
        }
      }
    }, { immediate: true, deep: true });
    watch(() => props.selectedIndex, () => {
      stopAnimation();
      if (props.showAnimation) {
        startAnimation();
      }
    });
    onMounted(() => {
      if (props.showAnimation && props.selectedIndex !== null) {
        startAnimation();
      }
    });
    onUnmounted(() => {
      stopAnimation();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "overlayRef",
        ref: overlayRef,
        class: "path-preview-overlay",
        style: normalizeStyle(overlayStyle.value)
      }, [
        (openBlock(), createElementBlock("svg", {
          class: "preview-svg",
          viewBox: `0 0 ${__props.width} ${__props.height}`,
          preserveAspectRatio: "xMidYMid meet"
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("pattern", {
              id: "preview-grid",
              width: __props.gridSize,
              height: __props.gridSize,
              patternUnits: "userSpaceOnUse"
            }, [
              createBaseVNode("path", {
                d: `M ${__props.gridSize} 0 L 0 0 0 ${__props.gridSize}`,
                fill: "none",
                stroke: "rgba(255,255,255,0.05)",
                "stroke-width": "1"
              }, null, 8, _hoisted_3$1)
            ], 8, _hoisted_2$1),
            _cache[0] || (_cache[0] = createStaticVNode('<filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%" data-v-021b36ff><feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" data-v-021b36ff></feGaussianBlur><feMerge data-v-021b36ff><feMergeNode in="blur" data-v-021b36ff></feMergeNode><feMergeNode in="SourceGraphic" data-v-021b36ff></feMergeNode></feMerge></filter><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse" data-v-021b36ff><path d="M 0 0 L 10 5 L 0 10 z" fill="#4a90d9" data-v-021b36ff></path></marker>', 2))
          ]),
          __props.showGrid ? (openBlock(), createElementBlock("rect", _hoisted_4$1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: index,
              class: normalizeClass(["path-group", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 0,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 0.3),
                "stroke-width": "8",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                filter: "url(#path-glow)"
              }, null, 8, _hoisted_6$1)) : createCommentVNode("", true),
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 1,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 1),
                "stroke-width": "2",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-dasharray": __props.selectedIndex === index ? "none" : "8,4",
                "marker-end": "url(#arrow)"
              }, null, 8, _hoisted_7$1)) : createCommentVNode("", true),
              suggestion.points && __props.showPoints ? (openBlock(), createElementBlock("g", _hoisted_8$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(suggestion.points, (point, pIndex) => {
                  return openBlock(), createElementBlock("g", {
                    key: pIndex,
                    class: "control-point"
                  }, [
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "8",
                      fill: "none",
                      stroke: getPathColor(index, 0.5),
                      "stroke-width": "2"
                    }, null, 8, _hoisted_9$1),
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "4",
                      fill: getPathColor(index, 1)
                    }, null, 8, _hoisted_10$1),
                    __props.showLabels ? (openBlock(), createElementBlock("text", {
                      key: 0,
                      x: point.x + 12,
                      y: point.y + 4,
                      class: "point-label",
                      fill: getPathColor(index, 0.8)
                    }, toDisplayString(pIndex + 1), 9, _hoisted_11$1)) : createCommentVNode("", true),
                    point.depth !== void 0 && __props.showDepth ? (openBlock(), createElementBlock("text", {
                      key: 1,
                      x: point.x + 12,
                      y: point.y + 16,
                      class: "depth-label"
                    }, " z: " + toDisplayString(point.depth.toFixed(2)), 9, _hoisted_12$1)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 10, _hoisted_5$1);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(cameraSuggestions.value, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: `cam-${index}`
            }, [
              createBaseVNode("g", {
                class: normalizeClass(["camera-indicator", { selected: __props.selectedIndex === index }])
              }, [
                createBaseVNode("rect", {
                  x: suggestion.startX - 12,
                  y: suggestion.startY - 8,
                  width: "24",
                  height: "16",
                  rx: "2",
                  fill: getPathColor(index, 0.8)
                }, null, 8, _hoisted_13$1),
                createBaseVNode("circle", {
                  cx: suggestion.startX + 8,
                  cy: suggestion.startY,
                  r: "4",
                  fill: "none",
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2"
                }, null, 8, _hoisted_14$1),
                createBaseVNode("line", {
                  x1: suggestion.startX,
                  y1: suggestion.startY,
                  x2: suggestion.endX,
                  y2: suggestion.endY,
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2",
                  "stroke-dasharray": "4,2",
                  "marker-end": "url(#arrow)"
                }, null, 8, _hoisted_15$1),
                createBaseVNode("text", {
                  x: (suggestion.startX + suggestion.endX) / 2,
                  y: (suggestion.startY + suggestion.endY) / 2 - 10,
                  class: "motion-label",
                  fill: getPathColor(index, 1)
                }, toDisplayString(suggestion.type), 9, _hoisted_16$1)
              ], 2)
            ]);
          }), 128)),
          animatedPosition.value && __props.showAnimation ? (openBlock(), createElementBlock("g", _hoisted_17$1, [
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "6",
              fill: "#fff",
              class: "animated-dot"
            }, null, 8, _hoisted_18$1),
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "12",
              fill: "none",
              stroke: "#fff",
              "stroke-width": "2",
              opacity: "0.5",
              class: "animated-ring"
            }, null, 8, _hoisted_19$1)
          ])) : createCommentVNode("", true)
        ], 8, _hoisted_1$1)),
        __props.suggestions.length > 0 && __props.showLegend ? (openBlock(), createElementBlock("div", _hoisted_20$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["legend-item", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              createBaseVNode("span", {
                class: "legend-color",
                style: normalizeStyle({ backgroundColor: getPathColor(index, 1) })
              }, null, 4),
              createBaseVNode("span", _hoisted_22$1, toDisplayString(suggestion.description || `Path ${index + 1}`), 1)
            ], 10, _hoisted_21$1);
          }), 128))
        ])) : createCommentVNode("", true),
        __props.suggestions.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_23$1, " Click a path to select it. Press Enter to accept. ")) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const PathPreviewOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-021b36ff"]]);

const _hoisted_1 = { class: "workspace-layout" };
const _hoisted_2 = { class: "toolbar" };
const _hoisted_3 = { class: "tool-group" };
const _hoisted_4 = { class: "tool-group segment-options" };
const _hoisted_5 = {
  key: 1,
  class: "loading-indicator"
};
const _hoisted_6 = { class: "tool-group" };
const _hoisted_7 = ["title"];
const _hoisted_8 = { class: "icon" };
const _hoisted_9 = { class: "timecode-display" };
const _hoisted_10 = { class: "tool-group" };
const _hoisted_11 = { class: "tool-group" };
const _hoisted_12 = ["disabled"];
const _hoisted_13 = ["disabled"];
const _hoisted_14 = { class: "workspace-content" };
const _hoisted_15 = { class: "panel left-panel" };
const _hoisted_16 = { class: "panel-tabs" };
const _hoisted_17 = { class: "panel-content" };
const _hoisted_18 = { class: "panel viewport-panel" };
const _hoisted_19 = { class: "viewport-header" };
const _hoisted_20 = { class: "viewport-tabs" };
const _hoisted_21 = { class: "viewport-controls" };
const _hoisted_22 = { class: "viewport-content" };
const _hoisted_23 = {
  key: 0,
  class: "rulers-overlay"
};
const _hoisted_24 = { class: "ruler ruler-horizontal" };
const _hoisted_25 = { class: "ruler ruler-vertical" };
const _hoisted_26 = { class: "panel timeline-panel" };
const _hoisted_27 = { class: "panel graph-editor-panel" };
const _hoisted_28 = {
  key: 1,
  class: "panel timeline-panel"
};
const _hoisted_29 = { class: "panel right-panel" };
const _hoisted_30 = { class: "panel-tabs" };
const _hoisted_31 = { class: "panel-content" };
const _hoisted_32 = { class: "status-bar" };
const _hoisted_33 = { class: "status-left" };
const _hoisted_34 = { class: "status-item" };
const _hoisted_35 = { class: "status-item" };
const _hoisted_36 = { class: "status-center" };
const _hoisted_37 = {
  key: 0,
  class: "render-progress"
};
const _hoisted_38 = { class: "status-right" };
const _hoisted_39 = { class: "status-item" };
const _hoisted_40 = { class: "status-item" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "WorkspaceLayout",
  setup(__props) {
    const store = useCompositorStore();
    const assetStore = useAssetStore();
    const currentTool = computed({
      get: () => store.currentTool,
      set: (tool) => store.setTool(tool)
    });
    const segmentMode = computed(() => store.segmentMode);
    const segmentPendingMask = computed(() => store.segmentPendingMask);
    const segmentIsLoading = computed(() => store.segmentIsLoading);
    function setSegmentMode(mode) {
      store.setSegmentMode(mode);
    }
    async function confirmSegmentMask() {
      await store.confirmSegmentMask();
    }
    function clearSegmentMask() {
      store.clearSegmentPendingMask();
    }
    const activeWorkspace = ref("standard");
    const leftTab = ref("project");
    const rightTab = ref("properties");
    const viewportTab = ref("composition");
    const viewZoom = ref("fit");
    const showGraphEditor = ref(false);
    const showExportDialog = ref(false);
    const showComfyUIExportDialog = ref(false);
    const showCompositionSettingsDialog = ref(false);
    const showPathSuggestionDialog = ref(false);
    const pathSuggestions = ref([]);
    const selectedPathIndex = ref(null);
    const isPlaying = ref(false);
    const gpuTier = ref("cpu");
    const threeCanvasRef = ref(null);
    const activeCamera = computed(() => {
      const cam = store.getActiveCameraAtFrame();
      if (cam) return cam;
      return createDefaultCamera("default", compWidth.value, compHeight.value);
    });
    const viewportState = ref(createDefaultViewportState());
    const viewOptions = ref({
      showGrid: true,
      showRulers: false,
      showAxes: true,
      showCameraFrustum: true,
      showCompositionBounds: true,
      showFocalPlane: false,
      showLayerOutlines: true,
      showSafeZones: false,
      gridSize: 100,
      gridDivisions: 10
    });
    const compWidth = computed(() => store.project?.composition?.width || 1920);
    const compHeight = computed(() => store.project?.composition?.height || 1080);
    const fps = ref(60);
    const memoryUsage = ref("0 MB");
    const renderProgress = ref(0);
    const formattedTimecode = computed(() => {
      const frame = store.currentFrame;
      const fpsVal = store.project?.composition?.fps || 30;
      const totalSeconds = frame / fpsVal;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const frames = frame % fpsVal;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    const projectName = computed(() => {
      return store.project?.meta?.name || "Untitled Project";
    });
    const compositionInfo = computed(() => {
      const comp = store.project?.composition;
      if (!comp) return "No Composition";
      return `${comp.width}Ã—${comp.height} @ ${comp.fps}fps`;
    });
    const canUndo = computed(() => store.canUndo);
    const canRedo = computed(() => store.canRedo);
    function togglePlay() {
      isPlaying.value = !isPlaying.value;
      if (isPlaying.value) {
        store.play();
      } else {
        store.pause();
      }
    }
    function goToStart() {
      store.goToStart();
    }
    function goToEnd() {
      store.goToEnd();
    }
    function stepForward() {
      store.setFrame(store.currentFrame + 1);
    }
    function stepBackward() {
      store.setFrame(Math.max(0, store.currentFrame - 1));
    }
    function undo() {
      store.undo();
    }
    function redo() {
      store.redo();
    }
    function updateCamera(camera) {
      if (store.activeCameraId) {
        store.updateCamera(camera.id, camera);
      }
    }
    function onExportComplete() {
      console.log("[Weyl] Matte export completed");
    }
    function onComfyUIExportComplete(result) {
      console.log("[Weyl] ComfyUI export completed", result);
      showComfyUIExportDialog.value = false;
    }
    function onCompositionSettingsConfirm(settings) {
      console.log("[Weyl] Composition settings updated:", settings);
      store.updateCompositionSettings(store.activeCompositionId, {
        width: settings.width,
        height: settings.height,
        fps: settings.fps,
        frameCount: settings.frameCount,
        backgroundColor: settings.backgroundColor,
        autoResizeToContent: settings.autoResizeToContent
      });
      store.renameComposition(store.activeCompositionId, settings.name);
      showCompositionSettingsDialog.value = false;
    }
    function generatePathDataFromPoints(points, closed) {
      if (points.length === 0) return "";
      if (points.length === 1) return `M ${points[0].x} ${points[0].y}`;
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        if (p0.handleOut && p1.handleIn) {
          const cp1x = p0.x + p0.handleOut.x;
          const cp1y = p0.y + p0.handleOut.y;
          const cp2x = p1.x + p1.handleIn.x;
          const cp2y = p1.y + p1.handleIn.y;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
        } else if (p0.handleOut) {
          const cpx = p0.x + p0.handleOut.x;
          const cpy = p0.y + p0.handleOut.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else if (p1.handleIn) {
          const cpx = p1.x + p1.handleIn.x;
          const cpy = p1.y + p1.handleIn.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else {
          d += ` L ${p1.x} ${p1.y}`;
        }
      }
      if (closed && points.length > 2) {
        d += " Z";
      }
      return d;
    }
    function onPathSuggestionClose() {
      showPathSuggestionDialog.value = false;
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
    }
    function onPathSuggestionPreview(suggestions) {
      pathSuggestions.value = suggestions;
      selectedPathIndex.value = suggestions.length > 0 ? 0 : null;
    }
    function onPathSuggestionAccept(result) {
      console.log("[Weyl] Path suggestion accepted:", result);
      if (result.keyframes && result.keyframes.length > 0) {
        for (const batch of result.keyframes) {
          for (const keyframe of batch.keyframes) {
            store.addKeyframe(batch.layerId, batch.propertyPath, keyframe.frame, keyframe.value, keyframe.easing);
          }
        }
      }
      if (result.splines && result.splines.length > 0) {
        for (const spline of result.splines) {
          const layer = store.createSplineLayer();
          if (spline.name) {
            store.renameLayer(layer.id, spline.name);
          }
          const controlPoints = (spline.points || []).map((p, i) => ({
            id: p.id || `cp_${Date.now()}_${i}`,
            x: p.x,
            y: p.y,
            depth: p.depth ?? 0,
            // Preserve z-space depth
            handleIn: p.handleIn || null,
            // Preserve bezier handles from translator
            handleOut: p.handleOut || null,
            type: p.type || "smooth"
          }));
          const pathData = generatePathDataFromPoints(controlPoints, spline.closed || false);
          store.updateLayerData(layer.id, {
            controlPoints,
            pathData,
            closed: spline.closed || false
          });
        }
      }
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
      showPathSuggestionDialog.value = false;
    }
    const activeCameraKeyframes = computed(() => {
      const activeCam = store.getActiveCameraAtFrame();
      if (!activeCam) return [];
      return store.getCameraKeyframes(activeCam.id);
    });
    function handleZoomChange() {
      if (!threeCanvasRef.value) return;
      if (viewZoom.value === "fit") {
        threeCanvasRef.value.fitToView();
      } else {
        const zoomLevel = parseInt(viewZoom.value) / 100;
        threeCanvasRef.value.setZoom(zoomLevel);
      }
    }
    function onCreateLayersFromSvg(svgId) {
      const storedSvg = assetStore.svgDocuments.get(svgId);
      if (!storedSvg) return;
      storedSvg.document.paths.forEach((path, index) => {
        const config = storedSvg.layerConfigs[index];
        const layer = store.createShapeLayer();
        store.renameLayer(layer.id, `${storedSvg.name}_${path.id}`);
        store.updateLayerData(layer.id, {
          svgDocumentId: svgId,
          svgPathId: path.id,
          svgPathIndex: index,
          extrusionConfig: config,
          // Set Z position based on layer depth
          transform: {
            ...layer.transform,
            position: {
              ...layer.transform.position,
              value: {
                ...layer.transform.position.value,
                z: config?.depth || 0
              }
            }
          }
        });
      });
      console.log(`[Weyl] Created ${storedSvg.document.paths.length} layers from SVG: ${storedSvg.name}`);
    }
    function onUseMeshAsEmitter(meshId) {
      const emitterConfig = assetStore.getMeshEmitterConfig(meshId);
      if (!emitterConfig) return;
      const selectedLayerIds = store.selectedLayerIds;
      if (selectedLayerIds.length === 0) {
        console.warn("[Weyl] No layer selected for mesh emitter");
        return;
      }
      const layer = store.layers.find((l) => l.id === selectedLayerIds[0]);
      if (!layer || layer.type !== "particle") {
        console.warn("[Weyl] Selected layer is not a particle layer");
        return;
      }
      store.updateLayerData(layer.id, {
        emitter: {
          ...layer.data.emitter,
          shape: "mesh",
          meshVertices: emitterConfig.meshVertices,
          meshNormals: emitterConfig.meshNormals
        }
      });
      console.log(`[Weyl] Set mesh emitter for layer: ${layer.name}`);
    }
    function onEnvironmentUpdate(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentConfig(settings);
    }
    async function onEnvironmentLoad(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      if (settings.url) {
        try {
          await engine.loadEnvironmentMap(settings.url, {
            intensity: settings.intensity,
            rotation: settings.rotation,
            backgroundBlur: settings.backgroundBlur,
            useAsBackground: settings.useAsBackground
          });
          console.log("[Weyl] Environment map loaded");
        } catch (error) {
          console.error("[Weyl] Failed to load environment map:", error);
        }
      }
    }
    function onEnvironmentClear() {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentEnabled(false);
    }
    function handleKeydown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA") {
        return;
      }
      switch (e.key.toLowerCase()) {
        case " ":
          e.preventDefault();
          togglePlay();
          break;
        case "v":
          currentTool.value = "select";
          break;
        case "p":
          currentTool.value = "pen";
          break;
        case "t":
          currentTool.value = "text";
          break;
        case "h":
          currentTool.value = "hand";
          break;
        case "z":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
          } else {
            currentTool.value = "zoom";
          }
          break;
        case "home":
          e.preventDefault();
          goToStart();
          break;
        case "end":
          e.preventDefault();
          goToEnd();
          break;
        case "arrowleft":
          e.preventDefault();
          stepBackward();
          break;
        case "arrowright":
          e.preventDefault();
          stepForward();
          break;
        case "g":
          if (e.shiftKey) {
            showGraphEditor.value = !showGraphEditor.value;
          }
          break;
        case "k":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            showCompositionSettingsDialog.value = true;
          }
          break;
        case "i":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            triggerAssetImport();
          }
          break;
        case "a":
          if (!e.ctrlKey && !e.metaKey) {
            leftTab.value = "assets";
          }
          break;
      }
    }
    ref(null);
    function triggerAssetImport() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".svg,.gltf,.glb,.obj,.fbx,.hdr,.exr,.png,.jpg";
      input.multiple = true;
      input.onchange = async (e) => {
        const files = e.target.files;
        if (!files) return;
        for (const file of files) {
          const ext = file.name.split(".").pop()?.toLowerCase();
          if (ext === "svg") {
            await assetStore.importSvgFromFile(file);
          } else if (["hdr", "exr"].includes(ext || "")) {
            await assetStore.loadEnvironment(file);
          }
        }
        leftTab.value = "assets";
      };
      input.click();
    }
    let perfInterval;
    function updatePerformanceStats() {
      if ("memory" in performance) {
        const mem = performance.memory;
        const usedMB = Math.round(mem.usedJSHeapSize / 1024 / 1024);
        memoryUsage.value = `${usedMB} MB`;
      }
    }
    onMounted(async () => {
      const tierInfo = await detectGPUTier();
      gpuTier.value = tierInfo.tier;
      window.addEventListener("keydown", handleKeydown);
      perfInterval = window.setInterval(updatePerformanceStats, 1e3);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
      clearInterval(perfInterval);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "select" }),
              onClick: _cache[0] || (_cache[0] = ($event) => currentTool.value = "select"),
              title: "Select (V)"
            }, [..._cache[34] || (_cache[34] = [
              createBaseVNode("span", { class: "icon" }, "â†–", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "pen" }),
              onClick: _cache[1] || (_cache[1] = ($event) => currentTool.value = "pen"),
              title: "Pen Tool (P)"
            }, [..._cache[35] || (_cache[35] = [
              createBaseVNode("span", { class: "icon" }, "âœ’", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "text" }),
              onClick: _cache[2] || (_cache[2] = ($event) => currentTool.value = "text"),
              title: "Text Tool (T)"
            }, [..._cache[36] || (_cache[36] = [
              createBaseVNode("span", { class: "icon" }, "T", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "hand" }),
              onClick: _cache[3] || (_cache[3] = ($event) => currentTool.value = "hand"),
              title: "Hand Tool (H)"
            }, [..._cache[37] || (_cache[37] = [
              createBaseVNode("span", { class: "icon" }, "âœ‹", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "zoom" }),
              onClick: _cache[4] || (_cache[4] = ($event) => currentTool.value = "zoom"),
              title: "Zoom Tool (Z)"
            }, [..._cache[38] || (_cache[38] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ”", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "segment" }),
              onClick: _cache[5] || (_cache[5] = ($event) => currentTool.value = "segment"),
              title: "Segment Tool (S) - Click to select objects"
            }, [..._cache[39] || (_cache[39] = [
              createBaseVNode("span", { class: "icon" }, "âœ‚", -1)
            ])], 2)
          ]),
          _cache[58] || (_cache[58] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", { class: "tool-group" }, [
            createBaseVNode("button", {
              onClick: triggerAssetImport,
              title: "Import Asset (Ctrl+I)",
              class: "import-btn"
            }, [..._cache[40] || (_cache[40] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ“¥", -1),
              createBaseVNode("span", { class: "btn-label" }, "Import", -1)
            ])])
          ]),
          currentTool.value === "segment" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _cache[46] || (_cache[46] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("div", _hoisted_4, [
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "point" }),
                onClick: _cache[6] || (_cache[6] = ($event) => setSegmentMode("point")),
                title: "Point Mode - Click to segment"
              }, [..._cache[41] || (_cache[41] = [
                createBaseVNode("span", { class: "icon" }, "â—", -1),
                createTextVNode(" Point ", -1)
              ])], 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "box" }),
                onClick: _cache[7] || (_cache[7] = ($event) => setSegmentMode("box")),
                title: "Box Mode - Draw rectangle to segment"
              }, [..._cache[42] || (_cache[42] = [
                createBaseVNode("span", { class: "icon" }, "â–¢", -1),
                createTextVNode(" Box ", -1)
              ])], 2),
              segmentPendingMask.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _cache[45] || (_cache[45] = createBaseVNode("div", { class: "divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: confirmSegmentMask,
                  class: "confirm-btn",
                  title: "Create Layer from Selection"
                }, [..._cache[43] || (_cache[43] = [
                  createBaseVNode("span", { class: "icon" }, "âœ“", -1),
                  createTextVNode(" Create Layer ", -1)
                ])]),
                createBaseVNode("button", {
                  onClick: clearSegmentMask,
                  class: "cancel-btn",
                  title: "Cancel Selection"
                }, [..._cache[44] || (_cache[44] = [
                  createBaseVNode("span", { class: "icon" }, "âœ•", -1)
                ])])
              ], 64)) : createCommentVNode("", true),
              segmentIsLoading.value ? (openBlock(), createElementBlock("span", _hoisted_5, "Segmenting...")) : createCommentVNode("", true)
            ])
          ], 64)) : createCommentVNode("", true),
          _cache[59] || (_cache[59] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("button", {
              onClick: goToStart,
              title: "Go to Start (Home)"
            }, [..._cache[47] || (_cache[47] = [
              createBaseVNode("span", { class: "icon" }, "â®", -1)
            ])]),
            createBaseVNode("button", {
              onClick: stepBackward,
              title: "Step Backward"
            }, [..._cache[48] || (_cache[48] = [
              createBaseVNode("span", { class: "icon" }, "âª", -1)
            ])]),
            createBaseVNode("button", {
              onClick: togglePlay,
              title: isPlaying.value ? "Pause (Space)" : "Play (Space)"
            }, [
              createBaseVNode("span", _hoisted_8, toDisplayString(isPlaying.value ? "â¸" : "â–¶"), 1)
            ], 8, _hoisted_7),
            createBaseVNode("button", {
              onClick: stepForward,
              title: "Step Forward"
            }, [..._cache[49] || (_cache[49] = [
              createBaseVNode("span", { class: "icon" }, "â©", -1)
            ])]),
            createBaseVNode("button", {
              onClick: goToEnd,
              title: "Go to End (End)"
            }, [..._cache[50] || (_cache[50] = [
              createBaseVNode("span", { class: "icon" }, "â­", -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_9, toDisplayString(formattedTimecode.value), 1),
          _cache[60] || (_cache[60] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_10, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => activeWorkspace.value = $event),
              class: "workspace-selector"
            }, [..._cache[51] || (_cache[51] = [
              createBaseVNode("option", { value: "standard" }, "Standard", -1),
              createBaseVNode("option", { value: "animation" }, "Animation", -1),
              createBaseVNode("option", { value: "effects" }, "Effects", -1),
              createBaseVNode("option", { value: "minimal" }, "Minimal", -1)
            ])], 512), [
              [vModelSelect, activeWorkspace.value]
            ])
          ]),
          _cache[61] || (_cache[61] = createBaseVNode("div", { class: "spacer" }, null, -1)),
          createBaseVNode("div", _hoisted_11, [
            createBaseVNode("span", {
              class: normalizeClass(["gpu-badge", gpuTier.value])
            }, toDisplayString(gpuTier.value.toUpperCase()), 3),
            createBaseVNode("button", {
              onClick: undo,
              disabled: !canUndo.value,
              title: "Undo (Ctrl+Z)"
            }, [..._cache[52] || (_cache[52] = [
              createBaseVNode("span", { class: "icon" }, "â†©", -1)
            ])], 8, _hoisted_12),
            createBaseVNode("button", {
              onClick: redo,
              disabled: !canRedo.value,
              title: "Redo (Ctrl+Shift+Z)"
            }, [..._cache[53] || (_cache[53] = [
              createBaseVNode("span", { class: "icon" }, "â†ª", -1)
            ])], 8, _hoisted_13),
            _cache[57] || (_cache[57] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("button", {
              onClick: _cache[9] || (_cache[9] = ($event) => showPathSuggestionDialog.value = true),
              title: "AI Path Suggestion",
              class: "ai-btn"
            }, [..._cache[54] || (_cache[54] = [
              createBaseVNode("span", { class: "icon" }, "âœ¨", -1),
              createTextVNode(" AI ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[10] || (_cache[10] = ($event) => showExportDialog.value = true),
              title: "Export Matte"
            }, [..._cache[55] || (_cache[55] = [
              createBaseVNode("span", { class: "icon" }, "ðŸ“¤", -1),
              createTextVNode(" Matte ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[11] || (_cache[11] = ($event) => showComfyUIExportDialog.value = true),
              title: "Export to ComfyUI"
            }, [..._cache[56] || (_cache[56] = [
              createBaseVNode("span", { class: "icon" }, "ðŸŽ¬", -1),
              createTextVNode(" ComfyUI ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_14, [
          createVNode(unref(Pe), { class: "default-theme horizontal-split" }, {
            default: withCtx(() => [
              createVNode(unref(ge), {
                size: 12,
                "min-size": 8,
                "max-size": 20
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_15, [
                    createBaseVNode("div", _hoisted_16, [
                      createBaseVNode("button", {
                        class: normalizeClass({ active: leftTab.value === "project" }),
                        onClick: _cache[12] || (_cache[12] = ($event) => leftTab.value = "project")
                      }, " Project ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: leftTab.value === "effects" }),
                        onClick: _cache[13] || (_cache[13] = ($event) => leftTab.value = "effects")
                      }, " Effects ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: leftTab.value === "assets" }),
                        onClick: _cache[14] || (_cache[14] = ($event) => leftTab.value = "assets")
                      }, " Assets ", 2)
                    ]),
                    createBaseVNode("div", _hoisted_17, [
                      leftTab.value === "project" ? (openBlock(), createBlock(ProjectPanel, {
                        key: 0,
                        onOpenCompositionSettings: _cache[15] || (_cache[15] = ($event) => showCompositionSettingsDialog.value = true)
                      })) : leftTab.value === "effects" ? (openBlock(), createBlock(EffectsPanel, { key: 1 })) : leftTab.value === "assets" ? (openBlock(), createBlock(AssetsPanel, {
                        key: 2,
                        onCreateLayersFromSvg,
                        onUseMeshAsEmitter,
                        onEnvironmentUpdate,
                        onEnvironmentLoad,
                        onEnvironmentClear
                      })) : createCommentVNode("", true)
                    ])
                  ])
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 70,
                "min-size": 40
              }, {
                default: withCtx(() => [
                  createVNode(unref(Pe), {
                    horizontal: "",
                    class: "default-theme"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ge), {
                        size: 65,
                        "min-size": 20
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_18, [
                            createBaseVNode("div", _hoisted_19, [
                              createBaseVNode("div", _hoisted_20, [
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "composition" }),
                                  onClick: _cache[16] || (_cache[16] = ($event) => viewportTab.value = "composition")
                                }, " Composition ", 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "layer" }),
                                  onClick: _cache[17] || (_cache[17] = ($event) => viewportTab.value = "layer")
                                }, " Layer ", 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewportTab.value === "footage" }),
                                  onClick: _cache[18] || (_cache[18] = ($event) => viewportTab.value = "footage")
                                }, " Footage ", 2)
                              ]),
                              createBaseVNode("div", _hoisted_21, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => viewZoom.value = $event),
                                  onChange: handleZoomChange,
                                  class: "zoom-select"
                                }, [..._cache[62] || (_cache[62] = [
                                  createBaseVNode("option", { value: "fit" }, "Fit", -1),
                                  createBaseVNode("option", { value: "25" }, "25%", -1),
                                  createBaseVNode("option", { value: "50" }, "50%", -1),
                                  createBaseVNode("option", { value: "75" }, "75%", -1),
                                  createBaseVNode("option", { value: "100" }, "100%", -1),
                                  createBaseVNode("option", { value: "150" }, "150%", -1),
                                  createBaseVNode("option", { value: "200" }, "200%", -1)
                                ])], 544), [
                                  [vModelSelect, viewZoom.value]
                                ]),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showRulers }),
                                  onClick: _cache[20] || (_cache[20] = ($event) => viewOptions.value.showRulers = !viewOptions.value.showRulers),
                                  title: "Toggle Rulers/Guides"
                                }, [..._cache[63] || (_cache[63] = [
                                  createBaseVNode("span", { class: "icon" }, "ðŸ“", -1)
                                ])], 2),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showGrid }),
                                  onClick: _cache[21] || (_cache[21] = ($event) => viewOptions.value.showGrid = !viewOptions.value.showGrid),
                                  title: "Toggle Grid"
                                }, [..._cache[64] || (_cache[64] = [
                                  createBaseVNode("span", { class: "icon" }, "â–¦", -1)
                                ])], 2)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_22, [
                              viewOptions.value.showRulers ? (openBlock(), createElementBlock("div", _hoisted_23, [
                                createBaseVNode("div", _hoisted_24, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "h" + i,
                                      class: "tick",
                                      style: normalizeStyle({ left: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compWidth.value)), 5);
                                  }), 64))
                                ]),
                                createBaseVNode("div", _hoisted_25, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "v" + i,
                                      class: "tick",
                                      style: normalizeStyle({ top: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compHeight.value)), 5);
                                  }), 64))
                                ])
                              ])) : createCommentVNode("", true),
                              viewportTab.value === "composition" ? (openBlock(), createBlock(ThreeCanvas, {
                                key: 1,
                                ref_key: "threeCanvasRef",
                                ref: threeCanvasRef
                              }, null, 512)) : (openBlock(), createBlock(ViewportRenderer, {
                                key: 2,
                                camera: activeCamera.value,
                                viewportState: viewportState.value,
                                viewOptions: viewOptions.value,
                                compWidth: compWidth.value,
                                compHeight: compHeight.value
                              }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                            ])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ge), {
                        size: 35,
                        "min-size": 15
                      }, {
                        default: withCtx(() => [
                          showGraphEditor.value ? (openBlock(), createBlock(unref(Pe), {
                            key: 0,
                            horizontal: "",
                            class: "default-theme"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_26, [
                                    createVNode(TimelinePanel, {
                                      onOpenCompositionSettings: _cache[22] || (_cache[22] = ($event) => showCompositionSettingsDialog.value = true)
                                    })
                                  ])
                                ]),
                                _: 1
                              }),
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_27, [
                                    createVNode(GraphEditor, {
                                      onClose: _cache[23] || (_cache[23] = ($event) => showGraphEditor.value = false)
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })) : (openBlock(), createElementBlock("div", _hoisted_28, [
                            createVNode(TimelinePanel, {
                              onOpenCompositionSettings: _cache[24] || (_cache[24] = ($event) => showCompositionSettingsDialog.value = true)
                            })
                          ]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 18,
                "min-size": 12,
                "max-size": 25
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_29, [
                    createBaseVNode("div", _hoisted_30, [
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "effects" }),
                        onClick: _cache[25] || (_cache[25] = ($event) => rightTab.value = "effects")
                      }, " Effects ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "properties" }),
                        onClick: _cache[26] || (_cache[26] = ($event) => rightTab.value = "properties")
                      }, " Properties ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "camera" }),
                        onClick: _cache[27] || (_cache[27] = ($event) => rightTab.value = "camera")
                      }, " Cam ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "audio" }),
                        onClick: _cache[28] || (_cache[28] = ($event) => rightTab.value = "audio")
                      }, " Audio ", 2),
                      createBaseVNode("button", {
                        class: normalizeClass({ active: rightTab.value === "export" }),
                        onClick: _cache[29] || (_cache[29] = ($event) => rightTab.value = "export")
                      }, " Export ", 2)
                    ]),
                    createBaseVNode("div", _hoisted_31, [
                      rightTab.value === "effects" ? (openBlock(), createBlock(EffectControlsPanel, { key: 0 })) : rightTab.value === "properties" ? (openBlock(), createBlock(PropertiesPanel, { key: 1 })) : rightTab.value === "camera" ? (openBlock(), createBlock(CameraProperties, {
                        key: 2,
                        camera: activeCamera.value,
                        "onUpdate:camera": updateCamera
                      }, null, 8, ["camera"])) : rightTab.value === "audio" ? (openBlock(), createBlock(AudioPanel, { key: 3 })) : rightTab.value === "export" ? (openBlock(), createBlock(ExportPanel, { key: 4 })) : createCommentVNode("", true)
                    ])
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        createBaseVNode("div", _hoisted_32, [
          createBaseVNode("div", _hoisted_33, [
            createBaseVNode("span", _hoisted_34, toDisplayString(projectName.value), 1),
            _cache[65] || (_cache[65] = createBaseVNode("span", { class: "status-divider" }, "|", -1)),
            createBaseVNode("span", _hoisted_35, toDisplayString(compositionInfo.value), 1)
          ]),
          createBaseVNode("div", _hoisted_36, [
            renderProgress.value > 0 ? (openBlock(), createElementBlock("span", _hoisted_37, " Rendering: " + toDisplayString(Math.round(renderProgress.value * 100)) + "% ", 1)) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_38, [
            createBaseVNode("span", _hoisted_39, toDisplayString(memoryUsage.value), 1),
            _cache[66] || (_cache[66] = createBaseVNode("span", { class: "status-divider" }, "|", -1)),
            createBaseVNode("span", _hoisted_40, toDisplayString(fps.value) + " fps", 1)
          ])
        ]),
        showExportDialog.value ? (openBlock(), createBlock(ExportDialog, {
          key: 0,
          onClose: _cache[30] || (_cache[30] = ($event) => showExportDialog.value = false),
          onExported: onExportComplete
        })) : createCommentVNode("", true),
        showComfyUIExportDialog.value ? (openBlock(), createBlock(ComfyUIExportDialog, {
          key: 1,
          layers: unref(store).layers,
          "camera-keyframes": activeCameraKeyframes.value,
          "current-frame": unref(store).currentFrame,
          "total-frames": unref(store).frameCount,
          onClose: _cache[31] || (_cache[31] = ($event) => showComfyUIExportDialog.value = false),
          onExported: onComfyUIExportComplete
        }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : createCommentVNode("", true),
        createVNode(CompositionSettingsDialog, {
          visible: showCompositionSettingsDialog.value,
          onClose: _cache[32] || (_cache[32] = ($event) => showCompositionSettingsDialog.value = false),
          onConfirm: onCompositionSettingsConfirm
        }, null, 8, ["visible"]),
        createVNode(PathSuggestionDialog, {
          visible: showPathSuggestionDialog.value,
          onClose: onPathSuggestionClose,
          onAccept: onPathSuggestionAccept,
          onPreview: onPathSuggestionPreview
        }, null, 8, ["visible"]),
        pathSuggestions.value.length > 0 ? (openBlock(), createBlock(Teleport, {
          key: 2,
          to: ".viewport-content"
        }, [
          createVNode(PathPreviewOverlay, {
            width: compWidth.value,
            height: compHeight.value,
            suggestions: pathSuggestions.value,
            selectedIndex: selectedPathIndex.value,
            onSelect: _cache[33] || (_cache[33] = ($event) => selectedPathIndex.value = $event)
          }, null, 8, ["width", "height", "suggestions", "selectedIndex"])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const WorkspaceLayout = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-e0af90cd"]]);

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WorkspaceLayout);
    };
  }
});

class WebGLBlurContext {
  gl = null;
  canvas = null;
  program = null;
  positionBuffer = null;
  texCoordBuffer = null;
  texture = null;
  framebuffer = null;
  pingPongTextures = [];
  _isAvailable = null;
  currentWidth = 0;
  currentHeight = 0;
  /**
   * Vertex shader for fullscreen quad
   */
  vertexShaderSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  /**
   * Fragment shader for separable Gaussian blur
   * Uses 9-tap kernel approximation
   */
  fragmentShaderSource = `
    precision mediump float;
    uniform sampler2D u_image;
    uniform vec2 u_direction;
    uniform vec2 u_resolution;
    uniform float u_radius;
    varying vec2 v_texCoord;

    void main() {
      vec2 texelSize = 1.0 / u_resolution;
      vec4 color = vec4(0.0);
      float total = 0.0;

      // Dynamic kernel based on radius
      int samples = int(min(u_radius * 2.0 + 1.0, 25.0));
      float sigma = max(u_radius / 2.0, 1.0);

      for (int i = -12; i <= 12; i++) {
        if (abs(float(i)) > u_radius) continue;

        float x = float(i);
        float weight = exp(-(x * x) / (2.0 * sigma * sigma));
        vec2 offset = u_direction * texelSize * x;
        color += texture2D(u_image, v_texCoord + offset) * weight;
        total += weight;
      }

      gl_FragColor = color / total;
    }
  `;
  /**
   * Check if WebGL blur is available
   */
  isAvailable() {
    if (this._isAvailable !== null) {
      return this._isAvailable;
    }
    try {
      const testCanvas = document.createElement("canvas");
      testCanvas.width = 1;
      testCanvas.height = 1;
      const gl = testCanvas.getContext("webgl") || testCanvas.getContext("experimental-webgl");
      this._isAvailable = gl !== null;
    } catch {
      this._isAvailable = false;
    }
    return this._isAvailable;
  }
  /**
   * Initialize WebGL context and shaders
   */
  init(width, height) {
    if (!this.isAvailable()) return false;
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
    }
    if (this.currentWidth !== width || this.currentHeight !== height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this.currentWidth = width;
      this.currentHeight = height;
      this.pingPongTextures = [];
    }
    if (!this.gl) {
      this.gl = this.canvas.getContext("webgl", {
        alpha: true,
        premultipliedAlpha: false,
        preserveDrawingBuffer: true
      });
      if (!this.gl) return false;
    }
    const gl = this.gl;
    if (!this.program) {
      const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, this.vertexShaderSource);
      const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, this.fragmentShaderSource);
      if (!vertexShader || !fragmentShader) return false;
      this.program = gl.createProgram();
      gl.attachShader(this.program, vertexShader);
      gl.attachShader(this.program, fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.warn("[WebGLBlur] Program link failed:", gl.getProgramInfoLog(this.program));
        return false;
      }
      this.positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1,
        1
      ]), gl.STATIC_DRAW);
      this.texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1,
        1
      ]), gl.STATIC_DRAW);
    }
    if (this.pingPongTextures.length < 2) {
      for (let i = 0; i < 2; i++) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this.pingPongTextures.push(tex);
      }
      this.framebuffer = gl.createFramebuffer();
    }
    return true;
  }
  /**
   * Compile a shader
   */
  compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.warn("[WebGLBlur] Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  /**
   * Apply Gaussian blur using WebGL
   */
  blur(input, radiusX, radiusY) {
    const { width, height } = input;
    if (!this.init(width, height)) {
      return null;
    }
    const gl = this.gl;
    const program = this.program;
    gl.useProgram(program);
    gl.viewport(0, 0, width, height);
    const positionLoc = gl.getAttribLocation(program, "a_position");
    const texCoordLoc = gl.getAttribLocation(program, "a_texCoord");
    const imageLoc = gl.getUniformLocation(program, "u_image");
    const directionLoc = gl.getUniformLocation(program, "u_direction");
    const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
    const radiusLoc = gl.getUniformLocation(program, "u_radius");
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.enableVertexAttribArray(texCoordLoc);
    gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1i(imageLoc, 0);
    gl.uniform2f(resolutionLoc, width, height);
    if (!this.texture) {
      this.texture = gl.createTexture();
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, input);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    let sourceTexture = this.texture;
    let destIdx = 0;
    if (radiusX > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 1, 0);
      gl.uniform1f(radiusLoc, radiusX);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
      destIdx = 1 - destIdx;
    }
    if (radiusY > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 0, 1);
      gl.uniform1f(radiusLoc, radiusY);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sourceTexture, 0);
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const outputCanvas = document.createElement("canvas");
    outputCanvas.width = width;
    outputCanvas.height = height;
    const ctx = outputCanvas.getContext("2d");
    const imageData = ctx.createImageData(width, height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width * 4;
      const dstRow = y * width * 4;
      for (let x = 0; x < width * 4; x++) {
        imageData.data[dstRow + x] = pixels[srcRow + x];
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return outputCanvas;
  }
  /**
   * Clean up WebGL resources
   */
  dispose() {
    if (this.gl) {
      if (this.program) this.gl.deleteProgram(this.program);
      if (this.texture) this.gl.deleteTexture(this.texture);
      if (this.positionBuffer) this.gl.deleteBuffer(this.positionBuffer);
      if (this.texCoordBuffer) this.gl.deleteBuffer(this.texCoordBuffer);
      if (this.framebuffer) this.gl.deleteFramebuffer(this.framebuffer);
      for (const tex of this.pingPongTextures) {
        this.gl.deleteTexture(tex);
      }
    }
    this.gl = null;
    this.canvas = null;
    this.program = null;
    this._isAvailable = null;
  }
}
const webglBlurContext = new WebGLBlurContext();
const GPU_BLUR_THRESHOLD = 15;
const MUL_TABLE = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
const SHG_TABLE = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function createBlurStack(size) {
  const first = { r: 0, g: 0, b: 0, a: 0, next: null };
  let current = first;
  for (let i = 1; i < size; i++) {
    current.next = { r: 0, g: 0, b: 0, a: 0, next: null };
    current = current.next;
  }
  current.next = first;
  return first;
}
function stackBlur(imageData, radiusX, radiusY) {
  const pixels = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  radiusX = Math.max(0, Math.min(255, Math.round(radiusX)));
  radiusY = Math.max(0, Math.min(255, Math.round(radiusY)));
  if (radiusX === 0 && radiusY === 0) return;
  if (radiusX > 0) {
    stackBlurHorizontal(pixels, width, height, radiusX);
  }
  if (radiusY > 0) {
    stackBlurVertical(pixels, width, height, radiusY);
  }
}
function stackBlurHorizontal(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const widthMinus1 = width - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let y = 0; y < height; y++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    const yOffset = y * width;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[yOffset * 4];
    const pg = pixels[yOffset * 4 + 1];
    const pb = pixels[yOffset * 4 + 2];
    const pa = pixels[yOffset * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, widthMinus1);
      const pOffset = (yOffset + p) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let x = 0; x < width; x++) {
      const pOffset = (yOffset + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(x + radius + 1, widthMinus1);
      const pIn = (yOffset + p) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function stackBlurVertical(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const heightMinus1 = height - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let x = 0; x < width; x++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[x * 4];
    const pg = pixels[x * 4 + 1];
    const pb = pixels[x * 4 + 2];
    const pa = pixels[x * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, heightMinus1);
      const pOffset = (p * width + x) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let y = 0; y < height; y++) {
      const pOffset = (y * width + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(y + radius + 1, heightMinus1);
      const pIn = (p * width + x) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function gaussianBlurRenderer(input, params) {
  const blurriness = params.blurriness ?? 10;
  const dimensions = params.blur_dimensions ?? "both";
  const useGpu = params.use_gpu !== false;
  if (blurriness <= 0) {
    return input;
  }
  let radiusX = 0;
  let radiusY = 0;
  switch (dimensions) {
    case "horizontal":
      radiusX = blurriness;
      break;
    case "vertical":
      radiusY = blurriness;
      break;
    case "both":
    default:
      radiusX = blurriness;
      radiusY = blurriness;
      break;
  }
  const maxRadius = Math.max(radiusX, radiusY);
  if (useGpu && maxRadius > GPU_BLUR_THRESHOLD && webglBlurContext.isAvailable()) {
    const gpuResult = webglBlurContext.blur(input.canvas, radiusX, radiusY);
    if (gpuResult) {
      const output2 = createMatchingCanvas(input.canvas);
      output2.ctx.drawImage(gpuResult, 0, 0);
      return output2;
    }
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  stackBlur(imageData, radiusX, radiusY);
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function directionalBlurRenderer(input, params) {
  const direction = (params.direction ?? 0) * Math.PI / 180;
  const blurLength = Math.max(0, Math.min(500, params.blur_length ?? 10));
  if (blurLength <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const dx = Math.cos(direction);
  const dy = Math.sin(direction);
  const samples = Math.max(3, Math.ceil(blurLength));
  const halfSamples = Math.floor(samples / 2);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      for (let i = -halfSamples; i <= halfSamples; i++) {
        const sampleX = Math.round(x + dx * i * (blurLength / samples));
        const sampleY = Math.round(y + dy * i * (blurLength / samples));
        const sx = Math.max(0, Math.min(width - 1, sampleX));
        const sy = Math.max(0, Math.min(height - 1, sampleY));
        const idx = (sy * width + sx) * 4;
        r += src[idx];
        g += src[idx + 1];
        b += src[idx + 2];
        a += src[idx + 3];
        count++;
      }
      const outIdx = (y * width + x) * 4;
      dst[outIdx] = Math.round(r / count);
      dst[outIdx + 1] = Math.round(g / count);
      dst[outIdx + 2] = Math.round(b / count);
      dst[outIdx + 3] = Math.round(a / count);
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function radialBlurRenderer(input, params) {
  const type = params.type ?? "spin";
  const amount = Math.max(0, Math.min(100, params.amount ?? 10));
  const centerX = (params.center_x ?? 50) / 100;
  const centerY = (params.center_y ?? 50) / 100;
  const quality = params.quality ?? "good";
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const cx = centerX * width;
  const cy = centerY * height;
  const samples = quality === "best" ? 32 : quality === "good" ? 16 : 8;
  if (type === "spin") {
    const maxAngle = amount / 100 * Math.PI * 0.5;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const baseAngle = Math.atan2(dy, dx);
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1) - 0.5;
          const angle = baseAngle + t * maxAngle;
          const sampleX = Math.round(cx + Math.cos(angle) * dist);
          const sampleY = Math.round(cy + Math.sin(angle) * dist);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  } else {
    const maxZoom = amount / 100;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1);
          const scale = 1 - t * maxZoom;
          const sampleX = Math.round(cx + dx * scale);
          const sampleY = Math.round(cy + dy * scale);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function boxBlurRenderer(input, params) {
  const radius = Math.max(0, Math.min(100, Math.round(params.radius ?? 5)));
  const iterations = Math.max(1, Math.min(5, params.iterations ?? 1));
  if (radius <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  let current = createMatchingCanvas(input.canvas);
  current.ctx.drawImage(input.canvas, 0, 0);
  for (let iter = 0; iter < iterations; iter++) {
    const imageData = current.ctx.getImageData(0, 0, width, height);
    const src = imageData.data;
    const dst = new Uint8ClampedArray(src.length);
    const size = radius * 2 + 1;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dx = -radius; dx <= radius; dx++) {
          const sx = Math.max(0, Math.min(width - 1, x + dx));
          const idx = (y * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    src.set(dst);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dy = -radius; dy <= radius; dy++) {
          const sy = Math.max(0, Math.min(height - 1, y + dy));
          const idx = (sy * width + x) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    imageData.data.set(dst);
    current.ctx.putImageData(imageData, 0, 0);
  }
  return current;
}
function sharpenRenderer(input, params) {
  const amount = (params.amount ?? 100) / 100;
  const radius = Math.max(1, Math.min(100, params.radius ?? 1));
  const threshold = params.threshold ?? 0;
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const blurred = createMatchingCanvas(input.canvas);
  blurred.ctx.drawImage(input.canvas, 0, 0);
  const blurredData = blurred.ctx.getImageData(0, 0, width, height);
  stackBlur(blurredData, radius, radius);
  const output = createMatchingCanvas(input.canvas);
  const originalData = input.ctx.getImageData(0, 0, width, height);
  const orig = originalData.data;
  const blur = blurredData.data;
  for (let i = 0; i < orig.length; i += 4) {
    for (let c = 0; c < 3; c++) {
      const diff = orig[i + c] - blur[i + c];
      if (Math.abs(diff) >= threshold) {
        const sharpened = orig[i + c] + diff * amount;
        orig[i + c] = Math.max(0, Math.min(255, Math.round(sharpened)));
      }
    }
  }
  output.ctx.putImageData(originalData, 0, 0);
  return output;
}
function registerBlurEffects() {
  registerEffectRenderer("gaussian-blur", gaussianBlurRenderer);
  registerEffectRenderer("directional-blur", directionalBlurRenderer);
  registerEffectRenderer("radial-blur", radialBlurRenderer);
  registerEffectRenderer("box-blur", boxBlurRenderer);
  registerEffectRenderer("sharpen", sharpenRenderer);
}

function brightnessContrastRenderer(input, params) {
  const brightness = (params.brightness ?? 0) / 100;
  const contrast = (params.contrast ?? 0) / 100;
  const useLegacy = params.use_legacy ?? false;
  if (brightness === 0 && contrast === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const contrastFactor = useLegacy ? 1 + contrast : 259 * (contrast * 255 + 255) / (255 * (259 - contrast * 255));
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    r += brightness * 255;
    g += brightness * 255;
    b += brightness * 255;
    r = contrastFactor * (r - 128) + 128;
    g = contrastFactor * (g - 128) + 128;
    b = contrastFactor * (b - 128) + 128;
    data[i] = Math.max(0, Math.min(255, r));
    data[i + 1] = Math.max(0, Math.min(255, g));
    data[i + 2] = Math.max(0, Math.min(255, b));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }
  return [h, s, l];
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
function hueSaturationRenderer(input, params) {
  const hueShift = (params.master_hue ?? 0) / 360;
  const saturationShift = (params.master_saturation ?? 0) / 100;
  const lightnessShift = (params.master_lightness ?? 0) / 100;
  const colorize = params.colorize ?? false;
  if (hueShift === 0 && saturationShift === 0 && lightnessShift === 0 && !colorize) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    let [h, s, l] = rgbToHsl(r, g, b);
    if (colorize) {
      h = hueShift;
      s = Math.abs(saturationShift) + 0.25;
    } else {
      h = (h + hueShift) % 1;
      if (h < 0) h += 1;
      s = s + s * saturationShift;
    }
    l = l + l * lightnessShift;
    s = Math.max(0, Math.min(1, s));
    l = Math.max(0, Math.min(1, l));
    const [newR, newG, newB] = hslToRgb(h, s, l);
    data[i] = newR;
    data[i + 1] = newG;
    data[i + 2] = newB;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function levelsRenderer(input, params) {
  const inputBlack = params.input_black ?? 0;
  const inputWhite = params.input_white ?? 255;
  const gamma = params.gamma ?? 1;
  const outputBlack = params.output_black ?? 0;
  const outputWhite = params.output_white ?? 255;
  if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const inputRange = inputWhite - inputBlack;
  const outputRange = outputWhite - outputBlack;
  for (let i = 0; i < 256; i++) {
    let value = (i - inputBlack) / inputRange;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, 1 / gamma);
    value = outputBlack + value * outputRange;
    value = Math.max(0, Math.min(255, value));
    lut[i] = Math.round(value);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function tintRenderer(input, params) {
  const blackColor = params.map_black_to ?? { r: 0, g: 0, b: 0 };
  const whiteColor = params.map_white_to ?? { r: 255, g: 255, b: 255 };
  const amount = (params.amount_to_tint ?? 100) / 100;
  if (amount === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const tintR = blackColor.r + (whiteColor.r - blackColor.r) * lum;
    const tintG = blackColor.g + (whiteColor.g - blackColor.g) * lum;
    const tintB = blackColor.b + (whiteColor.b - blackColor.b) * lum;
    data[i] = Math.round(r + (tintR - r) * amount);
    data[i + 1] = Math.round(g + (tintG - g) * amount);
    data[i + 2] = Math.round(b + (tintB - b) * amount);
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function cubicBezier(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
}
function buildCurveLUT(points) {
  const lut = new Uint8Array(256);
  if (!points || points.length === 0) {
    for (let i = 0; i < 256; i++) {
      lut[i] = i;
    }
    return lut;
  }
  if (points.length === 1) {
    for (let i = 0; i < 256; i++) {
      lut[i] = Math.max(0, Math.min(255, Math.round(points[0].y)));
    }
    return lut;
  }
  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
  if (sortedPoints[0].x > 0) {
    sortedPoints.unshift({ x: 0, y: sortedPoints[0].y });
  }
  if (sortedPoints[sortedPoints.length - 1].x < 255) {
    sortedPoints.push({ x: 255, y: sortedPoints[sortedPoints.length - 1].y });
  }
  for (let i = 0; i < 256; i++) {
    let segmentIndex = 0;
    for (let j = 0; j < sortedPoints.length - 1; j++) {
      if (i >= sortedPoints[j].x && i <= sortedPoints[j + 1].x) {
        segmentIndex = j;
        break;
      }
    }
    const p0 = sortedPoints[segmentIndex];
    const p1 = sortedPoints[segmentIndex + 1];
    const t = (i - p0.x) / (p1.x - p0.x || 1);
    let tangent0 = 0;
    let tangent1 = 0;
    if (segmentIndex > 0) {
      const pPrev = sortedPoints[segmentIndex - 1];
      tangent0 = (p1.y - pPrev.y) / (p1.x - pPrev.x || 1) * (p1.x - p0.x);
    }
    if (segmentIndex < sortedPoints.length - 2) {
      const pNext = sortedPoints[segmentIndex + 2];
      tangent1 = (pNext.y - p0.y) / (pNext.x - p0.x || 1) * (p1.x - p0.x);
    }
    const cp1y = p0.y + tangent0 / 3;
    const cp2y = p1.y - tangent1 / 3;
    const value = cubicBezier(p0.y, cp1y, cp2y, p1.y, t);
    lut[i] = Math.max(0, Math.min(255, Math.round(value)));
  }
  return lut;
}
function curvesRenderer(input, params) {
  const masterCurve = params.master_curve;
  const redCurve = params.red_curve;
  const greenCurve = params.green_curve;
  const blueCurve = params.blue_curve;
  const alphaCurve = params.alpha_curve;
  const blend = (params.blend_with_original ?? 100) / 100;
  const hasCurves = masterCurve || redCurve || greenCurve || blueCurve || alphaCurve;
  if (!hasCurves || blend === 0) {
    return input;
  }
  const masterLUT = buildCurveLUT(masterCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const redLUT = buildCurveLUT(redCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const greenLUT = buildCurveLUT(greenCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const blueLUT = buildCurveLUT(blueCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const alphaLUT = alphaCurve ? buildCurveLUT(alphaCurve) : null;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    const origA = data[i + 3];
    let r = masterLUT[origR];
    let g = masterLUT[origG];
    let b = masterLUT[origB];
    r = redLUT[r];
    g = greenLUT[g];
    b = blueLUT[b];
    const a = alphaLUT ? alphaLUT[origA] : origA;
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
    data[i + 3] = a;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function glowRenderer(input, params) {
  const threshold = params.glow_threshold ?? 128;
  const radius = params.glow_radius ?? 20;
  const intensity = (params.glow_intensity ?? 100) / 100;
  const operation = params.glow_operation ?? "add";
  if (intensity === 0 || radius === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const thresholdCanvas = document.createElement("canvas");
  thresholdCanvas.width = width;
  thresholdCanvas.height = height;
  const thresholdCtx = thresholdCanvas.getContext("2d");
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const thresholdData = thresholdCtx.createImageData(width, height);
  for (let i = 0; i < inputData.data.length; i += 4) {
    const r = inputData.data[i];
    const g = inputData.data[i + 1];
    const b = inputData.data[i + 2];
    const a = inputData.data[i + 3];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    if (lum > threshold) {
      const scale = (lum - threshold) / (255 - threshold) * intensity;
      thresholdData.data[i] = Math.min(255, r * scale);
      thresholdData.data[i + 1] = Math.min(255, g * scale);
      thresholdData.data[i + 2] = Math.min(255, b * scale);
      thresholdData.data[i + 3] = a;
    } else {
      thresholdData.data[i] = 0;
      thresholdData.data[i + 1] = 0;
      thresholdData.data[i + 2] = 0;
      thresholdData.data[i + 3] = 0;
    }
  }
  thresholdCtx.putImageData(thresholdData, 0, 0);
  const blurCanvas = document.createElement("canvas");
  blurCanvas.width = width;
  blurCanvas.height = height;
  const blurCtx = blurCanvas.getContext("2d");
  blurCtx.filter = `blur(${radius}px)`;
  blurCtx.drawImage(thresholdCanvas, 0, 0);
  output.ctx.drawImage(input.canvas, 0, 0);
  switch (operation) {
    case "screen":
      output.ctx.globalCompositeOperation = "screen";
      break;
    case "lighten":
      output.ctx.globalCompositeOperation = "lighten";
      break;
    case "add":
    default:
      output.ctx.globalCompositeOperation = "lighter";
      break;
  }
  output.ctx.drawImage(blurCanvas, 0, 0);
  output.ctx.globalCompositeOperation = "source-over";
  return output;
}
function dropShadowRenderer(input, params) {
  const shadowColor = params.shadow_color ?? { r: 0, g: 0, b: 0};
  const opacity = (params.opacity ?? 50) / 100;
  const direction = (params.direction ?? 135) * Math.PI / 180;
  const distance = params.distance ?? 5;
  const softness = params.softness ?? 5;
  const shadowOnly = params.shadow_only ?? false;
  const output = createMatchingCanvas(input.canvas);
  const offsetX = Math.cos(direction) * distance;
  const offsetY = Math.sin(direction) * distance;
  output.ctx.shadowColor = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${opacity})`;
  output.ctx.shadowBlur = softness;
  output.ctx.shadowOffsetX = offsetX;
  output.ctx.shadowOffsetY = offsetY;
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.shadowColor = "transparent";
  output.ctx.shadowBlur = 0;
  output.ctx.shadowOffsetX = 0;
  output.ctx.shadowOffsetY = 0;
  if (!shadowOnly) {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  return output;
}
function colorBalanceRenderer(input, params) {
  const shadowR = (params.shadow_red ?? 0) / 100;
  const shadowG = (params.shadow_green ?? 0) / 100;
  const shadowB = (params.shadow_blue ?? 0) / 100;
  const midtoneR = (params.midtone_red ?? 0) / 100;
  const midtoneG = (params.midtone_green ?? 0) / 100;
  const midtoneB = (params.midtone_blue ?? 0) / 100;
  const highlightR = (params.highlight_red ?? 0) / 100;
  const highlightG = (params.highlight_green ?? 0) / 100;
  const highlightB = (params.highlight_blue ?? 0) / 100;
  const preserveLuminosity = params.preserve_luminosity ?? true;
  if (shadowR === 0 && shadowG === 0 && shadowB === 0 && midtoneR === 0 && midtoneG === 0 && midtoneB === 0 && highlightR === 0 && highlightG === 0 && highlightB === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const shadowWeight = Math.max(0, 1 - lum * 3);
    const highlightWeight = Math.max(0, (lum - 0.67) * 3);
    const midtoneWeight = 1 - shadowWeight - highlightWeight;
    const rAdjust = shadowR * shadowWeight + midtoneR * midtoneWeight + highlightR * highlightWeight;
    const gAdjust = shadowG * shadowWeight + midtoneG * midtoneWeight + highlightG * highlightWeight;
    const bAdjust = shadowB * shadowWeight + midtoneB * midtoneWeight + highlightB * highlightWeight;
    r = r + rAdjust * 255;
    g = g + gAdjust * 255;
    b = b + bAdjust * 255;
    if (preserveLuminosity) {
      const newLum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      if (newLum > 1e-3) {
        const lumRatio = lum / newLum;
        r *= lumRatio;
        g *= lumRatio;
        b *= lumRatio;
      }
    }
    data[i] = Math.max(0, Math.min(255, Math.round(r)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function exposureRenderer(input, params) {
  const exposure = params.exposure ?? 0;
  const offset = params.offset ?? 0;
  const gamma = params.gamma ?? 1;
  if (exposure === 0 && offset === 0 && gamma === 1) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const exposureMultiplier = Math.pow(2, exposure);
  const gammaInv = 1 / gamma;
  for (let i = 0; i < 256; i++) {
    let value = i / 255;
    value *= exposureMultiplier;
    value += offset;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, gammaInv);
    lut[i] = Math.round(value * 255);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function vibranceRenderer(input, params) {
  const vibrance = (params.vibrance ?? 0) / 100;
  const saturation = (params.saturation ?? 0) / 100;
  if (vibrance === 0 && saturation === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i] / 255;
    let g = data[i + 1] / 255;
    let b = data[i + 2] / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const currentSat = max - min;
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const skinProtection = 1 - Math.max(0, Math.min(
      1,
      Math.abs(r - 0.8) * 2 + Math.abs(g - 0.5) * 2 + Math.abs(b - 0.3) * 3
    ));
    const vibranceAmount = vibrance * (1 - currentSat) * (1 - skinProtection * 0.5);
    const satAdjust = 1 + saturation + vibranceAmount;
    r = lum + (r - lum) * satAdjust;
    g = lum + (g - lum) * satAdjust;
    b = lum + (b - lum) * satAdjust;
    data[i] = Math.max(0, Math.min(255, Math.round(r * 255)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function invertRenderer(input, params) {
  const blend = (params.blend ?? 100) / 100;
  const channel = params.channel ?? "rgb";
  if (blend === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    let r = origR;
    let g = origG;
    let b = origB;
    switch (channel) {
      case "rgb":
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
        break;
      case "red":
        r = 255 - r;
        break;
      case "green":
        g = 255 - g;
        break;
      case "blue":
        b = 255 - b;
        break;
      case "hue":
      case "saturation":
      case "lightness": {
        let [h, s, l] = rgbToHsl(r, g, b);
        if (channel === "hue") h = (h + 0.5) % 1;
        else if (channel === "saturation") s = 1 - s;
        else if (channel === "lightness") l = 1 - l;
        [r, g, b] = hslToRgb(h, s, l);
        break;
      }
    }
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function posterizeRenderer(input, params) {
  const levels = Math.max(2, Math.min(256, params.levels ?? 6));
  if (levels === 256) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const step = 255 / (levels - 1);
  for (let i = 0; i < 256; i++) {
    const level = Math.round(i / 255 * (levels - 1));
    lut[i] = Math.round(level * step);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function thresholdRenderer(input, params) {
  const threshold = params.threshold ?? 128;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const value = lum >= threshold ? 255 : 0;
    data[i] = value;
    data[i + 1] = value;
    data[i + 2] = value;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function registerColorEffects() {
  registerEffectRenderer("brightness-contrast", brightnessContrastRenderer);
  registerEffectRenderer("hue-saturation", hueSaturationRenderer);
  registerEffectRenderer("levels", levelsRenderer);
  registerEffectRenderer("tint", tintRenderer);
  registerEffectRenderer("curves", curvesRenderer);
  registerEffectRenderer("glow", glowRenderer);
  registerEffectRenderer("drop-shadow", dropShadowRenderer);
  registerEffectRenderer("color-balance", colorBalanceRenderer);
  registerEffectRenderer("exposure", exposureRenderer);
  registerEffectRenderer("vibrance", vibranceRenderer);
  registerEffectRenderer("invert", invertRenderer);
  registerEffectRenderer("posterize", posterizeRenderer);
  registerEffectRenderer("threshold", thresholdRenderer);
}

function transformRenderer(input, params) {
  const anchorPoint = params.anchor_point ?? { x: 0.5, y: 0.5 };
  const position = params.position ?? { x: 0.5, y: 0.5 };
  const scaleWidth = (params.scale_width ?? 100) / 100;
  const scaleHeight = (params.scale_height ?? 100) / 100;
  const skew = (params.skew ?? 0) * Math.PI / 180;
  const skewAxis = (params.skew_axis ?? 0) * Math.PI / 180;
  const rotation = (params.rotation ?? 0) * Math.PI / 180;
  const opacity = (params.opacity ?? 100) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const anchorX = anchorPoint.x * width;
  const anchorY = anchorPoint.y * height;
  const posX = position.x * width;
  const posY = position.y * height;
  output.ctx.globalAlpha = opacity;
  output.ctx.translate(posX, posY);
  output.ctx.rotate(rotation);
  if (skew !== 0) {
    const skewX = Math.tan(skew) * Math.cos(skewAxis);
    const skewY = Math.tan(skew) * Math.sin(skewAxis);
    output.ctx.transform(1, skewY, skewX, 1, 0, 0);
  }
  output.ctx.scale(scaleWidth, scaleHeight);
  output.ctx.translate(-anchorX, -anchorY);
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.setTransform(1, 0, 0, 1, 0, 0);
  output.ctx.globalAlpha = 1;
  return output;
}
function warpRenderer(input, params) {
  const warpStyle = params.warp_style ?? "arc";
  const bend = (params.bend ?? 0) / 100;
  const hDistort = (params.horizontal_distortion ?? 0) / 100;
  const vDistort = (params.vertical_distortion ?? 0) / 100;
  if (bend === 0 && hDistort === 0 && vDistort === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const nx = (x - centerX) / centerX;
      const ny = (y - centerY) / centerY;
      let srcX = x;
      let srcY = y;
      switch (warpStyle) {
        case "arc": {
          const arcBend = bend * ny * ny;
          srcX = x + arcBend * centerX * nx;
          break;
        }
        case "bulge": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r < 1) {
            const factor = 1 + bend * (1 - r * r);
            srcX = centerX + (x - centerX) / factor;
            srcY = centerY + (y - centerY) / factor;
          }
          break;
        }
        case "wave": {
          srcX = x + Math.sin(ny * Math.PI * 2) * bend * width * 0.1;
          srcY = y + Math.sin(nx * Math.PI * 2) * bend * height * 0.1;
          break;
        }
        case "fisheye": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r > 0 && r < 1) {
            const theta = Math.atan2(ny, nx);
            const newR = Math.pow(r, 1 + bend);
            srcX = centerX + newR * Math.cos(theta) * centerX;
            srcY = centerY + newR * Math.sin(theta) * centerY;
          }
          break;
        }
        case "twist": {
          const r = Math.sqrt(nx * nx + ny * ny);
          const angle = bend * Math.PI * (1 - r);
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          srcX = centerX + (nx * cos - ny * sin) * centerX;
          srcY = centerY + (nx * sin + ny * cos) * centerY;
          break;
        }
      }
      srcX += hDistort * centerX * (1 - ny * ny);
      srcY += vDistort * centerY * (1 - nx * nx);
      srcX = Math.max(0, Math.min(width - 1, srcX));
      srcY = Math.max(0, Math.min(height - 1, srcY));
      const x0 = Math.floor(srcX);
      const y0 = Math.floor(srcY);
      const x1 = Math.min(x0 + 1, width - 1);
      const y1 = Math.min(y0 + 1, height - 1);
      const fx = srcX - x0;
      const fy = srcY - y0;
      const idx00 = (y0 * width + x0) * 4;
      const idx01 = (y0 * width + x1) * 4;
      const idx10 = (y1 * width + x0) * 4;
      const idx11 = (y1 * width + x1) * 4;
      const outIdx = (y * width + x) * 4;
      for (let c = 0; c < 4; c++) {
        const v00 = src[idx00 + c];
        const v01 = src[idx01 + c];
        const v10 = src[idx10 + c];
        const v11 = src[idx11 + c];
        dst[outIdx + c] = Math.round(
          v00 * (1 - fx) * (1 - fy) + v01 * fx * (1 - fy) + v10 * (1 - fx) * fy + v11 * fx * fy
        );
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function displacementMapRenderer(input, params) {
  return input;
}
function registerDistortEffects() {
  registerEffectRenderer("transform", transformRenderer);
  registerEffectRenderer("warp", warpRenderer);
  registerEffectRenderer("displacement-map", displacementMapRenderer);
}

class NoiseTileCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 32;
  // Max cached tiles
  maxAgeMs = 3e4;
  // 30 second TTL
  /**
   * Generate cache key from parameters
   */
  makeKey(width, height, scale, octave, seed) {
    const quantizedSeed = Math.round(seed * 100) / 100;
    return `${width}:${height}:${scale}:${octave}:${quantizedSeed}`;
  }
  /**
   * Get cached noise tile or null if not found/expired
   */
  get(width, height, scale, octave, seed) {
    const key = this.makeKey(width, height, scale, octave, seed);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, { ...entry, timestamp: now });
    return entry.tile;
  }
  /**
   * Store noise tile in cache
   */
  set(width, height, scale, octave, seed, tile) {
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    const key = this.makeKey(width, height, scale, octave, seed);
    this.cache.set(key, {
      tile,
      width,
      height,
      scale,
      octave,
      seed,
      timestamp: Date.now()
    });
  }
  /**
   * Clear all cached tiles
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const noiseTileCache = new NoiseTileCache();
function fillRenderer(input, params) {
  const color = params.color ?? { r: 255, g: 0, b: 0, a: 1 };
  const opacity = (params.opacity ?? 100) / 100;
  const invert = params.invert ?? false;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const r = color.r ?? 255;
  const g = color.g ?? 0;
  const b = color.b ?? 0;
  const a = (color.a ?? 1) * 255 * opacity;
  for (let i = 0; i < src.length; i += 4) {
    const srcAlpha = src[i + 3] / 255;
    if (invert) {
      const fillAmount = 1 - srcAlpha;
      dst[i] = Math.round(r * fillAmount + src[i] * (1 - fillAmount));
      dst[i + 1] = Math.round(g * fillAmount + src[i + 1] * (1 - fillAmount));
      dst[i + 2] = Math.round(b * fillAmount + src[i + 2] * (1 - fillAmount));
      dst[i + 3] = Math.max(src[i + 3], Math.round(a * fillAmount));
    } else {
      dst[i] = Math.round(r * srcAlpha * opacity + src[i] * (1 - opacity));
      dst[i + 1] = Math.round(g * srcAlpha * opacity + src[i + 1] * (1 - opacity));
      dst[i + 2] = Math.round(b * srcAlpha * opacity + src[i + 2] * (1 - opacity));
      dst[i + 3] = src[i + 3];
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function gradientRampRenderer(input, params) {
  const startPoint = params.start_of_ramp ?? { x: 0, y: 0.5 };
  const startColor = params.start_color ?? { r: 0, g: 0, b: 0, a: 1 };
  const endPoint = params.end_of_ramp ?? { x: 1, y: 0.5 };
  const endColor = params.end_color ?? { r: 255, g: 255, b: 255, a: 1 };
  const rampShape = params.ramp_shape ?? "linear";
  const scatter = (params.ramp_scatter ?? 0) / 100;
  const blend = (params.blend_with_original ?? 0) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  let gradient;
  if (rampShape === "radial") {
    const cx = startPoint.x * width;
    const cy = startPoint.y * height;
    const dx = (endPoint.x - startPoint.x) * width;
    const dy = (endPoint.y - startPoint.y) * height;
    const radius = Math.sqrt(dx * dx + dy * dy);
    gradient = output.ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  } else {
    gradient = output.ctx.createLinearGradient(
      startPoint.x * width,
      startPoint.y * height,
      endPoint.x * width,
      endPoint.y * height
    );
  }
  const startRgba = `rgba(${startColor.r}, ${startColor.g}, ${startColor.b}, ${startColor.a ?? 1})`;
  const endRgba = `rgba(${endColor.r}, ${endColor.g}, ${endColor.b}, ${endColor.a ?? 1})`;
  gradient.addColorStop(0, startRgba);
  gradient.addColorStop(1, endRgba);
  output.ctx.fillStyle = gradient;
  output.ctx.fillRect(0, 0, width, height);
  if (scatter > 0) {
    const outputData = output.ctx.getImageData(0, 0, width, height);
    const dst = outputData.data;
    const scatterAmount = scatter * 25;
    for (let i = 0; i < dst.length; i += 4) {
      const noise = (Math.random() - 0.5) * scatterAmount;
      dst[i] = Math.max(0, Math.min(255, dst[i] + noise));
      dst[i + 1] = Math.max(0, Math.min(255, dst[i + 1] + noise));
      dst[i + 2] = Math.max(0, Math.min(255, dst[i + 2] + noise));
    }
    output.ctx.putImageData(outputData, 0, 0);
  }
  if (blend > 0) {
    output.ctx.globalAlpha = blend;
    output.ctx.drawImage(input.canvas, 0, 0);
    output.ctx.globalAlpha = 1;
  }
  return output;
}
function noise2D(x, y, seed) {
  const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
  return n - Math.floor(n);
}
function smoothNoise(x, y, seed) {
  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const fx = x - x0;
  const fy = y - y0;
  const v00 = noise2D(x0, y0, seed);
  const v10 = noise2D(x0 + 1, y0, seed);
  const v01 = noise2D(x0, y0 + 1, seed);
  const v11 = noise2D(x0 + 1, y0 + 1, seed);
  const sx = fx * fx * (3 - 2 * fx);
  const sy = fy * fy * (3 - 2 * fy);
  return v00 * (1 - sx) * (1 - sy) + v10 * sx * (1 - sy) + v01 * (1 - sx) * sy + v11 * sx * sy;
}
function getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent) {
  const octaveSeed = seed + octave * 100;
  const cached = noiseTileCache.get(width, height, scale, octave, octaveSeed);
  if (cached) {
    return cached;
  }
  const tile = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const sampleX = x / scale * frequency;
      const sampleY = y / scale * frequency;
      let noiseValue = smoothNoise(sampleX, sampleY, octaveSeed);
      if (isTurbulent) {
        noiseValue = Math.abs(noiseValue * 2 - 1);
      }
      tile[y * width + x] = noiseValue;
    }
  }
  noiseTileCache.set(width, height, scale, octave, octaveSeed, tile);
  return tile;
}
function fractalNoiseRenderer(input, params) {
  const fractalType = params.fractal_type ?? "basic";
  const invert = params.invert ?? false;
  const contrast = (params.contrast ?? 100) / 100;
  const brightness = (params.brightness ?? 0) / 100;
  const scale = params.scale ?? 100;
  const complexity = Math.max(1, Math.min(20, params.complexity ?? 6));
  const evolution = (params.evolution ?? 0) * Math.PI / 180;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const outputData = output.ctx.createImageData(width, height);
  const dst = outputData.data;
  const seed = evolution * 1e3;
  const isTurbulent = fractalType.includes("turbulent");
  const octaveTiles = [];
  const amplitudes = [];
  let frequency = 1;
  let amplitude = 1;
  let maxValue = 0;
  for (let octave = 0; octave < complexity; octave++) {
    octaveTiles.push(getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent));
    amplitudes.push(amplitude);
    maxValue += amplitude;
    amplitude *= 0.5;
    frequency *= 2;
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      const pixelIdx = y * width + x;
      for (let octave = 0; octave < complexity; octave++) {
        value += octaveTiles[octave][pixelIdx] * amplitudes[octave];
      }
      value /= maxValue;
      value = (value - 0.5) * contrast + 0.5 + brightness;
      if (invert) {
        value = 1 - value;
      }
      value = Math.max(0, Math.min(1, value));
      const pixelValue = Math.round(value * 255);
      const idx = pixelIdx * 4;
      dst[idx] = pixelValue;
      dst[idx + 1] = pixelValue;
      dst[idx + 2] = pixelValue;
      dst[idx + 3] = 255;
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function registerGenerateEffects() {
  registerEffectRenderer("fill", fillRenderer);
  registerEffectRenderer("gradient-ramp", gradientRampRenderer);
  registerEffectRenderer("fractal-noise", fractalNoiseRenderer);
}

function initializeEffects() {
  registerBlurEffects();
  registerColorEffects();
  registerDistortEffects();
  registerGenerateEffects();
}

let appInstance = null;
function mountApp(container) {
  let el = null;
  if (typeof container === "string") {
    el = document.getElementById(container) || document.querySelector(container);
  } else if (container instanceof HTMLElement) {
    el = container;
  } else {
    el = document.getElementById("weyl-compositor-root") || document.getElementById("app");
  }
  if (!el) return null;
  initializeEffects();
  const app = createApp(_sfc_main);
  app.use(createPinia());
  app.mount(el);
  appInstance = app;
  setupBridge();
  return app;
}
function setupBridge() {
  window.addEventListener("weyl:inputs-ready", (e) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: e.detail }));
  });
}
async function sendToComfyUI(matte, preview) {
  return window.WeylCompositor?.sendOutput?.(matte, preview) ?? false;
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => mountApp());
} else {
  setTimeout(() => {
    if (!appInstance) mountApp();
  }, 0);
}

export { mountApp, sendToComfyUI };
