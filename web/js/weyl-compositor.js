var AS = Object.defineProperty;
var PS = (r, e, n) => e in r ? AS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : r[e] = n;
var pe = (r, e, n) => PS(r, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function bg(r) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of r.split(",")) e[n] = 1;
  return (n) => n in e;
}
const ln = {}, Ya = [], Vs = () => {
}, F_ = () => !1, Vd = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), wg = (r) => r.startsWith("onUpdate:"), mi = Object.assign, Sg = (r, e) => {
  const n = r.indexOf(e);
  n > -1 && r.splice(n, 1);
}, DS = Object.prototype.hasOwnProperty, Zt = (r, e) => DS.call(r, e), St = Array.isArray, qa = (r) => ru(r) === "[object Map]", vl = (r) => ru(r) === "[object Set]", Zv = (r) => ru(r) === "[object Date]", Pt = (r) => typeof r == "function", kn = (r) => typeof r == "string", Cs = (r) => typeof r == "symbol", cn = (r) => r !== null && typeof r == "object", U_ = (r) => (cn(r) || Pt(r)) && Pt(r.then) && Pt(r.catch), z_ = Object.prototype.toString, ru = (r) => z_.call(r), kS = (r) => ru(r).slice(8, -1), B_ = (r) => ru(r) === "[object Object]", Gd = (r) => kn(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, fc = /* @__PURE__ */ bg(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Hd = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = r(n));
}, RS = /-\w/g, is = Hd(
  (r) => r.replace(RS, (e) => e.slice(1).toUpperCase())
), LS = /\B([A-Z])/g, fo = Hd(
  (r) => r.replace(LS, "-$1").toLowerCase()
), Wd = Hd((r) => r.charAt(0).toUpperCase() + r.slice(1)), Of = Hd(
  (r) => r ? `on${Wd(r)}` : ""
), so = (r, e) => !Object.is(r, e), Nh = (r, ...e) => {
  for (let n = 0; n < r.length; n++)
    r[n](...e);
}, N_ = (r, e, n, i = !1) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: n
  });
}, jd = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
};
let Kv;
const $d = () => Kv || (Kv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Ct(r) {
  if (St(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++) {
      const i = r[n], s = kn(i) ? US(i) : Ct(i);
      if (s)
        for (const o in s)
          e[o] = s[o];
    }
    return e;
  } else if (kn(r) || cn(r))
    return r;
}
const IS = /;(?![^(]*\))/g, OS = /:([^]+)/, FS = /\/\*[^]*?\*\//g;
function US(r) {
  const e = {};
  return r.replace(FS, "").split(IS).forEach((n) => {
    if (n) {
      const i = n.split(OS);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Ye(r) {
  let e = "";
  if (kn(r))
    e = r;
  else if (St(r))
    for (let n = 0; n < r.length; n++) {
      const i = Ye(r[n]);
      i && (e += i + " ");
    }
  else if (cn(r))
    for (const n in r)
      r[n] && (e += n + " ");
  return e.trim();
}
const zS = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", BS = /* @__PURE__ */ bg(zS);
function V_(r) {
  return !!r || r === "";
}
function NS(r, e) {
  if (r.length !== e.length) return !1;
  let n = !0;
  for (let i = 0; n && i < r.length; i++)
    n = ou(r[i], e[i]);
  return n;
}
function ou(r, e) {
  if (r === e) return !0;
  let n = Zv(r), i = Zv(e);
  if (n || i)
    return n && i ? r.getTime() === e.getTime() : !1;
  if (n = Cs(r), i = Cs(e), n || i)
    return r === e;
  if (n = St(r), i = St(e), n || i)
    return n && i ? NS(r, e) : !1;
  if (n = cn(r), i = cn(e), n || i) {
    if (!n || !i)
      return !1;
    const s = Object.keys(r).length, o = Object.keys(e).length;
    if (s !== o)
      return !1;
    for (const a in r) {
      const l = r.hasOwnProperty(a), c = e.hasOwnProperty(a);
      if (l && !c || !l && c || !ou(r[a], e[a]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Mg(r, e) {
  return r.findIndex((n) => ou(n, e));
}
const G_ = (r) => !!(r && r.__v_isRef === !0), Ae = (r) => kn(r) ? r : r == null ? "" : St(r) || cn(r) && (r.toString === z_ || !Pt(r.toString)) ? G_(r) ? Ae(r.value) : JSON.stringify(r, H_, 2) : String(r), H_ = (r, e) => G_(e) ? H_(r, e.value) : qa(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [i, s], o) => (n[Ff(i, o) + " =>"] = s, n),
    {}
  )
} : vl(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => Ff(n))
} : Cs(e) ? Ff(e) : cn(e) && !St(e) && !B_(e) ? String(e) : e, Ff = (r, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Cs(r) ? `Symbol(${(n = r.description) != null ? n : e})` : r
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let ci;
class W_ {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = ci, !e && ci && (this.index = (ci.scopes || (ci.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = ci;
      try {
        return ci = this, e();
      } finally {
        ci = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = ci, ci = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (ci = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, i;
      for (n = 0, i = this.effects.length; n < i; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, i = this.scopes.length; n < i; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function j_(r) {
  return new W_(r);
}
function $_() {
  return ci;
}
function VS(r, e = !1) {
  ci && ci.cleanups.push(r);
}
let un;
const Uf = /* @__PURE__ */ new WeakSet();
class X_ {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, ci && ci.active && ci.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Uf.has(this) && (Uf.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || q_(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Jv(this), Z_(this);
    const e = un, n = Ss;
    un = this, Ss = !0;
    try {
      return this.fn();
    } finally {
      K_(this), un = e, Ss = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Eg(e);
      this.deps = this.depsTail = void 0, Jv(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Uf.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Qp(this) && this.run();
  }
  get dirty() {
    return Qp(this);
  }
}
let Y_ = 0, pc, mc;
function q_(r, e = !1) {
  if (r.flags |= 8, e) {
    r.next = mc, mc = r;
    return;
  }
  r.next = pc, pc = r;
}
function Cg() {
  Y_++;
}
function Tg() {
  if (--Y_ > 0)
    return;
  if (mc) {
    let e = mc;
    for (mc = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let r;
  for (; pc; ) {
    let e = pc;
    for (pc = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          r || (r = i);
        }
      e = n;
    }
  }
  if (r) throw r;
}
function Z_(r) {
  for (let e = r.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function K_(r) {
  let e, n = r.depsTail, i = n;
  for (; i; ) {
    const s = i.prevDep;
    i.version === -1 ? (i === n && (n = s), Eg(i), GS(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = s;
  }
  r.deps = e, r.depsTail = n;
}
function Qp(r) {
  for (let e = r.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (J_(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!r._dirty;
}
function J_(r) {
  if (r.flags & 4 && !(r.flags & 16) || (r.flags &= -17, r.globalVersion === Oc) || (r.globalVersion = Oc, !r.isSSR && r.flags & 128 && (!r.deps && !r._dirty || !Qp(r))))
    return;
  r.flags |= 2;
  const e = r.dep, n = un, i = Ss;
  un = r, Ss = !0;
  try {
    Z_(r);
    const s = r.fn(r._value);
    (e.version === 0 || so(s, r._value)) && (r.flags |= 128, r._value = s, e.version++);
  } catch (s) {
    throw e.version++, s;
  } finally {
    un = n, Ss = i, K_(r), r.flags &= -3;
  }
}
function Eg(r, e = !1) {
  const { dep: n, prevSub: i, nextSub: s } = r;
  if (i && (i.nextSub = s, r.prevSub = void 0), s && (s.prevSub = i, r.nextSub = void 0), n.subs === r && (n.subs = i, !i && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      Eg(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function GS(r) {
  const { prevDep: e, nextDep: n } = r;
  e && (e.nextDep = n, r.prevDep = void 0), n && (n.prevDep = e, r.nextDep = void 0);
}
let Ss = !0;
const Q_ = [];
function Sr() {
  Q_.push(Ss), Ss = !1;
}
function Mr() {
  const r = Q_.pop();
  Ss = r === void 0 ? !0 : r;
}
function Jv(r) {
  const { cleanup: e } = r;
  if (r.cleanup = void 0, e) {
    const n = un;
    un = void 0;
    try {
      e();
    } finally {
      un = n;
    }
  }
}
let Oc = 0;
class HS {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Ag {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!un || !Ss || un === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== un)
      n = this.activeLink = new HS(un, this), un.deps ? (n.prevDep = un.depsTail, un.depsTail.nextDep = n, un.depsTail = n) : un.deps = un.depsTail = n, ex(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const i = n.nextDep;
      i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = un.depsTail, n.nextDep = void 0, un.depsTail.nextDep = n, un.depsTail = n, un.deps === n && (un.deps = i);
    }
    return n;
  }
  trigger(e) {
    this.version++, Oc++, this.notify(e);
  }
  notify(e) {
    Cg();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      Tg();
    }
  }
}
function ex(r) {
  if (r.dep.sc++, r.sub.flags & 4) {
    const e = r.dep.computed;
    if (e && !r.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        ex(i);
    }
    const n = r.dep.subs;
    n !== r && (r.prevSub = n, n && (n.nextSub = r)), r.dep.subs = r;
  }
}
const od = /* @__PURE__ */ new WeakMap(), qo = Symbol(
  ""
), em = Symbol(
  ""
), Fc = Symbol(
  ""
);
function hi(r, e, n) {
  if (Ss && un) {
    let i = od.get(r);
    i || od.set(r, i = /* @__PURE__ */ new Map());
    let s = i.get(n);
    s || (i.set(n, s = new Ag()), s.map = i, s.key = n), s.track();
  }
}
function dr(r, e, n, i, s, o) {
  const a = od.get(r);
  if (!a) {
    Oc++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (Cg(), e === "clear")
    a.forEach(l);
  else {
    const c = St(r), u = c && Gd(n);
    if (c && n === "length") {
      const h = Number(i);
      a.forEach((d, p) => {
        (p === "length" || p === Fc || !Cs(p) && p >= h) && l(d);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), u && l(a.get(Fc)), e) {
        case "add":
          c ? u && l(a.get("length")) : (l(a.get(qo)), qa(r) && l(a.get(em)));
          break;
        case "delete":
          c || (l(a.get(qo)), qa(r) && l(a.get(em)));
          break;
        case "set":
          qa(r) && l(a.get(qo));
          break;
      }
  }
  Tg();
}
function WS(r, e) {
  const n = od.get(r);
  return n && n.get(e);
}
function ua(r) {
  const e = Ht(r);
  return e === r ? e : (hi(e, "iterate", Fc), Yi(r) ? e : e.map(Ts));
}
function Xd(r) {
  return hi(r = Ht(r), "iterate", Fc), r;
}
function Jr(r, e) {
  return Cr(r) ? vr(r) ? sl(Ts(e)) : sl(e) : Ts(e);
}
const jS = {
  __proto__: null,
  [Symbol.iterator]() {
    return zf(this, Symbol.iterator, (r) => Jr(this, r));
  },
  concat(...r) {
    return ua(this).concat(
      ...r.map((e) => St(e) ? ua(e) : e)
    );
  },
  entries() {
    return zf(this, "entries", (r) => (r[1] = Jr(this, r[1]), r));
  },
  every(r, e) {
    return Zs(this, "every", r, e, void 0, arguments);
  },
  filter(r, e) {
    return Zs(
      this,
      "filter",
      r,
      e,
      (n) => n.map((i) => Jr(this, i)),
      arguments
    );
  },
  find(r, e) {
    return Zs(
      this,
      "find",
      r,
      e,
      (n) => Jr(this, n),
      arguments
    );
  },
  findIndex(r, e) {
    return Zs(this, "findIndex", r, e, void 0, arguments);
  },
  findLast(r, e) {
    return Zs(
      this,
      "findLast",
      r,
      e,
      (n) => Jr(this, n),
      arguments
    );
  },
  findLastIndex(r, e) {
    return Zs(this, "findLastIndex", r, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(r, e) {
    return Zs(this, "forEach", r, e, void 0, arguments);
  },
  includes(...r) {
    return Bf(this, "includes", r);
  },
  indexOf(...r) {
    return Bf(this, "indexOf", r);
  },
  join(r) {
    return ua(this).join(r);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...r) {
    return Bf(this, "lastIndexOf", r);
  },
  map(r, e) {
    return Zs(this, "map", r, e, void 0, arguments);
  },
  pop() {
    return Bl(this, "pop");
  },
  push(...r) {
    return Bl(this, "push", r);
  },
  reduce(r, ...e) {
    return Qv(this, "reduce", r, e);
  },
  reduceRight(r, ...e) {
    return Qv(this, "reduceRight", r, e);
  },
  shift() {
    return Bl(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(r, e) {
    return Zs(this, "some", r, e, void 0, arguments);
  },
  splice(...r) {
    return Bl(this, "splice", r);
  },
  toReversed() {
    return ua(this).toReversed();
  },
  toSorted(r) {
    return ua(this).toSorted(r);
  },
  toSpliced(...r) {
    return ua(this).toSpliced(...r);
  },
  unshift(...r) {
    return Bl(this, "unshift", r);
  },
  values() {
    return zf(this, "values", (r) => Jr(this, r));
  }
};
function zf(r, e, n) {
  const i = Xd(r), s = i[e]();
  return i !== r && !Yi(r) && (s._next = s.next, s.next = () => {
    const o = s._next();
    return o.done || (o.value = n(o.value)), o;
  }), s;
}
const $S = Array.prototype;
function Zs(r, e, n, i, s, o) {
  const a = Xd(r), l = a !== r && !Yi(r), c = a[e];
  if (c !== $S[e]) {
    const d = c.apply(r, o);
    return l ? Ts(d) : d;
  }
  let u = n;
  a !== r && (l ? u = function(d, p) {
    return n.call(this, Jr(r, d), p, r);
  } : n.length > 2 && (u = function(d, p) {
    return n.call(this, d, p, r);
  }));
  const h = c.call(a, u, i);
  return l && s ? s(h) : h;
}
function Qv(r, e, n, i) {
  const s = Xd(r);
  let o = n;
  return s !== r && (Yi(r) ? n.length > 3 && (o = function(a, l, c) {
    return n.call(this, a, l, c, r);
  }) : o = function(a, l, c) {
    return n.call(this, a, Jr(r, l), c, r);
  }), s[e](o, ...i);
}
function Bf(r, e, n) {
  const i = Ht(r);
  hi(i, "iterate", Fc);
  const s = i[e](...n);
  return (s === -1 || s === !1) && Yd(n[0]) ? (n[0] = Ht(n[0]), i[e](...n)) : s;
}
function Bl(r, e, n = []) {
  Sr(), Cg();
  const i = Ht(r)[e].apply(r, n);
  return Tg(), Mr(), i;
}
const XS = /* @__PURE__ */ bg("__proto__,__v_isRef,__isVue"), tx = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Cs)
);
function YS(r) {
  Cs(r) || (r = String(r));
  const e = Ht(this);
  return hi(e, "has", r), e.hasOwnProperty(r);
}
class nx {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, i) {
    if (n === "__v_skip") return e.__v_skip;
    const s = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !s;
    if (n === "__v_isReadonly")
      return s;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return i === (s ? o ? sM : ox : o ? rx : sx).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const a = St(e);
    if (!s) {
      let c;
      if (a && (c = jS[n]))
        return c;
      if (n === "hasOwnProperty")
        return YS;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Dn(e) ? e : i
    );
    if ((Cs(n) ? tx.has(n) : XS(n)) || (s || hi(e, "get", n), o))
      return l;
    if (Dn(l)) {
      const c = a && Gd(n) ? l : l.value;
      return s && cn(c) ? nm(c) : c;
    }
    return cn(l) ? s ? nm(l) : yl(l) : l;
  }
}
class ix extends nx {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, i, s) {
    let o = e[n];
    const a = St(e) && Gd(n);
    if (!this._isShallow) {
      const u = Cr(o);
      if (!Yi(i) && !Cr(i) && (o = Ht(o), i = Ht(i)), !a && Dn(o) && !Dn(i))
        return u || (o.value = i), !0;
    }
    const l = a ? Number(n) < e.length : Zt(e, n), c = Reflect.set(
      e,
      n,
      i,
      Dn(e) ? e : s
    );
    return e === Ht(s) && (l ? so(i, o) && dr(e, "set", n, i) : dr(e, "add", n, i)), c;
  }
  deleteProperty(e, n) {
    const i = Zt(e, n);
    e[n];
    const s = Reflect.deleteProperty(e, n);
    return s && i && dr(e, "delete", n, void 0), s;
  }
  has(e, n) {
    const i = Reflect.has(e, n);
    return (!Cs(n) || !tx.has(n)) && hi(e, "has", n), i;
  }
  ownKeys(e) {
    return hi(
      e,
      "iterate",
      St(e) ? "length" : qo
    ), Reflect.ownKeys(e);
  }
}
class qS extends nx {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const ZS = /* @__PURE__ */ new ix(), KS = /* @__PURE__ */ new qS(), JS = /* @__PURE__ */ new ix(!0);
const tm = (r) => r, Mu = (r) => Reflect.getPrototypeOf(r);
function QS(r, e, n) {
  return function(...i) {
    const s = this.__v_raw, o = Ht(s), a = qa(o), l = r === "entries" || r === Symbol.iterator && a, c = r === "keys" && a, u = s[r](...i), h = n ? tm : e ? sl : Ts;
    return !e && hi(
      o,
      "iterate",
      c ? em : qo
    ), {
      // iterator protocol
      next() {
        const { value: d, done: p } = u.next();
        return p ? { value: d, done: p } : {
          value: l ? [h(d[0]), h(d[1])] : h(d),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Cu(r) {
  return function(...e) {
    return r === "delete" ? !1 : r === "clear" ? void 0 : this;
  };
}
function eM(r, e) {
  const n = {
    get(s) {
      const o = this.__v_raw, a = Ht(o), l = Ht(s);
      r || (so(s, l) && hi(a, "get", s), hi(a, "get", l));
      const { has: c } = Mu(a), u = e ? tm : r ? sl : Ts;
      if (c.call(a, s))
        return u(o.get(s));
      if (c.call(a, l))
        return u(o.get(l));
      o !== a && o.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !r && hi(Ht(s), "iterate", qo), s.size;
    },
    has(s) {
      const o = this.__v_raw, a = Ht(o), l = Ht(s);
      return r || (so(s, l) && hi(a, "has", s), hi(a, "has", l)), s === l ? o.has(s) : o.has(s) || o.has(l);
    },
    forEach(s, o) {
      const a = this, l = a.__v_raw, c = Ht(l), u = e ? tm : r ? sl : Ts;
      return !r && hi(c, "iterate", qo), l.forEach((h, d) => s.call(o, u(h), u(d), a));
    }
  };
  return mi(
    n,
    r ? {
      add: Cu("add"),
      set: Cu("set"),
      delete: Cu("delete"),
      clear: Cu("clear")
    } : {
      add(s) {
        !e && !Yi(s) && !Cr(s) && (s = Ht(s));
        const o = Ht(this);
        return Mu(o).has.call(o, s) || (o.add(s), dr(o, "add", s, s)), this;
      },
      set(s, o) {
        !e && !Yi(o) && !Cr(o) && (o = Ht(o));
        const a = Ht(this), { has: l, get: c } = Mu(a);
        let u = l.call(a, s);
        u || (s = Ht(s), u = l.call(a, s));
        const h = c.call(a, s);
        return a.set(s, o), u ? so(o, h) && dr(a, "set", s, o) : dr(a, "add", s, o), this;
      },
      delete(s) {
        const o = Ht(this), { has: a, get: l } = Mu(o);
        let c = a.call(o, s);
        c || (s = Ht(s), c = a.call(o, s)), l && l.call(o, s);
        const u = o.delete(s);
        return c && dr(o, "delete", s, void 0), u;
      },
      clear() {
        const s = Ht(this), o = s.size !== 0, a = s.clear();
        return o && dr(
          s,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((s) => {
    n[s] = QS(s, r, e);
  }), n;
}
function Pg(r, e) {
  const n = eM(r, e);
  return (i, s, o) => s === "__v_isReactive" ? !r : s === "__v_isReadonly" ? r : s === "__v_raw" ? i : Reflect.get(
    Zt(n, s) && s in i ? n : i,
    s,
    o
  );
}
const tM = {
  get: /* @__PURE__ */ Pg(!1, !1)
}, nM = {
  get: /* @__PURE__ */ Pg(!1, !0)
}, iM = {
  get: /* @__PURE__ */ Pg(!0, !1)
};
const sx = /* @__PURE__ */ new WeakMap(), rx = /* @__PURE__ */ new WeakMap(), ox = /* @__PURE__ */ new WeakMap(), sM = /* @__PURE__ */ new WeakMap();
function rM(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function oM(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : rM(kS(r));
}
function yl(r) {
  return Cr(r) ? r : Dg(
    r,
    !1,
    ZS,
    tM,
    sx
  );
}
function aM(r) {
  return Dg(
    r,
    !1,
    JS,
    nM,
    rx
  );
}
function nm(r) {
  return Dg(
    r,
    !0,
    KS,
    iM,
    ox
  );
}
function Dg(r, e, n, i, s) {
  if (!cn(r) || r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const o = oM(r);
  if (o === 0)
    return r;
  const a = s.get(r);
  if (a)
    return a;
  const l = new Proxy(
    r,
    o === 2 ? i : n
  );
  return s.set(r, l), l;
}
function vr(r) {
  return Cr(r) ? vr(r.__v_raw) : !!(r && r.__v_isReactive);
}
function Cr(r) {
  return !!(r && r.__v_isReadonly);
}
function Yi(r) {
  return !!(r && r.__v_isShallow);
}
function Yd(r) {
  return r ? !!r.__v_raw : !1;
}
function Ht(r) {
  const e = r && r.__v_raw;
  return e ? Ht(e) : r;
}
function cr(r) {
  return !Zt(r, "__v_skip") && Object.isExtensible(r) && N_(r, "__v_skip", !0), r;
}
const Ts = (r) => cn(r) ? yl(r) : r, sl = (r) => cn(r) ? nm(r) : r;
function Dn(r) {
  return r ? r.__v_isRef === !0 : !1;
}
function Ce(r) {
  return ax(r, !1);
}
function lM(r) {
  return ax(r, !0);
}
function ax(r, e) {
  return Dn(r) ? r : new cM(r, e);
}
class cM {
  constructor(e, n) {
    this.dep = new Ag(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : Ht(e), this._value = n ? e : Ts(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, i = this.__v_isShallow || Yi(e) || Cr(e);
    e = i ? e : Ht(e), so(e, n) && (this._rawValue = e, this._value = i ? e : Ts(e), this.dep.trigger());
  }
}
function Je(r) {
  return Dn(r) ? r.value : r;
}
const uM = {
  get: (r, e, n) => e === "__v_raw" ? r : Je(Reflect.get(r, e, n)),
  set: (r, e, n, i) => {
    const s = r[e];
    return Dn(s) && !Dn(n) ? (s.value = n, !0) : Reflect.set(r, e, n, i);
  }
};
function lx(r) {
  return vr(r) ? r : new Proxy(r, uM);
}
function hM(r) {
  const e = St(r) ? new Array(r.length) : {};
  for (const n in r)
    e[n] = fM(r, n);
  return e;
}
class dM {
  constructor(e, n, i) {
    this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0, this._raw = Ht(e);
    let s = !0, o = e;
    if (!St(e) || !Gd(String(n)))
      do
        s = !Yd(o) || Yi(o);
      while (s && (o = o.__v_raw));
    this._shallow = s;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = Je(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && Dn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (Dn(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return WS(this._raw, this._key);
  }
}
function fM(r, e, n) {
  return new dM(r, e, n);
}
class pM {
  constructor(e, n, i) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new Ag(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Oc - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    un !== this)
      return q_(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return J_(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function mM(r, e, n = !1) {
  let i, s;
  return Pt(r) ? i = r : (i = r.get, s = r.set), new pM(i, s, n);
}
const Tu = {}, ad = /* @__PURE__ */ new WeakMap();
let ko;
function gM(r, e = !1, n = ko) {
  if (n) {
    let i = ad.get(n);
    i || ad.set(n, i = []), i.push(r);
  }
}
function vM(r, e, n = ln) {
  const { immediate: i, deep: s, once: o, scheduler: a, augmentJob: l, call: c } = n, u = (x) => s ? x : Yi(x) || s === !1 || s === 0 ? fr(x, 1) : fr(x);
  let h, d, p, f, m = !1, _ = !1;
  if (Dn(r) ? (d = () => r.value, m = Yi(r)) : vr(r) ? (d = () => u(r), m = !0) : St(r) ? (_ = !0, m = r.some((x) => vr(x) || Yi(x)), d = () => r.map((x) => {
    if (Dn(x))
      return x.value;
    if (vr(x))
      return u(x);
    if (Pt(x))
      return c ? c(x, 2) : x();
  })) : Pt(r) ? e ? d = c ? () => c(r, 2) : r : d = () => {
    if (p) {
      Sr();
      try {
        p();
      } finally {
        Mr();
      }
    }
    const x = ko;
    ko = h;
    try {
      return c ? c(r, 3, [f]) : r(f);
    } finally {
      ko = x;
    }
  } : d = Vs, e && s) {
    const x = d, M = s === !0 ? 1 / 0 : s;
    d = () => fr(x(), M);
  }
  const g = $_(), v = () => {
    h.stop(), g && g.active && Sg(g.effects, h);
  };
  if (o && e) {
    const x = e;
    e = (...M) => {
      x(...M), v();
    };
  }
  let S = _ ? new Array(r.length).fill(Tu) : Tu;
  const b = (x) => {
    if (!(!(h.flags & 1) || !h.dirty && !x))
      if (e) {
        const M = h.run();
        if (s || m || (_ ? M.some((C, E) => so(C, S[E])) : so(M, S))) {
          p && p();
          const C = ko;
          ko = h;
          try {
            const E = [
              M,
              // pass undefined as the old value when it's changed for the first time
              S === Tu ? void 0 : _ && S[0] === Tu ? [] : S,
              f
            ];
            S = M, c ? c(e, 3, E) : (
              // @ts-expect-error
              e(...E)
            );
          } finally {
            ko = C;
          }
        }
      } else
        h.run();
  };
  return l && l(b), h = new X_(d), h.scheduler = a ? () => a(b, !1) : b, f = (x) => gM(x, !1, h), p = h.onStop = () => {
    const x = ad.get(h);
    if (x) {
      if (c)
        c(x, 4);
      else
        for (const M of x) M();
      ad.delete(h);
    }
  }, e ? i ? b(!0) : S = h.run() : a ? a(b.bind(null, !0), !0) : h.run(), v.pause = h.pause.bind(h), v.resume = h.resume.bind(h), v.stop = v, v;
}
function fr(r, e = 1 / 0, n) {
  if (e <= 0 || !cn(r) || r.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(r) || 0) >= e))
    return r;
  if (n.set(r, e), e--, Dn(r))
    fr(r.value, e, n);
  else if (St(r))
    for (let i = 0; i < r.length; i++)
      fr(r[i], e, n);
  else if (vl(r) || qa(r))
    r.forEach((i) => {
      fr(i, e, n);
    });
  else if (B_(r)) {
    for (const i in r)
      fr(r[i], e, n);
    for (const i of Object.getOwnPropertySymbols(r))
      Object.prototype.propertyIsEnumerable.call(r, i) && fr(r[i], e, n);
  }
  return r;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function au(r, e, n, i) {
  try {
    return i ? r(...i) : r();
  } catch (s) {
    qd(s, e, n);
  }
}
function Ws(r, e, n, i) {
  if (Pt(r)) {
    const s = au(r, e, n, i);
    return s && U_(s) && s.catch((o) => {
      qd(o, e, n);
    }), s;
  }
  if (St(r)) {
    const s = [];
    for (let o = 0; o < r.length; o++)
      s.push(Ws(r[o], e, n, i));
    return s;
  }
}
function qd(r, e, n, i = !0) {
  const s = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || ln;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const h = l.ec;
      if (h) {
        for (let d = 0; d < h.length; d++)
          if (h[d](r, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      Sr(), au(o, null, 10, [
        r,
        c,
        u
      ]), Mr();
      return;
    }
  }
  yM(r, n, s, i, a);
}
function yM(r, e, n, i = !0, s = !1) {
  if (s)
    throw r;
  console.error(r);
}
const bi = [];
let Os = -1;
const Za = [];
let Qr = null, La = 0;
const cx = /* @__PURE__ */ Promise.resolve();
let ld = null;
function Gs(r) {
  const e = ld || cx;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function _M(r) {
  let e = Os + 1, n = bi.length;
  for (; e < n; ) {
    const i = e + n >>> 1, s = bi[i], o = Uc(s);
    o < r || o === r && s.flags & 2 ? e = i + 1 : n = i;
  }
  return e;
}
function kg(r) {
  if (!(r.flags & 1)) {
    const e = Uc(r), n = bi[bi.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(r.flags & 2) && e >= Uc(n) ? bi.push(r) : bi.splice(_M(e), 0, r), r.flags |= 1, ux();
  }
}
function ux() {
  ld || (ld = cx.then(dx));
}
function xM(r) {
  St(r) ? Za.push(...r) : Qr && r.id === -1 ? Qr.splice(La + 1, 0, r) : r.flags & 1 || (Za.push(r), r.flags |= 1), ux();
}
function e0(r, e, n = Os + 1) {
  for (; n < bi.length; n++) {
    const i = bi[n];
    if (i && i.flags & 2) {
      if (r && i.id !== r.uid)
        continue;
      bi.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function hx(r) {
  if (Za.length) {
    const e = [...new Set(Za)].sort(
      (n, i) => Uc(n) - Uc(i)
    );
    if (Za.length = 0, Qr) {
      Qr.push(...e);
      return;
    }
    for (Qr = e, La = 0; La < Qr.length; La++) {
      const n = Qr[La];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    Qr = null, La = 0;
  }
}
const Uc = (r) => r.id == null ? r.flags & 2 ? -1 : 1 / 0 : r.id;
function dx(r) {
  try {
    for (Os = 0; Os < bi.length; Os++) {
      const e = bi[Os];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), au(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; Os < bi.length; Os++) {
      const e = bi[Os];
      e && (e.flags &= -2);
    }
    Os = -1, bi.length = 0, hx(), ld = null, (bi.length || Za.length) && dx();
  }
}
let ti = null, fx = null;
function cd(r) {
  const e = ti;
  return ti = r, fx = r && r.type.__scopeId || null, e;
}
function fs(r, e = ti, n) {
  if (!e || r._n)
    return r;
  const i = (...s) => {
    i._d && dd(-1);
    const o = cd(e);
    let a;
    try {
      a = r(...s);
    } finally {
      cd(o), i._d && dd(1);
    }
    return a;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function wt(r, e) {
  if (ti === null)
    return r;
  const n = ef(ti), i = r.dirs || (r.dirs = []);
  for (let s = 0; s < e.length; s++) {
    let [o, a, l, c = ln] = e[s];
    o && (Pt(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && fr(a), i.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return r;
}
function vo(r, e, n, i) {
  const s = r.dirs, o = e && e.dirs;
  for (let a = 0; a < s.length; a++) {
    const l = s[a];
    o && (l.oldValue = o[a].value);
    let c = l.dir[i];
    c && (Sr(), Ws(c, n, 8, [
      r.el,
      l,
      r,
      e
    ]), Mr());
  }
}
const px = Symbol("_vte"), bM = (r) => r.__isTeleport, gc = (r) => r && (r.disabled || r.disabled === ""), t0 = (r) => r && (r.defer || r.defer === ""), n0 = (r) => typeof SVGElement < "u" && r instanceof SVGElement, i0 = (r) => typeof MathMLElement == "function" && r instanceof MathMLElement, im = (r, e) => {
  const n = r && r.to;
  return kn(n) ? e ? e(n) : null : n;
}, mx = {
  name: "Teleport",
  __isTeleport: !0,
  process(r, e, n, i, s, o, a, l, c, u) {
    const {
      mc: h,
      pc: d,
      pbc: p,
      o: { insert: f, querySelector: m, createText: _, createComment: g }
    } = u, v = gc(e.props);
    let { shapeFlag: S, children: b, dynamicChildren: x } = e;
    if (r == null) {
      const M = e.el = _(""), C = e.anchor = _("");
      f(M, n, i), f(C, n, i);
      const E = (w, A) => {
        S & 16 && h(
          b,
          w,
          A,
          s,
          o,
          a,
          l,
          c
        );
      }, T = () => {
        const w = e.target = im(e.props, m), A = gx(w, e, _, f);
        w && (a !== "svg" && n0(w) ? a = "svg" : a !== "mathml" && i0(w) && (a = "mathml"), s && s.isCE && (s.ce._teleportTargets || (s.ce._teleportTargets = /* @__PURE__ */ new Set())).add(w), v || (E(w, A), Vh(e, !1)));
      };
      v && (E(n, C), Vh(e, !0)), t0(e.props) ? (e.el.__isMounted = !1, _i(() => {
        T(), delete e.el.__isMounted;
      }, o)) : T();
    } else {
      if (t0(e.props) && r.el.__isMounted === !1) {
        _i(() => {
          mx.process(
            r,
            e,
            n,
            i,
            s,
            o,
            a,
            l,
            c,
            u
          );
        }, o);
        return;
      }
      e.el = r.el, e.targetStart = r.targetStart;
      const M = e.anchor = r.anchor, C = e.target = r.target, E = e.targetAnchor = r.targetAnchor, T = gc(r.props), w = T ? n : C, A = T ? M : E;
      if (a === "svg" || n0(C) ? a = "svg" : (a === "mathml" || i0(C)) && (a = "mathml"), x ? (p(
        r.dynamicChildren,
        x,
        w,
        s,
        o,
        a,
        l
      ), Fg(r, e, !0)) : c || d(
        r,
        e,
        w,
        A,
        s,
        o,
        a,
        l,
        !1
      ), v)
        T ? e.props && r.props && e.props.to !== r.props.to && (e.props.to = r.props.to) : Eu(
          e,
          n,
          M,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const O = e.target = im(
          e.props,
          m
        );
        O && Eu(
          e,
          O,
          null,
          u,
          0
        );
      } else T && Eu(
        e,
        C,
        E,
        u,
        1
      );
      Vh(e, v);
    }
  },
  remove(r, e, n, { um: i, o: { remove: s } }, o) {
    const {
      shapeFlag: a,
      children: l,
      anchor: c,
      targetStart: u,
      targetAnchor: h,
      target: d,
      props: p
    } = r;
    if (d && (s(u), s(h)), o && s(c), a & 16) {
      const f = o || !gc(p);
      for (let m = 0; m < l.length; m++) {
        const _ = l[m];
        i(
          _,
          e,
          n,
          f,
          !!_.dynamicChildren
        );
      }
    }
  },
  move: Eu,
  hydrate: wM
};
function Eu(r, e, n, { o: { insert: i }, m: s }, o = 2) {
  o === 0 && i(r.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: c, children: u, props: h } = r, d = o === 2;
  if (d && i(a, e, n), (!d || gc(h)) && c & 16)
    for (let p = 0; p < u.length; p++)
      s(
        u[p],
        e,
        n,
        2
      );
  d && i(l, e, n);
}
function wM(r, e, n, i, s, o, {
  o: { nextSibling: a, parentNode: l, querySelector: c, insert: u, createText: h }
}, d) {
  function p(_, g, v, S) {
    g.anchor = d(
      a(_),
      g,
      l(_),
      n,
      i,
      s,
      o
    ), g.targetStart = v, g.targetAnchor = S;
  }
  const f = e.target = im(
    e.props,
    c
  ), m = gc(e.props);
  if (f) {
    const _ = f._lpa || f.firstChild;
    if (e.shapeFlag & 16)
      if (m)
        p(
          r,
          e,
          _,
          _ && a(_)
        );
      else {
        e.anchor = a(r);
        let g = _;
        for (; g; ) {
          if (g && g.nodeType === 8) {
            if (g.data === "teleport start anchor")
              e.targetStart = g;
            else if (g.data === "teleport anchor") {
              e.targetAnchor = g, f._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          g = a(g);
        }
        e.targetAnchor || gx(f, e, h, u), d(
          _ && a(_),
          e,
          f,
          n,
          i,
          s,
          o
        );
      }
    Vh(e, m);
  } else m && e.shapeFlag & 16 && p(r, e, r, a(r));
  return e.anchor && a(e.anchor);
}
const sm = mx;
function Vh(r, e) {
  const n = r.ctx;
  if (n && n.ut) {
    let i, s;
    for (e ? (i = r.el, s = r.anchor) : (i = r.targetStart, s = r.targetAnchor); i && i !== s; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", n.uid), i = i.nextSibling;
    n.ut();
  }
}
function gx(r, e, n, i) {
  const s = e.targetStart = n(""), o = e.targetAnchor = n("");
  return s[px] = o, r && (i(s, r), i(o, r)), o;
}
const SM = Symbol("_leaveCb");
function Rg(r, e) {
  r.shapeFlag & 6 && r.component ? (r.transition = e, Rg(r.component.subTree, e)) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
// @__NO_SIDE_EFFECTS__
function jt(r, e) {
  return Pt(r) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    mi({ name: r.name }, e, { setup: r })
  ) : r;
}
function vx(r) {
  r.ids = [r.ids[0] + r.ids[2]++ + "-", 0, 0];
}
const ud = /* @__PURE__ */ new WeakMap();
function vc(r, e, n, i, s = !1) {
  if (St(r)) {
    r.forEach(
      (m, _) => vc(
        m,
        e && (St(e) ? e[_] : e),
        n,
        i,
        s
      )
    );
    return;
  }
  if (Ka(i) && !s) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && vc(r, e, n, i.component.subTree);
    return;
  }
  const o = i.shapeFlag & 4 ? ef(i.component) : i.el, a = s ? null : o, { i: l, r: c } = r, u = e && e.r, h = l.refs === ln ? l.refs = {} : l.refs, d = l.setupState, p = Ht(d), f = d === ln ? F_ : (m) => Zt(p, m);
  if (u != null && u !== c) {
    if (s0(e), kn(u))
      h[u] = null, f(u) && (d[u] = null);
    else if (Dn(u)) {
      u.value = null;
      const m = e;
      m.k && (h[m.k] = null);
    }
  }
  if (Pt(c))
    au(c, l, 12, [a, h]);
  else {
    const m = kn(c), _ = Dn(c);
    if (m || _) {
      const g = () => {
        if (r.f) {
          const v = m ? f(c) ? d[c] : h[c] : c.value;
          if (s)
            St(v) && Sg(v, o);
          else if (St(v))
            v.includes(o) || v.push(o);
          else if (m)
            h[c] = [o], f(c) && (d[c] = h[c]);
          else {
            const S = [o];
            c.value = S, r.k && (h[r.k] = S);
          }
        } else m ? (h[c] = a, f(c) && (d[c] = a)) : _ && (c.value = a, r.k && (h[r.k] = a));
      };
      if (a) {
        const v = () => {
          g(), ud.delete(r);
        };
        v.id = -1, ud.set(r, v), _i(v, n);
      } else
        s0(r), g();
    }
  }
}
function s0(r) {
  const e = ud.get(r);
  e && (e.flags |= 8, ud.delete(r));
}
$d().requestIdleCallback;
$d().cancelIdleCallback;
const Ka = (r) => !!r.type.__asyncLoader, yx = (r) => r.type.__isKeepAlive;
function MM(r, e) {
  _x(r, "a", e);
}
function CM(r, e) {
  _x(r, "da", e);
}
function _x(r, e, n = di) {
  const i = r.__wdc || (r.__wdc = () => {
    let s = n;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return r();
  });
  if (Zd(e, i, n), n) {
    let s = n.parent;
    for (; s && s.parent; )
      yx(s.parent.vnode) && TM(i, e, n, s), s = s.parent;
  }
}
function TM(r, e, n, i) {
  const s = Zd(
    e,
    r,
    i,
    !0
    /* prepend */
  );
  Ni(() => {
    Sg(i[e], s);
  }, n);
}
function Zd(r, e, n = di, i = !1) {
  if (n) {
    const s = n[r] || (n[r] = []), o = e.__weh || (e.__weh = (...a) => {
      Sr();
      const l = lu(n), c = Ws(e, n, r, a);
      return l(), Mr(), c;
    });
    return i ? s.unshift(o) : s.push(o), o;
  }
}
const kr = (r) => (e, n = di) => {
  (!Nc || r === "sp") && Zd(r, (...i) => e(...i), n);
}, EM = kr("bm"), Xn = kr("m"), AM = kr(
  "bu"
), PM = kr("u"), Lg = kr(
  "bum"
), Ni = kr("um"), DM = kr(
  "sp"
), kM = kr("rtg"), RM = kr("rtc");
function LM(r, e = di) {
  Zd("ec", r, e);
}
const IM = "components", xx = Symbol.for("v-ndc");
function bx(r) {
  return kn(r) ? OM(IM, r, !1) || r : r || xx;
}
function OM(r, e, n = !0, i = !1) {
  const s = ti || di;
  if (s) {
    const o = s.type;
    {
      const l = CC(
        o,
        !1
      );
      if (l && (l === e || l === is(e) || l === Wd(is(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      r0(s[r] || o[r], e) || // global registration
      r0(s.appContext[r], e)
    );
    return !a && i ? o : a;
  }
}
function r0(r, e) {
  return r && (r[e] || r[is(e)] || r[Wd(is(e))]);
}
function pt(r, e, n, i) {
  let s;
  const o = n, a = St(r);
  if (a || kn(r)) {
    const l = a && vr(r);
    let c = !1, u = !1;
    l && (c = !Yi(r), u = Cr(r), r = Xd(r)), s = new Array(r.length);
    for (let h = 0, d = r.length; h < d; h++)
      s[h] = e(
        c ? u ? sl(Ts(r[h])) : Ts(r[h]) : r[h],
        h,
        void 0,
        o
      );
  } else if (typeof r == "number") {
    s = new Array(r);
    for (let l = 0; l < r; l++)
      s[l] = e(l + 1, l, void 0, o);
  } else if (cn(r))
    if (r[Symbol.iterator])
      s = Array.from(
        r,
        (l, c) => e(l, c, void 0, o)
      );
    else {
      const l = Object.keys(r);
      s = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const h = l[c];
        s[c] = e(r[h], h, c, o);
      }
    }
  else
    s = [];
  return s;
}
function FM(r, e, n = {}, i, s) {
  if (ti.ce || ti.parent && Ka(ti.parent) && ti.parent.ce) {
    const u = Object.keys(n).length > 0;
    return ie(), Et(
      nt,
      null,
      [Ze("slot", n, i)],
      u ? -2 : 64
    );
  }
  let o = r[e];
  o && o._c && (o._d = !1), ie();
  const a = o && wx(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, c = Et(
    nt,
    {
      key: (l && !Cs(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && i ? "_fb" : "")
    },
    a || [],
    a && r._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), o && o._c && (o._d = !0), c;
}
function wx(r) {
  return r.some((e) => Bc(e) ? !(e.type === Tr || e.type === nt && !wx(e.children)) : !0) ? r : null;
}
const rm = (r) => r ? Vx(r) ? ef(r) : rm(r.parent) : null, yc = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ mi(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => r.props,
    $attrs: (r) => r.attrs,
    $slots: (r) => r.slots,
    $refs: (r) => r.refs,
    $parent: (r) => rm(r.parent),
    $root: (r) => rm(r.root),
    $host: (r) => r.ce,
    $emit: (r) => r.emit,
    $options: (r) => Mx(r),
    $forceUpdate: (r) => r.f || (r.f = () => {
      kg(r.update);
    }),
    $nextTick: (r) => r.n || (r.n = Gs.bind(r.proxy)),
    $watch: (r) => ZM.bind(r)
  })
), Nf = (r, e) => r !== ln && !r.__isScriptSetup && Zt(r, e), UM = {
  get({ _: r }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: i, data: s, props: o, accessCache: a, type: l, appContext: c } = r;
    if (e[0] !== "$") {
      const p = a[e];
      if (p !== void 0)
        switch (p) {
          case 1:
            return i[e];
          case 2:
            return s[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (Nf(i, e))
          return a[e] = 1, i[e];
        if (s !== ln && Zt(s, e))
          return a[e] = 2, s[e];
        if (Zt(o, e))
          return a[e] = 3, o[e];
        if (n !== ln && Zt(n, e))
          return a[e] = 4, n[e];
        om && (a[e] = 0);
      }
    }
    const u = yc[e];
    let h, d;
    if (u)
      return e === "$attrs" && hi(r.attrs, "get", ""), u(r);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[e])
    )
      return h;
    if (n !== ln && Zt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      d = c.config.globalProperties, Zt(d, e)
    )
      return d[e];
  },
  set({ _: r }, e, n) {
    const { data: i, setupState: s, ctx: o } = r;
    return Nf(s, e) ? (s[e] = n, !0) : i !== ln && Zt(i, e) ? (i[e] = n, !0) : Zt(r.props, e) || e[0] === "$" && e.slice(1) in r ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: n, ctx: i, appContext: s, props: o, type: a }
  }, l) {
    let c;
    return !!(n[l] || r !== ln && l[0] !== "$" && Zt(r, l) || Nf(e, l) || Zt(o, l) || Zt(i, l) || Zt(yc, l) || Zt(s.config.globalProperties, l) || (c = a.__cssModules) && c[l]);
  },
  defineProperty(r, e, n) {
    return n.get != null ? r._.accessCache[e] = 0 : Zt(n, "value") && this.set(r, e, n.value, null), Reflect.defineProperty(r, e, n);
  }
};
function zM() {
  return BM().slots;
}
function BM(r) {
  const e = Qd();
  return e.setupContext || (e.setupContext = Hx(e));
}
function o0(r) {
  return St(r) ? r.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : r;
}
let om = !0;
function NM(r) {
  const e = Mx(r), n = r.proxy, i = r.ctx;
  om = !1, e.beforeCreate && a0(e.beforeCreate, r, "bc");
  const {
    // state
    data: s,
    computed: o,
    methods: a,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: h,
    beforeMount: d,
    mounted: p,
    beforeUpdate: f,
    updated: m,
    activated: _,
    deactivated: g,
    beforeDestroy: v,
    beforeUnmount: S,
    destroyed: b,
    unmounted: x,
    render: M,
    renderTracked: C,
    renderTriggered: E,
    errorCaptured: T,
    serverPrefetch: w,
    // public API
    expose: A,
    inheritAttrs: O,
    // assets
    components: U,
    directives: D,
    filters: L
  } = e;
  if (u && VM(u, i, null), a)
    for (const ce in a) {
      const q = a[ce];
      Pt(q) && (i[ce] = q.bind(n));
    }
  if (s) {
    const ce = s.call(n, n);
    cn(ce) && (r.data = yl(ce));
  }
  if (om = !0, o)
    for (const ce in o) {
      const q = o[ce], oe = Pt(q) ? q.bind(n, n) : Pt(q.get) ? q.get.bind(n, n) : Vs, ne = !Pt(q) && Pt(q.set) ? q.set.bind(n) : Vs, $ = Xe({
        get: oe,
        set: ne
      });
      Object.defineProperty(i, ce, {
        enumerable: !0,
        configurable: !0,
        get: () => $.value,
        set: (J) => $.value = J
      });
    }
  if (l)
    for (const ce in l)
      Sx(l[ce], i, n, ce);
  if (c) {
    const ce = Pt(c) ? c.call(n) : c;
    Reflect.ownKeys(ce).forEach((q) => {
      Zr(q, ce[q]);
    });
  }
  h && a0(h, r, "c");
  function V(ce, q) {
    St(q) ? q.forEach((oe) => ce(oe.bind(n))) : q && ce(q.bind(n));
  }
  if (V(EM, d), V(Xn, p), V(AM, f), V(PM, m), V(MM, _), V(CM, g), V(LM, T), V(RM, C), V(kM, E), V(Lg, S), V(Ni, x), V(DM, w), St(A))
    if (A.length) {
      const ce = r.exposed || (r.exposed = {});
      A.forEach((q) => {
        Object.defineProperty(ce, q, {
          get: () => n[q],
          set: (oe) => n[q] = oe,
          enumerable: !0
        });
      });
    } else r.exposed || (r.exposed = {});
  M && r.render === Vs && (r.render = M), O != null && (r.inheritAttrs = O), U && (r.components = U), D && (r.directives = D), w && vx(r);
}
function VM(r, e, n = Vs) {
  St(r) && (r = am(r));
  for (const i in r) {
    const s = r[i];
    let o;
    cn(s) ? "default" in s ? o = gs(
      s.from || i,
      s.default,
      !0
    ) : o = gs(s.from || i) : o = gs(s), Dn(o) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[i] = o;
  }
}
function a0(r, e, n) {
  Ws(
    St(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy),
    e,
    n
  );
}
function Sx(r, e, n, i) {
  let s = i.includes(".") ? Ex(n, i) : () => n[i];
  if (kn(r)) {
    const o = e[r];
    Pt(o) && At(s, o);
  } else if (Pt(r))
    At(s, r.bind(n));
  else if (cn(r))
    if (St(r))
      r.forEach((o) => Sx(o, e, n, i));
    else {
      const o = Pt(r.handler) ? r.handler.bind(n) : e[r.handler];
      Pt(o) && At(s, o, r);
    }
}
function Mx(r) {
  const e = r.type, { mixins: n, extends: i } = e, {
    mixins: s,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = r.appContext, l = o.get(e);
  let c;
  return l ? c = l : !s.length && !n && !i ? c = e : (c = {}, s.length && s.forEach(
    (u) => hd(c, u, a, !0)
  ), hd(c, e, a)), cn(e) && o.set(e, c), c;
}
function hd(r, e, n, i = !1) {
  const { mixins: s, extends: o } = e;
  o && hd(r, o, n, !0), s && s.forEach(
    (a) => hd(r, a, n, !0)
  );
  for (const a in e)
    if (!(i && a === "expose")) {
      const l = GM[a] || n && n[a];
      r[a] = l ? l(r[a], e[a]) : e[a];
    }
  return r;
}
const GM = {
  data: l0,
  props: c0,
  emits: c0,
  // objects
  methods: oc,
  computed: oc,
  // lifecycle
  beforeCreate: gi,
  created: gi,
  beforeMount: gi,
  mounted: gi,
  beforeUpdate: gi,
  updated: gi,
  beforeDestroy: gi,
  beforeUnmount: gi,
  destroyed: gi,
  unmounted: gi,
  activated: gi,
  deactivated: gi,
  errorCaptured: gi,
  serverPrefetch: gi,
  // assets
  components: oc,
  directives: oc,
  // watch
  watch: WM,
  // provide / inject
  provide: l0,
  inject: HM
};
function l0(r, e) {
  return e ? r ? function() {
    return mi(
      Pt(r) ? r.call(this, this) : r,
      Pt(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function HM(r, e) {
  return oc(am(r), am(e));
}
function am(r) {
  if (St(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++)
      e[r[n]] = r[n];
    return e;
  }
  return r;
}
function gi(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function oc(r, e) {
  return r ? mi(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function c0(r, e) {
  return r ? St(r) && St(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : mi(
    /* @__PURE__ */ Object.create(null),
    o0(r),
    o0(e ?? {})
  ) : e;
}
function WM(r, e) {
  if (!r) return e;
  if (!e) return r;
  const n = mi(/* @__PURE__ */ Object.create(null), r);
  for (const i in e)
    n[i] = gi(r[i], e[i]);
  return n;
}
function Cx() {
  return {
    app: null,
    config: {
      isNativeTag: F_,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let jM = 0;
function $M(r, e) {
  return function(i, s = null) {
    Pt(i) || (i = mi({}, i)), s != null && !cn(s) && (s = null);
    const o = Cx(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = o.app = {
      _uid: jM++,
      _component: i,
      _props: s,
      _container: null,
      _context: o,
      _instance: null,
      version: AC,
      get config() {
        return o.config;
      },
      set config(h) {
      },
      use(h, ...d) {
        return a.has(h) || (h && Pt(h.install) ? (a.add(h), h.install(u, ...d)) : Pt(h) && (a.add(h), h(u, ...d))), u;
      },
      mixin(h) {
        return o.mixins.includes(h) || o.mixins.push(h), u;
      },
      component(h, d) {
        return d ? (o.components[h] = d, u) : o.components[h];
      },
      directive(h, d) {
        return d ? (o.directives[h] = d, u) : o.directives[h];
      },
      mount(h, d, p) {
        if (!c) {
          const f = u._ceVNode || Ze(i, s);
          return f.appContext = o, p === !0 ? p = "svg" : p === !1 && (p = void 0), r(f, h, p), c = !0, u._container = h, h.__vue_app__ = u, ef(f.component);
        }
      },
      onUnmount(h) {
        l.push(h);
      },
      unmount() {
        c && (Ws(
          l,
          u._instance,
          16
        ), r(null, u._container), delete u._container.__vue_app__);
      },
      provide(h, d) {
        return o.provides[h] = d, u;
      },
      runWithContext(h) {
        const d = Zo;
        Zo = u;
        try {
          return h();
        } finally {
          Zo = d;
        }
      }
    };
    return u;
  };
}
let Zo = null;
function Zr(r, e) {
  if (di) {
    let n = di.provides;
    const i = di.parent && di.parent.provides;
    i === n && (n = di.provides = Object.create(i)), n[r] = e;
  }
}
function gs(r, e, n = !1) {
  const i = Qd();
  if (i || Zo) {
    let s = Zo ? Zo._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (s && r in s)
      return s[r];
    if (arguments.length > 1)
      return n && Pt(e) ? e.call(i && i.proxy) : e;
  }
}
function XM() {
  return !!(Qd() || Zo);
}
const YM = Symbol.for("v-scx"), qM = () => gs(YM);
function At(r, e, n) {
  return Tx(r, e, n);
}
function Tx(r, e, n = ln) {
  const { immediate: i, deep: s, flush: o, once: a } = n, l = mi({}, n), c = e && i || !e && o !== "post";
  let u;
  if (Nc) {
    if (o === "sync") {
      const f = qM();
      u = f.__watcherHandles || (f.__watcherHandles = []);
    } else if (!c) {
      const f = () => {
      };
      return f.stop = Vs, f.resume = Vs, f.pause = Vs, f;
    }
  }
  const h = di;
  l.call = (f, m, _) => Ws(f, h, m, _);
  let d = !1;
  o === "post" ? l.scheduler = (f) => {
    _i(f, h && h.suspense);
  } : o !== "sync" && (d = !0, l.scheduler = (f, m) => {
    m ? f() : kg(f);
  }), l.augmentJob = (f) => {
    e && (f.flags |= 4), d && (f.flags |= 2, h && (f.id = h.uid, f.i = h));
  };
  const p = vM(r, e, l);
  return Nc && (u ? u.push(p) : c && p()), p;
}
function ZM(r, e, n) {
  const i = this.proxy, s = kn(r) ? r.includes(".") ? Ex(i, r) : () => i[r] : r.bind(i, i);
  let o;
  Pt(e) ? o = e : (o = e.handler, n = e);
  const a = lu(this), l = Tx(s, o.bind(i), n);
  return a(), l;
}
function Ex(r, e) {
  const n = e.split(".");
  return () => {
    let i = r;
    for (let s = 0; s < n.length && i; s++)
      i = i[n[s]];
    return i;
  };
}
const KM = (r, e) => e === "modelValue" || e === "model-value" ? r.modelModifiers : r[`${e}Modifiers`] || r[`${is(e)}Modifiers`] || r[`${fo(e)}Modifiers`];
function JM(r, e, ...n) {
  if (r.isUnmounted) return;
  const i = r.vnode.props || ln;
  let s = n;
  const o = e.startsWith("update:"), a = o && KM(i, e.slice(7));
  a && (a.trim && (s = n.map((h) => kn(h) ? h.trim() : h)), a.number && (s = n.map(jd)));
  let l, c = i[l = Of(e)] || // also try camelCase event handler (#2249)
  i[l = Of(is(e))];
  !c && o && (c = i[l = Of(fo(e))]), c && Ws(
    c,
    r,
    6,
    s
  );
  const u = i[l + "Once"];
  if (u) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[l])
      return;
    r.emitted[l] = !0, Ws(
      u,
      r,
      6,
      s
    );
  }
}
const QM = /* @__PURE__ */ new WeakMap();
function Ax(r, e, n = !1) {
  const i = n ? QM : e.emitsCache, s = i.get(r);
  if (s !== void 0)
    return s;
  const o = r.emits;
  let a = {}, l = !1;
  if (!Pt(r)) {
    const c = (u) => {
      const h = Ax(u, e, !0);
      h && (l = !0, mi(a, h));
    };
    !n && e.mixins.length && e.mixins.forEach(c), r.extends && c(r.extends), r.mixins && r.mixins.forEach(c);
  }
  return !o && !l ? (cn(r) && i.set(r, null), null) : (St(o) ? o.forEach((c) => a[c] = null) : mi(a, o), cn(r) && i.set(r, a), a);
}
function Kd(r, e) {
  return !r || !Vd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Zt(r, e[0].toLowerCase() + e.slice(1)) || Zt(r, fo(e)) || Zt(r, e));
}
function u0(r) {
  const {
    type: e,
    vnode: n,
    proxy: i,
    withProxy: s,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: h,
    props: d,
    data: p,
    setupState: f,
    ctx: m,
    inheritAttrs: _
  } = r, g = cd(r);
  let v, S;
  try {
    if (n.shapeFlag & 4) {
      const x = s || i, M = x;
      v = Fs(
        u.call(
          M,
          x,
          h,
          d,
          f,
          p,
          m
        )
      ), S = l;
    } else {
      const x = e;
      v = Fs(
        x.length > 1 ? x(
          d,
          { attrs: l, slots: a, emit: c }
        ) : x(
          d,
          null
        )
      ), S = e.props ? l : eC(l);
    }
  } catch (x) {
    _c.length = 0, qd(x, r, 1), v = Ze(Tr);
  }
  let b = v;
  if (S && _ !== !1) {
    const x = Object.keys(S), { shapeFlag: M } = b;
    x.length && M & 7 && (o && x.some(wg) && (S = tC(
      S,
      o
    )), b = rl(b, S, !1, !0));
  }
  return n.dirs && (b = rl(b, null, !1, !0), b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && Rg(b, n.transition), v = b, cd(g), v;
}
const eC = (r) => {
  let e;
  for (const n in r)
    (n === "class" || n === "style" || Vd(n)) && ((e || (e = {}))[n] = r[n]);
  return e;
}, tC = (r, e) => {
  const n = {};
  for (const i in r)
    (!wg(i) || !(i.slice(9) in e)) && (n[i] = r[i]);
  return n;
};
function nC(r, e, n) {
  const { props: i, children: s, component: o } = r, { props: a, children: l, patchFlag: c } = e, u = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return i ? h0(i, a, u) : !!a;
    if (c & 8) {
      const h = e.dynamicProps;
      for (let d = 0; d < h.length; d++) {
        const p = h[d];
        if (a[p] !== i[p] && !Kd(u, p))
          return !0;
      }
    }
  } else
    return (s || l) && (!l || !l.$stable) ? !0 : i === a ? !1 : i ? a ? h0(i, a, u) : !0 : !!a;
  return !1;
}
function h0(r, e, n) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(r).length)
    return !0;
  for (let s = 0; s < i.length; s++) {
    const o = i[s];
    if (e[o] !== r[o] && !Kd(n, o))
      return !0;
  }
  return !1;
}
function iC({ vnode: r, parent: e }, n) {
  for (; e; ) {
    const i = e.subTree;
    if (i.suspense && i.suspense.activeBranch === r && (i.el = r.el), i === r)
      (r = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const Px = {}, Dx = () => Object.create(Px), kx = (r) => Object.getPrototypeOf(r) === Px;
function sC(r, e, n, i = !1) {
  const s = {}, o = Dx();
  r.propsDefaults = /* @__PURE__ */ Object.create(null), Rx(r, e, s, o);
  for (const a in r.propsOptions[0])
    a in s || (s[a] = void 0);
  n ? r.props = i ? s : aM(s) : r.type.props ? r.props = s : r.props = o, r.attrs = o;
}
function rC(r, e, n, i) {
  const {
    props: s,
    attrs: o,
    vnode: { patchFlag: a }
  } = r, l = Ht(s), [c] = r.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const h = r.vnode.dynamicProps;
      for (let d = 0; d < h.length; d++) {
        let p = h[d];
        if (Kd(r.emitsOptions, p))
          continue;
        const f = e[p];
        if (c)
          if (Zt(o, p))
            f !== o[p] && (o[p] = f, u = !0);
          else {
            const m = is(p);
            s[m] = lm(
              c,
              l,
              m,
              f,
              r,
              !1
            );
          }
        else
          f !== o[p] && (o[p] = f, u = !0);
      }
    }
  } else {
    Rx(r, e, s, o) && (u = !0);
    let h;
    for (const d in l)
      (!e || // for camelCase
      !Zt(e, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((h = fo(d)) === d || !Zt(e, h))) && (c ? n && // for camelCase
      (n[d] !== void 0 || // for kebab-case
      n[h] !== void 0) && (s[d] = lm(
        c,
        l,
        d,
        void 0,
        r,
        !0
      )) : delete s[d]);
    if (o !== l)
      for (const d in o)
        (!e || !Zt(e, d)) && (delete o[d], u = !0);
  }
  u && dr(r.attrs, "set", "");
}
function Rx(r, e, n, i) {
  const [s, o] = r.propsOptions;
  let a = !1, l;
  if (e)
    for (let c in e) {
      if (fc(c))
        continue;
      const u = e[c];
      let h;
      s && Zt(s, h = is(c)) ? !o || !o.includes(h) ? n[h] = u : (l || (l = {}))[h] = u : Kd(r.emitsOptions, c) || (!(c in i) || u !== i[c]) && (i[c] = u, a = !0);
    }
  if (o) {
    const c = Ht(n), u = l || ln;
    for (let h = 0; h < o.length; h++) {
      const d = o[h];
      n[d] = lm(
        s,
        c,
        d,
        u[d],
        r,
        !Zt(u, d)
      );
    }
  }
  return a;
}
function lm(r, e, n, i, s, o) {
  const a = r[n];
  if (a != null) {
    const l = Zt(a, "default");
    if (l && i === void 0) {
      const c = a.default;
      if (a.type !== Function && !a.skipFactory && Pt(c)) {
        const { propsDefaults: u } = s;
        if (n in u)
          i = u[n];
        else {
          const h = lu(s);
          i = u[n] = c.call(
            null,
            e
          ), h();
        }
      } else
        i = c;
      s.ce && s.ce._setProp(n, i);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? i = !1 : a[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === fo(n)) && (i = !0));
  }
  return i;
}
const oC = /* @__PURE__ */ new WeakMap();
function Lx(r, e, n = !1) {
  const i = n ? oC : e.propsCache, s = i.get(r);
  if (s)
    return s;
  const o = r.props, a = {}, l = [];
  let c = !1;
  if (!Pt(r)) {
    const h = (d) => {
      c = !0;
      const [p, f] = Lx(d, e, !0);
      mi(a, p), f && l.push(...f);
    };
    !n && e.mixins.length && e.mixins.forEach(h), r.extends && h(r.extends), r.mixins && r.mixins.forEach(h);
  }
  if (!o && !c)
    return cn(r) && i.set(r, Ya), Ya;
  if (St(o))
    for (let h = 0; h < o.length; h++) {
      const d = is(o[h]);
      d0(d) && (a[d] = ln);
    }
  else if (o)
    for (const h in o) {
      const d = is(h);
      if (d0(d)) {
        const p = o[h], f = a[d] = St(p) || Pt(p) ? { type: p } : mi({}, p), m = f.type;
        let _ = !1, g = !0;
        if (St(m))
          for (let v = 0; v < m.length; ++v) {
            const S = m[v], b = Pt(S) && S.name;
            if (b === "Boolean") {
              _ = !0;
              break;
            } else b === "String" && (g = !1);
          }
        else
          _ = Pt(m) && m.name === "Boolean";
        f[
          0
          /* shouldCast */
        ] = _, f[
          1
          /* shouldCastTrue */
        ] = g, (_ || Zt(f, "default")) && l.push(d);
      }
    }
  const u = [a, l];
  return cn(r) && i.set(r, u), u;
}
function d0(r) {
  return r[0] !== "$" && !fc(r);
}
const Ig = (r) => r === "_" || r === "_ctx" || r === "$stable", Og = (r) => St(r) ? r.map(Fs) : [Fs(r)], aC = (r, e, n) => {
  if (e._n)
    return e;
  const i = fs((...s) => Og(e(...s)), n);
  return i._c = !1, i;
}, Ix = (r, e, n) => {
  const i = r._ctx;
  for (const s in r) {
    if (Ig(s)) continue;
    const o = r[s];
    if (Pt(o))
      e[s] = aC(s, o, i);
    else if (o != null) {
      const a = Og(o);
      e[s] = () => a;
    }
  }
}, Ox = (r, e) => {
  const n = Og(e);
  r.slots.default = () => n;
}, Fx = (r, e, n) => {
  for (const i in e)
    (n || !Ig(i)) && (r[i] = e[i]);
}, lC = (r, e, n) => {
  const i = r.slots = Dx();
  if (r.vnode.shapeFlag & 32) {
    const s = e._;
    s ? (Fx(i, e, n), n && N_(i, "_", s, !0)) : Ix(e, i);
  } else e && Ox(r, e);
}, cC = (r, e, n) => {
  const { vnode: i, slots: s } = r;
  let o = !0, a = ln;
  if (i.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : Fx(s, e, n) : (o = !e.$stable, Ix(e, s)), a = e;
  } else e && (Ox(r, e), a = { default: 1 });
  if (o)
    for (const l in s)
      !Ig(l) && a[l] == null && delete s[l];
}, _i = pC;
function uC(r) {
  return hC(r);
}
function hC(r, e) {
  const n = $d();
  n.__VUE__ = !0;
  const {
    insert: i,
    remove: s,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: h,
    parentNode: d,
    nextSibling: p,
    setScopeId: f = Vs,
    insertStaticContent: m
  } = r, _ = (I, Q, X, k = null, ee = null, Z = null, N = void 0, j = null, te = !!Q.dynamicChildren) => {
    if (I === Q)
      return;
    I && !Nl(I, Q) && (k = H(I), J(I, ee, Z, !0), I = null), Q.patchFlag === -2 && (te = !1, Q.dynamicChildren = null);
    const { type: F, ref: B, shapeFlag: Y } = Q;
    switch (F) {
      case Jd:
        g(I, Q, X, k);
        break;
      case Tr:
        v(I, Q, X, k);
        break;
      case Gh:
        I == null && S(Q, X, k, N);
        break;
      case nt:
        U(
          I,
          Q,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te
        );
        break;
      default:
        Y & 1 ? M(
          I,
          Q,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te
        ) : Y & 6 ? D(
          I,
          Q,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te
        ) : (Y & 64 || Y & 128) && F.process(
          I,
          Q,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te,
          R
        );
    }
    B != null && ee ? vc(B, I && I.ref, Z, Q || I, !Q) : B == null && I && I.ref != null && vc(I.ref, null, Z, I, !0);
  }, g = (I, Q, X, k) => {
    if (I == null)
      i(
        Q.el = l(Q.children),
        X,
        k
      );
    else {
      const ee = Q.el = I.el;
      Q.children !== I.children && u(ee, Q.children);
    }
  }, v = (I, Q, X, k) => {
    I == null ? i(
      Q.el = c(Q.children || ""),
      X,
      k
    ) : Q.el = I.el;
  }, S = (I, Q, X, k) => {
    [I.el, I.anchor] = m(
      I.children,
      Q,
      X,
      k,
      I.el,
      I.anchor
    );
  }, b = ({ el: I, anchor: Q }, X, k) => {
    let ee;
    for (; I && I !== Q; )
      ee = p(I), i(I, X, k), I = ee;
    i(Q, X, k);
  }, x = ({ el: I, anchor: Q }) => {
    let X;
    for (; I && I !== Q; )
      X = p(I), s(I), I = X;
    s(Q);
  }, M = (I, Q, X, k, ee, Z, N, j, te) => {
    if (Q.type === "svg" ? N = "svg" : Q.type === "math" && (N = "mathml"), I == null)
      C(
        Q,
        X,
        k,
        ee,
        Z,
        N,
        j,
        te
      );
    else {
      const F = I.el && I.el._isVueCE ? I.el : null;
      try {
        F && F._beginPatch(), w(
          I,
          Q,
          ee,
          Z,
          N,
          j,
          te
        );
      } finally {
        F && F._endPatch();
      }
    }
  }, C = (I, Q, X, k, ee, Z, N, j) => {
    let te, F;
    const { props: B, shapeFlag: Y, transition: fe, dirs: ge } = I;
    if (te = I.el = a(
      I.type,
      Z,
      B && B.is,
      B
    ), Y & 8 ? h(te, I.children) : Y & 16 && T(
      I.children,
      te,
      null,
      k,
      ee,
      Vf(I, Z),
      N,
      j
    ), ge && vo(I, null, k, "created"), E(te, I, I.scopeId, N, k), B) {
      for (const De in B)
        De !== "value" && !fc(De) && o(te, De, null, B[De], Z, k);
      "value" in B && o(te, "value", null, B.value, Z), (F = B.onVnodeBeforeMount) && ks(F, k, I);
    }
    ge && vo(I, null, k, "beforeMount");
    const xe = dC(ee, fe);
    xe && fe.beforeEnter(te), i(te, Q, X), ((F = B && B.onVnodeMounted) || xe || ge) && _i(() => {
      F && ks(F, k, I), xe && fe.enter(te), ge && vo(I, null, k, "mounted");
    }, ee);
  }, E = (I, Q, X, k, ee) => {
    if (X && f(I, X), k)
      for (let Z = 0; Z < k.length; Z++)
        f(I, k[Z]);
    if (ee) {
      let Z = ee.subTree;
      if (Q === Z || zx(Z.type) && (Z.ssContent === Q || Z.ssFallback === Q)) {
        const N = ee.vnode;
        E(
          I,
          N,
          N.scopeId,
          N.slotScopeIds,
          ee.parent
        );
      }
    }
  }, T = (I, Q, X, k, ee, Z, N, j, te = 0) => {
    for (let F = te; F < I.length; F++) {
      const B = I[F] = j ? eo(I[F]) : Fs(I[F]);
      _(
        null,
        B,
        Q,
        X,
        k,
        ee,
        Z,
        N,
        j
      );
    }
  }, w = (I, Q, X, k, ee, Z, N) => {
    const j = Q.el = I.el;
    let { patchFlag: te, dynamicChildren: F, dirs: B } = Q;
    te |= I.patchFlag & 16;
    const Y = I.props || ln, fe = Q.props || ln;
    let ge;
    if (X && yo(X, !1), (ge = fe.onVnodeBeforeUpdate) && ks(ge, X, Q, I), B && vo(Q, I, X, "beforeUpdate"), X && yo(X, !0), (Y.innerHTML && fe.innerHTML == null || Y.textContent && fe.textContent == null) && h(j, ""), F ? A(
      I.dynamicChildren,
      F,
      j,
      X,
      k,
      Vf(Q, ee),
      Z
    ) : N || q(
      I,
      Q,
      j,
      null,
      X,
      k,
      Vf(Q, ee),
      Z,
      !1
    ), te > 0) {
      if (te & 16)
        O(j, Y, fe, X, ee);
      else if (te & 2 && Y.class !== fe.class && o(j, "class", null, fe.class, ee), te & 4 && o(j, "style", Y.style, fe.style, ee), te & 8) {
        const xe = Q.dynamicProps;
        for (let De = 0; De < xe.length; De++) {
          const ae = xe[De], de = Y[ae], Ee = fe[ae];
          (Ee !== de || ae === "value") && o(j, ae, de, Ee, ee, X);
        }
      }
      te & 1 && I.children !== Q.children && h(j, Q.children);
    } else !N && F == null && O(j, Y, fe, X, ee);
    ((ge = fe.onVnodeUpdated) || B) && _i(() => {
      ge && ks(ge, X, Q, I), B && vo(Q, I, X, "updated");
    }, k);
  }, A = (I, Q, X, k, ee, Z, N) => {
    for (let j = 0; j < Q.length; j++) {
      const te = I[j], F = Q[j], B = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        te.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (te.type === nt || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Nl(te, F) || // - In the case of a component, it could contain anything.
        te.shapeFlag & 198) ? d(te.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          X
        )
      );
      _(
        te,
        F,
        B,
        null,
        k,
        ee,
        Z,
        N,
        !0
      );
    }
  }, O = (I, Q, X, k, ee) => {
    if (Q !== X) {
      if (Q !== ln)
        for (const Z in Q)
          !fc(Z) && !(Z in X) && o(
            I,
            Z,
            Q[Z],
            null,
            ee,
            k
          );
      for (const Z in X) {
        if (fc(Z)) continue;
        const N = X[Z], j = Q[Z];
        N !== j && Z !== "value" && o(I, Z, j, N, ee, k);
      }
      "value" in X && o(I, "value", Q.value, X.value, ee);
    }
  }, U = (I, Q, X, k, ee, Z, N, j, te) => {
    const F = Q.el = I ? I.el : l(""), B = Q.anchor = I ? I.anchor : l("");
    let { patchFlag: Y, dynamicChildren: fe, slotScopeIds: ge } = Q;
    ge && (j = j ? j.concat(ge) : ge), I == null ? (i(F, X, k), i(B, X, k), T(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      Q.children || [],
      X,
      B,
      ee,
      Z,
      N,
      j,
      te
    )) : Y > 0 && Y & 64 && fe && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    I.dynamicChildren ? (A(
      I.dynamicChildren,
      fe,
      X,
      ee,
      Z,
      N,
      j
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (Q.key != null || ee && Q === ee.subTree) && Fg(
      I,
      Q,
      !0
      /* shallow */
    )) : q(
      I,
      Q,
      X,
      B,
      ee,
      Z,
      N,
      j,
      te
    );
  }, D = (I, Q, X, k, ee, Z, N, j, te) => {
    Q.slotScopeIds = j, I == null ? Q.shapeFlag & 512 ? ee.ctx.activate(
      Q,
      X,
      k,
      N,
      te
    ) : L(
      Q,
      X,
      k,
      ee,
      Z,
      N,
      te
    ) : P(I, Q, te);
  }, L = (I, Q, X, k, ee, Z, N) => {
    const j = I.component = bC(
      I,
      k,
      ee
    );
    if (yx(I) && (j.ctx.renderer = R), wC(j, !1, N), j.asyncDep) {
      if (ee && ee.registerDep(j, V, N), !I.el) {
        const te = j.subTree = Ze(Tr);
        v(null, te, Q, X), I.placeholder = te.el;
      }
    } else
      V(
        j,
        I,
        Q,
        X,
        ee,
        Z,
        N
      );
  }, P = (I, Q, X) => {
    const k = Q.component = I.component;
    if (nC(I, Q, X))
      if (k.asyncDep && !k.asyncResolved) {
        ce(k, Q, X);
        return;
      } else
        k.next = Q, k.update();
    else
      Q.el = I.el, k.vnode = Q;
  }, V = (I, Q, X, k, ee, Z, N) => {
    const j = () => {
      if (I.isMounted) {
        let { next: Y, bu: fe, u: ge, parent: xe, vnode: De } = I;
        {
          const ke = Ux(I);
          if (ke) {
            Y && (Y.el = De.el, ce(I, Y, N)), ke.asyncDep.then(() => {
              I.isUnmounted || j();
            });
            return;
          }
        }
        let ae = Y, de;
        yo(I, !1), Y ? (Y.el = De.el, ce(I, Y, N)) : Y = De, fe && Nh(fe), (de = Y.props && Y.props.onVnodeBeforeUpdate) && ks(de, xe, Y, De), yo(I, !0);
        const Ee = u0(I), be = I.subTree;
        I.subTree = Ee, _(
          be,
          Ee,
          // parent may have changed if it's in a teleport
          d(be.el),
          // anchor may have changed if it's in a fragment
          H(be),
          I,
          ee,
          Z
        ), Y.el = Ee.el, ae === null && iC(I, Ee.el), ge && _i(ge, ee), (de = Y.props && Y.props.onVnodeUpdated) && _i(
          () => ks(de, xe, Y, De),
          ee
        );
      } else {
        let Y;
        const { el: fe, props: ge } = Q, { bm: xe, m: De, parent: ae, root: de, type: Ee } = I, be = Ka(Q);
        yo(I, !1), xe && Nh(xe), !be && (Y = ge && ge.onVnodeBeforeMount) && ks(Y, ae, Q), yo(I, !0);
        {
          de.ce && // @ts-expect-error _def is private
          de.ce._def.shadowRoot !== !1 && de.ce._injectChildStyle(Ee);
          const ke = I.subTree = u0(I);
          _(
            null,
            ke,
            X,
            k,
            I,
            ee,
            Z
          ), Q.el = ke.el;
        }
        if (De && _i(De, ee), !be && (Y = ge && ge.onVnodeMounted)) {
          const ke = Q;
          _i(
            () => ks(Y, ae, ke),
            ee
          );
        }
        (Q.shapeFlag & 256 || ae && Ka(ae.vnode) && ae.vnode.shapeFlag & 256) && I.a && _i(I.a, ee), I.isMounted = !0, Q = X = k = null;
      }
    };
    I.scope.on();
    const te = I.effect = new X_(j);
    I.scope.off();
    const F = I.update = te.run.bind(te), B = I.job = te.runIfDirty.bind(te);
    B.i = I, B.id = I.uid, te.scheduler = () => kg(B), yo(I, !0), F();
  }, ce = (I, Q, X) => {
    Q.component = I;
    const k = I.vnode.props;
    I.vnode = Q, I.next = null, rC(I, Q.props, k, X), cC(I, Q.children, X), Sr(), e0(I), Mr();
  }, q = (I, Q, X, k, ee, Z, N, j, te = !1) => {
    const F = I && I.children, B = I ? I.shapeFlag : 0, Y = Q.children, { patchFlag: fe, shapeFlag: ge } = Q;
    if (fe > 0) {
      if (fe & 128) {
        ne(
          F,
          Y,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te
        );
        return;
      } else if (fe & 256) {
        oe(
          F,
          Y,
          X,
          k,
          ee,
          Z,
          N,
          j,
          te
        );
        return;
      }
    }
    ge & 8 ? (B & 16 && ye(F, ee, Z), Y !== F && h(X, Y)) : B & 16 ? ge & 16 ? ne(
      F,
      Y,
      X,
      k,
      ee,
      Z,
      N,
      j,
      te
    ) : ye(F, ee, Z, !0) : (B & 8 && h(X, ""), ge & 16 && T(
      Y,
      X,
      k,
      ee,
      Z,
      N,
      j,
      te
    ));
  }, oe = (I, Q, X, k, ee, Z, N, j, te) => {
    I = I || Ya, Q = Q || Ya;
    const F = I.length, B = Q.length, Y = Math.min(F, B);
    let fe;
    for (fe = 0; fe < Y; fe++) {
      const ge = Q[fe] = te ? eo(Q[fe]) : Fs(Q[fe]);
      _(
        I[fe],
        ge,
        X,
        null,
        ee,
        Z,
        N,
        j,
        te
      );
    }
    F > B ? ye(
      I,
      ee,
      Z,
      !0,
      !1,
      Y
    ) : T(
      Q,
      X,
      k,
      ee,
      Z,
      N,
      j,
      te,
      Y
    );
  }, ne = (I, Q, X, k, ee, Z, N, j, te) => {
    let F = 0;
    const B = Q.length;
    let Y = I.length - 1, fe = B - 1;
    for (; F <= Y && F <= fe; ) {
      const ge = I[F], xe = Q[F] = te ? eo(Q[F]) : Fs(Q[F]);
      if (Nl(ge, xe))
        _(
          ge,
          xe,
          X,
          null,
          ee,
          Z,
          N,
          j,
          te
        );
      else
        break;
      F++;
    }
    for (; F <= Y && F <= fe; ) {
      const ge = I[Y], xe = Q[fe] = te ? eo(Q[fe]) : Fs(Q[fe]);
      if (Nl(ge, xe))
        _(
          ge,
          xe,
          X,
          null,
          ee,
          Z,
          N,
          j,
          te
        );
      else
        break;
      Y--, fe--;
    }
    if (F > Y) {
      if (F <= fe) {
        const ge = fe + 1, xe = ge < B ? Q[ge].el : k;
        for (; F <= fe; )
          _(
            null,
            Q[F] = te ? eo(Q[F]) : Fs(Q[F]),
            X,
            xe,
            ee,
            Z,
            N,
            j,
            te
          ), F++;
      }
    } else if (F > fe)
      for (; F <= Y; )
        J(I[F], ee, Z, !0), F++;
    else {
      const ge = F, xe = F, De = /* @__PURE__ */ new Map();
      for (F = xe; F <= fe; F++) {
        const Pe = Q[F] = te ? eo(Q[F]) : Fs(Q[F]);
        Pe.key != null && De.set(Pe.key, F);
      }
      let ae, de = 0;
      const Ee = fe - xe + 1;
      let be = !1, ke = 0;
      const ze = new Array(Ee);
      for (F = 0; F < Ee; F++) ze[F] = 0;
      for (F = ge; F <= Y; F++) {
        const Pe = I[F];
        if (de >= Ee) {
          J(Pe, ee, Z, !0);
          continue;
        }
        let Ge;
        if (Pe.key != null)
          Ge = De.get(Pe.key);
        else
          for (ae = xe; ae <= fe; ae++)
            if (ze[ae - xe] === 0 && Nl(Pe, Q[ae])) {
              Ge = ae;
              break;
            }
        Ge === void 0 ? J(Pe, ee, Z, !0) : (ze[Ge - xe] = F + 1, Ge >= ke ? ke = Ge : be = !0, _(
          Pe,
          Q[Ge],
          X,
          null,
          ee,
          Z,
          N,
          j,
          te
        ), de++);
      }
      const Te = be ? fC(ze) : Ya;
      for (ae = Te.length - 1, F = Ee - 1; F >= 0; F--) {
        const Pe = xe + F, Ge = Q[Pe], Ve = Q[Pe + 1], Qe = Pe + 1 < B ? (
          // #13559, fallback to el placeholder for unresolved async component
          Ve.el || Ve.placeholder
        ) : k;
        ze[F] === 0 ? _(
          null,
          Ge,
          X,
          Qe,
          ee,
          Z,
          N,
          j,
          te
        ) : be && (ae < 0 || F !== Te[ae] ? $(Ge, X, Qe, 2) : ae--);
      }
    }
  }, $ = (I, Q, X, k, ee = null) => {
    const { el: Z, type: N, transition: j, children: te, shapeFlag: F } = I;
    if (F & 6) {
      $(I.component.subTree, Q, X, k);
      return;
    }
    if (F & 128) {
      I.suspense.move(Q, X, k);
      return;
    }
    if (F & 64) {
      N.move(I, Q, X, R);
      return;
    }
    if (N === nt) {
      i(Z, Q, X);
      for (let Y = 0; Y < te.length; Y++)
        $(te[Y], Q, X, k);
      i(I.anchor, Q, X);
      return;
    }
    if (N === Gh) {
      b(I, Q, X);
      return;
    }
    if (k !== 2 && F & 1 && j)
      if (k === 0)
        j.beforeEnter(Z), i(Z, Q, X), _i(() => j.enter(Z), ee);
      else {
        const { leave: Y, delayLeave: fe, afterLeave: ge } = j, xe = () => {
          I.ctx.isUnmounted ? s(Z) : i(Z, Q, X);
        }, De = () => {
          Z._isLeaving && Z[SM](
            !0
            /* cancelled */
          ), Y(Z, () => {
            xe(), ge && ge();
          });
        };
        fe ? fe(Z, xe, De) : De();
      }
    else
      i(Z, Q, X);
  }, J = (I, Q, X, k = !1, ee = !1) => {
    const {
      type: Z,
      props: N,
      ref: j,
      children: te,
      dynamicChildren: F,
      shapeFlag: B,
      patchFlag: Y,
      dirs: fe,
      cacheIndex: ge
    } = I;
    if (Y === -2 && (ee = !1), j != null && (Sr(), vc(j, null, X, I, !0), Mr()), ge != null && (Q.renderCache[ge] = void 0), B & 256) {
      Q.ctx.deactivate(I);
      return;
    }
    const xe = B & 1 && fe, De = !Ka(I);
    let ae;
    if (De && (ae = N && N.onVnodeBeforeUnmount) && ks(ae, Q, I), B & 6)
      re(I.component, X, k);
    else {
      if (B & 128) {
        I.suspense.unmount(X, k);
        return;
      }
      xe && vo(I, null, Q, "beforeUnmount"), B & 64 ? I.type.remove(
        I,
        Q,
        X,
        R,
        k
      ) : F && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !F.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Z !== nt || Y > 0 && Y & 64) ? ye(
        F,
        Q,
        X,
        !1,
        !0
      ) : (Z === nt && Y & 384 || !ee && B & 16) && ye(te, Q, X), k && se(I);
    }
    (De && (ae = N && N.onVnodeUnmounted) || xe) && _i(() => {
      ae && ks(ae, Q, I), xe && vo(I, null, Q, "unmounted");
    }, X);
  }, se = (I) => {
    const { type: Q, el: X, anchor: k, transition: ee } = I;
    if (Q === nt) {
      le(X, k);
      return;
    }
    if (Q === Gh) {
      x(I);
      return;
    }
    const Z = () => {
      s(X), ee && !ee.persisted && ee.afterLeave && ee.afterLeave();
    };
    if (I.shapeFlag & 1 && ee && !ee.persisted) {
      const { leave: N, delayLeave: j } = ee, te = () => N(X, Z);
      j ? j(I.el, Z, te) : te();
    } else
      Z();
  }, le = (I, Q) => {
    let X;
    for (; I !== Q; )
      X = p(I), s(I), I = X;
    s(Q);
  }, re = (I, Q, X) => {
    const { bum: k, scope: ee, job: Z, subTree: N, um: j, m: te, a: F } = I;
    f0(te), f0(F), k && Nh(k), ee.stop(), Z && (Z.flags |= 8, J(N, I, Q, X)), j && _i(j, Q), _i(() => {
      I.isUnmounted = !0;
    }, Q);
  }, ye = (I, Q, X, k = !1, ee = !1, Z = 0) => {
    for (let N = Z; N < I.length; N++)
      J(I[N], Q, X, k, ee);
  }, H = (I) => {
    if (I.shapeFlag & 6)
      return H(I.component.subTree);
    if (I.shapeFlag & 128)
      return I.suspense.next();
    const Q = p(I.anchor || I.el), X = Q && Q[px];
    return X ? p(X) : Q;
  };
  let K = !1;
  const G = (I, Q, X) => {
    I == null ? Q._vnode && J(Q._vnode, null, null, !0) : _(
      Q._vnode || null,
      I,
      Q,
      null,
      null,
      null,
      X
    ), Q._vnode = I, K || (K = !0, e0(), hx(), K = !1);
  }, R = {
    p: _,
    um: J,
    m: $,
    r: se,
    mt: L,
    mc: T,
    pc: q,
    pbc: A,
    n: H,
    o: r
  };
  return {
    render: G,
    hydrate: void 0,
    createApp: $M(G)
  };
}
function Vf({ type: r, props: e }, n) {
  return n === "svg" && r === "foreignObject" || n === "mathml" && r === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function yo({ effect: r, job: e }, n) {
  n ? (r.flags |= 32, e.flags |= 4) : (r.flags &= -33, e.flags &= -5);
}
function dC(r, e) {
  return (!r || r && !r.pendingBranch) && e && !e.persisted;
}
function Fg(r, e, n = !1) {
  const i = r.children, s = e.children;
  if (St(i) && St(s))
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      let l = s[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = s[o] = eo(s[o]), l.el = a.el), !n && l.patchFlag !== -2 && Fg(a, l)), l.type === Jd && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === Tr && !l.el && (l.el = a.el);
    }
}
function fC(r) {
  const e = r.slice(), n = [0];
  let i, s, o, a, l;
  const c = r.length;
  for (i = 0; i < c; i++) {
    const u = r[i];
    if (u !== 0) {
      if (s = n[n.length - 1], r[s] < u) {
        e[i] = s, n.push(i);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, r[n[l]] < u ? o = l + 1 : a = l;
      u < r[n[o]] && (o > 0 && (e[i] = n[o - 1]), n[o] = i);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function Ux(r) {
  const e = r.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Ux(e);
}
function f0(r) {
  if (r)
    for (let e = 0; e < r.length; e++)
      r[e].flags |= 8;
}
const zx = (r) => r.__isSuspense;
function pC(r, e) {
  e && e.pendingBranch ? St(r) ? e.effects.push(...r) : e.effects.push(r) : xM(r);
}
const nt = Symbol.for("v-fgt"), Jd = Symbol.for("v-txt"), Tr = Symbol.for("v-cmt"), Gh = Symbol.for("v-stc"), _c = [];
let Xi = null;
function ie(r = !1) {
  _c.push(Xi = r ? null : []);
}
function mC() {
  _c.pop(), Xi = _c[_c.length - 1] || null;
}
let zc = 1;
function dd(r, e = !1) {
  zc += r, r < 0 && Xi && e && (Xi.hasOnce = !0);
}
function Bx(r) {
  return r.dynamicChildren = zc > 0 ? Xi || Ya : null, mC(), zc > 0 && Xi && Xi.push(r), r;
}
function ue(r, e, n, i, s, o) {
  return Bx(
    y(
      r,
      e,
      n,
      i,
      s,
      o,
      !0
    )
  );
}
function Et(r, e, n, i, s) {
  return Bx(
    Ze(
      r,
      e,
      n,
      i,
      s,
      !0
    )
  );
}
function Bc(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function Nl(r, e) {
  return r.type === e.type && r.key === e.key;
}
const Nx = ({ key: r }) => r ?? null, Hh = ({
  ref: r,
  ref_key: e,
  ref_for: n
}) => (typeof r == "number" && (r = "" + r), r != null ? kn(r) || Dn(r) || Pt(r) ? { i: ti, r, k: e, f: !!n } : r : null);
function y(r, e = null, n = null, i = 0, s = null, o = r === nt ? 0 : 1, a = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && Nx(e),
    ref: e && Hh(e),
    scopeId: fx,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: i,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: ti
  };
  return l ? (Ug(c, n), o & 128 && r.normalize(c)) : n && (c.shapeFlag |= kn(n) ? 8 : 16), zc > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Xi && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && Xi.push(c), c;
}
const Ze = gC;
function gC(r, e = null, n = null, i = 0, s = null, o = !1) {
  if ((!r || r === xx) && (r = Tr), Bc(r)) {
    const l = rl(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return n && Ug(l, n), zc > 0 && !o && Xi && (l.shapeFlag & 6 ? Xi[Xi.indexOf(r)] = l : Xi.push(l)), l.patchFlag = -2, l;
  }
  if (TC(r) && (r = r.__vccOpts), e) {
    e = vC(e);
    let { class: l, style: c } = e;
    l && !kn(l) && (e.class = Ye(l)), cn(c) && (Yd(c) && !St(c) && (c = mi({}, c)), e.style = Ct(c));
  }
  const a = kn(r) ? 1 : zx(r) ? 128 : bM(r) ? 64 : cn(r) ? 4 : Pt(r) ? 2 : 0;
  return y(
    r,
    e,
    n,
    i,
    s,
    a,
    o,
    !0
  );
}
function vC(r) {
  return r ? Yd(r) || kx(r) ? mi({}, r) : r : null;
}
function rl(r, e, n = !1, i = !1) {
  const { props: s, ref: o, patchFlag: a, children: l, transition: c } = r, u = e ? yC(s || {}, e) : s, h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: u,
    key: u && Nx(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? St(o) ? o.concat(Hh(e)) : [o, Hh(e)] : Hh(e)
    ) : o,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: l,
    target: r.target,
    targetStart: r.targetStart,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== nt ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && rl(r.ssContent),
    ssFallback: r.ssFallback && rl(r.ssFallback),
    placeholder: r.placeholder,
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
  return c && i && Rg(
    h,
    c.clone(h)
  ), h;
}
function xt(r = " ", e = 0) {
  return Ze(Jd, null, r, e);
}
function ea(r, e) {
  const n = Ze(Gh, null, r);
  return n.staticCount = e, n;
}
function Ne(r = "", e = !1) {
  return e ? (ie(), Et(Tr, null, r)) : Ze(Tr, null, r);
}
function Fs(r) {
  return r == null || typeof r == "boolean" ? Ze(Tr) : St(r) ? Ze(
    nt,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : Bc(r) ? eo(r) : Ze(Jd, null, String(r));
}
function eo(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : rl(r);
}
function Ug(r, e) {
  let n = 0;
  const { shapeFlag: i } = r;
  if (e == null)
    e = null;
  else if (St(e))
    n = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const s = e.default;
      s && (s._c && (s._d = !1), Ug(r, s()), s._c && (s._d = !0));
      return;
    } else {
      n = 32;
      const s = e._;
      !s && !kx(e) ? e._ctx = ti : s === 3 && ti && (ti.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else Pt(e) ? (e = { default: e, _ctx: ti }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [xt(e)]) : n = 8);
  r.children = e, r.shapeFlag |= n;
}
function yC(...r) {
  const e = {};
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    for (const s in i)
      if (s === "class")
        e.class !== i.class && (e.class = Ye([e.class, i.class]));
      else if (s === "style")
        e.style = Ct([e.style, i.style]);
      else if (Vd(s)) {
        const o = e[s], a = i[s];
        a && o !== a && !(St(o) && o.includes(a)) && (e[s] = o ? [].concat(o, a) : a);
      } else s !== "" && (e[s] = i[s]);
  }
  return e;
}
function ks(r, e, n, i = null) {
  Ws(r, e, 7, [
    n,
    i
  ]);
}
const _C = Cx();
let xC = 0;
function bC(r, e, n) {
  const i = r.type, s = (e ? e.appContext : r.appContext) || _C, o = {
    uid: xC++,
    vnode: r,
    type: i,
    parent: e,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new W_(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(s.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Lx(i, s),
    emitsOptions: Ax(i, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ln,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: ln,
    data: ln,
    props: ln,
    attrs: ln,
    slots: ln,
    refs: ln,
    setupState: ln,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = JM.bind(null, o), r.ce && r.ce(o), o;
}
let di = null;
const Qd = () => di || ti;
let fd, cm;
{
  const r = $d(), e = (n, i) => {
    let s;
    return (s = r[n]) || (s = r[n] = []), s.push(i), (o) => {
      s.length > 1 ? s.forEach((a) => a(o)) : s[0](o);
    };
  };
  fd = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => di = n
  ), cm = e(
    "__VUE_SSR_SETTERS__",
    (n) => Nc = n
  );
}
const lu = (r) => {
  const e = di;
  return fd(r), r.scope.on(), () => {
    r.scope.off(), fd(e);
  };
}, p0 = () => {
  di && di.scope.off(), fd(null);
};
function Vx(r) {
  return r.vnode.shapeFlag & 4;
}
let Nc = !1;
function wC(r, e = !1, n = !1) {
  e && cm(e);
  const { props: i, children: s } = r.vnode, o = Vx(r);
  sC(r, i, o, e), lC(r, s, n || e);
  const a = o ? SC(r, e) : void 0;
  return e && cm(!1), a;
}
function SC(r, e) {
  const n = r.type;
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = new Proxy(r.ctx, UM);
  const { setup: i } = n;
  if (i) {
    Sr();
    const s = r.setupContext = i.length > 1 ? Hx(r) : null, o = lu(r), a = au(
      i,
      r,
      0,
      [
        r.props,
        s
      ]
    ), l = U_(a);
    if (Mr(), o(), (l || r.sp) && !Ka(r) && vx(r), l) {
      if (a.then(p0, p0), e)
        return a.then((c) => {
          m0(r, c);
        }).catch((c) => {
          qd(c, r, 0);
        });
      r.asyncDep = a;
    } else
      m0(r, a);
  } else
    Gx(r);
}
function m0(r, e, n) {
  Pt(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : cn(e) && (r.setupState = lx(e)), Gx(r);
}
function Gx(r, e, n) {
  const i = r.type;
  r.render || (r.render = i.render || Vs);
  {
    const s = lu(r);
    Sr();
    try {
      NM(r);
    } finally {
      Mr(), s();
    }
  }
}
const MC = {
  get(r, e) {
    return hi(r, "get", ""), r[e];
  }
};
function Hx(r) {
  const e = (n) => {
    r.exposed = n || {};
  };
  return {
    attrs: new Proxy(r.attrs, MC),
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function ef(r) {
  return r.exposed ? r.exposeProxy || (r.exposeProxy = new Proxy(lx(cr(r.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in yc)
        return yc[n](r);
    },
    has(e, n) {
      return n in e || n in yc;
    }
  })) : r.proxy;
}
function CC(r, e = !0) {
  return Pt(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function TC(r) {
  return Pt(r) && "__vccOpts" in r;
}
const Xe = (r, e) => mM(r, e, Nc);
function EC(r, e, n) {
  try {
    dd(-1);
    const i = arguments.length;
    return i === 2 ? cn(e) && !St(e) ? Bc(e) ? Ze(r, null, [e]) : Ze(r, e) : Ze(r, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && Bc(n) && (n = [n]), Ze(r, e, n));
  } finally {
    dd(1);
  }
}
const AC = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let um;
const g0 = typeof window < "u" && window.trustedTypes;
if (g0)
  try {
    um = /* @__PURE__ */ g0.createPolicy("vue", {
      createHTML: (r) => r
    });
  } catch {
  }
const Wx = um ? (r) => um.createHTML(r) : (r) => r, PC = "http://www.w3.org/2000/svg", DC = "http://www.w3.org/1998/Math/MathML", lr = typeof document < "u" ? document : null, v0 = lr && /* @__PURE__ */ lr.createElement("template"), kC = {
  insert: (r, e, n) => {
    e.insertBefore(r, n || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, n, i) => {
    const s = e === "svg" ? lr.createElementNS(PC, r) : e === "mathml" ? lr.createElementNS(DC, r) : n ? lr.createElement(r, { is: n }) : lr.createElement(r);
    return r === "select" && i && i.multiple != null && s.setAttribute("multiple", i.multiple), s;
  },
  createText: (r) => lr.createTextNode(r),
  createComment: (r) => lr.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => lr.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, n, i, s, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (s && (s === o || s.nextSibling))
      for (; e.insertBefore(s.cloneNode(!0), n), !(s === o || !(s = s.nextSibling)); )
        ;
    else {
      v0.innerHTML = Wx(
        i === "svg" ? `<svg>${r}</svg>` : i === "mathml" ? `<math>${r}</math>` : r
      );
      const l = v0.content;
      if (i === "svg" || i === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, RC = Symbol("_vtc");
function LC(r, e, n) {
  const i = r[RC];
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? r.removeAttribute("class") : n ? r.setAttribute("class", e) : r.className = e;
}
const pd = Symbol("_vod"), jx = Symbol("_vsh"), _o = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(r, { value: e }, { transition: n }) {
    r[pd] = r.style.display === "none" ? "" : r.style.display, n && e ? n.beforeEnter(r) : Vl(r, e);
  },
  mounted(r, { value: e }, { transition: n }) {
    n && e && n.enter(r);
  },
  updated(r, { value: e, oldValue: n }, { transition: i }) {
    !e != !n && (i ? e ? (i.beforeEnter(r), Vl(r, !0), i.enter(r)) : i.leave(r, () => {
      Vl(r, !1);
    }) : Vl(r, e));
  },
  beforeUnmount(r, { value: e }) {
    Vl(r, e);
  }
};
function Vl(r, e) {
  r.style.display = e ? r[pd] : "none", r[jx] = !e;
}
const IC = Symbol(""), OC = /(?:^|;)\s*display\s*:/;
function FC(r, e, n) {
  const i = r.style, s = kn(n);
  let o = !1;
  if (n && !s) {
    if (e)
      if (kn(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && Wh(i, l, "");
        }
      else
        for (const a in e)
          n[a] == null && Wh(i, a, "");
    for (const a in n)
      a === "display" && (o = !0), Wh(i, a, n[a]);
  } else if (s) {
    if (e !== n) {
      const a = i[IC];
      a && (n += ";" + a), i.cssText = n, o = OC.test(n);
    }
  } else e && r.removeAttribute("style");
  pd in r && (r[pd] = o ? i.display : "", r[jx] && (i.display = "none"));
}
const y0 = /\s*!important$/;
function Wh(r, e, n) {
  if (St(n))
    n.forEach((i) => Wh(r, e, i));
  else if (n == null && (n = ""), e.startsWith("--"))
    r.setProperty(e, n);
  else {
    const i = UC(r, e);
    y0.test(n) ? r.setProperty(
      fo(i),
      n.replace(y0, ""),
      "important"
    ) : r[i] = n;
  }
}
const _0 = ["Webkit", "Moz", "ms"], Gf = {};
function UC(r, e) {
  const n = Gf[e];
  if (n)
    return n;
  let i = is(e);
  if (i !== "filter" && i in r)
    return Gf[e] = i;
  i = Wd(i);
  for (let s = 0; s < _0.length; s++) {
    const o = _0[s] + i;
    if (o in r)
      return Gf[e] = o;
  }
  return e;
}
const x0 = "http://www.w3.org/1999/xlink";
function b0(r, e, n, i, s, o = BS(e)) {
  i && e.startsWith("xlink:") ? n == null ? r.removeAttributeNS(x0, e.slice(6, e.length)) : r.setAttributeNS(x0, e, n) : n == null || o && !V_(n) ? r.removeAttribute(e) : r.setAttribute(
    e,
    o ? "" : Cs(n) ? String(n) : n
  );
}
function w0(r, e, n, i, s) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (r[e] = e === "innerHTML" ? Wx(n) : n);
    return;
  }
  const o = r.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? r.getAttribute("value") || "" : r.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      r.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in r)) && (r.value = c), n == null && r.removeAttribute(e), r._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof r[e];
    l === "boolean" ? n = V_(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    r[e] = n;
  } catch {
  }
  a && r.removeAttribute(s || e);
}
function to(r, e, n, i) {
  r.addEventListener(e, n, i);
}
function zC(r, e, n, i) {
  r.removeEventListener(e, n, i);
}
const S0 = Symbol("_vei");
function BC(r, e, n, i, s = null) {
  const o = r[S0] || (r[S0] = {}), a = o[e];
  if (i && a)
    a.value = i;
  else {
    const [l, c] = NC(e);
    if (i) {
      const u = o[e] = HC(
        i,
        s
      );
      to(r, l, u, c);
    } else a && (zC(r, l, a, c), o[e] = void 0);
  }
}
const M0 = /(?:Once|Passive|Capture)$/;
function NC(r) {
  let e;
  if (M0.test(r)) {
    e = {};
    let i;
    for (; i = r.match(M0); )
      r = r.slice(0, r.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : fo(r.slice(2)), e];
}
let Hf = 0;
const VC = /* @__PURE__ */ Promise.resolve(), GC = () => Hf || (VC.then(() => Hf = 0), Hf = Date.now());
function HC(r, e) {
  const n = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= n.attached)
      return;
    Ws(
      WC(i, n.value),
      e,
      5,
      [i]
    );
  };
  return n.value = r, n.attached = GC(), n;
}
function WC(r, e) {
  if (St(e)) {
    const n = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      n.call(r), r._stopped = !0;
    }, e.map(
      (i) => (s) => !s._stopped && i && i(s)
    );
  } else
    return e;
}
const C0 = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // lowercase letter
r.charCodeAt(2) > 96 && r.charCodeAt(2) < 123, jC = (r, e, n, i, s, o) => {
  const a = s === "svg";
  e === "class" ? LC(r, i, a) : e === "style" ? FC(r, n, i) : Vd(e) ? wg(e) || BC(r, e, n, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : $C(r, e, i, a)) ? (w0(r, e, i), !r.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && b0(r, e, i, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ r._isVueCE && (/[A-Z]/.test(e) || !kn(i)) ? w0(r, is(e), i, o, e) : (e === "true-value" ? r._trueValue = i : e === "false-value" && (r._falseValue = i), b0(r, e, i, a));
};
function $C(r, e, n, i) {
  if (i)
    return !!(e === "innerHTML" || e === "textContent" || e in r && C0(e) && Pt(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && r.tagName === "IFRAME" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const s = r.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return C0(e) && kn(n) ? !1 : e in r;
}
const ol = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return St(e) ? (n) => Nh(e, n) : e;
};
function XC(r) {
  r.target.composing = !0;
}
function T0(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const yr = Symbol("_assign");
function E0(r, e, n) {
  return e && (r = r.trim()), n && (r = jd(r)), r;
}
const Tn = {
  created(r, { modifiers: { lazy: e, trim: n, number: i } }, s) {
    r[yr] = ol(s);
    const o = i || s.props && s.props.type === "number";
    to(r, e ? "change" : "input", (a) => {
      a.target.composing || r[yr](E0(r.value, n, o));
    }), (n || o) && to(r, "change", () => {
      r.value = E0(r.value, n, o);
    }), e || (to(r, "compositionstart", XC), to(r, "compositionend", T0), to(r, "change", T0));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, oldValue: n, modifiers: { lazy: i, trim: s, number: o } }, a) {
    if (r[yr] = ol(a), r.composing) return;
    const l = (o || r.type === "number") && !/^0\d/.test(r.value) ? jd(r.value) : r.value, c = e ?? "";
    l !== c && (document.activeElement === r && r.type !== "range" && (i && e === n || s && r.value.trim() === c) || (r.value = c));
  }
}, Us = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, n) {
    r[yr] = ol(n), to(r, "change", () => {
      const i = r._modelValue, s = Vc(r), o = r.checked, a = r[yr];
      if (St(i)) {
        const l = Mg(i, s), c = l !== -1;
        if (o && !c)
          a(i.concat(s));
        else if (!o && c) {
          const u = [...i];
          u.splice(l, 1), a(u);
        }
      } else if (vl(i)) {
        const l = new Set(i);
        o ? l.add(s) : l.delete(s), a(l);
      } else
        a($x(r, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: A0,
  beforeUpdate(r, e, n) {
    r[yr] = ol(n), A0(r, e, n);
  }
};
function A0(r, { value: e, oldValue: n }, i) {
  r._modelValue = e;
  let s;
  if (St(e))
    s = Mg(e, i.props.value) > -1;
  else if (vl(e))
    s = e.has(i.props.value);
  else {
    if (e === n) return;
    s = ou(e, $x(r, !0));
  }
  r.checked !== s && (r.checked = s);
}
const ns = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: n } }, i) {
    const s = vl(e);
    to(r, "change", () => {
      const o = Array.prototype.filter.call(r.options, (a) => a.selected).map(
        (a) => n ? jd(Vc(a)) : Vc(a)
      );
      r[yr](
        r.multiple ? s ? new Set(o) : o : o[0]
      ), r._assigning = !0, Gs(() => {
        r._assigning = !1;
      });
    }), r[yr] = ol(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e }) {
    P0(r, e);
  },
  beforeUpdate(r, e, n) {
    r[yr] = ol(n);
  },
  updated(r, { value: e }) {
    r._assigning || P0(r, e);
  }
};
function P0(r, e) {
  const n = r.multiple, i = St(e);
  if (!(n && !i && !vl(e))) {
    for (let s = 0, o = r.options.length; s < o; s++) {
      const a = r.options[s], l = Vc(a);
      if (n)
        if (i) {
          const c = typeof l;
          c === "string" || c === "number" ? a.selected = e.some((u) => String(u) === String(l)) : a.selected = Mg(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (ou(Vc(a), e)) {
        r.selectedIndex !== s && (r.selectedIndex = s);
        return;
      }
    }
    !n && r.selectedIndex !== -1 && (r.selectedIndex = -1);
  }
}
function Vc(r) {
  return "_value" in r ? r._value : r.value;
}
function $x(r, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in r ? r[n] : e;
}
const YC = ["ctrl", "shift", "alt", "meta"], qC = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => YC.some((n) => r[`${n}Key`] && !e.includes(n))
}, Rt = (r, e) => {
  const n = r._withMods || (r._withMods = {}), i = e.join(".");
  return n[i] || (n[i] = (s, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = qC[e[a]];
      if (l && l(s, e)) return;
    }
    return r(s, ...o);
  });
}, ZC = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, zg = (r, e) => {
  const n = r._withKeys || (r._withKeys = {}), i = e.join(".");
  return n[i] || (n[i] = (s) => {
    if (!("key" in s))
      return;
    const o = fo(s.key);
    if (e.some(
      (a) => a === o || ZC[a] === o
    ))
      return r(s);
  });
}, KC = /* @__PURE__ */ mi({ patchProp: jC }, kC);
let D0;
function JC() {
  return D0 || (D0 = uC(KC));
}
const QC = (...r) => {
  const e = JC().createApp(...r), { mount: n } = e;
  return e.mount = (i) => {
    const s = tT(i);
    if (!s) return;
    const o = e._component;
    !Pt(o) && !o.render && !o.template && (o.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
    const a = n(s, !1, eT(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), a;
  }, e;
};
function eT(r) {
  if (r instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && r instanceof MathMLElement)
    return "mathml";
}
function tT(r) {
  return kn(r) ? document.querySelector(r) : r;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Xx;
const tf = (r) => Xx = r, Yx = (
  /* istanbul ignore next */
  Symbol()
);
function hm(r) {
  return r && typeof r == "object" && Object.prototype.toString.call(r) === "[object Object]" && typeof r.toJSON != "function";
}
var xc;
(function(r) {
  r.direct = "direct", r.patchObject = "patch object", r.patchFunction = "patch function";
})(xc || (xc = {}));
function nT() {
  const r = j_(!0), e = r.run(() => Ce({}));
  let n = [], i = [];
  const s = cr({
    install(o) {
      tf(s), s._a = o, o.provide(Yx, s), o.config.globalProperties.$pinia = s, i.forEach((a) => n.push(a)), i = [];
    },
    use(o) {
      return this._a ? n.push(o) : i.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: r,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return s;
}
const qx = () => {
};
function k0(r, e, n, i = qx) {
  r.push(e);
  const s = () => {
    const o = r.indexOf(e);
    o > -1 && (r.splice(o, 1), i());
  };
  return !n && $_() && VS(s), s;
}
function ha(r, ...e) {
  r.slice().forEach((n) => {
    n(...e);
  });
}
const iT = (r) => r(), R0 = Symbol(), Wf = Symbol();
function dm(r, e) {
  r instanceof Map && e instanceof Map ? e.forEach((n, i) => r.set(i, n)) : r instanceof Set && e instanceof Set && e.forEach(r.add, r);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const i = e[n], s = r[n];
    hm(s) && hm(i) && r.hasOwnProperty(n) && !Dn(i) && !vr(i) ? r[n] = dm(s, i) : r[n] = i;
  }
  return r;
}
const sT = (
  /* istanbul ignore next */
  Symbol()
);
function rT(r) {
  return !hm(r) || !r.hasOwnProperty(sT);
}
const { assign: Kr } = Object;
function oT(r) {
  return !!(Dn(r) && r.effect);
}
function aT(r, e, n, i) {
  const { state: s, actions: o, getters: a } = e, l = n.state.value[r];
  let c;
  function u() {
    l || (n.state.value[r] = s ? s() : {});
    const h = hM(n.state.value[r]);
    return Kr(h, o, Object.keys(a || {}).reduce((d, p) => (d[p] = cr(Xe(() => {
      tf(n);
      const f = n._s.get(r);
      return a[p].call(f, f);
    })), d), {}));
  }
  return c = Zx(r, u, e, n, i, !0), c;
}
function Zx(r, e, n = {}, i, s, o) {
  let a;
  const l = Kr({ actions: {} }, n), c = { deep: !0 };
  let u, h, d = [], p = [], f;
  const m = i.state.value[r];
  !o && !m && (i.state.value[r] = {}), Ce({});
  let _;
  function g(T) {
    let w;
    u = h = !1, typeof T == "function" ? (T(i.state.value[r]), w = {
      type: xc.patchFunction,
      storeId: r,
      events: f
    }) : (dm(i.state.value[r], T), w = {
      type: xc.patchObject,
      payload: T,
      storeId: r,
      events: f
    });
    const A = _ = Symbol();
    Gs().then(() => {
      _ === A && (u = !0);
    }), h = !0, ha(d, w, i.state.value[r]);
  }
  const v = o ? function() {
    const { state: w } = n, A = w ? w() : {};
    this.$patch((O) => {
      Kr(O, A);
    });
  } : (
    /* istanbul ignore next */
    qx
  );
  function S() {
    a.stop(), d = [], p = [], i._s.delete(r);
  }
  const b = (T, w = "") => {
    if (R0 in T)
      return T[Wf] = w, T;
    const A = function() {
      tf(i);
      const O = Array.from(arguments), U = [], D = [];
      function L(ce) {
        U.push(ce);
      }
      function P(ce) {
        D.push(ce);
      }
      ha(p, {
        args: O,
        name: A[Wf],
        store: M,
        after: L,
        onError: P
      });
      let V;
      try {
        V = T.apply(this && this.$id === r ? this : M, O);
      } catch (ce) {
        throw ha(D, ce), ce;
      }
      return V instanceof Promise ? V.then((ce) => (ha(U, ce), ce)).catch((ce) => (ha(D, ce), Promise.reject(ce))) : (ha(U, V), V);
    };
    return A[R0] = !0, A[Wf] = w, A;
  }, x = {
    _p: i,
    // _s: scope,
    $id: r,
    $onAction: k0.bind(null, p),
    $patch: g,
    $reset: v,
    $subscribe(T, w = {}) {
      const A = k0(d, T, w.detached, () => O()), O = a.run(() => At(() => i.state.value[r], (U) => {
        (w.flush === "sync" ? h : u) && T({
          storeId: r,
          type: xc.direct,
          events: f
        }, U);
      }, Kr({}, c, w)));
      return A;
    },
    $dispose: S
  }, M = yl(x);
  i._s.set(r, M);
  const E = (i._a && i._a.runWithContext || iT)(() => i._e.run(() => (a = j_()).run(() => e({ action: b }))));
  for (const T in E) {
    const w = E[T];
    if (Dn(w) && !oT(w) || vr(w))
      o || (m && rT(w) && (Dn(w) ? w.value = m[T] : dm(w, m[T])), i.state.value[r][T] = w);
    else if (typeof w == "function") {
      const A = b(w, T);
      E[T] = A, l.actions[T] = w;
    }
  }
  return Kr(M, E), Kr(Ht(M), E), Object.defineProperty(M, "$state", {
    get: () => i.state.value[r],
    set: (T) => {
      g((w) => {
        Kr(w, T);
      });
    }
  }), i._p.forEach((T) => {
    Kr(M, a.run(() => T({
      store: M,
      app: i._a,
      pinia: i,
      options: l
    })));
  }), m && o && n.hydrate && n.hydrate(M.$state, m), u = !0, h = !0, M;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function lT(r, e, n) {
  let i, s;
  const o = typeof e == "function";
  i = r, s = o ? n : e;
  function a(l, c) {
    const u = XM();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? gs(Yx, null) : null), l && tf(l), l = Xx, l._s.has(i) || (o ? Zx(i, e, s, l) : aT(i, s, l)), l._s.get(i);
  }
  return a.$id = i, a;
}
const jf = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(r, { emit: e }) {
    const n = e, i = r, s = zM(), o = Ce([]), a = Xe(() => o.value.reduce((H, K) => (H[~~K.id] = K) && H, {})), l = Xe(() => o.value.length), c = Ce(null), u = Ce(!1), h = Ce({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), d = Ce({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), p = Xe(() => ({
      [`splitpanes splitpanes--${i.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": h.value.dragging
    })), f = () => {
      document.addEventListener("mousemove", g, { passive: !1 }), document.addEventListener("mouseup", v), "ontouchstart" in window && (document.addEventListener("touchmove", g, { passive: !1 }), document.addEventListener("touchend", v));
    }, m = () => {
      document.removeEventListener("mousemove", g, { passive: !1 }), document.removeEventListener("mouseup", v), "ontouchstart" in window && (document.removeEventListener("touchmove", g, { passive: !1 }), document.removeEventListener("touchend", v));
    }, _ = (H, K) => {
      const G = H.target.closest(".splitpanes__splitter");
      if (G) {
        const { left: R, top: z } = G.getBoundingClientRect(), { clientX: I, clientY: Q } = "ontouchstart" in window && H.touches ? H.touches[0] : H;
        h.value.cursorOffset = i.horizontal ? Q - z : I - R;
      }
      f(), h.value.mouseDown = !0, h.value.activeSplitter = K;
    }, g = (H) => {
      h.value.mouseDown && (H.preventDefault(), h.value.dragging = !0, requestAnimationFrame(() => {
        E(M(H)), re("resize", { event: H }, !0);
      }));
    }, v = (H) => {
      h.value.dragging && (window.getSelection().removeAllRanges(), re("resized", { event: H }, !0)), h.value.mouseDown = !1, h.value.activeSplitter = null, setTimeout(() => {
        h.value.dragging = !1, m();
      }, 100);
    }, S = (H, K) => {
      "ontouchstart" in window && (H.preventDefault(), d.value.splitter === K ? (clearTimeout(d.value.timeoutId), d.value.timeoutId = null, b(H, K), d.value.splitter = null) : (d.value.splitter = K, d.value.timeoutId = setTimeout(() => d.value.splitter = null, 500))), h.value.dragging || re("splitter-click", { event: H, index: K }, !0);
    }, b = (H, K) => {
      if (re("splitter-dblclick", { event: H, index: K }, !0), i.maximizePanes) {
        let G = 0;
        o.value = o.value.map((R, z) => (R.size = z === K ? R.max : R.min, z !== K && (G += R.min), R)), o.value[K].size -= G, re("pane-maximize", { event: H, index: K, pane: o.value[K] }), re("resized", { event: H, index: K }, !0);
      }
    }, x = (H, K) => {
      re("pane-click", {
        event: H,
        index: a.value[K].index,
        pane: a.value[K]
      });
    }, M = (H) => {
      const K = c.value.getBoundingClientRect(), { clientX: G, clientY: R } = "ontouchstart" in window && H.touches ? H.touches[0] : H;
      return {
        x: G - (i.horizontal ? 0 : h.value.cursorOffset) - K.left,
        y: R - (i.horizontal ? h.value.cursorOffset : 0) - K.top
      };
    }, C = (H) => {
      H = H[i.horizontal ? "y" : "x"];
      const K = c.value[i.horizontal ? "clientHeight" : "clientWidth"];
      return i.rtl && !i.horizontal && (H = K - H), H * 100 / K;
    }, E = (H) => {
      const K = h.value.activeSplitter;
      let G = {
        prevPanesSize: w(K),
        nextPanesSize: A(K),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const R = 0 + (i.pushOtherPanes ? 0 : G.prevPanesSize), z = 100 - (i.pushOtherPanes ? 0 : G.nextPanesSize), I = Math.max(Math.min(C(H), z), R);
      let Q = [K, K + 1], X = o.value[Q[0]] || null, k = o.value[Q[1]] || null;
      const ee = X.max < 100 && I >= X.max + G.prevPanesSize, Z = k.max < 100 && I <= 100 - (k.max + A(K + 1));
      if (ee || Z) {
        ee ? (X.size = X.max, k.size = Math.max(100 - X.max - G.prevPanesSize - G.nextPanesSize, 0)) : (X.size = Math.max(100 - k.max - G.prevPanesSize - A(K + 1), 0), k.size = k.max);
        return;
      }
      if (i.pushOtherPanes) {
        const N = T(G, I);
        if (!N) return;
        ({ sums: G, panesToResize: Q } = N), X = o.value[Q[0]] || null, k = o.value[Q[1]] || null;
      }
      X !== null && (X.size = Math.min(Math.max(I - G.prevPanesSize - G.prevReachedMinPanes, X.min), X.max)), k !== null && (k.size = Math.min(Math.max(100 - I - G.nextPanesSize - G.nextReachedMinPanes, k.min), k.max));
    }, T = (H, K) => {
      const G = h.value.activeSplitter, R = [G, G + 1];
      return K < H.prevPanesSize + o.value[R[0]].min && (R[0] = O(G).index, H.prevReachedMinPanes = 0, R[0] < G && o.value.forEach((z, I) => {
        I > R[0] && I <= G && (z.size = z.min, H.prevReachedMinPanes += z.min);
      }), H.prevPanesSize = w(R[0]), R[0] === void 0) ? (H.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((z, I) => {
        I > 0 && I <= G && (z.size = z.min, H.prevReachedMinPanes += z.min);
      }), o.value[R[1]].size = 100 - H.prevReachedMinPanes - o.value[0].min - H.prevPanesSize - H.nextPanesSize, null) : K > 100 - H.nextPanesSize - o.value[R[1]].min && (R[1] = U(G).index, H.nextReachedMinPanes = 0, R[1] > G + 1 && o.value.forEach((z, I) => {
        I > G && I < R[1] && (z.size = z.min, H.nextReachedMinPanes += z.min);
      }), H.nextPanesSize = A(R[1] - 1), R[1] === void 0) ? (H.nextReachedMinPanes = 0, o.value.forEach((z, I) => {
        I < l.value - 1 && I >= G + 1 && (z.size = z.min, H.nextReachedMinPanes += z.min);
      }), o.value[R[0]].size = 100 - H.prevPanesSize - A(R[0] - 1), null) : { sums: H, panesToResize: R };
    }, w = (H) => o.value.reduce((K, G, R) => K + (R < H ? G.size : 0), 0), A = (H) => o.value.reduce((K, G, R) => K + (R > H + 1 ? G.size : 0), 0), O = (H) => [...o.value].reverse().find((K) => K.index < H && K.size > K.min) || {}, U = (H) => o.value.find((K) => K.index > H + 1 && K.size > K.min) || {}, D = () => {
      var H;
      const K = Array.from(((H = c.value) == null ? void 0 : H.children) || []);
      for (const G of K) {
        const R = G.classList.contains("splitpanes__pane"), z = G.classList.contains("splitpanes__splitter");
        !R && !z && (G.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, L = (H, K, G = !1) => {
      const R = H - 1, z = document.createElement("div");
      z.classList.add("splitpanes__splitter"), G || (z.onmousedown = (I) => _(I, R), typeof window < "u" && "ontouchstart" in window && (z.ontouchstart = (I) => _(I, R)), z.onclick = (I) => S(I, R + 1)), z.ondblclick = (I) => b(I, R + 1), K.parentNode.insertBefore(z, K);
    }, P = (H) => {
      H.onmousedown = void 0, H.onclick = void 0, H.ondblclick = void 0, H.remove();
    }, V = () => {
      var H;
      const K = Array.from(((H = c.value) == null ? void 0 : H.children) || []);
      for (const R of K)
        R.className.includes("splitpanes__splitter") && P(R);
      let G = 0;
      for (const R of K)
        R.className.includes("splitpanes__pane") && (!G && i.firstSplitter ? L(G, R, !0) : G && L(G, R), G++);
    }, ce = ({ uid: H, ...K }) => {
      const G = a.value[H];
      for (const [R, z] of Object.entries(K)) G[R] = z;
    }, q = (H) => {
      var K;
      let G = -1;
      Array.from(((K = c.value) == null ? void 0 : K.children) || []).some((R) => (R.className.includes("splitpanes__pane") && G++, R.isSameNode(H.el))), o.value.splice(G, 0, { ...H, index: G }), o.value.forEach((R, z) => R.index = z), u.value && Gs(() => {
        V(), ne({ addedPane: o.value[G] }), re("pane-add", { pane: o.value[G] });
      });
    }, oe = (H) => {
      const K = o.value.findIndex((R) => R.id === H);
      o.value[K].el = null;
      const G = o.value.splice(K, 1)[0];
      o.value.forEach((R, z) => R.index = z), Gs(() => {
        V(), re("pane-remove", { pane: G }), ne({ removedPane: { ...G } });
      });
    }, ne = (H = {}) => {
      !H.addedPane && !H.removedPane ? J() : o.value.some((K) => K.givenSize !== null || K.min || K.max < 100) ? se(H) : $(), u.value && re("resized");
    }, $ = () => {
      const H = 100 / l.value;
      let K = 0;
      const G = [], R = [];
      for (const z of o.value)
        z.size = Math.max(Math.min(H, z.max), z.min), K -= z.size, z.size >= z.max && G.push(z.id), z.size <= z.min && R.push(z.id);
      K > 0.1 && le(K, G, R);
    }, J = () => {
      let H = 100;
      const K = [], G = [];
      let R = 0;
      for (const I of o.value)
        H -= I.size, I.givenSize !== null && R++, I.size >= I.max && K.push(I.id), I.size <= I.min && G.push(I.id);
      let z = 100;
      if (H > 0.1) {
        for (const I of o.value)
          I.givenSize === null && (I.size = Math.max(Math.min(H / (l.value - R), I.max), I.min)), z -= I.size;
        z > 0.1 && le(z, K, G);
      }
    }, se = ({ addedPane: H, removedPane: K } = {}) => {
      let G = 100 / l.value, R = 0;
      const z = [], I = [];
      ((H == null ? void 0 : H.givenSize) ?? null) !== null && (G = (100 - H.givenSize) / (l.value - 1));
      for (const Q of o.value)
        R -= Q.size, Q.size >= Q.max && z.push(Q.id), Q.size <= Q.min && I.push(Q.id);
      if (!(Math.abs(R) < 0.1)) {
        for (const Q of o.value)
          (H == null ? void 0 : H.givenSize) !== null && (H == null ? void 0 : H.id) === Q.id || (Q.size = Math.max(Math.min(G, Q.max), Q.min)), R -= Q.size, Q.size >= Q.max && z.push(Q.id), Q.size <= Q.min && I.push(Q.id);
        R > 0.1 && le(R, z, I);
      }
    }, le = (H, K, G) => {
      let R;
      H > 0 ? R = H / (l.value - K.length) : R = H / (l.value - G.length), o.value.forEach((z, I) => {
        if (H > 0 && !K.includes(z.id)) {
          const Q = Math.max(Math.min(z.size + R, z.max), z.min), X = Q - z.size;
          H -= X, z.size = Q;
        } else if (!G.includes(z.id)) {
          const Q = Math.max(Math.min(z.size + R, z.max), z.min), X = Q - z.size;
          H -= X, z.size = Q;
        }
      }), Math.abs(H) > 0.1 && Gs(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, re = (H, K = void 0, G = !1) => {
      const R = (K == null ? void 0 : K.index) ?? h.value.activeSplitter ?? null;
      n(H, {
        ...K,
        ...R !== null && { index: R },
        ...G && R !== null && {
          prevPane: o.value[R - (i.firstSplitter ? 1 : 0)],
          nextPane: o.value[R + (i.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((z) => ({ min: z.min, max: z.max, size: z.size }))
      });
    };
    At(() => i.firstSplitter, () => V()), Xn(() => {
      D(), V(), ne(), re("ready"), u.value = !0;
    }), Lg(() => u.value = !1);
    const ye = () => {
      var H;
      return EC(
        "div",
        { ref: c, class: p.value },
        (H = s.default) == null ? void 0 : H.call(s)
      );
    };
    return Zr("panes", o), Zr("indexedPanes", a), Zr("horizontal", Xe(() => i.horizontal)), Zr("requestUpdate", ce), Zr("onPaneAdd", q), Zr("onPaneRemove", oe), Zr("onPaneClick", x), (H, K) => (ie(), Et(bx(ye)));
  }
}, xo = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(r) {
    var e;
    const n = r, i = gs("requestUpdate"), s = gs("onPaneAdd"), o = gs("horizontal"), a = gs("onPaneRemove"), l = gs("onPaneClick"), c = (e = Qd()) == null ? void 0 : e.uid, u = gs("indexedPanes"), h = Xe(() => u.value[c]), d = Ce(null), p = Xe(() => {
      const g = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(g, m.value), f.value);
    }), f = Xe(() => {
      const g = parseFloat(n.minSize);
      return isNaN(g) ? 0 : g;
    }), m = Xe(() => {
      const g = parseFloat(n.maxSize);
      return isNaN(g) ? 100 : g;
    }), _ = Xe(() => {
      var g;
      return `${o.value ? "height" : "width"}: ${(g = h.value) == null ? void 0 : g.size}%`;
    });
    return At(() => p.value, (g) => i({ uid: c, size: g })), At(() => f.value, (g) => i({ uid: c, min: g })), At(() => m.value, (g) => i({ uid: c, max: g })), Xn(() => {
      s({
        id: c,
        el: d.value,
        min: f.value,
        max: m.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : p.value,
        size: p.value
        // The computed current size at any time.
      });
    }), Lg(() => a(c)), (g, v) => (ie(), ue("div", {
      ref_key: "paneEl",
      ref: d,
      class: "splitpanes__pane",
      onClick: v[0] || (v[0] = (S) => Je(l)(S, g._.uid)),
      style: Ct(_.value)
    }, [
      FM(g.$slots, "default")
    ], 4));
  }
};
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Bg = "170", cT = 0, L0 = 1, uT = 2, Kx = 1, Jx = 2, rr = 3, ao = 0, Oi = 1, Pn = 2, Hs = 0, xs = 1, Gc = 2, fm = 3, Ja = 4, Fo = 5, vs = 100, Qx = 101, hT = 102, eb = 103, tb = 104, dT = 200, or = 201, fT = 202, pm = 203, md = 204, Hc = 205, pT = 206, mT = 207, gT = 208, nb = 209, vT = 210, yT = 211, _T = 212, xT = 213, bT = 214, mm = 0, gm = 1, vm = 2, al = 3, ym = 4, _m = 5, xm = 6, bm = 7, ib = 0, wT = 1, ST = 2, ro = 0, sb = 1, rb = 2, ob = 3, Ng = 4, MT = 5, ab = 6, lb = 7, cb = 300, ll = 301, cl = 302, wm = 303, Sm = 304, nf = 306, Mm = 1e3, Wo = 1001, Cm = 1002, ii = 1003, CT = 1004, Au = 1005, Kt = 1006, $f = 1007, jo = 1008, js = 1009, ub = 1010, hb = 1011, Wc = 1012, Vg = 1013, ta = 1014, Ii = 1015, po = 1016, Gg = 1017, Hg = 1018, ul = 1020, db = 35902, fb = 1021, pb = 1022, fi = 1023, mb = 1024, gb = 1025, Ko = 1026, hl = 1027, gd = 1028, Wg = 1029, vb = 1030, jg = 1031, $g = 1033, jh = 33776, $h = 33777, Xh = 33778, Yh = 33779, Tm = 35840, Em = 35841, Am = 35842, Pm = 35843, Dm = 36196, km = 37492, Rm = 37496, Lm = 37808, Im = 37809, Om = 37810, Fm = 37811, Um = 37812, zm = 37813, Bm = 37814, Nm = 37815, Vm = 37816, Gm = 37817, Hm = 37818, Wm = 37819, jm = 37820, $m = 37821, qh = 36492, Xm = 36494, Ym = 36495, yb = 36283, qm = 36284, Zm = 36285, Km = 36286, TT = 3200, Xg = 3201, Yg = 0, ET = 1, no = "", An = "srgb", _l = "srgb-linear", sf = "linear", nn = "srgb", da = 7680, I0 = 519, AT = 512, PT = 513, DT = 514, _b = 515, kT = 516, RT = 517, LT = 518, IT = 519, O0 = 35044, fa = 35048, F0 = "300 es", pr = 2e3, vd = 2001;
class sa {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const s = this._listeners[e];
    if (s !== void 0) {
      const o = s.indexOf(n);
      o !== -1 && s.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const s = i.slice(0);
      for (let o = 0, a = s.length; o < a; o++)
        s[o].call(this, e);
      e.target = null;
    }
  }
}
const oi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let U0 = 1234567;
const bc = Math.PI / 180, dl = 180 / Math.PI;
function ra() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (oi[r & 255] + oi[r >> 8 & 255] + oi[r >> 16 & 255] + oi[r >> 24 & 255] + "-" + oi[e & 255] + oi[e >> 8 & 255] + "-" + oi[e >> 16 & 15 | 64] + oi[e >> 24 & 255] + "-" + oi[n & 63 | 128] + oi[n >> 8 & 255] + "-" + oi[n >> 16 & 255] + oi[n >> 24 & 255] + oi[i & 255] + oi[i >> 8 & 255] + oi[i >> 16 & 255] + oi[i >> 24 & 255]).toLowerCase();
}
function ei(r, e, n) {
  return Math.max(e, Math.min(n, r));
}
function qg(r, e) {
  return (r % e + e) % e;
}
function OT(r, e, n, i, s) {
  return i + (r - e) * (s - i) / (n - e);
}
function FT(r, e, n) {
  return r !== e ? (n - r) / (e - r) : 0;
}
function wc(r, e, n) {
  return (1 - n) * r + n * e;
}
function UT(r, e, n, i) {
  return wc(r, e, 1 - Math.exp(-n * i));
}
function zT(r, e = 1) {
  return e - Math.abs(qg(r, e * 2) - e);
}
function BT(r, e, n) {
  return r <= e ? 0 : r >= n ? 1 : (r = (r - e) / (n - e), r * r * (3 - 2 * r));
}
function NT(r, e, n) {
  return r <= e ? 0 : r >= n ? 1 : (r = (r - e) / (n - e), r * r * r * (r * (r * 6 - 15) + 10));
}
function VT(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function GT(r, e) {
  return r + Math.random() * (e - r);
}
function HT(r) {
  return r * (0.5 - Math.random());
}
function WT(r) {
  r !== void 0 && (U0 = r);
  let e = U0 += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function jT(r) {
  return r * bc;
}
function $T(r) {
  return r * dl;
}
function XT(r) {
  return (r & r - 1) === 0 && r !== 0;
}
function YT(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function qT(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function ZT(r, e, n, i, s) {
  const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), u = o((e + i) / 2), h = a((e + i) / 2), d = o((e - i) / 2), p = a((e - i) / 2), f = o((i - e) / 2), m = a((i - e) / 2);
  switch (s) {
    case "XYX":
      r.set(l * h, c * d, c * p, l * u);
      break;
    case "YZY":
      r.set(c * p, l * h, c * d, l * u);
      break;
    case "ZXZ":
      r.set(c * d, c * p, l * h, l * u);
      break;
    case "XZX":
      r.set(l * h, c * m, c * f, l * u);
      break;
    case "YXY":
      r.set(c * f, l * h, c * m, l * u);
      break;
    case "ZYZ":
      r.set(c * m, c * f, l * h, l * u);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s);
  }
}
function Ia(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vi(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const En = {
  DEG2RAD: bc,
  RAD2DEG: dl,
  generateUUID: ra,
  clamp: ei,
  euclideanModulo: qg,
  mapLinear: OT,
  inverseLerp: FT,
  lerp: wc,
  damp: UT,
  pingpong: zT,
  smoothstep: BT,
  smootherstep: NT,
  randInt: VT,
  randFloat: GT,
  randFloatSpread: HT,
  seededRandom: WT,
  degToRad: jT,
  radToDeg: $T,
  isPowerOfTwo: XT,
  ceilPowerOfTwo: YT,
  floorPowerOfTwo: qT,
  setQuaternionFromProperEuler: ZT,
  normalize: vi,
  denormalize: Ia
};
class ct {
  constructor(e = 0, n = 0) {
    ct.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = e.elements;
    return this.x = s[0] * n + s[3] * i + s[6], this.y = s[1] * n + s[4] * i + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(ei(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), s = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * i - a * s + e.x, this.y = o * s + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Dt {
  constructor(e, n, i, s, o, a, l, c, u) {
    Dt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, s, o, a, l, c, u);
  }
  set(e, n, i, s, o, a, l, c, u) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = l, h[3] = n, h[4] = o, h[5] = c, h[6] = i, h[7] = a, h[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, o = this.elements, a = i[0], l = i[3], c = i[6], u = i[1], h = i[4], d = i[7], p = i[2], f = i[5], m = i[8], _ = s[0], g = s[3], v = s[6], S = s[1], b = s[4], x = s[7], M = s[2], C = s[5], E = s[8];
    return o[0] = a * _ + l * S + c * M, o[3] = a * g + l * b + c * C, o[6] = a * v + l * x + c * E, o[1] = u * _ + h * S + d * M, o[4] = u * g + h * b + d * C, o[7] = u * v + h * x + d * E, o[2] = p * _ + f * S + m * M, o[5] = p * g + f * b + m * C, o[8] = p * v + f * x + m * E, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], h = e[8];
    return n * a * h - n * l * u - i * o * h + i * l * c + s * o * u - s * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], h = e[8], d = h * a - l * u, p = l * c - h * o, f = u * o - a * c, m = n * d + i * p + s * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / m;
    return e[0] = d * _, e[1] = (s * u - h * i) * _, e[2] = (l * i - s * a) * _, e[3] = p * _, e[4] = (h * n - s * c) * _, e[5] = (s * o - l * n) * _, e[6] = f * _, e[7] = (i * c - u * n) * _, e[8] = (a * n - i * o) * _, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, s, o, a, l) {
    const c = Math.cos(o), u = Math.sin(o);
    return this.set(
      i * c,
      i * u,
      -i * (c * a + u * l) + a + e,
      -s * u,
      s * c,
      -s * (-u * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply(Xf.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(Xf.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(Xf.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 9; s++)
      if (n[s] !== i[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Xf = /* @__PURE__ */ new Dt();
function xb(r) {
  for (let e = r.length - 1; e >= 0; --e)
    if (r[e] >= 65535) return !0;
  return !1;
}
function jc(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function KT() {
  const r = jc("canvas");
  return r.style.display = "block", r;
}
const z0 = {};
function ac(r) {
  r in z0 || (z0[r] = !0, console.warn(r));
}
function JT(r, e, n) {
  return new Promise(function(i, s) {
    function o() {
      switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          s();
          break;
        case r.TIMEOUT_EXPIRED:
          setTimeout(o, n);
          break;
        default:
          i();
      }
    }
    setTimeout(o, n);
  });
}
function QT(r) {
  const e = r.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function e2(r) {
  const e = r.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Nt = {
  enabled: !0,
  workingColorSpace: _l,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(r, e, n) {
    return this.enabled === !1 || e === n || !e || !n || (this.spaces[e].transfer === nn && (r.r = _r(r.r), r.g = _r(r.g), r.b = _r(r.b)), this.spaces[e].primaries !== this.spaces[n].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === nn && (r.r = Qa(r.r), r.g = Qa(r.g), r.b = Qa(r.b))), r;
  },
  fromWorkingColorSpace: function(r, e) {
    return this.convert(r, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(r, e) {
    return this.convert(r, e, this.workingColorSpace);
  },
  getPrimaries: function(r) {
    return this.spaces[r].primaries;
  },
  getTransfer: function(r) {
    return r === no ? sf : this.spaces[r].transfer;
  },
  getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
    return r.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(r) {
    Object.assign(this.spaces, r);
  },
  // Internal APIs
  _getMatrix: function(r, e, n) {
    return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(r) {
    return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(r = this.workingColorSpace) {
    return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
  }
};
function _r(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Qa(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const B0 = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], N0 = [0.2126, 0.7152, 0.0722], V0 = [0.3127, 0.329], G0 = /* @__PURE__ */ new Dt().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), H0 = /* @__PURE__ */ new Dt().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Nt.define({
  [_l]: {
    primaries: B0,
    whitePoint: V0,
    transfer: sf,
    toXYZ: G0,
    fromXYZ: H0,
    luminanceCoefficients: N0,
    workingColorSpaceConfig: { unpackColorSpace: An },
    outputColorSpaceConfig: { drawingBufferColorSpace: An }
  },
  [An]: {
    primaries: B0,
    whitePoint: V0,
    transfer: nn,
    toXYZ: G0,
    fromXYZ: H0,
    luminanceCoefficients: N0,
    outputColorSpaceConfig: { drawingBufferColorSpace: An }
  }
});
let pa;
class t2 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      pa === void 0 && (pa = jc("canvas")), pa.width = e.width, pa.height = e.height;
      const i = pa.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = pa;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = jc("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const s = i.getImageData(0, 0, e.width, e.height), o = s.data;
      for (let a = 0; a < o.length; a++)
        o[a] = _r(o[a] / 255) * 255;
      return i.putImageData(s, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(_r(n[i] / 255) * 255) : n[i] = _r(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let n2 = 0;
class bb {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: n2++ }), this.uuid = ra(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, s = this.data;
    if (s !== null) {
      let o;
      if (Array.isArray(s)) {
        o = [];
        for (let a = 0, l = s.length; a < l; a++)
          s[a].isDataTexture ? o.push(Yf(s[a].image)) : o.push(Yf(s[a]));
      } else
        o = Yf(s);
      i.url = o;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function Yf(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? t2.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let i2 = 0;
class Fn extends sa {
  constructor(e = Fn.DEFAULT_IMAGE, n = Fn.DEFAULT_MAPPING, i = Wo, s = Wo, o = Kt, a = jo, l = fi, c = js, u = Fn.DEFAULT_ANISOTROPY, h = no) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: i2++ }), this.uuid = ra(), this.name = "", this.source = new bb(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = o, this.minFilter = a, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = c, this.offset = new ct(0, 0), this.repeat = new ct(1, 1), this.center = new ct(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Dt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== cb) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Mm:
          e.x = e.x - Math.floor(e.x);
          break;
        case Wo:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Cm:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Mm:
          e.y = e.y - Math.floor(e.y);
          break;
        case Wo:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Cm:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Fn.DEFAULT_IMAGE = null;
Fn.DEFAULT_MAPPING = cb;
Fn.DEFAULT_ANISOTROPY = 1;
class Jt {
  constructor(e = 0, n = 0, i = 0, s = 1) {
    Jt.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, s) {
    return this.x = e, this.y = n, this.z = i, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * s + a[12] * o, this.y = a[1] * n + a[5] * i + a[9] * s + a[13] * o, this.z = a[2] * n + a[6] * i + a[10] * s + a[14] * o, this.w = a[3] * n + a[7] * i + a[11] * s + a[15] * o, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, s, o;
    const c = e.elements, u = c[0], h = c[4], d = c[8], p = c[1], f = c[5], m = c[9], _ = c[2], g = c[6], v = c[10];
    if (Math.abs(h - p) < 0.01 && Math.abs(d - _) < 0.01 && Math.abs(m - g) < 0.01) {
      if (Math.abs(h + p) < 0.1 && Math.abs(d + _) < 0.1 && Math.abs(m + g) < 0.1 && Math.abs(u + f + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const b = (u + 1) / 2, x = (f + 1) / 2, M = (v + 1) / 2, C = (h + p) / 4, E = (d + _) / 4, T = (m + g) / 4;
      return b > x && b > M ? b < 0.01 ? (i = 0, s = 0.707106781, o = 0.707106781) : (i = Math.sqrt(b), s = C / i, o = E / i) : x > M ? x < 0.01 ? (i = 0.707106781, s = 0, o = 0.707106781) : (s = Math.sqrt(x), i = C / s, o = T / s) : M < 0.01 ? (i = 0.707106781, s = 0.707106781, o = 0) : (o = Math.sqrt(M), i = E / o, s = T / o), this.set(i, s, o, n), this;
    }
    let S = Math.sqrt((g - m) * (g - m) + (d - _) * (d - _) + (p - h) * (p - h));
    return Math.abs(S) < 1e-3 && (S = 1), this.x = (g - m) / S, this.y = (d - _) / S, this.z = (p - h) / S, this.w = Math.acos((u + f + v - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class s2 extends sa {
  constructor(e = 1, n = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new Jt(0, 0, e, n), this.scissorTest = !1, this.viewport = new Jt(0, 0, e, n);
    const s = { width: e, height: n, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Kt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const o = new Fn(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    o.flipY = !1, o.generateMipmaps = i.generateMipmaps, o.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let l = 0; l < a; l++)
      this.textures[l] = o.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let s = 0, o = this.textures.length; s < o; s++)
        this.textures[s].image.width = e, this.textures[s].image.height = n, this.textures[s].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, s = e.textures.length; i < s; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new bb(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Es extends s2 {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), this.isWebGLRenderTarget = !0;
  }
}
class wb extends Fn {
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = ii, this.minFilter = ii, this.wrapR = Wo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class r2 extends Fn {
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = ii, this.minFilter = ii, this.wrapR = Wo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class xi {
  constructor(e = 0, n = 0, i = 0, s = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = s;
  }
  static slerpFlat(e, n, i, s, o, a, l) {
    let c = i[s + 0], u = i[s + 1], h = i[s + 2], d = i[s + 3];
    const p = o[a + 0], f = o[a + 1], m = o[a + 2], _ = o[a + 3];
    if (l === 0) {
      e[n + 0] = c, e[n + 1] = u, e[n + 2] = h, e[n + 3] = d;
      return;
    }
    if (l === 1) {
      e[n + 0] = p, e[n + 1] = f, e[n + 2] = m, e[n + 3] = _;
      return;
    }
    if (d !== _ || c !== p || u !== f || h !== m) {
      let g = 1 - l;
      const v = c * p + u * f + h * m + d * _, S = v >= 0 ? 1 : -1, b = 1 - v * v;
      if (b > Number.EPSILON) {
        const M = Math.sqrt(b), C = Math.atan2(M, v * S);
        g = Math.sin(g * C) / M, l = Math.sin(l * C) / M;
      }
      const x = l * S;
      if (c = c * g + p * x, u = u * g + f * x, h = h * g + m * x, d = d * g + _ * x, g === 1 - l) {
        const M = 1 / Math.sqrt(c * c + u * u + h * h + d * d);
        c *= M, u *= M, h *= M, d *= M;
      }
    }
    e[n] = c, e[n + 1] = u, e[n + 2] = h, e[n + 3] = d;
  }
  static multiplyQuaternionsFlat(e, n, i, s, o, a) {
    const l = i[s], c = i[s + 1], u = i[s + 2], h = i[s + 3], d = o[a], p = o[a + 1], f = o[a + 2], m = o[a + 3];
    return e[n] = l * m + h * d + c * f - u * p, e[n + 1] = c * m + h * p + u * d - l * f, e[n + 2] = u * m + h * f + l * p - c * d, e[n + 3] = h * m - l * d - c * p - u * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, s) {
    return this._x = e, this._y = n, this._z = i, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const i = e._x, s = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, u = l(i / 2), h = l(s / 2), d = l(o / 2), p = c(i / 2), f = c(s / 2), m = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = p * h * d + u * f * m, this._y = u * f * d - p * h * m, this._z = u * h * m + p * f * d, this._w = u * h * d - p * f * m;
        break;
      case "YXZ":
        this._x = p * h * d + u * f * m, this._y = u * f * d - p * h * m, this._z = u * h * m - p * f * d, this._w = u * h * d + p * f * m;
        break;
      case "ZXY":
        this._x = p * h * d - u * f * m, this._y = u * f * d + p * h * m, this._z = u * h * m + p * f * d, this._w = u * h * d - p * f * m;
        break;
      case "ZYX":
        this._x = p * h * d - u * f * m, this._y = u * f * d + p * h * m, this._z = u * h * m - p * f * d, this._w = u * h * d + p * f * m;
        break;
      case "YZX":
        this._x = p * h * d + u * f * m, this._y = u * f * d + p * h * m, this._z = u * h * m - p * f * d, this._w = u * h * d - p * f * m;
        break;
      case "XZY":
        this._x = p * h * d - u * f * m, this._y = u * f * d - p * h * m, this._z = u * h * m + p * f * d, this._w = u * h * d + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, s = Math.sin(i);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], s = n[4], o = n[8], a = n[1], l = n[5], c = n[9], u = n[2], h = n[6], d = n[10], p = i + l + d;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (h - c) * f, this._y = (o - u) * f, this._z = (a - s) * f;
    } else if (i > l && i > d) {
      const f = 2 * Math.sqrt(1 + i - l - d);
      this._w = (h - c) / f, this._x = 0.25 * f, this._y = (s + a) / f, this._z = (o + u) / f;
    } else if (l > d) {
      const f = 2 * Math.sqrt(1 + l - i - d);
      this._w = (o - u) / f, this._x = (s + a) / f, this._y = 0.25 * f, this._z = (c + h) / f;
    } else {
      const f = 2 * Math.sqrt(1 + d - i - l);
      this._w = (a - s) / f, this._x = (o + u) / f, this._y = (c + h) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ei(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const s = Math.min(1, n / i);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, s = e._y, o = e._z, a = e._w, l = n._x, c = n._y, u = n._z, h = n._w;
    return this._x = i * h + a * l + s * u - o * c, this._y = s * h + a * c + o * l - i * u, this._z = o * h + a * u + i * c - s * l, this._w = a * h - i * l - s * c - o * u, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, s = this._y, o = this._z, a = this._w;
    let l = a * e._w + i * e._x + s * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = i, this._y = s, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const f = 1 - n;
      return this._w = f * a + n * this._w, this._x = f * i + n * this._x, this._y = f * s + n * this._y, this._z = f * o + n * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(c), h = Math.atan2(u, l), d = Math.sin((1 - n) * h) / u, p = Math.sin(n * h) / u;
    return this._w = a * d + this._w * p, this._x = i * d + this._x * p, this._y = s * d + this._y * p, this._z = o * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), s = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(
      s * Math.sin(e),
      s * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class he {
  constructor(e = 0, n = 0, i = 0) {
    he.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(W0.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(W0.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6] * s, this.y = o[1] * n + o[4] * i + o[7] * s, this.z = o[2] * n + o[5] * i + o[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * i + o[11] * s + o[15]);
    return this.x = (o[0] * n + o[4] * i + o[8] * s + o[12]) * a, this.y = (o[1] * n + o[5] * i + o[9] * s + o[13]) * a, this.z = (o[2] * n + o[6] * i + o[10] * s + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, s = this.z, o = e.x, a = e.y, l = e.z, c = e.w, u = 2 * (a * s - l * i), h = 2 * (l * n - o * s), d = 2 * (o * i - a * n);
    return this.x = n + c * u + a * d - l * h, this.y = i + c * h + l * u - o * d, this.z = s + c * d + o * h - a * u, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, s = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * i + o[8] * s, this.y = o[1] * n + o[5] * i + o[9] * s, this.z = o[2] * n + o[6] * i + o[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, s = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = s * c - o * l, this.y = o * a - i * c, this.z = i * l - s * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return qf.copy(this).projectOnVector(e), this.sub(qf);
  }
  reflect(e) {
    return this.sub(qf.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(ei(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, s = this.z - e.z;
    return n * n + i * i + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const s = Math.sin(n) * e;
    return this.x = s * Math.sin(i), this.y = Math.cos(n) * e, this.z = s * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = s, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const qf = /* @__PURE__ */ new he(), W0 = /* @__PURE__ */ new xi();
class mo {
  constructor(e = new he(1 / 0, 1 / 0, 1 / 0), n = new he(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(cs.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(cs.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = cs.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const o = i.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = o.count; a < l; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, cs) : cs.fromBufferAttribute(o, a), cs.applyMatrix4(e.matrixWorld), this.expandByPoint(cs);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Pu.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Pu.copy(i.boundingBox)), Pu.applyMatrix4(e.matrixWorld), this.union(Pu);
    }
    const s = e.children;
    for (let o = 0, a = s.length; o < a; o++)
      this.expandByObject(s[o], n);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, cs), cs.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Gl), Du.subVectors(this.max, Gl), ma.subVectors(e.a, Gl), ga.subVectors(e.b, Gl), va.subVectors(e.c, Gl), zr.subVectors(ga, ma), Br.subVectors(va, ga), bo.subVectors(ma, va);
    let n = [
      0,
      -zr.z,
      zr.y,
      0,
      -Br.z,
      Br.y,
      0,
      -bo.z,
      bo.y,
      zr.z,
      0,
      -zr.x,
      Br.z,
      0,
      -Br.x,
      bo.z,
      0,
      -bo.x,
      -zr.y,
      zr.x,
      0,
      -Br.y,
      Br.x,
      0,
      -bo.y,
      bo.x,
      0
    ];
    return !Zf(n, ma, ga, va, Du) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Zf(n, ma, ga, va, Du)) ? !1 : (ku.crossVectors(zr, Br), n = [ku.x, ku.y, ku.z], Zf(n, ma, ga, va, Du));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, cs).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(cs).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ks[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ks[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ks[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ks[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ks[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ks[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ks[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ks[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ks), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ks = [
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he(),
  /* @__PURE__ */ new he()
], cs = /* @__PURE__ */ new he(), Pu = /* @__PURE__ */ new mo(), ma = /* @__PURE__ */ new he(), ga = /* @__PURE__ */ new he(), va = /* @__PURE__ */ new he(), zr = /* @__PURE__ */ new he(), Br = /* @__PURE__ */ new he(), bo = /* @__PURE__ */ new he(), Gl = /* @__PURE__ */ new he(), Du = /* @__PURE__ */ new he(), ku = /* @__PURE__ */ new he(), wo = /* @__PURE__ */ new he();
function Zf(r, e, n, i, s) {
  for (let o = 0, a = r.length - 3; o <= a; o += 3) {
    wo.fromArray(r, o);
    const l = s.x * Math.abs(wo.x) + s.y * Math.abs(wo.y) + s.z * Math.abs(wo.z), c = e.dot(wo), u = n.dot(wo), h = i.dot(wo);
    if (Math.max(-Math.max(c, u, h), Math.min(c, u, h)) > l)
      return !1;
  }
  return !0;
}
const o2 = /* @__PURE__ */ new mo(), Hl = /* @__PURE__ */ new he(), Kf = /* @__PURE__ */ new he();
class cu {
  constructor(e = new he(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : o2.setFromPoints(e).getCenter(i);
    let s = 0;
    for (let o = 0, a = e.length; o < a; o++)
      s = Math.max(s, i.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Hl.subVectors(e, this.center);
    const n = Hl.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), s = (i - this.radius) * 0.5;
      this.center.addScaledVector(Hl, s / i), this.radius += s;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Kf.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Hl.copy(e.center).add(Kf)), this.expandByPoint(Hl.copy(e.center).sub(Kf))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Js = /* @__PURE__ */ new he(), Jf = /* @__PURE__ */ new he(), Ru = /* @__PURE__ */ new he(), Nr = /* @__PURE__ */ new he(), Qf = /* @__PURE__ */ new he(), Lu = /* @__PURE__ */ new he(), ep = /* @__PURE__ */ new he();
class Zg {
  constructor(e = new he(), n = new he(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Js)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = Js.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (Js.copy(this.origin).addScaledVector(this.direction, n), Js.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, s) {
    Jf.copy(e).add(n).multiplyScalar(0.5), Ru.copy(n).sub(e).normalize(), Nr.copy(this.origin).sub(Jf);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Ru), l = Nr.dot(this.direction), c = -Nr.dot(Ru), u = Nr.lengthSq(), h = Math.abs(1 - a * a);
    let d, p, f, m;
    if (h > 0)
      if (d = a * c - l, p = a * l - c, m = o * h, d >= 0)
        if (p >= -m)
          if (p <= m) {
            const _ = 1 / h;
            d *= _, p *= _, f = d * (d + a * p + 2 * l) + p * (a * d + p + 2 * c) + u;
          } else
            p = o, d = Math.max(0, -(a * p + l)), f = -d * d + p * (p + 2 * c) + u;
        else
          p = -o, d = Math.max(0, -(a * p + l)), f = -d * d + p * (p + 2 * c) + u;
      else
        p <= -m ? (d = Math.max(0, -(-a * o + l)), p = d > 0 ? -o : Math.min(Math.max(-o, -c), o), f = -d * d + p * (p + 2 * c) + u) : p <= m ? (d = 0, p = Math.min(Math.max(-o, -c), o), f = p * (p + 2 * c) + u) : (d = Math.max(0, -(a * o + l)), p = d > 0 ? o : Math.min(Math.max(-o, -c), o), f = -d * d + p * (p + 2 * c) + u);
    else
      p = a > 0 ? -o : o, d = Math.max(0, -(a * p + l)), f = -d * d + p * (p + 2 * c) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, d), s && s.copy(Jf).addScaledVector(Ru, p), f;
  }
  intersectSphere(e, n) {
    Js.subVectors(e.center, this.origin);
    const i = Js.dot(this.direction), s = Js.dot(Js) - i * i, o = e.radius * e.radius;
    if (s > o) return null;
    const a = Math.sqrt(o - s), l = i - a, c = i + a;
    return c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, s, o, a, l, c;
    const u = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return u >= 0 ? (i = (e.min.x - p.x) * u, s = (e.max.x - p.x) * u) : (i = (e.max.x - p.x) * u, s = (e.min.x - p.x) * u), h >= 0 ? (o = (e.min.y - p.y) * h, a = (e.max.y - p.y) * h) : (o = (e.max.y - p.y) * h, a = (e.min.y - p.y) * h), i > a || o > s || ((o > i || isNaN(i)) && (i = o), (a < s || isNaN(s)) && (s = a), d >= 0 ? (l = (e.min.z - p.z) * d, c = (e.max.z - p.z) * d) : (l = (e.max.z - p.z) * d, c = (e.min.z - p.z) * d), i > c || l > s) || ((l > i || i !== i) && (i = l), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(i >= 0 ? i : s, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Js) !== null;
  }
  intersectTriangle(e, n, i, s, o) {
    Qf.subVectors(n, e), Lu.subVectors(i, e), ep.crossVectors(Qf, Lu);
    let a = this.direction.dot(ep), l;
    if (a > 0) {
      if (s) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    Nr.subVectors(this.origin, e);
    const c = l * this.direction.dot(Lu.crossVectors(Nr, Lu));
    if (c < 0)
      return null;
    const u = l * this.direction.dot(Qf.cross(Nr));
    if (u < 0 || c + u > a)
      return null;
    const h = -l * Nr.dot(ep);
    return h < 0 ? null : this.at(h / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class rn {
  constructor(e, n, i, s, o, a, l, c, u, h, d, p, f, m, _, g) {
    rn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, s, o, a, l, c, u, h, d, p, f, m, _, g);
  }
  set(e, n, i, s, o, a, l, c, u, h, d, p, f, m, _, g) {
    const v = this.elements;
    return v[0] = e, v[4] = n, v[8] = i, v[12] = s, v[1] = o, v[5] = a, v[9] = l, v[13] = c, v[2] = u, v[6] = h, v[10] = d, v[14] = p, v[3] = f, v[7] = m, v[11] = _, v[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new rn().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, s = 1 / ya.setFromMatrixColumn(e, 0).length(), o = 1 / ya.setFromMatrixColumn(e, 1).length(), a = 1 / ya.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * s, n[1] = i[1] * s, n[2] = i[2] * s, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, s = e.y, o = e.z, a = Math.cos(i), l = Math.sin(i), c = Math.cos(s), u = Math.sin(s), h = Math.cos(o), d = Math.sin(o);
    if (e.order === "XYZ") {
      const p = a * h, f = a * d, m = l * h, _ = l * d;
      n[0] = c * h, n[4] = -c * d, n[8] = u, n[1] = f + m * u, n[5] = p - _ * u, n[9] = -l * c, n[2] = _ - p * u, n[6] = m + f * u, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const p = c * h, f = c * d, m = u * h, _ = u * d;
      n[0] = p + _ * l, n[4] = m * l - f, n[8] = a * u, n[1] = a * d, n[5] = a * h, n[9] = -l, n[2] = f * l - m, n[6] = _ + p * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const p = c * h, f = c * d, m = u * h, _ = u * d;
      n[0] = p - _ * l, n[4] = -a * d, n[8] = m + f * l, n[1] = f + m * l, n[5] = a * h, n[9] = _ - p * l, n[2] = -a * u, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const p = a * h, f = a * d, m = l * h, _ = l * d;
      n[0] = c * h, n[4] = m * u - f, n[8] = p * u + _, n[1] = c * d, n[5] = _ * u + p, n[9] = f * u - m, n[2] = -u, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const p = a * c, f = a * u, m = l * c, _ = l * u;
      n[0] = c * h, n[4] = _ - p * d, n[8] = m * d + f, n[1] = d, n[5] = a * h, n[9] = -l * h, n[2] = -u * h, n[6] = f * d + m, n[10] = p - _ * d;
    } else if (e.order === "XZY") {
      const p = a * c, f = a * u, m = l * c, _ = l * u;
      n[0] = c * h, n[4] = -d, n[8] = u * h, n[1] = p * d + _, n[5] = a * h, n[9] = f * d - m, n[2] = m * d - f, n[6] = l * h, n[10] = _ * d + p;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(a2, e, l2);
  }
  lookAt(e, n, i) {
    const s = this.elements;
    return Wi.subVectors(e, n), Wi.lengthSq() === 0 && (Wi.z = 1), Wi.normalize(), Vr.crossVectors(i, Wi), Vr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Wi.x += 1e-4 : Wi.z += 1e-4, Wi.normalize(), Vr.crossVectors(i, Wi)), Vr.normalize(), Iu.crossVectors(Wi, Vr), s[0] = Vr.x, s[4] = Iu.x, s[8] = Wi.x, s[1] = Vr.y, s[5] = Iu.y, s[9] = Wi.y, s[2] = Vr.z, s[6] = Iu.z, s[10] = Wi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, o = this.elements, a = i[0], l = i[4], c = i[8], u = i[12], h = i[1], d = i[5], p = i[9], f = i[13], m = i[2], _ = i[6], g = i[10], v = i[14], S = i[3], b = i[7], x = i[11], M = i[15], C = s[0], E = s[4], T = s[8], w = s[12], A = s[1], O = s[5], U = s[9], D = s[13], L = s[2], P = s[6], V = s[10], ce = s[14], q = s[3], oe = s[7], ne = s[11], $ = s[15];
    return o[0] = a * C + l * A + c * L + u * q, o[4] = a * E + l * O + c * P + u * oe, o[8] = a * T + l * U + c * V + u * ne, o[12] = a * w + l * D + c * ce + u * $, o[1] = h * C + d * A + p * L + f * q, o[5] = h * E + d * O + p * P + f * oe, o[9] = h * T + d * U + p * V + f * ne, o[13] = h * w + d * D + p * ce + f * $, o[2] = m * C + _ * A + g * L + v * q, o[6] = m * E + _ * O + g * P + v * oe, o[10] = m * T + _ * U + g * V + v * ne, o[14] = m * w + _ * D + g * ce + v * $, o[3] = S * C + b * A + x * L + M * q, o[7] = S * E + b * O + x * P + M * oe, o[11] = S * T + b * U + x * V + M * ne, o[15] = S * w + b * D + x * ce + M * $, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], s = e[8], o = e[12], a = e[1], l = e[5], c = e[9], u = e[13], h = e[2], d = e[6], p = e[10], f = e[14], m = e[3], _ = e[7], g = e[11], v = e[15];
    return m * (+o * c * d - s * u * d - o * l * p + i * u * p + s * l * f - i * c * f) + _ * (+n * c * f - n * u * p + o * a * p - s * a * f + s * u * h - o * c * h) + g * (+n * u * d - n * l * f - o * a * d + i * a * f + o * l * h - i * u * h) + v * (-s * l * h - n * c * d + n * l * p + s * a * d - i * a * p + i * c * h);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = n, s[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], h = e[8], d = e[9], p = e[10], f = e[11], m = e[12], _ = e[13], g = e[14], v = e[15], S = d * g * u - _ * p * u + _ * c * f - l * g * f - d * c * v + l * p * v, b = m * p * u - h * g * u - m * c * f + a * g * f + h * c * v - a * p * v, x = h * _ * u - m * d * u + m * l * f - a * _ * f - h * l * v + a * d * v, M = m * d * c - h * _ * c - m * l * p + a * _ * p + h * l * g - a * d * g, C = n * S + i * b + s * x + o * M;
    if (C === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / C;
    return e[0] = S * E, e[1] = (_ * p * o - d * g * o - _ * s * f + i * g * f + d * s * v - i * p * v) * E, e[2] = (l * g * o - _ * c * o + _ * s * u - i * g * u - l * s * v + i * c * v) * E, e[3] = (d * c * o - l * p * o - d * s * u + i * p * u + l * s * f - i * c * f) * E, e[4] = b * E, e[5] = (h * g * o - m * p * o + m * s * f - n * g * f - h * s * v + n * p * v) * E, e[6] = (m * c * o - a * g * o - m * s * u + n * g * u + a * s * v - n * c * v) * E, e[7] = (a * p * o - h * c * o + h * s * u - n * p * u - a * s * f + n * c * f) * E, e[8] = x * E, e[9] = (m * d * o - h * _ * o - m * i * f + n * _ * f + h * i * v - n * d * v) * E, e[10] = (a * _ * o - m * l * o + m * i * u - n * _ * u - a * i * v + n * l * v) * E, e[11] = (h * l * o - a * d * o - h * i * u + n * d * u + a * i * f - n * l * f) * E, e[12] = M * E, e[13] = (h * _ * s - m * d * s + m * i * p - n * _ * p - h * i * g + n * d * g) * E, e[14] = (m * l * s - a * _ * s - m * i * c + n * _ * c + a * i * g - n * l * g) * E, e[15] = (a * d * s - h * l * s + h * i * c - n * d * c - a * i * p + n * l * p) * E, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, s = e.y, o = e.z;
    return n[0] *= i, n[4] *= s, n[8] *= o, n[1] *= i, n[5] *= s, n[9] *= o, n[2] *= i, n[6] *= s, n[10] *= o, n[3] *= i, n[7] *= s, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, s));
  }
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), s = Math.sin(n), o = 1 - i, a = e.x, l = e.y, c = e.z, u = o * a, h = o * l;
    return this.set(
      u * a + i,
      u * l - s * c,
      u * c + s * l,
      0,
      u * l + s * c,
      h * l + i,
      h * c - s * a,
      0,
      u * c - s * l,
      h * c + s * a,
      o * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, i, s, o, a) {
    return this.set(
      1,
      i,
      o,
      0,
      e,
      1,
      a,
      0,
      n,
      s,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, i) {
    const s = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, u = o + o, h = a + a, d = l + l, p = o * u, f = o * h, m = o * d, _ = a * h, g = a * d, v = l * d, S = c * u, b = c * h, x = c * d, M = i.x, C = i.y, E = i.z;
    return s[0] = (1 - (_ + v)) * M, s[1] = (f + x) * M, s[2] = (m - b) * M, s[3] = 0, s[4] = (f - x) * C, s[5] = (1 - (p + v)) * C, s[6] = (g + S) * C, s[7] = 0, s[8] = (m + b) * E, s[9] = (g - S) * E, s[10] = (1 - (p + _)) * E, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, n, i) {
    const s = this.elements;
    let o = ya.set(s[0], s[1], s[2]).length();
    const a = ya.set(s[4], s[5], s[6]).length(), l = ya.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (o = -o), e.x = s[12], e.y = s[13], e.z = s[14], us.copy(this);
    const u = 1 / o, h = 1 / a, d = 1 / l;
    return us.elements[0] *= u, us.elements[1] *= u, us.elements[2] *= u, us.elements[4] *= h, us.elements[5] *= h, us.elements[6] *= h, us.elements[8] *= d, us.elements[9] *= d, us.elements[10] *= d, n.setFromRotationMatrix(us), i.x = o, i.y = a, i.z = l, this;
  }
  makePerspective(e, n, i, s, o, a, l = pr) {
    const c = this.elements, u = 2 * o / (n - e), h = 2 * o / (i - s), d = (n + e) / (n - e), p = (i + s) / (i - s);
    let f, m;
    if (l === pr)
      f = -(a + o) / (a - o), m = -2 * a * o / (a - o);
    else if (l === vd)
      f = -a / (a - o), m = -a * o / (a - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = u, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = h, c[9] = p, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = m, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, n, i, s, o, a, l = pr) {
    const c = this.elements, u = 1 / (n - e), h = 1 / (i - s), d = 1 / (a - o), p = (n + e) * u, f = (i + s) * h;
    let m, _;
    if (l === pr)
      m = (a + o) * d, _ = -2 * d;
    else if (l === vd)
      m = o * d, _ = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * u, c[4] = 0, c[8] = 0, c[12] = -p, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = _, c[14] = -m, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 16; s++)
      if (n[s] !== i[s]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const ya = /* @__PURE__ */ new he(), us = /* @__PURE__ */ new rn(), a2 = /* @__PURE__ */ new he(0, 0, 0), l2 = /* @__PURE__ */ new he(1, 1, 1), Vr = /* @__PURE__ */ new he(), Iu = /* @__PURE__ */ new he(), Wi = /* @__PURE__ */ new he(), j0 = /* @__PURE__ */ new rn(), $0 = /* @__PURE__ */ new xi();
class Zi {
  constructor(e = 0, n = 0, i = 0, s = Zi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, s = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const s = e.elements, o = s[0], a = s[4], l = s[8], c = s[1], u = s[5], h = s[9], d = s[2], p = s[6], f = s[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(ei(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-ei(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-d, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(ei(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-ei(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u));
        break;
      case "YZX":
        this._z = Math.asin(ei(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-d, o)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-ei(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return j0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(j0, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return $0.setFromEuler(this), this.setFromQuaternion($0, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Zi.DEFAULT_ORDER = "XYZ";
class Kg {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let c2 = 0;
const X0 = /* @__PURE__ */ new he(), _a = /* @__PURE__ */ new xi(), Qs = /* @__PURE__ */ new rn(), Ou = /* @__PURE__ */ new he(), Wl = /* @__PURE__ */ new he(), u2 = /* @__PURE__ */ new he(), h2 = /* @__PURE__ */ new xi(), Y0 = /* @__PURE__ */ new he(1, 0, 0), q0 = /* @__PURE__ */ new he(0, 1, 0), Z0 = /* @__PURE__ */ new he(0, 0, 1), K0 = { type: "added" }, d2 = { type: "removed" }, xa = { type: "childadded", child: null }, tp = { type: "childremoved", child: null };
class vn extends sa {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: c2++ }), this.uuid = ra(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vn.DEFAULT_UP.clone();
    const e = new he(), n = new Zi(), i = new xi(), s = new he(1, 1, 1);
    function o() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(o), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: s
      },
      modelViewMatrix: {
        value: new rn()
      },
      normalMatrix: {
        value: new Dt()
      }
    }), this.matrix = new rn(), this.matrixWorld = new rn(), this.matrixAutoUpdate = vn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Kg(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return _a.setFromAxisAngle(e, n), this.quaternion.multiply(_a), this;
  }
  rotateOnWorldAxis(e, n) {
    return _a.setFromAxisAngle(e, n), this.quaternion.premultiply(_a), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Y0, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(q0, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Z0, e);
  }
  translateOnAxis(e, n) {
    return X0.copy(e).applyQuaternion(this.quaternion), this.position.add(X0.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Y0, e);
  }
  translateY(e) {
    return this.translateOnAxis(q0, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Z0, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Qs.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? Ou.copy(e) : Ou.set(e, n, i);
    const s = this.parent;
    this.updateWorldMatrix(!0, !1), Wl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Qs.lookAt(Wl, Ou, this.up) : Qs.lookAt(Ou, Wl, this.up), this.quaternion.setFromRotationMatrix(Qs), s && (Qs.extractRotation(s.matrixWorld), _a.setFromRotationMatrix(Qs), this.quaternion.premultiply(_a.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(K0), xa.child = e, this.dispatchEvent(xa), xa.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(d2), tp.child = e, this.dispatchEvent(tp), tp.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Qs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Qs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Qs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(K0), xa.child = e, this.dispatchEvent(xa), xa.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, s = this.children.length; i < s; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const s = this.children;
    for (let o = 0, a = s.length; o < a; o++)
      s[o].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wl, e, u2), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Wl, h2, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++)
      n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const s = this.children;
      for (let o = 0, a = s.length; o < a; o++)
        s[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
      center: s.boundingSphere.center.toArray(),
      radius: s.boundingSphere.radius
    }), this.boundingBox !== null && (s.boundingBox = {
      min: s.boundingBox.min.toArray(),
      max: s.boundingBox.max.toArray()
    }));
    function o(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, h = c.length; u < h; u++) {
            const d = c[u];
            o(e.shapes, d);
          }
        else
          o(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(o(e.materials, this.material[c]));
        s.material = l;
      } else
        s.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let l = 0; l < this.children.length; l++)
        s.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        s.animations.push(o(e.animations, c));
      }
    }
    if (n) {
      const l = a(e.geometries), c = a(e.materials), u = a(e.textures), h = a(e.images), d = a(e.shapes), p = a(e.skeletons), f = a(e.animations), m = a(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), u.length > 0 && (i.textures = u), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), p.length > 0 && (i.skeletons = p), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m);
    }
    return i.object = s, i;
    function a(l) {
      const c = [];
      for (const u in l) {
        const h = l[u];
        delete h.metadata, c.push(h);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const s = e.children[i];
        this.add(s.clone());
      }
    return this;
  }
}
vn.DEFAULT_UP = /* @__PURE__ */ new he(0, 1, 0);
vn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const hs = /* @__PURE__ */ new he(), er = /* @__PURE__ */ new he(), np = /* @__PURE__ */ new he(), tr = /* @__PURE__ */ new he(), ba = /* @__PURE__ */ new he(), wa = /* @__PURE__ */ new he(), J0 = /* @__PURE__ */ new he(), ip = /* @__PURE__ */ new he(), sp = /* @__PURE__ */ new he(), rp = /* @__PURE__ */ new he(), op = /* @__PURE__ */ new Jt(), ap = /* @__PURE__ */ new Jt(), lp = /* @__PURE__ */ new Jt();
class ys {
  constructor(e = new he(), n = new he(), i = new he()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, s) {
    s.subVectors(i, n), hs.subVectors(e, n), s.cross(hs);
    const o = s.lengthSq();
    return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, i, s, o) {
    hs.subVectors(s, n), er.subVectors(i, n), np.subVectors(e, n);
    const a = hs.dot(hs), l = hs.dot(er), c = hs.dot(np), u = er.dot(er), h = er.dot(np), d = a * u - l * l;
    if (d === 0)
      return o.set(0, 0, 0), null;
    const p = 1 / d, f = (u * c - l * h) * p, m = (a * h - l * c) * p;
    return o.set(1 - f - m, m, f);
  }
  static containsPoint(e, n, i, s) {
    return this.getBarycoord(e, n, i, s, tr) === null ? !1 : tr.x >= 0 && tr.y >= 0 && tr.x + tr.y <= 1;
  }
  static getInterpolation(e, n, i, s, o, a, l, c) {
    return this.getBarycoord(e, n, i, s, tr) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(o, tr.x), c.addScaledVector(a, tr.y), c.addScaledVector(l, tr.z), c);
  }
  static getInterpolatedAttribute(e, n, i, s, o, a) {
    return op.setScalar(0), ap.setScalar(0), lp.setScalar(0), op.fromBufferAttribute(e, n), ap.fromBufferAttribute(e, i), lp.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(op, o.x), a.addScaledVector(ap, o.y), a.addScaledVector(lp, o.z), a;
  }
  static isFrontFacing(e, n, i, s) {
    return hs.subVectors(i, n), er.subVectors(e, n), hs.cross(er).dot(s) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, s) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, n, i, s) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return hs.subVectors(this.c, this.b), er.subVectors(this.a, this.b), hs.cross(er).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ys.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return ys.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, s, o) {
    return ys.getInterpolation(e, this.a, this.b, this.c, n, i, s, o);
  }
  containsPoint(e) {
    return ys.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ys.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, s = this.b, o = this.c;
    let a, l;
    ba.subVectors(s, i), wa.subVectors(o, i), ip.subVectors(e, i);
    const c = ba.dot(ip), u = wa.dot(ip);
    if (c <= 0 && u <= 0)
      return n.copy(i);
    sp.subVectors(e, s);
    const h = ba.dot(sp), d = wa.dot(sp);
    if (h >= 0 && d <= h)
      return n.copy(s);
    const p = c * d - h * u;
    if (p <= 0 && c >= 0 && h <= 0)
      return a = c / (c - h), n.copy(i).addScaledVector(ba, a);
    rp.subVectors(e, o);
    const f = ba.dot(rp), m = wa.dot(rp);
    if (m >= 0 && f <= m)
      return n.copy(o);
    const _ = f * u - c * m;
    if (_ <= 0 && u >= 0 && m <= 0)
      return l = u / (u - m), n.copy(i).addScaledVector(wa, l);
    const g = h * m - f * d;
    if (g <= 0 && d - h >= 0 && f - m >= 0)
      return J0.subVectors(o, s), l = (d - h) / (d - h + (f - m)), n.copy(s).addScaledVector(J0, l);
    const v = 1 / (g + _ + p);
    return a = _ * v, l = p * v, n.copy(i).addScaledVector(ba, a).addScaledVector(wa, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Sb = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Gr = { h: 0, s: 0, l: 0 }, Fu = { h: 0, s: 0, l: 0 };
function cp(r, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + (e - r) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - n) : r;
}
class Tt {
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = An) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Nt.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, s = Nt.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, Nt.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, n, i, s = Nt.workingColorSpace) {
    if (e = qg(e, 1), n = ei(n, 0, 1), i = ei(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o;
      this.r = cp(a, o, e + 1 / 3), this.g = cp(a, o, e), this.b = cp(a, o, e - 1 / 3);
    }
    return Nt.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, n = An) {
    function i(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const a = s[1], l = s[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              n
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = s[1], a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6)
        return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = An) {
    const i = Sb[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = _r(e.r), this.g = _r(e.g), this.b = _r(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Qa(e.r), this.g = Qa(e.g), this.b = Qa(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = An) {
    return Nt.fromWorkingColorSpace(ai.copy(this), e), Math.round(ei(ai.r * 255, 0, 255)) * 65536 + Math.round(ei(ai.g * 255, 0, 255)) * 256 + Math.round(ei(ai.b * 255, 0, 255));
  }
  getHexString(e = An) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = Nt.workingColorSpace) {
    Nt.fromWorkingColorSpace(ai.copy(this), n);
    const i = ai.r, s = ai.g, o = ai.b, a = Math.max(i, s, o), l = Math.min(i, s, o);
    let c, u;
    const h = (l + a) / 2;
    if (l === a)
      c = 0, u = 0;
    else {
      const d = a - l;
      switch (u = h <= 0.5 ? d / (a + l) : d / (2 - a - l), a) {
        case i:
          c = (s - o) / d + (s < o ? 6 : 0);
          break;
        case s:
          c = (o - i) / d + 2;
          break;
        case o:
          c = (i - s) / d + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = u, e.l = h, e;
  }
  getRGB(e, n = Nt.workingColorSpace) {
    return Nt.fromWorkingColorSpace(ai.copy(this), n), e.r = ai.r, e.g = ai.g, e.b = ai.b, e;
  }
  getStyle(e = An) {
    Nt.fromWorkingColorSpace(ai.copy(this), e);
    const n = ai.r, i = ai.g, s = ai.b;
    return e !== An ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(Gr), this.setHSL(Gr.h + e, Gr.s + n, Gr.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Gr), e.getHSL(Fu);
    const i = wc(Gr.h, Fu.h, n), s = wc(Gr.s, Fu.s, n), o = wc(Gr.l, Fu.l, n);
    return this.setHSL(i, s, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, i = this.g, s = this.b, o = e.elements;
    return this.r = o[0] * n + o[3] * i + o[6] * s, this.g = o[1] * n + o[4] * i + o[7] * s, this.b = o[2] * n + o[5] * i + o[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ai = /* @__PURE__ */ new Tt();
Tt.NAMES = Sb;
let f2 = 0;
class oa extends sa {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: f2++ }), this.uuid = ra(), this.name = "", this.blending = xs, this.side = ao, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = md, this.blendDst = Hc, this.blendEquation = vs, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Tt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = al, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = I0, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = da, this.stencilZFail = da, this.stencilZPass = da, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const s = this[n];
        if (s === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[n] = i;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== xs && (i.blending = this.blending), this.side !== ao && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== md && (i.blendSrc = this.blendSrc), this.blendDst !== Hc && (i.blendDst = this.blendDst), this.blendEquation !== vs && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== al && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== I0 && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== da && (i.stencilFail = this.stencilFail), this.stencilZFail !== da && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== da && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function s(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (n) {
      const o = s(e.textures), a = s(e.images);
      o.length > 0 && (i.textures = o), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const s = n.length;
      i = new Array(s);
      for (let o = 0; o !== s; ++o)
        i[o] = n[o].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Gn extends oa {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.combine = ib, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Bn = /* @__PURE__ */ new he(), Uu = /* @__PURE__ */ new ct();
class qi {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = O0, this.updateRanges = [], this.gpuType = Ii, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let s = 0, o = this.itemSize; s < o; s++)
      this.array[e + s] = n.array[i + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        Uu.fromBufferAttribute(this, n), Uu.applyMatrix3(e), this.setXY(n, Uu.x, Uu.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Bn.fromBufferAttribute(this, n), Bn.applyMatrix3(e), this.setXYZ(n, Bn.x, Bn.y, Bn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Bn.fromBufferAttribute(this, n), Bn.applyMatrix4(e), this.setXYZ(n, Bn.x, Bn.y, Bn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Bn.fromBufferAttribute(this, n), Bn.applyNormalMatrix(e), this.setXYZ(n, Bn.x, Bn.y, Bn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Bn.fromBufferAttribute(this, n), Bn.transformDirection(e), this.setXYZ(n, Bn.x, Bn.y, Bn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = Ia(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return this.normalized && (i = vi(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Ia(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = vi(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Ia(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = vi(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Ia(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = vi(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Ia(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = vi(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = vi(n, this.array), i = vi(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, s) {
    return e *= this.itemSize, this.normalized && (n = vi(n, this.array), i = vi(i, this.array), s = vi(s, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this;
  }
  setXYZW(e, n, i, s, o) {
    return e *= this.itemSize, this.normalized && (n = vi(n, this.array), i = vi(i, this.array), s = vi(s, this.array), o = vi(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== O0 && (e.usage = this.usage), e;
  }
}
class Mb extends qi {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class Cb extends qi {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Ot extends qi {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let p2 = 0;
const Ki = /* @__PURE__ */ new rn(), up = /* @__PURE__ */ new vn(), Sa = /* @__PURE__ */ new he(), ji = /* @__PURE__ */ new mo(), jl = /* @__PURE__ */ new mo(), Yn = /* @__PURE__ */ new he();
class Wt extends sa {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: p2++ }), this.uuid = ra(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (xb(e) ? Cb : Mb)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new Dt().getNormalMatrix(e);
      i.applyNormalMatrix(o), i.needsUpdate = !0;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ki.makeRotationFromQuaternion(e), this.applyMatrix4(Ki), this;
  }
  rotateX(e) {
    return Ki.makeRotationX(e), this.applyMatrix4(Ki), this;
  }
  rotateY(e) {
    return Ki.makeRotationY(e), this.applyMatrix4(Ki), this;
  }
  rotateZ(e) {
    return Ki.makeRotationZ(e), this.applyMatrix4(Ki), this;
  }
  translate(e, n, i) {
    return Ki.makeTranslation(e, n, i), this.applyMatrix4(Ki), this;
  }
  scale(e, n, i) {
    return Ki.makeScale(e, n, i), this.applyMatrix4(Ki), this;
  }
  lookAt(e) {
    return up.lookAt(e), up.updateMatrix(), this.applyMatrix4(up.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Sa).negate(), this.translate(Sa.x, Sa.y, Sa.z), this;
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Ot(i, 3));
    } else {
      for (let i = 0, s = n.count; i < s; i++) {
        const o = e[i];
        n.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new mo());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new he(-1 / 0, -1 / 0, -1 / 0),
        new he(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, s = n.length; i < s; i++) {
          const o = n[i];
          ji.setFromBufferAttribute(o), this.morphTargetsRelative ? (Yn.addVectors(this.boundingBox.min, ji.min), this.boundingBox.expandByPoint(Yn), Yn.addVectors(this.boundingBox.max, ji.max), this.boundingBox.expandByPoint(Yn)) : (this.boundingBox.expandByPoint(ji.min), this.boundingBox.expandByPoint(ji.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new cu());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new he(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (ji.setFromBufferAttribute(e), n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o];
          jl.setFromBufferAttribute(l), this.morphTargetsRelative ? (Yn.addVectors(ji.min, jl.min), ji.expandByPoint(Yn), Yn.addVectors(ji.max, jl.max), ji.expandByPoint(Yn)) : (ji.expandByPoint(jl.min), ji.expandByPoint(jl.max));
        }
      ji.getCenter(i);
      let s = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Yn.fromBufferAttribute(e, o), s = Math.max(s, i.distanceToSquared(Yn));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o], c = this.morphTargetsRelative;
          for (let u = 0, h = l.count; u < h; u++)
            Yn.fromBufferAttribute(l, u), c && (Sa.fromBufferAttribute(e, u), Yn.add(Sa)), s = Math.max(s, i.distanceToSquared(Yn));
        }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, s = n.normal, o = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new qi(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), l = [], c = [];
    for (let T = 0; T < i.count; T++)
      l[T] = new he(), c[T] = new he();
    const u = new he(), h = new he(), d = new he(), p = new ct(), f = new ct(), m = new ct(), _ = new he(), g = new he();
    function v(T, w, A) {
      u.fromBufferAttribute(i, T), h.fromBufferAttribute(i, w), d.fromBufferAttribute(i, A), p.fromBufferAttribute(o, T), f.fromBufferAttribute(o, w), m.fromBufferAttribute(o, A), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
      const O = 1 / (f.x * m.y - m.x * f.y);
      isFinite(O) && (_.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(O), g.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(O), l[T].add(_), l[w].add(_), l[A].add(_), c[T].add(g), c[w].add(g), c[A].add(g));
    }
    let S = this.groups;
    S.length === 0 && (S = [{
      start: 0,
      count: e.count
    }]);
    for (let T = 0, w = S.length; T < w; ++T) {
      const A = S[T], O = A.start, U = A.count;
      for (let D = O, L = O + U; D < L; D += 3)
        v(
          e.getX(D + 0),
          e.getX(D + 1),
          e.getX(D + 2)
        );
    }
    const b = new he(), x = new he(), M = new he(), C = new he();
    function E(T) {
      M.fromBufferAttribute(s, T), C.copy(M);
      const w = l[T];
      b.copy(w), b.sub(M.multiplyScalar(M.dot(w))).normalize(), x.crossVectors(C, w);
      const O = x.dot(c[T]) < 0 ? -1 : 1;
      a.setXYZW(T, b.x, b.y, b.z, O);
    }
    for (let T = 0, w = S.length; T < w; ++T) {
      const A = S[T], O = A.start, U = A.count;
      for (let D = O, L = O + U; D < L; D += 3)
        E(e.getX(D + 0)), E(e.getX(D + 1)), E(e.getX(D + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new qi(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let p = 0, f = i.count; p < f; p++)
          i.setXYZ(p, 0, 0, 0);
      const s = new he(), o = new he(), a = new he(), l = new he(), c = new he(), u = new he(), h = new he(), d = new he();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), _ = e.getX(p + 1), g = e.getX(p + 2);
          s.fromBufferAttribute(n, m), o.fromBufferAttribute(n, _), a.fromBufferAttribute(n, g), h.subVectors(a, o), d.subVectors(s, o), h.cross(d), l.fromBufferAttribute(i, m), c.fromBufferAttribute(i, _), u.fromBufferAttribute(i, g), l.add(h), c.add(h), u.add(h), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(_, c.x, c.y, c.z), i.setXYZ(g, u.x, u.y, u.z);
        }
      else
        for (let p = 0, f = n.count; p < f; p += 3)
          s.fromBufferAttribute(n, p + 0), o.fromBufferAttribute(n, p + 1), a.fromBufferAttribute(n, p + 2), h.subVectors(a, o), d.subVectors(s, o), h.cross(d), i.setXYZ(p + 0, h.x, h.y, h.z), i.setXYZ(p + 1, h.x, h.y, h.z), i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Yn.fromBufferAttribute(e, n), Yn.normalize(), e.setXYZ(n, Yn.x, Yn.y, Yn.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array, h = l.itemSize, d = l.normalized, p = new u.constructor(c.length * h);
      let f = 0, m = 0;
      for (let _ = 0, g = c.length; _ < g; _++) {
        l.isInterleavedBufferAttribute ? f = c[_] * l.data.stride + l.offset : f = c[_] * h;
        for (let v = 0; v < h; v++)
          p[m++] = u[f++];
      }
      return new qi(p, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Wt(), i = this.index.array, s = this.attributes;
    for (const l in s) {
      const c = s[l], u = e(c, i);
      n.setAttribute(l, u);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const c = [], u = o[l];
      for (let h = 0, d = u.length; h < d; h++) {
        const p = u[h], f = e(p, i);
        c.push(f);
      }
      n.morphAttributes[l] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      n.addGroup(u.start, u.count, u.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const u in c)
        c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const u = i[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const s = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c], h = [];
      for (let d = 0, p = u.length; d < p; d++) {
        const f = u[d];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && (s[c] = h, o = !0);
    }
    o && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const s = e.attributes;
    for (const u in s) {
      const h = s[u];
      this.setAttribute(u, h.clone(n));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const h = [], d = o[u];
      for (let p = 0, f = d.length; p < f; p++)
        h.push(d[p].clone(n));
      this.morphAttributes[u] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let u = 0, h = a.length; u < h; u++) {
      const d = a[u];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Q0 = /* @__PURE__ */ new rn(), So = /* @__PURE__ */ new Zg(), zu = /* @__PURE__ */ new cu(), ey = /* @__PURE__ */ new he(), Bu = /* @__PURE__ */ new he(), Nu = /* @__PURE__ */ new he(), Vu = /* @__PURE__ */ new he(), hp = /* @__PURE__ */ new he(), Gu = /* @__PURE__ */ new he(), ty = /* @__PURE__ */ new he(), Hu = /* @__PURE__ */ new he();
class tt extends vn {
  constructor(e = new Wt(), n = new Gn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const s = n[i[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = s.length; o < a; o++) {
          const l = s[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry, s = i.attributes.position, o = i.morphAttributes.position, a = i.morphTargetsRelative;
    n.fromBufferAttribute(s, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      Gu.set(0, 0, 0);
      for (let c = 0, u = o.length; c < u; c++) {
        const h = l[c], d = o[c];
        h !== 0 && (hp.fromBufferAttribute(d, e), a ? Gu.addScaledVector(hp, h) : Gu.addScaledVector(hp.sub(n), h));
      }
      n.add(Gu);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry, s = this.material, o = this.matrixWorld;
    s !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), zu.copy(i.boundingSphere), zu.applyMatrix4(o), So.copy(e.ray).recast(e.near), !(zu.containsPoint(So.origin) === !1 && (So.intersectSphere(zu, ey) === null || So.origin.distanceToSquared(ey) > (e.far - e.near) ** 2)) && (Q0.copy(o).invert(), So.copy(e.ray).applyMatrix4(Q0), !(i.boundingBox !== null && So.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, So)));
  }
  _computeIntersections(e, n, i) {
    let s;
    const o = this.geometry, a = this.material, l = o.index, c = o.attributes.position, u = o.attributes.uv, h = o.attributes.uv1, d = o.attributes.normal, p = o.groups, f = o.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let m = 0, _ = p.length; m < _; m++) {
          const g = p[m], v = a[g.materialIndex], S = Math.max(g.start, f.start), b = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
          for (let x = S, M = b; x < M; x += 3) {
            const C = l.getX(x), E = l.getX(x + 1), T = l.getX(x + 2);
            s = Wu(this, v, e, i, u, h, d, C, E, T), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = g.materialIndex, n.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), _ = Math.min(l.count, f.start + f.count);
        for (let g = m, v = _; g < v; g += 3) {
          const S = l.getX(g), b = l.getX(g + 1), x = l.getX(g + 2);
          s = Wu(this, a, e, i, u, h, d, S, b, x), s && (s.faceIndex = Math.floor(g / 3), n.push(s));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let m = 0, _ = p.length; m < _; m++) {
          const g = p[m], v = a[g.materialIndex], S = Math.max(g.start, f.start), b = Math.min(c.count, Math.min(g.start + g.count, f.start + f.count));
          for (let x = S, M = b; x < M; x += 3) {
            const C = x, E = x + 1, T = x + 2;
            s = Wu(this, v, e, i, u, h, d, C, E, T), s && (s.faceIndex = Math.floor(x / 3), s.face.materialIndex = g.materialIndex, n.push(s));
          }
        }
      else {
        const m = Math.max(0, f.start), _ = Math.min(c.count, f.start + f.count);
        for (let g = m, v = _; g < v; g += 3) {
          const S = g, b = g + 1, x = g + 2;
          s = Wu(this, a, e, i, u, h, d, S, b, x), s && (s.faceIndex = Math.floor(g / 3), n.push(s));
        }
      }
  }
}
function m2(r, e, n, i, s, o, a, l) {
  let c;
  if (e.side === Oi ? c = i.intersectTriangle(a, o, s, !0, l) : c = i.intersectTriangle(s, o, a, e.side === ao, l), c === null) return null;
  Hu.copy(l), Hu.applyMatrix4(r.matrixWorld);
  const u = n.ray.origin.distanceTo(Hu);
  return u < n.near || u > n.far ? null : {
    distance: u,
    point: Hu.clone(),
    object: r
  };
}
function Wu(r, e, n, i, s, o, a, l, c, u) {
  r.getVertexPosition(l, Bu), r.getVertexPosition(c, Nu), r.getVertexPosition(u, Vu);
  const h = m2(r, e, n, i, Bu, Nu, Vu, ty);
  if (h) {
    const d = new he();
    ys.getBarycoord(ty, Bu, Nu, Vu, d), s && (h.uv = ys.getInterpolatedAttribute(s, l, c, u, d, new ct())), o && (h.uv1 = ys.getInterpolatedAttribute(o, l, c, u, d, new ct())), a && (h.normal = ys.getInterpolatedAttribute(a, l, c, u, d, new he()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: c,
      c: u,
      normal: new he(),
      materialIndex: 0
    };
    ys.getNormal(Bu, Nu, Vu, p.normal), h.face = p, h.barycoord = d;
  }
  return h;
}
class Cn extends Wt {
  constructor(e = 1, n = 1, i = 1, s = 1, o = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: s,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    s = Math.floor(s), o = Math.floor(o), a = Math.floor(a);
    const c = [], u = [], h = [], d = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, i, n, e, a, o, 0), m("z", "y", "x", 1, -1, i, n, -e, a, o, 1), m("x", "z", "y", 1, 1, e, i, n, s, a, 2), m("x", "z", "y", 1, -1, e, i, -n, s, a, 3), m("x", "y", "z", 1, -1, e, n, i, s, o, 4), m("x", "y", "z", -1, -1, e, n, -i, s, o, 5), this.setIndex(c), this.setAttribute("position", new Ot(u, 3)), this.setAttribute("normal", new Ot(h, 3)), this.setAttribute("uv", new Ot(d, 2));
    function m(_, g, v, S, b, x, M, C, E, T, w) {
      const A = x / E, O = M / T, U = x / 2, D = M / 2, L = C / 2, P = E + 1, V = T + 1;
      let ce = 0, q = 0;
      const oe = new he();
      for (let ne = 0; ne < V; ne++) {
        const $ = ne * O - D;
        for (let J = 0; J < P; J++) {
          const se = J * A - U;
          oe[_] = se * S, oe[g] = $ * b, oe[v] = L, u.push(oe.x, oe.y, oe.z), oe[_] = 0, oe[g] = 0, oe[v] = C > 0 ? 1 : -1, h.push(oe.x, oe.y, oe.z), d.push(J / E), d.push(1 - ne / T), ce += 1;
        }
      }
      for (let ne = 0; ne < T; ne++)
        for (let $ = 0; $ < E; $++) {
          const J = p + $ + P * ne, se = p + $ + P * (ne + 1), le = p + ($ + 1) + P * (ne + 1), re = p + ($ + 1) + P * ne;
          c.push(J, se, re), c.push(se, le, re), q += 6;
        }
      l.addGroup(f, q, w), f += q, p += ce;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function fl(r) {
  const e = {};
  for (const n in r) {
    e[n] = {};
    for (const i in r[n]) {
      const s = r[n][i];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = s.clone() : Array.isArray(s) ? e[n][i] = s.slice() : e[n][i] = s;
    }
  }
  return e;
}
function yi(r) {
  const e = {};
  for (let n = 0; n < r.length; n++) {
    const i = fl(r[n]);
    for (const s in i)
      e[s] = i[s];
  }
  return e;
}
function g2(r) {
  const e = [];
  for (let n = 0; n < r.length; n++)
    e.push(r[n].clone());
  return e;
}
function Tb(r) {
  const e = r.getRenderTarget();
  return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Nt.workingColorSpace;
}
const uu = { clone: fl, merge: yi };
var v2 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, y2 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class si extends oa {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = v2, this.fragmentShader = y2, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = fl(e.uniforms), this.uniformsGroups = g2(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const s in this.uniforms) {
      const a = this.uniforms[s].value;
      a && a.isTexture ? n.uniforms[s] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? n.uniforms[s] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? n.uniforms[s] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? n.uniforms[s] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? n.uniforms[s] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? n.uniforms[s] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? n.uniforms[s] = {
        type: "m4",
        value: a.toArray()
      } : n.uniforms[s] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const i = {};
    for (const s in this.extensions)
      this.extensions[s] === !0 && (i[s] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class Eb extends vn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rn(), this.projectionMatrix = new rn(), this.projectionMatrixInverse = new rn(), this.coordinateSystem = pr;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Hr = /* @__PURE__ */ new he(), ny = /* @__PURE__ */ new ct(), iy = /* @__PURE__ */ new ct();
class Li extends Eb {
  constructor(e = 50, n = 1, i = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = dl * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(bc * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return dl * 2 * Math.atan(
      Math.tan(bc * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, i) {
    Hr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z), Hr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, ny, iy), n.subVectors(iy, ny);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, i, s, o, a) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(bc * 0.5 * this.fov) / this.zoom, i = 2 * n, s = this.aspect * i, o = -0.5 * s;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, u = a.fullHeight;
      o += a.offsetX * s / c, n -= a.offsetY * i / u, s *= a.width / c, i *= a.height / u;
    }
    const l = this.filmOffset;
    l !== 0 && (o += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + s, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const Ma = -90, Ca = 1;
class _2 extends vn {
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const s = new Li(Ma, Ca, e, n);
    s.layers = this.layers, this.add(s);
    const o = new Li(Ma, Ca, e, n);
    o.layers = this.layers, this.add(o);
    const a = new Li(Ma, Ca, e, n);
    a.layers = this.layers, this.add(a);
    const l = new Li(Ma, Ca, e, n);
    l.layers = this.layers, this.add(l);
    const c = new Li(Ma, Ca, e, n);
    c.layers = this.layers, this.add(c);
    const u = new Li(Ma, Ca, e, n);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, s, o, a, l, c] = n;
    for (const u of n) this.remove(u);
    if (e === pr)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === vd)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of n)
      this.add(u), u.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: s } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, a, l, c, u, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, s), e.render(n, o), e.setRenderTarget(i, 1, s), e.render(n, a), e.setRenderTarget(i, 2, s), e.render(n, l), e.setRenderTarget(i, 3, s), e.render(n, c), e.setRenderTarget(i, 4, s), e.render(n, u), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, s), e.render(n, h), e.setRenderTarget(d, p, f), e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
}
class Ab extends Fn {
  constructor(e, n, i, s, o, a, l, c, u, h) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : ll, super(e, n, i, s, o, a, l, c, u, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class x2 extends Es {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, s = [i, i, i, i, i, i];
    this.texture = new Ab(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Kt;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, s = new Cn(5, 5, 5), o = new si({
      name: "CubemapFromEquirect",
      uniforms: fl(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Oi,
      blending: Hs
    });
    o.uniforms.tEquirect.value = n;
    const a = new tt(s, o), l = n.minFilter;
    return n.minFilter === jo && (n.minFilter = Kt), new _2(1, 10, this).update(e, a), n.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, n, i, s) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(n, i, s);
    e.setRenderTarget(o);
  }
}
const dp = /* @__PURE__ */ new he(), b2 = /* @__PURE__ */ new he(), w2 = /* @__PURE__ */ new Dt();
class Ro {
  constructor(e = new he(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, s) {
    return this.normal.set(e, n, i), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const s = dp.subVectors(i, n).cross(b2.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(dp), s = this.normal.dot(i);
    if (s === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / s;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(i, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || w2.getNormalMatrix(e), s = this.coplanarPoint(dp).applyMatrix4(e), o = this.normal.applyMatrix3(i).normalize();
    return this.constant = -s.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Mo = /* @__PURE__ */ new cu(), ju = /* @__PURE__ */ new he();
class Jg {
  constructor(e = new Ro(), n = new Ro(), i = new Ro(), s = new Ro(), o = new Ro(), a = new Ro()) {
    this.planes = [e, n, i, s, o, a];
  }
  set(e, n, i, s, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(i), l[3].copy(s), l[4].copy(o), l[5].copy(a), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = pr) {
    const i = this.planes, s = e.elements, o = s[0], a = s[1], l = s[2], c = s[3], u = s[4], h = s[5], d = s[6], p = s[7], f = s[8], m = s[9], _ = s[10], g = s[11], v = s[12], S = s[13], b = s[14], x = s[15];
    if (i[0].setComponents(c - o, p - u, g - f, x - v).normalize(), i[1].setComponents(c + o, p + u, g + f, x + v).normalize(), i[2].setComponents(c + a, p + h, g + m, x + S).normalize(), i[3].setComponents(c - a, p - h, g - m, x - S).normalize(), i[4].setComponents(c - l, p - d, g - _, x - b).normalize(), n === pr)
      i[5].setComponents(c + l, p + d, g + _, x + b).normalize();
    else if (n === vd)
      i[5].setComponents(l, d, _, b).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Mo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), Mo.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Mo);
  }
  intersectsSprite(e) {
    return Mo.center.set(0, 0, 0), Mo.radius = 0.7071067811865476, Mo.applyMatrix4(e.matrixWorld), this.intersectsSphere(Mo);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, s = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(i) < s)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const s = n[i];
      if (ju.x = s.normal.x > 0 ? e.max.x : e.min.x, ju.y = s.normal.y > 0 ? e.max.y : e.min.y, ju.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(ju) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Pb() {
  let r = null, e = !1, n = null, i = null;
  function s(o, a) {
    n(o, a), i = r.requestAnimationFrame(s);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (i = r.requestAnimationFrame(s), e = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      r = o;
    }
  };
}
function S2(r) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(l, c) {
    const u = l.array, h = l.usage, d = u.byteLength, p = r.createBuffer();
    r.bindBuffer(c, p), r.bufferData(c, u, h), l.onUploadCallback();
    let f;
    if (u instanceof Float32Array)
      f = r.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = r.HALF_FLOAT : f = r.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      f = r.SHORT;
    else if (u instanceof Uint32Array)
      f = r.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      f = r.INT;
    else if (u instanceof Int8Array)
      f = r.BYTE;
    else if (u instanceof Uint8Array)
      f = r.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      f = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: p,
      type: f,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: d
    };
  }
  function i(l, c, u) {
    const h = c.array, d = c.updateRanges;
    if (r.bindBuffer(u, l), d.length === 0)
      r.bufferSubData(u, 0, h);
    else {
      d.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < d.length; f++) {
        const m = d[p], _ = d[f];
        _.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          _.start + _.count - m.start
        ) : (++p, d[p] = _);
      }
      d.length = p + 1;
      for (let f = 0, m = d.length; f < m; f++) {
        const _ = d[f];
        r.bufferSubData(
          u,
          _.start * h.BYTES_PER_ELEMENT,
          h,
          _.start,
          _.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function s(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (r.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const h = e.get(l);
      (!h || h.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const u = e.get(l);
    if (u === void 0)
      e.set(l, n(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(u.buffer, l, c), u.version = l.version;
    }
  }
  return {
    get: s,
    remove: o,
    update: a
  };
}
class yn extends Wt {
  constructor(e = 1, n = 1, i = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: s
    };
    const o = e / 2, a = n / 2, l = Math.floor(i), c = Math.floor(s), u = l + 1, h = c + 1, d = e / l, p = n / c, f = [], m = [], _ = [], g = [];
    for (let v = 0; v < h; v++) {
      const S = v * p - a;
      for (let b = 0; b < u; b++) {
        const x = b * d - o;
        m.push(x, -S, 0), _.push(0, 0, 1), g.push(b / l), g.push(1 - v / c);
      }
    }
    for (let v = 0; v < c; v++)
      for (let S = 0; S < l; S++) {
        const b = S + u * v, x = S + u * (v + 1), M = S + 1 + u * (v + 1), C = S + 1 + u * v;
        f.push(b, x, C), f.push(x, M, C);
      }
    this.setIndex(f), this.setAttribute("position", new Ot(m, 3)), this.setAttribute("normal", new Ot(_, 3)), this.setAttribute("uv", new Ot(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new yn(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var M2 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, C2 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, T2 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, E2 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, A2 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, P2 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, D2 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, k2 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, R2 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, L2 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, I2 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, O2 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, F2 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, U2 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, z2 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, B2 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, N2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, V2 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, G2 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, H2 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, W2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, j2 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, $2 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, X2 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Y2 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, q2 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Z2 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, K2 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, J2 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Q2 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, eE = "gl_FragColor = linearToOutputTexel( gl_FragColor );", tE = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, nE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, iE = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, sE = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, rE = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, oE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, aE = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, lE = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, cE = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, uE = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, hE = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, dE = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, fE = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, pE = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, mE = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, gE = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, vE = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, yE = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, _E = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, xE = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, bE = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, wE = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, SE = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, ME = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, CE = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, TE = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, EE = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, AE = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, PE = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, DE = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, kE = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, RE = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, LE = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, IE = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, OE = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, FE = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, UE = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, zE = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, BE = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, NE = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, VE = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, GE = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, HE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, WE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, jE = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, $E = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, XE = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, YE = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, qE = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, ZE = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, KE = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, JE = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, QE = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, eA = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, tA = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, nA = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, iA = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, sA = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, rA = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, oA = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, aA = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, lA = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, cA = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, uA = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, hA = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, dA = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, fA = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, pA = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, mA = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, gA = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, vA = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, yA = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, _A = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, xA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, bA = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, wA = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const SA = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, MA = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, CA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, TA = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, EA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, AA = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, PA = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, DA = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, kA = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, RA = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, LA = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, IA = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, OA = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, FA = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, UA = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, zA = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, BA = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, NA = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, VA = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, GA = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, HA = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, WA = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, jA = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, $A = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XA = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, YA = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qA = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ZA = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, KA = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, JA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, QA = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, eP = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, tP = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, nP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, kt = {
  alphahash_fragment: M2,
  alphahash_pars_fragment: C2,
  alphamap_fragment: T2,
  alphamap_pars_fragment: E2,
  alphatest_fragment: A2,
  alphatest_pars_fragment: P2,
  aomap_fragment: D2,
  aomap_pars_fragment: k2,
  batching_pars_vertex: R2,
  batching_vertex: L2,
  begin_vertex: I2,
  beginnormal_vertex: O2,
  bsdfs: F2,
  iridescence_fragment: U2,
  bumpmap_pars_fragment: z2,
  clipping_planes_fragment: B2,
  clipping_planes_pars_fragment: N2,
  clipping_planes_pars_vertex: V2,
  clipping_planes_vertex: G2,
  color_fragment: H2,
  color_pars_fragment: W2,
  color_pars_vertex: j2,
  color_vertex: $2,
  common: X2,
  cube_uv_reflection_fragment: Y2,
  defaultnormal_vertex: q2,
  displacementmap_pars_vertex: Z2,
  displacementmap_vertex: K2,
  emissivemap_fragment: J2,
  emissivemap_pars_fragment: Q2,
  colorspace_fragment: eE,
  colorspace_pars_fragment: tE,
  envmap_fragment: nE,
  envmap_common_pars_fragment: iE,
  envmap_pars_fragment: sE,
  envmap_pars_vertex: rE,
  envmap_physical_pars_fragment: gE,
  envmap_vertex: oE,
  fog_vertex: aE,
  fog_pars_vertex: lE,
  fog_fragment: cE,
  fog_pars_fragment: uE,
  gradientmap_pars_fragment: hE,
  lightmap_pars_fragment: dE,
  lights_lambert_fragment: fE,
  lights_lambert_pars_fragment: pE,
  lights_pars_begin: mE,
  lights_toon_fragment: vE,
  lights_toon_pars_fragment: yE,
  lights_phong_fragment: _E,
  lights_phong_pars_fragment: xE,
  lights_physical_fragment: bE,
  lights_physical_pars_fragment: wE,
  lights_fragment_begin: SE,
  lights_fragment_maps: ME,
  lights_fragment_end: CE,
  logdepthbuf_fragment: TE,
  logdepthbuf_pars_fragment: EE,
  logdepthbuf_pars_vertex: AE,
  logdepthbuf_vertex: PE,
  map_fragment: DE,
  map_pars_fragment: kE,
  map_particle_fragment: RE,
  map_particle_pars_fragment: LE,
  metalnessmap_fragment: IE,
  metalnessmap_pars_fragment: OE,
  morphinstance_vertex: FE,
  morphcolor_vertex: UE,
  morphnormal_vertex: zE,
  morphtarget_pars_vertex: BE,
  morphtarget_vertex: NE,
  normal_fragment_begin: VE,
  normal_fragment_maps: GE,
  normal_pars_fragment: HE,
  normal_pars_vertex: WE,
  normal_vertex: jE,
  normalmap_pars_fragment: $E,
  clearcoat_normal_fragment_begin: XE,
  clearcoat_normal_fragment_maps: YE,
  clearcoat_pars_fragment: qE,
  iridescence_pars_fragment: ZE,
  opaque_fragment: KE,
  packing: JE,
  premultiplied_alpha_fragment: QE,
  project_vertex: eA,
  dithering_fragment: tA,
  dithering_pars_fragment: nA,
  roughnessmap_fragment: iA,
  roughnessmap_pars_fragment: sA,
  shadowmap_pars_fragment: rA,
  shadowmap_pars_vertex: oA,
  shadowmap_vertex: aA,
  shadowmask_pars_fragment: lA,
  skinbase_vertex: cA,
  skinning_pars_vertex: uA,
  skinning_vertex: hA,
  skinnormal_vertex: dA,
  specularmap_fragment: fA,
  specularmap_pars_fragment: pA,
  tonemapping_fragment: mA,
  tonemapping_pars_fragment: gA,
  transmission_fragment: vA,
  transmission_pars_fragment: yA,
  uv_pars_fragment: _A,
  uv_pars_vertex: xA,
  uv_vertex: bA,
  worldpos_vertex: wA,
  background_vert: SA,
  background_frag: MA,
  backgroundCube_vert: CA,
  backgroundCube_frag: TA,
  cube_vert: EA,
  cube_frag: AA,
  depth_vert: PA,
  depth_frag: DA,
  distanceRGBA_vert: kA,
  distanceRGBA_frag: RA,
  equirect_vert: LA,
  equirect_frag: IA,
  linedashed_vert: OA,
  linedashed_frag: FA,
  meshbasic_vert: UA,
  meshbasic_frag: zA,
  meshlambert_vert: BA,
  meshlambert_frag: NA,
  meshmatcap_vert: VA,
  meshmatcap_frag: GA,
  meshnormal_vert: HA,
  meshnormal_frag: WA,
  meshphong_vert: jA,
  meshphong_frag: $A,
  meshphysical_vert: XA,
  meshphysical_frag: YA,
  meshtoon_vert: qA,
  meshtoon_frag: ZA,
  points_vert: KA,
  points_frag: JA,
  shadow_vert: QA,
  shadow_frag: eP,
  sprite_vert: tP,
  sprite_frag: nP
}, at = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Dt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Dt() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Dt() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Dt() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Dt() },
    normalScale: { value: /* @__PURE__ */ new ct(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Dt() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Dt() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Tt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Dt() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Dt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ct(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Dt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Dt() },
    alphaTest: { value: 0 }
  }
}, zs = {
  basic: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.specularmap,
      at.envmap,
      at.aomap,
      at.lightmap,
      at.fog
    ]),
    vertexShader: kt.meshbasic_vert,
    fragmentShader: kt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.specularmap,
      at.envmap,
      at.aomap,
      at.lightmap,
      at.emissivemap,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      at.fog,
      at.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: kt.meshlambert_vert,
    fragmentShader: kt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.specularmap,
      at.envmap,
      at.aomap,
      at.lightmap,
      at.emissivemap,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      at.fog,
      at.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        specular: { value: /* @__PURE__ */ new Tt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: kt.meshphong_vert,
    fragmentShader: kt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.envmap,
      at.aomap,
      at.lightmap,
      at.emissivemap,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      at.roughnessmap,
      at.metalnessmap,
      at.fog,
      at.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: kt.meshphysical_vert,
    fragmentShader: kt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.aomap,
      at.lightmap,
      at.emissivemap,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      at.gradientmap,
      at.fog,
      at.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: kt.meshtoon_vert,
    fragmentShader: kt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      at.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: kt.meshmatcap_vert,
    fragmentShader: kt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ yi([
      at.points,
      at.fog
    ]),
    vertexShader: kt.points_vert,
    fragmentShader: kt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: kt.linedashed_vert,
    fragmentShader: kt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.displacementmap
    ]),
    vertexShader: kt.depth_vert,
    fragmentShader: kt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.bumpmap,
      at.normalmap,
      at.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: kt.meshnormal_vert,
    fragmentShader: kt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ yi([
      at.sprite,
      at.fog
    ]),
    vertexShader: kt.sprite_vert,
    fragmentShader: kt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Dt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: kt.background_vert,
    fragmentShader: kt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Dt() }
    },
    vertexShader: kt.backgroundCube_vert,
    fragmentShader: kt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: kt.cube_vert,
    fragmentShader: kt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: kt.equirect_vert,
    fragmentShader: kt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ yi([
      at.common,
      at.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new he() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: kt.distanceRGBA_vert,
    fragmentShader: kt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ yi([
      at.lights,
      at.fog,
      {
        color: { value: /* @__PURE__ */ new Tt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: kt.shadow_vert,
    fragmentShader: kt.shadow_frag
  }
};
zs.physical = {
  uniforms: /* @__PURE__ */ yi([
    zs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Dt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Dt() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ct(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Dt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Dt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Dt() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Dt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Dt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Dt() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ct() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Dt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Tt(0) },
      specularColor: { value: /* @__PURE__ */ new Tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Dt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Dt() },
      anisotropyVector: { value: /* @__PURE__ */ new ct() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Dt() }
    }
  ]),
  vertexShader: kt.meshphysical_vert,
  fragmentShader: kt.meshphysical_frag
};
const $u = { r: 0, b: 0, g: 0 }, Co = /* @__PURE__ */ new Zi(), iP = /* @__PURE__ */ new rn();
function sP(r, e, n, i, s, o, a) {
  const l = new Tt(0);
  let c = o === !0 ? 0 : 1, u, h, d = null, p = 0, f = null;
  function m(S) {
    let b = S.isScene === !0 ? S.background : null;
    return b && b.isTexture && (b = (S.backgroundBlurriness > 0 ? n : e).get(b)), b;
  }
  function _(S) {
    let b = !1;
    const x = m(S);
    x === null ? v(l, c) : x && x.isColor && (v(x, 1), b = !0);
    const M = r.xr.getEnvironmentBlendMode();
    M === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : M === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (r.autoClear || b) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
  }
  function g(S, b) {
    const x = m(b);
    x && (x.isCubeTexture || x.mapping === nf) ? (h === void 0 && (h = new tt(
      new Cn(1, 1, 1),
      new si({
        name: "BackgroundCubeMaterial",
        uniforms: fl(zs.backgroundCube.uniforms),
        vertexShader: zs.backgroundCube.vertexShader,
        fragmentShader: zs.backgroundCube.fragmentShader,
        side: Oi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(M, C, E) {
      this.matrixWorld.copyPosition(E.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), s.update(h)), Co.copy(b.backgroundRotation), Co.x *= -1, Co.y *= -1, Co.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (Co.y *= -1, Co.z *= -1), h.material.uniforms.envMap.value = x, h.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = b.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(iP.makeRotationFromEuler(Co)), h.material.toneMapped = Nt.getTransfer(x.colorSpace) !== nn, (d !== x || p !== x.version || f !== r.toneMapping) && (h.material.needsUpdate = !0, d = x, p = x.version, f = r.toneMapping), h.layers.enableAll(), S.unshift(h, h.geometry, h.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new tt(
      new yn(2, 2),
      new si({
        name: "BackgroundMaterial",
        uniforms: fl(zs.background.uniforms),
        vertexShader: zs.background.vertexShader,
        fragmentShader: zs.background.fragmentShader,
        side: ao,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), s.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = b.backgroundIntensity, u.material.toneMapped = Nt.getTransfer(x.colorSpace) !== nn, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (d !== x || p !== x.version || f !== r.toneMapping) && (u.material.needsUpdate = !0, d = x, p = x.version, f = r.toneMapping), u.layers.enableAll(), S.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function v(S, b) {
    S.getRGB($u, Tb(r)), i.buffers.color.setClear($u.r, $u.g, $u.b, b, a);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(S, b = 1) {
      l.set(S), c = b, v(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(S) {
      c = S, v(l, c);
    },
    render: _,
    addToRenderList: g
  };
}
function rP(r, e) {
  const n = r.getParameter(r.MAX_VERTEX_ATTRIBS), i = {}, s = p(null);
  let o = s, a = !1;
  function l(A, O, U, D, L) {
    let P = !1;
    const V = d(D, U, O);
    o !== V && (o = V, u(o.object)), P = f(A, D, U, L), P && m(A, D, U, L), L !== null && e.update(L, r.ELEMENT_ARRAY_BUFFER), (P || a) && (a = !1, x(A, O, U, D), L !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(L).buffer));
  }
  function c() {
    return r.createVertexArray();
  }
  function u(A) {
    return r.bindVertexArray(A);
  }
  function h(A) {
    return r.deleteVertexArray(A);
  }
  function d(A, O, U) {
    const D = U.wireframe === !0;
    let L = i[A.id];
    L === void 0 && (L = {}, i[A.id] = L);
    let P = L[O.id];
    P === void 0 && (P = {}, L[O.id] = P);
    let V = P[D];
    return V === void 0 && (V = p(c()), P[D] = V), V;
  }
  function p(A) {
    const O = [], U = [], D = [];
    for (let L = 0; L < n; L++)
      O[L] = 0, U[L] = 0, D[L] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: U,
      attributeDivisors: D,
      object: A,
      attributes: {},
      index: null
    };
  }
  function f(A, O, U, D) {
    const L = o.attributes, P = O.attributes;
    let V = 0;
    const ce = U.getAttributes();
    for (const q in ce)
      if (ce[q].location >= 0) {
        const ne = L[q];
        let $ = P[q];
        if ($ === void 0 && (q === "instanceMatrix" && A.instanceMatrix && ($ = A.instanceMatrix), q === "instanceColor" && A.instanceColor && ($ = A.instanceColor)), ne === void 0 || ne.attribute !== $ || $ && ne.data !== $.data) return !0;
        V++;
      }
    return o.attributesNum !== V || o.index !== D;
  }
  function m(A, O, U, D) {
    const L = {}, P = O.attributes;
    let V = 0;
    const ce = U.getAttributes();
    for (const q in ce)
      if (ce[q].location >= 0) {
        let ne = P[q];
        ne === void 0 && (q === "instanceMatrix" && A.instanceMatrix && (ne = A.instanceMatrix), q === "instanceColor" && A.instanceColor && (ne = A.instanceColor));
        const $ = {};
        $.attribute = ne, ne && ne.data && ($.data = ne.data), L[q] = $, V++;
      }
    o.attributes = L, o.attributesNum = V, o.index = D;
  }
  function _() {
    const A = o.newAttributes;
    for (let O = 0, U = A.length; O < U; O++)
      A[O] = 0;
  }
  function g(A) {
    v(A, 0);
  }
  function v(A, O) {
    const U = o.newAttributes, D = o.enabledAttributes, L = o.attributeDivisors;
    U[A] = 1, D[A] === 0 && (r.enableVertexAttribArray(A), D[A] = 1), L[A] !== O && (r.vertexAttribDivisor(A, O), L[A] = O);
  }
  function S() {
    const A = o.newAttributes, O = o.enabledAttributes;
    for (let U = 0, D = O.length; U < D; U++)
      O[U] !== A[U] && (r.disableVertexAttribArray(U), O[U] = 0);
  }
  function b(A, O, U, D, L, P, V) {
    V === !0 ? r.vertexAttribIPointer(A, O, U, L, P) : r.vertexAttribPointer(A, O, U, D, L, P);
  }
  function x(A, O, U, D) {
    _();
    const L = D.attributes, P = U.getAttributes(), V = O.defaultAttributeValues;
    for (const ce in P) {
      const q = P[ce];
      if (q.location >= 0) {
        let oe = L[ce];
        if (oe === void 0 && (ce === "instanceMatrix" && A.instanceMatrix && (oe = A.instanceMatrix), ce === "instanceColor" && A.instanceColor && (oe = A.instanceColor)), oe !== void 0) {
          const ne = oe.normalized, $ = oe.itemSize, J = e.get(oe);
          if (J === void 0) continue;
          const se = J.buffer, le = J.type, re = J.bytesPerElement, ye = le === r.INT || le === r.UNSIGNED_INT || oe.gpuType === Vg;
          if (oe.isInterleavedBufferAttribute) {
            const H = oe.data, K = H.stride, G = oe.offset;
            if (H.isInstancedInterleavedBuffer) {
              for (let R = 0; R < q.locationSize; R++)
                v(q.location + R, H.meshPerAttribute);
              A.isInstancedMesh !== !0 && D._maxInstanceCount === void 0 && (D._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let R = 0; R < q.locationSize; R++)
                g(q.location + R);
            r.bindBuffer(r.ARRAY_BUFFER, se);
            for (let R = 0; R < q.locationSize; R++)
              b(
                q.location + R,
                $ / q.locationSize,
                le,
                ne,
                K * re,
                (G + $ / q.locationSize * R) * re,
                ye
              );
          } else {
            if (oe.isInstancedBufferAttribute) {
              for (let H = 0; H < q.locationSize; H++)
                v(q.location + H, oe.meshPerAttribute);
              A.isInstancedMesh !== !0 && D._maxInstanceCount === void 0 && (D._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let H = 0; H < q.locationSize; H++)
                g(q.location + H);
            r.bindBuffer(r.ARRAY_BUFFER, se);
            for (let H = 0; H < q.locationSize; H++)
              b(
                q.location + H,
                $ / q.locationSize,
                le,
                ne,
                $ * re,
                $ / q.locationSize * H * re,
                ye
              );
          }
        } else if (V !== void 0) {
          const ne = V[ce];
          if (ne !== void 0)
            switch (ne.length) {
              case 2:
                r.vertexAttrib2fv(q.location, ne);
                break;
              case 3:
                r.vertexAttrib3fv(q.location, ne);
                break;
              case 4:
                r.vertexAttrib4fv(q.location, ne);
                break;
              default:
                r.vertexAttrib1fv(q.location, ne);
            }
        }
      }
    }
    S();
  }
  function M() {
    T();
    for (const A in i) {
      const O = i[A];
      for (const U in O) {
        const D = O[U];
        for (const L in D)
          h(D[L].object), delete D[L];
        delete O[U];
      }
      delete i[A];
    }
  }
  function C(A) {
    if (i[A.id] === void 0) return;
    const O = i[A.id];
    for (const U in O) {
      const D = O[U];
      for (const L in D)
        h(D[L].object), delete D[L];
      delete O[U];
    }
    delete i[A.id];
  }
  function E(A) {
    for (const O in i) {
      const U = i[O];
      if (U[A.id] === void 0) continue;
      const D = U[A.id];
      for (const L in D)
        h(D[L].object), delete D[L];
      delete U[A.id];
    }
  }
  function T() {
    w(), a = !0, o !== s && (o = s, u(o.object));
  }
  function w() {
    s.geometry = null, s.program = null, s.wireframe = !1;
  }
  return {
    setup: l,
    reset: T,
    resetDefaultState: w,
    dispose: M,
    releaseStatesOfGeometry: C,
    releaseStatesOfProgram: E,
    initAttributes: _,
    enableAttribute: g,
    disableUnusedAttributes: S
  };
}
function oP(r, e, n) {
  let i;
  function s(u) {
    i = u;
  }
  function o(u, h) {
    r.drawArrays(i, u, h), n.update(h, i, 1);
  }
  function a(u, h, d) {
    d !== 0 && (r.drawArraysInstanced(i, u, h, d), n.update(h, i, d));
  }
  function l(u, h, d) {
    if (d === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, h, 0, d);
    let f = 0;
    for (let m = 0; m < d; m++)
      f += h[m];
    n.update(f, i, 1);
  }
  function c(u, h, d, p) {
    if (d === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < u.length; m++)
        a(u[m], h[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, u, 0, h, 0, p, 0, d);
      let m = 0;
      for (let _ = 0; _ < d; _++)
        m += h[_] * p[_];
      n.update(m, i, 1);
    }
  }
  this.setMode = s, this.render = o, this.renderInstances = a, this.renderMultiDraw = l, this.renderMultiDrawInstances = c;
}
function aP(r, e, n, i) {
  let s;
  function o() {
    if (s !== void 0) return s;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const E = e.get("EXT_texture_filter_anisotropic");
      s = r.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      s = 0;
    return s;
  }
  function a(E) {
    return !(E !== fi && i.convert(E) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(E) {
    const T = E === po && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(E !== js && i.convert(E) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    E !== Ii && !T);
  }
  function c(E) {
    if (E === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      E = "mediump";
    }
    return E === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = n.precision !== void 0 ? n.precision : "highp";
  const h = c(u);
  h !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", h, "instead."), u = h);
  const d = n.logarithmicDepthBuffer === !0, p = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), m = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = r.getParameter(r.MAX_TEXTURE_SIZE), g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), v = r.getParameter(r.MAX_VERTEX_ATTRIBS), S = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), b = r.getParameter(r.MAX_VARYING_VECTORS), x = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), M = m > 0, C = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: d,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: _,
    maxCubemapSize: g,
    maxAttributes: v,
    maxVertexUniforms: S,
    maxVaryings: b,
    maxFragmentUniforms: x,
    vertexTextures: M,
    maxSamples: C
  };
}
function lP(r) {
  const e = this;
  let n = null, i = 0, s = !1, o = !1;
  const a = new Ro(), l = new Dt(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const f = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || s;
    return s = p, i = d.length, f;
  }, this.beginShadows = function() {
    o = !0, h(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(d, p) {
    n = h(d, p, 0);
  }, this.setState = function(d, p, f) {
    const m = d.clippingPlanes, _ = d.clipIntersection, g = d.clipShadows, v = r.get(d);
    if (!s || m === null || m.length === 0 || o && !g)
      o ? h(null) : u();
    else {
      const S = o ? 0 : i, b = S * 4;
      let x = v.clippingState || null;
      c.value = x, x = h(m, p, b, f);
      for (let M = 0; M !== b; ++M)
        x[M] = n[M];
      v.clippingState = x, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += S;
    }
  };
  function u() {
    c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(d, p, f, m) {
    const _ = d !== null ? d.length : 0;
    let g = null;
    if (_ !== 0) {
      if (g = c.value, m !== !0 || g === null) {
        const v = f + _ * 4, S = p.matrixWorldInverse;
        l.getNormalMatrix(S), (g === null || g.length < v) && (g = new Float32Array(v));
        for (let b = 0, x = f; b !== _; ++b, x += 4)
          a.copy(d[b]).applyMatrix4(S, l), a.normal.toArray(g, x), g[x + 3] = a.constant;
      }
      c.value = g, c.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, g;
  }
}
function cP(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === wm ? a.mapping = ll : l === Sm && (a.mapping = cl), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === wm || l === Sm)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const u = new x2(c.height);
            return u.fromEquirectangularTexture(r, a), e.set(a, u), a.addEventListener("dispose", s), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: o
  };
}
class rf extends Eb {
  constructor(e = -1, n = 1, i = 1, s = -1, o = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = s, this.near = o, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, s, o, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let o = i - e, a = i + e, l = s + n, c = s - n;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += u * this.view.offsetX, a = o + u * this.view.width, l -= h * this.view.offsetY, c = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, a, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const za = 4, sy = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Uo = 20, fp = /* @__PURE__ */ new rf(), ry = /* @__PURE__ */ new Tt();
let pp = null, mp = 0, gp = 0, vp = !1;
const Lo = (1 + Math.sqrt(5)) / 2, Ta = 1 / Lo, oy = [
  /* @__PURE__ */ new he(-Lo, Ta, 0),
  /* @__PURE__ */ new he(Lo, Ta, 0),
  /* @__PURE__ */ new he(-Ta, 0, Lo),
  /* @__PURE__ */ new he(Ta, 0, Lo),
  /* @__PURE__ */ new he(0, Lo, -Ta),
  /* @__PURE__ */ new he(0, Lo, Ta),
  /* @__PURE__ */ new he(-1, 1, -1),
  /* @__PURE__ */ new he(1, 1, -1),
  /* @__PURE__ */ new he(-1, 1, 1),
  /* @__PURE__ */ new he(1, 1, 1)
];
class ay {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, i = 0.1, s = 100) {
    pp = this._renderer.getRenderTarget(), mp = this._renderer.getActiveCubeFace(), gp = this._renderer.getActiveMipmapLevel(), vp = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, i, s, o), n > 0 && this._blur(o, 0, 0, n), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = uy(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = cy(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(pp, mp, gp), this._renderer.xr.enabled = vp, e.scissorTest = !1, Xu(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === ll || e.mapping === cl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), pp = this._renderer.getRenderTarget(), mp = this._renderer.getActiveCubeFace(), gp = this._renderer.getActiveMipmapLevel(), vp = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
      magFilter: Kt,
      minFilter: Kt,
      generateMipmaps: !1,
      type: po,
      format: fi,
      colorSpace: _l,
      depthBuffer: !1
    }, s = ly(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = ly(e, n, i);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = uP(o)), this._blurMaterial = hP(o, e, n);
    }
    return s;
  }
  _compileMaterial(e) {
    const n = new tt(this._lodPlanes[0], e);
    this._renderer.compile(n, fp);
  }
  _sceneToCubeUV(e, n, i, s) {
    const l = new Li(90, 1, n, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, p = h.toneMapping;
    h.getClearColor(ry), h.toneMapping = ro, h.autoClear = !1;
    const f = new Gn({
      name: "PMREM.Background",
      side: Oi,
      depthWrite: !1,
      depthTest: !1
    }), m = new tt(new Cn(), f);
    let _ = !1;
    const g = e.background;
    g ? g.isColor && (f.color.copy(g), e.background = null, _ = !0) : (f.color.copy(ry), _ = !0);
    for (let v = 0; v < 6; v++) {
      const S = v % 3;
      S === 0 ? (l.up.set(0, c[v], 0), l.lookAt(u[v], 0, 0)) : S === 1 ? (l.up.set(0, 0, c[v]), l.lookAt(0, u[v], 0)) : (l.up.set(0, c[v], 0), l.lookAt(0, 0, u[v]));
      const b = this._cubeSize;
      Xu(s, S * b, v > 2 ? b : 0, b, b), h.setRenderTarget(s), _ && h.render(m, l), h.render(e, l);
    }
    m.geometry.dispose(), m.material.dispose(), h.toneMapping = p, h.autoClear = d, e.background = g;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, s = e.mapping === ll || e.mapping === cl;
    s ? (this._cubemapMaterial === null && (this._cubemapMaterial = uy()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = cy());
    const o = s ? this._cubemapMaterial : this._equirectMaterial, a = new tt(this._lodPlanes[0], o), l = o.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    Xu(n, 0, 0, 3 * c, 2 * c), i.setRenderTarget(n), i.render(a, fp);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = !1;
    const s = this._lodPlanes.length;
    for (let o = 1; o < s; o++) {
      const a = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), l = oy[(s - o - 1) % oy.length];
      this._blur(e, o - 1, o, a, l);
    }
    n.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, i, s, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      n,
      i,
      s,
      "latitudinal",
      o
    ), this._halfBlur(
      a,
      e,
      i,
      i,
      s,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, n, i, s, o, a, l) {
    const c = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, d = new tt(this._lodPlanes[s], u), p = u.uniforms, f = this._sizeLods[i] - 1, m = isFinite(o) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Uo - 1), _ = o / m, g = isFinite(o) ? 1 + Math.floor(h * _) : Uo;
    g > Uo && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Uo}`);
    const v = [];
    let S = 0;
    for (let E = 0; E < Uo; ++E) {
      const T = E / _, w = Math.exp(-T * T / 2);
      v.push(w), E === 0 ? S += w : E < g && (S += 2 * w);
    }
    for (let E = 0; E < v.length; E++)
      v[E] = v[E] / S;
    p.envMap.value = e.texture, p.samples.value = g, p.weights.value = v, p.latitudinal.value = a === "latitudinal", l && (p.poleAxis.value = l);
    const { _lodMax: b } = this;
    p.dTheta.value = m, p.mipInt.value = b - i;
    const x = this._sizeLods[s], M = 3 * x * (s > b - za ? s - b + za : 0), C = 4 * (this._cubeSize - x);
    Xu(n, M, C, 3 * x, 2 * x), c.setRenderTarget(n), c.render(d, fp);
  }
}
function uP(r) {
  const e = [], n = [], i = [];
  let s = r;
  const o = r - za + 1 + sy.length;
  for (let a = 0; a < o; a++) {
    const l = Math.pow(2, s);
    n.push(l);
    let c = 1 / l;
    a > r - za ? c = sy[a - r + za - 1] : a === 0 && (c = 0), i.push(c);
    const u = 1 / (l - 2), h = -u, d = 1 + u, p = [h, h, d, h, d, d, h, h, d, d, h, d], f = 6, m = 6, _ = 3, g = 2, v = 1, S = new Float32Array(_ * m * f), b = new Float32Array(g * m * f), x = new Float32Array(v * m * f);
    for (let C = 0; C < f; C++) {
      const E = C % 3 * 2 / 3 - 1, T = C > 2 ? 0 : -1, w = [
        E,
        T,
        0,
        E + 2 / 3,
        T,
        0,
        E + 2 / 3,
        T + 1,
        0,
        E,
        T,
        0,
        E + 2 / 3,
        T + 1,
        0,
        E,
        T + 1,
        0
      ];
      S.set(w, _ * m * C), b.set(p, g * m * C);
      const A = [C, C, C, C, C, C];
      x.set(A, v * m * C);
    }
    const M = new Wt();
    M.setAttribute("position", new qi(S, _)), M.setAttribute("uv", new qi(b, g)), M.setAttribute("faceIndex", new qi(x, v)), e.push(M), s > za && s--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function ly(r, e, n) {
  const i = new Es(r, e, n);
  return i.texture.mapping = nf, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Xu(r, e, n, i, s) {
  r.viewport.set(e, n, i, s), r.scissor.set(e, n, i, s);
}
function hP(r, e, n) {
  const i = new Float32Array(Uo), s = new he(0, 1, 0);
  return new si({
    name: "SphericalGaussianBlur",
    defines: {
      n: Uo,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s }
    },
    vertexShader: Qg(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Hs,
    depthTest: !1,
    depthWrite: !1
  });
}
function cy() {
  return new si({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Qg(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Hs,
    depthTest: !1,
    depthWrite: !1
  });
}
function uy() {
  return new si({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Qg(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Hs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Qg() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function dP(r) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, u = c === wm || c === Sm, h = c === ll || c === cl;
      if (u || h) {
        let d = e.get(l);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return n === null && (n = new ay(r)), d = u ? n.fromEquirectangular(l, d) : n.fromCubemap(l, d), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), d.texture;
        if (d !== void 0)
          return d.texture;
        {
          const f = l.image;
          return u && f && f.height > 0 || h && f && s(f) ? (n === null && (n = new ay(r)), d = u ? n.fromEquirectangular(l) : n.fromCubemap(l), d.texture.pmremVersion = l.pmremVersion, e.set(l, d), l.addEventListener("dispose", o), d.texture) : null;
        }
      }
    }
    return l;
  }
  function s(l) {
    let c = 0;
    const u = 6;
    for (let h = 0; h < u; h++)
      l[h] !== void 0 && c++;
    return c === u;
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function fP(r) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0)
      return e[i];
    let s;
    switch (i) {
      case "WEBGL_depth_texture":
        s = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = r.getExtension(i);
    }
    return e[i] = s, s;
  }
  return {
    has: function(i) {
      return n(i) !== null;
    },
    init: function() {
      n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const s = n(i);
      return s === null && ac("THREE.WebGLRenderer: " + i + " extension not supported."), s;
    }
  };
}
function pP(r, e, n, i) {
  const s = {}, o = /* @__PURE__ */ new WeakMap();
  function a(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const _ = p.morphAttributes[m];
      for (let g = 0, v = _.length; g < v; g++)
        e.remove(_[g]);
    }
    p.removeEventListener("dispose", a), delete s[p.id];
    const f = o.get(p);
    f && (e.remove(f), o.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, n.memory.geometries--;
  }
  function l(d, p) {
    return s[p.id] === !0 || (p.addEventListener("dispose", a), s[p.id] = !0, n.memory.geometries++), p;
  }
  function c(d) {
    const p = d.attributes;
    for (const m in p)
      e.update(p[m], r.ARRAY_BUFFER);
    const f = d.morphAttributes;
    for (const m in f) {
      const _ = f[m];
      for (let g = 0, v = _.length; g < v; g++)
        e.update(_[g], r.ARRAY_BUFFER);
    }
  }
  function u(d) {
    const p = [], f = d.index, m = d.attributes.position;
    let _ = 0;
    if (f !== null) {
      const S = f.array;
      _ = f.version;
      for (let b = 0, x = S.length; b < x; b += 3) {
        const M = S[b + 0], C = S[b + 1], E = S[b + 2];
        p.push(M, C, C, E, E, M);
      }
    } else if (m !== void 0) {
      const S = m.array;
      _ = m.version;
      for (let b = 0, x = S.length / 3 - 1; b < x; b += 3) {
        const M = b + 0, C = b + 1, E = b + 2;
        p.push(M, C, C, E, E, M);
      }
    } else
      return;
    const g = new (xb(p) ? Cb : Mb)(p, 1);
    g.version = _;
    const v = o.get(d);
    v && e.remove(v), o.set(d, g);
  }
  function h(d) {
    const p = o.get(d);
    if (p) {
      const f = d.index;
      f !== null && p.version < f.version && u(d);
    } else
      u(d);
    return o.get(d);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: h
  };
}
function mP(r, e, n) {
  let i;
  function s(p) {
    i = p;
  }
  let o, a;
  function l(p) {
    o = p.type, a = p.bytesPerElement;
  }
  function c(p, f) {
    r.drawElements(i, f, o, p * a), n.update(f, i, 1);
  }
  function u(p, f, m) {
    m !== 0 && (r.drawElementsInstanced(i, f, o, p * a, m), n.update(f, i, m));
  }
  function h(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, o, p, 0, m);
    let g = 0;
    for (let v = 0; v < m; v++)
      g += f[v];
    n.update(g, i, 1);
  }
  function d(p, f, m, _) {
    if (m === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null)
      for (let v = 0; v < p.length; v++)
        u(p[v] / a, f[v], _[v]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, f, 0, o, p, 0, _, 0, m);
      let v = 0;
      for (let S = 0; S < m; S++)
        v += f[S] * _[S];
      n.update(v, i, 1);
    }
  }
  this.setMode = s, this.setIndex = l, this.render = c, this.renderInstances = u, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
}
function gP(r) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(o, a, l) {
    switch (n.calls++, a) {
      case r.TRIANGLES:
        n.triangles += l * (o / 3);
        break;
      case r.LINES:
        n.lines += l * (o / 2);
        break;
      case r.LINE_STRIP:
        n.lines += l * (o - 1);
        break;
      case r.LINE_LOOP:
        n.lines += l * o;
        break;
      case r.POINTS:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function s() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: s,
    update: i
  };
}
function vP(r, e, n) {
  const i = /* @__PURE__ */ new WeakMap(), s = new Jt();
  function o(a, l, c) {
    const u = a.morphTargetInfluences, h = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, d = h !== void 0 ? h.length : 0;
    let p = i.get(l);
    if (p === void 0 || p.count !== d) {
      let f = function() {
        T.dispose(), i.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, _ = l.morphAttributes.normal !== void 0, g = l.morphAttributes.color !== void 0, v = l.morphAttributes.position || [], S = l.morphAttributes.normal || [], b = l.morphAttributes.color || [];
      let x = 0;
      m === !0 && (x = 1), _ === !0 && (x = 2), g === !0 && (x = 3);
      let M = l.attributes.position.count * x, C = 1;
      M > e.maxTextureSize && (C = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
      const E = new Float32Array(M * C * 4 * d), T = new wb(E, M, C, d);
      T.type = Ii, T.needsUpdate = !0;
      const w = x * 4;
      for (let A = 0; A < d; A++) {
        const O = v[A], U = S[A], D = b[A], L = M * C * 4 * A;
        for (let P = 0; P < O.count; P++) {
          const V = P * w;
          m === !0 && (s.fromBufferAttribute(O, P), E[L + V + 0] = s.x, E[L + V + 1] = s.y, E[L + V + 2] = s.z, E[L + V + 3] = 0), _ === !0 && (s.fromBufferAttribute(U, P), E[L + V + 4] = s.x, E[L + V + 5] = s.y, E[L + V + 6] = s.z, E[L + V + 7] = 0), g === !0 && (s.fromBufferAttribute(D, P), E[L + V + 8] = s.x, E[L + V + 9] = s.y, E[L + V + 10] = s.z, E[L + V + 11] = D.itemSize === 4 ? s.w : 1);
        }
      }
      p = {
        count: d,
        texture: T,
        size: new ct(M, C)
      }, i.set(l, p), l.addEventListener("dispose", f);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(r, "morphTexture", a.morphTexture, n);
    else {
      let f = 0;
      for (let _ = 0; _ < u.length; _++)
        f += u[_];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      c.getUniforms().setValue(r, "morphTargetBaseInfluence", m), c.getUniforms().setValue(r, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(r, "morphTargetsTexture", p.texture, n), c.getUniforms().setValue(r, "morphTargetsTextureSize", p.size);
  }
  return {
    update: o
  };
}
function yP(r, e, n, i) {
  let s = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const u = i.render.frame, h = c.geometry, d = e.get(c, h);
    if (s.get(d) !== u && (e.update(d), s.set(d, u)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), s.get(c) !== u && (n.update(c.instanceMatrix, r.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, r.ARRAY_BUFFER), s.set(c, u))), c.isSkinnedMesh) {
      const p = c.skeleton;
      s.get(p) !== u && (p.update(), s.set(p, u));
    }
    return d;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
class ev extends Fn {
  constructor(e, n, i, s, o, a, l, c, u, h = Ko) {
    if (h !== Ko && h !== hl)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === Ko && (i = ta), i === void 0 && h === hl && (i = ul), super(null, s, o, a, l, c, h, i, u), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = l !== void 0 ? l : ii, this.minFilter = c !== void 0 ? c : ii, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const Db = /* @__PURE__ */ new Fn(), hy = /* @__PURE__ */ new ev(1, 1), kb = /* @__PURE__ */ new wb(), Rb = /* @__PURE__ */ new r2(), Lb = /* @__PURE__ */ new Ab(), dy = [], fy = [], py = new Float32Array(16), my = new Float32Array(9), gy = new Float32Array(4);
function xl(r, e, n) {
  const i = r[0];
  if (i <= 0 || i > 0) return r;
  const s = e * n;
  let o = dy[s];
  if (o === void 0 && (o = new Float32Array(s), dy[s] = o), e !== 0) {
    i.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, r[a].toArray(o, l);
  }
  return o;
}
function Wn(r, e) {
  if (r.length !== e.length) return !1;
  for (let n = 0, i = r.length; n < i; n++)
    if (r[n] !== e[n]) return !1;
  return !0;
}
function jn(r, e) {
  for (let n = 0, i = e.length; n < i; n++)
    r[n] = e[n];
}
function of(r, e) {
  let n = fy[e];
  n === void 0 && (n = new Int32Array(e), fy[e] = n);
  for (let i = 0; i !== e; ++i)
    n[i] = r.allocateTextureUnit();
  return n;
}
function _P(r, e) {
  const n = this.cache;
  n[0] !== e && (r.uniform1f(this.addr, e), n[0] = e);
}
function xP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Wn(n, e)) return;
    r.uniform2fv(this.addr, e), jn(n, e);
  }
}
function bP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Wn(n, e)) return;
    r.uniform3fv(this.addr, e), jn(n, e);
  }
}
function wP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Wn(n, e)) return;
    r.uniform4fv(this.addr, e), jn(n, e);
  }
}
function SP(r, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Wn(n, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), jn(n, e);
  } else {
    if (Wn(n, i)) return;
    gy.set(i), r.uniformMatrix2fv(this.addr, !1, gy), jn(n, i);
  }
}
function MP(r, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Wn(n, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), jn(n, e);
  } else {
    if (Wn(n, i)) return;
    my.set(i), r.uniformMatrix3fv(this.addr, !1, my), jn(n, i);
  }
}
function CP(r, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Wn(n, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), jn(n, e);
  } else {
    if (Wn(n, i)) return;
    py.set(i), r.uniformMatrix4fv(this.addr, !1, py), jn(n, i);
  }
}
function TP(r, e) {
  const n = this.cache;
  n[0] !== e && (r.uniform1i(this.addr, e), n[0] = e);
}
function EP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Wn(n, e)) return;
    r.uniform2iv(this.addr, e), jn(n, e);
  }
}
function AP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Wn(n, e)) return;
    r.uniform3iv(this.addr, e), jn(n, e);
  }
}
function PP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Wn(n, e)) return;
    r.uniform4iv(this.addr, e), jn(n, e);
  }
}
function DP(r, e) {
  const n = this.cache;
  n[0] !== e && (r.uniform1ui(this.addr, e), n[0] = e);
}
function kP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Wn(n, e)) return;
    r.uniform2uiv(this.addr, e), jn(n, e);
  }
}
function RP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Wn(n, e)) return;
    r.uniform3uiv(this.addr, e), jn(n, e);
  }
}
function LP(r, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Wn(n, e)) return;
    r.uniform4uiv(this.addr, e), jn(n, e);
  }
}
function IP(r, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (r.uniform1i(this.addr, s), i[0] = s);
  let o;
  this.type === r.SAMPLER_2D_SHADOW ? (hy.compareFunction = _b, o = hy) : o = Db, n.setTexture2D(e || o, s);
}
function OP(r, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (r.uniform1i(this.addr, s), i[0] = s), n.setTexture3D(e || Rb, s);
}
function FP(r, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (r.uniform1i(this.addr, s), i[0] = s), n.setTextureCube(e || Lb, s);
}
function UP(r, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (r.uniform1i(this.addr, s), i[0] = s), n.setTexture2DArray(e || kb, s);
}
function zP(r) {
  switch (r) {
    case 5126:
      return _P;
    case 35664:
      return xP;
    case 35665:
      return bP;
    case 35666:
      return wP;
    case 35674:
      return SP;
    case 35675:
      return MP;
    case 35676:
      return CP;
    case 5124:
    case 35670:
      return TP;
    case 35667:
    case 35671:
      return EP;
    case 35668:
    case 35672:
      return AP;
    case 35669:
    case 35673:
      return PP;
    case 5125:
      return DP;
    case 36294:
      return kP;
    case 36295:
      return RP;
    case 36296:
      return LP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return IP;
    case 35679:
    case 36299:
    case 36307:
      return OP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return FP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return UP;
  }
}
function BP(r, e) {
  r.uniform1fv(this.addr, e);
}
function NP(r, e) {
  const n = xl(e, this.size, 2);
  r.uniform2fv(this.addr, n);
}
function VP(r, e) {
  const n = xl(e, this.size, 3);
  r.uniform3fv(this.addr, n);
}
function GP(r, e) {
  const n = xl(e, this.size, 4);
  r.uniform4fv(this.addr, n);
}
function HP(r, e) {
  const n = xl(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, n);
}
function WP(r, e) {
  const n = xl(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, n);
}
function jP(r, e) {
  const n = xl(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, n);
}
function $P(r, e) {
  r.uniform1iv(this.addr, e);
}
function XP(r, e) {
  r.uniform2iv(this.addr, e);
}
function YP(r, e) {
  r.uniform3iv(this.addr, e);
}
function qP(r, e) {
  r.uniform4iv(this.addr, e);
}
function ZP(r, e) {
  r.uniform1uiv(this.addr, e);
}
function KP(r, e) {
  r.uniform2uiv(this.addr, e);
}
function JP(r, e) {
  r.uniform3uiv(this.addr, e);
}
function QP(r, e) {
  r.uniform4uiv(this.addr, e);
}
function eD(r, e, n) {
  const i = this.cache, s = e.length, o = of(n, s);
  Wn(i, o) || (r.uniform1iv(this.addr, o), jn(i, o));
  for (let a = 0; a !== s; ++a)
    n.setTexture2D(e[a] || Db, o[a]);
}
function tD(r, e, n) {
  const i = this.cache, s = e.length, o = of(n, s);
  Wn(i, o) || (r.uniform1iv(this.addr, o), jn(i, o));
  for (let a = 0; a !== s; ++a)
    n.setTexture3D(e[a] || Rb, o[a]);
}
function nD(r, e, n) {
  const i = this.cache, s = e.length, o = of(n, s);
  Wn(i, o) || (r.uniform1iv(this.addr, o), jn(i, o));
  for (let a = 0; a !== s; ++a)
    n.setTextureCube(e[a] || Lb, o[a]);
}
function iD(r, e, n) {
  const i = this.cache, s = e.length, o = of(n, s);
  Wn(i, o) || (r.uniform1iv(this.addr, o), jn(i, o));
  for (let a = 0; a !== s; ++a)
    n.setTexture2DArray(e[a] || kb, o[a]);
}
function sD(r) {
  switch (r) {
    case 5126:
      return BP;
    case 35664:
      return NP;
    case 35665:
      return VP;
    case 35666:
      return GP;
    case 35674:
      return HP;
    case 35675:
      return WP;
    case 35676:
      return jP;
    case 5124:
    case 35670:
      return $P;
    case 35667:
    case 35671:
      return XP;
    case 35668:
    case 35672:
      return YP;
    case 35669:
    case 35673:
      return qP;
    case 5125:
      return ZP;
    case 36294:
      return KP;
    case 36295:
      return JP;
    case 36296:
      return QP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return eD;
    case 35679:
    case 36299:
    case 36307:
      return tD;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return nD;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return iD;
  }
}
class rD {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.setValue = zP(n.type);
  }
}
class oD {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = sD(n.type);
  }
}
class aD {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const s = this.seq;
    for (let o = 0, a = s.length; o !== a; ++o) {
      const l = s[o];
      l.setValue(e, n[l.id], i);
    }
  }
}
const yp = /(\w+)(\])?(\[|\.)?/g;
function vy(r, e) {
  r.seq.push(e), r.map[e.id] = e;
}
function lD(r, e, n) {
  const i = r.name, s = i.length;
  for (yp.lastIndex = 0; ; ) {
    const o = yp.exec(i), a = yp.lastIndex;
    let l = o[1];
    const c = o[2] === "]", u = o[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && a + 2 === s) {
      vy(n, u === void 0 ? new rD(l, r, e) : new oD(l, r, e));
      break;
    } else {
      let d = n.map[l];
      d === void 0 && (d = new aD(l), vy(n, d)), n = d;
    }
  }
}
class Zh {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < i; ++s) {
      const o = e.getActiveUniform(n, s), a = e.getUniformLocation(n, o.name);
      lD(o, a, this);
    }
  }
  setValue(e, n, i, s) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, i, s);
  }
  setOptional(e, n, i) {
    const s = n[i];
    s !== void 0 && this.setValue(e, i, s);
  }
  static upload(e, n, i, s) {
    for (let o = 0, a = n.length; o !== a; ++o) {
      const l = n[o], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, s);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let s = 0, o = e.length; s !== o; ++s) {
      const a = e[s];
      a.id in n && i.push(a);
    }
    return i;
  }
}
function yy(r, e, n) {
  const i = r.createShader(e);
  return r.shaderSource(i, n), r.compileShader(i), i;
}
const cD = 37297;
let uD = 0;
function hD(r, e) {
  const n = r.split(`
`), i = [], s = Math.max(e - 6, 0), o = Math.min(e + 6, n.length);
  for (let a = s; a < o; a++) {
    const l = a + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${n[a]}`);
  }
  return i.join(`
`);
}
const _y = /* @__PURE__ */ new Dt();
function dD(r) {
  Nt._getMatrix(_y, Nt.workingColorSpace, r);
  const e = `mat3( ${_y.elements.map((n) => n.toFixed(4))} )`;
  switch (Nt.getTransfer(r)) {
    case sf:
      return [e, "LinearTransferOETF"];
    case nn:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"];
  }
}
function xy(r, e, n) {
  const i = r.getShaderParameter(e, r.COMPILE_STATUS), s = r.getShaderInfoLog(e).trim();
  if (i && s === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(s);
  if (o) {
    const a = parseInt(o[1]);
    return n.toUpperCase() + `

` + s + `

` + hD(r.getShaderSource(e), a);
  } else
    return s;
}
function fD(r, e) {
  const n = dD(e);
  return [
    `vec4 ${r}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function pD(r, e) {
  let n;
  switch (e) {
    case sb:
      n = "Linear";
      break;
    case rb:
      n = "Reinhard";
      break;
    case ob:
      n = "Cineon";
      break;
    case Ng:
      n = "ACESFilmic";
      break;
    case ab:
      n = "AgX";
      break;
    case lb:
      n = "Neutral";
      break;
    case MT:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
const Yu = /* @__PURE__ */ new he();
function mD() {
  Nt.getLuminanceCoefficients(Yu);
  const r = Yu.x.toFixed(4), e = Yu.y.toFixed(4), n = Yu.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function gD(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(lc).join(`
`);
}
function vD(r) {
  const e = [];
  for (const n in r) {
    const i = r[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function yD(r, e) {
  const n = {}, i = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let s = 0; s < i; s++) {
    const o = r.getActiveAttrib(e, s), a = o.name;
    let l = 1;
    o.type === r.FLOAT_MAT2 && (l = 2), o.type === r.FLOAT_MAT3 && (l = 3), o.type === r.FLOAT_MAT4 && (l = 4), n[a] = {
      type: o.type,
      location: r.getAttribLocation(e, a),
      locationSize: l
    };
  }
  return n;
}
function lc(r) {
  return r !== "";
}
function by(r, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function wy(r, e) {
  return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const _D = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Jm(r) {
  return r.replace(_D, bD);
}
const xD = /* @__PURE__ */ new Map();
function bD(r, e) {
  let n = kt[e];
  if (n === void 0) {
    const i = xD.get(e);
    if (i !== void 0)
      n = kt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Jm(n);
}
const wD = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Sy(r) {
  return r.replace(wD, SD);
}
function SD(r, e, n, i) {
  let s = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    s += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return s;
}
function My(r) {
  let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function MD(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === Kx ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === Jx ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === rr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function CD(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case ll:
      case cl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case nf:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function TD(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case cl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function ED(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case ib:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case wT:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case ST:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function AD(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function PD(r, e, n, i) {
  const s = r.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = MD(n), u = CD(n), h = TD(n), d = ED(n), p = AD(n), f = gD(n), m = vD(o), _ = s.createProgram();
  let g, v, S = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (g = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m
  ].filter(lc).join(`
`), g.length > 0 && (g += `
`), v = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m
  ].filter(lc).join(`
`), v.length > 0 && (v += `
`)) : (g = [
    My(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + h : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(lc).join(`
`), v = [
    My(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + h : "",
    n.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.dispersion ? "#define USE_DISPERSION" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== ro ? "#define TONE_MAPPING" : "",
    n.toneMapping !== ro ? kt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== ro ? pD("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    kt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    fD("linearToOutputTexel", n.outputColorSpace),
    mD(),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(lc).join(`
`)), a = Jm(a), a = by(a, n), a = wy(a, n), l = Jm(l), l = by(l, n), l = wy(l, n), a = Sy(a), l = Sy(l), n.isRawShaderMaterial !== !0 && (S = `#version 300 es
`, g = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, v = [
    "#define varying in",
    n.glslVersion === F0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === F0 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + v);
  const b = S + g + a, x = S + v + l, M = yy(s, s.VERTEX_SHADER, b), C = yy(s, s.FRAGMENT_SHADER, x);
  s.attachShader(_, M), s.attachShader(_, C), n.index0AttributeName !== void 0 ? s.bindAttribLocation(_, 0, n.index0AttributeName) : n.morphTargets === !0 && s.bindAttribLocation(_, 0, "position"), s.linkProgram(_);
  function E(O) {
    if (r.debug.checkShaderErrors) {
      const U = s.getProgramInfoLog(_).trim(), D = s.getShaderInfoLog(M).trim(), L = s.getShaderInfoLog(C).trim();
      let P = !0, V = !0;
      if (s.getProgramParameter(_, s.LINK_STATUS) === !1)
        if (P = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(s, _, M, C);
        else {
          const ce = xy(s, M, "vertex"), q = xy(s, C, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(_, s.VALIDATE_STATUS) + `

Material Name: ` + O.name + `
Material Type: ` + O.type + `

Program Info Log: ` + U + `
` + ce + `
` + q
          );
        }
      else U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (D === "" || L === "") && (V = !1);
      V && (O.diagnostics = {
        runnable: P,
        programLog: U,
        vertexShader: {
          log: D,
          prefix: g
        },
        fragmentShader: {
          log: L,
          prefix: v
        }
      });
    }
    s.deleteShader(M), s.deleteShader(C), T = new Zh(s, _), w = yD(s, _);
  }
  let T;
  this.getUniforms = function() {
    return T === void 0 && E(this), T;
  };
  let w;
  this.getAttributes = function() {
    return w === void 0 && E(this), w;
  };
  let A = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return A === !1 && (A = s.getProgramParameter(_, cD)), A;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), s.deleteProgram(_), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = uD++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = M, this.fragmentShader = C, this;
}
let DD = 0;
class kD {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, s = this._getShaderStage(n), o = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
    return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(o) === !1 && (a.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && (i = new RD(e), n.set(e, i)), i;
  }
}
class RD {
  constructor(e) {
    this.id = DD++, this.code = e, this.usedTimes = 0;
  }
}
function LD(r, e, n, i, s, o, a) {
  const l = new Kg(), c = new kD(), u = /* @__PURE__ */ new Set(), h = [], d = s.logarithmicDepthBuffer, p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(w) {
    return u.add(w), w === 0 ? "uv" : `uv${w}`;
  }
  function g(w, A, O, U, D) {
    const L = U.fog, P = D.geometry, V = w.isMeshStandardMaterial ? U.environment : null, ce = (w.isMeshStandardMaterial ? n : e).get(w.envMap || V), q = ce && ce.mapping === nf ? ce.image.height : null, oe = m[w.type];
    w.precision !== null && (f = s.getMaxPrecision(w.precision), f !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", f, "instead."));
    const ne = P.morphAttributes.position || P.morphAttributes.normal || P.morphAttributes.color, $ = ne !== void 0 ? ne.length : 0;
    let J = 0;
    P.morphAttributes.position !== void 0 && (J = 1), P.morphAttributes.normal !== void 0 && (J = 2), P.morphAttributes.color !== void 0 && (J = 3);
    let se, le, re, ye;
    if (oe) {
      const mt = zs[oe];
      se = mt.vertexShader, le = mt.fragmentShader;
    } else
      se = w.vertexShader, le = w.fragmentShader, c.update(w), re = c.getVertexShaderID(w), ye = c.getFragmentShaderID(w);
    const H = r.getRenderTarget(), K = r.state.buffers.depth.getReversed(), G = D.isInstancedMesh === !0, R = D.isBatchedMesh === !0, z = !!w.map, I = !!w.matcap, Q = !!ce, X = !!w.aoMap, k = !!w.lightMap, ee = !!w.bumpMap, Z = !!w.normalMap, N = !!w.displacementMap, j = !!w.emissiveMap, te = !!w.metalnessMap, F = !!w.roughnessMap, B = w.anisotropy > 0, Y = w.clearcoat > 0, fe = w.dispersion > 0, ge = w.iridescence > 0, xe = w.sheen > 0, De = w.transmission > 0, ae = B && !!w.anisotropyMap, de = Y && !!w.clearcoatMap, Ee = Y && !!w.clearcoatNormalMap, be = Y && !!w.clearcoatRoughnessMap, ke = ge && !!w.iridescenceMap, ze = ge && !!w.iridescenceThicknessMap, Te = xe && !!w.sheenColorMap, Pe = xe && !!w.sheenRoughnessMap, Ge = !!w.specularMap, Ve = !!w.specularColorMap, Qe = !!w.specularIntensityMap, _e = De && !!w.transmissionMap, Ue = De && !!w.thicknessMap, Fe = !!w.gradientMap, je = !!w.alphaMap, Ke = w.alphaTest > 0, qe = !!w.alphaHash, ut = !!w.extensions;
    let ot = ro;
    w.toneMapped && (H === null || H.isXRRenderTarget === !0) && (ot = r.toneMapping);
    const dt = {
      shaderID: oe,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: se,
      fragmentShader: le,
      defines: w.defines,
      customVertexShaderID: re,
      customFragmentShaderID: ye,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: f,
      batching: R,
      batchingColor: R && D._colorsTexture !== null,
      instancing: G,
      instancingColor: G && D.instanceColor !== null,
      instancingMorph: G && D.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: H === null ? r.outputColorSpace : H.isXRRenderTarget === !0 ? H.texture.colorSpace : _l,
      alphaToCoverage: !!w.alphaToCoverage,
      map: z,
      matcap: I,
      envMap: Q,
      envMapMode: Q && ce.mapping,
      envMapCubeUVHeight: q,
      aoMap: X,
      lightMap: k,
      bumpMap: ee,
      normalMap: Z,
      displacementMap: p && N,
      emissiveMap: j,
      normalMapObjectSpace: Z && w.normalMapType === ET,
      normalMapTangentSpace: Z && w.normalMapType === Yg,
      metalnessMap: te,
      roughnessMap: F,
      anisotropy: B,
      anisotropyMap: ae,
      clearcoat: Y,
      clearcoatMap: de,
      clearcoatNormalMap: Ee,
      clearcoatRoughnessMap: be,
      dispersion: fe,
      iridescence: ge,
      iridescenceMap: ke,
      iridescenceThicknessMap: ze,
      sheen: xe,
      sheenColorMap: Te,
      sheenRoughnessMap: Pe,
      specularMap: Ge,
      specularColorMap: Ve,
      specularIntensityMap: Qe,
      transmission: De,
      transmissionMap: _e,
      thicknessMap: Ue,
      gradientMap: Fe,
      opaque: w.transparent === !1 && w.blending === xs && w.alphaToCoverage === !1,
      alphaMap: je,
      alphaTest: Ke,
      alphaHash: qe,
      combine: w.combine,
      //
      mapUv: z && _(w.map.channel),
      aoMapUv: X && _(w.aoMap.channel),
      lightMapUv: k && _(w.lightMap.channel),
      bumpMapUv: ee && _(w.bumpMap.channel),
      normalMapUv: Z && _(w.normalMap.channel),
      displacementMapUv: N && _(w.displacementMap.channel),
      emissiveMapUv: j && _(w.emissiveMap.channel),
      metalnessMapUv: te && _(w.metalnessMap.channel),
      roughnessMapUv: F && _(w.roughnessMap.channel),
      anisotropyMapUv: ae && _(w.anisotropyMap.channel),
      clearcoatMapUv: de && _(w.clearcoatMap.channel),
      clearcoatNormalMapUv: Ee && _(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: be && _(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ke && _(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: ze && _(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: Te && _(w.sheenColorMap.channel),
      sheenRoughnessMapUv: Pe && _(w.sheenRoughnessMap.channel),
      specularMapUv: Ge && _(w.specularMap.channel),
      specularColorMapUv: Ve && _(w.specularColorMap.channel),
      specularIntensityMapUv: Qe && _(w.specularIntensityMap.channel),
      transmissionMapUv: _e && _(w.transmissionMap.channel),
      thicknessMapUv: Ue && _(w.thicknessMap.channel),
      alphaMapUv: je && _(w.alphaMap.channel),
      //
      vertexTangents: !!P.attributes.tangent && (Z || B),
      vertexColors: w.vertexColors,
      vertexAlphas: w.vertexColors === !0 && !!P.attributes.color && P.attributes.color.itemSize === 4,
      pointsUvs: D.isPoints === !0 && !!P.attributes.uv && (z || je),
      fog: !!L,
      useFog: w.fog === !0,
      fogExp2: !!L && L.isFogExp2,
      flatShading: w.flatShading === !0,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      reverseDepthBuffer: K,
      skinning: D.isSkinnedMesh === !0,
      morphTargets: P.morphAttributes.position !== void 0,
      morphNormals: P.morphAttributes.normal !== void 0,
      morphColors: P.morphAttributes.color !== void 0,
      morphTargetsCount: $,
      morphTextureStride: J,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numSpotLightMaps: A.spotLightMap.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
      numLightProbes: A.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: r.shadowMap.enabled && O.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: ot,
      decodeVideoTexture: z && w.map.isVideoTexture === !0 && Nt.getTransfer(w.map.colorSpace) === nn,
      decodeVideoTextureEmissive: j && w.emissiveMap.isVideoTexture === !0 && Nt.getTransfer(w.emissiveMap.colorSpace) === nn,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === Pn,
      flipSided: w.side === Oi,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionClipCullDistance: ut && w.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ut && w.extensions.multiDraw === !0 || R) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: w.customProgramCacheKey()
    };
    return dt.vertexUv1s = u.has(1), dt.vertexUv2s = u.has(2), dt.vertexUv3s = u.has(3), u.clear(), dt;
  }
  function v(w) {
    const A = [];
    if (w.shaderID ? A.push(w.shaderID) : (A.push(w.customVertexShaderID), A.push(w.customFragmentShaderID)), w.defines !== void 0)
      for (const O in w.defines)
        A.push(O), A.push(w.defines[O]);
    return w.isRawShaderMaterial === !1 && (S(A, w), b(A, w), A.push(r.outputColorSpace)), A.push(w.customProgramCacheKey), A.join();
  }
  function S(w, A) {
    w.push(A.precision), w.push(A.outputColorSpace), w.push(A.envMapMode), w.push(A.envMapCubeUVHeight), w.push(A.mapUv), w.push(A.alphaMapUv), w.push(A.lightMapUv), w.push(A.aoMapUv), w.push(A.bumpMapUv), w.push(A.normalMapUv), w.push(A.displacementMapUv), w.push(A.emissiveMapUv), w.push(A.metalnessMapUv), w.push(A.roughnessMapUv), w.push(A.anisotropyMapUv), w.push(A.clearcoatMapUv), w.push(A.clearcoatNormalMapUv), w.push(A.clearcoatRoughnessMapUv), w.push(A.iridescenceMapUv), w.push(A.iridescenceThicknessMapUv), w.push(A.sheenColorMapUv), w.push(A.sheenRoughnessMapUv), w.push(A.specularMapUv), w.push(A.specularColorMapUv), w.push(A.specularIntensityMapUv), w.push(A.transmissionMapUv), w.push(A.thicknessMapUv), w.push(A.combine), w.push(A.fogExp2), w.push(A.sizeAttenuation), w.push(A.morphTargetsCount), w.push(A.morphAttributeCount), w.push(A.numDirLights), w.push(A.numPointLights), w.push(A.numSpotLights), w.push(A.numSpotLightMaps), w.push(A.numHemiLights), w.push(A.numRectAreaLights), w.push(A.numDirLightShadows), w.push(A.numPointLightShadows), w.push(A.numSpotLightShadows), w.push(A.numSpotLightShadowsWithMaps), w.push(A.numLightProbes), w.push(A.shadowMapType), w.push(A.toneMapping), w.push(A.numClippingPlanes), w.push(A.numClipIntersection), w.push(A.depthPacking);
  }
  function b(w, A) {
    l.disableAll(), A.supportsVertexTextures && l.enable(0), A.instancing && l.enable(1), A.instancingColor && l.enable(2), A.instancingMorph && l.enable(3), A.matcap && l.enable(4), A.envMap && l.enable(5), A.normalMapObjectSpace && l.enable(6), A.normalMapTangentSpace && l.enable(7), A.clearcoat && l.enable(8), A.iridescence && l.enable(9), A.alphaTest && l.enable(10), A.vertexColors && l.enable(11), A.vertexAlphas && l.enable(12), A.vertexUv1s && l.enable(13), A.vertexUv2s && l.enable(14), A.vertexUv3s && l.enable(15), A.vertexTangents && l.enable(16), A.anisotropy && l.enable(17), A.alphaHash && l.enable(18), A.batching && l.enable(19), A.dispersion && l.enable(20), A.batchingColor && l.enable(21), w.push(l.mask), l.disableAll(), A.fog && l.enable(0), A.useFog && l.enable(1), A.flatShading && l.enable(2), A.logarithmicDepthBuffer && l.enable(3), A.reverseDepthBuffer && l.enable(4), A.skinning && l.enable(5), A.morphTargets && l.enable(6), A.morphNormals && l.enable(7), A.morphColors && l.enable(8), A.premultipliedAlpha && l.enable(9), A.shadowMapEnabled && l.enable(10), A.doubleSided && l.enable(11), A.flipSided && l.enable(12), A.useDepthPacking && l.enable(13), A.dithering && l.enable(14), A.transmission && l.enable(15), A.sheen && l.enable(16), A.opaque && l.enable(17), A.pointsUvs && l.enable(18), A.decodeVideoTexture && l.enable(19), A.decodeVideoTextureEmissive && l.enable(20), A.alphaToCoverage && l.enable(21), w.push(l.mask);
  }
  function x(w) {
    const A = m[w.type];
    let O;
    if (A) {
      const U = zs[A];
      O = uu.clone(U.uniforms);
    } else
      O = w.uniforms;
    return O;
  }
  function M(w, A) {
    let O;
    for (let U = 0, D = h.length; U < D; U++) {
      const L = h[U];
      if (L.cacheKey === A) {
        O = L, ++O.usedTimes;
        break;
      }
    }
    return O === void 0 && (O = new PD(r, A, w, o), h.push(O)), O;
  }
  function C(w) {
    if (--w.usedTimes === 0) {
      const A = h.indexOf(w);
      h[A] = h[h.length - 1], h.pop(), w.destroy();
    }
  }
  function E(w) {
    c.remove(w);
  }
  function T() {
    c.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: v,
    getUniforms: x,
    acquireProgram: M,
    releaseProgram: C,
    releaseShaderCache: E,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: T
  };
}
function ID() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(a) {
    return r.has(a);
  }
  function n(a) {
    let l = r.get(a);
    return l === void 0 && (l = {}, r.set(a, l)), l;
  }
  function i(a) {
    r.delete(a);
  }
  function s(a, l, c) {
    r.get(a)[l] = c;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: n,
    remove: i,
    update: s,
    dispose: o
  };
}
function OD(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
}
function Cy(r, e) {
  return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
}
function Ty() {
  const r = [];
  let e = 0;
  const n = [], i = [], s = [];
  function o() {
    e = 0, n.length = 0, i.length = 0, s.length = 0;
  }
  function a(d, p, f, m, _, g) {
    let v = r[e];
    return v === void 0 ? (v = {
      id: d.id,
      object: d,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: d.renderOrder,
      z: _,
      group: g
    }, r[e] = v) : (v.id = d.id, v.object = d, v.geometry = p, v.material = f, v.groupOrder = m, v.renderOrder = d.renderOrder, v.z = _, v.group = g), e++, v;
  }
  function l(d, p, f, m, _, g) {
    const v = a(d, p, f, m, _, g);
    f.transmission > 0 ? i.push(v) : f.transparent === !0 ? s.push(v) : n.push(v);
  }
  function c(d, p, f, m, _, g) {
    const v = a(d, p, f, m, _, g);
    f.transmission > 0 ? i.unshift(v) : f.transparent === !0 ? s.unshift(v) : n.unshift(v);
  }
  function u(d, p) {
    n.length > 1 && n.sort(d || OD), i.length > 1 && i.sort(p || Cy), s.length > 1 && s.sort(p || Cy);
  }
  function h() {
    for (let d = e, p = r.length; d < p; d++) {
      const f = r[d];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: s,
    init: o,
    push: l,
    unshift: c,
    finish: h,
    sort: u
  };
}
function FD() {
  let r = /* @__PURE__ */ new WeakMap();
  function e(i, s) {
    const o = r.get(i);
    let a;
    return o === void 0 ? (a = new Ty(), r.set(i, [a])) : s >= o.length ? (a = new Ty(), o.push(a)) : a = o[s], a;
  }
  function n() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function UD() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new he(),
            color: new Tt()
          };
          break;
        case "SpotLight":
          n = {
            position: new he(),
            direction: new he(),
            color: new Tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new he(),
            color: new Tt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new he(),
            skyColor: new Tt(),
            groundColor: new Tt()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Tt(),
            position: new he(),
            halfWidth: new he(),
            halfHeight: new he()
          };
          break;
      }
      return r[e.id] = n, n;
    }
  };
}
function zD() {
  const r = {};
  return {
    get: function(e) {
      if (r[e.id] !== void 0)
        return r[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ct()
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ct()
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ct(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[e.id] = n, n;
    }
  };
}
let BD = 0;
function ND(r, e) {
  return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
}
function VD(r) {
  const e = new UD(), n = zD(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) i.probe.push(new he());
  const s = new he(), o = new rn(), a = new rn();
  function l(u) {
    let h = 0, d = 0, p = 0;
    for (let w = 0; w < 9; w++) i.probe[w].set(0, 0, 0);
    let f = 0, m = 0, _ = 0, g = 0, v = 0, S = 0, b = 0, x = 0, M = 0, C = 0, E = 0;
    u.sort(ND);
    for (let w = 0, A = u.length; w < A; w++) {
      const O = u[w], U = O.color, D = O.intensity, L = O.distance, P = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
      if (O.isAmbientLight)
        h += U.r * D, d += U.g * D, p += U.b * D;
      else if (O.isLightProbe) {
        for (let V = 0; V < 9; V++)
          i.probe[V].addScaledVector(O.sh.coefficients[V], D);
        E++;
      } else if (O.isDirectionalLight) {
        const V = e.get(O);
        if (V.color.copy(O.color).multiplyScalar(O.intensity), O.castShadow) {
          const ce = O.shadow, q = n.get(O);
          q.shadowIntensity = ce.intensity, q.shadowBias = ce.bias, q.shadowNormalBias = ce.normalBias, q.shadowRadius = ce.radius, q.shadowMapSize = ce.mapSize, i.directionalShadow[f] = q, i.directionalShadowMap[f] = P, i.directionalShadowMatrix[f] = O.shadow.matrix, S++;
        }
        i.directional[f] = V, f++;
      } else if (O.isSpotLight) {
        const V = e.get(O);
        V.position.setFromMatrixPosition(O.matrixWorld), V.color.copy(U).multiplyScalar(D), V.distance = L, V.coneCos = Math.cos(O.angle), V.penumbraCos = Math.cos(O.angle * (1 - O.penumbra)), V.decay = O.decay, i.spot[_] = V;
        const ce = O.shadow;
        if (O.map && (i.spotLightMap[M] = O.map, M++, ce.updateMatrices(O), O.castShadow && C++), i.spotLightMatrix[_] = ce.matrix, O.castShadow) {
          const q = n.get(O);
          q.shadowIntensity = ce.intensity, q.shadowBias = ce.bias, q.shadowNormalBias = ce.normalBias, q.shadowRadius = ce.radius, q.shadowMapSize = ce.mapSize, i.spotShadow[_] = q, i.spotShadowMap[_] = P, x++;
        }
        _++;
      } else if (O.isRectAreaLight) {
        const V = e.get(O);
        V.color.copy(U).multiplyScalar(D), V.halfWidth.set(O.width * 0.5, 0, 0), V.halfHeight.set(0, O.height * 0.5, 0), i.rectArea[g] = V, g++;
      } else if (O.isPointLight) {
        const V = e.get(O);
        if (V.color.copy(O.color).multiplyScalar(O.intensity), V.distance = O.distance, V.decay = O.decay, O.castShadow) {
          const ce = O.shadow, q = n.get(O);
          q.shadowIntensity = ce.intensity, q.shadowBias = ce.bias, q.shadowNormalBias = ce.normalBias, q.shadowRadius = ce.radius, q.shadowMapSize = ce.mapSize, q.shadowCameraNear = ce.camera.near, q.shadowCameraFar = ce.camera.far, i.pointShadow[m] = q, i.pointShadowMap[m] = P, i.pointShadowMatrix[m] = O.shadow.matrix, b++;
        }
        i.point[m] = V, m++;
      } else if (O.isHemisphereLight) {
        const V = e.get(O);
        V.skyColor.copy(O.color).multiplyScalar(D), V.groundColor.copy(O.groundColor).multiplyScalar(D), i.hemi[v] = V, v++;
      }
    }
    g > 0 && (r.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = at.LTC_FLOAT_1, i.rectAreaLTC2 = at.LTC_FLOAT_2) : (i.rectAreaLTC1 = at.LTC_HALF_1, i.rectAreaLTC2 = at.LTC_HALF_2)), i.ambient[0] = h, i.ambient[1] = d, i.ambient[2] = p;
    const T = i.hash;
    (T.directionalLength !== f || T.pointLength !== m || T.spotLength !== _ || T.rectAreaLength !== g || T.hemiLength !== v || T.numDirectionalShadows !== S || T.numPointShadows !== b || T.numSpotShadows !== x || T.numSpotMaps !== M || T.numLightProbes !== E) && (i.directional.length = f, i.spot.length = _, i.rectArea.length = g, i.point.length = m, i.hemi.length = v, i.directionalShadow.length = S, i.directionalShadowMap.length = S, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = S, i.pointShadowMatrix.length = b, i.spotLightMatrix.length = x + M - C, i.spotLightMap.length = M, i.numSpotLightShadowsWithMaps = C, i.numLightProbes = E, T.directionalLength = f, T.pointLength = m, T.spotLength = _, T.rectAreaLength = g, T.hemiLength = v, T.numDirectionalShadows = S, T.numPointShadows = b, T.numSpotShadows = x, T.numSpotMaps = M, T.numLightProbes = E, i.version = BD++);
  }
  function c(u, h) {
    let d = 0, p = 0, f = 0, m = 0, _ = 0;
    const g = h.matrixWorldInverse;
    for (let v = 0, S = u.length; v < S; v++) {
      const b = u[v];
      if (b.isDirectionalLight) {
        const x = i.directional[d];
        x.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(g), d++;
      } else if (b.isSpotLight) {
        const x = i.spot[f];
        x.position.setFromMatrixPosition(b.matrixWorld), x.position.applyMatrix4(g), x.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), x.direction.sub(s), x.direction.transformDirection(g), f++;
      } else if (b.isRectAreaLight) {
        const x = i.rectArea[m];
        x.position.setFromMatrixPosition(b.matrixWorld), x.position.applyMatrix4(g), a.identity(), o.copy(b.matrixWorld), o.premultiply(g), a.extractRotation(o), x.halfWidth.set(b.width * 0.5, 0, 0), x.halfHeight.set(0, b.height * 0.5, 0), x.halfWidth.applyMatrix4(a), x.halfHeight.applyMatrix4(a), m++;
      } else if (b.isPointLight) {
        const x = i.point[p];
        x.position.setFromMatrixPosition(b.matrixWorld), x.position.applyMatrix4(g), p++;
      } else if (b.isHemisphereLight) {
        const x = i.hemi[_];
        x.direction.setFromMatrixPosition(b.matrixWorld), x.direction.transformDirection(g), _++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: i
  };
}
function Ey(r) {
  const e = new VD(r), n = [], i = [];
  function s(h) {
    u.camera = h, n.length = 0, i.length = 0;
  }
  function o(h) {
    n.push(h);
  }
  function a(h) {
    i.push(h);
  }
  function l() {
    e.setup(n);
  }
  function c(h) {
    e.setupView(n, h);
  }
  const u = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: s,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a
  };
}
function GD(r) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(s, o = 0) {
    const a = e.get(s);
    let l;
    return a === void 0 ? (l = new Ey(r), e.set(s, [l])) : o >= a.length ? (l = new Ey(r), a.push(l)) : l = a[o], l;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class tv extends oa {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = TT, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Ib extends oa {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const HD = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, WD = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function jD(r, e, n) {
  let i = new Jg();
  const s = new ct(), o = new ct(), a = new Jt(), l = new tv({ depthPacking: Xg }), c = new Ib(), u = {}, h = n.maxTextureSize, d = { [ao]: Oi, [Oi]: ao, [Pn]: Pn }, p = new si({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ct() },
      radius: { value: 4 }
    },
    vertexShader: HD,
    fragmentShader: WD
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new Wt();
  m.setAttribute(
    "position",
    new qi(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new tt(m, p), g = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Kx;
  let v = this.type;
  this.render = function(C, E, T) {
    if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || C.length === 0) return;
    const w = r.getRenderTarget(), A = r.getActiveCubeFace(), O = r.getActiveMipmapLevel(), U = r.state;
    U.setBlending(Hs), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
    const D = v !== rr && this.type === rr, L = v === rr && this.type !== rr;
    for (let P = 0, V = C.length; P < V; P++) {
      const ce = C[P], q = ce.shadow;
      if (q === void 0) {
        console.warn("THREE.WebGLShadowMap:", ce, "has no shadow.");
        continue;
      }
      if (q.autoUpdate === !1 && q.needsUpdate === !1) continue;
      s.copy(q.mapSize);
      const oe = q.getFrameExtents();
      if (s.multiply(oe), o.copy(q.mapSize), (s.x > h || s.y > h) && (s.x > h && (o.x = Math.floor(h / oe.x), s.x = o.x * oe.x, q.mapSize.x = o.x), s.y > h && (o.y = Math.floor(h / oe.y), s.y = o.y * oe.y, q.mapSize.y = o.y)), q.map === null || D === !0 || L === !0) {
        const $ = this.type !== rr ? { minFilter: ii, magFilter: ii } : {};
        q.map !== null && q.map.dispose(), q.map = new Es(s.x, s.y, $), q.map.texture.name = ce.name + ".shadowMap", q.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(q.map), r.clear();
      const ne = q.getViewportCount();
      for (let $ = 0; $ < ne; $++) {
        const J = q.getViewport($);
        a.set(
          o.x * J.x,
          o.y * J.y,
          o.x * J.z,
          o.y * J.w
        ), U.viewport(a), q.updateMatrices(ce, $), i = q.getFrustum(), x(E, T, q.camera, ce, this.type);
      }
      q.isPointLightShadow !== !0 && this.type === rr && S(q, T), q.needsUpdate = !1;
    }
    v = this.type, g.needsUpdate = !1, r.setRenderTarget(w, A, O);
  };
  function S(C, E) {
    const T = e.update(_);
    p.defines.VSM_SAMPLES !== C.blurSamples && (p.defines.VSM_SAMPLES = C.blurSamples, f.defines.VSM_SAMPLES = C.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), C.mapPass === null && (C.mapPass = new Es(s.x, s.y)), p.uniforms.shadow_pass.value = C.map.texture, p.uniforms.resolution.value = C.mapSize, p.uniforms.radius.value = C.radius, r.setRenderTarget(C.mapPass), r.clear(), r.renderBufferDirect(E, null, T, p, _, null), f.uniforms.shadow_pass.value = C.mapPass.texture, f.uniforms.resolution.value = C.mapSize, f.uniforms.radius.value = C.radius, r.setRenderTarget(C.map), r.clear(), r.renderBufferDirect(E, null, T, f, _, null);
  }
  function b(C, E, T, w) {
    let A = null;
    const O = T.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (O !== void 0)
      A = O;
    else if (A = T.isPointLight === !0 ? c : l, r.localClippingEnabled && E.clipShadows === !0 && Array.isArray(E.clippingPlanes) && E.clippingPlanes.length !== 0 || E.displacementMap && E.displacementScale !== 0 || E.alphaMap && E.alphaTest > 0 || E.map && E.alphaTest > 0) {
      const U = A.uuid, D = E.uuid;
      let L = u[U];
      L === void 0 && (L = {}, u[U] = L);
      let P = L[D];
      P === void 0 && (P = A.clone(), L[D] = P, E.addEventListener("dispose", M)), A = P;
    }
    if (A.visible = E.visible, A.wireframe = E.wireframe, w === rr ? A.side = E.shadowSide !== null ? E.shadowSide : E.side : A.side = E.shadowSide !== null ? E.shadowSide : d[E.side], A.alphaMap = E.alphaMap, A.alphaTest = E.alphaTest, A.map = E.map, A.clipShadows = E.clipShadows, A.clippingPlanes = E.clippingPlanes, A.clipIntersection = E.clipIntersection, A.displacementMap = E.displacementMap, A.displacementScale = E.displacementScale, A.displacementBias = E.displacementBias, A.wireframeLinewidth = E.wireframeLinewidth, A.linewidth = E.linewidth, T.isPointLight === !0 && A.isMeshDistanceMaterial === !0) {
      const U = r.properties.get(A);
      U.light = T;
    }
    return A;
  }
  function x(C, E, T, w, A) {
    if (C.visible === !1) return;
    if (C.layers.test(E.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && A === rr) && (!C.frustumCulled || i.intersectsObject(C))) {
      C.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, C.matrixWorld);
      const D = e.update(C), L = C.material;
      if (Array.isArray(L)) {
        const P = D.groups;
        for (let V = 0, ce = P.length; V < ce; V++) {
          const q = P[V], oe = L[q.materialIndex];
          if (oe && oe.visible) {
            const ne = b(C, oe, w, A);
            C.onBeforeShadow(r, C, E, T, D, ne, q), r.renderBufferDirect(T, null, D, ne, C, q), C.onAfterShadow(r, C, E, T, D, ne, q);
          }
        }
      } else if (L.visible) {
        const P = b(C, L, w, A);
        C.onBeforeShadow(r, C, E, T, D, P, null), r.renderBufferDirect(T, null, D, P, C, null), C.onAfterShadow(r, C, E, T, D, P, null);
      }
    }
    const U = C.children;
    for (let D = 0, L = U.length; D < L; D++)
      x(U[D], E, T, w, A);
  }
  function M(C) {
    C.target.removeEventListener("dispose", M);
    for (const T in u) {
      const w = u[T], A = C.target.uuid;
      A in w && (w[A].dispose(), delete w[A]);
    }
  }
}
const $D = {
  [mm]: gm,
  [vm]: xm,
  [ym]: bm,
  [al]: _m,
  [gm]: mm,
  [xm]: vm,
  [bm]: ym,
  [_m]: al
};
function XD(r, e) {
  function n() {
    let _e = !1;
    const Ue = new Jt();
    let Fe = null;
    const je = new Jt(0, 0, 0, 0);
    return {
      setMask: function(Ke) {
        Fe !== Ke && !_e && (r.colorMask(Ke, Ke, Ke, Ke), Fe = Ke);
      },
      setLocked: function(Ke) {
        _e = Ke;
      },
      setClear: function(Ke, qe, ut, ot, dt) {
        dt === !0 && (Ke *= ot, qe *= ot, ut *= ot), Ue.set(Ke, qe, ut, ot), je.equals(Ue) === !1 && (r.clearColor(Ke, qe, ut, ot), je.copy(Ue));
      },
      reset: function() {
        _e = !1, Fe = null, je.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let _e = !1, Ue = !1, Fe = null, je = null, Ke = null;
    return {
      setReversed: function(qe) {
        if (Ue !== qe) {
          const ut = e.get("EXT_clip_control");
          Ue ? ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.ZERO_TO_ONE_EXT) : ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.NEGATIVE_ONE_TO_ONE_EXT);
          const ot = Ke;
          Ke = null, this.setClear(ot);
        }
        Ue = qe;
      },
      getReversed: function() {
        return Ue;
      },
      setTest: function(qe) {
        qe ? H(r.DEPTH_TEST) : K(r.DEPTH_TEST);
      },
      setMask: function(qe) {
        Fe !== qe && !_e && (r.depthMask(qe), Fe = qe);
      },
      setFunc: function(qe) {
        if (Ue && (qe = $D[qe]), je !== qe) {
          switch (qe) {
            case mm:
              r.depthFunc(r.NEVER);
              break;
            case gm:
              r.depthFunc(r.ALWAYS);
              break;
            case vm:
              r.depthFunc(r.LESS);
              break;
            case al:
              r.depthFunc(r.LEQUAL);
              break;
            case ym:
              r.depthFunc(r.EQUAL);
              break;
            case _m:
              r.depthFunc(r.GEQUAL);
              break;
            case xm:
              r.depthFunc(r.GREATER);
              break;
            case bm:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          je = qe;
        }
      },
      setLocked: function(qe) {
        _e = qe;
      },
      setClear: function(qe) {
        Ke !== qe && (Ue && (qe = 1 - qe), r.clearDepth(qe), Ke = qe);
      },
      reset: function() {
        _e = !1, Fe = null, je = null, Ke = null, Ue = !1;
      }
    };
  }
  function s() {
    let _e = !1, Ue = null, Fe = null, je = null, Ke = null, qe = null, ut = null, ot = null, dt = null;
    return {
      setTest: function(mt) {
        _e || (mt ? H(r.STENCIL_TEST) : K(r.STENCIL_TEST));
      },
      setMask: function(mt) {
        Ue !== mt && !_e && (r.stencilMask(mt), Ue = mt);
      },
      setFunc: function(mt, Bt, $t) {
        (Fe !== mt || je !== Bt || Ke !== $t) && (r.stencilFunc(mt, Bt, $t), Fe = mt, je = Bt, Ke = $t);
      },
      setOp: function(mt, Bt, $t) {
        (qe !== mt || ut !== Bt || ot !== $t) && (r.stencilOp(mt, Bt, $t), qe = mt, ut = Bt, ot = $t);
      },
      setLocked: function(mt) {
        _e = mt;
      },
      setClear: function(mt) {
        dt !== mt && (r.clearStencil(mt), dt = mt);
      },
      reset: function() {
        _e = !1, Ue = null, Fe = null, je = null, Ke = null, qe = null, ut = null, ot = null, dt = null;
      }
    };
  }
  const o = new n(), a = new i(), l = new s(), c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let h = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, _ = !1, g = null, v = null, S = null, b = null, x = null, M = null, C = null, E = new Tt(0, 0, 0), T = 0, w = !1, A = null, O = null, U = null, D = null, L = null;
  const P = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1, ce = 0;
  const q = r.getParameter(r.VERSION);
  q.indexOf("WebGL") !== -1 ? (ce = parseFloat(/^WebGL (\d)/.exec(q)[1]), V = ce >= 1) : q.indexOf("OpenGL ES") !== -1 && (ce = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]), V = ce >= 2);
  let oe = null, ne = {};
  const $ = r.getParameter(r.SCISSOR_BOX), J = r.getParameter(r.VIEWPORT), se = new Jt().fromArray($), le = new Jt().fromArray(J);
  function re(_e, Ue, Fe, je) {
    const Ke = new Uint8Array(4), qe = r.createTexture();
    r.bindTexture(_e, qe), r.texParameteri(_e, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(_e, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let ut = 0; ut < Fe; ut++)
      _e === r.TEXTURE_3D || _e === r.TEXTURE_2D_ARRAY ? r.texImage3D(Ue, 0, r.RGBA, 1, 1, je, 0, r.RGBA, r.UNSIGNED_BYTE, Ke) : r.texImage2D(Ue + ut, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ke);
    return qe;
  }
  const ye = {};
  ye[r.TEXTURE_2D] = re(r.TEXTURE_2D, r.TEXTURE_2D, 1), ye[r.TEXTURE_CUBE_MAP] = re(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ye[r.TEXTURE_2D_ARRAY] = re(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), ye[r.TEXTURE_3D] = re(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), a.setClear(1), l.setClear(0), H(r.DEPTH_TEST), a.setFunc(al), ee(!1), Z(L0), H(r.CULL_FACE), X(Hs);
  function H(_e) {
    h[_e] !== !0 && (r.enable(_e), h[_e] = !0);
  }
  function K(_e) {
    h[_e] !== !1 && (r.disable(_e), h[_e] = !1);
  }
  function G(_e, Ue) {
    return d[_e] !== Ue ? (r.bindFramebuffer(_e, Ue), d[_e] = Ue, _e === r.DRAW_FRAMEBUFFER && (d[r.FRAMEBUFFER] = Ue), _e === r.FRAMEBUFFER && (d[r.DRAW_FRAMEBUFFER] = Ue), !0) : !1;
  }
  function R(_e, Ue) {
    let Fe = f, je = !1;
    if (_e) {
      Fe = p.get(Ue), Fe === void 0 && (Fe = [], p.set(Ue, Fe));
      const Ke = _e.textures;
      if (Fe.length !== Ke.length || Fe[0] !== r.COLOR_ATTACHMENT0) {
        for (let qe = 0, ut = Ke.length; qe < ut; qe++)
          Fe[qe] = r.COLOR_ATTACHMENT0 + qe;
        Fe.length = Ke.length, je = !0;
      }
    } else
      Fe[0] !== r.BACK && (Fe[0] = r.BACK, je = !0);
    je && r.drawBuffers(Fe);
  }
  function z(_e) {
    return m !== _e ? (r.useProgram(_e), m = _e, !0) : !1;
  }
  const I = {
    [vs]: r.FUNC_ADD,
    [Qx]: r.FUNC_SUBTRACT,
    [hT]: r.FUNC_REVERSE_SUBTRACT
  };
  I[eb] = r.MIN, I[tb] = r.MAX;
  const Q = {
    [dT]: r.ZERO,
    [or]: r.ONE,
    [fT]: r.SRC_COLOR,
    [md]: r.SRC_ALPHA,
    [vT]: r.SRC_ALPHA_SATURATE,
    [gT]: r.DST_COLOR,
    [pT]: r.DST_ALPHA,
    [pm]: r.ONE_MINUS_SRC_COLOR,
    [Hc]: r.ONE_MINUS_SRC_ALPHA,
    [nb]: r.ONE_MINUS_DST_COLOR,
    [mT]: r.ONE_MINUS_DST_ALPHA,
    [yT]: r.CONSTANT_COLOR,
    [_T]: r.ONE_MINUS_CONSTANT_COLOR,
    [xT]: r.CONSTANT_ALPHA,
    [bT]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function X(_e, Ue, Fe, je, Ke, qe, ut, ot, dt, mt) {
    if (_e === Hs) {
      _ === !0 && (K(r.BLEND), _ = !1);
      return;
    }
    if (_ === !1 && (H(r.BLEND), _ = !0), _e !== Fo) {
      if (_e !== g || mt !== w) {
        if ((v !== vs || x !== vs) && (r.blendEquation(r.FUNC_ADD), v = vs, x = vs), mt)
          switch (_e) {
            case xs:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Gc:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case fm:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ja:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", _e);
              break;
          }
        else
          switch (_e) {
            case xs:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Gc:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case fm:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ja:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", _e);
              break;
          }
        S = null, b = null, M = null, C = null, E.set(0, 0, 0), T = 0, g = _e, w = mt;
      }
      return;
    }
    Ke = Ke || Ue, qe = qe || Fe, ut = ut || je, (Ue !== v || Ke !== x) && (r.blendEquationSeparate(I[Ue], I[Ke]), v = Ue, x = Ke), (Fe !== S || je !== b || qe !== M || ut !== C) && (r.blendFuncSeparate(Q[Fe], Q[je], Q[qe], Q[ut]), S = Fe, b = je, M = qe, C = ut), (ot.equals(E) === !1 || dt !== T) && (r.blendColor(ot.r, ot.g, ot.b, dt), E.copy(ot), T = dt), g = _e, w = !1;
  }
  function k(_e, Ue) {
    _e.side === Pn ? K(r.CULL_FACE) : H(r.CULL_FACE);
    let Fe = _e.side === Oi;
    Ue && (Fe = !Fe), ee(Fe), _e.blending === xs && _e.transparent === !1 ? X(Hs) : X(_e.blending, _e.blendEquation, _e.blendSrc, _e.blendDst, _e.blendEquationAlpha, _e.blendSrcAlpha, _e.blendDstAlpha, _e.blendColor, _e.blendAlpha, _e.premultipliedAlpha), a.setFunc(_e.depthFunc), a.setTest(_e.depthTest), a.setMask(_e.depthWrite), o.setMask(_e.colorWrite);
    const je = _e.stencilWrite;
    l.setTest(je), je && (l.setMask(_e.stencilWriteMask), l.setFunc(_e.stencilFunc, _e.stencilRef, _e.stencilFuncMask), l.setOp(_e.stencilFail, _e.stencilZFail, _e.stencilZPass)), j(_e.polygonOffset, _e.polygonOffsetFactor, _e.polygonOffsetUnits), _e.alphaToCoverage === !0 ? H(r.SAMPLE_ALPHA_TO_COVERAGE) : K(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ee(_e) {
    A !== _e && (_e ? r.frontFace(r.CW) : r.frontFace(r.CCW), A = _e);
  }
  function Z(_e) {
    _e !== cT ? (H(r.CULL_FACE), _e !== O && (_e === L0 ? r.cullFace(r.BACK) : _e === uT ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : K(r.CULL_FACE), O = _e;
  }
  function N(_e) {
    _e !== U && (V && r.lineWidth(_e), U = _e);
  }
  function j(_e, Ue, Fe) {
    _e ? (H(r.POLYGON_OFFSET_FILL), (D !== Ue || L !== Fe) && (r.polygonOffset(Ue, Fe), D = Ue, L = Fe)) : K(r.POLYGON_OFFSET_FILL);
  }
  function te(_e) {
    _e ? H(r.SCISSOR_TEST) : K(r.SCISSOR_TEST);
  }
  function F(_e) {
    _e === void 0 && (_e = r.TEXTURE0 + P - 1), oe !== _e && (r.activeTexture(_e), oe = _e);
  }
  function B(_e, Ue, Fe) {
    Fe === void 0 && (oe === null ? Fe = r.TEXTURE0 + P - 1 : Fe = oe);
    let je = ne[Fe];
    je === void 0 && (je = { type: void 0, texture: void 0 }, ne[Fe] = je), (je.type !== _e || je.texture !== Ue) && (oe !== Fe && (r.activeTexture(Fe), oe = Fe), r.bindTexture(_e, Ue || ye[_e]), je.type = _e, je.texture = Ue);
  }
  function Y() {
    const _e = ne[oe];
    _e !== void 0 && _e.type !== void 0 && (r.bindTexture(_e.type, null), _e.type = void 0, _e.texture = void 0);
  }
  function fe() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ge() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function xe() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function De() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ae() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function de() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Ee() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function be() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ke() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ze() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Te(_e) {
    se.equals(_e) === !1 && (r.scissor(_e.x, _e.y, _e.z, _e.w), se.copy(_e));
  }
  function Pe(_e) {
    le.equals(_e) === !1 && (r.viewport(_e.x, _e.y, _e.z, _e.w), le.copy(_e));
  }
  function Ge(_e, Ue) {
    let Fe = u.get(Ue);
    Fe === void 0 && (Fe = /* @__PURE__ */ new WeakMap(), u.set(Ue, Fe));
    let je = Fe.get(_e);
    je === void 0 && (je = r.getUniformBlockIndex(Ue, _e.name), Fe.set(_e, je));
  }
  function Ve(_e, Ue) {
    const je = u.get(Ue).get(_e);
    c.get(Ue) !== je && (r.uniformBlockBinding(Ue, je, _e.__bindingPointIndex), c.set(Ue, je));
  }
  function Qe() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), a.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), h = {}, oe = null, ne = {}, d = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, _ = !1, g = null, v = null, S = null, b = null, x = null, M = null, C = null, E = new Tt(0, 0, 0), T = 0, w = !1, A = null, O = null, U = null, D = null, L = null, se.set(0, 0, r.canvas.width, r.canvas.height), le.set(0, 0, r.canvas.width, r.canvas.height), o.reset(), a.reset(), l.reset();
  }
  return {
    buffers: {
      color: o,
      depth: a,
      stencil: l
    },
    enable: H,
    disable: K,
    bindFramebuffer: G,
    drawBuffers: R,
    useProgram: z,
    setBlending: X,
    setMaterial: k,
    setFlipSided: ee,
    setCullFace: Z,
    setLineWidth: N,
    setPolygonOffset: j,
    setScissorTest: te,
    activeTexture: F,
    bindTexture: B,
    unbindTexture: Y,
    compressedTexImage2D: fe,
    compressedTexImage3D: ge,
    texImage2D: ke,
    texImage3D: ze,
    updateUBOMapping: Ge,
    uniformBlockBinding: Ve,
    texStorage2D: Ee,
    texStorage3D: be,
    texSubImage2D: xe,
    texSubImage3D: De,
    compressedTexSubImage2D: ae,
    compressedTexSubImage3D: de,
    scissor: Te,
    viewport: Pe,
    reset: Qe
  };
}
function Ay(r, e, n, i) {
  const s = YD(i);
  switch (n) {
    case fb:
      return r * e;
    case mb:
      return r * e;
    case gb:
      return r * e * 2;
    case gd:
      return r * e / s.components * s.byteLength;
    case Wg:
      return r * e / s.components * s.byteLength;
    case vb:
      return r * e * 2 / s.components * s.byteLength;
    case jg:
      return r * e * 2 / s.components * s.byteLength;
    case pb:
      return r * e * 3 / s.components * s.byteLength;
    case fi:
      return r * e * 4 / s.components * s.byteLength;
    case $g:
      return r * e * 4 / s.components * s.byteLength;
    case jh:
    case $h:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Xh:
    case Yh:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Em:
    case Pm:
      return Math.max(r, 16) * Math.max(e, 8) / 4;
    case Tm:
    case Am:
      return Math.max(r, 8) * Math.max(e, 8) / 2;
    case Dm:
    case km:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Rm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Lm:
      return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Im:
      return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Om:
      return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Fm:
      return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Um:
      return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case zm:
      return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Bm:
      return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Nm:
      return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Vm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Gm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Hm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Wm:
      return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case jm:
      return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case $m:
      return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case qh:
    case Xm:
    case Ym:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
    case yb:
    case qm:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
    case Zm:
    case Km:
      return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function YD(r) {
  switch (r) {
    case js:
    case ub:
      return { byteLength: 1, components: 1 };
    case Wc:
    case hb:
    case po:
      return { byteLength: 2, components: 1 };
    case Gg:
    case Hg:
      return { byteLength: 2, components: 4 };
    case ta:
    case Vg:
    case Ii:
      return { byteLength: 4, components: 1 };
    case db:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${r}.`);
}
function qD(r, e, n, i, s, o, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new ct(), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(F, B) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(F, B)
    ) : jc("canvas");
  }
  function _(F, B, Y) {
    let fe = 1;
    const ge = te(F);
    if ((ge.width > Y || ge.height > Y) && (fe = Y / Math.max(ge.width, ge.height)), fe < 1)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap || typeof VideoFrame < "u" && F instanceof VideoFrame) {
        const xe = Math.floor(fe * ge.width), De = Math.floor(fe * ge.height);
        d === void 0 && (d = m(xe, De));
        const ae = B ? m(xe, De) : d;
        return ae.width = xe, ae.height = De, ae.getContext("2d").drawImage(F, 0, 0, xe, De), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ge.width + "x" + ge.height + ") to (" + xe + "x" + De + ")."), ae;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ge.width + "x" + ge.height + ")."), F;
    return F;
  }
  function g(F) {
    return F.generateMipmaps;
  }
  function v(F) {
    r.generateMipmap(F);
  }
  function S(F) {
    return F.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : F.isWebGL3DRenderTarget ? r.TEXTURE_3D : F.isWebGLArrayRenderTarget || F.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
  }
  function b(F, B, Y, fe, ge = !1) {
    if (F !== null) {
      if (r[F] !== void 0) return r[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let xe = B;
    if (B === r.RED && (Y === r.FLOAT && (xe = r.R32F), Y === r.HALF_FLOAT && (xe = r.R16F), Y === r.UNSIGNED_BYTE && (xe = r.R8)), B === r.RED_INTEGER && (Y === r.UNSIGNED_BYTE && (xe = r.R8UI), Y === r.UNSIGNED_SHORT && (xe = r.R16UI), Y === r.UNSIGNED_INT && (xe = r.R32UI), Y === r.BYTE && (xe = r.R8I), Y === r.SHORT && (xe = r.R16I), Y === r.INT && (xe = r.R32I)), B === r.RG && (Y === r.FLOAT && (xe = r.RG32F), Y === r.HALF_FLOAT && (xe = r.RG16F), Y === r.UNSIGNED_BYTE && (xe = r.RG8)), B === r.RG_INTEGER && (Y === r.UNSIGNED_BYTE && (xe = r.RG8UI), Y === r.UNSIGNED_SHORT && (xe = r.RG16UI), Y === r.UNSIGNED_INT && (xe = r.RG32UI), Y === r.BYTE && (xe = r.RG8I), Y === r.SHORT && (xe = r.RG16I), Y === r.INT && (xe = r.RG32I)), B === r.RGB_INTEGER && (Y === r.UNSIGNED_BYTE && (xe = r.RGB8UI), Y === r.UNSIGNED_SHORT && (xe = r.RGB16UI), Y === r.UNSIGNED_INT && (xe = r.RGB32UI), Y === r.BYTE && (xe = r.RGB8I), Y === r.SHORT && (xe = r.RGB16I), Y === r.INT && (xe = r.RGB32I)), B === r.RGBA_INTEGER && (Y === r.UNSIGNED_BYTE && (xe = r.RGBA8UI), Y === r.UNSIGNED_SHORT && (xe = r.RGBA16UI), Y === r.UNSIGNED_INT && (xe = r.RGBA32UI), Y === r.BYTE && (xe = r.RGBA8I), Y === r.SHORT && (xe = r.RGBA16I), Y === r.INT && (xe = r.RGBA32I)), B === r.RGB && Y === r.UNSIGNED_INT_5_9_9_9_REV && (xe = r.RGB9_E5), B === r.RGBA) {
      const De = ge ? sf : Nt.getTransfer(fe);
      Y === r.FLOAT && (xe = r.RGBA32F), Y === r.HALF_FLOAT && (xe = r.RGBA16F), Y === r.UNSIGNED_BYTE && (xe = De === nn ? r.SRGB8_ALPHA8 : r.RGBA8), Y === r.UNSIGNED_SHORT_4_4_4_4 && (xe = r.RGBA4), Y === r.UNSIGNED_SHORT_5_5_5_1 && (xe = r.RGB5_A1);
    }
    return (xe === r.R16F || xe === r.R32F || xe === r.RG16F || xe === r.RG32F || xe === r.RGBA16F || xe === r.RGBA32F) && e.get("EXT_color_buffer_float"), xe;
  }
  function x(F, B) {
    let Y;
    return F ? B === null || B === ta || B === ul ? Y = r.DEPTH24_STENCIL8 : B === Ii ? Y = r.DEPTH32F_STENCIL8 : B === Wc && (Y = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : B === null || B === ta || B === ul ? Y = r.DEPTH_COMPONENT24 : B === Ii ? Y = r.DEPTH_COMPONENT32F : B === Wc && (Y = r.DEPTH_COMPONENT16), Y;
  }
  function M(F, B) {
    return g(F) === !0 || F.isFramebufferTexture && F.minFilter !== ii && F.minFilter !== Kt ? Math.log2(Math.max(B.width, B.height)) + 1 : F.mipmaps !== void 0 && F.mipmaps.length > 0 ? F.mipmaps.length : F.isCompressedTexture && Array.isArray(F.image) ? B.mipmaps.length : 1;
  }
  function C(F) {
    const B = F.target;
    B.removeEventListener("dispose", C), T(B), B.isVideoTexture && h.delete(B);
  }
  function E(F) {
    const B = F.target;
    B.removeEventListener("dispose", E), A(B);
  }
  function T(F) {
    const B = i.get(F);
    if (B.__webglInit === void 0) return;
    const Y = F.source, fe = p.get(Y);
    if (fe) {
      const ge = fe[B.__cacheKey];
      ge.usedTimes--, ge.usedTimes === 0 && w(F), Object.keys(fe).length === 0 && p.delete(Y);
    }
    i.remove(F);
  }
  function w(F) {
    const B = i.get(F);
    r.deleteTexture(B.__webglTexture);
    const Y = F.source, fe = p.get(Y);
    delete fe[B.__cacheKey], a.memory.textures--;
  }
  function A(F) {
    const B = i.get(F);
    if (F.depthTexture && (F.depthTexture.dispose(), i.remove(F.depthTexture)), F.isWebGLCubeRenderTarget)
      for (let fe = 0; fe < 6; fe++) {
        if (Array.isArray(B.__webglFramebuffer[fe]))
          for (let ge = 0; ge < B.__webglFramebuffer[fe].length; ge++) r.deleteFramebuffer(B.__webglFramebuffer[fe][ge]);
        else
          r.deleteFramebuffer(B.__webglFramebuffer[fe]);
        B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer[fe]);
      }
    else {
      if (Array.isArray(B.__webglFramebuffer))
        for (let fe = 0; fe < B.__webglFramebuffer.length; fe++) r.deleteFramebuffer(B.__webglFramebuffer[fe]);
      else
        r.deleteFramebuffer(B.__webglFramebuffer);
      if (B.__webglDepthbuffer && r.deleteRenderbuffer(B.__webglDepthbuffer), B.__webglMultisampledFramebuffer && r.deleteFramebuffer(B.__webglMultisampledFramebuffer), B.__webglColorRenderbuffer)
        for (let fe = 0; fe < B.__webglColorRenderbuffer.length; fe++)
          B.__webglColorRenderbuffer[fe] && r.deleteRenderbuffer(B.__webglColorRenderbuffer[fe]);
      B.__webglDepthRenderbuffer && r.deleteRenderbuffer(B.__webglDepthRenderbuffer);
    }
    const Y = F.textures;
    for (let fe = 0, ge = Y.length; fe < ge; fe++) {
      const xe = i.get(Y[fe]);
      xe.__webglTexture && (r.deleteTexture(xe.__webglTexture), a.memory.textures--), i.remove(Y[fe]);
    }
    i.remove(F);
  }
  let O = 0;
  function U() {
    O = 0;
  }
  function D() {
    const F = O;
    return F >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + s.maxTextures), O += 1, F;
  }
  function L(F) {
    const B = [];
    return B.push(F.wrapS), B.push(F.wrapT), B.push(F.wrapR || 0), B.push(F.magFilter), B.push(F.minFilter), B.push(F.anisotropy), B.push(F.internalFormat), B.push(F.format), B.push(F.type), B.push(F.generateMipmaps), B.push(F.premultiplyAlpha), B.push(F.flipY), B.push(F.unpackAlignment), B.push(F.colorSpace), B.join();
  }
  function P(F, B) {
    const Y = i.get(F);
    if (F.isVideoTexture && N(F), F.isRenderTargetTexture === !1 && F.version > 0 && Y.__version !== F.version) {
      const fe = F.image;
      if (fe === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (fe.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        le(Y, F, B);
        return;
      }
    }
    n.bindTexture(r.TEXTURE_2D, Y.__webglTexture, r.TEXTURE0 + B);
  }
  function V(F, B) {
    const Y = i.get(F);
    if (F.version > 0 && Y.__version !== F.version) {
      le(Y, F, B);
      return;
    }
    n.bindTexture(r.TEXTURE_2D_ARRAY, Y.__webglTexture, r.TEXTURE0 + B);
  }
  function ce(F, B) {
    const Y = i.get(F);
    if (F.version > 0 && Y.__version !== F.version) {
      le(Y, F, B);
      return;
    }
    n.bindTexture(r.TEXTURE_3D, Y.__webglTexture, r.TEXTURE0 + B);
  }
  function q(F, B) {
    const Y = i.get(F);
    if (F.version > 0 && Y.__version !== F.version) {
      re(Y, F, B);
      return;
    }
    n.bindTexture(r.TEXTURE_CUBE_MAP, Y.__webglTexture, r.TEXTURE0 + B);
  }
  const oe = {
    [Mm]: r.REPEAT,
    [Wo]: r.CLAMP_TO_EDGE,
    [Cm]: r.MIRRORED_REPEAT
  }, ne = {
    [ii]: r.NEAREST,
    [CT]: r.NEAREST_MIPMAP_NEAREST,
    [Au]: r.NEAREST_MIPMAP_LINEAR,
    [Kt]: r.LINEAR,
    [$f]: r.LINEAR_MIPMAP_NEAREST,
    [jo]: r.LINEAR_MIPMAP_LINEAR
  }, $ = {
    [AT]: r.NEVER,
    [IT]: r.ALWAYS,
    [PT]: r.LESS,
    [_b]: r.LEQUAL,
    [DT]: r.EQUAL,
    [LT]: r.GEQUAL,
    [kT]: r.GREATER,
    [RT]: r.NOTEQUAL
  };
  function J(F, B) {
    if (B.type === Ii && e.has("OES_texture_float_linear") === !1 && (B.magFilter === Kt || B.magFilter === $f || B.magFilter === Au || B.magFilter === jo || B.minFilter === Kt || B.minFilter === $f || B.minFilter === Au || B.minFilter === jo) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(F, r.TEXTURE_WRAP_S, oe[B.wrapS]), r.texParameteri(F, r.TEXTURE_WRAP_T, oe[B.wrapT]), (F === r.TEXTURE_3D || F === r.TEXTURE_2D_ARRAY) && r.texParameteri(F, r.TEXTURE_WRAP_R, oe[B.wrapR]), r.texParameteri(F, r.TEXTURE_MAG_FILTER, ne[B.magFilter]), r.texParameteri(F, r.TEXTURE_MIN_FILTER, ne[B.minFilter]), B.compareFunction && (r.texParameteri(F, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(F, r.TEXTURE_COMPARE_FUNC, $[B.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (B.magFilter === ii || B.minFilter !== Au && B.minFilter !== jo || B.type === Ii && e.has("OES_texture_float_linear") === !1) return;
      if (B.anisotropy > 1 || i.get(B).__currentAnisotropy) {
        const Y = e.get("EXT_texture_filter_anisotropic");
        r.texParameterf(F, Y.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(B.anisotropy, s.getMaxAnisotropy())), i.get(B).__currentAnisotropy = B.anisotropy;
      }
    }
  }
  function se(F, B) {
    let Y = !1;
    F.__webglInit === void 0 && (F.__webglInit = !0, B.addEventListener("dispose", C));
    const fe = B.source;
    let ge = p.get(fe);
    ge === void 0 && (ge = {}, p.set(fe, ge));
    const xe = L(B);
    if (xe !== F.__cacheKey) {
      ge[xe] === void 0 && (ge[xe] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, Y = !0), ge[xe].usedTimes++;
      const De = ge[F.__cacheKey];
      De !== void 0 && (ge[F.__cacheKey].usedTimes--, De.usedTimes === 0 && w(B)), F.__cacheKey = xe, F.__webglTexture = ge[xe].texture;
    }
    return Y;
  }
  function le(F, B, Y) {
    let fe = r.TEXTURE_2D;
    (B.isDataArrayTexture || B.isCompressedArrayTexture) && (fe = r.TEXTURE_2D_ARRAY), B.isData3DTexture && (fe = r.TEXTURE_3D);
    const ge = se(F, B), xe = B.source;
    n.bindTexture(fe, F.__webglTexture, r.TEXTURE0 + Y);
    const De = i.get(xe);
    if (xe.version !== De.__version || ge === !0) {
      n.activeTexture(r.TEXTURE0 + Y);
      const ae = Nt.getPrimaries(Nt.workingColorSpace), de = B.colorSpace === no ? null : Nt.getPrimaries(B.colorSpace), Ee = B.colorSpace === no || ae === de ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, B.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, B.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
      let be = _(B.image, !1, s.maxTextureSize);
      be = j(B, be);
      const ke = o.convert(B.format, B.colorSpace), ze = o.convert(B.type);
      let Te = b(B.internalFormat, ke, ze, B.colorSpace, B.isVideoTexture);
      J(fe, B);
      let Pe;
      const Ge = B.mipmaps, Ve = B.isVideoTexture !== !0, Qe = De.__version === void 0 || ge === !0, _e = xe.dataReady, Ue = M(B, be);
      if (B.isDepthTexture)
        Te = x(B.format === hl, B.type), Qe && (Ve ? n.texStorage2D(r.TEXTURE_2D, 1, Te, be.width, be.height) : n.texImage2D(r.TEXTURE_2D, 0, Te, be.width, be.height, 0, ke, ze, null));
      else if (B.isDataTexture)
        if (Ge.length > 0) {
          Ve && Qe && n.texStorage2D(r.TEXTURE_2D, Ue, Te, Ge[0].width, Ge[0].height);
          for (let Fe = 0, je = Ge.length; Fe < je; Fe++)
            Pe = Ge[Fe], Ve ? _e && n.texSubImage2D(r.TEXTURE_2D, Fe, 0, 0, Pe.width, Pe.height, ke, ze, Pe.data) : n.texImage2D(r.TEXTURE_2D, Fe, Te, Pe.width, Pe.height, 0, ke, ze, Pe.data);
          B.generateMipmaps = !1;
        } else
          Ve ? (Qe && n.texStorage2D(r.TEXTURE_2D, Ue, Te, be.width, be.height), _e && n.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, be.width, be.height, ke, ze, be.data)) : n.texImage2D(r.TEXTURE_2D, 0, Te, be.width, be.height, 0, ke, ze, be.data);
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          Ve && Qe && n.texStorage3D(r.TEXTURE_2D_ARRAY, Ue, Te, Ge[0].width, Ge[0].height, be.depth);
          for (let Fe = 0, je = Ge.length; Fe < je; Fe++)
            if (Pe = Ge[Fe], B.format !== fi)
              if (ke !== null)
                if (Ve) {
                  if (_e)
                    if (B.layerUpdates.size > 0) {
                      const Ke = Ay(Pe.width, Pe.height, B.format, B.type);
                      for (const qe of B.layerUpdates) {
                        const ut = Pe.data.subarray(
                          qe * Ke / Pe.data.BYTES_PER_ELEMENT,
                          (qe + 1) * Ke / Pe.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Fe, 0, 0, qe, Pe.width, Pe.height, 1, ke, ut);
                      }
                      B.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, Pe.width, Pe.height, be.depth, ke, Pe.data);
                } else
                  n.compressedTexImage3D(r.TEXTURE_2D_ARRAY, Fe, Te, Pe.width, Pe.height, be.depth, 0, Pe.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Ve ? _e && n.texSubImage3D(r.TEXTURE_2D_ARRAY, Fe, 0, 0, 0, Pe.width, Pe.height, be.depth, ke, ze, Pe.data) : n.texImage3D(r.TEXTURE_2D_ARRAY, Fe, Te, Pe.width, Pe.height, be.depth, 0, ke, ze, Pe.data);
        } else {
          Ve && Qe && n.texStorage2D(r.TEXTURE_2D, Ue, Te, Ge[0].width, Ge[0].height);
          for (let Fe = 0, je = Ge.length; Fe < je; Fe++)
            Pe = Ge[Fe], B.format !== fi ? ke !== null ? Ve ? _e && n.compressedTexSubImage2D(r.TEXTURE_2D, Fe, 0, 0, Pe.width, Pe.height, ke, Pe.data) : n.compressedTexImage2D(r.TEXTURE_2D, Fe, Te, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ve ? _e && n.texSubImage2D(r.TEXTURE_2D, Fe, 0, 0, Pe.width, Pe.height, ke, ze, Pe.data) : n.texImage2D(r.TEXTURE_2D, Fe, Te, Pe.width, Pe.height, 0, ke, ze, Pe.data);
        }
      else if (B.isDataArrayTexture)
        if (Ve) {
          if (Qe && n.texStorage3D(r.TEXTURE_2D_ARRAY, Ue, Te, be.width, be.height, be.depth), _e)
            if (B.layerUpdates.size > 0) {
              const Fe = Ay(be.width, be.height, B.format, B.type);
              for (const je of B.layerUpdates) {
                const Ke = be.data.subarray(
                  je * Fe / be.data.BYTES_PER_ELEMENT,
                  (je + 1) * Fe / be.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, je, be.width, be.height, 1, ke, ze, Ke);
              }
              B.clearLayerUpdates();
            } else
              n.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, be.width, be.height, be.depth, ke, ze, be.data);
        } else
          n.texImage3D(r.TEXTURE_2D_ARRAY, 0, Te, be.width, be.height, be.depth, 0, ke, ze, be.data);
      else if (B.isData3DTexture)
        Ve ? (Qe && n.texStorage3D(r.TEXTURE_3D, Ue, Te, be.width, be.height, be.depth), _e && n.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, be.width, be.height, be.depth, ke, ze, be.data)) : n.texImage3D(r.TEXTURE_3D, 0, Te, be.width, be.height, be.depth, 0, ke, ze, be.data);
      else if (B.isFramebufferTexture) {
        if (Qe)
          if (Ve)
            n.texStorage2D(r.TEXTURE_2D, Ue, Te, be.width, be.height);
          else {
            let Fe = be.width, je = be.height;
            for (let Ke = 0; Ke < Ue; Ke++)
              n.texImage2D(r.TEXTURE_2D, Ke, Te, Fe, je, 0, ke, ze, null), Fe >>= 1, je >>= 1;
          }
      } else if (Ge.length > 0) {
        if (Ve && Qe) {
          const Fe = te(Ge[0]);
          n.texStorage2D(r.TEXTURE_2D, Ue, Te, Fe.width, Fe.height);
        }
        for (let Fe = 0, je = Ge.length; Fe < je; Fe++)
          Pe = Ge[Fe], Ve ? _e && n.texSubImage2D(r.TEXTURE_2D, Fe, 0, 0, ke, ze, Pe) : n.texImage2D(r.TEXTURE_2D, Fe, Te, ke, ze, Pe);
        B.generateMipmaps = !1;
      } else if (Ve) {
        if (Qe) {
          const Fe = te(be);
          n.texStorage2D(r.TEXTURE_2D, Ue, Te, Fe.width, Fe.height);
        }
        _e && n.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, ke, ze, be);
      } else
        n.texImage2D(r.TEXTURE_2D, 0, Te, ke, ze, be);
      g(B) && v(fe), De.__version = xe.version, B.onUpdate && B.onUpdate(B);
    }
    F.__version = B.version;
  }
  function re(F, B, Y) {
    if (B.image.length !== 6) return;
    const fe = se(F, B), ge = B.source;
    n.bindTexture(r.TEXTURE_CUBE_MAP, F.__webglTexture, r.TEXTURE0 + Y);
    const xe = i.get(ge);
    if (ge.version !== xe.__version || fe === !0) {
      n.activeTexture(r.TEXTURE0 + Y);
      const De = Nt.getPrimaries(Nt.workingColorSpace), ae = B.colorSpace === no ? null : Nt.getPrimaries(B.colorSpace), de = B.colorSpace === no || De === ae ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, B.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, B.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, de);
      const Ee = B.isCompressedTexture || B.image[0].isCompressedTexture, be = B.image[0] && B.image[0].isDataTexture, ke = [];
      for (let je = 0; je < 6; je++)
        !Ee && !be ? ke[je] = _(B.image[je], !0, s.maxCubemapSize) : ke[je] = be ? B.image[je].image : B.image[je], ke[je] = j(B, ke[je]);
      const ze = ke[0], Te = o.convert(B.format, B.colorSpace), Pe = o.convert(B.type), Ge = b(B.internalFormat, Te, Pe, B.colorSpace), Ve = B.isVideoTexture !== !0, Qe = xe.__version === void 0 || fe === !0, _e = ge.dataReady;
      let Ue = M(B, ze);
      J(r.TEXTURE_CUBE_MAP, B);
      let Fe;
      if (Ee) {
        Ve && Qe && n.texStorage2D(r.TEXTURE_CUBE_MAP, Ue, Ge, ze.width, ze.height);
        for (let je = 0; je < 6; je++) {
          Fe = ke[je].mipmaps;
          for (let Ke = 0; Ke < Fe.length; Ke++) {
            const qe = Fe[Ke];
            B.format !== fi ? Te !== null ? Ve ? _e && n.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke, 0, 0, qe.width, qe.height, Te, qe.data) : n.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke, Ge, qe.width, qe.height, 0, qe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ve ? _e && n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke, 0, 0, qe.width, qe.height, Te, Pe, qe.data) : n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke, Ge, qe.width, qe.height, 0, Te, Pe, qe.data);
          }
        }
      } else {
        if (Fe = B.mipmaps, Ve && Qe) {
          Fe.length > 0 && Ue++;
          const je = te(ke[0]);
          n.texStorage2D(r.TEXTURE_CUBE_MAP, Ue, Ge, je.width, je.height);
        }
        for (let je = 0; je < 6; je++)
          if (be) {
            Ve ? _e && n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, 0, 0, 0, ke[je].width, ke[je].height, Te, Pe, ke[je].data) : n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, 0, Ge, ke[je].width, ke[je].height, 0, Te, Pe, ke[je].data);
            for (let Ke = 0; Ke < Fe.length; Ke++) {
              const ut = Fe[Ke].image[je].image;
              Ve ? _e && n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke + 1, 0, 0, ut.width, ut.height, Te, Pe, ut.data) : n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke + 1, Ge, ut.width, ut.height, 0, Te, Pe, ut.data);
            }
          } else {
            Ve ? _e && n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, 0, 0, 0, Te, Pe, ke[je]) : n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, 0, Ge, Te, Pe, ke[je]);
            for (let Ke = 0; Ke < Fe.length; Ke++) {
              const qe = Fe[Ke];
              Ve ? _e && n.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke + 1, 0, 0, Te, Pe, qe.image[je]) : n.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + je, Ke + 1, Ge, Te, Pe, qe.image[je]);
            }
          }
      }
      g(B) && v(r.TEXTURE_CUBE_MAP), xe.__version = ge.version, B.onUpdate && B.onUpdate(B);
    }
    F.__version = B.version;
  }
  function ye(F, B, Y, fe, ge, xe) {
    const De = o.convert(Y.format, Y.colorSpace), ae = o.convert(Y.type), de = b(Y.internalFormat, De, ae, Y.colorSpace), Ee = i.get(B), be = i.get(Y);
    if (be.__renderTarget = B, !Ee.__hasExternalTextures) {
      const ke = Math.max(1, B.width >> xe), ze = Math.max(1, B.height >> xe);
      ge === r.TEXTURE_3D || ge === r.TEXTURE_2D_ARRAY ? n.texImage3D(ge, xe, de, ke, ze, B.depth, 0, De, ae, null) : n.texImage2D(ge, xe, de, ke, ze, 0, De, ae, null);
    }
    n.bindFramebuffer(r.FRAMEBUFFER, F), Z(B) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, fe, ge, be.__webglTexture, 0, ee(B)) : (ge === r.TEXTURE_2D || ge >= r.TEXTURE_CUBE_MAP_POSITIVE_X && ge <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, fe, ge, be.__webglTexture, xe), n.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function H(F, B, Y) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, F), B.depthBuffer) {
      const fe = B.depthTexture, ge = fe && fe.isDepthTexture ? fe.type : null, xe = x(B.stencilBuffer, ge), De = B.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ae = ee(B);
      Z(B) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ae, xe, B.width, B.height) : Y ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ae, xe, B.width, B.height) : r.renderbufferStorage(r.RENDERBUFFER, xe, B.width, B.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, De, r.RENDERBUFFER, F);
    } else {
      const fe = B.textures;
      for (let ge = 0; ge < fe.length; ge++) {
        const xe = fe[ge], De = o.convert(xe.format, xe.colorSpace), ae = o.convert(xe.type), de = b(xe.internalFormat, De, ae, xe.colorSpace), Ee = ee(B);
        Y && Z(B) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Ee, de, B.width, B.height) : Z(B) ? l.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Ee, de, B.width, B.height) : r.renderbufferStorage(r.RENDERBUFFER, de, B.width, B.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function K(F, B) {
    if (B && B.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(r.FRAMEBUFFER, F), !(B.depthTexture && B.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const fe = i.get(B.depthTexture);
    fe.__renderTarget = B, (!fe.__webglTexture || B.depthTexture.image.width !== B.width || B.depthTexture.image.height !== B.height) && (B.depthTexture.image.width = B.width, B.depthTexture.image.height = B.height, B.depthTexture.needsUpdate = !0), P(B.depthTexture, 0);
    const ge = fe.__webglTexture, xe = ee(B);
    if (B.depthTexture.format === Ko)
      Z(B) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ge, 0, xe) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ge, 0);
    else if (B.depthTexture.format === hl)
      Z(B) ? l.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ge, 0, xe) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ge, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function G(F) {
    const B = i.get(F), Y = F.isWebGLCubeRenderTarget === !0;
    if (B.__boundDepthTexture !== F.depthTexture) {
      const fe = F.depthTexture;
      if (B.__depthDisposeCallback && B.__depthDisposeCallback(), fe) {
        const ge = () => {
          delete B.__boundDepthTexture, delete B.__depthDisposeCallback, fe.removeEventListener("dispose", ge);
        };
        fe.addEventListener("dispose", ge), B.__depthDisposeCallback = ge;
      }
      B.__boundDepthTexture = fe;
    }
    if (F.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (Y) throw new Error("target.depthTexture not supported in Cube render targets");
      K(B.__webglFramebuffer, F);
    } else if (Y) {
      B.__webglDepthbuffer = [];
      for (let fe = 0; fe < 6; fe++)
        if (n.bindFramebuffer(r.FRAMEBUFFER, B.__webglFramebuffer[fe]), B.__webglDepthbuffer[fe] === void 0)
          B.__webglDepthbuffer[fe] = r.createRenderbuffer(), H(B.__webglDepthbuffer[fe], F, !1);
        else {
          const ge = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, xe = B.__webglDepthbuffer[fe];
          r.bindRenderbuffer(r.RENDERBUFFER, xe), r.framebufferRenderbuffer(r.FRAMEBUFFER, ge, r.RENDERBUFFER, xe);
        }
    } else if (n.bindFramebuffer(r.FRAMEBUFFER, B.__webglFramebuffer), B.__webglDepthbuffer === void 0)
      B.__webglDepthbuffer = r.createRenderbuffer(), H(B.__webglDepthbuffer, F, !1);
    else {
      const fe = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, ge = B.__webglDepthbuffer;
      r.bindRenderbuffer(r.RENDERBUFFER, ge), r.framebufferRenderbuffer(r.FRAMEBUFFER, fe, r.RENDERBUFFER, ge);
    }
    n.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function R(F, B, Y) {
    const fe = i.get(F);
    B !== void 0 && ye(fe.__webglFramebuffer, F, F.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), Y !== void 0 && G(F);
  }
  function z(F) {
    const B = F.texture, Y = i.get(F), fe = i.get(B);
    F.addEventListener("dispose", E);
    const ge = F.textures, xe = F.isWebGLCubeRenderTarget === !0, De = ge.length > 1;
    if (De || (fe.__webglTexture === void 0 && (fe.__webglTexture = r.createTexture()), fe.__version = B.version, a.memory.textures++), xe) {
      Y.__webglFramebuffer = [];
      for (let ae = 0; ae < 6; ae++)
        if (B.mipmaps && B.mipmaps.length > 0) {
          Y.__webglFramebuffer[ae] = [];
          for (let de = 0; de < B.mipmaps.length; de++)
            Y.__webglFramebuffer[ae][de] = r.createFramebuffer();
        } else
          Y.__webglFramebuffer[ae] = r.createFramebuffer();
    } else {
      if (B.mipmaps && B.mipmaps.length > 0) {
        Y.__webglFramebuffer = [];
        for (let ae = 0; ae < B.mipmaps.length; ae++)
          Y.__webglFramebuffer[ae] = r.createFramebuffer();
      } else
        Y.__webglFramebuffer = r.createFramebuffer();
      if (De)
        for (let ae = 0, de = ge.length; ae < de; ae++) {
          const Ee = i.get(ge[ae]);
          Ee.__webglTexture === void 0 && (Ee.__webglTexture = r.createTexture(), a.memory.textures++);
        }
      if (F.samples > 0 && Z(F) === !1) {
        Y.__webglMultisampledFramebuffer = r.createFramebuffer(), Y.__webglColorRenderbuffer = [], n.bindFramebuffer(r.FRAMEBUFFER, Y.__webglMultisampledFramebuffer);
        for (let ae = 0; ae < ge.length; ae++) {
          const de = ge[ae];
          Y.__webglColorRenderbuffer[ae] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, Y.__webglColorRenderbuffer[ae]);
          const Ee = o.convert(de.format, de.colorSpace), be = o.convert(de.type), ke = b(de.internalFormat, Ee, be, de.colorSpace, F.isXRRenderTarget === !0), ze = ee(F);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, ze, ke, F.width, F.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ae, r.RENDERBUFFER, Y.__webglColorRenderbuffer[ae]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), F.depthBuffer && (Y.__webglDepthRenderbuffer = r.createRenderbuffer(), H(Y.__webglDepthRenderbuffer, F, !0)), n.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (xe) {
      n.bindTexture(r.TEXTURE_CUBE_MAP, fe.__webglTexture), J(r.TEXTURE_CUBE_MAP, B);
      for (let ae = 0; ae < 6; ae++)
        if (B.mipmaps && B.mipmaps.length > 0)
          for (let de = 0; de < B.mipmaps.length; de++)
            ye(Y.__webglFramebuffer[ae][de], F, B, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ae, de);
        else
          ye(Y.__webglFramebuffer[ae], F, B, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ae, 0);
      g(B) && v(r.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (De) {
      for (let ae = 0, de = ge.length; ae < de; ae++) {
        const Ee = ge[ae], be = i.get(Ee);
        n.bindTexture(r.TEXTURE_2D, be.__webglTexture), J(r.TEXTURE_2D, Ee), ye(Y.__webglFramebuffer, F, Ee, r.COLOR_ATTACHMENT0 + ae, r.TEXTURE_2D, 0), g(Ee) && v(r.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let ae = r.TEXTURE_2D;
      if ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) && (ae = F.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), n.bindTexture(ae, fe.__webglTexture), J(ae, B), B.mipmaps && B.mipmaps.length > 0)
        for (let de = 0; de < B.mipmaps.length; de++)
          ye(Y.__webglFramebuffer[de], F, B, r.COLOR_ATTACHMENT0, ae, de);
      else
        ye(Y.__webglFramebuffer, F, B, r.COLOR_ATTACHMENT0, ae, 0);
      g(B) && v(ae), n.unbindTexture();
    }
    F.depthBuffer && G(F);
  }
  function I(F) {
    const B = F.textures;
    for (let Y = 0, fe = B.length; Y < fe; Y++) {
      const ge = B[Y];
      if (g(ge)) {
        const xe = S(F), De = i.get(ge).__webglTexture;
        n.bindTexture(xe, De), v(xe), n.unbindTexture();
      }
    }
  }
  const Q = [], X = [];
  function k(F) {
    if (F.samples > 0) {
      if (Z(F) === !1) {
        const B = F.textures, Y = F.width, fe = F.height;
        let ge = r.COLOR_BUFFER_BIT;
        const xe = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, De = i.get(F), ae = B.length > 1;
        if (ae)
          for (let de = 0; de < B.length; de++)
            n.bindFramebuffer(r.FRAMEBUFFER, De.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + de, r.RENDERBUFFER, null), n.bindFramebuffer(r.FRAMEBUFFER, De.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + de, r.TEXTURE_2D, null, 0);
        n.bindFramebuffer(r.READ_FRAMEBUFFER, De.__webglMultisampledFramebuffer), n.bindFramebuffer(r.DRAW_FRAMEBUFFER, De.__webglFramebuffer);
        for (let de = 0; de < B.length; de++) {
          if (F.resolveDepthBuffer && (F.depthBuffer && (ge |= r.DEPTH_BUFFER_BIT), F.stencilBuffer && F.resolveStencilBuffer && (ge |= r.STENCIL_BUFFER_BIT)), ae) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, De.__webglColorRenderbuffer[de]);
            const Ee = i.get(B[de]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Ee, 0);
          }
          r.blitFramebuffer(0, 0, Y, fe, 0, 0, Y, fe, ge, r.NEAREST), c === !0 && (Q.length = 0, X.length = 0, Q.push(r.COLOR_ATTACHMENT0 + de), F.depthBuffer && F.resolveDepthBuffer === !1 && (Q.push(xe), X.push(xe), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, X)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, Q));
        }
        if (n.bindFramebuffer(r.READ_FRAMEBUFFER, null), n.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), ae)
          for (let de = 0; de < B.length; de++) {
            n.bindFramebuffer(r.FRAMEBUFFER, De.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + de, r.RENDERBUFFER, De.__webglColorRenderbuffer[de]);
            const Ee = i.get(B[de]).__webglTexture;
            n.bindFramebuffer(r.FRAMEBUFFER, De.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + de, r.TEXTURE_2D, Ee, 0);
          }
        n.bindFramebuffer(r.DRAW_FRAMEBUFFER, De.__webglMultisampledFramebuffer);
      } else if (F.depthBuffer && F.resolveDepthBuffer === !1 && c) {
        const B = F.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [B]);
      }
    }
  }
  function ee(F) {
    return Math.min(s.maxSamples, F.samples);
  }
  function Z(F) {
    const B = i.get(F);
    return F.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && B.__useRenderToTexture !== !1;
  }
  function N(F) {
    const B = a.render.frame;
    h.get(F) !== B && (h.set(F, B), F.update());
  }
  function j(F, B) {
    const Y = F.colorSpace, fe = F.format, ge = F.type;
    return F.isCompressedTexture === !0 || F.isVideoTexture === !0 || Y !== _l && Y !== no && (Nt.getTransfer(Y) === nn ? (fe !== fi || ge !== js) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Y)), B;
  }
  function te(F) {
    return typeof HTMLImageElement < "u" && F instanceof HTMLImageElement ? (u.width = F.naturalWidth || F.width, u.height = F.naturalHeight || F.height) : typeof VideoFrame < "u" && F instanceof VideoFrame ? (u.width = F.displayWidth, u.height = F.displayHeight) : (u.width = F.width, u.height = F.height), u;
  }
  this.allocateTextureUnit = D, this.resetTextureUnits = U, this.setTexture2D = P, this.setTexture2DArray = V, this.setTexture3D = ce, this.setTextureCube = q, this.rebindTextures = R, this.setupRenderTarget = z, this.updateRenderTargetMipmap = I, this.updateMultisampleRenderTarget = k, this.setupDepthRenderbuffer = G, this.setupFrameBufferTexture = ye, this.useMultisampledRTT = Z;
}
function ZD(r, e) {
  function n(i, s = no) {
    let o;
    const a = Nt.getTransfer(s);
    if (i === js) return r.UNSIGNED_BYTE;
    if (i === Gg) return r.UNSIGNED_SHORT_4_4_4_4;
    if (i === Hg) return r.UNSIGNED_SHORT_5_5_5_1;
    if (i === db) return r.UNSIGNED_INT_5_9_9_9_REV;
    if (i === ub) return r.BYTE;
    if (i === hb) return r.SHORT;
    if (i === Wc) return r.UNSIGNED_SHORT;
    if (i === Vg) return r.INT;
    if (i === ta) return r.UNSIGNED_INT;
    if (i === Ii) return r.FLOAT;
    if (i === po) return r.HALF_FLOAT;
    if (i === fb) return r.ALPHA;
    if (i === pb) return r.RGB;
    if (i === fi) return r.RGBA;
    if (i === mb) return r.LUMINANCE;
    if (i === gb) return r.LUMINANCE_ALPHA;
    if (i === Ko) return r.DEPTH_COMPONENT;
    if (i === hl) return r.DEPTH_STENCIL;
    if (i === gd) return r.RED;
    if (i === Wg) return r.RED_INTEGER;
    if (i === vb) return r.RG;
    if (i === jg) return r.RG_INTEGER;
    if (i === $g) return r.RGBA_INTEGER;
    if (i === jh || i === $h || i === Xh || i === Yh)
      if (a === nn)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (i === jh) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === $h) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === Xh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Yh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (i === jh) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === $h) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === Xh) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === Yh) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === Tm || i === Em || i === Am || i === Pm)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (i === Tm) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === Em) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === Am) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === Pm) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === Dm || i === km || i === Rm)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (i === Dm || i === km) return a === nn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (i === Rm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === Lm || i === Im || i === Om || i === Fm || i === Um || i === zm || i === Bm || i === Nm || i === Vm || i === Gm || i === Hm || i === Wm || i === jm || i === $m)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (i === Lm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Im) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Om) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Fm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Um) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === zm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Bm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Nm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Vm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Gm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Hm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Wm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === jm) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === $m) return a === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === qh || i === Xm || i === Ym)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (i === qh) return a === nn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Xm) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === Ym) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === yb || i === qm || i === Zm || i === Km)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (i === qh) return o.COMPRESSED_RED_RGTC1_EXT;
        if (i === qm) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Zm) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Km) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === ul ? r.UNSIGNED_INT_24_8 : r[i] !== void 0 ? r[i] : null;
  }
  return { convert: n };
}
class KD extends Li {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class ts extends vn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const JD = { type: "move" };
class _p {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new ts(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new ts(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new he(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new he()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new ts(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new he(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new he()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const i of e.hand.values())
          this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, i) {
    let s = null, o = null, a = null;
    const l = this._targetRay, c = this._grip, u = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        a = !0;
        for (const _ of e.hand.values()) {
          const g = n.getJointPose(_, i), v = this._getHandJoint(u, _);
          g !== null && (v.matrix.fromArray(g.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = !0, v.jointRadius = g.radius), v.visible = g !== null;
        }
        const h = u.joints["index-finger-tip"], d = u.joints["thumb-tip"], p = h.position.distanceTo(d.position), f = 0.02, m = 5e-3;
        u.inputState.pinching && p > f + m ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && p <= f - m && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (o = n.getPose(e.gripSpace, i), o !== null && (c.matrix.fromArray(o.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(o.linearVelocity)) : c.hasLinearVelocity = !1, o.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(o.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (s = n.getPose(e.targetRaySpace, i), s === null && o !== null && (s = o), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(JD)));
    }
    return l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), u !== null && (u.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new ts();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[n.jointName] = i, e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const QD = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, e3 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class t3 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, i) {
    if (this.texture === null) {
      const s = new Fn(), o = e.properties.get(s);
      o.__webglTexture = n.texture, (n.depthNear != i.depthNear || n.depthFar != i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = s;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport, i = new si({
        vertexShader: QD,
        fragmentShader: e3,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: n.z },
          depthHeight: { value: n.w }
        }
      });
      this.mesh = new tt(new yn(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class n3 extends sa {
  constructor(e, n) {
    super();
    const i = this;
    let s = null, o = 1, a = null, l = "local-floor", c = 1, u = null, h = null, d = null, p = null, f = null, m = null;
    const _ = new t3(), g = n.getContextAttributes();
    let v = null, S = null;
    const b = [], x = [], M = new ct();
    let C = null;
    const E = new Li();
    E.viewport = new Jt();
    const T = new Li();
    T.viewport = new Jt();
    const w = [E, T], A = new KD();
    let O = null, U = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(le) {
      let re = b[le];
      return re === void 0 && (re = new _p(), b[le] = re), re.getTargetRaySpace();
    }, this.getControllerGrip = function(le) {
      let re = b[le];
      return re === void 0 && (re = new _p(), b[le] = re), re.getGripSpace();
    }, this.getHand = function(le) {
      let re = b[le];
      return re === void 0 && (re = new _p(), b[le] = re), re.getHandSpace();
    };
    function D(le) {
      const re = x.indexOf(le.inputSource);
      if (re === -1)
        return;
      const ye = b[re];
      ye !== void 0 && (ye.update(le.inputSource, le.frame, u || a), ye.dispatchEvent({ type: le.type, data: le.inputSource }));
    }
    function L() {
      s.removeEventListener("select", D), s.removeEventListener("selectstart", D), s.removeEventListener("selectend", D), s.removeEventListener("squeeze", D), s.removeEventListener("squeezestart", D), s.removeEventListener("squeezeend", D), s.removeEventListener("end", L), s.removeEventListener("inputsourceschange", P);
      for (let le = 0; le < b.length; le++) {
        const re = x[le];
        re !== null && (x[le] = null, b[le].disconnect(re));
      }
      O = null, U = null, _.reset(), e.setRenderTarget(v), f = null, p = null, d = null, s = null, S = null, se.stop(), i.isPresenting = !1, e.setPixelRatio(C), e.setSize(M.width, M.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(le) {
      o = le, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(le) {
      l = le, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || a;
    }, this.setReferenceSpace = function(le) {
      u = le;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(le) {
      if (s = le, s !== null) {
        if (v = e.getRenderTarget(), s.addEventListener("select", D), s.addEventListener("selectstart", D), s.addEventListener("selectend", D), s.addEventListener("squeeze", D), s.addEventListener("squeezestart", D), s.addEventListener("squeezeend", D), s.addEventListener("end", L), s.addEventListener("inputsourceschange", P), g.xrCompatible !== !0 && await n.makeXRCompatible(), C = e.getPixelRatio(), e.getSize(M), s.renderState.layers === void 0) {
          const re = {
            antialias: g.antialias,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: o
          };
          f = new XRWebGLLayer(s, n, re), s.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), S = new Es(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: fi,
              type: js,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let re = null, ye = null, H = null;
          g.depth && (H = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, re = g.stencil ? hl : Ko, ye = g.stencil ? ul : ta);
          const K = {
            colorFormat: n.RGBA8,
            depthFormat: H,
            scaleFactor: o
          };
          d = new XRWebGLBinding(s, n), p = d.createProjectionLayer(K), s.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), S = new Es(
            p.textureWidth,
            p.textureHeight,
            {
              format: fi,
              type: js,
              depthTexture: new ev(p.textureWidth, p.textureHeight, ye, void 0, void 0, void 0, void 0, void 0, void 0, re),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        S.isXRRenderTarget = !0, this.setFoveation(c), u = null, a = await s.requestReferenceSpace(l), se.setContext(s), se.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (s !== null)
        return s.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return _.getDepthTexture();
    };
    function P(le) {
      for (let re = 0; re < le.removed.length; re++) {
        const ye = le.removed[re], H = x.indexOf(ye);
        H >= 0 && (x[H] = null, b[H].disconnect(ye));
      }
      for (let re = 0; re < le.added.length; re++) {
        const ye = le.added[re];
        let H = x.indexOf(ye);
        if (H === -1) {
          for (let G = 0; G < b.length; G++)
            if (G >= x.length) {
              x.push(ye), H = G;
              break;
            } else if (x[G] === null) {
              x[G] = ye, H = G;
              break;
            }
          if (H === -1) break;
        }
        const K = b[H];
        K && K.connect(ye);
      }
    }
    const V = new he(), ce = new he();
    function q(le, re, ye) {
      V.setFromMatrixPosition(re.matrixWorld), ce.setFromMatrixPosition(ye.matrixWorld);
      const H = V.distanceTo(ce), K = re.projectionMatrix.elements, G = ye.projectionMatrix.elements, R = K[14] / (K[10] - 1), z = K[14] / (K[10] + 1), I = (K[9] + 1) / K[5], Q = (K[9] - 1) / K[5], X = (K[8] - 1) / K[0], k = (G[8] + 1) / G[0], ee = R * X, Z = R * k, N = H / (-X + k), j = N * -X;
      if (re.matrixWorld.decompose(le.position, le.quaternion, le.scale), le.translateX(j), le.translateZ(N), le.matrixWorld.compose(le.position, le.quaternion, le.scale), le.matrixWorldInverse.copy(le.matrixWorld).invert(), K[10] === -1)
        le.projectionMatrix.copy(re.projectionMatrix), le.projectionMatrixInverse.copy(re.projectionMatrixInverse);
      else {
        const te = R + N, F = z + N, B = ee - j, Y = Z + (H - j), fe = I * z / F * te, ge = Q * z / F * te;
        le.projectionMatrix.makePerspective(B, Y, fe, ge, te, F), le.projectionMatrixInverse.copy(le.projectionMatrix).invert();
      }
    }
    function oe(le, re) {
      re === null ? le.matrixWorld.copy(le.matrix) : le.matrixWorld.multiplyMatrices(re.matrixWorld, le.matrix), le.matrixWorldInverse.copy(le.matrixWorld).invert();
    }
    this.updateCamera = function(le) {
      if (s === null) return;
      let re = le.near, ye = le.far;
      _.texture !== null && (_.depthNear > 0 && (re = _.depthNear), _.depthFar > 0 && (ye = _.depthFar)), A.near = T.near = E.near = re, A.far = T.far = E.far = ye, (O !== A.near || U !== A.far) && (s.updateRenderState({
        depthNear: A.near,
        depthFar: A.far
      }), O = A.near, U = A.far), E.layers.mask = le.layers.mask | 2, T.layers.mask = le.layers.mask | 4, A.layers.mask = E.layers.mask | T.layers.mask;
      const H = le.parent, K = A.cameras;
      oe(A, H);
      for (let G = 0; G < K.length; G++)
        oe(K[G], H);
      K.length === 2 ? q(A, E, T) : A.projectionMatrix.copy(E.projectionMatrix), ne(le, A, H);
    };
    function ne(le, re, ye) {
      ye === null ? le.matrix.copy(re.matrixWorld) : (le.matrix.copy(ye.matrixWorld), le.matrix.invert(), le.matrix.multiply(re.matrixWorld)), le.matrix.decompose(le.position, le.quaternion, le.scale), le.updateMatrixWorld(!0), le.projectionMatrix.copy(re.projectionMatrix), le.projectionMatrixInverse.copy(re.projectionMatrixInverse), le.isPerspectiveCamera && (le.fov = dl * 2 * Math.atan(1 / le.projectionMatrix.elements[5]), le.zoom = 1);
    }
    this.getCamera = function() {
      return A;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return c;
    }, this.setFoveation = function(le) {
      c = le, p !== null && (p.fixedFoveation = le), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = le);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return _.getMesh(A);
    };
    let $ = null;
    function J(le, re) {
      if (h = re.getViewerPose(u || a), m = re, h !== null) {
        const ye = h.views;
        f !== null && (e.setRenderTargetFramebuffer(S, f.framebuffer), e.setRenderTarget(S));
        let H = !1;
        ye.length !== A.cameras.length && (A.cameras.length = 0, H = !0);
        for (let G = 0; G < ye.length; G++) {
          const R = ye[G];
          let z = null;
          if (f !== null)
            z = f.getViewport(R);
          else {
            const Q = d.getViewSubImage(p, R);
            z = Q.viewport, G === 0 && (e.setRenderTargetTextures(
              S,
              Q.colorTexture,
              p.ignoreDepthValues ? void 0 : Q.depthStencilTexture
            ), e.setRenderTarget(S));
          }
          let I = w[G];
          I === void 0 && (I = new Li(), I.layers.enable(G), I.viewport = new Jt(), w[G] = I), I.matrix.fromArray(R.transform.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale), I.projectionMatrix.fromArray(R.projectionMatrix), I.projectionMatrixInverse.copy(I.projectionMatrix).invert(), I.viewport.set(z.x, z.y, z.width, z.height), G === 0 && (A.matrix.copy(I.matrix), A.matrix.decompose(A.position, A.quaternion, A.scale)), H === !0 && A.cameras.push(I);
        }
        const K = s.enabledFeatures;
        if (K && K.includes("depth-sensing")) {
          const G = d.getDepthInformation(ye[0]);
          G && G.isValid && G.texture && _.init(e, G, s.renderState);
        }
      }
      for (let ye = 0; ye < b.length; ye++) {
        const H = x[ye], K = b[ye];
        H !== null && K !== void 0 && K.update(H, re, u || a);
      }
      $ && $(le, re), re.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: re }), m = null;
    }
    const se = new Pb();
    se.setAnimationLoop(J), this.setAnimationLoop = function(le) {
      $ = le;
    }, this.dispose = function() {
    };
  }
}
const To = /* @__PURE__ */ new Zi(), i3 = /* @__PURE__ */ new rn();
function s3(r, e) {
  function n(g, v) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), v.value.copy(g.matrix);
  }
  function i(g, v) {
    v.color.getRGB(g.fogColor.value, Tb(r)), v.isFog ? (g.fogNear.value = v.near, g.fogFar.value = v.far) : v.isFogExp2 && (g.fogDensity.value = v.density);
  }
  function s(g, v, S, b, x) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial ? o(g, v) : v.isMeshToonMaterial ? (o(g, v), d(g, v)) : v.isMeshPhongMaterial ? (o(g, v), h(g, v)) : v.isMeshStandardMaterial ? (o(g, v), p(g, v), v.isMeshPhysicalMaterial && f(g, v, x)) : v.isMeshMatcapMaterial ? (o(g, v), m(g, v)) : v.isMeshDepthMaterial ? o(g, v) : v.isMeshDistanceMaterial ? (o(g, v), _(g, v)) : v.isMeshNormalMaterial ? o(g, v) : v.isLineBasicMaterial ? (a(g, v), v.isLineDashedMaterial && l(g, v)) : v.isPointsMaterial ? c(g, v, S, b) : v.isSpriteMaterial ? u(g, v) : v.isShadowMaterial ? (g.color.value.copy(v.color), g.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function o(g, v) {
    g.opacity.value = v.opacity, v.color && g.diffuse.value.copy(v.color), v.emissive && g.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (g.map.value = v.map, n(v.map, g.mapTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, n(v.alphaMap, g.alphaMapTransform)), v.bumpMap && (g.bumpMap.value = v.bumpMap, n(v.bumpMap, g.bumpMapTransform), g.bumpScale.value = v.bumpScale, v.side === Oi && (g.bumpScale.value *= -1)), v.normalMap && (g.normalMap.value = v.normalMap, n(v.normalMap, g.normalMapTransform), g.normalScale.value.copy(v.normalScale), v.side === Oi && g.normalScale.value.negate()), v.displacementMap && (g.displacementMap.value = v.displacementMap, n(v.displacementMap, g.displacementMapTransform), g.displacementScale.value = v.displacementScale, g.displacementBias.value = v.displacementBias), v.emissiveMap && (g.emissiveMap.value = v.emissiveMap, n(v.emissiveMap, g.emissiveMapTransform)), v.specularMap && (g.specularMap.value = v.specularMap, n(v.specularMap, g.specularMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
    const S = e.get(v), b = S.envMap, x = S.envMapRotation;
    b && (g.envMap.value = b, To.copy(x), To.x *= -1, To.y *= -1, To.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (To.y *= -1, To.z *= -1), g.envMapRotation.value.setFromMatrix4(i3.makeRotationFromEuler(To)), g.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = v.reflectivity, g.ior.value = v.ior, g.refractionRatio.value = v.refractionRatio), v.lightMap && (g.lightMap.value = v.lightMap, g.lightMapIntensity.value = v.lightMapIntensity, n(v.lightMap, g.lightMapTransform)), v.aoMap && (g.aoMap.value = v.aoMap, g.aoMapIntensity.value = v.aoMapIntensity, n(v.aoMap, g.aoMapTransform));
  }
  function a(g, v) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, v.map && (g.map.value = v.map, n(v.map, g.mapTransform));
  }
  function l(g, v) {
    g.dashSize.value = v.dashSize, g.totalSize.value = v.dashSize + v.gapSize, g.scale.value = v.scale;
  }
  function c(g, v, S, b) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, g.size.value = v.size * S, g.scale.value = b * 0.5, v.map && (g.map.value = v.map, n(v.map, g.uvTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, n(v.alphaMap, g.alphaMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
  }
  function u(g, v) {
    g.diffuse.value.copy(v.color), g.opacity.value = v.opacity, g.rotation.value = v.rotation, v.map && (g.map.value = v.map, n(v.map, g.mapTransform)), v.alphaMap && (g.alphaMap.value = v.alphaMap, n(v.alphaMap, g.alphaMapTransform)), v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest);
  }
  function h(g, v) {
    g.specular.value.copy(v.specular), g.shininess.value = Math.max(v.shininess, 1e-4);
  }
  function d(g, v) {
    v.gradientMap && (g.gradientMap.value = v.gradientMap);
  }
  function p(g, v) {
    g.metalness.value = v.metalness, v.metalnessMap && (g.metalnessMap.value = v.metalnessMap, n(v.metalnessMap, g.metalnessMapTransform)), g.roughness.value = v.roughness, v.roughnessMap && (g.roughnessMap.value = v.roughnessMap, n(v.roughnessMap, g.roughnessMapTransform)), v.envMap && (g.envMapIntensity.value = v.envMapIntensity);
  }
  function f(g, v, S) {
    g.ior.value = v.ior, v.sheen > 0 && (g.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), g.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (g.sheenColorMap.value = v.sheenColorMap, n(v.sheenColorMap, g.sheenColorMapTransform)), v.sheenRoughnessMap && (g.sheenRoughnessMap.value = v.sheenRoughnessMap, n(v.sheenRoughnessMap, g.sheenRoughnessMapTransform))), v.clearcoat > 0 && (g.clearcoat.value = v.clearcoat, g.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (g.clearcoatMap.value = v.clearcoatMap, n(v.clearcoatMap, g.clearcoatMapTransform)), v.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap, n(v.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), v.clearcoatNormalMap && (g.clearcoatNormalMap.value = v.clearcoatNormalMap, n(v.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), v.side === Oi && g.clearcoatNormalScale.value.negate())), v.dispersion > 0 && (g.dispersion.value = v.dispersion), v.iridescence > 0 && (g.iridescence.value = v.iridescence, g.iridescenceIOR.value = v.iridescenceIOR, g.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (g.iridescenceMap.value = v.iridescenceMap, n(v.iridescenceMap, g.iridescenceMapTransform)), v.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = v.iridescenceThicknessMap, n(v.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), v.transmission > 0 && (g.transmission.value = v.transmission, g.transmissionSamplerMap.value = S.texture, g.transmissionSamplerSize.value.set(S.width, S.height), v.transmissionMap && (g.transmissionMap.value = v.transmissionMap, n(v.transmissionMap, g.transmissionMapTransform)), g.thickness.value = v.thickness, v.thicknessMap && (g.thicknessMap.value = v.thicknessMap, n(v.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = v.attenuationDistance, g.attenuationColor.value.copy(v.attenuationColor)), v.anisotropy > 0 && (g.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)), v.anisotropyMap && (g.anisotropyMap.value = v.anisotropyMap, n(v.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = v.specularIntensity, g.specularColor.value.copy(v.specularColor), v.specularColorMap && (g.specularColorMap.value = v.specularColorMap, n(v.specularColorMap, g.specularColorMapTransform)), v.specularIntensityMap && (g.specularIntensityMap.value = v.specularIntensityMap, n(v.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function m(g, v) {
    v.matcap && (g.matcap.value = v.matcap);
  }
  function _(g, v) {
    const S = e.get(v).light;
    g.referencePosition.value.setFromMatrixPosition(S.matrixWorld), g.nearDistance.value = S.shadow.camera.near, g.farDistance.value = S.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: s
  };
}
function r3(r, e, n, i) {
  let s = {}, o = {}, a = [];
  const l = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(S, b) {
    const x = b.program;
    i.uniformBlockBinding(S, x);
  }
  function u(S, b) {
    let x = s[S.id];
    x === void 0 && (m(S), x = h(S), s[S.id] = x, S.addEventListener("dispose", g));
    const M = b.program;
    i.updateUBOMapping(S, M);
    const C = e.render.frame;
    o[S.id] !== C && (p(S), o[S.id] = C);
  }
  function h(S) {
    const b = d();
    S.__bindingPointIndex = b;
    const x = r.createBuffer(), M = S.__size, C = S.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, x), r.bufferData(r.UNIFORM_BUFFER, M, C), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, b, x), x;
  }
  function d() {
    for (let S = 0; S < l; S++)
      if (a.indexOf(S) === -1)
        return a.push(S), S;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(S) {
    const b = s[S.id], x = S.uniforms, M = S.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, b);
    for (let C = 0, E = x.length; C < E; C++) {
      const T = Array.isArray(x[C]) ? x[C] : [x[C]];
      for (let w = 0, A = T.length; w < A; w++) {
        const O = T[w];
        if (f(O, C, w, M) === !0) {
          const U = O.__offset, D = Array.isArray(O.value) ? O.value : [O.value];
          let L = 0;
          for (let P = 0; P < D.length; P++) {
            const V = D[P], ce = _(V);
            typeof V == "number" || typeof V == "boolean" ? (O.__data[0] = V, r.bufferSubData(r.UNIFORM_BUFFER, U + L, O.__data)) : V.isMatrix3 ? (O.__data[0] = V.elements[0], O.__data[1] = V.elements[1], O.__data[2] = V.elements[2], O.__data[3] = 0, O.__data[4] = V.elements[3], O.__data[5] = V.elements[4], O.__data[6] = V.elements[5], O.__data[7] = 0, O.__data[8] = V.elements[6], O.__data[9] = V.elements[7], O.__data[10] = V.elements[8], O.__data[11] = 0) : (V.toArray(O.__data, L), L += ce.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, U, O.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(S, b, x, M) {
    const C = S.value, E = b + "_" + x;
    if (M[E] === void 0)
      return typeof C == "number" || typeof C == "boolean" ? M[E] = C : M[E] = C.clone(), !0;
    {
      const T = M[E];
      if (typeof C == "number" || typeof C == "boolean") {
        if (T !== C)
          return M[E] = C, !0;
      } else if (T.equals(C) === !1)
        return T.copy(C), !0;
    }
    return !1;
  }
  function m(S) {
    const b = S.uniforms;
    let x = 0;
    const M = 16;
    for (let E = 0, T = b.length; E < T; E++) {
      const w = Array.isArray(b[E]) ? b[E] : [b[E]];
      for (let A = 0, O = w.length; A < O; A++) {
        const U = w[A], D = Array.isArray(U.value) ? U.value : [U.value];
        for (let L = 0, P = D.length; L < P; L++) {
          const V = D[L], ce = _(V), q = x % M, oe = q % ce.boundary, ne = q + oe;
          x += oe, ne !== 0 && M - ne < ce.storage && (x += M - ne), U.__data = new Float32Array(ce.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = x, x += ce.storage;
        }
      }
    }
    const C = x % M;
    return C > 0 && (x += M - C), S.__size = x, S.__cache = {}, this;
  }
  function _(S) {
    const b = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof S == "number" || typeof S == "boolean" ? (b.boundary = 4, b.storage = 4) : S.isVector2 ? (b.boundary = 8, b.storage = 8) : S.isVector3 || S.isColor ? (b.boundary = 16, b.storage = 12) : S.isVector4 ? (b.boundary = 16, b.storage = 16) : S.isMatrix3 ? (b.boundary = 48, b.storage = 48) : S.isMatrix4 ? (b.boundary = 64, b.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), b;
  }
  function g(S) {
    const b = S.target;
    b.removeEventListener("dispose", g);
    const x = a.indexOf(b.__bindingPointIndex);
    a.splice(x, 1), r.deleteBuffer(s[b.id]), delete s[b.id], delete o[b.id];
  }
  function v() {
    for (const S in s)
      r.deleteBuffer(s[S]);
    a = [], s = {}, o = {};
  }
  return {
    bind: c,
    update: u,
    dispose: v
  };
}
class o3 {
  constructor(e = {}) {
    const {
      canvas: n = KT(),
      context: i = null,
      depth: s = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = i.getContextAttributes().alpha;
    } else
      f = a;
    const m = new Uint32Array(4), _ = new Int32Array(4);
    let g = null, v = null;
    const S = [], b = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = An, this.toneMapping = ro, this.toneMappingExposure = 1;
    const x = this;
    let M = !1, C = 0, E = 0, T = null, w = -1, A = null;
    const O = new Jt(), U = new Jt();
    let D = null;
    const L = new Tt(0);
    let P = 0, V = n.width, ce = n.height, q = 1, oe = null, ne = null;
    const $ = new Jt(0, 0, V, ce), J = new Jt(0, 0, V, ce);
    let se = !1;
    const le = new Jg();
    let re = !1, ye = !1;
    const H = new rn(), K = new rn(), G = new he(), R = new Jt(), z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let I = !1;
    function Q() {
      return T === null ? q : 1;
    }
    let X = i;
    function k(W, ve) {
      return n.getContext(W, ve);
    }
    try {
      const W = {
        alpha: !0,
        depth: s,
        stencil: o,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${Bg}`), n.addEventListener("webglcontextlost", je, !1), n.addEventListener("webglcontextrestored", Ke, !1), n.addEventListener("webglcontextcreationerror", qe, !1), X === null) {
        const ve = "webgl2";
        if (X = k(ve, W), X === null)
          throw k(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (W) {
      throw console.error("THREE.WebGLRenderer: " + W.message), W;
    }
    let ee, Z, N, j, te, F, B, Y, fe, ge, xe, De, ae, de, Ee, be, ke, ze, Te, Pe, Ge, Ve, Qe, _e;
    function Ue() {
      ee = new fP(X), ee.init(), Ve = new ZD(X, ee), Z = new aP(X, ee, e, Ve), N = new XD(X, ee), Z.reverseDepthBuffer && p && N.buffers.depth.setReversed(!0), j = new gP(X), te = new ID(), F = new qD(X, ee, N, te, Z, Ve, j), B = new cP(x), Y = new dP(x), fe = new S2(X), Qe = new rP(X, fe), ge = new pP(X, fe, j, Qe), xe = new yP(X, ge, fe, j), Te = new vP(X, Z, F), be = new lP(te), De = new LD(x, B, Y, ee, Z, Qe, be), ae = new s3(x, te), de = new FD(), Ee = new GD(ee), ze = new sP(x, B, Y, N, xe, f, c), ke = new jD(x, xe, Z), _e = new r3(X, j, Z, N), Pe = new oP(X, ee, j), Ge = new mP(X, ee, j), j.programs = De.programs, x.capabilities = Z, x.extensions = ee, x.properties = te, x.renderLists = de, x.shadowMap = ke, x.state = N, x.info = j;
    }
    Ue();
    const Fe = new n3(x, X);
    this.xr = Fe, this.getContext = function() {
      return X;
    }, this.getContextAttributes = function() {
      return X.getContextAttributes();
    }, this.forceContextLoss = function() {
      const W = ee.get("WEBGL_lose_context");
      W && W.loseContext();
    }, this.forceContextRestore = function() {
      const W = ee.get("WEBGL_lose_context");
      W && W.restoreContext();
    }, this.getPixelRatio = function() {
      return q;
    }, this.setPixelRatio = function(W) {
      W !== void 0 && (q = W, this.setSize(V, ce, !1));
    }, this.getSize = function(W) {
      return W.set(V, ce);
    }, this.setSize = function(W, ve, we = !0) {
      if (Fe.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      V = W, ce = ve, n.width = Math.floor(W * q), n.height = Math.floor(ve * q), we === !0 && (n.style.width = W + "px", n.style.height = ve + "px"), this.setViewport(0, 0, W, ve);
    }, this.getDrawingBufferSize = function(W) {
      return W.set(V * q, ce * q).floor();
    }, this.setDrawingBufferSize = function(W, ve, we) {
      V = W, ce = ve, q = we, n.width = Math.floor(W * we), n.height = Math.floor(ve * we), this.setViewport(0, 0, W, ve);
    }, this.getCurrentViewport = function(W) {
      return W.copy(O);
    }, this.getViewport = function(W) {
      return W.copy($);
    }, this.setViewport = function(W, ve, we, Le) {
      W.isVector4 ? $.set(W.x, W.y, W.z, W.w) : $.set(W, ve, we, Le), N.viewport(O.copy($).multiplyScalar(q).round());
    }, this.getScissor = function(W) {
      return W.copy(J);
    }, this.setScissor = function(W, ve, we, Le) {
      W.isVector4 ? J.set(W.x, W.y, W.z, W.w) : J.set(W, ve, we, Le), N.scissor(U.copy(J).multiplyScalar(q).round());
    }, this.getScissorTest = function() {
      return se;
    }, this.setScissorTest = function(W) {
      N.setScissorTest(se = W);
    }, this.setOpaqueSort = function(W) {
      oe = W;
    }, this.setTransparentSort = function(W) {
      ne = W;
    }, this.getClearColor = function(W) {
      return W.copy(ze.getClearColor());
    }, this.setClearColor = function() {
      ze.setClearColor.apply(ze, arguments);
    }, this.getClearAlpha = function() {
      return ze.getClearAlpha();
    }, this.setClearAlpha = function() {
      ze.setClearAlpha.apply(ze, arguments);
    }, this.clear = function(W = !0, ve = !0, we = !0) {
      let Le = 0;
      if (W) {
        let Me = !1;
        if (T !== null) {
          const We = T.texture.format;
          Me = We === $g || We === jg || We === Wg;
        }
        if (Me) {
          const We = T.texture.type, Be = We === js || We === ta || We === Wc || We === ul || We === Gg || We === Hg, st = ze.getClearColor(), lt = ze.getClearAlpha(), yt = st.r, bt = st.g, ft = st.b;
          Be ? (m[0] = yt, m[1] = bt, m[2] = ft, m[3] = lt, X.clearBufferuiv(X.COLOR, 0, m)) : (_[0] = yt, _[1] = bt, _[2] = ft, _[3] = lt, X.clearBufferiv(X.COLOR, 0, _));
        } else
          Le |= X.COLOR_BUFFER_BIT;
      }
      ve && (Le |= X.DEPTH_BUFFER_BIT), we && (Le |= X.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), X.clear(Le);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", je, !1), n.removeEventListener("webglcontextrestored", Ke, !1), n.removeEventListener("webglcontextcreationerror", qe, !1), de.dispose(), Ee.dispose(), te.dispose(), B.dispose(), Y.dispose(), xe.dispose(), Qe.dispose(), _e.dispose(), De.dispose(), Fe.dispose(), Fe.removeEventListener("sessionstart", on), Fe.removeEventListener("sessionend", Rn), dn.stop();
    };
    function je(W) {
      W.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = !0;
    }
    function Ke() {
      console.log("THREE.WebGLRenderer: Context Restored."), M = !1;
      const W = j.autoReset, ve = ke.enabled, we = ke.autoUpdate, Le = ke.needsUpdate, Me = ke.type;
      Ue(), j.autoReset = W, ke.enabled = ve, ke.autoUpdate = we, ke.needsUpdate = Le, ke.type = Me;
    }
    function qe(W) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", W.statusMessage);
    }
    function ut(W) {
      const ve = W.target;
      ve.removeEventListener("dispose", ut), ot(ve);
    }
    function ot(W) {
      dt(W), te.remove(W);
    }
    function dt(W) {
      const ve = te.get(W).programs;
      ve !== void 0 && (ve.forEach(function(we) {
        De.releaseProgram(we);
      }), W.isShaderMaterial && De.releaseShaderCache(W));
    }
    this.renderBufferDirect = function(W, ve, we, Le, Me, We) {
      ve === null && (ve = z);
      const Be = Me.isMesh && Me.matrixWorld.determinant() < 0, st = Se(W, ve, we, Le, Me);
      N.setMaterial(Le, Be);
      let lt = we.index, yt = 1;
      if (Le.wireframe === !0) {
        if (lt = ge.getWireframeAttribute(we), lt === void 0) return;
        yt = 2;
      }
      const bt = we.drawRange, ft = we.attributes.position;
      let Ft = bt.start * yt, Xt = (bt.start + bt.count) * yt;
      We !== null && (Ft = Math.max(Ft, We.start * yt), Xt = Math.min(Xt, (We.start + We.count) * yt)), lt !== null ? (Ft = Math.max(Ft, 0), Xt = Math.min(Xt, lt.count)) : ft != null && (Ft = Math.max(Ft, 0), Xt = Math.min(Xt, ft.count));
      const qt = Xt - Ft;
      if (qt < 0 || qt === 1 / 0) return;
      Qe.setup(Me, Le, st, we, lt);
      let Zn, zt = Pe;
      if (lt !== null && (Zn = fe.get(lt), zt = Ge, zt.setIndex(Zn)), Me.isMesh)
        Le.wireframe === !0 ? (N.setLineWidth(Le.wireframeLinewidth * Q()), zt.setMode(X.LINES)) : zt.setMode(X.TRIANGLES);
      else if (Me.isLine) {
        let gt = Le.linewidth;
        gt === void 0 && (gt = 1), N.setLineWidth(gt * Q()), Me.isLineSegments ? zt.setMode(X.LINES) : Me.isLineLoop ? zt.setMode(X.LINE_LOOP) : zt.setMode(X.LINE_STRIP);
      } else Me.isPoints ? zt.setMode(X.POINTS) : Me.isSprite && zt.setMode(X.TRIANGLES);
      if (Me.isBatchedMesh)
        if (Me._multiDrawInstances !== null)
          zt.renderMultiDrawInstances(Me._multiDrawStarts, Me._multiDrawCounts, Me._multiDrawCount, Me._multiDrawInstances);
        else if (ee.get("WEBGL_multi_draw"))
          zt.renderMultiDraw(Me._multiDrawStarts, Me._multiDrawCounts, Me._multiDrawCount);
        else {
          const gt = Me._multiDrawStarts, Vi = Me._multiDrawCounts, Vt = Me._multiDrawCount, Kn = lt ? fe.get(lt).bytesPerElement : 1, Ds = te.get(Le).currentProgram.getUniforms();
          for (let zn = 0; zn < Vt; zn++)
            Ds.setValue(X, "_gl_DrawID", zn), zt.render(gt[zn] / Kn, Vi[zn]);
        }
      else if (Me.isInstancedMesh)
        zt.renderInstances(Ft, qt, Me.count);
      else if (we.isInstancedBufferGeometry) {
        const gt = we._maxInstanceCount !== void 0 ? we._maxInstanceCount : 1 / 0, Vi = Math.min(we.instanceCount, gt);
        zt.renderInstances(Ft, qt, Vi);
      } else
        zt.render(Ft, qt);
    };
    function mt(W, ve, we) {
      W.transparent === !0 && W.side === Pn && W.forceSinglePass === !1 ? (W.side = Oi, W.needsUpdate = !0, Mi(W, ve, we), W.side = ao, W.needsUpdate = !0, Mi(W, ve, we), W.side = Pn) : Mi(W, ve, we);
    }
    this.compile = function(W, ve, we = null) {
      we === null && (we = W), v = Ee.get(we), v.init(ve), b.push(v), we.traverseVisible(function(Me) {
        Me.isLight && Me.layers.test(ve.layers) && (v.pushLight(Me), Me.castShadow && v.pushShadow(Me));
      }), W !== we && W.traverseVisible(function(Me) {
        Me.isLight && Me.layers.test(ve.layers) && (v.pushLight(Me), Me.castShadow && v.pushShadow(Me));
      }), v.setupLights();
      const Le = /* @__PURE__ */ new Set();
      return W.traverse(function(Me) {
        if (!(Me.isMesh || Me.isPoints || Me.isLine || Me.isSprite))
          return;
        const We = Me.material;
        if (We)
          if (Array.isArray(We))
            for (let Be = 0; Be < We.length; Be++) {
              const st = We[Be];
              mt(st, we, Me), Le.add(st);
            }
          else
            mt(We, we, Me), Le.add(We);
      }), b.pop(), v = null, Le;
    }, this.compileAsync = function(W, ve, we = null) {
      const Le = this.compile(W, ve, we);
      return new Promise((Me) => {
        function We() {
          if (Le.forEach(function(Be) {
            te.get(Be).currentProgram.isReady() && Le.delete(Be);
          }), Le.size === 0) {
            Me(W);
            return;
          }
          setTimeout(We, 10);
        }
        ee.get("KHR_parallel_shader_compile") !== null ? We() : setTimeout(We, 10);
      });
    };
    let Bt = null;
    function $t(W) {
      Bt && Bt(W);
    }
    function on() {
      dn.stop();
    }
    function Rn() {
      dn.start();
    }
    const dn = new Pb();
    dn.setAnimationLoop($t), typeof self < "u" && dn.setContext(self), this.setAnimationLoop = function(W) {
      Bt = W, Fe.setAnimationLoop(W), W === null ? dn.stop() : dn.start();
    }, Fe.addEventListener("sessionstart", on), Fe.addEventListener("sessionend", Rn), this.render = function(W, ve) {
      if (ve !== void 0 && ve.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (M === !0) return;
      if (W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), Fe.enabled === !0 && Fe.isPresenting === !0 && (Fe.cameraAutoUpdate === !0 && Fe.updateCamera(ve), ve = Fe.getCamera()), W.isScene === !0 && W.onBeforeRender(x, W, ve, T), v = Ee.get(W, b.length), v.init(ve), b.push(v), K.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), le.setFromProjectionMatrix(K), ye = this.localClippingEnabled, re = be.init(this.clippingPlanes, ye), g = de.get(W, S.length), g.init(), S.push(g), Fe.enabled === !0 && Fe.isPresenting === !0) {
        const We = x.xr.getDepthSensingMesh();
        We !== null && Un(We, ve, -1 / 0, x.sortObjects);
      }
      Un(W, ve, 0, x.sortObjects), g.finish(), x.sortObjects === !0 && g.sort(oe, ne), I = Fe.enabled === !1 || Fe.isPresenting === !1 || Fe.hasDepthSensing() === !1, I && ze.addToRenderList(g, W), this.info.render.frame++, re === !0 && be.beginShadows();
      const we = v.state.shadowsArray;
      ke.render(we, W, ve), re === !0 && be.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Le = g.opaque, Me = g.transmissive;
      if (v.setupLights(), ve.isArrayCamera) {
        const We = ve.cameras;
        if (Me.length > 0)
          for (let Be = 0, st = We.length; Be < st; Be++) {
            const lt = We[Be];
            Ln(Le, Me, W, lt);
          }
        I && ze.render(W);
        for (let Be = 0, st = We.length; Be < st; Be++) {
          const lt = We[Be];
          qn(g, W, lt, lt.viewport);
        }
      } else
        Me.length > 0 && Ln(Le, Me, W, ve), I && ze.render(W), qn(g, W, ve);
      T !== null && (F.updateMultisampleRenderTarget(T), F.updateRenderTargetMipmap(T)), W.isScene === !0 && W.onAfterRender(x, W, ve), Qe.resetDefaultState(), w = -1, A = null, b.pop(), b.length > 0 ? (v = b[b.length - 1], re === !0 && be.setGlobalState(x.clippingPlanes, v.state.camera)) : v = null, S.pop(), S.length > 0 ? g = S[S.length - 1] : g = null;
    };
    function Un(W, ve, we, Le) {
      if (W.visible === !1) return;
      if (W.layers.test(ve.layers)) {
        if (W.isGroup)
          we = W.renderOrder;
        else if (W.isLOD)
          W.autoUpdate === !0 && W.update(ve);
        else if (W.isLight)
          v.pushLight(W), W.castShadow && v.pushShadow(W);
        else if (W.isSprite) {
          if (!W.frustumCulled || le.intersectsSprite(W)) {
            Le && R.setFromMatrixPosition(W.matrixWorld).applyMatrix4(K);
            const Be = xe.update(W), st = W.material;
            st.visible && g.push(W, Be, st, we, R.z, null);
          }
        } else if ((W.isMesh || W.isLine || W.isPoints) && (!W.frustumCulled || le.intersectsObject(W))) {
          const Be = xe.update(W), st = W.material;
          if (Le && (W.boundingSphere !== void 0 ? (W.boundingSphere === null && W.computeBoundingSphere(), R.copy(W.boundingSphere.center)) : (Be.boundingSphere === null && Be.computeBoundingSphere(), R.copy(Be.boundingSphere.center)), R.applyMatrix4(W.matrixWorld).applyMatrix4(K)), Array.isArray(st)) {
            const lt = Be.groups;
            for (let yt = 0, bt = lt.length; yt < bt; yt++) {
              const ft = lt[yt], Ft = st[ft.materialIndex];
              Ft && Ft.visible && g.push(W, Be, Ft, we, R.z, ft);
            }
          } else st.visible && g.push(W, Be, st, we, R.z, null);
        }
      }
      const We = W.children;
      for (let Be = 0, st = We.length; Be < st; Be++)
        Un(We[Be], ve, we, Le);
    }
    function qn(W, ve, we, Le) {
      const Me = W.opaque, We = W.transmissive, Be = W.transparent;
      v.setupLightsView(we), re === !0 && be.setGlobalState(x.clippingPlanes, we), Le && N.viewport(O.copy(Le)), Me.length > 0 && wn(Me, ve, we), We.length > 0 && wn(We, ve, we), Be.length > 0 && wn(Be, ve, we), N.buffers.depth.setTest(!0), N.buffers.depth.setMask(!0), N.buffers.color.setMask(!0), N.setPolygonOffset(!1);
    }
    function Ln(W, ve, we, Le) {
      if ((we.isScene === !0 ? we.overrideMaterial : null) !== null)
        return;
      v.state.transmissionRenderTarget[Le.id] === void 0 && (v.state.transmissionRenderTarget[Le.id] = new Es(1, 1, {
        generateMipmaps: !0,
        type: ee.has("EXT_color_buffer_half_float") || ee.has("EXT_color_buffer_float") ? po : js,
        minFilter: jo,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Nt.workingColorSpace
      }));
      const We = v.state.transmissionRenderTarget[Le.id], Be = Le.viewport || O;
      We.setSize(Be.z, Be.w);
      const st = x.getRenderTarget();
      x.setRenderTarget(We), x.getClearColor(L), P = x.getClearAlpha(), P < 1 && x.setClearColor(16777215, 0.5), x.clear(), I && ze.render(we);
      const lt = x.toneMapping;
      x.toneMapping = ro;
      const yt = Le.viewport;
      if (Le.viewport !== void 0 && (Le.viewport = void 0), v.setupLightsView(Le), re === !0 && be.setGlobalState(x.clippingPlanes, Le), wn(W, we, Le), F.updateMultisampleRenderTarget(We), F.updateRenderTargetMipmap(We), ee.has("WEBGL_multisampled_render_to_texture") === !1) {
        let bt = !1;
        for (let ft = 0, Ft = ve.length; ft < Ft; ft++) {
          const Xt = ve[ft], qt = Xt.object, Zn = Xt.geometry, zt = Xt.material, gt = Xt.group;
          if (zt.side === Pn && qt.layers.test(Le.layers)) {
            const Vi = zt.side;
            zt.side = Oi, zt.needsUpdate = !0, Sn(qt, we, Le, Zn, zt, gt), zt.side = Vi, zt.needsUpdate = !0, bt = !0;
          }
        }
        bt === !0 && (F.updateMultisampleRenderTarget(We), F.updateRenderTargetMipmap(We));
      }
      x.setRenderTarget(st), x.setClearColor(L, P), yt !== void 0 && (Le.viewport = yt), x.toneMapping = lt;
    }
    function wn(W, ve, we) {
      const Le = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let Me = 0, We = W.length; Me < We; Me++) {
        const Be = W[Me], st = Be.object, lt = Be.geometry, yt = Le === null ? Be.material : Le, bt = Be.group;
        st.layers.test(we.layers) && Sn(st, ve, we, lt, yt, bt);
      }
    }
    function Sn(W, ve, we, Le, Me, We) {
      W.onBeforeRender(x, ve, we, Le, Me, We), W.modelViewMatrix.multiplyMatrices(we.matrixWorldInverse, W.matrixWorld), W.normalMatrix.getNormalMatrix(W.modelViewMatrix), Me.onBeforeRender(x, ve, we, Le, W, We), Me.transparent === !0 && Me.side === Pn && Me.forceSinglePass === !1 ? (Me.side = Oi, Me.needsUpdate = !0, x.renderBufferDirect(we, ve, Le, Me, W, We), Me.side = ao, Me.needsUpdate = !0, x.renderBufferDirect(we, ve, Le, Me, W, We), Me.side = Pn) : x.renderBufferDirect(we, ve, Le, Me, W, We), W.onAfterRender(x, ve, we, Le, Me, We);
    }
    function Mi(W, ve, we) {
      ve.isScene !== !0 && (ve = z);
      const Le = te.get(W), Me = v.state.lights, We = v.state.shadowsArray, Be = Me.state.version, st = De.getParameters(W, Me.state, We, ve, we), lt = De.getProgramCacheKey(st);
      let yt = Le.programs;
      Le.environment = W.isMeshStandardMaterial ? ve.environment : null, Le.fog = ve.fog, Le.envMap = (W.isMeshStandardMaterial ? Y : B).get(W.envMap || Le.environment), Le.envMapRotation = Le.environment !== null && W.envMap === null ? ve.environmentRotation : W.envMapRotation, yt === void 0 && (W.addEventListener("dispose", ut), yt = /* @__PURE__ */ new Map(), Le.programs = yt);
      let bt = yt.get(lt);
      if (bt !== void 0) {
        if (Le.currentProgram === bt && Le.lightsStateVersion === Be)
          return me(W, st), bt;
      } else
        st.uniforms = De.getUniforms(W), W.onBeforeCompile(st, x), bt = De.acquireProgram(st, lt), yt.set(lt, bt), Le.uniforms = st.uniforms;
      const ft = Le.uniforms;
      return (!W.isShaderMaterial && !W.isRawShaderMaterial || W.clipping === !0) && (ft.clippingPlanes = be.uniform), me(W, st), Le.needsLights = $e(W), Le.lightsStateVersion = Be, Le.needsLights && (ft.ambientLightColor.value = Me.state.ambient, ft.lightProbe.value = Me.state.probe, ft.directionalLights.value = Me.state.directional, ft.directionalLightShadows.value = Me.state.directionalShadow, ft.spotLights.value = Me.state.spot, ft.spotLightShadows.value = Me.state.spotShadow, ft.rectAreaLights.value = Me.state.rectArea, ft.ltc_1.value = Me.state.rectAreaLTC1, ft.ltc_2.value = Me.state.rectAreaLTC2, ft.pointLights.value = Me.state.point, ft.pointLightShadows.value = Me.state.pointShadow, ft.hemisphereLights.value = Me.state.hemi, ft.directionalShadowMap.value = Me.state.directionalShadowMap, ft.directionalShadowMatrix.value = Me.state.directionalShadowMatrix, ft.spotShadowMap.value = Me.state.spotShadowMap, ft.spotLightMatrix.value = Me.state.spotLightMatrix, ft.spotLightMap.value = Me.state.spotLightMap, ft.pointShadowMap.value = Me.state.pointShadowMap, ft.pointShadowMatrix.value = Me.state.pointShadowMatrix), Le.currentProgram = bt, Le.uniformsList = null, bt;
    }
    function os(W) {
      if (W.uniformsList === null) {
        const ve = W.currentProgram.getUniforms();
        W.uniformsList = Zh.seqWithValue(ve.seq, W.uniforms);
      }
      return W.uniformsList;
    }
    function me(W, ve) {
      const we = te.get(W);
      we.outputColorSpace = ve.outputColorSpace, we.batching = ve.batching, we.batchingColor = ve.batchingColor, we.instancing = ve.instancing, we.instancingColor = ve.instancingColor, we.instancingMorph = ve.instancingMorph, we.skinning = ve.skinning, we.morphTargets = ve.morphTargets, we.morphNormals = ve.morphNormals, we.morphColors = ve.morphColors, we.morphTargetsCount = ve.morphTargetsCount, we.numClippingPlanes = ve.numClippingPlanes, we.numIntersection = ve.numClipIntersection, we.vertexAlphas = ve.vertexAlphas, we.vertexTangents = ve.vertexTangents, we.toneMapping = ve.toneMapping;
    }
    function Se(W, ve, we, Le, Me) {
      ve.isScene !== !0 && (ve = z), F.resetTextureUnits();
      const We = ve.fog, Be = Le.isMeshStandardMaterial ? ve.environment : null, st = T === null ? x.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : _l, lt = (Le.isMeshStandardMaterial ? Y : B).get(Le.envMap || Be), yt = Le.vertexColors === !0 && !!we.attributes.color && we.attributes.color.itemSize === 4, bt = !!we.attributes.tangent && (!!Le.normalMap || Le.anisotropy > 0), ft = !!we.morphAttributes.position, Ft = !!we.morphAttributes.normal, Xt = !!we.morphAttributes.color;
      let qt = ro;
      Le.toneMapped && (T === null || T.isXRRenderTarget === !0) && (qt = x.toneMapping);
      const Zn = we.morphAttributes.position || we.morphAttributes.normal || we.morphAttributes.color, zt = Zn !== void 0 ? Zn.length : 0, gt = te.get(Le), Vi = v.state.lights;
      if (re === !0 && (ye === !0 || W !== A)) {
        const Ti = W === A && Le.id === w;
        be.setState(Le, W, Ti);
      }
      let Vt = !1;
      Le.version === gt.__version ? (gt.needsLights && gt.lightsStateVersion !== Vi.state.version || gt.outputColorSpace !== st || Me.isBatchedMesh && gt.batching === !1 || !Me.isBatchedMesh && gt.batching === !0 || Me.isBatchedMesh && gt.batchingColor === !0 && Me.colorTexture === null || Me.isBatchedMesh && gt.batchingColor === !1 && Me.colorTexture !== null || Me.isInstancedMesh && gt.instancing === !1 || !Me.isInstancedMesh && gt.instancing === !0 || Me.isSkinnedMesh && gt.skinning === !1 || !Me.isSkinnedMesh && gt.skinning === !0 || Me.isInstancedMesh && gt.instancingColor === !0 && Me.instanceColor === null || Me.isInstancedMesh && gt.instancingColor === !1 && Me.instanceColor !== null || Me.isInstancedMesh && gt.instancingMorph === !0 && Me.morphTexture === null || Me.isInstancedMesh && gt.instancingMorph === !1 && Me.morphTexture !== null || gt.envMap !== lt || Le.fog === !0 && gt.fog !== We || gt.numClippingPlanes !== void 0 && (gt.numClippingPlanes !== be.numPlanes || gt.numIntersection !== be.numIntersection) || gt.vertexAlphas !== yt || gt.vertexTangents !== bt || gt.morphTargets !== ft || gt.morphNormals !== Ft || gt.morphColors !== Xt || gt.toneMapping !== qt || gt.morphTargetsCount !== zt) && (Vt = !0) : (Vt = !0, gt.__version = Le.version);
      let Kn = gt.currentProgram;
      Vt === !0 && (Kn = Mi(Le, ve, Me));
      let Ds = !1, zn = !1, qs = !1;
      const en = Kn.getUniforms(), Ci = gt.uniforms;
      if (N.useProgram(Kn.program) && (Ds = !0, zn = !0, qs = !0), Le.id !== w && (w = Le.id, zn = !0), Ds || A !== W) {
        N.buffers.depth.getReversed() ? (H.copy(W.projectionMatrix), QT(H), e2(H), en.setValue(X, "projectionMatrix", H)) : en.setValue(X, "projectionMatrix", W.projectionMatrix), en.setValue(X, "viewMatrix", W.matrixWorldInverse);
        const Gi = en.map.cameraPosition;
        Gi !== void 0 && Gi.setValue(X, G.setFromMatrixPosition(W.matrixWorld)), Z.logarithmicDepthBuffer && en.setValue(
          X,
          "logDepthBufFC",
          2 / (Math.log(W.far + 1) / Math.LN2)
        ), (Le.isMeshPhongMaterial || Le.isMeshToonMaterial || Le.isMeshLambertMaterial || Le.isMeshBasicMaterial || Le.isMeshStandardMaterial || Le.isShaderMaterial) && en.setValue(X, "isOrthographic", W.isOrthographicCamera === !0), A !== W && (A = W, zn = !0, qs = !0);
      }
      if (Me.isSkinnedMesh) {
        en.setOptional(X, Me, "bindMatrix"), en.setOptional(X, Me, "bindMatrixInverse");
        const Ti = Me.skeleton;
        Ti && (Ti.boneTexture === null && Ti.computeBoneTexture(), en.setValue(X, "boneTexture", Ti.boneTexture, F));
      }
      Me.isBatchedMesh && (en.setOptional(X, Me, "batchingTexture"), en.setValue(X, "batchingTexture", Me._matricesTexture, F), en.setOptional(X, Me, "batchingIdTexture"), en.setValue(X, "batchingIdTexture", Me._indirectTexture, F), en.setOptional(X, Me, "batchingColorTexture"), Me._colorsTexture !== null && en.setValue(X, "batchingColorTexture", Me._colorsTexture, F));
      const ri = we.morphAttributes;
      if ((ri.position !== void 0 || ri.normal !== void 0 || ri.color !== void 0) && Te.update(Me, we, Kn), (zn || gt.receiveShadow !== Me.receiveShadow) && (gt.receiveShadow = Me.receiveShadow, en.setValue(X, "receiveShadow", Me.receiveShadow)), Le.isMeshGouraudMaterial && Le.envMap !== null && (Ci.envMap.value = lt, Ci.flipEnvMap.value = lt.isCubeTexture && lt.isRenderTargetTexture === !1 ? -1 : 1), Le.isMeshStandardMaterial && Le.envMap === null && ve.environment !== null && (Ci.envMapIntensity.value = ve.environmentIntensity), zn && (en.setValue(X, "toneMappingExposure", x.toneMappingExposure), gt.needsLights && Oe(Ci, qs), We && Le.fog === !0 && ae.refreshFogUniforms(Ci, We), ae.refreshMaterialUniforms(Ci, Le, q, ce, v.state.transmissionRenderTarget[W.id]), Zh.upload(X, os(gt), Ci, F)), Le.isShaderMaterial && Le.uniformsNeedUpdate === !0 && (Zh.upload(X, os(gt), Ci, F), Le.uniformsNeedUpdate = !1), Le.isSpriteMaterial && en.setValue(X, "center", Me.center), en.setValue(X, "modelViewMatrix", Me.modelViewMatrix), en.setValue(X, "normalMatrix", Me.normalMatrix), en.setValue(X, "modelMatrix", Me.matrixWorld), Le.isShaderMaterial || Le.isRawShaderMaterial) {
        const Ti = Le.uniformsGroups;
        for (let Gi = 0, Ei = Ti.length; Gi < Ei; Gi++) {
          const kl = Ti[Gi];
          _e.update(kl, Kn), _e.bind(kl, Kn);
        }
      }
      return Kn;
    }
    function Oe(W, ve) {
      W.ambientLightColor.needsUpdate = ve, W.lightProbe.needsUpdate = ve, W.directionalLights.needsUpdate = ve, W.directionalLightShadows.needsUpdate = ve, W.pointLights.needsUpdate = ve, W.pointLightShadows.needsUpdate = ve, W.spotLights.needsUpdate = ve, W.spotLightShadows.needsUpdate = ve, W.rectAreaLights.needsUpdate = ve, W.hemisphereLights.needsUpdate = ve;
    }
    function $e(W) {
      return W.isMeshLambertMaterial || W.isMeshToonMaterial || W.isMeshPhongMaterial || W.isMeshStandardMaterial || W.isShadowMaterial || W.isShaderMaterial && W.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return C;
    }, this.getActiveMipmapLevel = function() {
      return E;
    }, this.getRenderTarget = function() {
      return T;
    }, this.setRenderTargetTextures = function(W, ve, we) {
      te.get(W.texture).__webglTexture = ve, te.get(W.depthTexture).__webglTexture = we;
      const Le = te.get(W);
      Le.__hasExternalTextures = !0, Le.__autoAllocateDepthBuffer = we === void 0, Le.__autoAllocateDepthBuffer || ee.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Le.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(W, ve) {
      const we = te.get(W);
      we.__webglFramebuffer = ve, we.__useDefaultFramebuffer = ve === void 0;
    }, this.setRenderTarget = function(W, ve = 0, we = 0) {
      T = W, C = ve, E = we;
      let Le = !0, Me = null, We = !1, Be = !1;
      if (W) {
        const lt = te.get(W);
        if (lt.__useDefaultFramebuffer !== void 0)
          N.bindFramebuffer(X.FRAMEBUFFER, null), Le = !1;
        else if (lt.__webglFramebuffer === void 0)
          F.setupRenderTarget(W);
        else if (lt.__hasExternalTextures)
          F.rebindTextures(W, te.get(W.texture).__webglTexture, te.get(W.depthTexture).__webglTexture);
        else if (W.depthBuffer) {
          const ft = W.depthTexture;
          if (lt.__boundDepthTexture !== ft) {
            if (ft !== null && te.has(ft) && (W.width !== ft.image.width || W.height !== ft.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            F.setupDepthRenderbuffer(W);
          }
        }
        const yt = W.texture;
        (yt.isData3DTexture || yt.isDataArrayTexture || yt.isCompressedArrayTexture) && (Be = !0);
        const bt = te.get(W).__webglFramebuffer;
        W.isWebGLCubeRenderTarget ? (Array.isArray(bt[ve]) ? Me = bt[ve][we] : Me = bt[ve], We = !0) : W.samples > 0 && F.useMultisampledRTT(W) === !1 ? Me = te.get(W).__webglMultisampledFramebuffer : Array.isArray(bt) ? Me = bt[we] : Me = bt, O.copy(W.viewport), U.copy(W.scissor), D = W.scissorTest;
      } else
        O.copy($).multiplyScalar(q).floor(), U.copy(J).multiplyScalar(q).floor(), D = se;
      if (N.bindFramebuffer(X.FRAMEBUFFER, Me) && Le && N.drawBuffers(W, Me), N.viewport(O), N.scissor(U), N.setScissorTest(D), We) {
        const lt = te.get(W.texture);
        X.framebufferTexture2D(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, X.TEXTURE_CUBE_MAP_POSITIVE_X + ve, lt.__webglTexture, we);
      } else if (Be) {
        const lt = te.get(W.texture), yt = ve || 0;
        X.framebufferTextureLayer(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, lt.__webglTexture, we || 0, yt);
      }
      w = -1;
    }, this.readRenderTargetPixels = function(W, ve, we, Le, Me, We, Be) {
      if (!(W && W.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let st = te.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && Be !== void 0 && (st = st[Be]), st) {
        N.bindFramebuffer(X.FRAMEBUFFER, st);
        try {
          const lt = W.texture, yt = lt.format, bt = lt.type;
          if (!Z.textureFormatReadable(yt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Z.textureTypeReadable(bt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ve >= 0 && ve <= W.width - Le && we >= 0 && we <= W.height - Me && X.readPixels(ve, we, Le, Me, Ve.convert(yt), Ve.convert(bt), We);
        } finally {
          const lt = T !== null ? te.get(T).__webglFramebuffer : null;
          N.bindFramebuffer(X.FRAMEBUFFER, lt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(W, ve, we, Le, Me, We, Be) {
      if (!(W && W.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let st = te.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && Be !== void 0 && (st = st[Be]), st) {
        const lt = W.texture, yt = lt.format, bt = lt.type;
        if (!Z.textureFormatReadable(yt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!Z.textureTypeReadable(bt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ve >= 0 && ve <= W.width - Le && we >= 0 && we <= W.height - Me) {
          N.bindFramebuffer(X.FRAMEBUFFER, st);
          const ft = X.createBuffer();
          X.bindBuffer(X.PIXEL_PACK_BUFFER, ft), X.bufferData(X.PIXEL_PACK_BUFFER, We.byteLength, X.STREAM_READ), X.readPixels(ve, we, Le, Me, Ve.convert(yt), Ve.convert(bt), 0);
          const Ft = T !== null ? te.get(T).__webglFramebuffer : null;
          N.bindFramebuffer(X.FRAMEBUFFER, Ft);
          const Xt = X.fenceSync(X.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return X.flush(), await JT(X, Xt, 4), X.bindBuffer(X.PIXEL_PACK_BUFFER, ft), X.getBufferSubData(X.PIXEL_PACK_BUFFER, 0, We), X.deleteBuffer(ft), X.deleteSync(Xt), We;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(W, ve = null, we = 0) {
      W.isTexture !== !0 && (ac("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ve = arguments[0] || null, W = arguments[1]);
      const Le = Math.pow(2, -we), Me = Math.floor(W.image.width * Le), We = Math.floor(W.image.height * Le), Be = ve !== null ? ve.x : 0, st = ve !== null ? ve.y : 0;
      F.setTexture2D(W, 0), X.copyTexSubImage2D(X.TEXTURE_2D, we, 0, 0, Be, st, Me, We), N.unbindTexture();
    }, this.copyTextureToTexture = function(W, ve, we = null, Le = null, Me = 0) {
      W.isTexture !== !0 && (ac("WebGLRenderer: copyTextureToTexture function signature has changed."), Le = arguments[0] || null, W = arguments[1], ve = arguments[2], Me = arguments[3] || 0, we = null);
      let We, Be, st, lt, yt, bt, ft, Ft, Xt;
      const qt = W.isCompressedTexture ? W.mipmaps[Me] : W.image;
      we !== null ? (We = we.max.x - we.min.x, Be = we.max.y - we.min.y, st = we.isBox3 ? we.max.z - we.min.z : 1, lt = we.min.x, yt = we.min.y, bt = we.isBox3 ? we.min.z : 0) : (We = qt.width, Be = qt.height, st = qt.depth || 1, lt = 0, yt = 0, bt = 0), Le !== null ? (ft = Le.x, Ft = Le.y, Xt = Le.z) : (ft = 0, Ft = 0, Xt = 0);
      const Zn = Ve.convert(ve.format), zt = Ve.convert(ve.type);
      let gt;
      ve.isData3DTexture ? (F.setTexture3D(ve, 0), gt = X.TEXTURE_3D) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? (F.setTexture2DArray(ve, 0), gt = X.TEXTURE_2D_ARRAY) : (F.setTexture2D(ve, 0), gt = X.TEXTURE_2D), X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL, ve.flipY), X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), X.pixelStorei(X.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const Vi = X.getParameter(X.UNPACK_ROW_LENGTH), Vt = X.getParameter(X.UNPACK_IMAGE_HEIGHT), Kn = X.getParameter(X.UNPACK_SKIP_PIXELS), Ds = X.getParameter(X.UNPACK_SKIP_ROWS), zn = X.getParameter(X.UNPACK_SKIP_IMAGES);
      X.pixelStorei(X.UNPACK_ROW_LENGTH, qt.width), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, qt.height), X.pixelStorei(X.UNPACK_SKIP_PIXELS, lt), X.pixelStorei(X.UNPACK_SKIP_ROWS, yt), X.pixelStorei(X.UNPACK_SKIP_IMAGES, bt);
      const qs = W.isDataArrayTexture || W.isData3DTexture, en = ve.isDataArrayTexture || ve.isData3DTexture;
      if (W.isRenderTargetTexture || W.isDepthTexture) {
        const Ci = te.get(W), ri = te.get(ve), Ti = te.get(Ci.__renderTarget), Gi = te.get(ri.__renderTarget);
        N.bindFramebuffer(X.READ_FRAMEBUFFER, Ti.__webglFramebuffer), N.bindFramebuffer(X.DRAW_FRAMEBUFFER, Gi.__webglFramebuffer);
        for (let Ei = 0; Ei < st; Ei++)
          qs && X.framebufferTextureLayer(X.READ_FRAMEBUFFER, X.COLOR_ATTACHMENT0, te.get(W).__webglTexture, Me, bt + Ei), W.isDepthTexture ? (en && X.framebufferTextureLayer(X.DRAW_FRAMEBUFFER, X.COLOR_ATTACHMENT0, te.get(ve).__webglTexture, Me, Xt + Ei), X.blitFramebuffer(lt, yt, We, Be, ft, Ft, We, Be, X.DEPTH_BUFFER_BIT, X.NEAREST)) : en ? X.copyTexSubImage3D(gt, Me, ft, Ft, Xt + Ei, lt, yt, We, Be) : X.copyTexSubImage2D(gt, Me, ft, Ft, Xt + Ei, lt, yt, We, Be);
        N.bindFramebuffer(X.READ_FRAMEBUFFER, null), N.bindFramebuffer(X.DRAW_FRAMEBUFFER, null);
      } else
        en ? W.isDataTexture || W.isData3DTexture ? X.texSubImage3D(gt, Me, ft, Ft, Xt, We, Be, st, Zn, zt, qt.data) : ve.isCompressedArrayTexture ? X.compressedTexSubImage3D(gt, Me, ft, Ft, Xt, We, Be, st, Zn, qt.data) : X.texSubImage3D(gt, Me, ft, Ft, Xt, We, Be, st, Zn, zt, qt) : W.isDataTexture ? X.texSubImage2D(X.TEXTURE_2D, Me, ft, Ft, We, Be, Zn, zt, qt.data) : W.isCompressedTexture ? X.compressedTexSubImage2D(X.TEXTURE_2D, Me, ft, Ft, qt.width, qt.height, Zn, qt.data) : X.texSubImage2D(X.TEXTURE_2D, Me, ft, Ft, We, Be, Zn, zt, qt);
      X.pixelStorei(X.UNPACK_ROW_LENGTH, Vi), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, Vt), X.pixelStorei(X.UNPACK_SKIP_PIXELS, Kn), X.pixelStorei(X.UNPACK_SKIP_ROWS, Ds), X.pixelStorei(X.UNPACK_SKIP_IMAGES, zn), Me === 0 && ve.generateMipmaps && X.generateMipmap(gt), N.unbindTexture();
    }, this.copyTextureToTexture3D = function(W, ve, we = null, Le = null, Me = 0) {
      return W.isTexture !== !0 && (ac("WebGLRenderer: copyTextureToTexture3D function signature has changed."), we = arguments[0] || null, Le = arguments[1] || null, W = arguments[2], ve = arguments[3], Me = arguments[4] || 0), ac('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(W, ve, we, Le, Me);
    }, this.initRenderTarget = function(W) {
      te.get(W).__webglFramebuffer === void 0 && F.setupRenderTarget(W);
    }, this.initTexture = function(W) {
      W.isCubeTexture ? F.setTextureCube(W, 0) : W.isData3DTexture ? F.setTexture3D(W, 0) : W.isDataArrayTexture || W.isCompressedArrayTexture ? F.setTexture2DArray(W, 0) : F.setTexture2D(W, 0), N.unbindTexture();
    }, this.resetState = function() {
      C = 0, E = 0, T = null, N.reset(), Qe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return pr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorspace = Nt._getDrawingBufferColorSpace(e), n.unpackColorSpace = Nt._getUnpackColorSpace();
  }
}
class a3 extends vn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Zi(), this.environmentIntensity = 1, this.environmentRotation = new Zi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class Sc extends Fn {
  constructor(e = null, n = 1, i = 1, s, o, a, l, c, u = ii, h = ii, d, p) {
    super(null, a, l, c, u, h, s, o, d, p), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Io extends qi {
  constructor(e, n, i, s = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class As extends oa {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Tt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const yd = /* @__PURE__ */ new he(), _d = /* @__PURE__ */ new he(), Py = /* @__PURE__ */ new rn(), $l = /* @__PURE__ */ new Zg(), qu = /* @__PURE__ */ new cu(), xp = /* @__PURE__ */ new he(), Dy = /* @__PURE__ */ new he();
class gn extends vn {
  constructor(e = new Wt(), n = new As()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [0];
      for (let s = 1, o = n.count; s < o; s++)
        yd.fromBufferAttribute(n, s - 1), _d.fromBufferAttribute(n, s), i[s] = i[s - 1], i[s] += yd.distanceTo(_d);
      e.setAttribute("lineDistance", new Ot(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const i = this.geometry, s = this.matrixWorld, o = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), qu.copy(i.boundingSphere), qu.applyMatrix4(s), qu.radius += o, e.ray.intersectsSphere(qu) === !1) return;
    Py.copy(s).invert(), $l.copy(e.ray).applyMatrix4(Py);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = this.isLineSegments ? 2 : 1, h = i.index, p = i.attributes.position;
    if (h !== null) {
      const f = Math.max(0, a.start), m = Math.min(h.count, a.start + a.count);
      for (let _ = f, g = m - 1; _ < g; _ += u) {
        const v = h.getX(_), S = h.getX(_ + 1), b = Zu(this, e, $l, c, v, S);
        b && n.push(b);
      }
      if (this.isLineLoop) {
        const _ = h.getX(m - 1), g = h.getX(f), v = Zu(this, e, $l, c, _, g);
        v && n.push(v);
      }
    } else {
      const f = Math.max(0, a.start), m = Math.min(p.count, a.start + a.count);
      for (let _ = f, g = m - 1; _ < g; _ += u) {
        const v = Zu(this, e, $l, c, _, _ + 1);
        v && n.push(v);
      }
      if (this.isLineLoop) {
        const _ = Zu(this, e, $l, c, m - 1, f);
        _ && n.push(_);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const s = n[i[0]];
      if (s !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = s.length; o < a; o++) {
          const l = s[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
}
function Zu(r, e, n, i, s, o) {
  const a = r.geometry.attributes.position;
  if (yd.fromBufferAttribute(a, s), _d.fromBufferAttribute(a, o), n.distanceSqToSegment(yd, _d, xp, Dy) > i) return;
  xp.applyMatrix4(r.matrixWorld);
  const c = e.ray.origin.distanceTo(xp);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: Dy.clone().applyMatrix4(r.matrixWorld),
      index: s,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: r
    };
}
const ky = /* @__PURE__ */ new he(), Ry = /* @__PURE__ */ new he();
class nv extends gn {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [];
      for (let s = 0, o = n.count; s < o; s += 2)
        ky.fromBufferAttribute(n, s), Ry.fromBufferAttribute(n, s + 1), i[s] = s === 0 ? 0 : i[s - 1], i[s + 1] = i[s] + ky.distanceTo(Ry);
      e.setAttribute("lineDistance", new Ot(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class l3 extends gn {
  constructor(e, n) {
    super(e, n), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class c3 extends Fn {
  constructor(e, n, i, s, o, a, l, c, u) {
    super(e, n, i, s, o, a, l, c, u), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Kt, this.magFilter = o !== void 0 ? o : Kt, this.generateMipmaps = !1;
    const h = this;
    function d() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class Ly extends Fn {
  constructor(e, n, i, s, o, a, l, c, u) {
    super(e, n, i, s, o, a, l, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Xs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, s = this.getPoint(0), o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), o += i.distanceTo(s), n.push(o), s = i;
    return this.cacheArcLengths = n, n;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, n) {
    const i = this.getLengths();
    let s = 0;
    const o = i.length;
    let a;
    n ? a = n : a = e * i[o - 1];
    let l = 0, c = o - 1, u;
    for (; l <= c; )
      if (s = Math.floor(l + (c - l) / 2), u = i[s] - a, u < 0)
        l = s + 1;
      else if (u > 0)
        c = s - 1;
      else {
        c = s;
        break;
      }
    if (s = c, i[s] === a)
      return s / (o - 1);
    const h = i[s], p = i[s + 1] - h, f = (a - h) / p;
    return (s + f) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, n) {
    let s = e - 1e-4, o = e + 1e-4;
    s < 0 && (s = 0), o > 1 && (o = 1);
    const a = this.getPoint(s), l = this.getPoint(o), c = n || (a.isVector2 ? new ct() : new he());
    return c.copy(l).sub(a).normalize(), c;
  }
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  computeFrenetFrames(e, n) {
    const i = new he(), s = [], o = [], a = [], l = new he(), c = new rn();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      s[f] = this.getTangentAt(m, new he());
    }
    o[0] = new he(), a[0] = new he();
    let u = Number.MAX_VALUE;
    const h = Math.abs(s[0].x), d = Math.abs(s[0].y), p = Math.abs(s[0].z);
    h <= u && (u = h, i.set(1, 0, 0)), d <= u && (u = d, i.set(0, 1, 0)), p <= u && i.set(0, 0, 1), l.crossVectors(s[0], i).normalize(), o[0].crossVectors(s[0], l), a[0].crossVectors(s[0], o[0]);
    for (let f = 1; f <= e; f++) {
      if (o[f] = o[f - 1].clone(), a[f] = a[f - 1].clone(), l.crossVectors(s[f - 1], s[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos(ei(s[f - 1].dot(s[f]), -1, 1));
        o[f].applyMatrix4(c.makeRotationAxis(l, m));
      }
      a[f].crossVectors(s[f], o[f]);
    }
    if (n === !0) {
      let f = Math.acos(ei(o[0].dot(o[e]), -1, 1));
      f /= e, s[0].dot(l.crossVectors(o[0], o[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        o[m].applyMatrix4(c.makeRotationAxis(s[m], f * m)), a[m].crossVectors(s[m], o[m]);
    }
    return {
      tangents: s,
      normals: o,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class iv extends Xs {
  constructor(e = 0, n = 0, i = 1, s = 1, o = 0, a = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = s, this.aStartAngle = o, this.aEndAngle = a, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, n = new ct()) {
    const i = n, s = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += s;
    for (; o > s; ) o -= s;
    o < Number.EPSILON && (a ? o = 0 : o = s), this.aClockwise === !0 && !a && (o === s ? o = -s : o = o - s);
    const l = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(l), u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = c - this.aX, f = u - this.aY;
      c = p * h - f * d + this.aX, u = p * d + f * h + this.aY;
    }
    return i.set(c, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class u3 extends iv {
  constructor(e, n, i, s, o, a) {
    super(e, n, i, i, s, o, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function sv() {
  let r = 0, e = 0, n = 0, i = 0;
  function s(o, a, l, c) {
    r = o, e = l, n = -3 * o + 3 * a - 2 * l - c, i = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, u) {
      s(a, l, u * (l - o), u * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, u, h, d) {
      let p = (a - o) / u - (l - o) / (u + h) + (l - a) / h, f = (l - a) / h - (c - a) / (h + d) + (c - l) / d;
      p *= h, f *= h, s(a, l, p, f);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return r + e * o + n * a + i * l;
    }
  };
}
const Ku = /* @__PURE__ */ new he(), bp = /* @__PURE__ */ new sv(), wp = /* @__PURE__ */ new sv(), Sp = /* @__PURE__ */ new sv();
class h3 extends Xs {
  constructor(e = [], n = !1, i = "centripetal", s = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = s;
  }
  getPoint(e, n = new he()) {
    const i = n, s = this.points, o = s.length, a = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a), c = a - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : c === 0 && l === o - 1 && (l = o - 2, c = 1);
    let u, h;
    this.closed || l > 0 ? u = s[(l - 1) % o] : (Ku.subVectors(s[0], s[1]).add(s[0]), u = Ku);
    const d = s[l % o], p = s[(l + 1) % o];
    if (this.closed || l + 2 < o ? h = s[(l + 2) % o] : (Ku.subVectors(s[o - 1], s[o - 2]).add(s[o - 1]), h = Ku), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(u.distanceToSquared(d), f), _ = Math.pow(d.distanceToSquared(p), f), g = Math.pow(p.distanceToSquared(h), f);
      _ < 1e-4 && (_ = 1), m < 1e-4 && (m = _), g < 1e-4 && (g = _), bp.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, m, _, g), wp.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, m, _, g), Sp.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, m, _, g);
    } else this.curveType === "catmullrom" && (bp.initCatmullRom(u.x, d.x, p.x, h.x, this.tension), wp.initCatmullRom(u.y, d.y, p.y, h.y, this.tension), Sp.initCatmullRom(u.z, d.z, p.z, h.z, this.tension));
    return i.set(
      bp.calc(c),
      wp.calc(c),
      Sp.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(s.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const s = this.points[n];
      e.points.push(s.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(new he().fromArray(s));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Iy(r, e, n, i, s) {
  const o = (i - e) * 0.5, a = (s - n) * 0.5, l = r * r, c = r * l;
  return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * l + o * r + n;
}
function d3(r, e) {
  const n = 1 - r;
  return n * n * e;
}
function f3(r, e) {
  return 2 * (1 - r) * r * e;
}
function p3(r, e) {
  return r * r * e;
}
function Mc(r, e, n, i) {
  return d3(r, e) + f3(r, n) + p3(r, i);
}
function m3(r, e) {
  const n = 1 - r;
  return n * n * n * e;
}
function g3(r, e) {
  const n = 1 - r;
  return 3 * n * n * r * e;
}
function v3(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function y3(r, e) {
  return r * r * r * e;
}
function Cc(r, e, n, i, s) {
  return m3(r, e) + g3(r, n) + v3(r, i) + y3(r, s);
}
class Ob extends Xs {
  constructor(e = new ct(), n = new ct(), i = new ct(), s = new ct()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = s;
  }
  getPoint(e, n = new ct()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Cc(e, s.x, o.x, a.x, l.x),
      Cc(e, s.y, o.y, a.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class $c extends Xs {
  constructor(e = new he(), n = new he(), i = new he(), s = new he()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = s;
  }
  getPoint(e, n = new he()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Cc(e, s.x, o.x, a.x, l.x),
      Cc(e, s.y, o.y, a.y, l.y),
      Cc(e, s.z, o.z, a.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Fb extends Xs {
  constructor(e = new ct(), n = new ct()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new ct()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new ct()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class _3 extends Xs {
  constructor(e = new he(), n = new he()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new he()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new he()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ub extends Xs {
  constructor(e = new ct(), n = new ct(), i = new ct()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new ct()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Mc(e, s.x, o.x, a.x),
      Mc(e, s.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class x3 extends Xs {
  constructor(e = new he(), n = new he(), i = new he()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new he()) {
    const i = n, s = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Mc(e, s.x, o.x, a.x),
      Mc(e, s.y, o.y, a.y),
      Mc(e, s.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class zb extends Xs {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, n = new ct()) {
    const i = n, s = this.points, o = (s.length - 1) * e, a = Math.floor(o), l = o - a, c = s[a === 0 ? a : a - 1], u = s[a], h = s[a > s.length - 2 ? s.length - 1 : a + 1], d = s[a > s.length - 3 ? s.length - 1 : a + 2];
    return i.set(
      Iy(l, c.x, u.x, h.x, d.x),
      Iy(l, c.y, u.y, h.y, d.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const s = this.points[n];
      e.points.push(s.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const s = e.points[n];
      this.points.push(new ct().fromArray(s));
    }
    return this;
  }
}
var Oy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: u3,
  CatmullRomCurve3: h3,
  CubicBezierCurve: Ob,
  CubicBezierCurve3: $c,
  EllipseCurve: iv,
  LineCurve: Fb,
  LineCurve3: _3,
  QuadraticBezierCurve: Ub,
  QuadraticBezierCurve3: x3,
  SplineCurve: zb
});
class rv extends Xs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Oy[i](n, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, n) {
    const i = e * this.getLength(), s = this.getCurveLengths();
    let o = 0;
    for (; o < s.length; ) {
      if (s[o] >= i) {
        const a = s[o] - i, l = this.curves[o], c = l.getLength(), u = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(u, n);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, s = this.curves.length; i < s; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let s = 0, o = this.curves; s < o.length; s++) {
      const a = o[s], l = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const h = c[u];
        i && i.equals(h) || (n.push(h), i = h);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const s = e.curves[n];
      this.curves.push(s.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const s = this.curves[n];
      e.curves.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const s = e.curves[n];
      this.curves.push(new Oy[s.type]().fromJSON(s));
    }
    return this;
  }
}
class Fy extends rv {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new ct(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const i = new Fb(this.currentPoint.clone(), new ct(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, i, s) {
    const o = new Ub(
      this.currentPoint.clone(),
      new ct(e, n),
      new ct(i, s)
    );
    return this.curves.push(o), this.currentPoint.set(i, s), this;
  }
  bezierCurveTo(e, n, i, s, o, a) {
    const l = new Ob(
      this.currentPoint.clone(),
      new ct(e, n),
      new ct(i, s),
      new ct(o, a)
    );
    return this.curves.push(l), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new zb(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, i, s, o, a) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      n + c,
      i,
      s,
      o,
      a
    ), this;
  }
  absarc(e, n, i, s, o, a) {
    return this.absellipse(e, n, i, i, s, o, a), this;
  }
  ellipse(e, n, i, s, o, a, l, c) {
    const u = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + u, n + h, i, s, o, a, l, c), this;
  }
  absellipse(e, n, i, s, o, a, l, c) {
    const u = new iv(e, n, i, s, o, a, l, c);
    if (this.curves.length > 0) {
      const d = u.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(u);
    const h = u.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class af extends Wt {
  constructor(e = 1, n = 32, i = 0, s = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: s
    }, n = Math.max(3, n);
    const o = [], a = [], l = [], c = [], u = new he(), h = new ct();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= n; d++, p += 3) {
      const f = i + d / n * s;
      u.x = e * Math.cos(f), u.y = e * Math.sin(f), a.push(u.x, u.y, u.z), l.push(0, 0, 1), h.x = (a[p] / e + 1) / 2, h.y = (a[p + 1] / e + 1) / 2, c.push(h.x, h.y);
    }
    for (let d = 1; d <= n; d++)
      o.push(d, d + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Ot(a, 3)), this.setAttribute("normal", new Ot(l, 3)), this.setAttribute("uv", new Ot(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new af(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Qn extends Wt {
  constructor(e = 1, n = 1, i = 1, s = 32, o = 1, a = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: s,
      heightSegments: o,
      openEnded: a,
      thetaStart: l,
      thetaLength: c
    };
    const u = this;
    s = Math.floor(s), o = Math.floor(o);
    const h = [], d = [], p = [], f = [];
    let m = 0;
    const _ = [], g = i / 2;
    let v = 0;
    S(), a === !1 && (e > 0 && b(!0), n > 0 && b(!1)), this.setIndex(h), this.setAttribute("position", new Ot(d, 3)), this.setAttribute("normal", new Ot(p, 3)), this.setAttribute("uv", new Ot(f, 2));
    function S() {
      const x = new he(), M = new he();
      let C = 0;
      const E = (n - e) / i;
      for (let T = 0; T <= o; T++) {
        const w = [], A = T / o, O = A * (n - e) + e;
        for (let U = 0; U <= s; U++) {
          const D = U / s, L = D * c + l, P = Math.sin(L), V = Math.cos(L);
          M.x = O * P, M.y = -A * i + g, M.z = O * V, d.push(M.x, M.y, M.z), x.set(P, E, V).normalize(), p.push(x.x, x.y, x.z), f.push(D, 1 - A), w.push(m++);
        }
        _.push(w);
      }
      for (let T = 0; T < s; T++)
        for (let w = 0; w < o; w++) {
          const A = _[w][T], O = _[w + 1][T], U = _[w + 1][T + 1], D = _[w][T + 1];
          (e > 0 || w !== 0) && (h.push(A, O, D), C += 3), (n > 0 || w !== o - 1) && (h.push(O, U, D), C += 3);
        }
      u.addGroup(v, C, 0), v += C;
    }
    function b(x) {
      const M = m, C = new ct(), E = new he();
      let T = 0;
      const w = x === !0 ? e : n, A = x === !0 ? 1 : -1;
      for (let U = 1; U <= s; U++)
        d.push(0, g * A, 0), p.push(0, A, 0), f.push(0.5, 0.5), m++;
      const O = m;
      for (let U = 0; U <= s; U++) {
        const L = U / s * c + l, P = Math.cos(L), V = Math.sin(L);
        E.x = w * V, E.y = g * A, E.z = w * P, d.push(E.x, E.y, E.z), p.push(0, A, 0), C.x = P * 0.5 + 0.5, C.y = V * 0.5 * A + 0.5, f.push(C.x, C.y), m++;
      }
      for (let U = 0; U < s; U++) {
        const D = M + U, L = O + U;
        x === !0 ? h.push(L, L + 1, D) : h.push(L + 1, L, D), T += 3;
      }
      u.addGroup(v, T, x === !0 ? 1 : 2), v += T;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Qn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ov extends Qn {
  constructor(e = 1, n = 1, i = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(0, e, n, i, s, o, a, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: s,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new ov(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class av extends Wt {
  constructor(e = [], n = [], i = 1, s = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: s
    };
    const o = [], a = [];
    l(s), u(i), h(), this.setAttribute("position", new Ot(o, 3)), this.setAttribute("normal", new Ot(o.slice(), 3)), this.setAttribute("uv", new Ot(a, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(S) {
      const b = new he(), x = new he(), M = new he();
      for (let C = 0; C < n.length; C += 3)
        f(n[C + 0], b), f(n[C + 1], x), f(n[C + 2], M), c(b, x, M, S);
    }
    function c(S, b, x, M) {
      const C = M + 1, E = [];
      for (let T = 0; T <= C; T++) {
        E[T] = [];
        const w = S.clone().lerp(x, T / C), A = b.clone().lerp(x, T / C), O = C - T;
        for (let U = 0; U <= O; U++)
          U === 0 && T === C ? E[T][U] = w : E[T][U] = w.clone().lerp(A, U / O);
      }
      for (let T = 0; T < C; T++)
        for (let w = 0; w < 2 * (C - T) - 1; w++) {
          const A = Math.floor(w / 2);
          w % 2 === 0 ? (p(E[T][A + 1]), p(E[T + 1][A]), p(E[T][A])) : (p(E[T][A + 1]), p(E[T + 1][A + 1]), p(E[T + 1][A]));
        }
    }
    function u(S) {
      const b = new he();
      for (let x = 0; x < o.length; x += 3)
        b.x = o[x + 0], b.y = o[x + 1], b.z = o[x + 2], b.normalize().multiplyScalar(S), o[x + 0] = b.x, o[x + 1] = b.y, o[x + 2] = b.z;
    }
    function h() {
      const S = new he();
      for (let b = 0; b < o.length; b += 3) {
        S.x = o[b + 0], S.y = o[b + 1], S.z = o[b + 2];
        const x = g(S) / 2 / Math.PI + 0.5, M = v(S) / Math.PI + 0.5;
        a.push(x, 1 - M);
      }
      m(), d();
    }
    function d() {
      for (let S = 0; S < a.length; S += 6) {
        const b = a[S + 0], x = a[S + 2], M = a[S + 4], C = Math.max(b, x, M), E = Math.min(b, x, M);
        C > 0.9 && E < 0.1 && (b < 0.2 && (a[S + 0] += 1), x < 0.2 && (a[S + 2] += 1), M < 0.2 && (a[S + 4] += 1));
      }
    }
    function p(S) {
      o.push(S.x, S.y, S.z);
    }
    function f(S, b) {
      const x = S * 3;
      b.x = e[x + 0], b.y = e[x + 1], b.z = e[x + 2];
    }
    function m() {
      const S = new he(), b = new he(), x = new he(), M = new he(), C = new ct(), E = new ct(), T = new ct();
      for (let w = 0, A = 0; w < o.length; w += 9, A += 6) {
        S.set(o[w + 0], o[w + 1], o[w + 2]), b.set(o[w + 3], o[w + 4], o[w + 5]), x.set(o[w + 6], o[w + 7], o[w + 8]), C.set(a[A + 0], a[A + 1]), E.set(a[A + 2], a[A + 3]), T.set(a[A + 4], a[A + 5]), M.copy(S).add(b).add(x).divideScalar(3);
        const O = g(M);
        _(C, A + 0, S, O), _(E, A + 2, b, O), _(T, A + 4, x, O);
      }
    }
    function _(S, b, x, M) {
      M < 0 && S.x === 1 && (a[b] = S.x - 1), x.x === 0 && x.z === 0 && (a[b] = M / 2 / Math.PI + 0.5);
    }
    function g(S) {
      return Math.atan2(S.z, -S.x);
    }
    function v(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new av(e.vertices, e.indices, e.radius, e.details);
  }
}
class Bb extends Fy {
  constructor(e) {
    super(e), this.uuid = ra(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, s = this.holes.length; i < s; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const s = e.holes[n];
      this.holes.push(s.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const s = this.holes[n];
      e.holes.push(s.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const s = e.holes[n];
      this.holes.push(new Fy().fromJSON(s));
    }
    return this;
  }
}
const b3 = {
  triangulate: function(r, e, n = 2) {
    const i = e && e.length, s = i ? e[0] * n : r.length;
    let o = Nb(r, 0, s, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, u, h, d, p, f;
    if (i && (o = T3(r, e, o, n)), r.length > 80 * n) {
      l = u = r[0], c = h = r[1];
      for (let m = n; m < s; m += n)
        d = r[m], p = r[m + 1], d < l && (l = d), p < c && (c = p), d > u && (u = d), p > h && (h = p);
      f = Math.max(u - l, h - c), f = f !== 0 ? 32767 / f : 0;
    }
    return Xc(o, a, n, l, c, f, 0), a;
  }
};
function Nb(r, e, n, i, s) {
  let o, a;
  if (s === U3(r, e, n, i) > 0)
    for (o = e; o < n; o += i) a = Uy(o, r[o], r[o + 1], a);
  else
    for (o = n - i; o >= e; o -= i) a = Uy(o, r[o], r[o + 1], a);
  return a && lf(a, a.next) && (qc(a), a = a.next), a;
}
function na(r, e) {
  if (!r) return r;
  e || (e = r);
  let n = r, i;
  do
    if (i = !1, !n.steiner && (lf(n, n.next) || bn(n.prev, n, n.next) === 0)) {
      if (qc(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function Xc(r, e, n, i, s, o, a) {
  if (!r) return;
  !a && o && k3(r, i, s, o);
  let l = r, c, u;
  for (; r.prev !== r.next; ) {
    if (c = r.prev, u = r.next, o ? S3(r, i, s, o) : w3(r)) {
      e.push(c.i / n | 0), e.push(r.i / n | 0), e.push(u.i / n | 0), qc(r), r = u.next, l = u.next;
      continue;
    }
    if (r = u, r === l) {
      a ? a === 1 ? (r = M3(na(r), e, n), Xc(r, e, n, i, s, o, 2)) : a === 2 && C3(r, e, n, i, s, o) : Xc(na(r), e, n, i, s, o, 1);
      break;
    }
  }
}
function w3(r) {
  const e = r.prev, n = r, i = r.next;
  if (bn(e, n, i) >= 0) return !1;
  const s = e.x, o = n.x, a = i.x, l = e.y, c = n.y, u = i.y, h = s < o ? s < a ? s : a : o < a ? o : a, d = l < c ? l < u ? l : u : c < u ? c : u, p = s > o ? s > a ? s : a : o > a ? o : a, f = l > c ? l > u ? l : u : c > u ? c : u;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= h && m.x <= p && m.y >= d && m.y <= f && Ba(s, l, o, c, a, u, m.x, m.y) && bn(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function S3(r, e, n, i) {
  const s = r.prev, o = r, a = r.next;
  if (bn(s, o, a) >= 0) return !1;
  const l = s.x, c = o.x, u = a.x, h = s.y, d = o.y, p = a.y, f = l < c ? l < u ? l : u : c < u ? c : u, m = h < d ? h < p ? h : p : d < p ? d : p, _ = l > c ? l > u ? l : u : c > u ? c : u, g = h > d ? h > p ? h : p : d > p ? d : p, v = Qm(f, m, e, n, i), S = Qm(_, g, e, n, i);
  let b = r.prevZ, x = r.nextZ;
  for (; b && b.z >= v && x && x.z <= S; ) {
    if (b.x >= f && b.x <= _ && b.y >= m && b.y <= g && b !== s && b !== a && Ba(l, h, c, d, u, p, b.x, b.y) && bn(b.prev, b, b.next) >= 0 || (b = b.prevZ, x.x >= f && x.x <= _ && x.y >= m && x.y <= g && x !== s && x !== a && Ba(l, h, c, d, u, p, x.x, x.y) && bn(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; b && b.z >= v; ) {
    if (b.x >= f && b.x <= _ && b.y >= m && b.y <= g && b !== s && b !== a && Ba(l, h, c, d, u, p, b.x, b.y) && bn(b.prev, b, b.next) >= 0) return !1;
    b = b.prevZ;
  }
  for (; x && x.z <= S; ) {
    if (x.x >= f && x.x <= _ && x.y >= m && x.y <= g && x !== s && x !== a && Ba(l, h, c, d, u, p, x.x, x.y) && bn(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function M3(r, e, n) {
  let i = r;
  do {
    const s = i.prev, o = i.next.next;
    !lf(s, o) && Vb(s, i, i.next, o) && Yc(s, o) && Yc(o, s) && (e.push(s.i / n | 0), e.push(i.i / n | 0), e.push(o.i / n | 0), qc(i), qc(i.next), i = r = o), i = i.next;
  } while (i !== r);
  return na(i);
}
function C3(r, e, n, i, s, o) {
  let a = r;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && I3(a, l)) {
        let c = Gb(a, l);
        a = na(a, a.next), c = na(c, c.next), Xc(a, e, n, i, s, o, 0), Xc(c, e, n, i, s, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== r);
}
function T3(r, e, n, i) {
  const s = [];
  let o, a, l, c, u;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * i, c = o < a - 1 ? e[o + 1] * i : r.length, u = Nb(r, l, c, i, !1), u === u.next && (u.steiner = !0), s.push(L3(u));
  for (s.sort(E3), o = 0; o < s.length; o++)
    n = A3(s[o], n);
  return n;
}
function E3(r, e) {
  return r.x - e.x;
}
function A3(r, e) {
  const n = P3(r, e);
  if (!n)
    return e;
  const i = Gb(n, r);
  return na(i, i.next), na(n, n.next);
}
function P3(r, e) {
  let n = e, i = -1 / 0, s;
  const o = r.x, a = r.y;
  do {
    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
      const p = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (p <= o && p > i && (i = p, s = n.x < n.next.x ? n : n.next, p === o))
        return s;
    }
    n = n.next;
  } while (n !== e);
  if (!s) return null;
  const l = s, c = s.x, u = s.y;
  let h = 1 / 0, d;
  n = s;
  do
    o >= n.x && n.x >= c && o !== n.x && Ba(a < u ? o : i, a, c, u, a < u ? i : o, a, n.x, n.y) && (d = Math.abs(a - n.y) / (o - n.x), Yc(n, r) && (d < h || d === h && (n.x > s.x || n.x === s.x && D3(s, n))) && (s = n, h = d)), n = n.next;
  while (n !== l);
  return s;
}
function D3(r, e) {
  return bn(r.prev, r, e.prev) < 0 && bn(e.next, r, r.next) < 0;
}
function k3(r, e, n, i) {
  let s = r;
  do
    s.z === 0 && (s.z = Qm(s.x, s.y, e, n, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== r);
  s.prevZ.nextZ = null, s.prevZ = null, R3(s);
}
function R3(r) {
  let e, n, i, s, o, a, l, c, u = 1;
  do {
    for (n = r, r = null, o = null, a = 0; n; ) {
      for (a++, i = n, l = 0, e = 0; e < u && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = u; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || n.z <= i.z) ? (s = n, n = n.nextZ, l--) : (s = i, i = i.nextZ, c--), o ? o.nextZ = s : r = s, s.prevZ = o, o = s;
      n = i;
    }
    o.nextZ = null, u *= 2;
  } while (a > 1);
  return r;
}
function Qm(r, e, n, i, s) {
  return r = (r - n) * s | 0, e = (e - i) * s | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function L3(r) {
  let e = r, n = r;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== r);
  return n;
}
function Ba(r, e, n, i, s, o, a, l) {
  return (s - a) * (e - l) >= (r - a) * (o - l) && (r - a) * (i - l) >= (n - a) * (e - l) && (n - a) * (o - l) >= (s - a) * (i - l);
}
function I3(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !O3(r, e) && // dones't intersect other edges
  (Yc(r, e) && Yc(e, r) && F3(r, e) && // locally visible
  (bn(r.prev, r, e.prev) || bn(r, e.prev, e)) || // does not create opposite-facing sectors
  lf(r, e) && bn(r.prev, r, r.next) > 0 && bn(e.prev, e, e.next) > 0);
}
function bn(r, e, n) {
  return (e.y - r.y) * (n.x - e.x) - (e.x - r.x) * (n.y - e.y);
}
function lf(r, e) {
  return r.x === e.x && r.y === e.y;
}
function Vb(r, e, n, i) {
  const s = Qu(bn(r, e, n)), o = Qu(bn(r, e, i)), a = Qu(bn(n, i, r)), l = Qu(bn(n, i, e));
  return !!(s !== o && a !== l || s === 0 && Ju(r, n, e) || o === 0 && Ju(r, i, e) || a === 0 && Ju(n, r, i) || l === 0 && Ju(n, e, i));
}
function Ju(r, e, n) {
  return e.x <= Math.max(r.x, n.x) && e.x >= Math.min(r.x, n.x) && e.y <= Math.max(r.y, n.y) && e.y >= Math.min(r.y, n.y);
}
function Qu(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function O3(r, e) {
  let n = r;
  do {
    if (n.i !== r.i && n.next.i !== r.i && n.i !== e.i && n.next.i !== e.i && Vb(n, n.next, r, e)) return !0;
    n = n.next;
  } while (n !== r);
  return !1;
}
function Yc(r, e) {
  return bn(r.prev, r, r.next) < 0 ? bn(r, e, r.next) >= 0 && bn(r, r.prev, e) >= 0 : bn(r, e, r.prev) < 0 || bn(r, r.next, e) < 0;
}
function F3(r, e) {
  let n = r, i = !1;
  const s = (r.x + e.x) / 2, o = (r.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && s < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== r);
  return i;
}
function Gb(r, e) {
  const n = new eg(r.i, r.x, r.y), i = new eg(e.i, e.x, e.y), s = r.next, o = e.prev;
  return r.next = e, e.prev = r, n.next = s, s.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function Uy(r, e, n, i) {
  const s = new eg(r, e, n);
  return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s;
}
function qc(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function eg(r, e, n) {
  this.i = r, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function U3(r, e, n, i) {
  let s = 0;
  for (let o = e, a = n - i; o < n; o += i)
    s += (r[a] - r[o]) * (r[o + 1] + r[a + 1]), a = o;
  return s;
}
class Tc {
  // calculate area of the contour polygon
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let s = n - 1, o = 0; o < n; s = o++)
      i += e[s].x * e[o].y - e[o].x * e[s].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Tc.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const i = [], s = [], o = [];
    zy(e), By(i, e);
    let a = e.length;
    n.forEach(zy);
    for (let c = 0; c < n.length; c++)
      s.push(a), a += n[c].length, By(i, n[c]);
    const l = b3.triangulate(i, s);
    for (let c = 0; c < l.length; c += 3)
      o.push(l.slice(c, c + 3));
    return o;
  }
}
function zy(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function By(r, e) {
  for (let n = 0; n < e.length; n++)
    r.push(e[n].x), r.push(e[n].y);
}
class Na extends av {
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], s = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, s, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  static fromJSON(e) {
    return new Na(e.radius, e.detail);
  }
}
class lv extends Wt {
  constructor(e = new Bb([new ct(0, 0.5), new ct(-0.5, -0.5), new ct(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], s = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let h = 0; h < e.length; h++)
        u(e[h]), this.addGroup(l, c, h), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Ot(s, 3)), this.setAttribute("normal", new Ot(o, 3)), this.setAttribute("uv", new Ot(a, 2));
    function u(h) {
      const d = s.length / 3, p = h.extractPoints(n);
      let f = p.shape;
      const m = p.holes;
      Tc.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, v = m.length; g < v; g++) {
        const S = m[g];
        Tc.isClockWise(S) === !0 && (m[g] = S.reverse());
      }
      const _ = Tc.triangulateShape(f, m);
      for (let g = 0, v = m.length; g < v; g++) {
        const S = m[g];
        f = f.concat(S);
      }
      for (let g = 0, v = f.length; g < v; g++) {
        const S = f[g];
        s.push(S.x, S.y, 0), o.push(0, 0, 1), a.push(S.x, S.y);
      }
      for (let g = 0, v = _.length; g < v; g++) {
        const S = _[g], b = S[0] + d, x = S[1] + d, M = S[2] + d;
        i.push(b, x, M), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return z3(n, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = n[e.shapes[s]];
      i.push(a);
    }
    return new lv(i, e.curveSegments);
  }
}
function z3(r, e) {
  if (e.shapes = [], Array.isArray(r))
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(r.uuid);
  return e;
}
class cf extends Wt {
  constructor(e = 1, n = 32, i = 16, s = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: s,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(a + l, Math.PI);
    let u = 0;
    const h = [], d = new he(), p = new he(), f = [], m = [], _ = [], g = [];
    for (let v = 0; v <= i; v++) {
      const S = [], b = v / i;
      let x = 0;
      v === 0 && a === 0 ? x = 0.5 / n : v === i && c === Math.PI && (x = -0.5 / n);
      for (let M = 0; M <= n; M++) {
        const C = M / n;
        d.x = -e * Math.cos(s + C * o) * Math.sin(a + b * l), d.y = e * Math.cos(a + b * l), d.z = e * Math.sin(s + C * o) * Math.sin(a + b * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), _.push(p.x, p.y, p.z), g.push(C + x, 1 - b), S.push(u++);
      }
      h.push(S);
    }
    for (let v = 0; v < i; v++)
      for (let S = 0; S < n; S++) {
        const b = h[v][S + 1], x = h[v][S], M = h[v + 1][S], C = h[v + 1][S + 1];
        (v !== 0 || a > 0) && f.push(b, x, C), (v !== i - 1 || c < Math.PI) && f.push(x, M, C);
      }
    this.setIndex(f), this.setAttribute("position", new Ot(m, 3)), this.setAttribute("normal", new Ot(_, 3)), this.setAttribute("uv", new Ot(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new cf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class zo extends Wt {
  constructor(e = 1, n = 0.4, i = 12, s = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: s,
      arc: o
    }, i = Math.floor(i), s = Math.floor(s);
    const a = [], l = [], c = [], u = [], h = new he(), d = new he(), p = new he();
    for (let f = 0; f <= i; f++)
      for (let m = 0; m <= s; m++) {
        const _ = m / s * o, g = f / i * Math.PI * 2;
        d.x = (e + n * Math.cos(g)) * Math.cos(_), d.y = (e + n * Math.cos(g)) * Math.sin(_), d.z = n * Math.sin(g), l.push(d.x, d.y, d.z), h.x = e * Math.cos(_), h.y = e * Math.sin(_), p.subVectors(d, h).normalize(), c.push(p.x, p.y, p.z), u.push(m / s), u.push(f / i);
      }
    for (let f = 1; f <= i; f++)
      for (let m = 1; m <= s; m++) {
        const _ = (s + 1) * f + m - 1, g = (s + 1) * (f - 1) + m - 1, v = (s + 1) * (f - 1) + m, S = (s + 1) * f + m;
        a.push(_, g, S), a.push(g, v, S);
      }
    this.setIndex(a), this.setAttribute("position", new Ot(l, 3)), this.setAttribute("normal", new Ot(c, 3)), this.setAttribute("uv", new Ot(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new zo(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class B3 extends si {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0;
  }
}
class N3 extends oa {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Tt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yg, this.normalScale = new ct(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class V3 extends oa {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yg, this.normalScale = new ct(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const Ny = {
  enabled: !1,
  files: {},
  add: function(r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function(r) {
    if (this.enabled !== !1)
      return this.files[r];
  },
  remove: function(r) {
    delete this.files[r];
  },
  clear: function() {
    this.files = {};
  }
};
class G3 {
  constructor(e, n, i) {
    const s = this;
    let o = !1, a = 0, l = 0, c;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = i, this.itemStart = function(h) {
      l++, o === !1 && s.onStart !== void 0 && s.onStart(h, a, l), o = !0;
    }, this.itemEnd = function(h) {
      a++, s.onProgress !== void 0 && s.onProgress(h, a, l), a === l && (o = !1, s.onLoad !== void 0 && s.onLoad());
    }, this.itemError = function(h) {
      s.onError !== void 0 && s.onError(h);
    }, this.resolveURL = function(h) {
      return c ? c(h) : h;
    }, this.setURLModifier = function(h) {
      return c = h, this;
    }, this.addHandler = function(h, d) {
      return u.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = u.indexOf(h);
      return d !== -1 && u.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = u.length; d < p; d += 2) {
        const f = u[d], m = u[d + 1];
        if (f.global && (f.lastIndex = 0), f.test(h))
          return m;
      }
      return null;
    };
  }
}
const H3 = /* @__PURE__ */ new G3();
class cv {
  constructor(e) {
    this.manager = e !== void 0 ? e : H3, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, n) {
    const i = this;
    return new Promise(function(s, o) {
      i.load(e, s, n, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
cv.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class W3 extends cv {
  constructor(e) {
    super(e);
  }
  load(e, n, i, s) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, a = Ny.get(e);
    if (a !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        n && n(a), o.manager.itemEnd(e);
      }, 0), a;
    const l = jc("img");
    function c() {
      h(), Ny.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function u(d) {
      h(), s && s(d), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", u, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l;
  }
}
class j3 extends cv {
  constructor(e) {
    super(e);
  }
  load(e, n, i, s) {
    const o = new Fn(), a = new W3(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(l) {
      o.image = l, o.needsUpdate = !0, n !== void 0 && n(o);
    }, i, s), o;
  }
}
class uf extends vn {
  constructor(e, n = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Tt(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
  }
}
const Mp = /* @__PURE__ */ new rn(), Vy = /* @__PURE__ */ new he(), Gy = /* @__PURE__ */ new he();
class uv {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ct(512, 512), this.map = null, this.mapPass = null, this.matrix = new rn(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Jg(), this._frameExtents = new ct(1, 1), this._viewportCount = 1, this._viewports = [
      new Jt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    Vy.setFromMatrixPosition(e.matrixWorld), n.position.copy(Vy), Gy.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(Gy), n.updateMatrixWorld(), Mp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mp), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Mp);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class $3 extends uv {
  constructor() {
    super(new Li(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = dl * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, o = e.distance || n.far;
    (i !== n.fov || s !== n.aspect || o !== n.far) && (n.fov = i, n.aspect = s, n.far = o, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Wr extends uf {
  constructor(e, n, i = 0, s = Math.PI / 3, o = 0, a = 2) {
    super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn(), this.distance = i, this.angle = s, this.penumbra = o, this.decay = a, this.map = null, this.shadow = new $3();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const Hy = /* @__PURE__ */ new rn(), Xl = /* @__PURE__ */ new he(), Cp = /* @__PURE__ */ new he();
class X3 extends uv {
  constructor() {
    super(new Li(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ct(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Jt(2, 1, 1, 1),
      // negative X
      new Jt(0, 1, 1, 1),
      // positive Z
      new Jt(3, 1, 1, 1),
      // negative Z
      new Jt(1, 1, 1, 1),
      // positive Y
      new Jt(3, 0, 1, 1),
      // negative Y
      new Jt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new he(1, 0, 0),
      new he(-1, 0, 0),
      new he(0, 0, 1),
      new he(0, 0, -1),
      new he(0, 1, 0),
      new he(0, -1, 0)
    ], this._cubeUps = [
      new he(0, 1, 0),
      new he(0, 1, 0),
      new he(0, 1, 0),
      new he(0, 1, 0),
      new he(0, 0, 1),
      new he(0, 0, -1)
    ];
  }
  updateMatrices(e, n = 0) {
    const i = this.camera, s = this.matrix, o = e.distance || i.far;
    o !== i.far && (i.far = o, i.updateProjectionMatrix()), Xl.setFromMatrixPosition(e.matrixWorld), i.position.copy(Xl), Cp.copy(i.position), Cp.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(Cp), i.updateMatrixWorld(), s.makeTranslation(-Xl.x, -Xl.y, -Xl.z), Hy.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Hy);
  }
}
class Yl extends uf {
  constructor(e, n, i = 0, s = 2) {
    super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = s, this.shadow = new X3();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Y3 extends uv {
  constructor() {
    super(new rf(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Va extends uf {
  constructor(e, n) {
    super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn(), this.shadow = new Y3();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Hb extends uf {
  constructor(e, n) {
    super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Wb extends Wt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class q3 {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Wy(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = Wy();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
function Wy() {
  return performance.now();
}
const jy = /* @__PURE__ */ new rn();
class hv {
  constructor(e, n, i = 0, s = 1 / 0) {
    this.ray = new Zg(e, n), this.near = i, this.far = s, this.camera = null, this.layers = new Kg(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return jy.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(jy), this;
  }
  intersectObject(e, n = !0, i = []) {
    return tg(e, this, i, n), i.sort($y), i;
  }
  intersectObjects(e, n = !0, i = []) {
    for (let s = 0, o = e.length; s < o; s++)
      tg(e[s], this, i, n);
    return i.sort($y), i;
  }
}
function $y(r, e) {
  return r.distance - e.distance;
}
function tg(r, e, n, i) {
  let s = !0;
  if (r.layers.test(e.layers) && r.raycast(e, n) === !1 && (s = !1), s === !0 && i === !0) {
    const o = r.children;
    for (let a = 0, l = o.length; a < l; a++)
      tg(o[a], e, n, !0);
  }
}
const Xy = /* @__PURE__ */ new he();
class Tp extends vn {
  constructor(e, n) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
    const i = new Wt(), s = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const u = a / c * Math.PI * 2, h = l / c * Math.PI * 2;
      s.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    i.setAttribute("position", new Ot(s, 3));
    const o = new As({ fog: !1, toneMapped: !1 });
    this.cone = new nv(i, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e), Xy.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Xy), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
class Z3 extends tt {
  constructor(e, n, i) {
    const s = new cf(n, 4, 2), o = new Gn({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(s, o), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
class K3 extends nv {
  constructor(e = 10, n = 10, i = 4473924, s = 8947848) {
    i = new Tt(i), s = new Tt(s);
    const o = n / 2, a = e / n, l = e / 2, c = [], u = [];
    for (let p = 0, f = 0, m = -l; p <= n; p++, m += a) {
      c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
      const _ = p === o ? i : s;
      _.toArray(u, f), f += 3, _.toArray(u, f), f += 3, _.toArray(u, f), f += 3, _.toArray(u, f), f += 3;
    }
    const h = new Wt();
    h.setAttribute("position", new Ot(c, 3)), h.setAttribute("color", new Ot(u, 3));
    const d = new As({ vertexColors: !0, toneMapped: !1 });
    super(h, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Yy = /* @__PURE__ */ new he(), eh = /* @__PURE__ */ new he(), qy = /* @__PURE__ */ new he();
class J3 extends vn {
  constructor(e, n, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
    let s = new Wt();
    s.setAttribute("position", new Ot([
      -n,
      n,
      0,
      n,
      n,
      0,
      n,
      -n,
      0,
      -n,
      -n,
      0,
      -n,
      n,
      0
    ], 3));
    const o = new As({ fog: !1, toneMapped: !1 });
    this.lightPlane = new gn(s, o), this.add(this.lightPlane), s = new Wt(), s.setAttribute("position", new Ot([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new gn(s, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), Yy.setFromMatrixPosition(this.light.matrixWorld), eh.setFromMatrixPosition(this.light.target.matrixWorld), qy.subVectors(eh, Yy), this.lightPlane.lookAt(eh), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(eh), this.targetLine.scale.z = qy.length();
  }
}
class Q3 extends nv {
  constructor(e = 1) {
    const n = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], s = new Wt();
    s.setAttribute("position", new Ot(n, 3)), s.setAttribute("color", new Ot(i, 3));
    const o = new As({ vertexColors: !0, toneMapped: !1 });
    super(s, o), this.type = "AxesHelper";
  }
  setColors(e, n, i) {
    const s = new Tt(), o = this.geometry.attributes.color.array;
    return s.set(e), s.toArray(o, 0), s.toArray(o, 3), s.set(n), s.toArray(o, 6), s.toArray(o, 9), s.set(i), s.toArray(o, 12), s.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class ek extends sa {
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Bg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Bg);
const Kh = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (r) => r,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (r) => 1 - Math.cos(r * Math.PI / 2),
  easeOutSine: (r) => Math.sin(r * Math.PI / 2),
  easeInOutSine: (r) => -(Math.cos(Math.PI * r) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (r) => r * r,
  easeOutQuad: (r) => 1 - (1 - r) * (1 - r),
  easeInOutQuad: (r) => r < 0.5 ? 2 * r * r : 1 - Math.pow(-2 * r + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (r) => r * r * r,
  easeOutCubic: (r) => 1 - Math.pow(1 - r, 3),
  easeInOutCubic: (r) => r < 0.5 ? 4 * r * r * r : 1 - Math.pow(-2 * r + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (r) => r * r * r * r,
  easeOutQuart: (r) => 1 - Math.pow(1 - r, 4),
  easeInOutQuart: (r) => r < 0.5 ? 8 * r * r * r * r : 1 - Math.pow(-2 * r + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (r) => r * r * r * r * r,
  easeOutQuint: (r) => 1 - Math.pow(1 - r, 5),
  easeInOutQuint: (r) => r < 0.5 ? 16 * r * r * r * r * r : 1 - Math.pow(-2 * r + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (r) => r === 0 ? 0 : Math.pow(2, 10 * r - 10),
  easeOutExpo: (r) => r === 1 ? 1 : 1 - Math.pow(2, -10 * r),
  easeInOutExpo: (r) => r === 0 ? 0 : r === 1 ? 1 : r < 0.5 ? Math.pow(2, 20 * r - 10) / 2 : (2 - Math.pow(2, -20 * r + 10)) / 2,
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (r) => 1 - Math.sqrt(1 - Math.pow(r, 2)),
  easeOutCirc: (r) => Math.sqrt(1 - Math.pow(r - 1, 2)),
  easeInOutCirc: (r) => r < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * r, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * r + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (r) => 2.70158 * r * r * r - 1.70158 * r * r,
  easeOutBack: (r) => 1 + 2.70158 * Math.pow(r - 1, 3) + 1.70158 * Math.pow(r - 1, 2),
  easeInOutBack: (r) => {
    const n = 2.5949095;
    return r < 0.5 ? Math.pow(2 * r, 2) * ((n + 1) * 2 * r - n) / 2 : (Math.pow(2 * r - 2, 2) * ((n + 1) * (r * 2 - 2) + n) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (r) => {
    const e = 2 * Math.PI / 3;
    return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * r - 10) * Math.sin((r * 10 - 10.75) * e);
  },
  easeOutElastic: (r) => {
    const e = 2 * Math.PI / 3;
    return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r * 10 - 0.75) * e) + 1;
  },
  easeInOutElastic: (r) => {
    const e = 2 * Math.PI / 4.5;
    return r === 0 ? 0 : r === 1 ? 1 : r < 0.5 ? -(Math.pow(2, 20 * r - 10) * Math.sin((20 * r - 11.125) * e)) / 2 : Math.pow(2, -20 * r + 10) * Math.sin((20 * r - 11.125) * e) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (r) => 1 - Kh.easeOutBounce(1 - r),
  easeOutBounce: (r) => r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375,
  easeInOutBounce: (r) => r < 0.5 ? (1 - Kh.easeOutBounce(1 - 2 * r)) / 2 : (1 + Kh.easeOutBounce(2 * r - 1)) / 2
};
class hu {
  constructor() {
    // Cache for recent evaluations (cleared per frame batch)
    pe(this, "cache", /* @__PURE__ */ new Map());
  }
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(e, n) {
    const i = e.id, s = this.cache.get(i);
    if (s && s.frame === n)
      return s.value;
    let o;
    return !e.animated || !e.keyframes || e.keyframes.length === 0 ? o = e.value : o = this.evaluateKeyframes(e.keyframes, n, e.value), this.cache.set(i, { frame: n, value: o }), o;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(e, n, i) {
    const s = [...e].sort((h, d) => h.frame - d.frame);
    if (n <= s[0].frame)
      return s[0].value;
    if (n >= s[s.length - 1].frame)
      return s[s.length - 1].value;
    let o = s[0], a = s[s.length - 1];
    for (let h = 0; h < s.length - 1; h++)
      if (s[h].frame <= n && s[h + 1].frame > n) {
        o = s[h], a = s[h + 1];
        break;
      }
    const l = a.frame - o.frame, c = l > 0 ? (n - o.frame) / l : 0, u = this.applyEasing(c, o.interpolation, o, a);
    return this.interpolateValue(o.value, a.value, u, i);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(e, n, i, s) {
    switch (n) {
      case "hold":
        return 0;
      case "linear":
        return e;
      case "bezier":
        return this.evaluateBezier(e, i, s);
      default:
        const o = Kh[n];
        return o ? o(e) : e;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(e, n, i) {
    const s = n.outHandle, o = i.inHandle;
    if (!(s != null && s.enabled) && !(o != null && o.enabled))
      return e;
    const a = i.frame - n.frame, l = { x: 0, y: 0 }, c = {
      x: s != null && s.enabled ? Math.min(1, Math.max(0, s.frame / a)) : 0.33,
      y: s != null && s.enabled ? s.value : 0
    }, u = {
      x: o != null && o.enabled ? Math.min(1, Math.max(0, 1 + o.frame / a)) : 0.67,
      y: o != null && o.enabled ? 1 + o.value : 1
    }, h = { x: 1, y: 1 };
    return this.solveCubicBezier(e, l.x, c.x, u.x, h.x, l.y, c.y, u.y, h.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(e, n, i, s, o, a, l, c, u) {
    let h = e;
    const d = 1e-4;
    for (let p = 0; p < 10; p++) {
      const m = this.cubicBezier(h, n, i, s, o) - e;
      if (Math.abs(m) < d)
        break;
      const _ = this.cubicBezierDerivative(h, n, i, s, o);
      if (Math.abs(_) < d)
        break;
      h -= m / _, h = Math.max(0, Math.min(1, h));
    }
    return this.cubicBezier(h, a, l, c, u);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(e, n, i, s, o) {
    const a = 1 - e;
    return a * a * a * n + 3 * a * a * e * i + 3 * a * e * e * s + e * e * e * o;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(e, n, i, s, o) {
    const a = 1 - e;
    return 3 * a * a * (i - n) + 6 * a * e * (s - i) + 3 * e * e * (o - s);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(e, n, i, s) {
    return typeof e == "number" && typeof n == "number" ? e + (n - e) * i : this.isPositionLike(e) && this.isPositionLike(n) ? this.interpolatePosition(e, n, i) : typeof e == "string" && typeof n == "string" && e.startsWith("#") && n.startsWith("#") ? this.interpolateColor(e, n, i) : Array.isArray(e) && Array.isArray(n) ? this.interpolateArray(e, n, i) : i < 0.5 ? e : n;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(e) {
    return e !== null && typeof e == "object" && "x" in e && "y" in e;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(e, n, i) {
    const s = {
      x: e.x + (n.x - e.x) * i,
      y: e.y + (n.y - e.y) * i
    };
    return ("z" in e || "z" in n) && (s.z = (e.z ?? 0) + ((n.z ?? 0) - (e.z ?? 0)) * i), s;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(e, n, i) {
    const s = this.hexToRGB(e), o = this.hexToRGB(n), a = Math.round(s.r + (o.r - s.r) * i), l = Math.round(s.g + (o.g - s.g) * i), c = Math.round(s.b + (o.b - s.b) * i);
    return this.rgbToHex(a, l, c);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(e, n, i) {
    const s = Math.max(e.length, n.length), o = [];
    for (let a = 0; a < s; a++) {
      const l = e[a] ?? 0, c = n[a] ?? 0;
      o.push(l + (c - l) * i);
    }
    return o;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(e) {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? {
      r: parseInt(n[1], 16),
      g: parseInt(n[2], 16),
      b: parseInt(n[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(e, n, i) {
    return "#" + [e, n, i].map((s) => Math.max(0, Math.min(255, s)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}
const Ec = Math.PI, xd = 1.70158, th = xd * 1.525, Zy = xd + 1, Ky = 2 * Ec / 3, Jy = 2 * Ec / 4.5, Jo = {
  // Linear - no easing
  linear: (r) => r,
  // Sine easing
  easeInSine: (r) => 1 - Math.cos(r * Ec / 2),
  easeOutSine: (r) => Math.sin(r * Ec / 2),
  easeInOutSine: (r) => -(Math.cos(Ec * r) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (r) => r * r,
  easeOutQuad: (r) => 1 - (1 - r) * (1 - r),
  easeInOutQuad: (r) => r < 0.5 ? 2 * r * r : 1 - Math.pow(-2 * r + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (r) => r * r * r,
  easeOutCubic: (r) => 1 - Math.pow(1 - r, 3),
  easeInOutCubic: (r) => r < 0.5 ? 4 * r * r * r : 1 - Math.pow(-2 * r + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (r) => r * r * r * r,
  easeOutQuart: (r) => 1 - Math.pow(1 - r, 4),
  easeInOutQuart: (r) => r < 0.5 ? 8 * r * r * r * r : 1 - Math.pow(-2 * r + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (r) => r * r * r * r * r,
  easeOutQuint: (r) => 1 - Math.pow(1 - r, 5),
  easeInOutQuint: (r) => r < 0.5 ? 16 * r * r * r * r * r : 1 - Math.pow(-2 * r + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (r) => r === 0 ? 0 : Math.pow(2, 10 * r - 10),
  easeOutExpo: (r) => r === 1 ? 1 : 1 - Math.pow(2, -10 * r),
  easeInOutExpo: (r) => r === 0 ? 0 : r === 1 ? 1 : r < 0.5 ? Math.pow(2, 20 * r - 10) / 2 : (2 - Math.pow(2, -20 * r + 10)) / 2,
  // Circ (circular)
  easeInCirc: (r) => 1 - Math.sqrt(1 - Math.pow(r, 2)),
  easeOutCirc: (r) => Math.sqrt(1 - Math.pow(r - 1, 2)),
  easeInOutCirc: (r) => r < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * r, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * r + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (r) => Zy * r * r * r - xd * r * r,
  easeOutBack: (r) => 1 + Zy * Math.pow(r - 1, 3) + xd * Math.pow(r - 1, 2),
  easeInOutBack: (r) => r < 0.5 ? Math.pow(2 * r, 2) * ((th + 1) * 2 * r - th) / 2 : (Math.pow(2 * r - 2, 2) * ((th + 1) * (r * 2 - 2) + th) + 2) / 2,
  // Elastic
  easeInElastic: (r) => r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * r - 10) * Math.sin((r * 10 - 10.75) * Ky),
  easeOutElastic: (r) => r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r * 10 - 0.75) * Ky) + 1,
  easeInOutElastic: (r) => r === 0 ? 0 : r === 1 ? 1 : r < 0.5 ? -(Math.pow(2, 20 * r - 10) * Math.sin((20 * r - 11.125) * Jy)) / 2 : Math.pow(2, -20 * r + 10) * Math.sin((20 * r - 11.125) * Jy) / 2 + 1,
  // Bounce
  easeOutBounce: (r) => r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375,
  easeInBounce: (r) => 1 - Jo.easeOutBounce(1 - r),
  easeInOutBounce: (r) => r < 0.5 ? (1 - Jo.easeOutBounce(1 - 2 * r)) / 2 : (1 + Jo.easeOutBounce(2 * r - 1)) / 2
};
function tk(r) {
  return r in Jo ? Jo[r] : Jo.linear;
}
function nk(r, e) {
  if (typeof r == "number" && typeof e == "number")
    return e - r;
  if (typeof r == "object" && r !== null && "x" in r && "y" in r && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - r.x, i = e.y - r.y;
    return Math.sqrt(n * n + i * i) || 1;
  }
  return 1;
}
function fn(r, e) {
  if (!r.animated || r.keyframes.length === 0)
    return r.value;
  const n = r.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  let i = n[0], s = n[1];
  for (let u = 0; u < n.length - 1; u++)
    if (e >= n[u].frame && e <= n[u + 1].frame) {
      i = n[u], s = n[u + 1];
      break;
    }
  const o = s.frame - i.frame, a = e - i.frame;
  let l = o > 0 ? a / o : 0;
  const c = i.interpolation || "linear";
  if (c === "hold")
    return i.value;
  if (c === "bezier") {
    const u = nk(i.value, s.value);
    l = ik(l, i.outHandle, s.inHandle, o, u);
  } else c === "linear" || (c in Jo ? l = tk(c)(l) : console.warn(`Unknown interpolation type: ${c}, using linear`));
  return rk(i.value, s.value, l);
}
function ik(r, e, n, i = 1, s = 1) {
  if (!e.enabled && !n.enabled)
    return r;
  const o = i > 0 ? Math.abs(e.frame) / i : 0.33, a = s !== 0 ? e.value / s : 0.33, l = i > 0 ? 1 - Math.abs(n.frame) / i : 0.67, c = s !== 0 ? 1 - n.value / s : 0.67;
  let u = r;
  for (let h = 0; h < 8; h++) {
    const d = bd(u, 0, o, l, 1), p = sk(u, 0, o, l, 1);
    if (Math.abs(p) < 1e-6) break;
    const f = d - r;
    u -= f / p, u = Math.max(0, Math.min(1, u));
  }
  return bd(u, 0, a, c, 1);
}
function bd(r, e, n, i, s) {
  const o = 1 - r;
  return o * o * o * e + 3 * o * o * r * n + 3 * o * r * r * i + r * r * r * s;
}
function sk(r, e, n, i, s) {
  const o = 1 - r;
  return 3 * o * o * (n - e) + 6 * o * r * (i - n) + 3 * r * r * (s - i);
}
function rk(r, e, n) {
  if (typeof r == "number" && typeof e == "number")
    return r + (e - r) * n;
  if (typeof r == "object" && r !== null && typeof e == "object" && e !== null && "x" in r && "y" in r && "x" in e && "y" in e) {
    const i = r, s = e, o = {
      x: i.x + (s.x - i.x) * n,
      y: i.y + (s.y - i.y) * n
    };
    return "z" in i && "z" in s ? o.z = i.z + (s.z - i.z) * n : "z" in i ? o.z = i.z * (1 - n) : "z" in s && (o.z = s.z * n), o;
  }
  return typeof r == "string" && typeof e == "string" && r.startsWith("#") && e.startsWith("#") ? ok(r, e, n) : n < 0.5 ? r : e;
}
function ok(r, e, n) {
  const i = parseInt(r.slice(1, 3), 16), s = parseInt(r.slice(3, 5), 16), o = parseInt(r.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(i + (a - i) * n), h = Math.round(s + (l - s) * n), d = Math.round(o + (c - o) * n);
  return `#${u.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}`;
}
const ak = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, wd = ak;
function lk(r, e, n) {
  const i = e.x, s = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: bd(r, 0, i, o, 1),
    y: bd(r, 0, s, a, 1)
  };
}
function ck(r, e) {
  const n = Math.max(0, Math.min(1, r));
  return lk(n, e.outHandle, e.inHandle).y;
}
const jb = /* @__PURE__ */ new Map();
function Oa(r, e) {
  jb.set(r, e);
}
function uk(r, e) {
  const n = {};
  for (const [i, s] of Object.entries(r.parameters)) {
    const o = s;
    n[i] = fn(o, e);
  }
  return n;
}
function $b(r, e, n) {
  const i = document.createElement("canvas");
  i.width = e.width, i.height = e.height;
  const s = i.getContext("2d");
  s.drawImage(e, 0, 0);
  let o = {
    canvas: i,
    ctx: s
  };
  for (const a of r) {
    if (!a.enabled)
      continue;
    const l = jb.get(a.effectKey);
    if (!l) {
      console.warn(`No renderer registered for effect: ${a.effectKey}`);
      continue;
    }
    const c = uk(a, n);
    try {
      o = l(o, c);
    } catch (u) {
      console.error(`Error applying effect ${a.name}:`, u);
    }
  }
  return o;
}
function bl(r) {
  const e = document.createElement("canvas");
  e.width = r.width, e.height = r.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function Xb(r) {
  return r.some((e) => e.enabled);
}
class Ps {
  constructor(e) {
    /** Unique layer identifier */
    pe(this, "id");
    /** Layer type */
    pe(this, "type");
    /** The Three.js group containing this layer's content */
    pe(this, "group");
    /** Keyframe evaluator for animated properties */
    pe(this, "evaluator");
    /** Layer visibility */
    pe(this, "visible");
    /** Layer locked state */
    pe(this, "locked");
    /** In point (start frame) */
    pe(this, "inPoint");
    /** Out point (end frame) */
    pe(this, "outPoint");
    /** Layer opacity (0-100) */
    pe(this, "opacity");
    /** Layer transform */
    pe(this, "transform");
    /** 3D layer flag */
    pe(this, "threeD");
    /** Blend mode */
    pe(this, "blendMode");
    /** Parent layer ID (for parenting hierarchy) */
    pe(this, "parentId");
    /** Reference to parent layer (set by LayerManager) */
    pe(this, "parentLayer", null);
    /** Driven values override (from property drivers/expressions) */
    pe(this, "drivenValues", /* @__PURE__ */ new Map());
    /** Audio reactive values (from audio analysis mapping) */
    pe(this, "audioReactiveValues", /* @__PURE__ */ new Map());
    /** Effects stack for this layer */
    pe(this, "effects", []);
    /** Source canvas for effect processing (lazy initialized) */
    pe(this, "effectSourceCanvas", null);
    /** Flag to track if effects need processing */
    pe(this, "effectsDirty", !1);
    this.id = e.id, this.type = e.type, this.group = new ts(), this.group.name = `layer_${this.id}`, this.group.userData.layerId = this.id, this.group.userData.layerType = this.type, this.evaluator = new hu(), this.visible = e.visible, this.locked = e.locked, this.inPoint = e.inPoint, this.outPoint = e.outPoint, this.opacity = e.opacity, this.transform = e.transform, this.threeD = e.threeD ?? !1, this.blendMode = e.blendMode ?? "normal", this.parentId = e.parentId ?? null, this.effects = e.effects ?? [];
  }
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    this.blendMode !== "normal" && this.applyBlendMode(this.blendMode);
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(e) {
    const n = e >= this.inPoint && e <= this.outPoint;
    if (this.group.visible = this.visible && n, !this.group.visible)
      return;
    let i = this.evaluator.evaluate(this.opacity, e);
    i = this.getDrivenOrBase("opacity", i);
    const s = this.applyAudioModulation(i, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(s), this.evaluateTransform(e), this.onEvaluateFrame(e);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(e) {
    const n = this.evaluator.evaluate(this.transform.position, e);
    let i = this.getDrivenOrBase("transform.position.x", n.x), s = this.getDrivenOrBase("transform.position.y", n.y);
    const o = this.getDrivenOrBase("transform.position.z", n.z ?? 0);
    i = this.applyAudioModulation(i, "layer.x", "add"), s = this.applyAudioModulation(s, "layer.y", "add");
    const a = { x: i, y: s, z: o }, l = this.evaluator.evaluate(this.transform.scale, e);
    let c = this.getDrivenOrBase("transform.scale.x", l.x ?? 100), u = this.getDrivenOrBase("transform.scale.y", l.y ?? 100);
    const h = this.getDrivenOrBase("transform.scale.z", l.z ?? 100), d = this.getAudioReactiveValue("layer.scale");
    if (d !== 0) {
      const b = 0.5 + d;
      c *= b, u *= b;
    }
    const p = { x: c, y: u, z: h }, f = this.evaluator.evaluate(this.transform.anchorPoint, e), m = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", f.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", f.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", f.z ?? 0)
    };
    let _ = 0, g = 0, v = 0;
    if (this.threeD) {
      const b = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, e) : 0;
      g = this.getDrivenOrBase("transform.rotationX", b);
      const x = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, e) : 0;
      v = this.getDrivenOrBase("transform.rotationY", x);
      const M = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, e) : 0;
      _ = this.getDrivenOrBase("transform.rotationZ", M);
    } else {
      const b = this.evaluator.evaluate(this.transform.rotation, e);
      _ = this.getDrivenOrBase("transform.rotation", b);
    }
    const S = this.getAudioReactiveValue("layer.rotation");
    S !== 0 && (_ += S * 360), this.applyTransform({
      position: {
        x: a.x,
        y: a.y,
        z: a.z
      },
      rotation: {
        x: g,
        y: v,
        z: _
      },
      scale: {
        x: p.x / 100,
        y: p.y / 100,
        z: p.z / 100
      },
      anchorPoint: {
        x: m.x,
        y: m.y,
        z: m.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(e) {
    const { position: n, rotation: i, scale: s, anchorPoint: o } = e;
    this.group.position.set(
      n.x - o.x,
      -(n.y - o.y),
      // Negate for screen coords
      n.z - o.z
    ), this.group.rotation.set(
      En.degToRad(i.x),
      En.degToRad(i.y),
      En.degToRad(-i.z)
    ), this.group.scale.set(s.x, s.y, s.z), this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(e) {
    const n = Math.max(0, Math.min(100, e)) / 100;
    this.group.traverse((i) => {
      if (i instanceof tt && i.material) {
        const s = i.material;
        "opacity" in s && (s.opacity = n, s.transparent = n < 1, s.needsUpdate = !0);
      }
    });
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(e) {
    e.visible !== void 0 && (this.visible = e.visible, this.group.visible = this.visible), e.locked !== void 0 && (this.locked = e.locked), e.inPoint !== void 0 && (this.inPoint = e.inPoint), e.outPoint !== void 0 && (this.outPoint = e.outPoint), e.opacity !== void 0 && (this.opacity = e.opacity), e.transform !== void 0 && (this.transform = e.transform), e.threeD !== void 0 && (this.threeD = e.threeD), e.blendMode !== void 0 && (this.blendMode = e.blendMode, this.applyBlendMode(this.blendMode)), e.effects !== void 0 && this.setEffects(e.effects), this.onUpdate(e);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(e) {
    this.visible = e, this.group.visible = e;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(e) {
    this.drivenValues = e;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(e, n) {
    return this.drivenValues.get(e) ?? n;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(e) {
    this.audioReactiveValues = e;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(e) {
    return this.audioReactiveValues.get(e) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(e, n, i = "add", s = {}) {
    const o = this.getAudioReactiveValue(n);
    if (o === 0) return e;
    let a;
    switch (i) {
      case "multiply":
        a = e * (0.5 + o);
        break;
      case "replace":
        a = o;
        break;
      case "add":
      default:
        a = e + o * 100;
        break;
    }
    return s.min !== void 0 && (a = Math.max(s.min, a)), s.max !== void 0 && (a = Math.min(s.max, a)), a;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(e) {
    this.effects = e, this.effectsDirty = !0;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return Xb(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(e) {
    if (!this.hasEnabledEffects())
      return null;
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    try {
      return $b(this.effects, n, e).canvas;
    } catch (i) {
      return console.error(`[BaseLayer] Error processing effects for layer ${this.id}:`, i), null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(e) {
  }
  /**
   * Called after frame evaluation to apply effects
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(e) {
    if (!this.hasEnabledEffects())
      return;
    const n = this.processEffects(e);
    n && this.applyProcessedEffects(n);
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(e) {
    this.parentLayer && this.parentLayer.getObject().remove(this.group), this.parentLayer = e, e && e.getObject().add(this.group);
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(e) {
    this.group.traverse((n) => {
      if (n instanceof tt && n.material) {
        const i = n.material;
        this.setMaterialBlendMode(i, e), i.needsUpdate = !0;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(e, n) {
    switch (e.blending = xs, e.blendEquation = vs, e.blendSrc = md, e.blendDst = Hc, e.blendEquationAlpha = vs, e.blendSrcAlpha = or, e.blendDstAlpha = Hc, n) {
      case "normal":
        e.blending = xs;
        break;
      case "add":
        e.blending = Gc;
        break;
      case "multiply":
        e.blending = Ja;
        break;
      case "screen":
        e.blending = Fo, e.blendEquation = vs, e.blendSrc = or, e.blendDst = pm;
        break;
      case "overlay":
        e.blending = Ja;
        break;
      case "soft-light":
        e.blending = xs;
        break;
      case "hard-light":
        e.blending = Ja;
        break;
      case "color-dodge":
        e.blending = Gc;
        break;
      case "color-burn":
        e.blending = fm;
        break;
      case "difference":
        e.blending = Fo, e.blendEquation = Qx, e.blendSrc = or, e.blendDst = or;
        break;
      case "exclusion":
        e.blending = Fo, e.blendEquation = vs, e.blendSrc = nb, e.blendDst = pm;
        break;
      case "darken":
        e.blending = Fo, e.blendEquation = eb, e.blendSrc = or, e.blendDst = or;
        break;
      case "lighten":
        e.blending = Fo, e.blendEquation = tb, e.blendSrc = or, e.blendDst = or;
        break;
      default:
        e.blending = xs;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const e = new mo();
    return e.setFromObject(this.group), e;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const e = this.getBoundingBox(), n = new he();
    return e.getCenter(n), n;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((e) => {
      var n;
      e instanceof tt && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => i.dispose()) : e.material && e.material.dispose());
    }), this.group.clear(), this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}
class hk extends Ps {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Video elements
    pe(this, "videoElement", null);
    pe(this, "videoTexture", null);
    pe(this, "mesh", null);
    pe(this, "material", null);
    // Video data
    pe(this, "videoData");
    pe(this, "assetRef", null);
    // Metadata (populated after video loads)
    pe(this, "metadata", null);
    // Animation evaluator
    pe(this, "videoEvaluator");
    // Playback state
    pe(this, "lastEvaluatedFrame", -1);
    pe(this, "isPlaying", !1);
    // Callbacks for composition auto-resize
    pe(this, "onMetadataLoaded");
    // Composition FPS for time calculation
    pe(this, "compositionFPS", 30);
    // Canvas for effect processing
    pe(this, "effectCanvas", null);
    pe(this, "effectCanvasCtx", null);
    this.resources = i, this.videoEvaluator = new hu(), this.videoData = this.extractVideoData(n), this.createPlaceholderMesh(), this.videoData.assetId && this.loadVideo(this.videoData.assetId), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(n) {
    const i = n.data;
    return {
      assetId: (i == null ? void 0 : i.assetId) ?? null,
      loop: (i == null ? void 0 : i.loop) ?? !1,
      pingPong: (i == null ? void 0 : i.pingPong) ?? !1,
      startTime: (i == null ? void 0 : i.startTime) ?? 0,
      endTime: i == null ? void 0 : i.endTime,
      speed: (i == null ? void 0 : i.speed) ?? 1,
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      frameBlending: (i == null ? void 0 : i.frameBlending) ?? "none",
      audioEnabled: (i == null ? void 0 : i.audioEnabled) ?? !0,
      audioLevel: (i == null ? void 0 : i.audioLevel) ?? 100,
      posterFrame: (i == null ? void 0 : i.posterFrame) ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const n = new yn(1, 1);
    this.material = new Gn({
      color: 3355443,
      transparent: !0,
      side: Pn
    }), this.mesh = new tt(n, this.material), this.mesh.name = `video_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(n) {
    const i = this.resources.getAsset(n);
    if (!i || i.type !== "video") {
      console.warn(`[VideoLayer] Asset ${n} not found or not a video`);
      return;
    }
    this.assetRef = i, this.videoData.assetId = n, this.videoElement = document.createElement("video"), this.videoElement.crossOrigin = "anonymous", this.videoElement.playsInline = !0, this.videoElement.muted = !this.videoData.audioEnabled, this.videoElement.loop = !1, this.videoElement.preload = "auto", i.data && (this.videoElement.src = i.data), await this.waitForMetadata(), this.createVideoTexture(), this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((n, i) => {
      if (!this.videoElement) {
        i(new Error("No video element"));
        return;
      }
      const s = () => {
        this.extractMetadata(), a(), n();
      }, o = (l) => {
        a(), i(new Error(`Video load error: ${l}`));
      }, a = () => {
        var l, c;
        (l = this.videoElement) == null || l.removeEventListener("loadedmetadata", s), (c = this.videoElement) == null || c.removeEventListener("error", o);
      };
      this.videoElement.addEventListener("loadedmetadata", s), this.videoElement.addEventListener("error", o), this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    var l, c;
    if (!this.videoElement) return;
    const n = this.videoElement.duration, i = this.videoElement.videoWidth, s = this.videoElement.videoHeight, o = ((l = this.assetRef) == null ? void 0 : l.fps) ?? 30, a = Math.ceil(n * o);
    this.metadata = {
      duration: n,
      frameCount: a,
      fps: o,
      width: i,
      height: s,
      hasAudio: this.hasAudioTrack()
    }, this.assetRef && (this.assetRef.duration = n, this.assetRef.frameCount = a, this.assetRef.fps = o, this.assetRef.hasAudio = this.metadata.hasAudio), (c = this.onMetadataLoaded) == null || c.call(this, this.metadata), console.log(`[VideoLayer] Loaded: ${i}x${s}, ${a} frames @ ${o}fps, ${n.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return !1;
    const n = this.videoElement.audioTracks;
    return n ? n.length > 0 : !0;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    !this.videoElement || !this.metadata || (this.videoTexture = new c3(this.videoElement), this.videoTexture.minFilter = Kt, this.videoTexture.magFilter = Kt, this.videoTexture.format = fi, this.videoTexture.colorSpace = An, this.material && (this.material.map = this.videoTexture, this.material.color.setHex(16777215), this.material.needsUpdate = !0), this.resizeMesh(this.metadata.width, this.metadata.height));
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new yn(n, i));
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(n) {
    if (!this.videoElement || !this.metadata) return;
    const i = this.calculateVideoTime(n), s = Math.max(0, Math.min(i, this.videoElement.duration));
    this.videoElement.currentTime = s;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(n) {
    var l;
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && ((l = this.videoData.timeRemap) != null && l.animated))
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, n);
    const i = this.compositionFPS;
    let o = n / i * this.videoData.speed;
    o += this.videoData.startTime;
    const a = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && a > 0) {
      if (this.videoData.pingPong) {
        const c = Math.floor(o / a), u = o % a;
        o = c % 2 === 0 ? u : a - u;
      } else
        o = o % a;
      o += this.videoData.startTime;
    }
    return o;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(n) {
    this.videoData.audioLevel = n, this.videoElement && (this.videoElement.volume = Math.max(0, Math.min(1, n / 100)));
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(n) {
    this.videoData.audioEnabled = n, this.videoElement && (this.videoElement.muted = !n);
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.compositionFPS = n;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(n) {
    this.onMetadataLoaded = n, this.metadata && n(this.metadata);
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(n) {
    this.videoData.loop = n;
  }
  setPingPong(n) {
    this.videoData.pingPong = n;
  }
  setSpeed(n) {
    this.videoData.speed = n, this.videoElement && (this.videoElement.playbackRate = n);
  }
  setStartTime(n) {
    this.videoData.startTime = n;
  }
  setEndTime(n) {
    this.videoData.endTime = n;
  }
  setFrameBlending(n) {
    this.videoData.frameBlending = n;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata)
      return null;
    const n = this.metadata.width, i = this.metadata.height;
    return (!this.effectCanvas || this.effectCanvas.width !== n || this.effectCanvas.height !== i) && (this.effectCanvas = document.createElement("canvas"), this.effectCanvas.width = n, this.effectCanvas.height = i, this.effectCanvasCtx = this.effectCanvas.getContext("2d")), this.effectCanvasCtx ? (this.effectCanvasCtx.clearRect(0, 0, n, i), this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, n, i), this.effectCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    if (!this.material || !this.metadata) return;
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Kt,
        magFilter: Kt,
        generateMipmaps: !1,
        colorSpace: An
      }
    );
    this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    n !== this.lastEvaluatedFrame && (this.lastEvaluatedFrame = n, this.seekToFrame(n), this.videoTexture && (this.videoTexture.needsUpdate = !0), this.hasEnabledEffects() ? this.evaluateEffects(n) : this.material && this.videoTexture && (this.material.map = this.videoTexture, this.material.needsUpdate = !0));
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.assetId !== void 0 && i.assetId !== this.videoData.assetId && (i.assetId ? this.loadVideo(i.assetId) : this.clearVideo()), i.loop !== void 0 && this.setLoop(i.loop), i.pingPong !== void 0 && this.setPingPong(i.pingPong), i.speed !== void 0 && this.setSpeed(i.speed), i.startTime !== void 0 && this.setStartTime(i.startTime), i.endTime !== void 0 && this.setEndTime(i.endTime), i.frameBlending !== void 0 && this.setFrameBlending(i.frameBlending), i.audioEnabled !== void 0 && this.setAudioEnabled(i.audioEnabled), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel));
  }
  /**
   * Clear current video
   */
  clearVideo() {
    this.videoElement && (this.videoElement.pause(), this.videoElement.src = "", this.videoElement = null), this.videoTexture && (this.videoTexture.dispose(), this.videoTexture = null), this.material && (this.material.map = null, this.material.color.setHex(3355443)), this.metadata = null, this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo(), this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh));
  }
}
async function dk(r) {
  return new Promise((e, n) => {
    const i = document.createElement("video");
    i.crossOrigin = "anonymous", i.preload = "metadata";
    const s = () => {
      i.removeEventListener("loadedmetadata", o), i.removeEventListener("error", a), URL.revokeObjectURL(i.src);
    }, o = () => {
      const l = {
        duration: i.duration,
        frameCount: Math.ceil(i.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: i.videoWidth,
        height: i.videoHeight,
        hasAudio: !0
        // Assume true
      };
      s(), e(l);
    }, a = () => {
      s(), n(new Error("Failed to load video metadata"));
    };
    i.addEventListener("loadedmetadata", o), i.addEventListener("error", a), typeof r == "string" ? i.src = r : i.src = URL.createObjectURL(r);
  });
}
function fk(r, e = 16) {
  const n = Math.round(r.width / 8) * 8, i = Math.round(r.height / 8) * 8, s = Math.ceil(r.duration * e);
  return { width: n, height: i, frameCount: s };
}
const pk = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function Yb(r, e, n) {
  const i = e / 2, s = n / 2;
  return {
    id: r,
    name: "Camera 1",
    type: "two-node",
    position: { x: i, y: s, z: -1500 },
    pointOfInterest: { x: i, y: s, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function qb() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function mk() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function Mt(r, e, n) {
  return { x: r, y: e, z: n };
}
function Lt(r, e) {
  return { x: r.x + e.x, y: r.y + e.y, z: r.z + e.z };
}
function dv(r, e) {
  return { x: r.x - e.x, y: r.y - e.y, z: r.z - e.z };
}
function Ut(r, e) {
  return { x: r.x * e, y: r.y * e, z: r.z * e };
}
function gk(r) {
  return Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z);
}
function xr(r) {
  const e = gk(r);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: r.x / e, y: r.y / e, z: r.z / e };
}
function pl(r, e) {
  return {
    x: r.y * e.z - r.z * e.y,
    y: r.z * e.x - r.x * e.z,
    z: r.x * e.y - r.y * e.x
  };
}
function Ep(r, e) {
  return r.x * e.x + r.y * e.y + r.z * e.z;
}
function vk(r, e, n, i) {
  const s = new Float32Array(16), o = 1 / Math.tan(r / 2), a = 1 / (n - i);
  return s[0] = o / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = o, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (i + n) * a, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * i * n * a, s[15] = 0, { elements: s };
}
function yk(r, e, n, i, s, o) {
  const a = new Float32Array(16), l = 1 / (e - r), c = 1 / (i - n), u = 1 / (o - s);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * c, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * u, a[11] = 0, a[12] = -(e + r) * l, a[13] = -(i + n) * c, a[14] = -10001 * u, a[15] = 1, { elements: a };
}
function Is(r, e, n) {
  const i = new Float32Array(16);
  let s = r.x - e.x, o = r.y - e.y, a = r.z - e.z, l = Math.sqrt(s * s + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, s *= l, o *= l, a *= l);
  let c = n.y * a - n.z * o, u = n.z * s - n.x * a, h = n.x * o - n.y * s;
  l = Math.sqrt(c * c + u * u + h * h), l === 0 ? (c = 0, u = 0, h = 0) : (l = 1 / l, c *= l, u *= l, h *= l);
  let d = o * h - a * u, p = a * c - s * h, f = s * u - o * c;
  return l = Math.sqrt(d * d + p * p + f * f), l === 0 ? (d = 0, p = 0, f = 0) : (l = 1 / l, d *= l, p *= l, f *= l), i[0] = c, i[4] = u, i[8] = h, i[12] = -Ep({ x: c, y: u, z: h }, r), i[1] = d, i[5] = p, i[9] = f, i[13] = -Ep({ x: d, y: p, z: f }, r), i[2] = s, i[6] = o, i[10] = a, i[14] = -Ep({ x: s, y: o, z: a }, r), i[3] = 0, i[7] = 0, i[11] = 0, i[15] = 1, { elements: i };
}
function _k(r, e) {
  const n = r.elements, i = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / i,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / i,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / i
  };
}
function du(r, e) {
  return 2 * Math.atan(e / (2 * r));
}
function xk(r, e) {
  return e / (2 * Math.tan(r / 2));
}
function Zc(r, e, n) {
  if (!e || e.length === 0)
    return {
      position: r.position,
      rotation: r.orientation,
      focalLength: r.focalLength,
      zoom: r.zoom,
      focusDistance: r.depthOfField.focusDistance
    };
  let i = null, s = null;
  for (const _ of e)
    _.frame <= n && (i = _), _.frame >= n && !s && (s = _);
  if (!i && !s)
    return {
      position: r.position,
      rotation: r.orientation,
      focalLength: r.focalLength,
      zoom: r.zoom,
      focusDistance: r.depthOfField.focusDistance
    };
  i || (i = s), s || (s = i);
  const o = (_) => (_ == null ? void 0 : _.position) ?? r.position, a = (_) => (_ == null ? void 0 : _.orientation) ?? r.orientation, l = (_) => (_ == null ? void 0 : _.focalLength) ?? r.focalLength, c = (_) => (_ == null ? void 0 : _.zoom) ?? r.zoom, u = (_) => (_ == null ? void 0 : _.focusDistance) ?? r.depthOfField.focusDistance;
  if (i.frame === s.frame)
    return {
      position: o(i),
      rotation: a(i),
      focalLength: l(i),
      zoom: c(i),
      focusDistance: u(i)
    };
  const h = (n - i.frame) / (s.frame - i.frame), d = o(i), p = o(s), f = a(i), m = a(s);
  return {
    position: {
      x: Ea(d.x, p.x, h),
      y: Ea(d.y, p.y, h),
      z: Ea(d.z, p.z, h)
    },
    rotation: {
      x: Ap(f.x, m.x, h),
      y: Ap(f.y, m.y, h),
      z: Ap(f.z, m.z, h)
    },
    focalLength: Ea(l(i), l(s), h),
    zoom: Ea(c(i), c(s), h),
    focusDistance: Ea(u(i), u(s), h)
  };
}
function Ea(r, e, n) {
  return r + (e - r) * n;
}
function Ap(r, e, n) {
  let i = e - r;
  return i > 180 && (i -= 360), i < -180 && (i += 360), r + i * n;
}
function Zb(r) {
  const { position: e, rotation: n } = r, i = n.x * Math.PI / 180, s = n.y * Math.PI / 180, o = n.z * Math.PI / 180, a = Math.cos(i), l = Math.sin(i), c = Math.cos(s), u = Math.sin(s), h = Math.cos(o), d = Math.sin(o), p = c * h + u * l * d, f = -c * d + u * l * h, m = u * a, _ = a * d, g = a * h, v = -l, S = -u * h + c * l * d, b = u * d + c * l * h, x = c * a, M = -(p * e.x + _ * e.y + S * e.z), C = -(f * e.x + g * e.y + b * e.z), E = -(m * e.x + v * e.y + x * e.z);
  return [
    [p, f, m, M],
    [_, g, v, C],
    [S, b, x, E],
    [0, 0, 0, 1]
  ];
}
function bk(r, e, n = 0.1, i = 1e3) {
  const o = du(r.focalLength, 36) * Math.PI / 180, l = 1 / Math.tan(o / 2), c = 1 / (n - i);
  return [
    [l / e, 0, 0, 0],
    [0, l, 0, 0],
    [0, 0, (i + n) * c, 2 * i * n * c],
    [0, 0, -1, 0]
  ];
}
function Kb(r, e, n) {
  const i = [];
  for (let s = 0; s < n; s++) {
    const o = Zc(r, e, s), a = Zb(o);
    i.push({
      RT: a
    });
  }
  return { camera_poses: i };
}
function wk(r) {
  if (!r || r.length < 2) return "static";
  const e = r[0], n = r[r.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, s = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = s.x - i.x, c = s.y - i.y, u = s.z - i.z, h = a.y - o.y, d = 50;
  return Math.abs(u) > d ? u < 0 ? "zoom_in" : "zoom_out" : Math.abs(h) > 15 ? h > 0 ? "rotate_cw" : "rotate_ccw" : Math.abs(l) > d ? l > 0 ? "pan_right" : "pan_left" : Math.abs(c) > d ? c > 0 ? "pan_down" : "pan_up" : "static";
}
function Sk(r, e, n) {
  const i = wk(e);
  if (i !== "static" && e.length <= 2)
    return { motion_camera: i };
  const s = Kb(r, e, n);
  return {
    motion_camera: i,
    camera_poses: JSON.stringify(s.camera_poses)
  };
}
function hf(r) {
  if (!r || r.length < 2)
    return {
      hasPan: !1,
      panMagnitude: 0,
      hasZoom: !1,
      zoomMagnitude: 0,
      hasOrbit: !1,
      orbitMagnitude: 0,
      hasRotation: !1,
      rotationMagnitude: 0
    };
  const e = r[0], n = r[r.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, s = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = s.x - i.x, c = s.y - i.y, u = s.z - i.z, h = a.y - o.y, d = 30, p = 50, f = 20;
  let m;
  const _ = Math.abs(l), g = Math.abs(c);
  (_ > d || g > d) && (_ > g ? m = l > 0 ? "right" : "left" : m = c > 0 ? "down" : "up");
  let v;
  Math.abs(u) > p && (v = u < 0 ? "in" : "out");
  let S;
  return Math.abs(h) > f && Math.abs(l) > d && (S = h > 0 ? "right" : "left"), {
    hasPan: !!m,
    panDirection: m,
    panMagnitude: Math.max(_, g),
    hasZoom: !!v,
    zoomDirection: v,
    zoomMagnitude: Math.abs(u),
    hasOrbit: !!S,
    orbitDirection: S,
    orbitMagnitude: Math.abs(h),
    hasRotation: Math.abs(h) > 5,
    rotationMagnitude: Math.abs(h)
  };
}
function Mk(r) {
  const e = hf(r);
  let n = "Static";
  if (e.hasOrbit)
    n = e.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  else if (e.hasZoom && e.hasPan) {
    const i = Qy(e.panDirection || "up"), s = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    n = `Pan ${i} + ${s}`;
  } else e.hasZoom ? n = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out" : e.hasPan && (n = `Pan ${Qy(e.panDirection || "up")}`);
  return { camera_motion: n };
}
function Qy(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
function Ck(r) {
  const e = hf(r);
  return e.hasOrbit && e.orbitMagnitude > 45 ? "orbit" : e.hasPan && e.hasZoom ? "custom" : !e.hasPan && !e.hasZoom && !e.hasOrbit ? "free1" : "custom";
}
function Tk(r, e, n, i, s) {
  const o = Ck(e);
  if (o !== "custom")
    return { traj_type: o };
  const a = [], l = Zc(r, e, 0);
  for (let c = 0; c < n; c++) {
    const u = Zc(r, e, c);
    a.push({
      zoom: u.zoom / l.zoom,
      x_offset: (u.position.x - l.position.x) / i,
      y_offset: (u.position.y - l.position.y) / s,
      z_offset: (u.position.z - l.position.z) / 1e3,
      pitch: u.rotation.x,
      yaw: u.rotation.y,
      roll: u.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: a
  };
}
function Ek(r) {
  const e = hf(r);
  if (!e.hasPan && !e.hasZoom && !e.hasRotation)
    return "Static";
  if (e.hasZoom)
    return e.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  if (e.hasPan)
    switch (e.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  if (e.hasRotation) {
    const n = r[0], i = r[r.length - 1], s = n.orientation ?? { x: 0, y: 0, z: 0 }, o = i.orientation ?? { x: 0, y: 0, z: 0 }, a = o.x - s.x, l = o.y - s.y, c = o.z - s.z;
    return Math.abs(l) > Math.abs(a) && Math.abs(l) > Math.abs(c) ? l > 0 ? "Rotate Right" : "Rotate Left" : Math.abs(a) > Math.abs(c) ? a > 0 ? "Rotate Down" : "Rotate Up" : c > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function Ak(r, e) {
  const n = Ek(r), i = hf(r);
  let s = 0;
  return i.hasZoom ? s = Math.min(100, i.zoomMagnitude / 5) : i.hasPan ? s = Math.min(100, i.panMagnitude / 3) : i.hasRotation && (s = Math.min(100, i.rotationMagnitude * 2)), {
    motion_type: n,
    speed: Math.round(s),
    frame_length: e
  };
}
function Pk(r, e, n) {
  const i = [], s = n.width / n.height;
  for (let o = 0; o < n.frameCount; o++) {
    const a = Zc(r, e, o), l = Zb(a), c = bk(a, s);
    i.push({
      frame: o,
      timestamp: o / n.fps,
      view_matrix: l,
      projection_matrix: c,
      position: [a.position.x, a.position.y, a.position.z],
      rotation: [a.rotation.x, a.rotation.y, a.rotation.z],
      fov: du(a.focalLength, r.filmSize),
      focal_length: a.focalLength,
      focus_distance: a.focusDistance
    });
  }
  return {
    frames: i,
    metadata: {
      width: n.width,
      height: n.height,
      fps: n.fps,
      total_frames: n.frameCount,
      camera_type: r.type,
      film_size: r.filmSize
    }
  };
}
function Dk(r, e, n, i, s = 1920, o = 1080, a = 24) {
  switch (r) {
    case "motionctrl":
      return Kb(e, n, i);
    case "motionctrl-svd":
      return Sk(e, n, i);
    case "wan22-fun-camera":
      return Mk(n);
    case "uni3c-camera":
    case "uni3c-motion":
      return Tk(e, n, i, s, o);
    case "animatediff-cameractrl":
      return Ak(n, i);
    default:
      return Pk(e, n, {
        frameCount: i,
        width: s,
        height: o,
        fps: a
      });
  }
}
function Kc(r, e, n) {
  const i = Math.max(0, Math.min(n, r.frameCount - 1));
  switch (e) {
    case "amplitude":
      return r.amplitudeEnvelope[i] ?? 0;
    case "rms":
      return r.rmsEnergy[i] ?? 0;
    case "spectralCentroid":
      return r.spectralCentroid[i] ?? 0;
    case "sub":
      return r.frequencyBands.sub[i] ?? 0;
    case "bass":
      return r.frequencyBands.bass[i] ?? 0;
    case "lowMid":
      return r.frequencyBands.lowMid[i] ?? 0;
    case "mid":
      return r.frequencyBands.mid[i] ?? 0;
    case "highMid":
      return r.frequencyBands.highMid[i] ?? 0;
    case "high":
      return r.frequencyBands.high[i] ?? 0;
    case "onsets":
      return r.onsets.includes(i) ? 1 : 0;
    default:
      return 0;
  }
}
function Jb(r, e) {
  const { threshold: n, minPeaksDistance: i, multiply: s } = e, o = r.map((h) => Math.min(1, h * s)), a = [];
  for (let h = 1; h < o.length - 1; h++) {
    const d = o[h - 1], p = o[h], f = o[h + 1];
    p > d && p > f && p >= n && a.push({ index: h, value: p });
  }
  const l = [];
  for (const h of a) {
    const d = l.findIndex(
      (p) => Math.abs(p.index - h.index) < i
    );
    d === -1 ? l.push(h) : h.value > l[d].value && (l[d] = h);
  }
  l.sort((h, d) => h.index - d.index);
  const c = new Array(r.length).fill(0);
  let u = 0;
  for (let h = 0; h < r.length; h++)
    l.some((p) => p.index === h) && (u = 1 - u), c[h] = u;
  return {
    indices: l.map((h) => h.index),
    values: l.map((h) => h.value),
    count: l.length,
    alternating: c
  };
}
function e1(r, e) {
  return r.onsets.includes(e);
}
function kk(r, e) {
  return r.indices.includes(e);
}
let Bo = null, Jc = null, Ga = null, Sd = null;
function Rk() {
  return Bo || (Bo = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), Bo.onmessage = (r) => {
    const e = r.data;
    switch (e.type) {
      case "progress":
        Sd && Sd({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        Jc && (Jc(e.payload), Pp());
        break;
      case "error":
        Ga && (Ga(new Error(e.payload.message)), Pp());
        break;
    }
  }, Bo.onerror = (r) => {
    console.error("[AudioWorker] Worker error:", r), Ga && (Ga(new Error(`Worker error: ${r.message}`)), Pp());
  }), Bo;
}
function Pp() {
  Jc = null, Ga = null, Sd = null;
}
function Lk() {
  Bo && Bo.postMessage({ type: "cancel" });
}
async function Ik(r, e, n = {}) {
  const i = Rk();
  if (Jc)
    throw new Error("Analysis already in progress. Cancel it first.");
  const s = r.getChannelData(0), o = new Float32Array(s);
  return new Promise((a, l) => {
    Jc = a, Ga = l, Sd = n.onProgress || null, i.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: o,
          sampleRate: r.sampleRate,
          fps: e
        }
      },
      [o.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function Ok(r, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const i = await r.arrayBuffer(), s = new AudioContext();
  let o;
  try {
    o = await s.decodeAudioData(i);
  } finally {
    await s.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const a = await Ik(o, e, n);
  return { buffer: o, analysis: a };
}
function tn(r, e, n = "number", i) {
  return {
    id: `prop_${r}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: r,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: i
  };
}
function t1() {
  return {
    position: tn("position", { x: 0, y: 0 }, "position"),
    anchorPoint: tn("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: tn("scale", { x: 100, y: 100 }, "position"),
    rotation: tn("rotation", 0, "number")
  };
}
function Fk(r, e) {
  const n = "main", i = {
    width: r,
    height: e,
    frameCount: 81,
    fps: 16,
    duration: 5.0625,
    backgroundColor: "#000000",
    autoResizeToContent: !0
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [n]: {
        id: n,
        name: "Main Comp",
        settings: i,
        layers: [],
        currentFrame: 0,
        isPrecomp: !1
      }
    },
    mainCompositionId: n,
    // Legacy alias
    composition: i,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function Uk(r, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: r || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0
  };
}
class zk {
  constructor(e) {
    pe(this, "analysis");
    pe(this, "mappings", /* @__PURE__ */ new Map());
    pe(this, "smoothedValues", /* @__PURE__ */ new Map());
    pe(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const i = this.mappings.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && kk(this.peakData, n) ? 1 : 0 : Kc(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const i = this.mappings.get(e);
    if (!i || !i.enabled) return 0;
    let s = this.getFeatureAtFrame(i.feature, n);
    s < i.threshold && (s = 0), i.invert && (s = 1 - s), s *= i.sensitivity, s += i.offset, s = Math.max(i.min, Math.min(i.max, s));
    const a = (this.smoothedValues.get(e) || 0) * i.smoothing + s * (1 - i.smoothing);
    return this.smoothedValues.set(e, a), a;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled) continue;
      const s = this.getValueAtFrame(i.id, e), o = n.get(i.target);
      o !== void 0 ? n.set(i.target, o + s) : n.set(i.target, s);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of this.mappings.values()) {
      if (!s.enabled || s.targetLayerId && s.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(s.id, n), a = i.get(s.target);
      a !== void 0 ? i.set(s.target, a + o) : i.set(s.target, o);
    }
    return i;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function Dp(r) {
  return {
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    onsets: "Beat Onsets",
    peaks: "Detected Peaks"
  }[r] || r;
}
function n1(r) {
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[r] || r;
}
function Bk() {
  return [
    "amplitude",
    "rms",
    "spectralCentroid",
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    "onsets",
    "peaks"
  ];
}
function Nk() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
  };
}
const Vk = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class Gk {
  // For amplitude mode release tracking
  constructor(e = {}) {
    pe(this, "config");
    pe(this, "state");
    pe(this, "pathSegments", []);
    pe(this, "totalLength", 0);
    pe(this, "releaseState", 0);
    this.config = { ...Vk, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], i = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let s = 0, o = 0;
    for (const a of i) {
      const l = a[0].toUpperCase(), c = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          s = c[0] || 0, o = c[1] || 0, n.push({
            type: "M",
            points: [s, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [s, o, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), s = c[0], o = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [s, o, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), s = c[4], o = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [s, o, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), s = c[2], o = c[3];
          break;
        case "Z":
          const u = n.find((h) => h.type === "M");
          u && n.push({
            type: "L",
            points: [s, o, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], i = e[3] - e[1];
    return Math.sqrt(n * n + i * i);
  }
  bezierLength(e, n) {
    let s = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: h } = this.getBezierPoint(e, c, n), d = u - o, p = h - a;
      s += Math.sqrt(d * d + p * p), o = u, a = h;
    }
    return s;
  }
  getBezierPoint(e, n, i) {
    if (i === 2) {
      const s = 1 - n;
      return {
        x: s * s * e[0] + 2 * s * n * e[2] + n * n * e[4],
        y: s * s * e[1] + 2 * s * n * e[3] + n * n * e[5]
      };
    } else {
      const s = 1 - n, o = s * s, a = n * n;
      return {
        x: o * s * e[0] + 3 * o * n * e[2] + 3 * s * a * e[4] + a * n * e[6],
        y: o * s * e[1] + 3 * o * n * e[3] + 3 * s * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const i = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = i, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(i) : this.updateAccumulateMode(i, n);
    const s = this.getPositionOnPath(this.state.position);
    return this.state.x = s.x, this.state.y = s.y, this.state.angle = s.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const s = 1 - this.config.release * 0.95;
      this.releaseState *= s;
    }
    const i = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, i * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const i = e * this.config.sensitivity * 0.02 * this.state.direction;
    let s = this.state.position + i;
    s > 1 ? (s = 2 - s, this.state.direction = -1) : s < 0 && (s = -s, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, s));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const i = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let s, o, a, l;
    switch (n.type) {
      case "L":
        s = n.points[0] + (n.points[2] - n.points[0]) * i, o = n.points[1] + (n.points[3] - n.points[1]) * i, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, i, 2);
        s = u.x, o = u.y;
        const h = 1 - i;
        a = 2 * h * (n.points[2] - n.points[0]) + 2 * i * (n.points[4] - n.points[2]), l = 2 * h * (n.points[3] - n.points[1]) + 2 * i * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, i, 3);
        s = u.x, o = u.y;
        const h = 1 - i, d = h * h, p = i * i;
        a = 3 * d * (n.points[2] - n.points[0]) + 6 * h * i * (n.points[4] - n.points[2]) + 3 * p * (n.points[6] - n.points[4]), l = 3 * d * (n.points[3] - n.points[1]) + 6 * h * i * (n.points[5] - n.points[3]) + 3 * p * (n.points[7] - n.points[5]);
        break;
      }
      default:
        s = 0, o = 0, a = 1, l = 0;
    }
    const c = Math.atan2(l, a);
    return { x: s, y: o, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], i = this.state.previousPosition, s = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = i + (s - i) * (o / e), l = this.getPositionOnPath(a), c = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function Hk(r) {
  switch (r) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const Md = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, ng = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function Wk(r) {
  const e = Md[r];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((i, s) => {
    const o = i.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[o] = {
      id: `${r}-${o}-${s}`,
      name: i.name,
      type: Hk(i.type),
      value: i.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: r,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const jk = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];
class $k {
  constructor() {
    pe(this, "drivers", /* @__PURE__ */ new Map());
    pe(this, "smoothedValues", /* @__PURE__ */ new Map());
    pe(this, "audioAnalysis", null);
    pe(this, "propertyGetter", null);
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(e) {
    this.audioAnalysis = e;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(e) {
    this.propertyGetter = e;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(e) {
    return e.sourceType === "property" && e.sourceLayerId && e.sourceProperty && this.wouldCreateCycle(e) ? (console.warn("[PropertyDriverSystem] Cannot add driver: would create circular dependency"), !1) : (this.drivers.set(e.id, e), this.smoothedValues.set(e.id, 0), !0);
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(e) {
    if (e.sourceType !== "property" || !e.sourceLayerId || !e.sourceProperty) return !1;
    const n = /* @__PURE__ */ new Set(), i = `${e.targetLayerId}:${e.targetProperty}`, s = (o, a) => {
      const l = `${o}:${a}`;
      if (l === i) return !0;
      if (n.has(l)) return !1;
      n.add(l);
      for (const c of this.drivers.values())
        if (c.sourceType === "property" && !(c.targetLayerId !== o || c.targetProperty !== a) && !(!c.sourceLayerId || !c.sourceProperty) && s(c.sourceLayerId, c.sourceProperty))
          return !0;
      return !1;
    };
    return s(e.sourceLayerId, e.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(e) {
    this.drivers.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update a driver
   */
  updateDriver(e, n) {
    const i = this.drivers.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a driver by ID
   */
  getDriver(e) {
    return this.drivers.get(e);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(e) {
    return Array.from(this.drivers.values()).filter((n) => n.targetLayerId === e);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(e, n) {
    return Array.from(this.drivers.values()).filter(
      (i) => i.targetLayerId === e && i.targetProperty === n && i.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(e, n, i) {
    if (!e.enabled) return i;
    let s = this.getSourceValue(e, n);
    return s === null ? i : (s = this.applyTransforms(e, s), this.blendValue(i, s, e.blendMode, e.blendAmount));
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(e, n) {
    switch (e.sourceType) {
      case "property":
        return this.getPropertySourceValue(e, n);
      case "audio":
        return this.getAudioSourceValue(e, n);
      case "time":
        return n;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(e, n) {
    return !this.propertyGetter || !e.sourceLayerId || !e.sourceProperty ? null : this.propertyGetter(e.sourceLayerId, e.sourceProperty, n);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(e, n) {
    if (!this.audioAnalysis || !e.audioFeature)
      return null;
    let i = Kc(this.audioAnalysis, e.audioFeature, n);
    return e.audioThreshold !== void 0 && (e.audioAboveThreshold ? i = i > e.audioThreshold ? i : 0 : i = i >= e.audioThreshold ? i : 0), i;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(e, n) {
    for (const i of e.transforms)
      n = this.applyTransform(e.id, i, n);
    return n;
  }
  /**
   * Apply a single transform
   */
  applyTransform(e, n, i) {
    switch (n.type) {
      case "scale":
        return i * (n.factor ?? 1);
      case "offset":
        return i + (n.amount ?? 0);
      case "clamp":
        return Math.max(n.min ?? -1 / 0, Math.min(n.max ?? 1 / 0, i));
      case "smooth": {
        const s = this.smoothedValues.get(e) ?? i, o = n.smoothing ?? 0.5, a = s * o + i * (1 - o);
        return this.smoothedValues.set(e, a), a;
      }
      case "invert":
        return 1 - i;
      case "remap": {
        const s = n.inMin ?? 0, o = n.inMax ?? 1, a = n.outMin ?? 0, l = n.outMax ?? 1, c = (i - s) / (o - s);
        return a + c * (l - a);
      }
      case "threshold":
        return i > (n.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const s = n.frequency ?? 1, o = n.amplitude ?? 1, a = n.phase ?? 0;
        return Math.sin((i * s + a) * Math.PI * 2) * o;
      }
      default:
        return i;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(e, n, i, s) {
    let o;
    switch (i) {
      case "replace":
        o = n;
        break;
      case "add":
        o = e + n;
        break;
      case "multiply":
        o = e * n;
        break;
      default:
        o = n;
    }
    return e * (1 - s) + o * s;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(e, n, i) {
    const s = /* @__PURE__ */ new Map(), o = this.getDriversForLayer(e);
    for (const a of o) {
      if (!a.enabled) continue;
      const l = i.get(a.targetProperty) ?? 0, c = this.evaluateDriver(a, n, l), u = s.get(a.targetProperty);
      u !== void 0 ? s.set(a.targetProperty, u + c - l) : s.set(a.targetProperty, c);
    }
    return s;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addDriver(n);
  }
}
function Qb(r, e, n = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: !0,
    targetLayerId: r,
    targetProperty: e,
    sourceType: n,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function Xk(r, e, n, i = {}) {
  const s = Qb(r, e, "audio");
  return s.audioFeature = n, s.audioThreshold = i.threshold ?? 0, s.audioAboveThreshold = i.threshold !== void 0, i.scale !== void 0 && i.scale !== 1 && s.transforms.push({ type: "scale", factor: i.scale }), i.offset !== void 0 && i.offset !== 0 && s.transforms.push({ type: "offset", amount: i.offset }), i.smoothing !== void 0 && i.smoothing > 0 && s.transforms.push({ type: "smooth", smoothing: i.smoothing }), s;
}
function Yk(r, e, n, i, s = {}) {
  const o = Qb(r, e, "property");
  return o.sourceLayerId = n, o.sourceProperty = i, o.blendMode = s.blendMode ?? "add", s.scale !== void 0 && s.scale !== 1 && o.transforms.push({ type: "scale", factor: s.scale }), s.offset !== void 0 && s.offset !== 0 && o.transforms.push({ type: "offset", amount: s.offset }), o;
}
const qk = {
  enabled: !0,
  snapToGrid: !0,
  snapToKeyframes: !0,
  snapToBeats: !0,
  snapToPeaks: !0,
  snapToLayerBounds: !0,
  snapToPlayhead: !0,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function Zk(r, e, n, i) {
  var l, c;
  if (!e.enabled)
    return null;
  const s = [], o = e.threshold / n;
  if (e.snapToGrid) {
    const u = Math.round(r / e.gridInterval) * e.gridInterval, h = Math.abs(r - u);
    h <= o && s.push({
      frame: u,
      type: "frame",
      distance: h * n
    });
  }
  if (e.snapToKeyframes && i.layers)
    for (const u of i.layers)
      u.id !== i.selectedLayerId && Kk(u, r, o, n, s);
  if (e.snapToBeats && ((l = i.audioAnalysis) != null && l.onsets))
    for (const u of i.audioAnalysis.onsets) {
      const h = Math.abs(r - u);
      h <= o && s.push({
        frame: u,
        type: "beat",
        distance: h * n
      });
    }
  if (e.snapToPeaks && ((c = i.peakData) != null && c.indices))
    for (const u of i.peakData.indices) {
      const h = Math.abs(r - u);
      h <= o && s.push({
        frame: u,
        type: "peak",
        distance: h * n
      });
    }
  if (e.snapToLayerBounds && i.layers)
    for (const u of i.layers) {
      if (u.id === i.selectedLayerId) continue;
      const h = Math.abs(r - u.inPoint), d = Math.abs(r - u.outPoint);
      h <= o && s.push({
        frame: u.inPoint,
        type: "layer-in",
        distance: h * n
      }), d <= o && s.push({
        frame: u.outPoint,
        type: "layer-out",
        distance: d * n
      });
    }
  if (e.snapToPlayhead && i.currentFrame !== void 0) {
    const u = Math.abs(r - i.currentFrame);
    u <= o && u > 0 && s.push({
      frame: i.currentFrame,
      type: "playhead",
      distance: u * n
    });
  }
  if (s.length === 0)
    return null;
  const a = {
    playhead: 5,
    beat: 4,
    peak: 4,
    keyframe: 3,
    "layer-in": 2,
    "layer-out": 2,
    frame: 1
  };
  return s.sort((u, h) => {
    const d = u.distance - h.distance;
    return Math.abs(d) < 0.5 ? a[h.type] - a[u.type] : d;
  }), s[0];
}
function Kk(r, e, n, i, s) {
  const o = [
    r.transform.position,
    r.transform.scale,
    r.transform.rotation,
    r.opacity,
    ...r.properties
  ];
  for (const a of o)
    if (!(!a.animated || !a.keyframes))
      for (const l of a.keyframes) {
        const c = Math.abs(e - l.frame);
        c <= n && (s.some((u) => u.frame === l.frame && u.type === "keyframe") || s.push({
          frame: l.frame,
          type: "keyframe",
          distance: c * i
        }));
      }
}
function Jk(r) {
  return (r == null ? void 0 : r.onsets) ?? [];
}
function Qk(r) {
  return (r == null ? void 0 : r.indices) ?? [];
}
const _n = /* @__PURE__ */ lT("compositor", {
  state: () => ({
    project: Fk(1024, 1024),
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: qb(),
    viewOptions: mk(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...qk }
  }),
  getters: {
    // Project info
    hasProject: (r) => r.sourceImage !== null,
    width: (r) => r.project.composition.width,
    height: (r) => r.project.composition.height,
    frameCount: (r) => r.project.composition.frameCount,
    fps: (r) => r.project.composition.fps,
    duration: (r) => r.project.composition.duration,
    // Current frame
    currentFrame: (r) => r.project.currentFrame,
    currentTime: (r) => r.project.currentFrame / r.project.composition.fps,
    // Layers
    layers: (r) => r.project.layers,
    visibleLayers: (r) => r.project.layers.filter((e) => e.visible),
    // Selection
    selectedLayers: (r) => r.project.layers.filter((e) => r.selectedLayerIds.includes(e.id)),
    selectedLayer: (r) => r.selectedLayerIds.length !== 1 ? null : r.project.layers.find((e) => e.id === r.selectedLayerIds[0]) || null,
    // Assets
    assets: (r) => r.project.assets,
    // History
    canUndo: (r) => r.historyIndex > 0,
    canRedo: (r) => r.historyIndex < r.historyStack.length - 1,
    // Camera
    activeCamera: (r) => r.activeCameraId && r.cameras.get(r.activeCameraId) || null,
    allCameras: (r) => Array.from(r.cameras.values()),
    cameraLayers: (r) => r.project.layers.filter((e) => e.type === "camera")
  },
  actions: {
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(r) {
      this.comfyuiNodeId = r.node_id, this.sourceImage = r.source_image, this.depthMap = r.depth_map, this.project.composition.width = r.width, this.project.composition.height = r.height, this.project.composition.frameCount = r.frame_count, this.project.composition.duration = r.frame_count / this.project.composition.fps, r.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: r.node_id,
        width: r.width,
        height: r.height,
        data: r.source_image
      }), r.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: r.node_id,
        width: r.width,
        height: r.height,
        data: r.depth_map
      }), this.project.currentFrame = 0, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[Weyl] Loaded inputs from ComfyUI:", {
        width: r.width,
        height: r.height,
        frameCount: r.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(r, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let i = null;
      switch (r) {
        case "text":
          i = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: !1,
            pathPerpendicularToPath: !0,
            pathForceAlignment: !1,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          i = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          i = {
            size: 40
          };
          break;
        case "spline":
          i = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          i = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          i = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          i = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: !1,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          i = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          i = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          i = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let s;
      (r === "video" || r === "audio") && (s = {
        level: tn("Audio Levels", 0, "number")
        // 0dB default
      });
      const o = {
        id: n,
        name: e || `${r.charAt(0).toUpperCase() + r.slice(1)} ${this.project.layers.length + 1}`,
        type: r,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: tn("opacity", 100, "number"),
        transform: t1(),
        audio: s,
        properties: [],
        effects: [],
        data: i
      };
      return r === "camera" && console.warn("Use createCameraLayer() for camera layers"), this.project.layers.unshift(o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), o;
    },
    /**
     * Delete a layer
     */
    deleteLayer(r) {
      const e = this.project.layers.findIndex((n) => n.id === r);
      e !== -1 && (this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((n) => n !== r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update layer properties
     */
    updateLayer(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      !n || !n.data || (Object.assign(n.data, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      i.controlPoints || (i.controlPoints = []), i.controlPoints.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(r, e, n) {
      var a;
      const i = this.project.layers.find((l) => l.id === r);
      if (!i || i.type !== "spline" || !i.data) return;
      const o = (a = i.data.controlPoints) == null ? void 0 : a.find((l) => l.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(r, e) {
      const n = this.project.layers.find((o) => o.id === r);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      if (!i.controlPoints) return;
      const s = i.controlPoints.findIndex((o) => o.id === e);
      s >= 0 && (i.controlPoints.splice(s, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(r) {
      const e = this.project.layers.find((n) => n.id === r);
      if (e) {
        if (e.threeD = !e.threeD, e.threeD) {
          const n = e.transform, i = n.position.value;
          n.position.value = { x: i.x, y: i.y, z: i.z ?? 0 }, n.position.type = "vector3";
          const s = n.anchorPoint.value;
          n.anchorPoint.value = { x: s.x, y: s.y, z: s.z ?? 0 }, n.anchorPoint.type = "vector3";
          const o = n.scale.value;
          n.scale.value = { x: o.x, y: o.y, z: o.z ?? 100 }, n.scale.type = "vector3", n.orientation || (n.orientation = tn("orientation", { x: 0, y: 0, z: 0 }, "vector3")), n.rotationX || (n.rotationX = tn("rotationX", 0, "number")), n.rotationY || (n.rotationY = tn("rotationY", 0, "number")), n.rotationZ || (n.rotationZ = tn("rotationZ", 0, "number"), n.rotationZ.value = n.rotation.value);
        } else
          e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Reorder layers
     */
    moveLayer(r, e) {
      const n = this.project.layers.findIndex((s) => s.id === r);
      if (n === -1) return;
      const [i] = this.project.layers.splice(n, 1);
      this.project.layers.splice(e, 0, i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(r, e = !1) {
      e ? this.selectedLayerIds.includes(r) || this.selectedLayerIds.push(r) : this.selectedLayerIds = [r];
    },
    deselectLayer(r) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== r);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      if (n && e !== r) {
        if (e) {
          const i = (o) => {
            const a = this.project.layers.filter((c) => c.parentId === o);
            let l = a.map((c) => c.id);
            for (const c of a)
              l = l.concat(i(c.id));
            return l;
          };
          if (new Set(i(r)).has(e)) {
            console.warn("[Store] Cannot set parent: would create circular reference");
            return;
          }
        }
        n.parentId = e, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
      }
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(r) {
      this.selectedPropertyPath = r;
    },
    /**
     * Playback controls
     */
    play() {
      this.isPlaying || (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = this.project.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const r = performance.now() - (this.playbackStartTime || 0), e = this.project.composition.fps, n = this.project.composition.frameCount, i = Math.floor(r / 1e3 * e);
      let s = this.playbackStartFrame + i;
      s >= n && (s = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), this.project.currentFrame = s, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(r) {
      this.project.currentFrame = Math.max(0, Math.min(r, this.project.composition.frameCount - 1));
    },
    nextFrame() {
      this.project.currentFrame < this.project.composition.frameCount - 1 && this.project.currentFrame++;
    },
    prevFrame() {
      this.project.currentFrame > 0 && this.project.currentFrame--;
    },
    goToStart() {
      this.project.currentFrame = 0;
    },
    goToEnd() {
      this.project.currentFrame = this.project.composition.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(r) {
      this.currentTool = r;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const r = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(r), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(r) {
      try {
        const e = JSON.parse(r);
        this.project = e, this.pushHistory();
      } catch (e) {
        console.error("[Weyl] Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(r) {
      return fn(r, this.project.currentFrame);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(r, e, n, i) {
      const s = i ?? this.project.currentFrame;
      console.log("[Store] addKeyframe called:", { layerId: r, propertyName: e, value: n, frame: s });
      const o = this.project.layers.find((u) => u.id === r);
      if (!o)
        return console.log("[Store] addKeyframe: layer not found"), null;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((u) => u.name === e), !a)
        return console.log("[Store] addKeyframe: property not found:", e), null;
      a.animated = !0;
      const l = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: s,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, c = a.keyframes.findIndex((u) => u.frame === s);
      return c >= 0 ? (a.keyframes[c] = l, console.log("[Store] addKeyframe: replaced existing keyframe at frame", this.project.currentFrame)) : (a.keyframes.push(l), a.keyframes.sort((u, h) => u.frame - h.frame), console.log("[Store] addKeyframe: added new keyframe at frame", this.project.currentFrame, "total keyframes:", a.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), l;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(r, e, n) {
      const i = this.project.layers.find((a) => a.id === r);
      if (!i) return;
      let s;
      if (e === "position" || e === "transform.position" ? s = i.transform.position : e === "scale" || e === "transform.scale" ? s = i.transform.scale : e === "rotation" || e === "transform.rotation" ? s = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? s = i.transform.anchorPoint : e === "opacity" ? s = i.opacity : s = i.properties.find((a) => a.name === e), !s) return;
      const o = s.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (s.keyframes.splice(o, 1), s.keyframes.length === 0 && (s.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(r, e, n) {
      const i = this.project.layers.find((o) => o.id === r);
      if (!i) return;
      let s;
      if (e === "position" || e === "transform.position" ? s = i.transform.position : e === "scale" || e === "transform.scale" ? s = i.transform.scale : e === "rotation" || e === "transform.rotation" ? s = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? s = i.transform.anchorPoint : e === "opacity" ? s = i.opacity : s = i.properties.find((o) => o.name === e), !!s) {
        if (s.value = n, s.animated && s.keyframes.length > 0) {
          const o = s.keyframes.find((a) => a.frame === this.project.currentFrame);
          o && (o.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(r, e, n) {
      const i = this.project.layers.find((o) => o.id === r);
      if (!i) return;
      let s;
      e === "position" || e === "transform.position" ? s = i.transform.position : e === "scale" || e === "transform.scale" ? s = i.transform.scale : e === "rotation" || e === "transform.rotation" ? s = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? s = i.transform.anchorPoint : e === "opacity" ? s = i.opacity : s = i.properties.find((o) => o.name === e), s && (s.animated = n, n && s.keyframes.length === 0 && this.addKeyframe(r, e, s.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(r, e, n, i) {
      const s = this.project.layers.find((c) => c.id === r);
      if (!s) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = s.transform.position : e === "scale" || e === "transform.scale" ? o = s.transform.scale : e === "rotation" || e === "transform.rotation" ? o = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = s.transform.anchorPoint : e === "opacity" ? o = s.opacity : o = s.properties.find((c) => c.name === e), !o) return;
      const a = o.keyframes.find((c) => c.id === n);
      if (!a) return;
      const l = o.keyframes.find((c) => c.frame === i && c.id !== n);
      l && (o.keyframes = o.keyframes.filter((c) => c.id !== l.id)), a.frame = i, o.keyframes.sort((c, u) => c.frame - u.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(r, e, n, i) {
      const s = this.project.layers.find((l) => l.id === r);
      if (!s) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = s.transform.position : e === "scale" || e === "transform.scale" ? o = s.transform.scale : e === "rotation" || e === "transform.rotation" ? o = s.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = s.transform.anchorPoint : e === "opacity" ? o = s.opacity : o = s.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (a.interpolation = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(r, e, n, i) {
      const s = this.project.layers.find((l) => l.id === r);
      if (!s) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = s.transform.position : e === "scale" || e === "transform.scale" ? o = s.transform.scale : e === "rotation" || e === "transform.rotation" ? o = s.transform.rotation : e === "opacity" ? o = s.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? o = s.transform.anchorPoint : o = s.properties.find((l) => l.id === e || l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (i.frame !== void 0 && (a.frame = i.frame, o.keyframes.sort((l, c) => l.frame - c.frame)), i.value !== void 0 && (a.value = i.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(r, e, n, i, s) {
      const o = this.project.layers.find((c) => c.id === r);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((c) => c.id === e || c.name === e), !a) return;
      const l = a.keyframes.find((c) => c.id === n);
      l && (i === "in" ? l.inHandle = { ...s } : l.outHandle = { ...s }, s.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(r = "Text") {
      const e = this.createLayer("text", r.substring(0, 20)), n = {
        text: r,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: !1,
        pathPerpendicularToPath: !0,
        pathForceAlignment: !1,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(tn("Font Size", 72, "number", "Text")), e.properties.push(tn("Fill Color", "#ffffff", "color", "Text")), e.properties.push(tn("Stroke Color", "#000000", "color", "Text")), e.properties.push(tn("Stroke Width", 0, "number", "Text")), e.properties.push(tn("Path Offset", 0, "number", "Path Options")), e.properties.push(tn("First Margin", 0, "number", "Path Options")), e.properties.push(tn("Last Margin", 0, "number", "Path Options")), e.properties.push(tn("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(tn("Tracking", 0, "number", "Advanced")), e.properties.push(tn("Line Spacing", 0, "number", "Advanced")), e.properties.push(tn("Character Offset", 0, "number", "Advanced")), e.properties.push(tn("Character Value", 0, "number", "Advanced")), e.properties.push(tn("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const r = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return r.data = e, r;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const r = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return r.data = e, r;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(r, e, n) {
      const i = this.project.layers.find((a) => a.id === r);
      if (!i || i.type !== "particles") return;
      const o = i.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      i.emitters = i.emitters.filter((s) => s.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(r = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), i = {
        sourceLayerId: r,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: tn("zoom", 1, "number"),
        animatedOffsetX: tn("offsetX", 0, "number"),
        animatedOffsetY: tn("offsetY", 0, "number"),
        animatedRotation: tn("rotation", 0, "number"),
        animatedDepthScale: tn("depthScale", 1, "number")
      };
      return n.data = i, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "depthflow") return;
      const i = n.data;
      Object.assign(i.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(r, e = !0) {
      let n;
      try {
        n = URL.createObjectURL(r);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let i;
      try {
        i = await dk(n);
      } catch (c) {
        throw URL.revokeObjectURL(n), new Error(`Failed to load video metadata: ${c.message}`);
      }
      const s = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: s,
        type: "video",
        source: "file",
        width: i.width,
        height: i.height,
        data: n,
        // Video-specific metadata
        duration: i.duration,
        frameCount: i.frameCount,
        fps: i.fps,
        hasAudio: i.hasAudio
      };
      if (this.project.assets[s] = o, e) {
        const c = fk(i, this.project.composition.fps);
        console.log("[Weyl] Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: c.width,
          newHeight: c.height,
          newFrameCount: c.frameCount,
          videoDuration: i.duration
        }), this.project.composition.width = c.width, this.project.composition.height = c.height, this.project.composition.frameCount = c.frameCount, this.project.composition.duration = c.frameCount / this.project.composition.fps;
      }
      const a = this.createLayer("video", r.name.replace(/\.[^.]+$/, "")), l = {
        assetId: s,
        loop: !1,
        pingPong: !1,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: i.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      if (a.data = l, !e) {
        const c = Math.ceil(i.duration * this.project.composition.fps);
        a.outPoint = Math.min(c - 1, this.project.composition.frameCount - 1);
      }
      return this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), console.log("[Weyl] Created video layer:", {
        layerId: a.id,
        assetId: s,
        dimensions: `${i.width}x${i.height}`,
        duration: `${i.duration.toFixed(2)}s`,
        frameCount: i.frameCount,
        hasAudio: i.hasAudio
      }), a;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "video") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(r, e) {
      const n = this.project.layers.find((o) => o.id === r);
      if (!n || n.type !== "video") return;
      const i = n.data;
      if (!i.assetId) return;
      const s = this.project.assets[i.assetId];
      s && (s.width = e.width, s.height = e.height, s.duration = e.duration, s.frameCount = e.frameCount, s.fps = e.fps, s.hasAudio = e.hasAudio), console.log("[Weyl] Video metadata loaded:", { layerId: r, metadata: e });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(r, e, n) {
      this.project.composition.width = r, this.project.composition.height = e, n !== void 0 && (this.project.composition.frameCount = n, this.project.composition.duration = n / this.project.composition.fps), this.project.currentFrame >= this.project.composition.frameCount && (this.project.currentFrame = this.project.composition.frameCount - 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), console.log("[Weyl] Composition resized:", {
        width: r,
        height: e,
        frameCount: this.project.composition.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(r, e) {
      const n = this.createLayer("precomp", e || "Precomp"), i = {
        compositionId: r,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        collapseTransformations: !1,
        overrideFrameRate: !1,
        frameRate: void 0
      };
      return n.data = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), n;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || n.type !== "precomp") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n) return;
      const i = Wk(e);
      i && (n.effects || (n.effects = []), n.effects.push(i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || !n.effects) return;
      const i = n.effects.findIndex((s) => s.id === e);
      i >= 0 && (n.effects.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(r, e, n, i) {
      const s = this.project.layers.find((a) => a.id === r);
      if (!s || !s.effects) return;
      const o = s.effects.find((a) => a.id === e);
      !o || !o.parameters[n] || (o.parameters[n].value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(r, e, n, i) {
      const s = this.project.layers.find((l) => l.id === r);
      if (!s || !s.effects) return;
      const o = s.effects.find((l) => l.id === e);
      if (!o || !o.parameters[n]) return;
      const a = o.parameters[n];
      a.animated = i, i && (!a.keyframes || a.keyframes.length === 0) && (a.keyframes = [{
        id: `kf_${Date.now()}`,
        frame: this.currentFrame,
        value: a.value,
        interpolation: "linear",
        inHandle: { frame: -5, value: 0, enabled: !1 },
        outHandle: { frame: 5, value: 0, enabled: !1 },
        controlMode: "smooth"
      }]), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      if (!n || !n.effects) return;
      const i = n.effects.find((s) => s.id === e);
      i && (i.enabled = !i.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(r, e, n) {
      const i = this.project.layers.find((o) => o.id === r);
      if (!i || !i.effects || e < 0 || e >= i.effects.length || n < 0 || n >= i.effects.length) return;
      const [s] = i.effects.splice(e, 1);
      i.effects.splice(n, 0, s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(r, e, n, i) {
      const s = this.project.layers.find((c) => c.id === r);
      if (!s || !s.effects) return null;
      const o = s.effects.find((c) => c.id === e);
      if (!o || !o.parameters[n]) return null;
      const a = o.parameters[n], l = i ?? this.project.currentFrame;
      return a.animated && a.keyframes.length > 0 ? fn(a, l) : a.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(r) {
      const e = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, n = r || `Camera ${this.cameras.size + 1}`, i = Yb(
        e,
        this.project.composition.width,
        this.project.composition.height
      );
      i.name = n, this.cameras.set(e, i), this.activeCameraId || (this.activeCameraId = e);
      const s = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: s,
        name: n,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: tn("opacity", 100, "number"),
        transform: t1(),
        properties: [],
        effects: [],
        data: {
          cameraId: e,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === e
        }
      };
      return this.project.layers.unshift(o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(s), { camera: i, layer: o };
    },
    /**
     * Get a camera by ID
     */
    getCamera(r) {
      return this.cameras.get(r) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(r, e) {
      const n = this.cameras.get(r);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(r) {
      if (this.cameras.has(r)) {
        this.activeCameraId = r;
        for (const e of this.project.layers)
          if (e.type === "camera" && e.data) {
            const n = e.data;
            n.isActiveCamera = n.cameraId === r;
          }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(r) {
      const e = this.project.layers.findIndex(
        (n) => {
          var i;
          return n.type === "camera" && ((i = n.data) == null ? void 0 : i.cameraId) === r;
        }
      );
      if (e !== -1) {
        const n = this.project.layers[e].id;
        this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((i) => i !== n);
      }
      if (this.cameras.delete(r), this.activeCameraId === r) {
        const n = Array.from(this.cameras.keys());
        this.activeCameraId = n.length > 0 ? n[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(r) {
      return this.cameraKeyframes.get(r) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(r, e) {
      let n = this.cameraKeyframes.get(r);
      n || (n = [], this.cameraKeyframes.set(r, n));
      const i = n.findIndex((s) => s.frame === e.frame);
      i >= 0 ? n[i] = e : (n.push(e), n.sort((s, o) => s.frame - o.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(r, e) {
      const n = this.cameraKeyframes.get(r);
      if (!n) return;
      const i = n.findIndex((s) => s.frame === e);
      i >= 0 && (n.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(r, e) {
      const n = this.cameras.get(r);
      if (!n) return null;
      const i = this.cameraKeyframes.get(r);
      if (!i || i.length === 0)
        return n;
      const s = Zc(n, i, e);
      return {
        ...n,
        position: s.position,
        orientation: s.rotation,
        focalLength: s.focalLength,
        zoom: s.zoom,
        depthOfField: {
          ...n.depthOfField,
          focusDistance: s.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(r) {
      return this.activeCameraId ? this.getCameraAtFrame(this.activeCameraId, r ?? this.currentFrame) : null;
    },
    /**
     * Update viewport state
     */
    updateViewportState(r) {
      Object.assign(this.viewportState, r);
    },
    /**
     * Update view options
     */
    updateViewOptions(r) {
      Object.assign(this.viewOptions, r);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(r) {
      this.audioFile = r, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await Ok(
          r,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), this.propertyDriverSystem && this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis), console.log("[Weyl] Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        console.error("[Weyl] Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      Lk(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(r, e) {
      return this.audioAnalysis ? Kc(this.audioAnalysis, r, e ?? this.project.currentFrame) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(r, e) {
      const n = this.audioMappings.get(r) || [];
      n.push(e), this.audioMappings.set(r, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(r, e) {
      const n = this.audioMappings.get(r);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(r));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(r) {
      return this.audioMappings.get(r) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(r) {
      this.peakData = r, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(r);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(r) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = Jb(e, r);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(r) {
      this.audioReactiveMappings.push(r), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(r);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(r) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === r);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(r);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(r, e) {
      const n = this.audioReactiveMappings.find((i) => i.id === r);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(r, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(r, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(r, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(r) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(r ?? this.project.currentFrame) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(r) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === r || e.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(r, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValuesForLayerAtFrame(r, e) : /* @__PURE__ */ new Map();
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      return this.audioAnalysis ? e1(this.audioAnalysis, this.project.currentFrame) : !1;
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(r, e, n) {
      return Zk(r, this.snapConfig, e, {
        layers: this.layers,
        selectedLayerId: n,
        currentFrame: this.project.currentFrame,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return Jk(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return Qk(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(r) {
      this.snapConfig = { ...this.snapConfig, ...r };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(r) {
      const n = {
        grid: "snapToGrid",
        keyframes: "snapToKeyframes",
        beats: "snapToBeats",
        peaks: "snapToPeaks",
        layerBounds: "snapToLayerBounds",
        playhead: "snapToPlayhead"
      }[r];
      n && typeof this.snapConfig[n] == "boolean" && (this.snapConfig[n] = !this.snapConfig[n]);
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(r, e = {}) {
      const n = new Gk(e);
      this.pathAnimators.set(r, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(r, e) {
      const n = this.pathAnimators.get(r);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(r, e) {
      const n = this.pathAnimators.get(r);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(r) {
      this.pathAnimators.delete(r);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(r) {
      return this.pathAnimators.get(r);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      if (!this.audioAnalysis) return;
      const r = this.project.currentFrame, e = Kc(this.audioAnalysis, "amplitude", r), n = e1(this.audioAnalysis, r);
      for (const [i, s] of this.pathAnimators)
        s.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const r of this.pathAnimators.values())
        r.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new zk(this.audioAnalysis);
        for (const r of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(r);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new $k(), this.propertyDriverSystem.setPropertyGetter((r, e, n) => this.getPropertyValueAtFrame(r, e, n)), this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const r of this.propertyDrivers)
        this.propertyDriverSystem.addDriver(r);
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(r, e, n) {
      const i = this.project.layers.find((o) => o.id === r);
      if (!i) return null;
      const s = e.split(".");
      if (s[0] === "transform") {
        const o = i.transform;
        if (s[1] === "position") {
          const a = fn(o.position, n);
          if (s[2] === "x") return a.x;
          if (s[2] === "y") return a.y;
          if (s[2] === "z") return a.z ?? 0;
        }
        if (s[1] === "anchorPoint") {
          const a = fn(o.anchorPoint, n);
          if (s[2] === "x") return a.x;
          if (s[2] === "y") return a.y;
          if (s[2] === "z") return a.z ?? 0;
        }
        if (s[1] === "scale") {
          const a = fn(o.scale, n);
          if (s[2] === "x") return a.x;
          if (s[2] === "y") return a.y;
          if (s[2] === "z") return a.z ?? 100;
        }
        if (s[1] === "rotation")
          return fn(o.rotation, n);
        if (s[1] === "rotationX" && o.rotationX)
          return fn(o.rotationX, n);
        if (s[1] === "rotationY" && o.rotationY)
          return fn(o.rotationY, n);
        if (s[1] === "rotationZ" && o.rotationZ)
          return fn(o.rotationZ, n);
      }
      return s[0] === "opacity" ? fn(i.opacity, n) : null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(r) {
      if (!this.propertyDriverSystem)
        return /* @__PURE__ */ new Map();
      const e = this.project.layers.find((l) => l.id === r);
      if (!e) return /* @__PURE__ */ new Map();
      const n = /* @__PURE__ */ new Map(), i = this.project.currentFrame, s = fn(e.transform.position, i);
      n.set("transform.position.x", s.x), n.set("transform.position.y", s.y), n.set("transform.position.z", s.z ?? 0);
      const o = fn(e.transform.anchorPoint, i);
      n.set("transform.anchorPoint.x", o.x), n.set("transform.anchorPoint.y", o.y), n.set("transform.anchorPoint.z", o.z ?? 0);
      const a = fn(e.transform.scale, i);
      return n.set("transform.scale.x", a.x), n.set("transform.scale.y", a.y), n.set("transform.scale.z", a.z ?? 100), n.set("transform.rotation", fn(e.transform.rotation, i)), e.transform.rotationX && n.set("transform.rotationX", fn(e.transform.rotationX, i)), e.transform.rotationY && n.set("transform.rotationY", fn(e.transform.rotationY, i)), e.transform.rotationZ && n.set("transform.rotationZ", fn(e.transform.rotationZ, i)), n.set("opacity", fn(e.opacity, i)), this.propertyDriverSystem.evaluateLayerDrivers(r, i, n);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(r) {
      return this.propertyDriverSystem && !this.propertyDriverSystem.addDriver(r) ? (console.warn("[Store] Cannot add property driver: would create circular dependency"), !1) : (this.propertyDrivers.push(r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), !0);
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(r, e, n, i = {}) {
      const s = Xk(r, e, n, i);
      return this.addPropertyDriver(s), s;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(r, e, n, i, s = {}) {
      const o = Yk(
        r,
        e,
        n,
        i,
        s
      );
      return this.addPropertyDriver(o) ? o : null;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(r) {
      const e = this.propertyDrivers.findIndex((n) => n.id === r);
      e >= 0 && this.propertyDrivers.splice(e, 1), this.propertyDriverSystem && this.propertyDriverSystem.removeDriver(r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(r, e) {
      const n = this.propertyDrivers.find((i) => i.id === r);
      n && Object.assign(n, e), this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(r, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(r) {
      return this.propertyDrivers.filter((e) => e.targetLayerId === r);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(r) {
      const e = this.propertyDrivers.find((n) => n.id === r);
      e && (e.enabled = !e.enabled, this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(r, { enabled: e.enabled }), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
  }
});
async function i1(r) {
  try {
    const e = await r.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function eR() {
  if ("gpu" in navigator)
    try {
      const i = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (i) {
        let s = "";
        if ("info" in i) {
          const o = i.info;
          s = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return s.includes("RTX 50") || s.toLowerCase().includes("blackwell") || s.includes("B100") || s.includes("B200") ? {
          tier: "blackwell",
          vram: await i1(i),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await i1(i),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      console.warn("[Weyl] WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), i = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return console.log("[Weyl] WebGL renderer:", i), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const tR = { class: "project-panel" }, nR = { class: "panel-header" }, iR = { class: "header-actions" }, sR = {
  key: 0,
  class: "search-bar"
}, rR = { class: "panel-content" }, oR = { class: "folder-tree" }, aR = ["onClick", "onDblclick"], lR = ["onClick"], cR = { class: "folder-name" }, uR = { class: "item-count" }, hR = {
  key: 0,
  class: "folder-contents"
}, dR = ["onClick", "onDblclick", "onDragstart"], fR = { class: "item-icon" }, pR = { class: "item-name" }, mR = { class: "item-info" }, gR = ["onClick", "onDblclick", "onDragstart"], vR = { class: "item-icon" }, yR = { class: "item-name" }, _R = { class: "item-info" }, xR = {
  key: 0,
  class: "empty-state"
}, bR = {
  key: 1,
  class: "panel-footer"
}, wR = { class: "item-details" }, SR = { class: "detail-label" }, MR = { class: "detail-info" }, CR = /* @__PURE__ */ jt({
  __name: "ProjectPanel",
  setup(r) {
    const e = _n(), n = Ce(null), i = Ce(!1), s = Ce(""), o = Ce(null), a = Ce(["compositions", "footage"]), l = Ce([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), c = Ce([]), u = Xe(() => {
      if (!s.value) return l.value;
      const C = s.value.toLowerCase();
      return l.value.map((E) => ({
        ...E,
        items: E.items.filter(
          (T) => T.name.toLowerCase().includes(C)
        )
      })).filter((E) => E.items.length > 0 || E.name.toLowerCase().includes(C));
    }), h = Xe(() => {
      if (!s.value) return c.value;
      const C = s.value.toLowerCase();
      return c.value.filter(
        (E) => E.name.toLowerCase().includes(C)
      );
    }), d = Xe(() => {
      if (!o.value) return null;
      for (const E of l.value) {
        const T = E.items.find((w) => w.id === o.value);
        if (T)
          return {
            name: T.name,
            info: x(T)
          };
      }
      const C = c.value.find((E) => E.id === o.value);
      return C ? {
        name: C.name,
        info: x(C)
      } : null;
    });
    function p(C) {
      const E = a.value.indexOf(C);
      E >= 0 ? a.value.splice(E, 1) : a.value.push(C);
    }
    function f(C) {
      o.value = C;
    }
    function m(C) {
      C.type === "composition" && console.log("Opening composition:", C.name);
    }
    function _() {
      console.log("Create new item");
    }
    function g() {
      var C;
      (C = n.value) == null || C.click();
    }
    async function v(C) {
      const E = C.target, T = E.files;
      if (!(!T || T.length === 0)) {
        for (const w of Array.from(T)) {
          const A = S(w), O = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: w.name,
            type: A
          };
          if (A === "audio")
            e.loadAudio(w);
          else if (w.type.startsWith("video/"))
            try {
              const D = await e.createVideoLayer(w, !0);
              O.id = D.id, O.width = e.width, O.height = e.height, O.duration = e.frameCount, O.fps = e.fps, console.log("[ProjectPanel] Video layer created:", D.id, D.name);
            } catch (D) {
              console.error("[ProjectPanel] Failed to import video:", D);
              continue;
            }
          else if (w.type.startsWith("image/")) {
            const D = URL.createObjectURL(w), L = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            e.project.assets[L] = {
              id: L,
              type: "image",
              source: "file",
              width: 0,
              // Will be updated when image loads
              height: 0,
              data: D
            };
            const P = e.createLayer("image", w.name.replace(/\.[^.]+$/, ""));
            P.data = { assetId: L }, O.id = P.id;
          }
          const U = l.value.find((D) => D.id === "footage");
          U ? U.items.push(O) : c.value.push(O), console.log("[ProjectPanel] Imported:", w.name, A);
        }
        E.value = "";
      }
    }
    function S(C) {
      const E = C.type;
      return E.startsWith("audio/") ? "audio" : (E.startsWith("video/") || E.startsWith("image/"), "footage");
    }
    function b(C) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[C] || "";
    }
    function x(C) {
      if (C.type === "composition" || C.type === "footage") {
        const E = [];
        if (C.width && C.height && E.push(`${C.width}${C.height}`), C.fps && E.push(`${C.fps}fps`), C.duration) {
          const T = C.duration / (C.fps || 30);
          E.push(`${T.toFixed(1)}s`);
        }
        return E.join("  ");
      }
      return "";
    }
    function M(C, E) {
      var T;
      (T = E.dataTransfer) == null || T.setData("application/project-item", JSON.stringify(C));
    }
    return (C, E) => (ie(), ue("div", tR, [
      y("div", nR, [
        E[2] || (E[2] = y("span", { class: "panel-title" }, "Project", -1)),
        y("div", iR, [
          y("button", {
            onClick: g,
            title: "Import File (Ctrl+I)"
          }, ""),
          y("button", {
            onClick: _,
            title: "New Item"
          }, "+"),
          y("button", {
            onClick: E[0] || (E[0] = (T) => i.value = !i.value),
            title: "Search"
          }, "")
        ])
      ]),
      y("input", {
        ref_key: "fileInputRef",
        ref: n,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: v
      }, null, 544),
      i.value ? (ie(), ue("div", sR, [
        wt(y("input", {
          type: "text",
          "onUpdate:modelValue": E[1] || (E[1] = (T) => s.value = T),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [Tn, s.value]
        ])
      ])) : Ne("", !0),
      y("div", rR, [
        y("div", oR, [
          (ie(!0), ue(nt, null, pt(u.value, (T) => (ie(), ue("div", {
            key: T.id,
            class: "folder-item"
          }, [
            y("div", {
              class: Ye(["folder-header", { selected: o.value === T.id }]),
              onClick: (w) => f(T.id),
              onDblclick: (w) => p(T.id)
            }, [
              y("span", {
                class: "expand-icon",
                onClick: Rt((w) => p(T.id), ["stop"])
              }, Ae(a.value.includes(T.id) ? "" : ""), 9, lR),
              E[3] || (E[3] = y("span", { class: "folder-icon" }, "", -1)),
              y("span", cR, Ae(T.name), 1),
              y("span", uR, Ae(T.items.length), 1)
            ], 42, aR),
            a.value.includes(T.id) ? (ie(), ue("div", hR, [
              (ie(!0), ue(nt, null, pt(T.items, (w) => (ie(), ue("div", {
                key: w.id,
                class: Ye(["project-item", { selected: o.value === w.id }]),
                onClick: (A) => f(w.id),
                onDblclick: (A) => m(w),
                draggable: "true",
                onDragstart: (A) => M(w, A)
              }, [
                y("span", fR, Ae(b(w.type)), 1),
                y("span", pR, Ae(w.name), 1),
                y("span", mR, Ae(x(w)), 1)
              ], 42, dR))), 128))
            ])) : Ne("", !0)
          ]))), 128)),
          (ie(!0), ue(nt, null, pt(h.value, (T) => (ie(), ue("div", {
            key: T.id,
            class: Ye(["project-item", { selected: o.value === T.id }]),
            onClick: (w) => f(T.id),
            onDblclick: (w) => m(T),
            draggable: "true",
            onDragstart: (w) => M(T, w)
          }, [
            y("span", vR, Ae(b(T.type)), 1),
            y("span", yR, Ae(T.name), 1),
            y("span", _R, Ae(x(T)), 1)
          ], 42, gR))), 128))
        ]),
        c.value.length === 0 ? (ie(), ue("div", xR, [...E[4] || (E[4] = [
          y("p", null, "No items in project", -1),
          y("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Ne("", !0)
      ]),
      d.value ? (ie(), ue("div", bR, [
        y("div", wR, [
          y("span", SR, Ae(d.value.name), 1),
          y("span", MR, Ae(d.value.info), 1)
        ])
      ])) : Ne("", !0)
    ]));
  }
}), Yt = (r, e) => {
  const n = r.__vccOpts || r;
  for (const [i, s] of e)
    n[i] = s;
  return n;
}, TR = /* @__PURE__ */ Yt(CR, [["__scopeId", "data-v-b35e7287"]]), ER = { class: "effects-panel" }, AR = { class: "panel-header" }, PR = { class: "header-actions" }, DR = { class: "panel-content" }, kR = { class: "tabs" }, RR = {
  key: 0,
  class: "effects-list"
}, LR = ["onClick"], IR = { class: "expand-icon" }, OR = { class: "category-icon" }, FR = { class: "category-name" }, UR = { class: "effect-count" }, zR = {
  key: 0,
  class: "category-effects"
}, BR = ["onDblclick", "onDragstart"], NR = { class: "effect-name" }, VR = ["onClick", "title"], GR = {
  key: 1,
  class: "presets-list"
}, HR = ["onClick"], WR = { class: "expand-icon" }, jR = { class: "category-name" }, $R = { class: "preset-count" }, XR = {
  key: 0,
  class: "category-presets"
}, YR = ["onDblclick", "onDragstart"], qR = { class: "preset-info" }, ZR = { class: "preset-name" }, KR = { class: "preset-description" }, JR = {
  key: 2,
  class: "favorites-list"
}, QR = {
  key: 0,
  class: "empty-favorites"
}, eL = ["onDblclick", "onDragstart"], tL = { class: "category-badge" }, nL = { class: "effect-name" }, iL = ["onClick"], sL = /* @__PURE__ */ jt({
  __name: "EffectsPanel",
  setup(r) {
    const e = _n(), n = Ce("effects"), i = Ce(""), s = Ce(["blur-sharpen", "color-correction"]), o = Ce(["Fade", "Scale"]), a = Ce([]);
    Xn(() => {
      const x = localStorage.getItem("effect-favorites");
      if (x)
        try {
          a.value = JSON.parse(x);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const c = Xe(() => Object.entries(Md).map(([x, M]) => ({
      key: x,
      name: M.name,
      category: M.category,
      description: M.description
    }))), u = Xe(() => {
      const x = i.value.toLowerCase();
      return Object.entries(ng).map(([M, C]) => {
        const E = c.value.filter((T) => !(T.category !== M || x && !T.name.toLowerCase().includes(x)));
        return {
          key: M,
          label: C.label,
          icon: C.icon,
          effects: E
        };
      }).filter((M) => M.effects.length > 0);
    }), h = Xe(() => {
      const x = i.value.toLowerCase(), M = {};
      for (const C of jk)
        x && !C.name.toLowerCase().includes(x) || (M[C.category] || (M[C.category] = []), M[C.category].push(C));
      return Object.entries(M).map(([C, E]) => ({
        category: C,
        presets: E
      }));
    }), d = Xe(() => c.value.filter((x) => a.value.includes(x.key)));
    function p(x) {
      const M = s.value.indexOf(x);
      M >= 0 ? s.value.splice(M, 1) : s.value.push(x);
    }
    function f(x) {
      const M = o.value.indexOf(x);
      M >= 0 ? o.value.splice(M, 1) : o.value.push(x);
    }
    function m(x) {
      const M = a.value.indexOf(x);
      M >= 0 ? a.value.splice(M, 1) : a.value.push(x), l();
    }
    function _(x) {
      var M;
      return ((M = ng[x]) == null ? void 0 : M.icon) || "?";
    }
    function g(x) {
      const M = e.selectedLayer;
      if (!M) {
        console.warn("No layer selected to apply effect");
        return;
      }
      e.addEffectToLayer(M.id, x);
    }
    function v(x) {
      if (!e.selectedLayer) {
        console.warn("No layer selected to apply preset");
        return;
      }
      console.log("Applying preset:", x.name);
    }
    function S(x, M) {
      var C;
      (C = M.dataTransfer) == null || C.setData("application/effect", x);
    }
    function b(x, M) {
      var C;
      (C = M.dataTransfer) == null || C.setData("application/preset", JSON.stringify(x));
    }
    return (x, M) => (ie(), ue("div", ER, [
      y("div", AR, [
        M[4] || (M[4] = y("span", { class: "panel-title" }, "Effects & Presets", -1)),
        y("div", PR, [
          wt(y("input", {
            type: "text",
            "onUpdate:modelValue": M[0] || (M[0] = (C) => i.value = C),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [Tn, i.value]
          ])
        ])
      ]),
      y("div", DR, [
        y("div", kR, [
          y("button", {
            class: Ye({ active: n.value === "effects" }),
            onClick: M[1] || (M[1] = (C) => n.value = "effects")
          }, " Effects ", 2),
          y("button", {
            class: Ye({ active: n.value === "presets" }),
            onClick: M[2] || (M[2] = (C) => n.value = "presets")
          }, " Presets ", 2),
          y("button", {
            class: Ye({ active: n.value === "favorites" }),
            onClick: M[3] || (M[3] = (C) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (ie(), ue("div", RR, [
          (ie(!0), ue(nt, null, pt(u.value, (C) => (ie(), ue("div", {
            key: C.key,
            class: "effect-category"
          }, [
            y("div", {
              class: "category-header",
              onClick: (E) => p(C.key)
            }, [
              y("span", IR, Ae(s.value.includes(C.key) ? "" : ""), 1),
              y("span", OR, Ae(C.icon), 1),
              y("span", FR, Ae(C.label), 1),
              y("span", UR, Ae(C.effects.length), 1)
            ], 8, LR),
            s.value.includes(C.key) ? (ie(), ue("div", zR, [
              (ie(!0), ue(nt, null, pt(C.effects, (E) => (ie(), ue("div", {
                key: E.key,
                class: Ye(["effect-item", { favorite: a.value.includes(E.key) }]),
                onDblclick: (T) => g(E.key),
                onDragstart: (T) => S(E.key, T),
                draggable: "true"
              }, [
                y("span", NR, Ae(E.name), 1),
                y("button", {
                  class: "favorite-btn",
                  onClick: Rt((T) => m(E.key), ["stop"]),
                  title: a.value.includes(E.key) ? "Remove from favorites" : "Add to favorites"
                }, Ae(a.value.includes(E.key) ? "" : ""), 9, VR)
              ], 42, BR))), 128))
            ])) : Ne("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (ie(), ue("div", GR, [
          (ie(!0), ue(nt, null, pt(h.value, (C) => (ie(), ue("div", {
            key: C.category,
            class: "preset-category"
          }, [
            y("div", {
              class: "category-header",
              onClick: (E) => f(C.category)
            }, [
              y("span", WR, Ae(o.value.includes(C.category) ? "" : ""), 1),
              y("span", jR, Ae(C.category), 1),
              y("span", $R, Ae(C.presets.length), 1)
            ], 8, HR),
            o.value.includes(C.category) ? (ie(), ue("div", XR, [
              (ie(!0), ue(nt, null, pt(C.presets, (E) => (ie(), ue("div", {
                key: E.id,
                class: "preset-item",
                onDblclick: (T) => v(E),
                onDragstart: (T) => b(E, T),
                draggable: "true"
              }, [
                M[5] || (M[5] = y("div", { class: "preset-preview" }, [
                  y("span", { class: "preview-icon" }, "")
                ], -1)),
                y("div", qR, [
                  y("span", ZR, Ae(E.name), 1),
                  y("span", KR, Ae(E.description), 1)
                ])
              ], 40, YR))), 128))
            ])) : Ne("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (ie(), ue("div", JR, [
          d.value.length === 0 ? (ie(), ue("div", QR, [...M[6] || (M[6] = [
            y("p", null, "No favorites yet", -1),
            y("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Ne("", !0),
          (ie(!0), ue(nt, null, pt(d.value, (C) => (ie(), ue("div", {
            key: C.key,
            class: "effect-item",
            onDblclick: (E) => g(C.key),
            onDragstart: (E) => S(C.key, E),
            draggable: "true"
          }, [
            y("span", tL, Ae(_(C.category)), 1),
            y("span", nL, Ae(C.name), 1),
            y("button", {
              class: "favorite-btn active",
              onClick: Rt((E) => m(C.key), ["stop"])
            }, "  ", 8, iL)
          ], 40, eL))), 128))
        ])) : Ne("", !0)
      ]),
      M[7] || (M[7] = y("div", { class: "panel-footer" }, [
        y("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), rL = /* @__PURE__ */ Yt(sL, [["__scopeId", "data-v-5ceccb10"]]), oL = ["value", "min", "max", "step", "disabled"], aL = {
  key: 1,
  class: "scrub-unit"
}, lL = /* @__PURE__ */ jt({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce(!1), o = Ce(0), a = Ce(0), l = Xe(() => n.default ?? n.modelValue), c = Xe(() => n.default !== void 0), u = Xe(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(b) {
      return Math.max(n.min, Math.min(n.max, b));
    }
    function d(b) {
      const x = Math.pow(10, n.precision);
      return Math.round(b * x) / x;
    }
    function p(b) {
      n.disabled || (s.value = !0, o.value = b.clientX, a.value = n.modelValue, document.addEventListener("mousemove", f), document.addEventListener("mouseup", m), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function f(b) {
      const x = b.clientX - o.value;
      let M = n.sensitivity;
      b.shiftKey && (M *= 10), (b.ctrlKey || b.metaKey) && (M *= 0.1);
      const C = x * n.step * M * 0.5, E = d(h(a.value + C));
      E !== n.modelValue && i("update:modelValue", E);
    }
    function m() {
      s.value = !1, document.removeEventListener("mousemove", f), document.removeEventListener("mouseup", m), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(b) {
      const x = b.target, M = parseFloat(x.value);
      isNaN(M) || i("update:modelValue", d(h(M)));
    }
    function g(b) {
      if (n.disabled) return;
      let x = 0;
      b.key === "ArrowUp" ? x = n.step : b.key === "ArrowDown" && (x = -n.step), x !== 0 && (b.preventDefault(), b.shiftKey && (x *= 10), (b.ctrlKey || b.metaKey) && (x *= 0.1), i("update:modelValue", d(h(n.modelValue + x))));
    }
    function v(b) {
      const x = b.target, M = parseFloat(x.value);
      isNaN(M) && (x.value = u.value.toString());
    }
    function S() {
      n.default !== void 0 && i("update:modelValue", n.default);
    }
    return (b, x) => (ie(), ue("div", {
      class: Ye(["scrubable-number", { disabled: r.disabled }])
    }, [
      r.label ? (ie(), ue("label", {
        key: 0,
        class: Ye(["scrub-label", { scrubbing: s.value }]),
        onMousedown: p
      }, Ae(r.label), 35)) : Ne("", !0),
      y("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: r.min,
        max: r.max,
        step: r.step,
        disabled: r.disabled,
        onInput: _,
        onKeydown: g,
        onBlur: v
      }, null, 40, oL),
      r.unit ? (ie(), ue("span", aL, Ae(r.unit), 1)) : Ne("", !0),
      c.value && r.modelValue !== l.value ? (ie(), ue("button", {
        key: 2,
        class: "reset-btn",
        onClick: S,
        title: "Reset to default"
      }, [...x[0] || (x[0] = [
        y("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Ne("", !0)
    ], 2));
  }
}), rt = /* @__PURE__ */ Yt(lL, [["__scopeId", "data-v-2a930cf0"]]), cL = ["value", "min", "max", "step", "disabled"], uL = {
  key: 2,
  class: "slider-unit"
}, hL = /* @__PURE__ */ jt({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce(null), o = Ce(!1), a = Ce(!1), l = Ce(0), c = Ce(0), u = Xe(() => {
      const C = n.max - n.min;
      return C === 0 ? 0 : (n.modelValue - n.min) / C * 100;
    }), h = Xe(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(C) {
      return Math.max(n.min, Math.min(n.max, C));
    }
    function p(C) {
      const E = Math.pow(10, n.precision);
      return Math.round(C * E) / E;
    }
    function f(C) {
      n.disabled || (o.value = !0, l.value = C.clientX, c.value = n.modelValue, document.addEventListener("mousemove", m), document.addEventListener("mouseup", _), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function m(C) {
      const E = C.clientX - l.value, T = n.max - n.min;
      let w = 1;
      C.shiftKey && (w *= 10), (C.ctrlKey || C.metaKey) && (w *= 0.1);
      const A = E / 200 * T * w, O = p(d(c.value + A));
      O !== n.modelValue && i("update:modelValue", O);
    }
    function _() {
      o.value = !1, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", _), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function g(C) {
      if (n.disabled || !s.value) return;
      const E = s.value.getBoundingClientRect(), T = (C.clientX - E.left) / E.width, w = n.min + T * (n.max - n.min);
      i("update:modelValue", p(d(w)));
    }
    function v(C) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", S), document.addEventListener("mouseup", b), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function S(C) {
      if (!s.value) return;
      const E = s.value.getBoundingClientRect(), T = (C.clientX - E.left) / E.width, w = n.min + Math.max(0, Math.min(1, T)) * (n.max - n.min);
      i("update:modelValue", p(d(w)));
    }
    function b() {
      a.value = !1, document.removeEventListener("mousemove", S), document.removeEventListener("mouseup", b), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function x(C) {
      const E = C.target, T = parseFloat(E.value);
      isNaN(T) || i("update:modelValue", p(d(T)));
    }
    function M(C) {
      const E = C.target, T = parseFloat(E.value);
      isNaN(T) && (E.value = h.value.toString());
    }
    return (C, E) => (ie(), ue("div", {
      class: Ye(["slider-input", { disabled: r.disabled }])
    }, [
      r.label ? (ie(), ue("label", {
        key: 0,
        class: Ye(["slider-label", { scrubbing: o.value }]),
        onMousedown: f
      }, Ae(r.label), 35)) : Ne("", !0),
      y("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: s,
        onMousedown: g
      }, [
        y("div", {
          class: "slider-fill",
          style: Ct({ width: u.value + "%", background: r.gradient || void 0 })
        }, null, 4),
        y("div", {
          class: "slider-thumb",
          style: Ct({ left: u.value + "%" }),
          onMousedown: Rt(v, ["stop"])
        }, null, 36)
      ], 544),
      r.showValue ? (ie(), ue("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: h.value,
        min: r.min,
        max: r.max,
        step: r.step,
        disabled: r.disabled,
        onInput: x,
        onBlur: M
      }, null, 40, cL)) : Ne("", !0),
      r.unit ? (ie(), ue("span", uL, Ae(r.unit), 1)) : Ne("", !0)
    ], 2));
  }
}), Di = /* @__PURE__ */ Yt(hL, [["__scopeId", "data-v-9dd40416"]]), dL = { class: "dial-marks" }, fL = {
  key: 0,
  class: "angle-value"
}, pL = ["value", "disabled"], mL = /* @__PURE__ */ jt({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce(null), o = Ce(!1), a = Xe(() => Math.round(n.modelValue * 10) / 10);
    function l(m) {
      return (m % 360 + 360) % 360;
    }
    function c(m) {
      n.disabled || (o.value = !0, h(m), document.addEventListener("mousemove", u), document.addEventListener("mouseup", d), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(m) {
      o.value && h(m);
    }
    function h(m) {
      if (!s.value) return;
      const _ = s.value.getBoundingClientRect(), g = _.left + _.width / 2, v = _.top + _.height / 2, S = m.clientX - g, b = m.clientY - v;
      let x = Math.atan2(S, -b) * (180 / Math.PI);
      x = l(x), m.shiftKey && (x = Math.round(x / 45) * 45), i("update:modelValue", x);
    }
    function d() {
      o.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", d), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function p(m) {
      const _ = m.target, g = parseFloat(_.value);
      isNaN(g) || i("update:modelValue", l(g));
    }
    function f(m) {
      const _ = m.target, g = parseFloat(_.value);
      isNaN(g) && (_.value = a.value.toString());
    }
    return (m, _) => (ie(), ue("div", {
      class: Ye(["angle-dial", { disabled: r.disabled }])
    }, [
      y("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: s,
        style: Ct({ width: r.size + "px", height: r.size + "px" }),
        onMousedown: c
      }, [
        _[0] || (_[0] = y("div", { class: "dial-ring" }, null, -1)),
        _[1] || (_[1] = y("div", { class: "dial-center" }, null, -1)),
        y("div", {
          class: "dial-indicator",
          style: Ct({ transform: `rotate(${r.modelValue}deg)` })
        }, null, 4),
        y("div", dL, [
          (ie(), ue(nt, null, pt(8, (g) => y("div", {
            class: "dial-mark",
            key: g,
            style: Ct({ transform: `rotate(${g * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      r.showValue ? (ie(), ue("div", fL, [
        y("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: r.disabled,
          onInput: p,
          onBlur: f
        }, null, 40, pL),
        _[2] || (_[2] = y("span", { class: "angle-unit" }, "", -1))
      ])) : Ne("", !0)
    ], 2));
  }
}), fv = /* @__PURE__ */ Yt(mL, [["__scopeId", "data-v-04a5caf6"]]);
function s1(r, e, n) {
  r = (r % 360 + 360) % 360;
  const i = n * e, s = i * (1 - Math.abs(r / 60 % 2 - 1)), o = n - i;
  let a = 0, l = 0, c = 0;
  return r < 60 ? (a = i, l = s, c = 0) : r < 120 ? (a = s, l = i, c = 0) : r < 180 ? (a = 0, l = i, c = s) : r < 240 ? (a = 0, l = s, c = i) : r < 300 ? (a = s, l = 0, c = i) : (a = i, l = 0, c = s), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function nr(r, e, n) {
  r /= 255, e /= 255, n /= 255;
  const i = Math.max(r, e, n), s = Math.min(r, e, n), o = i - s;
  let a = 0;
  const l = i === 0 ? 0 : o / i, c = i;
  if (o !== 0)
    switch (i) {
      case r:
        a = ((e - n) / o + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - r) / o + 2) * 60;
        break;
      case n:
        a = ((r - e) / o + 4) * 60;
        break;
    }
  return [a, l, c];
}
function nh(r, e, n) {
  r = (r % 360 + 360) % 360;
  const i = (1 - Math.abs(2 * n - 1)) * e, s = i * (1 - Math.abs(r / 60 % 2 - 1)), o = n - i / 2;
  let a = 0, l = 0, c = 0;
  return r < 60 ? (a = i, l = s, c = 0) : r < 120 ? (a = s, l = i, c = 0) : r < 180 ? (a = 0, l = i, c = s) : r < 240 ? (a = 0, l = s, c = i) : r < 300 ? (a = s, l = 0, c = i) : (a = i, l = 0, c = s), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function Eo(r, e, n) {
  r /= 255, e /= 255, n /= 255;
  const i = Math.max(r, e, n), s = Math.min(r, e, n), o = (i + s) / 2;
  let a = 0, l = 0;
  if (i !== s) {
    const c = i - s;
    switch (l = o > 0.5 ? c / (2 - i - s) : c / (i + s), i) {
      case r:
        a = ((e - n) / c + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - r) / c + 2) * 60;
        break;
      case n:
        a = ((r - e) / c + 4) * 60;
        break;
    }
  }
  return [a, l, o];
}
function gL(r) {
  if (r = r.replace(/^#/, ""), r.length === 3 && (r = r[0] + r[0] + r[1] + r[1] + r[2] + r[2]), r.length === 6 || r.length === 8) {
    const e = parseInt(r.slice(0, 2), 16), n = parseInt(r.slice(2, 4), 16), i = parseInt(r.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(i))
      return [e, n, i];
  }
  return null;
}
function vL(r) {
  if (r = r.replace(/^#/, ""), r.length === 3 && (r = r[0] + r[0] + r[1] + r[1] + r[2] + r[2] + "ff"), r.length === 6 && (r = r + "ff"), r.length === 8) {
    const e = parseInt(r.slice(0, 2), 16), n = parseInt(r.slice(2, 4), 16), i = parseInt(r.slice(4, 6), 16), s = parseInt(r.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(i) && !isNaN(s))
      return [e, n, i, s];
  }
  return null;
}
function yL(r, e, n) {
  const i = (s) => Math.max(0, Math.min(255, Math.round(s))).toString(16).padStart(2, "0");
  return `#${i(r)}${i(e)}${i(n)}`;
}
function _L(r, e, n, i) {
  const s = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${s(r)}${s(e)}${s(n)}${s(i * 255)}`;
}
const xL = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], bL = {
  key: 0,
  class: "checkerboard"
}, wL = ["value"], SL = { class: "mode-tabs" }, ML = ["onClick"], CL = {
  key: 1,
  class: "rgb-sliders"
}, TL = { class: "color-slider" }, EL = ["value"], AL = { class: "color-slider" }, PL = ["value"], DL = { class: "color-slider" }, kL = ["value"], RL = {
  key: 2,
  class: "hsl-sliders"
}, LL = { class: "color-slider" }, IL = ["value"], OL = { class: "color-slider" }, FL = ["value"], UL = { class: "color-slider" }, zL = ["value"], BL = {
  key: 3,
  class: "alpha-slider"
}, NL = ["value"], VL = { class: "swatches-section" }, GL = { class: "swatches-grid" }, HL = ["onClick"], WL = {
  key: 4,
  class: "recent-section"
}, jL = { class: "swatches-grid" }, $L = ["onClick"], XL = /* @__PURE__ */ jt({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = ["hsv", "rgb", "hsl"], o = Ce(null), a = Ce(null), l = Ce(null), c = Ce(null), u = Ce(null), h = Ce(!1), d = Ce("hsv"), p = Ce(1), f = Ce([]), m = Ce([255, 255, 255]), _ = Ce([0, 0, 1]), g = Ce([0, 0, 1]), v = Xe(() => n.swatches || xL), S = Xe(() => {
      if (!o.value || !n.teleport) return {};
      const ee = o.value.getBoundingClientRect();
      return {
        top: `${ee.bottom + 4}px`,
        left: `${ee.left}px`
      };
    });
    function b(ee) {
      const Z = gL(ee);
      Z && (m.value = Z, _.value = nr(Z[0], Z[1], Z[2]), g.value = Eo(Z[0], Z[1], Z[2]));
    }
    function x() {
      const ee = yL(m.value[0], m.value[1], m.value[2]);
      i("update:modelValue", ee);
    }
    function M() {
      h.value = !h.value;
    }
    function C() {
      h.value && (h.value = !1, E(n.modelValue));
    }
    function E(ee) {
      const Z = f.value.indexOf(ee);
      Z !== -1 && f.value.splice(Z, 1), f.value.unshift(ee), f.value.length > n.recentCount && f.value.pop();
    }
    function T(ee) {
      i("update:modelValue", ee);
    }
    let w = !1;
    function A(ee) {
      w = !0, U(ee), document.addEventListener("mousemove", O), document.addEventListener("mouseup", D);
    }
    function O(ee) {
      w && U(ee);
    }
    function U(ee) {
      if (!l.value) return;
      const Z = l.value.getBoundingClientRect(), N = Math.max(0, Math.min(1, (ee.clientX - Z.left) / Z.width)), j = Math.max(0, Math.min(1, 1 - (ee.clientY - Z.top) / Z.height));
      _.value = [_.value[0], N, j], m.value = s1(_.value[0], _.value[1], _.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]), x();
    }
    function D() {
      w = !1, document.removeEventListener("mousemove", O), document.removeEventListener("mouseup", D);
    }
    let L = !1;
    function P(ee) {
      L = !0, ce(ee), document.addEventListener("mousemove", V), document.addEventListener("mouseup", q);
    }
    function V(ee) {
      L && ce(ee);
    }
    function ce(ee) {
      if (!c.value) return;
      const Z = c.value.getBoundingClientRect(), N = Math.max(0, Math.min(360, (ee.clientX - Z.left) / Z.width * 360));
      _.value = [N, _.value[1], _.value[2]], m.value = s1(_.value[0], _.value[1], _.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]), x();
    }
    function q() {
      L = !1, document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", q);
    }
    let oe = null, ne = null;
    function $(ee, Z) {
      oe = ee;
      const N = Z.target.closest(".slider-track");
      N && (ne = N.getBoundingClientRect(), se(Z), document.addEventListener("mousemove", J), document.addEventListener("mouseup", le));
    }
    function J(ee) {
      oe && se(ee);
    }
    function se(ee) {
      if (!ne || !oe) return;
      const Z = Math.max(0, Math.min(1, (ee.clientX - ne.left) / ne.width));
      switch (oe) {
        case "r":
          m.value = [Math.round(Z * 255), m.value[1], m.value[2]], _.value = nr(m.value[0], m.value[1], m.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]);
          break;
        case "g":
          m.value = [m.value[0], Math.round(Z * 255), m.value[2]], _.value = nr(m.value[0], m.value[1], m.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]);
          break;
        case "b":
          m.value = [m.value[0], m.value[1], Math.round(Z * 255)], _.value = nr(m.value[0], m.value[1], m.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]);
          break;
        case "h":
          g.value = [Z * 360, g.value[1], g.value[2]], m.value = nh(g.value[0], g.value[1], g.value[2]), _.value = nr(m.value[0], m.value[1], m.value[2]);
          break;
        case "s":
          g.value = [g.value[0], Z, g.value[2]], m.value = nh(g.value[0], g.value[1], g.value[2]), _.value = nr(m.value[0], m.value[1], m.value[2]);
          break;
        case "l":
          g.value = [g.value[0], g.value[1], Z], m.value = nh(g.value[0], g.value[1], g.value[2]), _.value = nr(m.value[0], m.value[1], m.value[2]);
          break;
      }
      x();
    }
    function le() {
      oe = null, ne = null, document.removeEventListener("mousemove", J), document.removeEventListener("mouseup", le);
    }
    let re = !1;
    function ye(ee) {
      re = !0, K(ee), document.addEventListener("mousemove", H), document.addEventListener("mouseup", G);
    }
    function H(ee) {
      re && K(ee);
    }
    function K(ee) {
      if (!u.value) return;
      const Z = u.value.getBoundingClientRect();
      p.value = Math.max(0, Math.min(1, (ee.clientX - Z.left) / Z.width));
    }
    function G() {
      re = !1, document.removeEventListener("mousemove", H), document.removeEventListener("mouseup", G);
    }
    function R(ee) {
      let N = ee.target.value.trim();
      N.startsWith("#") || (N = "#" + N), /^#[0-9a-f]{6}$/i.test(N) && i("update:modelValue", N.toLowerCase());
    }
    function z(ee) {
      const Z = ee.target;
      Z.value = n.modelValue;
    }
    function I(ee, Z) {
      const N = Z.target, j = Math.max(0, Math.min(255, parseInt(N.value) || 0)), te = [...m.value];
      te[ee] = j, m.value = te, _.value = nr(m.value[0], m.value[1], m.value[2]), g.value = Eo(m.value[0], m.value[1], m.value[2]), x();
    }
    function Q(ee, Z) {
      const N = Z.target;
      let j = parseFloat(N.value) || 0;
      ee === 0 ? (j = Math.max(0, Math.min(360, j)), g.value = [j, g.value[1], g.value[2]]) : (j = Math.max(0, Math.min(100, j)) / 100, ee === 1 ? g.value = [g.value[0], j, g.value[2]] : g.value = [g.value[0], g.value[1], j]), m.value = nh(g.value[0], g.value[1], g.value[2]), _.value = nr(m.value[0], m.value[1], m.value[2]), x();
    }
    function X(ee) {
      const Z = ee.target;
      p.value = Math.max(0, Math.min(100, parseInt(Z.value) || 0)) / 100;
    }
    function k(ee) {
      o.value && !o.value.contains(ee.target) && a.value && !a.value.contains(ee.target) && C();
    }
    return At(() => n.modelValue, (ee) => {
      b(ee);
    }, { immediate: !0 }), Xn(() => {
      document.addEventListener("mousedown", k);
    }), Ni(() => {
      document.removeEventListener("mousedown", k);
    }), (ee, Z) => (ie(), ue("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: o
    }, [
      y("button", {
        class: "color-swatch",
        style: Ct({ backgroundColor: r.modelValue }),
        onClick: M
      }, [
        r.alpha ? (ie(), ue("span", bL)) : Ne("", !0)
      ], 4),
      y("input", {
        type: "text",
        class: "hex-input",
        value: r.modelValue,
        onInput: R,
        onBlur: z,
        onKeydown: Z[0] || (Z[0] = zg((N) => N.target.blur(), ["enter"]))
      }, null, 40, wL),
      (ie(), Et(sm, {
        to: "body",
        disabled: !r.teleport
      }, [
        h.value ? (ie(), ue("div", {
          key: 0,
          class: "picker-panel",
          style: Ct(S.value),
          ref_key: "panelRef",
          ref: a
        }, [
          y("div", SL, [
            (ie(), ue(nt, null, pt(s, (N) => y("button", {
              key: N,
              class: Ye({ active: d.value === N }),
              onClick: (j) => d.value = N
            }, Ae(N.toUpperCase()), 11, ML)), 64))
          ]),
          d.value === "hsv" ? (ie(), ue(nt, { key: 0 }, [
            y("div", {
              class: "sv-square",
              style: Ct({ backgroundColor: `hsl(${_.value[0]}, 100%, 50%)` }),
              onMousedown: A,
              ref_key: "svSquareRef",
              ref: l
            }, [
              Z[13] || (Z[13] = y("div", { class: "sv-white" }, null, -1)),
              Z[14] || (Z[14] = y("div", { class: "sv-black" }, null, -1)),
              y("div", {
                class: "sv-cursor",
                style: Ct({ left: _.value[1] * 100 + "%", top: (1 - _.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            y("div", {
              class: "hue-slider",
              onMousedown: P,
              ref_key: "hueSliderRef",
              ref: c
            }, [
              y("div", {
                class: "hue-cursor",
                style: Ct({ left: _.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : d.value === "rgb" ? (ie(), ue("div", CL, [
            y("div", TL, [
              Z[15] || (Z[15] = y("label", null, "R", -1)),
              y("div", {
                class: "slider-track r-track",
                onMousedown: Z[1] || (Z[1] = (N) => $("r", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: m.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              y("input", {
                type: "number",
                value: m.value[0],
                min: "0",
                max: "255",
                onInput: Z[2] || (Z[2] = (N) => I(0, N))
              }, null, 40, EL)
            ]),
            y("div", AL, [
              Z[16] || (Z[16] = y("label", null, "G", -1)),
              y("div", {
                class: "slider-track g-track",
                onMousedown: Z[3] || (Z[3] = (N) => $("g", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: m.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              y("input", {
                type: "number",
                value: m.value[1],
                min: "0",
                max: "255",
                onInput: Z[4] || (Z[4] = (N) => I(1, N))
              }, null, 40, PL)
            ]),
            y("div", DL, [
              Z[17] || (Z[17] = y("label", null, "B", -1)),
              y("div", {
                class: "slider-track b-track",
                onMousedown: Z[5] || (Z[5] = (N) => $("b", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: m.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              y("input", {
                type: "number",
                value: m.value[2],
                min: "0",
                max: "255",
                onInput: Z[6] || (Z[6] = (N) => I(2, N))
              }, null, 40, kL)
            ])
          ])) : d.value === "hsl" ? (ie(), ue("div", RL, [
            y("div", LL, [
              Z[18] || (Z[18] = y("label", null, "H", -1)),
              y("div", {
                class: "slider-track hue-track",
                onMousedown: Z[7] || (Z[7] = (N) => $("h", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: g.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              y("input", {
                type: "number",
                value: Math.round(g.value[0]),
                min: "0",
                max: "360",
                onInput: Z[8] || (Z[8] = (N) => Q(0, N))
              }, null, 40, IL)
            ]),
            y("div", OL, [
              Z[19] || (Z[19] = y("label", null, "S", -1)),
              y("div", {
                class: "slider-track sat-track",
                style: Ct({ "--hue": g.value[0] }),
                onMousedown: Z[9] || (Z[9] = (N) => $("s", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: g.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              y("input", {
                type: "number",
                value: Math.round(g.value[1] * 100),
                min: "0",
                max: "100",
                onInput: Z[10] || (Z[10] = (N) => Q(1, N))
              }, null, 40, FL)
            ]),
            y("div", UL, [
              Z[20] || (Z[20] = y("label", null, "L", -1)),
              y("div", {
                class: "slider-track light-track",
                style: Ct({ "--hue": g.value[0] }),
                onMousedown: Z[11] || (Z[11] = (N) => $("l", N))
              }, [
                y("div", {
                  class: "slider-cursor",
                  style: Ct({ left: g.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              y("input", {
                type: "number",
                value: Math.round(g.value[2] * 100),
                min: "0",
                max: "100",
                onInput: Z[12] || (Z[12] = (N) => Q(2, N))
              }, null, 40, zL)
            ])
          ])) : Ne("", !0),
          r.alpha ? (ie(), ue("div", BL, [
            Z[21] || (Z[21] = y("label", null, "A", -1)),
            y("div", {
              class: "slider-track alpha-track",
              style: Ct({ "--color": r.modelValue }),
              onMousedown: ye,
              ref_key: "alphaSliderRef",
              ref: u
            }, [
              y("div", {
                class: "slider-cursor",
                style: Ct({ left: p.value * 100 + "%" })
              }, null, 4)
            ], 36),
            y("input", {
              type: "number",
              value: Math.round(p.value * 100),
              min: "0",
              max: "100",
              onInput: X
            }, null, 40, NL)
          ])) : Ne("", !0),
          y("div", VL, [
            Z[22] || (Z[22] = y("div", { class: "swatches-label" }, "Swatches", -1)),
            y("div", GL, [
              (ie(!0), ue(nt, null, pt(v.value, (N) => (ie(), ue("button", {
                key: N,
                class: "swatch",
                style: Ct({ backgroundColor: N }),
                onClick: (j) => T(N)
              }, null, 12, HL))), 128))
            ])
          ]),
          f.value.length > 0 ? (ie(), ue("div", WL, [
            Z[23] || (Z[23] = y("div", { class: "swatches-label" }, "Recent", -1)),
            y("div", jL, [
              (ie(!0), ue(nt, null, pt(f.value, (N) => (ie(), ue("button", {
                key: N,
                class: "swatch",
                style: Ct({ backgroundColor: N }),
                onClick: (j) => T(N)
              }, null, 12, $L))), 128))
            ])
          ])) : Ne("", !0)
        ], 4)) : Ne("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), Cd = /* @__PURE__ */ Yt(XL, [["__scopeId", "data-v-05165efb"]]), YL = { class: "effect-controls" }, qL = { class: "panel-header" }, ZL = { class: "header-row" }, KL = {
  key: 0,
  class: "layer-badge"
}, JL = { class: "layer-type-icon" }, QL = ["disabled"], eI = {
  key: 0,
  class: "effect-menu"
}, tI = { class: "category-label" }, nI = { class: "cat-icon" }, iI = { class: "category-items" }, sI = ["onClick"], rI = { class: "panel-content" }, oI = {
  key: 0,
  class: "empty-state"
}, aI = {
  key: 1,
  class: "empty-state"
}, lI = {
  key: 2,
  class: "effects-list"
}, cI = ["onClick"], uI = { class: "header-left" }, hI = { class: "arrow" }, dI = ["onClick"], fI = { class: "effect-name" }, pI = { class: "header-right" }, mI = ["onClick"], gI = {
  key: 0,
  class: "effect-params"
}, vI = { class: "param-header" }, yI = ["title"], _I = ["onClick"], xI = { class: "param-control" }, bI = {
  key: 0,
  class: "control-group"
}, wI = {
  key: 1,
  class: "control-group"
}, SI = {
  key: 2,
  class: "control-group point-group"
}, MI = ["checked", "onChange"], CI = ["value", "onChange"], TI = ["value"], EI = /* @__PURE__ */ jt({
  __name: "EffectControlsPanel",
  setup(r) {
    const e = _n(), n = Ce(!1), i = Ce(null), s = Xe(() => e.selectedLayer), o = ng;
    function a(T) {
      return Object.entries(Md).filter(([w, A]) => A.category === T).map(([w, A]) => ({ key: w, ...A }));
    }
    function l(T, w) {
      const A = Md[T];
      return A == null ? void 0 : A.parameters.find((O) => c(O.name) === w);
    }
    function c(T) {
      return T.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function u(T, w) {
      const A = l(T, w);
      return A && (A.min !== void 0 || A.max !== void 0);
    }
    function h(T, w) {
      const A = l(T, w);
      return (A == null ? void 0 : A.type) === "checkbox";
    }
    function d(T, w) {
      const A = l(T, w);
      return (A == null ? void 0 : A.type) === "angle";
    }
    function p(T, w) {
      const A = l(T, w);
      return (A == null ? void 0 : A.options) || [];
    }
    function f(T) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[T] || "";
    }
    function m(T) {
      s.value && (e.addEffectToLayer(s.value.id, T), n.value = !1);
    }
    function _(T) {
      s.value && e.removeEffectFromLayer(s.value.id, T.id);
    }
    function g(T) {
      s.value && e.toggleEffect(s.value.id, T.id);
    }
    function v(T) {
      T.expanded = !T.expanded;
    }
    function S(T, w, A) {
      s.value && e.updateEffectParameter(s.value.id, T, w, A);
    }
    function b(T, w, A, O) {
      if (!s.value) return;
      const U = s.value.effects.find((P) => P.id === T);
      if (!U) return;
      const L = { ...U.parameters[w].value, [A]: O };
      e.updateEffectParameter(s.value.id, T, w, L);
    }
    function x(T) {
      return typeof T == "string" ? T : _L(T.r, T.g, T.b, T.a ?? 1);
    }
    function M(T, w, A) {
      const O = vL(A);
      if (O && s.value) {
        const U = { r: O[0], g: O[1], b: O[2], a: O[3] };
        e.updateEffectParameter(s.value.id, T, w, U);
      }
    }
    function C(T, w) {
      if (!s.value) return;
      const A = s.value.effects.find((U) => U.id === T), O = A == null ? void 0 : A.parameters[w];
      O && e.setEffectParamAnimated(s.value.id, T, w, !O.animated);
    }
    function E(T) {
      i.value && !i.value.contains(T.target) && (n.value = !1);
    }
    return Xn(() => window.addEventListener("mousedown", E)), Ni(() => window.removeEventListener("mousedown", E)), (T, w) => (ie(), ue("div", YL, [
      y("div", qL, [
        y("div", ZL, [
          w[1] || (w[1] = y("h3", null, "Effect Controls", -1)),
          s.value ? (ie(), ue("div", KL, [
            y("span", JL, Ae(f(s.value.type)), 1),
            xt(" " + Ae(s.value.name), 1)
          ])) : Ne("", !0)
        ]),
        y("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: i
        }, [
          y("button", {
            class: "add-btn",
            onClick: w[0] || (w[0] = (A) => n.value = !n.value),
            disabled: !s.value
          }, [...w[2] || (w[2] = [
            y("span", { class: "icon" }, "+", -1),
            xt(" Add Effect ", -1)
          ])], 8, QL),
          n.value ? (ie(), ue("div", eI, [
            (ie(!0), ue(nt, null, pt(Je(o), (A, O) => (ie(), ue("div", {
              key: O,
              class: "effect-category"
            }, [
              y("div", tI, [
                y("span", nI, Ae(A.icon), 1),
                xt(" " + Ae(A.label), 1)
              ]),
              y("div", iI, [
                (ie(!0), ue(nt, null, pt(a(O), (U) => (ie(), ue("button", {
                  key: U.key,
                  onClick: (D) => m(U.key)
                }, Ae(U.name), 9, sI))), 128))
              ])
            ]))), 128))
          ])) : Ne("", !0)
        ], 512)
      ]),
      y("div", rI, [
        s.value ? !s.value.effects || s.value.effects.length === 0 ? (ie(), ue("div", aI, " No effects applied ")) : (ie(), ue("div", lI, [
          (ie(!0), ue(nt, null, pt(s.value.effects, (A, O) => (ie(), ue("div", {
            key: A.id,
            class: Ye(["effect-item", { collapsed: !A.expanded }])
          }, [
            y("div", {
              class: "effect-header",
              onClick: (U) => v(A)
            }, [
              y("div", uI, [
                y("span", hI, Ae(A.expanded ? "" : ""), 1),
                y("button", {
                  class: "icon-btn",
                  onClick: Rt((U) => g(A), ["stop"])
                }, [
                  y("span", {
                    class: Ye(["fx-icon", { disabled: !A.enabled }])
                  }, "fx", 2)
                ], 8, dI),
                y("span", fI, Ae(A.name), 1)
              ]),
              y("div", pI, [
                y("button", {
                  class: "icon-btn delete",
                  onClick: Rt((U) => _(A), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, mI)
              ])
            ], 8, cI),
            A.expanded ? (ie(), ue("div", gI, [
              (ie(!0), ue(nt, null, pt(A.parameters, (U, D) => {
                var L, P, V, ce;
                return ie(), ue("div", {
                  key: D,
                  class: "param-row"
                }, [
                  y("div", vI, [
                    y("span", {
                      class: "param-name",
                      title: String(D)
                    }, Ae(U.name), 9, yI),
                    y("button", {
                      class: Ye(["stopwatch", { active: U.animated }]),
                      onClick: (q) => C(A.id, String(D)),
                      title: "Toggle Animation"
                    }, "", 10, _I)
                  ]),
                  y("div", xI, [
                    U.type === "number" && d(A.effectKey, String(D)) ? (ie(), ue("div", bI, [
                      Ze(fv, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (q) => S(A.id, String(D), q),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ze(rt, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (q) => S(A.id, String(D), q),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "number" ? (ie(), ue("div", wI, [
                      u(A.effectKey, String(D)) ? (ie(), Et(Di, {
                        key: 0,
                        modelValue: U.value,
                        "onUpdate:modelValue": (q) => S(A.id, String(D), q),
                        min: ((L = l(A.effectKey, String(D))) == null ? void 0 : L.min) ?? 0,
                        max: ((P = l(A.effectKey, String(D))) == null ? void 0 : P.max) ?? 100,
                        step: ((V = l(A.effectKey, String(D))) == null ? void 0 : V.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Ne("", !0),
                      Ze(rt, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (q) => S(A.id, String(D), q),
                        step: ((ce = l(A.effectKey, String(D))) == null ? void 0 : ce.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : U.type === "position" ? (ie(), ue("div", SI, [
                      Ze(rt, {
                        modelValue: U.value.x,
                        "onUpdate:modelValue": (q) => b(A.id, String(D), "x", q),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ze(rt, {
                        modelValue: U.value.y,
                        "onUpdate:modelValue": (q) => b(A.id, String(D), "y", q),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "color" ? (ie(), Et(Cd, {
                      key: 3,
                      modelValue: x(U.value),
                      "onUpdate:modelValue": (q) => M(A.id, String(D), q),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : U.type === "enum" && h(A.effectKey, String(D)) ? (ie(), ue("input", {
                      key: 4,
                      type: "checkbox",
                      checked: U.value,
                      onChange: (q) => S(A.id, String(D), q.target.checked)
                    }, null, 40, MI)) : U.type === "enum" ? (ie(), ue("select", {
                      key: 5,
                      value: U.value,
                      onChange: (q) => S(A.id, String(D), q.target.value),
                      class: "param-select"
                    }, [
                      (ie(!0), ue(nt, null, pt(p(A.effectKey, String(D)), (q) => (ie(), ue("option", {
                        key: q.value,
                        value: q.value
                      }, Ae(q.label), 9, TI))), 128))
                    ], 40, CI)) : Ne("", !0)
                  ])
                ]);
              }), 128))
            ])) : Ne("", !0)
          ], 2))), 128))
        ])) : (ie(), ue("div", oI, " Select a layer to edit effects "))
      ])
    ]));
  }
}), AI = /* @__PURE__ */ Yt(EI, [["__scopeId", "data-v-8ac57c6b"]]), ih = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], sh = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class PI {
  constructor() {
    pe(this, "systemFonts", []);
    pe(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    pe(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const i of e)
        (!n.has(i.family) || i.style === "Regular") && n.set(i.family, {
          family: i.family,
          fullName: i.fullName,
          style: i.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((i, s) => i.family.localeCompare(s.family)), console.log(`[FontService] Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? console.log("[FontService] User denied font access permission") : console.error("[FontService] Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: ih
    }), e.push({
      name: "Google Fonts",
      fonts: sh.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return ih.forEach((n) => e.add(n.family)), sh.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const i = n.join(";"), s = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${i}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = s, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), console.log(`[FontService] Loaded Google Font: ${e}`);
    } catch (a) {
      console.error(`[FontService] Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return ih.some((n) => n.family === e) ? !0 : sh.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", s = document.createElement("canvas").getContext("2d");
    s.font = "72px monospace";
    const o = s.measureText(n).width;
    s.font = `72px "${e}", monospace`;
    const a = s.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return ih;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return sh;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (console.log("[FontService] Local Font Access API not available"), !1);
  }
}
const Aa = new PI(), DI = { class: "text-properties" }, kI = { class: "prop-section" }, RI = ["value"], LI = { class: "prop-section" }, II = { class: "row font-row" }, OI = ["value"], FI = ["label"], UI = ["value"], zI = { class: "style-toggles" }, BI = {
  key: 0,
  class: "row"
}, NI = ["disabled"], VI = { class: "row" }, GI = { class: "row color-row" }, HI = { class: "color-item" }, WI = ["value"], jI = { class: "color-item" }, $I = ["value"], XI = { class: "row" }, YI = { class: "row" }, qI = { class: "align-buttons" }, ZI = { class: "prop-section" }, KI = { class: "row" }, JI = { class: "vec2" }, QI = { class: "row" }, eO = { class: "vec2" }, tO = { class: "row" }, nO = { class: "vec2" }, iO = { class: "row" }, sO = { class: "row" }, rO = { class: "prop-section" }, oO = { class: "row" }, aO = ["value"], lO = ["value"], cO = { class: "row" }, uO = { class: "row" }, hO = { class: "row" }, dO = { class: "row checkbox-row" }, fO = ["checked"], pO = { class: "row checkbox-row" }, mO = ["checked"], gO = { class: "row checkbox-row" }, vO = ["checked"], yO = { class: "prop-section" }, _O = { class: "row" }, xO = { class: "row" }, bO = { class: "row" }, wO = { class: "prop-section checkbox" }, SO = ["checked"], MO = /* @__PURE__ */ jt({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Ce([]), a = Ce(!1), l = Ce(!1);
    Xn(async () => {
      await Aa.initialize(), o.value = Aa.getFontCategories(), a.value = Aa.hasSystemFonts();
    });
    async function c() {
      l.value = !0;
      try {
        await Aa.requestSystemFontAccess() && (o.value = Aa.getFontCategories(), a.value = !0);
      } finally {
        l.value = !1;
      }
    }
    const u = Xe(() => n.layer.data), h = Xe(() => n.layer.transform), d = Xe(() => s.layers.filter((T) => T.type === "spline"));
    function p(T) {
      var w;
      return (w = n.layer.properties) == null ? void 0 : w.find((A) => A.name === T);
    }
    function f(T) {
      const w = p(T);
      return w ? w.value : null;
    }
    function m(T) {
      s.setPropertyValue(n.layer.id, "Source Text", T), s.updateLayerData(n.layer.id, { text: T }), i("update");
    }
    function _(T, w) {
      s.updateLayerData(n.layer.id, { [T]: w });
      const A = {
        fill: "Fill Color",
        stroke: "Stroke Color",
        fontSize: "Font Size",
        strokeWidth: "Stroke Width"
      };
      A[T] && s.setPropertyValue(n.layer.id, A[T], w), i("update");
    }
    function g(T, w) {
      s.setPropertyValue(n.layer.id, T, w);
      const A = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      A[T] && s.updateLayerData(n.layer.id, { [A[T]]: w }), i("update");
    }
    function v(T) {
      const w = p(T);
      return (w == null ? void 0 : w.animated) ?? !1;
    }
    function S(T) {
      var U;
      const w = p(T);
      if (!w) return;
      const A = s.currentFrame, O = (U = w.keyframes) == null ? void 0 : U.find((D) => D.frame === A);
      O ? s.removeKeyframe(n.layer.id, T, O.id) : s.addKeyframe(n.layer.id, T, w.value, A), i("update");
    }
    function b(T, w, A) {
      const O = h.value[T];
      let U;
      w ? U = { ...O.value, [w]: A } : U = A, s.setPropertyValue(n.layer.id, `transform.${T}`, U), i("update");
    }
    function x(T) {
      s.setPropertyValue(n.layer.id, "opacity", T), i("update");
    }
    function M() {
      _("fontWeight", u.value.fontWeight === "bold" ? "400" : "bold");
    }
    function C() {
      _("fontStyle", u.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function E(T) {
      await Aa.ensureFont(T), _("fontFamily", T);
    }
    return (T, w) => {
      var A;
      return ie(), ue("div", DI, [
        y("div", kI, [
          w[29] || (w[29] = y("div", { class: "section-title" }, "Source Text", -1)),
          y("textarea", {
            value: u.value.text,
            onInput: w[0] || (w[0] = (O) => m(O.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, RI)
        ]),
        y("div", LI, [
          w[35] || (w[35] = y("div", { class: "section-title" }, "Character", -1)),
          y("div", II, [
            y("select", {
              value: u.value.fontFamily,
              onChange: w[1] || (w[1] = (O) => E(O.target.value)),
              class: "font-select"
            }, [
              (ie(!0), ue(nt, null, pt(o.value, (O) => (ie(), ue("optgroup", {
                key: O.name,
                label: O.name
              }, [
                (ie(!0), ue(nt, null, pt(O.fonts, (U) => (ie(), ue("option", {
                  key: U.family,
                  value: U.family
                }, Ae(U.family), 9, UI))), 128))
              ], 8, FI))), 128))
            ], 40, OI),
            y("div", zI, [
              y("button", {
                class: Ye({ active: u.value.fontWeight === "bold" }),
                onClick: M
              }, "B", 2),
              y("button", {
                class: Ye({ active: u.value.fontStyle === "italic" }),
                onClick: C
              }, "I", 2)
            ])
          ]),
          a.value ? Ne("", !0) : (ie(), ue("div", BI, [
            y("button", {
              class: "font-access-btn",
              onClick: c,
              disabled: l.value
            }, Ae(l.value ? "Loading..." : "+ Load System Fonts"), 9, NI)
          ])),
          y("div", VI, [
            w[30] || (w[30] = y("label", null, "Size", -1)),
            Ze(Je(rt), {
              modelValue: f("Font Size") || u.value.fontSize,
              "onUpdate:modelValue": w[2] || (w[2] = (O) => g("Font Size", O))
            }, null, 8, ["modelValue"])
          ]),
          y("div", GI, [
            y("div", HI, [
              y("input", {
                type: "color",
                value: u.value.fill,
                onInput: w[3] || (w[3] = (O) => _("fill", O.target.value))
              }, null, 40, WI),
              w[31] || (w[31] = y("span", null, "Fill", -1))
            ]),
            y("div", jI, [
              y("input", {
                type: "color",
                value: u.value.stroke || "#000000",
                onInput: w[4] || (w[4] = (O) => _("stroke", O.target.value))
              }, null, 40, $I),
              w[32] || (w[32] = y("span", null, "Stroke", -1))
            ])
          ]),
          y("div", XI, [
            w[33] || (w[33] = y("label", null, "Stroke Width", -1)),
            Ze(Je(rt), {
              modelValue: f("Stroke Width") || u.value.strokeWidth || 0,
              "onUpdate:modelValue": w[5] || (w[5] = (O) => g("Stroke Width", O)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          y("div", YI, [
            w[34] || (w[34] = y("label", null, "Alignment", -1)),
            y("div", qI, [
              y("button", {
                class: Ye({ active: u.value.textAlign === "left" }),
                onClick: w[6] || (w[6] = (O) => _("textAlign", "left"))
              }, "", 2),
              y("button", {
                class: Ye({ active: u.value.textAlign === "center" }),
                onClick: w[7] || (w[7] = (O) => _("textAlign", "center"))
              }, "", 2),
              y("button", {
                class: Ye({ active: u.value.textAlign === "right" }),
                onClick: w[8] || (w[8] = (O) => _("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        y("div", ZI, [
          w[41] || (w[41] = y("div", { class: "section-title" }, "Transform", -1)),
          y("div", KI, [
            w[36] || (w[36] = y("label", null, "Position", -1)),
            y("div", JI, [
              Ze(Je(rt), {
                modelValue: h.value.position.value.x,
                "onUpdate:modelValue": w[9] || (w[9] = (O) => b("position", "x", O))
              }, null, 8, ["modelValue"]),
              Ze(Je(rt), {
                modelValue: h.value.position.value.y,
                "onUpdate:modelValue": w[10] || (w[10] = (O) => b("position", "y", O))
              }, null, 8, ["modelValue"])
            ])
          ]),
          y("div", QI, [
            w[37] || (w[37] = y("label", null, "Anchor Pt", -1)),
            y("div", eO, [
              Ze(Je(rt), {
                modelValue: h.value.anchorPoint.value.x,
                "onUpdate:modelValue": w[11] || (w[11] = (O) => b("anchorPoint", "x", O))
              }, null, 8, ["modelValue"]),
              Ze(Je(rt), {
                modelValue: h.value.anchorPoint.value.y,
                "onUpdate:modelValue": w[12] || (w[12] = (O) => b("anchorPoint", "y", O))
              }, null, 8, ["modelValue"])
            ])
          ]),
          y("div", tO, [
            w[38] || (w[38] = y("label", null, "Scale %", -1)),
            y("div", nO, [
              Ze(Je(rt), {
                modelValue: h.value.scale.value.x,
                "onUpdate:modelValue": w[13] || (w[13] = (O) => b("scale", "x", O))
              }, null, 8, ["modelValue"]),
              Ze(Je(rt), {
                modelValue: h.value.scale.value.y,
                "onUpdate:modelValue": w[14] || (w[14] = (O) => b("scale", "y", O))
              }, null, 8, ["modelValue"])
            ])
          ]),
          y("div", iO, [
            w[39] || (w[39] = y("label", null, "Rotation", -1)),
            Ze(Je(rt), {
              modelValue: h.value.rotation.value,
              "onUpdate:modelValue": w[15] || (w[15] = (O) => b("rotation", null, O))
            }, null, 8, ["modelValue"])
          ]),
          y("div", sO, [
            w[40] || (w[40] = y("label", null, "Opacity", -1)),
            Ze(Je(rt), {
              modelValue: ((A = r.layer.opacity) == null ? void 0 : A.value) ?? 100,
              "onUpdate:modelValue": w[16] || (w[16] = (O) => x(O)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        y("div", rO, [
          w[50] || (w[50] = y("div", { class: "section-title" }, "Path Options", -1)),
          y("div", oO, [
            w[43] || (w[43] = y("label", null, "Path", -1)),
            y("select", {
              value: u.value.pathLayerId || "",
              onChange: w[17] || (w[17] = (O) => _("pathLayerId", O.target.value || null)),
              class: "full-select"
            }, [
              w[42] || (w[42] = y("option", { value: "" }, "None", -1)),
              (ie(!0), ue(nt, null, pt(d.value, (O) => (ie(), ue("option", {
                key: O.id,
                value: O.id
              }, Ae(O.name), 9, lO))), 128))
            ], 40, aO)
          ]),
          u.value.pathLayerId ? (ie(), ue(nt, { key: 0 }, [
            y("div", cO, [
              w[44] || (w[44] = y("label", null, "Path Offset %", -1)),
              Ze(Je(rt), {
                modelValue: f("Path Offset") ?? u.value.pathOffset ?? 0,
                "onUpdate:modelValue": w[18] || (w[18] = (O) => g("Path Offset", O)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              y("button", {
                class: Ye(["keyframe-btn", { active: v("Path Offset") }]),
                onClick: w[19] || (w[19] = (O) => S("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            y("div", uO, [
              w[45] || (w[45] = y("label", null, "First Margin", -1)),
              Ze(Je(rt), {
                modelValue: f("First Margin") ?? u.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": w[20] || (w[20] = (O) => g("First Margin", O)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            y("div", hO, [
              w[46] || (w[46] = y("label", null, "Last Margin", -1)),
              Ze(Je(rt), {
                modelValue: f("Last Margin") ?? u.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": w[21] || (w[21] = (O) => g("Last Margin", O)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            y("div", dO, [
              y("label", null, [
                y("input", {
                  type: "checkbox",
                  checked: u.value.pathReversed,
                  onChange: w[22] || (w[22] = (O) => _("pathReversed", !u.value.pathReversed))
                }, null, 40, fO),
                w[47] || (w[47] = xt(" Reverse Path ", -1))
              ])
            ]),
            y("div", pO, [
              y("label", null, [
                y("input", {
                  type: "checkbox",
                  checked: u.value.pathPerpendicularToPath ?? !0,
                  onChange: w[23] || (w[23] = (O) => _("pathPerpendicularToPath", !u.value.pathPerpendicularToPath))
                }, null, 40, mO),
                w[48] || (w[48] = xt(" Perpendicular to Path ", -1))
              ])
            ]),
            y("div", gO, [
              y("label", null, [
                y("input", {
                  type: "checkbox",
                  checked: u.value.pathForceAlignment,
                  onChange: w[24] || (w[24] = (O) => _("pathForceAlignment", !u.value.pathForceAlignment))
                }, null, 40, vO),
                w[49] || (w[49] = xt(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : Ne("", !0)
        ]),
        y("div", yO, [
          w[54] || (w[54] = y("div", { class: "section-title" }, "Advanced", -1)),
          y("div", _O, [
            w[51] || (w[51] = y("label", null, "Tracking", -1)),
            Ze(Je(rt), {
              modelValue: f("Tracking") || u.value.tracking || 0,
              "onUpdate:modelValue": w[25] || (w[25] = (O) => g("Tracking", O))
            }, null, 8, ["modelValue"])
          ]),
          y("div", xO, [
            w[52] || (w[52] = y("label", null, "Line Spacing", -1)),
            Ze(Je(rt), {
              modelValue: f("Line Spacing") || u.value.lineSpacing || 0,
              "onUpdate:modelValue": w[26] || (w[26] = (O) => g("Line Spacing", O))
            }, null, 8, ["modelValue"])
          ]),
          y("div", bO, [
            w[53] || (w[53] = y("label", null, "Char Offset", -1)),
            Ze(Je(rt), {
              modelValue: f("Character Offset") || u.value.characterOffset || 0,
              "onUpdate:modelValue": w[27] || (w[27] = (O) => g("Character Offset", O)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        y("div", wO, [
          y("label", null, [
            y("input", {
              type: "checkbox",
              checked: u.value.perCharacter3D,
              onChange: w[28] || (w[28] = (O) => _("perCharacter3D", !u.value.perCharacter3D))
            }, null, 40, SO),
            w[55] || (w[55] = xt(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
}), CO = /* @__PURE__ */ Yt(MO, [["__scopeId", "data-v-947c42b2"]]), TO = { class: "particle-properties" }, EO = { class: "property-section" }, AO = {
  key: 0,
  class: "section-content"
}, PO = { class: "property-row" }, DO = ["value"], kO = { class: "value-display" }, RO = { class: "property-row" }, LO = ["value"], IO = { class: "value-display" }, OO = { class: "property-row" }, FO = ["value"], UO = { class: "value-display" }, zO = { class: "property-row" }, BO = ["value"], NO = { class: "value-display" }, VO = { class: "property-row" }, GO = ["value"], HO = { class: "value-display" }, WO = { class: "property-row" }, jO = ["value"], $O = { class: "property-section" }, XO = {
  key: 0,
  class: "section-content"
}, YO = ["onClick"], qO = ["value", "onInput"], ZO = { class: "enabled-toggle" }, KO = ["checked", "onChange"], JO = ["onClick"], QO = {
  key: 0,
  class: "emitter-content"
}, eF = { class: "property-row" }, tF = ["value", "onInput"], nF = { class: "value-display" }, iF = { class: "property-row" }, sF = ["value", "onInput"], rF = { class: "value-display" }, oF = { class: "property-row" }, aF = ["value", "onInput"], lF = { class: "value-display" }, cF = { class: "property-row" }, uF = ["value", "onInput"], hF = { class: "value-display" }, dF = { class: "property-row" }, fF = ["value", "onInput"], pF = { class: "value-display" }, mF = { class: "property-row" }, gF = ["value", "onInput"], vF = { class: "value-display" }, yF = { class: "property-row" }, _F = ["value", "onInput"], xF = { class: "value-display" }, bF = { class: "property-row" }, wF = ["value", "onInput"], SF = { class: "value-display" }, MF = { class: "property-row" }, CF = ["value", "onInput"], TF = { class: "property-row" }, EF = ["value", "onInput"], AF = { class: "value-display" }, PF = { class: "property-row" }, DF = ["value", "onInput"], kF = { class: "value-display" }, RF = { class: "property-row" }, LF = ["value", "onInput"], IF = { class: "value-display" }, OF = { class: "property-row checkbox-row" }, FF = ["checked", "onChange"], UF = {
  key: 0,
  class: "property-row"
}, zF = ["value", "onInput"], BF = { class: "value-display" }, NF = {
  key: 0,
  class: "empty-message"
}, VF = { class: "property-section" }, GF = {
  key: 0,
  class: "section-content"
}, HF = { class: "force-tabs" }, WF = {
  key: 0,
  class: "force-list"
}, jF = { class: "force-header" }, $F = ["value", "onInput"], XF = { class: "enabled-toggle" }, YF = ["checked", "onChange"], qF = ["onClick"], ZF = { class: "property-row" }, KF = ["value", "onInput"], JF = { class: "value-display" }, QF = { class: "property-row" }, e5 = ["value", "onInput"], t5 = { class: "value-display" }, n5 = { class: "property-row" }, i5 = ["value", "onInput"], s5 = { class: "value-display" }, r5 = { class: "property-row" }, o5 = ["value", "onInput"], a5 = { class: "value-display" }, l5 = { class: "property-row" }, c5 = ["value", "onChange"], u5 = {
  key: 1,
  class: "force-list"
}, h5 = { class: "force-header" }, d5 = ["value", "onInput"], f5 = { class: "enabled-toggle" }, p5 = ["checked", "onChange"], m5 = ["onClick"], g5 = { class: "property-row" }, v5 = ["value", "onInput"], y5 = { class: "value-display" }, _5 = { class: "property-row" }, x5 = ["value", "onInput"], b5 = { class: "value-display" }, w5 = { class: "property-row" }, S5 = ["value", "onInput"], M5 = { class: "value-display" }, C5 = { class: "property-row" }, T5 = ["value", "onInput"], E5 = { class: "value-display" }, A5 = { class: "property-row" }, P5 = ["value", "onInput"], D5 = { class: "value-display" }, k5 = { class: "property-row" }, R5 = ["value", "onInput"], L5 = { class: "value-display" }, I5 = { class: "property-section" }, O5 = {
  key: 0,
  class: "section-content"
}, F5 = { class: "force-header" }, U5 = { class: "enabled-toggle" }, z5 = ["checked", "onChange"], B5 = ["onClick"], N5 = { class: "property-row" }, V5 = ["value", "onInput"], G5 = { class: "value-display" }, H5 = { class: "property-row" }, W5 = ["value", "onInput"], j5 = { class: "value-display" }, $5 = { class: "property-row" }, X5 = ["value", "onInput"], Y5 = { class: "value-display" }, q5 = {
  key: 0,
  class: "empty-message"
}, Z5 = { class: "property-section" }, K5 = {
  key: 0,
  class: "section-content"
}, J5 = { class: "force-header" }, Q5 = ["value", "onChange"], e4 = ["value"], t4 = { class: "enabled-toggle" }, n4 = ["checked", "onChange"], i4 = ["onClick"], s4 = { class: "property-row" }, r4 = ["value", "onChange"], o4 = { class: "property-row" }, a4 = ["value", "onInput"], l4 = { class: "value-display" }, c4 = { class: "property-row" }, u4 = ["value", "onInput"], h4 = { class: "value-display" }, d4 = { class: "property-row" }, f4 = ["value", "onInput"], p4 = { class: "value-display" }, m4 = { class: "property-row" }, g4 = ["value", "onInput"], v4 = { class: "value-display" }, y4 = { class: "property-row" }, _4 = ["value", "onInput"], x4 = { class: "value-display" }, b4 = { class: "property-row" }, w4 = ["value", "onInput"], S4 = { class: "value-display" }, M4 = { class: "property-row" }, C4 = ["value", "onInput"], T4 = {
  key: 0,
  class: "empty-message"
}, E4 = { class: "property-section" }, A4 = {
  key: 0,
  class: "section-content"
}, P4 = { class: "modulation-header" }, D4 = ["value", "onChange"], k4 = ["value"], R4 = ["onClick"], L4 = { class: "property-row" }, I4 = ["value", "onChange"], O4 = { class: "property-row" }, F4 = ["value", "onInput"], U4 = { class: "property-row" }, z4 = ["value", "onInput"], B4 = { class: "property-row" }, N4 = ["value", "onChange"], V4 = {
  key: 0,
  class: "empty-message"
}, G4 = { class: "property-section" }, H4 = {
  key: 0,
  class: "section-content"
}, W4 = { class: "property-row" }, j4 = ["value"], $4 = { class: "property-row" }, X4 = ["value"], Y4 = { class: "property-row checkbox-row" }, q4 = ["checked"], Z4 = {
  key: 0,
  class: "property-row"
}, K4 = ["value"], J4 = { class: "value-display" }, Q4 = { class: "property-row checkbox-row" }, eU = ["checked"], tU = {
  key: 1,
  class: "property-row"
}, nU = ["value"], iU = { class: "value-display" }, sU = {
  key: 2,
  class: "property-row"
}, rU = ["value"], oU = { class: "value-display" }, aU = { class: "property-row checkbox-row" }, lU = ["checked"], cU = {
  key: 3,
  class: "property-row"
}, uU = ["value"], hU = { class: "value-display" }, dU = {
  key: 4,
  class: "property-row"
}, fU = ["value"], pU = { class: "value-display" }, mU = {
  key: 5,
  class: "property-row"
}, gU = ["value"], vU = { class: "value-display" }, yU = {
  key: 6,
  class: "property-row"
}, _U = ["value"], xU = { class: "value-display" }, bU = {
  key: 7,
  class: "property-row checkbox-row"
}, wU = ["checked"], SU = { class: "particle-count" }, MU = /* @__PURE__ */ jt({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce(/* @__PURE__ */ new Set(["system", "emitters"])), o = Ce(/* @__PURE__ */ new Set()), a = Ce("wells"), l = Xe(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = Xe(() => l.value.systemConfig), u = Xe(() => l.value.emitters), h = Xe(() => l.value.gravityWells), d = Xe(() => l.value.vortices), p = Xe(() => l.value.modulations), f = Xe(() => l.value.renderOptions), m = Xe(() => l.value.turbulenceFields || []), _ = Xe(() => l.value.subEmitters || []), g = Xe(() => f.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), v = Xe(() => n.particleCount);
    function S(G) {
      s.value.has(G) ? s.value.delete(G) : s.value.add(G);
    }
    function b(G) {
      o.value.has(G) ? o.value.delete(G) : o.value.add(G);
    }
    function x(G, R) {
      i("update", {
        systemConfig: { ...c.value, [G]: R }
      });
    }
    function M(G, R, z) {
      const I = u.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { emitters: I });
    }
    function C(G, R) {
      const z = K(R);
      M(G, "color", z);
    }
    function E() {
      const G = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      i("update", { emitters: [...u.value, G] }), o.value.add(G.id);
    }
    function T(G) {
      i("update", { emitters: u.value.filter((R) => R.id !== G) });
    }
    function w(G, R, z) {
      const I = h.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { gravityWells: I });
    }
    function A() {
      const G = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      i("update", { gravityWells: [...h.value, G] });
    }
    function O(G) {
      i("update", { gravityWells: h.value.filter((R) => R.id !== G) });
    }
    function U(G, R, z) {
      const I = d.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { vortices: I });
    }
    function D() {
      const G = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      i("update", { vortices: [...d.value, G] });
    }
    function L(G) {
      i("update", { vortices: d.value.filter((R) => R.id !== G) });
    }
    function P(G, R, z) {
      const I = p.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { modulations: I });
    }
    function V() {
      const G = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      i("update", { modulations: [...p.value, G] });
    }
    function ce(G) {
      i("update", { modulations: p.value.filter((R) => R.id !== G) });
    }
    function q(G, R) {
      i("update", {
        renderOptions: { ...f.value, [G]: R }
      });
    }
    function oe(G, R) {
      i("update", {
        renderOptions: {
          ...f.value,
          connections: { ...g.value, [G]: R }
        }
      });
    }
    function ne(G, R, z) {
      const I = m.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { turbulenceFields: I });
    }
    function $() {
      const G = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      i("update", { turbulenceFields: [...m.value, G] });
    }
    function J(G) {
      i("update", { turbulenceFields: m.value.filter((R) => R.id !== G) });
    }
    function se(G, R, z) {
      const I = _.value.map(
        (Q) => Q.id === G ? { ...Q, [R]: z } : Q
      );
      i("update", { subEmitters: I });
    }
    function le(G, R) {
      const z = K(R);
      se(G, "color", z);
    }
    function re() {
      const G = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      i("update", { subEmitters: [..._.value, G] });
    }
    function ye(G) {
      i("update", { subEmitters: _.value.filter((R) => R.id !== G) });
    }
    function H(G) {
      return "#" + G.map((R) => R.toString(16).padStart(2, "0")).join("");
    }
    function K(G) {
      const R = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(G);
      return R ? [parseInt(R[1], 16), parseInt(R[2], 16), parseInt(R[3], 16)] : [255, 255, 255];
    }
    return (G, R) => (ie(), ue("div", TO, [
      y("div", EO, [
        y("div", {
          class: "section-header",
          onClick: R[0] || (R[0] = (z) => S("system"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[30] || (R[30] = y("span", null, "System Settings", -1))
        ]),
        s.value.has("system") ? (ie(), ue("div", AO, [
          y("div", PO, [
            R[31] || (R[31] = y("label", null, "Max Particles", -1)),
            y("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: R[1] || (R[1] = (z) => x("maxParticles", Number(z.target.value)))
            }, null, 40, DO),
            y("span", kO, Ae(c.value.maxParticles), 1)
          ]),
          y("div", RO, [
            R[32] || (R[32] = y("label", null, "Gravity", -1)),
            y("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: R[2] || (R[2] = (z) => x("gravity", Number(z.target.value)))
            }, null, 40, LO),
            y("span", IO, Ae(c.value.gravity), 1)
          ]),
          y("div", OO, [
            R[33] || (R[33] = y("label", null, "Wind Strength", -1)),
            y("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: R[3] || (R[3] = (z) => x("windStrength", Number(z.target.value)))
            }, null, 40, FO),
            y("span", UO, Ae(c.value.windStrength), 1)
          ]),
          y("div", zO, [
            R[34] || (R[34] = y("label", null, "Wind Direction", -1)),
            y("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: R[4] || (R[4] = (z) => x("windDirection", Number(z.target.value)))
            }, null, 40, BO),
            y("span", NO, Ae(c.value.windDirection) + "", 1)
          ]),
          y("div", VO, [
            R[35] || (R[35] = y("label", null, "Friction", -1)),
            y("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: R[5] || (R[5] = (z) => x("friction", Number(z.target.value)))
            }, null, 40, GO),
            y("span", HO, Ae(c.value.friction.toFixed(2)), 1)
          ]),
          y("div", WO, [
            R[37] || (R[37] = y("label", null, "Boundary", -1)),
            y("select", {
              value: c.value.boundaryBehavior,
              onChange: R[6] || (R[6] = (z) => x("boundaryBehavior", z.target.value))
            }, [...R[36] || (R[36] = [
              y("option", { value: "kill" }, "Kill", -1),
              y("option", { value: "bounce" }, "Bounce", -1),
              y("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, jO)
          ])
        ])) : Ne("", !0)
      ]),
      y("div", $O, [
        y("div", {
          class: "section-header",
          onClick: R[7] || (R[7] = (z) => S("emitters"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[39] || (R[39] = y("span", null, "Emitters", -1)),
          y("button", {
            class: "add-btn",
            onClick: Rt(E, ["stop"]),
            title: "Add Emitter"
          }, [...R[38] || (R[38] = [
            y("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        s.value.has("emitters") ? (ie(), ue("div", XO, [
          (ie(!0), ue(nt, null, pt(u.value, (z) => (ie(), ue("div", {
            key: z.id,
            class: "emitter-item"
          }, [
            y("div", {
              class: "emitter-header",
              onClick: (I) => b(z.id)
            }, [
              y("i", {
                class: Ye(["pi", o.value.has(z.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              y("input", {
                type: "text",
                value: z.name,
                onInput: (I) => M(z.id, "name", I.target.value),
                onClick: R[8] || (R[8] = Rt(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, qO),
              y("label", ZO, [
                y("input", {
                  type: "checkbox",
                  checked: z.enabled,
                  onChange: (I) => M(z.id, "enabled", I.target.checked),
                  onClick: R[9] || (R[9] = Rt(() => {
                  }, ["stop"]))
                }, null, 40, KO)
              ]),
              y("button", {
                class: "remove-btn",
                onClick: Rt((I) => T(z.id), ["stop"]),
                title: "Remove"
              }, [...R[40] || (R[40] = [
                y("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, JO)
            ], 8, YO),
            o.value.has(z.id) ? (ie(), ue("div", QO, [
              y("div", eF, [
                R[41] || (R[41] = y("label", null, "Position X", -1)),
                y("input", {
                  type: "range",
                  value: z.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => M(z.id, "x", Number(I.target.value))
                }, null, 40, tF),
                y("span", nF, Ae(z.x.toFixed(2)), 1)
              ]),
              y("div", iF, [
                R[42] || (R[42] = y("label", null, "Position Y", -1)),
                y("input", {
                  type: "range",
                  value: z.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => M(z.id, "y", Number(I.target.value))
                }, null, 40, sF),
                y("span", rF, Ae(z.y.toFixed(2)), 1)
              ]),
              y("div", oF, [
                R[43] || (R[43] = y("label", null, "Direction", -1)),
                y("input", {
                  type: "range",
                  value: z.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (I) => M(z.id, "direction", Number(I.target.value))
                }, null, 40, aF),
                y("span", lF, Ae(z.direction) + "", 1)
              ]),
              y("div", cF, [
                R[44] || (R[44] = y("label", null, "Spread", -1)),
                y("input", {
                  type: "range",
                  value: z.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (I) => M(z.id, "spread", Number(I.target.value))
                }, null, 40, uF),
                y("span", hF, Ae(z.spread) + "", 1)
              ]),
              y("div", dF, [
                R[45] || (R[45] = y("label", null, "Speed", -1)),
                y("input", {
                  type: "range",
                  value: z.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (I) => M(z.id, "speed", Number(I.target.value))
                }, null, 40, fF),
                y("span", pF, Ae(z.speed), 1)
              ]),
              y("div", mF, [
                R[46] || (R[46] = y("label", null, "Speed Variance", -1)),
                y("input", {
                  type: "range",
                  value: z.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (I) => M(z.id, "speedVariance", Number(I.target.value))
                }, null, 40, gF),
                y("span", vF, Ae(z.speedVariance), 1)
              ]),
              y("div", yF, [
                R[47] || (R[47] = y("label", null, "Size", -1)),
                y("input", {
                  type: "range",
                  value: z.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (I) => M(z.id, "size", Number(I.target.value))
                }, null, 40, _F),
                y("span", xF, Ae(z.size) + "px", 1)
              ]),
              y("div", bF, [
                R[48] || (R[48] = y("label", null, "Size Variance", -1)),
                y("input", {
                  type: "range",
                  value: z.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (I) => M(z.id, "sizeVariance", Number(I.target.value))
                }, null, 40, wF),
                y("span", SF, Ae(z.sizeVariance), 1)
              ]),
              y("div", MF, [
                R[49] || (R[49] = y("label", null, "Color", -1)),
                y("input", {
                  type: "color",
                  value: H(z.color),
                  onInput: (I) => C(z.id, I.target.value)
                }, null, 40, CF)
              ]),
              y("div", TF, [
                R[50] || (R[50] = y("label", null, "Emission Rate", -1)),
                y("input", {
                  type: "range",
                  value: z.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (I) => M(z.id, "emissionRate", Number(I.target.value))
                }, null, 40, EF),
                y("span", AF, Ae(z.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              y("div", PF, [
                R[51] || (R[51] = y("label", null, "Lifetime", -1)),
                y("input", {
                  type: "range",
                  value: z.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (I) => M(z.id, "particleLifetime", Number(I.target.value))
                }, null, 40, DF),
                y("span", kF, Ae(z.particleLifetime) + "f", 1)
              ]),
              y("div", RF, [
                R[52] || (R[52] = y("label", null, "Initial Burst", -1)),
                y("input", {
                  type: "range",
                  value: z.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (I) => M(z.id, "initialBurst", Number(I.target.value))
                }, null, 40, LF),
                y("span", IF, Ae((z.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              y("div", OF, [
                y("label", null, [
                  y("input", {
                    type: "checkbox",
                    checked: z.burstOnBeat,
                    onChange: (I) => M(z.id, "burstOnBeat", I.target.checked)
                  }, null, 40, FF),
                  R[53] || (R[53] = xt(" Burst on Beat ", -1))
                ])
              ]),
              z.burstOnBeat ? (ie(), ue("div", UF, [
                R[54] || (R[54] = y("label", null, "Burst Count", -1)),
                y("input", {
                  type: "range",
                  value: z.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (I) => M(z.id, "burstCount", Number(I.target.value))
                }, null, 40, zF),
                y("span", BF, Ae(z.burstCount), 1)
              ])) : Ne("", !0)
            ])) : Ne("", !0)
          ]))), 128)),
          u.value.length === 0 ? (ie(), ue("div", NF, " No emitters. Click + to add one. ")) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", VF, [
        y("div", {
          class: "section-header",
          onClick: R[10] || (R[10] = (z) => S("forces"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[55] || (R[55] = y("span", null, "Force Fields", -1))
        ]),
        s.value.has("forces") ? (ie(), ue("div", GF, [
          y("div", HF, [
            y("button", {
              class: Ye({ active: a.value === "wells" }),
              onClick: R[11] || (R[11] = (z) => a.value = "wells")
            }, " Gravity Wells ", 2),
            y("button", {
              class: Ye({ active: a.value === "vortices" }),
              onClick: R[12] || (R[12] = (z) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (ie(), ue("div", WF, [
            y("button", {
              class: "add-btn full-width",
              onClick: A
            }, [...R[56] || (R[56] = [
              y("i", { class: "pi pi-plus" }, null, -1),
              xt(" Add Gravity Well ", -1)
            ])]),
            (ie(!0), ue(nt, null, pt(h.value, (z) => (ie(), ue("div", {
              key: z.id,
              class: "force-item"
            }, [
              y("div", jF, [
                y("input", {
                  type: "text",
                  value: z.name,
                  onInput: (I) => w(z.id, "name", I.target.value),
                  class: "force-name"
                }, null, 40, $F),
                y("label", XF, [
                  y("input", {
                    type: "checkbox",
                    checked: z.enabled,
                    onChange: (I) => w(z.id, "enabled", I.target.checked)
                  }, null, 40, YF)
                ]),
                y("button", {
                  class: "remove-btn",
                  onClick: (I) => O(z.id)
                }, [...R[57] || (R[57] = [
                  y("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, qF)
              ]),
              y("div", ZF, [
                R[58] || (R[58] = y("label", null, "Position X", -1)),
                y("input", {
                  type: "range",
                  value: z.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => w(z.id, "x", Number(I.target.value))
                }, null, 40, KF),
                y("span", JF, Ae(z.x.toFixed(2)), 1)
              ]),
              y("div", QF, [
                R[59] || (R[59] = y("label", null, "Position Y", -1)),
                y("input", {
                  type: "range",
                  value: z.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => w(z.id, "y", Number(I.target.value))
                }, null, 40, e5),
                y("span", t5, Ae(z.y.toFixed(2)), 1)
              ]),
              y("div", n5, [
                R[60] || (R[60] = y("label", null, "Strength", -1)),
                y("input", {
                  type: "range",
                  value: z.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (I) => w(z.id, "strength", Number(I.target.value))
                }, null, 40, i5),
                y("span", s5, Ae(z.strength), 1)
              ]),
              y("div", r5, [
                R[61] || (R[61] = y("label", null, "Radius", -1)),
                y("input", {
                  type: "range",
                  value: z.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => w(z.id, "radius", Number(I.target.value))
                }, null, 40, o5),
                y("span", a5, Ae(z.radius.toFixed(2)), 1)
              ]),
              y("div", l5, [
                R[63] || (R[63] = y("label", null, "Falloff", -1)),
                y("select", {
                  value: z.falloff,
                  onChange: (I) => w(z.id, "falloff", I.target.value)
                }, [...R[62] || (R[62] = [
                  y("option", { value: "linear" }, "Linear", -1),
                  y("option", { value: "quadratic" }, "Quadratic", -1),
                  y("option", { value: "constant" }, "Constant", -1)
                ])], 40, c5)
              ])
            ]))), 128))
          ])) : Ne("", !0),
          a.value === "vortices" ? (ie(), ue("div", u5, [
            y("button", {
              class: "add-btn full-width",
              onClick: D
            }, [...R[64] || (R[64] = [
              y("i", { class: "pi pi-plus" }, null, -1),
              xt(" Add Vortex ", -1)
            ])]),
            (ie(!0), ue(nt, null, pt(d.value, (z) => (ie(), ue("div", {
              key: z.id,
              class: "force-item"
            }, [
              y("div", h5, [
                y("input", {
                  type: "text",
                  value: z.name,
                  onInput: (I) => U(z.id, "name", I.target.value),
                  class: "force-name"
                }, null, 40, d5),
                y("label", f5, [
                  y("input", {
                    type: "checkbox",
                    checked: z.enabled,
                    onChange: (I) => U(z.id, "enabled", I.target.checked)
                  }, null, 40, p5)
                ]),
                y("button", {
                  class: "remove-btn",
                  onClick: (I) => L(z.id)
                }, [...R[65] || (R[65] = [
                  y("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, m5)
              ]),
              y("div", g5, [
                R[66] || (R[66] = y("label", null, "Position X", -1)),
                y("input", {
                  type: "range",
                  value: z.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => U(z.id, "x", Number(I.target.value))
                }, null, 40, v5),
                y("span", y5, Ae(z.x.toFixed(2)), 1)
              ]),
              y("div", _5, [
                R[67] || (R[67] = y("label", null, "Position Y", -1)),
                y("input", {
                  type: "range",
                  value: z.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => U(z.id, "y", Number(I.target.value))
                }, null, 40, x5),
                y("span", b5, Ae(z.y.toFixed(2)), 1)
              ]),
              y("div", w5, [
                R[68] || (R[68] = y("label", null, "Strength", -1)),
                y("input", {
                  type: "range",
                  value: z.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (I) => U(z.id, "strength", Number(I.target.value))
                }, null, 40, S5),
                y("span", M5, Ae(z.strength), 1)
              ]),
              y("div", C5, [
                R[69] || (R[69] = y("label", null, "Radius", -1)),
                y("input", {
                  type: "range",
                  value: z.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (I) => U(z.id, "radius", Number(I.target.value))
                }, null, 40, T5),
                y("span", E5, Ae(z.radius.toFixed(2)), 1)
              ]),
              y("div", A5, [
                R[70] || (R[70] = y("label", null, "Rotation Speed", -1)),
                y("input", {
                  type: "range",
                  value: z.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (I) => U(z.id, "rotationSpeed", Number(I.target.value))
                }, null, 40, P5),
                y("span", D5, Ae(z.rotationSpeed) + "/f", 1)
              ]),
              y("div", k5, [
                R[71] || (R[71] = y("label", null, "Inward Pull", -1)),
                y("input", {
                  type: "range",
                  value: z.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (I) => U(z.id, "inwardPull", Number(I.target.value))
                }, null, 40, R5),
                y("span", L5, Ae(z.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", I5, [
        y("div", {
          class: "section-header",
          onClick: R[13] || (R[13] = (z) => S("turbulence"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[73] || (R[73] = y("span", null, "Turbulence", -1)),
          y("button", {
            class: "add-btn",
            onClick: Rt($, ["stop"]),
            title: "Add Turbulence Field"
          }, [...R[72] || (R[72] = [
            y("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        s.value.has("turbulence") ? (ie(), ue("div", O5, [
          (ie(!0), ue(nt, null, pt(m.value, (z) => (ie(), ue("div", {
            key: z.id,
            class: "force-item"
          }, [
            y("div", F5, [
              R[75] || (R[75] = y("span", { class: "force-label" }, "Turbulence Field", -1)),
              y("label", U5, [
                y("input", {
                  type: "checkbox",
                  checked: z.enabled,
                  onChange: (I) => ne(z.id, "enabled", I.target.checked)
                }, null, 40, z5)
              ]),
              y("button", {
                class: "remove-btn",
                onClick: (I) => J(z.id)
              }, [...R[74] || (R[74] = [
                y("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, B5)
            ]),
            y("div", N5, [
              R[76] || (R[76] = y("label", null, "Scale", -1)),
              y("input", {
                type: "range",
                value: z.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (I) => ne(z.id, "scale", Number(I.target.value))
              }, null, 40, V5),
              y("span", G5, Ae(z.scale.toFixed(3)), 1)
            ]),
            y("div", H5, [
              R[77] || (R[77] = y("label", null, "Strength", -1)),
              y("input", {
                type: "range",
                value: z.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (I) => ne(z.id, "strength", Number(I.target.value))
              }, null, 40, W5),
              y("span", j5, Ae(z.strength), 1)
            ]),
            y("div", $5, [
              R[78] || (R[78] = y("label", null, "Evolution", -1)),
              y("input", {
                type: "range",
                value: z.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (I) => ne(z.id, "evolutionSpeed", Number(I.target.value))
              }, null, 40, X5),
              y("span", Y5, Ae(z.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          m.value.length === 0 ? (ie(), ue("div", q5, " No turbulence fields. Add one for organic particle motion. ")) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", Z5, [
        y("div", {
          class: "section-header",
          onClick: R[14] || (R[14] = (z) => S("subEmitters"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[80] || (R[80] = y("span", null, "Sub-Emitters", -1)),
          y("button", {
            class: "add-btn",
            onClick: Rt(re, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...R[79] || (R[79] = [
            y("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        s.value.has("subEmitters") ? (ie(), ue("div", K5, [
          (ie(!0), ue(nt, null, pt(_.value, (z) => (ie(), ue("div", {
            key: z.id,
            class: "force-item"
          }, [
            y("div", J5, [
              y("select", {
                value: z.parentEmitterId,
                onChange: (I) => se(z.id, "parentEmitterId", I.target.value),
                class: "sub-emitter-parent"
              }, [
                R[81] || (R[81] = y("option", { value: "*" }, "All Emitters", -1)),
                (ie(!0), ue(nt, null, pt(u.value, (I) => (ie(), ue("option", {
                  key: I.id,
                  value: I.id
                }, Ae(I.name), 9, e4))), 128))
              ], 40, Q5),
              y("label", t4, [
                y("input", {
                  type: "checkbox",
                  checked: z.enabled,
                  onChange: (I) => se(z.id, "enabled", I.target.checked)
                }, null, 40, n4)
              ]),
              y("button", {
                class: "remove-btn",
                onClick: (I) => ye(z.id)
              }, [...R[82] || (R[82] = [
                y("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, i4)
            ]),
            y("div", s4, [
              R[84] || (R[84] = y("label", null, "Trigger", -1)),
              y("select", {
                value: z.trigger,
                onChange: (I) => se(z.id, "trigger", I.target.value)
              }, [...R[83] || (R[83] = [
                y("option", { value: "death" }, "On Death", -1)
              ])], 40, r4)
            ]),
            y("div", o4, [
              R[85] || (R[85] = y("label", null, "Spawn Count", -1)),
              y("input", {
                type: "range",
                value: z.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (I) => se(z.id, "spawnCount", Number(I.target.value))
              }, null, 40, a4),
              y("span", l4, Ae(z.spawnCount), 1)
            ]),
            y("div", c4, [
              R[86] || (R[86] = y("label", null, "Inherit Velocity", -1)),
              y("input", {
                type: "range",
                value: z.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (I) => se(z.id, "inheritVelocity", Number(I.target.value))
              }, null, 40, u4),
              y("span", h4, Ae((z.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            y("div", d4, [
              R[87] || (R[87] = y("label", null, "Size", -1)),
              y("input", {
                type: "range",
                value: z.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (I) => se(z.id, "size", Number(I.target.value))
              }, null, 40, f4),
              y("span", p4, Ae(z.size) + "px", 1)
            ]),
            y("div", m4, [
              R[88] || (R[88] = y("label", null, "Lifetime", -1)),
              y("input", {
                type: "range",
                value: z.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (I) => se(z.id, "lifetime", Number(I.target.value))
              }, null, 40, g4),
              y("span", v4, Ae(z.lifetime) + "f", 1)
            ]),
            y("div", y4, [
              R[89] || (R[89] = y("label", null, "Speed", -1)),
              y("input", {
                type: "range",
                value: z.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (I) => se(z.id, "speed", Number(I.target.value))
              }, null, 40, _4),
              y("span", x4, Ae(z.speed), 1)
            ]),
            y("div", b4, [
              R[90] || (R[90] = y("label", null, "Spread", -1)),
              y("input", {
                type: "range",
                value: z.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (I) => se(z.id, "spread", Number(I.target.value))
              }, null, 40, w4),
              y("span", S4, Ae(z.spread) + "", 1)
            ]),
            y("div", M4, [
              R[91] || (R[91] = y("label", null, "Color", -1)),
              y("input", {
                type: "color",
                value: H(z.color),
                onInput: (I) => le(z.id, I.target.value)
              }, null, 40, C4)
            ])
          ]))), 128)),
          _.value.length === 0 ? (ie(), ue("div", T4, " No sub-emitters. Add one for particle death effects. ")) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", E4, [
        y("div", {
          class: "section-header",
          onClick: R[15] || (R[15] = (z) => S("modulations"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[93] || (R[93] = y("span", null, "Modulations", -1)),
          y("button", {
            class: "add-btn",
            onClick: Rt(V, ["stop"]),
            title: "Add Modulation"
          }, [...R[92] || (R[92] = [
            y("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        s.value.has("modulations") ? (ie(), ue("div", A4, [
          (ie(!0), ue(nt, null, pt(p.value, (z) => (ie(), ue("div", {
            key: z.id,
            class: "modulation-item"
          }, [
            y("div", P4, [
              y("select", {
                value: z.emitterId,
                onChange: (I) => P(z.id, "emitterId", I.target.value)
              }, [
                R[94] || (R[94] = y("option", { value: "*" }, "All Emitters", -1)),
                (ie(!0), ue(nt, null, pt(u.value, (I) => (ie(), ue("option", {
                  key: I.id,
                  value: I.id
                }, Ae(I.name), 9, k4))), 128))
              ], 40, D4),
              y("button", {
                class: "remove-btn",
                onClick: (I) => ce(z.id)
              }, [...R[95] || (R[95] = [
                y("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, R4)
            ]),
            y("div", L4, [
              R[97] || (R[97] = y("label", null, "Property", -1)),
              y("select", {
                value: z.property,
                onChange: (I) => P(z.id, "property", I.target.value)
              }, [...R[96] || (R[96] = [
                ea('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, I4)
            ]),
            y("div", O4, [
              R[98] || (R[98] = y("label", null, "Start Value", -1)),
              y("input", {
                type: "number",
                value: z.startValue,
                step: "0.1",
                onInput: (I) => P(z.id, "startValue", Number(I.target.value))
              }, null, 40, F4)
            ]),
            y("div", U4, [
              R[99] || (R[99] = y("label", null, "End Value", -1)),
              y("input", {
                type: "number",
                value: z.endValue,
                step: "0.1",
                onInput: (I) => P(z.id, "endValue", Number(I.target.value))
              }, null, 40, z4)
            ]),
            y("div", B4, [
              R[101] || (R[101] = y("label", null, "Easing", -1)),
              y("select", {
                value: z.easing,
                onChange: (I) => P(z.id, "easing", I.target.value)
              }, [...R[100] || (R[100] = [
                ea('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, N4)
            ])
          ]))), 128)),
          p.value.length === 0 ? (ie(), ue("div", V4, " No modulations. Add one to animate particle properties over lifetime. ")) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", G4, [
        y("div", {
          class: "section-header",
          onClick: R[16] || (R[16] = (z) => S("render"))
        }, [
          y("i", {
            class: Ye(["pi", s.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          R[102] || (R[102] = y("span", null, "Render Options", -1))
        ]),
        s.value.has("render") ? (ie(), ue("div", H4, [
          y("div", W4, [
            R[104] || (R[104] = y("label", null, "Blend Mode", -1)),
            y("select", {
              value: f.value.blendMode,
              onChange: R[17] || (R[17] = (z) => q("blendMode", z.target.value))
            }, [...R[103] || (R[103] = [
              y("option", { value: "normal" }, "Normal", -1),
              y("option", { value: "additive" }, "Additive", -1),
              y("option", { value: "multiply" }, "Multiply", -1),
              y("option", { value: "screen" }, "Screen", -1)
            ])], 40, j4)
          ]),
          y("div", $4, [
            R[106] || (R[106] = y("label", null, "Shape", -1)),
            y("select", {
              value: f.value.particleShape,
              onChange: R[18] || (R[18] = (z) => q("particleShape", z.target.value))
            }, [...R[105] || (R[105] = [
              y("option", { value: "circle" }, "Circle", -1),
              y("option", { value: "square" }, "Square", -1),
              y("option", { value: "triangle" }, "Triangle", -1),
              y("option", { value: "star" }, "Star", -1)
            ])], 40, X4)
          ]),
          y("div", Y4, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: f.value.renderTrails,
                onChange: R[19] || (R[19] = (z) => q("renderTrails", z.target.checked))
              }, null, 40, q4),
              R[107] || (R[107] = xt(" Render Trails ", -1))
            ])
          ]),
          f.value.renderTrails ? (ie(), ue("div", Z4, [
            R[108] || (R[108] = y("label", null, "Trail Length", -1)),
            y("input", {
              type: "range",
              value: f.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: R[20] || (R[20] = (z) => q("trailLength", Number(z.target.value)))
            }, null, 40, K4),
            y("span", J4, Ae(f.value.trailLength), 1)
          ])) : Ne("", !0),
          y("div", Q4, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: f.value.glowEnabled,
                onChange: R[21] || (R[21] = (z) => q("glowEnabled", z.target.checked))
              }, null, 40, eU),
              R[109] || (R[109] = xt(" Enable Glow ", -1))
            ])
          ]),
          f.value.glowEnabled ? (ie(), ue("div", tU, [
            R[110] || (R[110] = y("label", null, "Glow Radius", -1)),
            y("input", {
              type: "range",
              value: f.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: R[22] || (R[22] = (z) => q("glowRadius", Number(z.target.value)))
            }, null, 40, nU),
            y("span", iU, Ae(f.value.glowRadius) + "px", 1)
          ])) : Ne("", !0),
          f.value.glowEnabled ? (ie(), ue("div", sU, [
            R[111] || (R[111] = y("label", null, "Glow Intensity", -1)),
            y("input", {
              type: "range",
              value: f.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: R[23] || (R[23] = (z) => q("glowIntensity", Number(z.target.value)))
            }, null, 40, rU),
            y("span", oU, Ae(f.value.glowIntensity.toFixed(2)), 1)
          ])) : Ne("", !0),
          R[118] || (R[118] = y("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          y("div", aU, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: g.value.enabled,
                onChange: R[24] || (R[24] = (z) => oe("enabled", z.target.checked))
              }, null, 40, lU),
              R[112] || (R[112] = xt(" Enable Connections ", -1))
            ])
          ]),
          g.value.enabled ? (ie(), ue("div", cU, [
            R[113] || (R[113] = y("label", null, "Max Distance", -1)),
            y("input", {
              type: "range",
              value: g.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: R[25] || (R[25] = (z) => oe("maxDistance", Number(z.target.value)))
            }, null, 40, uU),
            y("span", hU, Ae(g.value.maxDistance) + "px", 1)
          ])) : Ne("", !0),
          g.value.enabled ? (ie(), ue("div", dU, [
            R[114] || (R[114] = y("label", null, "Max Connections", -1)),
            y("input", {
              type: "range",
              value: g.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: R[26] || (R[26] = (z) => oe("maxConnections", Number(z.target.value)))
            }, null, 40, fU),
            y("span", pU, Ae(g.value.maxConnections), 1)
          ])) : Ne("", !0),
          g.value.enabled ? (ie(), ue("div", mU, [
            R[115] || (R[115] = y("label", null, "Line Width", -1)),
            y("input", {
              type: "range",
              value: g.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: R[27] || (R[27] = (z) => oe("lineWidth", Number(z.target.value)))
            }, null, 40, gU),
            y("span", vU, Ae(g.value.lineWidth.toFixed(1)), 1)
          ])) : Ne("", !0),
          g.value.enabled ? (ie(), ue("div", yU, [
            R[116] || (R[116] = y("label", null, "Line Opacity", -1)),
            y("input", {
              type: "range",
              value: g.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: R[28] || (R[28] = (z) => oe("lineOpacity", Number(z.target.value)))
            }, null, 40, _U),
            y("span", xU, Ae(g.value.lineOpacity.toFixed(2)), 1)
          ])) : Ne("", !0),
          g.value.enabled ? (ie(), ue("div", bU, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: g.value.fadeByDistance,
                onChange: R[29] || (R[29] = (z) => oe("fadeByDistance", z.target.checked))
              }, null, 40, wU),
              R[117] || (R[117] = xt(" Fade by Distance ", -1))
            ])
          ])) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", SU, [
        R[119] || (R[119] = y("i", { class: "pi pi-circle-fill" }, null, -1)),
        y("span", null, Ae(v.value) + " particles", 1)
      ])
    ]));
  }
}), CU = /* @__PURE__ */ Yt(MU, [["__scopeId", "data-v-60b9bdc8"]]), TU = ["title"], EU = /* @__PURE__ */ jt({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Xe(() => n.property.animated ? n.property.keyframes.some((p) => p.frame === s.currentFrame) : !1), a = Xe(() => n.property.animated && n.property.keyframes.find((p) => p.frame === s.currentFrame) || null), l = Xe(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = Xe(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      o.value ? d() : h();
    }
    function h() {
      const p = { frame: 0, value: 0, enabled: !1 }, f = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: s.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...p },
        outHandle: { ...p },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, i("animationToggled", !0)), n.property.keyframes.push(f), n.property.keyframes.sort((m, _) => m.frame - _.frame), i("keyframeAdded", f);
    }
    function d() {
      const p = a.value;
      if (!p) return;
      const f = n.property.keyframes.findIndex((m) => m.id === p.id);
      f >= 0 && (n.property.keyframes.splice(f, 1), i("keyframeRemoved", p.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, i("animationToggled", !1));
    }
    return (p, f) => (ie(), ue("button", {
      class: Ye(["keyframe-toggle", {
        animated: r.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: u,
      title: c.value
    }, [
      y("i", {
        class: Ye(["pi", l.value])
      }, null, 2)
    ], 10, TU));
  }
}), No = /* @__PURE__ */ Yt(EU, [["__scopeId", "data-v-b9271c8f"]]), AU = { class: "depthflow-properties" }, PU = { class: "property-section" }, DU = {
  key: 0,
  class: "section-content"
}, kU = { class: "property-row" }, RU = ["value"], LU = ["value"], IU = { class: "property-row" }, OU = ["value"], FU = ["value"], UU = { class: "property-section" }, zU = {
  key: 0,
  class: "section-content"
}, BU = { class: "preset-grid" }, NU = ["onClick"], VU = {
  key: 0,
  class: "property-row"
}, GU = ["value"], HU = { class: "value-display" }, WU = { class: "property-section" }, jU = {
  key: 0,
  class: "section-content"
}, $U = { class: "property-row" }, XU = ["value"], YU = { class: "value-display" }, qU = { class: "property-row" }, ZU = ["value"], KU = { class: "value-display" }, JU = { class: "property-row" }, QU = ["value"], ez = { class: "value-display" }, tz = { class: "property-row" }, nz = ["value"], iz = { class: "value-display" }, sz = { class: "property-section" }, rz = {
  key: 0,
  class: "section-content"
}, oz = { class: "property-row" }, az = ["value"], lz = { class: "value-display" }, cz = { class: "property-row" }, uz = ["value"], hz = { class: "value-display" }, dz = {
  key: 0,
  class: "property-section"
}, fz = {
  key: 0,
  class: "section-content"
}, pz = { class: "property-row" }, mz = ["value"], gz = { class: "value-display" }, vz = { class: "property-row" }, yz = ["value"], _z = { class: "value-display" }, xz = { class: "property-row" }, bz = ["value"], wz = { class: "value-display" }, Sz = { class: "property-row" }, Mz = ["value"], Cz = { class: "value-display" }, Tz = {
  key: 2,
  class: "property-row"
}, Ez = ["value"], Az = { class: "value-display" }, Pz = { class: "property-section" }, Dz = {
  key: 0,
  class: "section-content"
}, kz = { class: "property-row" }, Rz = ["value"], Lz = { class: "value-display" }, Iz = { class: "property-row checkbox-row" }, Oz = ["checked"], Fz = { class: "property-section" }, Uz = {
  key: 0,
  class: "section-content"
}, zz = { class: "preview-container" }, Bz = { class: "preview-controls" }, Nz = { class: "frame-indicator" }, Rs = 200, Vz = /* @__PURE__ */ jt({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Ce(null), a = Ce(!1), l = Ce(0), c = Ce(null), u = Ce(/* @__PURE__ */ new Set(["source", "preset", "camera"])), h = Ce(1), d = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], p = Xe(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), f = Xe(() => p.value.config), m = Xe(() => s.frameCount), _ = Xe(
      () => s.layers.filter((L) => L.type === "image" || L.type === "generated")
    ), g = Xe(
      () => s.layers.filter((L) => L.type === "depth" || L.type === "generated")
    ), v = Xe(
      () => ["circle_cw", "circle_ccw"].includes(f.value.preset)
    ), S = Xe(
      () => ["horizontal_swing", "vertical_swing"].includes(f.value.preset)
    ), b = Xe(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(f.value.preset)
    ), x = Xe(
      () => v.value || S.value || b.value
    ), M = Xe(() => v.value ? "Orbit Settings" : S.value ? "Swing Settings" : b.value ? "Dolly Zoom Settings" : "Preset Settings");
    function C(L) {
      u.value.has(L) ? u.value.delete(L) : u.value.add(L);
    }
    function E(L, P) {
      i("update", { [L]: P });
    }
    function T(L, P) {
      i("update", {
        config: { ...f.value, [L]: P }
      });
    }
    function w(L) {
      T("preset", L);
    }
    function A(L) {
      h.value = L, v.value ? T("orbitRadius", 0.1 * L) : S.value ? T("swingAmplitude", 0.1 * L) : T("depthScale", 1 * L);
    }
    function O() {
      a.value = !a.value, a.value ? U() : c.value !== null && (cancelAnimationFrame(c.value), c.value = null);
    }
    function U() {
      a.value && (l.value = (l.value + 1) % m.value, D(), c.value = requestAnimationFrame(() => {
        setTimeout(U, 1e3 / s.fps);
      }));
    }
    function D() {
      const L = o.value;
      if (!L) return;
      const P = L.getContext("2d");
      P && (P.fillStyle = "#1e1e1e", P.fillRect(0, 0, Rs, Rs), P.fillStyle = "#333", P.fillRect(10, 10, Rs - 20, Rs - 20), P.fillStyle = "#666", P.font = "12px sans-serif", P.textAlign = "center", P.fillText("Depthflow Preview", Rs / 2, Rs / 2), P.fillText(`Frame ${l.value}`, Rs / 2, Rs / 2 + 16));
    }
    return Xn(() => {
      D();
    }), Ni(() => {
      c.value !== null && cancelAnimationFrame(c.value);
    }), (L, P) => (ie(), ue("div", AU, [
      y("div", PU, [
        y("div", {
          class: "section-header",
          onClick: P[0] || (P[0] = (V) => C("source"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[23] || (P[23] = y("span", null, "Source Selection", -1))
        ]),
        u.value.has("source") ? (ie(), ue("div", DU, [
          y("div", kU, [
            P[25] || (P[25] = y("label", null, "Source Layer", -1)),
            y("select", {
              value: p.value.sourceLayerId,
              onChange: P[1] || (P[1] = (V) => E("sourceLayerId", V.target.value))
            }, [
              P[24] || (P[24] = y("option", { value: "" }, "Select source...", -1)),
              (ie(!0), ue(nt, null, pt(_.value, (V) => (ie(), ue("option", {
                key: V.id,
                value: V.id
              }, Ae(V.name), 9, LU))), 128))
            ], 40, RU)
          ]),
          y("div", IU, [
            P[27] || (P[27] = y("label", null, "Depth Layer", -1)),
            y("select", {
              value: p.value.depthLayerId,
              onChange: P[2] || (P[2] = (V) => E("depthLayerId", V.target.value))
            }, [
              P[26] || (P[26] = y("option", { value: "" }, "Select depth map...", -1)),
              (ie(!0), ue(nt, null, pt(g.value, (V) => (ie(), ue("option", {
                key: V.id,
                value: V.id
              }, Ae(V.name), 9, FU))), 128))
            ], 40, OU)
          ])
        ])) : Ne("", !0)
      ]),
      y("div", UU, [
        y("div", {
          class: "section-header",
          onClick: P[3] || (P[3] = (V) => C("preset"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[28] || (P[28] = y("span", null, "Motion Preset", -1))
        ]),
        u.value.has("preset") ? (ie(), ue("div", zU, [
          y("div", BU, [
            (ie(), ue(nt, null, pt(d, (V) => y("button", {
              key: V.value,
              class: Ye(["preset-btn", { active: f.value.preset === V.value }]),
              onClick: (ce) => w(V.value)
            }, [
              y("i", {
                class: Ye(V.icon)
              }, null, 2),
              y("span", null, Ae(V.label), 1)
            ], 10, NU)), 64))
          ]),
          f.value.preset !== "static" ? (ie(), ue("div", VU, [
            P[29] || (P[29] = y("label", null, "Intensity", -1)),
            y("input", {
              type: "range",
              value: h.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: P[4] || (P[4] = (V) => A(Number(V.target.value)))
            }, null, 40, GU),
            y("span", HU, Ae(h.value.toFixed(1)) + "x", 1)
          ])) : Ne("", !0)
        ])) : Ne("", !0)
      ]),
      y("div", WU, [
        y("div", {
          class: "section-header",
          onClick: P[5] || (P[5] = (V) => C("camera"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[30] || (P[30] = y("span", null, "Camera Controls", -1))
        ]),
        u.value.has("camera") ? (ie(), ue("div", jU, [
          y("div", $U, [
            P[31] || (P[31] = y("label", null, "Zoom", -1)),
            p.value.animatedZoom ? (ie(), Et(No, {
              key: 0,
              property: p.value.animatedZoom,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : Ne("", !0),
            y("input", {
              type: "range",
              value: f.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: P[6] || (P[6] = (V) => T("zoom", Number(V.target.value)))
            }, null, 40, XU),
            y("span", YU, Ae(f.value.zoom.toFixed(2)), 1)
          ]),
          y("div", qU, [
            P[32] || (P[32] = y("label", null, "Offset X", -1)),
            p.value.animatedOffsetX ? (ie(), Et(No, {
              key: 0,
              property: p.value.animatedOffsetX,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : Ne("", !0),
            y("input", {
              type: "range",
              value: f.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: P[7] || (P[7] = (V) => T("offsetX", Number(V.target.value)))
            }, null, 40, ZU),
            y("span", KU, Ae(f.value.offsetX.toFixed(2)), 1)
          ]),
          y("div", JU, [
            P[33] || (P[33] = y("label", null, "Offset Y", -1)),
            p.value.animatedOffsetY ? (ie(), Et(No, {
              key: 0,
              property: p.value.animatedOffsetY,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : Ne("", !0),
            y("input", {
              type: "range",
              value: f.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: P[8] || (P[8] = (V) => T("offsetY", Number(V.target.value)))
            }, null, 40, QU),
            y("span", ez, Ae(f.value.offsetY.toFixed(2)), 1)
          ]),
          y("div", tz, [
            P[34] || (P[34] = y("label", null, "Rotation", -1)),
            p.value.animatedRotation ? (ie(), Et(No, {
              key: 0,
              property: p.value.animatedRotation,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : Ne("", !0),
            y("input", {
              type: "range",
              value: f.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: P[9] || (P[9] = (V) => T("rotation", Number(V.target.value)))
            }, null, 40, nz),
            y("span", iz, Ae(f.value.rotation) + "", 1)
          ])
        ])) : Ne("", !0)
      ]),
      y("div", sz, [
        y("div", {
          class: "section-header",
          onClick: P[10] || (P[10] = (V) => C("depth"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[35] || (P[35] = y("span", null, "Depth Settings", -1))
        ]),
        u.value.has("depth") ? (ie(), ue("div", rz, [
          y("div", oz, [
            P[36] || (P[36] = y("label", null, "Depth Scale", -1)),
            p.value.animatedDepthScale ? (ie(), Et(No, {
              key: 0,
              property: p.value.animatedDepthScale,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : Ne("", !0),
            y("input", {
              type: "range",
              value: f.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: P[11] || (P[11] = (V) => T("depthScale", Number(V.target.value)))
            }, null, 40, az),
            y("span", lz, Ae(f.value.depthScale.toFixed(2)), 1)
          ]),
          y("div", cz, [
            P[37] || (P[37] = y("label", null, "Focus Depth", -1)),
            y("input", {
              type: "range",
              value: f.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: P[12] || (P[12] = (V) => T("focusDepth", Number(V.target.value)))
            }, null, 40, uz),
            y("span", hz, Ae(f.value.focusDepth.toFixed(2)), 1)
          ]),
          P[38] || (P[38] = y("div", { class: "depth-hint" }, [
            xt(" Objects at focus depth stay stationary."),
            y("br"),
            xt(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Ne("", !0)
      ]),
      x.value ? (ie(), ue("div", dz, [
        y("div", {
          class: "section-header",
          onClick: P[13] || (P[13] = (V) => C("presetSettings"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          y("span", null, Ae(M.value), 1)
        ]),
        u.value.has("presetSettings") ? (ie(), ue("div", fz, [
          v.value ? (ie(), ue(nt, { key: 0 }, [
            y("div", pz, [
              P[39] || (P[39] = y("label", null, "Orbit Radius", -1)),
              y("input", {
                type: "range",
                value: f.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: P[14] || (P[14] = (V) => T("orbitRadius", Number(V.target.value)))
              }, null, 40, mz),
              y("span", gz, Ae(f.value.orbitRadius.toFixed(2)), 1)
            ]),
            y("div", vz, [
              P[40] || (P[40] = y("label", null, "Orbit Speed", -1)),
              y("input", {
                type: "range",
                value: f.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: P[15] || (P[15] = (V) => T("orbitSpeed", Number(V.target.value)))
              }, null, 40, yz),
              y("span", _z, Ae(f.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Ne("", !0),
          S.value ? (ie(), ue(nt, { key: 1 }, [
            y("div", xz, [
              P[41] || (P[41] = y("label", null, "Amplitude", -1)),
              y("input", {
                type: "range",
                value: f.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: P[16] || (P[16] = (V) => T("swingAmplitude", Number(V.target.value)))
              }, null, 40, bz),
              y("span", wz, Ae(f.value.swingAmplitude.toFixed(2)), 1)
            ]),
            y("div", Sz, [
              P[42] || (P[42] = y("label", null, "Frequency", -1)),
              y("input", {
                type: "range",
                value: f.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: P[17] || (P[17] = (V) => T("swingFrequency", Number(V.target.value)))
              }, null, 40, Mz),
              y("span", Cz, Ae(f.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Ne("", !0),
          b.value ? (ie(), ue("div", Tz, [
            P[43] || (P[43] = y("label", null, "Dolly Rate", -1)),
            y("input", {
              type: "range",
              value: f.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: P[18] || (P[18] = (V) => T("dollyZoom", Number(V.target.value)))
            }, null, 40, Ez),
            y("span", Az, Ae(f.value.dollyZoom.toFixed(2)), 1)
          ])) : Ne("", !0)
        ])) : Ne("", !0)
      ])) : Ne("", !0),
      y("div", Pz, [
        y("div", {
          class: "section-header",
          onClick: P[19] || (P[19] = (V) => C("quality"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[44] || (P[44] = y("span", null, "Quality", -1))
        ]),
        u.value.has("quality") ? (ie(), ue("div", Dz, [
          y("div", kz, [
            P[45] || (P[45] = y("label", null, "Edge Dilation", -1)),
            y("input", {
              type: "range",
              value: f.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: P[20] || (P[20] = (V) => T("edgeDilation", Number(V.target.value)))
            }, null, 40, Rz),
            y("span", Lz, Ae(f.value.edgeDilation) + "px", 1)
          ]),
          y("div", Iz, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: f.value.inpaintEdges,
                onChange: P[21] || (P[21] = (V) => T("inpaintEdges", V.target.checked))
              }, null, 40, Oz),
              P[46] || (P[46] = xt(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Ne("", !0)
      ]),
      y("div", Fz, [
        y("div", {
          class: "section-header",
          onClick: P[22] || (P[22] = (V) => C("preview"))
        }, [
          y("i", {
            class: Ye(["pi", u.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          P[47] || (P[47] = y("span", null, "Preview", -1))
        ]),
        u.value.has("preview") ? (ie(), ue("div", Uz, [
          y("div", zz, [
            y("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Rs,
              height: Rs
            }, null, 512)
          ]),
          y("div", Bz, [
            y("button", {
              class: Ye(["preview-btn", { active: a.value }]),
              onClick: O
            }, [
              y("i", {
                class: Ye(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              xt(" " + Ae(a.value ? "Pause" : "Play"), 1)
            ], 2),
            y("span", Nz, " Frame " + Ae(l.value) + " / " + Ae(m.value - 1), 1)
          ])
        ])) : Ne("", !0)
      ])
    ]));
  }
}), Gz = /* @__PURE__ */ Yt(Vz, [["__scopeId", "data-v-ffaf4c8a"]]), Hz = { class: "light-properties" }, Wz = { class: "property-section" }, jz = { class: "section-content" }, $z = { class: "property-row" }, Xz = ["value"], Yz = { class: "property-group" }, qz = { class: "property-group" }, Zz = { class: "control-row" }, Kz = { class: "property-group" }, Jz = { class: "control-row" }, Qz = { class: "property-group" }, eB = {
  key: 1,
  class: "property-row"
}, tB = ["value"], nB = {
  key: 2,
  class: "property-group"
}, iB = {
  key: 3,
  class: "property-group"
}, sB = { class: "property-group checkbox-row" }, rB = ["checked"], oB = { class: "property-group" }, aB = { class: "property-group" }, lB = {
  key: 5,
  class: "note"
}, cB = /* @__PURE__ */ jt({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Xe(() => n.layer.data || {
      lightType: "spot",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "none",
      falloffDistance: 500,
      castShadows: !1,
      shadowDarkness: 100,
      shadowDiffusion: 0,
      coneAngle: 90,
      coneFeather: 50
    });
    function a(l, c) {
      s.updateLayer(n.layer.id, {
        data: { ...o.value, [l]: c }
      }), i("update");
    }
    return (l, c) => (ie(), ue("div", Hz, [
      y("div", Wz, [
        c[25] || (c[25] = y("div", { class: "section-header" }, "Light Settings", -1)),
        y("div", jz, [
          y("div", $z, [
            c[13] || (c[13] = y("label", null, "Type", -1)),
            y("select", {
              value: o.value.lightType,
              onChange: c[0] || (c[0] = (u) => a("lightType", u.target.value)),
              class: "type-select"
            }, [...c[12] || (c[12] = [
              y("option", { value: "parallel" }, "Parallel", -1),
              y("option", { value: "spot" }, "Spot", -1),
              y("option", { value: "point" }, "Point", -1),
              y("option", { value: "ambient" }, "Ambient", -1)
            ])], 40, Xz)
          ]),
          y("div", Yz, [
            c[14] || (c[14] = y("label", null, "Color", -1)),
            Ze(Je(Cd), {
              modelValue: o.value.color,
              "onUpdate:modelValue": c[1] || (c[1] = (u) => a("color", u))
            }, null, 8, ["modelValue"])
          ]),
          y("div", qz, [
            c[15] || (c[15] = y("label", null, "Intensity", -1)),
            y("div", Zz, [
              Ze(Je(Di), {
                modelValue: o.value.intensity,
                "onUpdate:modelValue": c[2] || (c[2] = (u) => a("intensity", u)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          o.value.lightType === "spot" ? (ie(), ue(nt, { key: 0 }, [
            y("div", Kz, [
              c[16] || (c[16] = y("label", null, "Cone Angle", -1)),
              y("div", Jz, [
                Ze(Je(fv), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[3] || (c[3] = (u) => a("coneAngle", u)),
                  size: 32
                }, null, 8, ["modelValue"]),
                Ze(Je(rt), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[4] || (c[4] = (u) => a("coneAngle", u)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            y("div", Qz, [
              c[17] || (c[17] = y("label", null, "Cone Feather", -1)),
              Ze(Je(Di), {
                modelValue: o.value.coneFeather ?? 50,
                "onUpdate:modelValue": c[5] || (c[5] = (u) => a("coneFeather", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Ne("", !0),
          o.value.lightType !== "ambient" ? (ie(), ue("div", eB, [
            c[19] || (c[19] = y("label", null, "Falloff", -1)),
            y("select", {
              value: o.value.falloff,
              onChange: c[6] || (c[6] = (u) => a("falloff", u.target.value)),
              class: "type-select"
            }, [...c[18] || (c[18] = [
              y("option", { value: "none" }, "None", -1),
              y("option", { value: "smooth" }, "Smooth", -1),
              y("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
            ])], 40, tB)
          ])) : Ne("", !0),
          o.value.lightType !== "ambient" && o.value.lightType !== "parallel" ? (ie(), ue("div", nB, [
            c[20] || (c[20] = y("label", null, "Radius", -1)),
            Ze(Je(rt), {
              modelValue: o.value.radius,
              "onUpdate:modelValue": c[7] || (c[7] = (u) => a("radius", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Ne("", !0),
          o.value.lightType !== "ambient" ? (ie(), ue("div", iB, [
            c[21] || (c[21] = y("label", null, "Falloff Distance", -1)),
            Ze(Je(rt), {
              modelValue: o.value.falloffDistance ?? 500,
              "onUpdate:modelValue": c[8] || (c[8] = (u) => a("falloffDistance", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Ne("", !0),
          y("div", sB, [
            y("label", null, [
              y("input", {
                type: "checkbox",
                checked: o.value.castShadows,
                onChange: c[9] || (c[9] = (u) => a("castShadows", u.target.checked))
              }, null, 40, rB),
              c[22] || (c[22] = xt(" Casts Shadows ", -1))
            ])
          ]),
          o.value.castShadows ? (ie(), ue(nt, { key: 4 }, [
            y("div", oB, [
              c[23] || (c[23] = y("label", null, "Shadow Darkness", -1)),
              Ze(Je(Di), {
                modelValue: o.value.shadowDarkness ?? 100,
                "onUpdate:modelValue": c[10] || (c[10] = (u) => a("shadowDarkness", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            y("div", aB, [
              c[24] || (c[24] = y("label", null, "Shadow Diffusion", -1)),
              Ze(Je(rt), {
                modelValue: o.value.shadowDiffusion ?? 0,
                "onUpdate:modelValue": c[11] || (c[11] = (u) => a("shadowDiffusion", u)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Ne("", !0),
          o.value.castShadows ? (ie(), ue("div", lB, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : Ne("", !0)
        ])
      ])
    ]));
  }
}), uB = /* @__PURE__ */ Yt(cB, [["__scopeId", "data-v-7bf0f1bf"]]), hB = { class: "shape-properties" }, dB = { class: "property-section" }, fB = { class: "section-content" }, pB = { class: "property-group" }, mB = { class: "group-header" }, gB = ["checked"], vB = {
  key: 0,
  class: "control-row"
}, yB = { class: "property-group" }, _B = { class: "group-header" }, xB = ["checked"], bB = {
  key: 0,
  class: "stroke-controls"
}, wB = { class: "control-row" }, SB = { class: "property-row" }, MB = { class: "property-row" }, CB = { class: "icon-toggle-group" }, TB = { class: "property-group" }, EB = { class: "control-row checkbox-row" }, AB = ["checked"], PB = /* @__PURE__ */ jt({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Xe(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), a = Xe(() => !!o.value.fill && o.value.fill !== "transparent"), l = Xe(() => !!o.value.stroke && o.value.strokeWidth > 0), c = Xe(() => o.value.strokeLineCap || "round");
    function u(p, f) {
      s.updateLayer(n.layer.id, {
        data: { ...o.value, [p]: f }
      }), i("update");
    }
    function h(p) {
      const f = p.target.checked;
      u("fill", f ? "#ffffff" : "");
    }
    function d(p) {
      p.target.checked ? (u("stroke", "#ffffff"), u("strokeWidth", 2)) : u("strokeWidth", 0);
    }
    return (p, f) => (ie(), ue("div", hB, [
      y("div", dB, [
        f[13] || (f[13] = y("div", { class: "section-header" }, "Shape Appearance", -1)),
        y("div", fB, [
          y("div", pB, [
            y("div", mB, [
              f[7] || (f[7] = y("label", null, "Fill", -1)),
              y("input", {
                type: "checkbox",
                checked: a.value,
                onChange: h
              }, null, 40, gB)
            ]),
            a.value ? (ie(), ue("div", vB, [
              Ze(Je(Cd), {
                modelValue: o.value.fill || "#ffffff",
                "onUpdate:modelValue": f[0] || (f[0] = (m) => u("fill", m)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Ne("", !0)
          ]),
          y("div", yB, [
            y("div", _B, [
              f[8] || (f[8] = y("label", null, "Stroke", -1)),
              y("input", {
                type: "checkbox",
                checked: l.value,
                onChange: d
              }, null, 40, xB)
            ]),
            l.value ? (ie(), ue("div", bB, [
              y("div", wB, [
                Ze(Je(Cd), {
                  modelValue: o.value.stroke || "#ffffff",
                  "onUpdate:modelValue": f[1] || (f[1] = (m) => u("stroke", m)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              y("div", SB, [
                f[9] || (f[9] = y("label", { class: "sub-label" }, "Width", -1)),
                Ze(Je(rt), {
                  modelValue: o.value.strokeWidth || 0,
                  "onUpdate:modelValue": f[2] || (f[2] = (m) => u("strokeWidth", m)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              y("div", MB, [
                f[10] || (f[10] = y("label", { class: "sub-label" }, "Cap", -1)),
                y("div", CB, [
                  y("button", {
                    class: Ye({ active: c.value === "butt" }),
                    onClick: f[3] || (f[3] = (m) => u("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  y("button", {
                    class: Ye({ active: c.value === "round" }),
                    onClick: f[4] || (f[4] = (m) => u("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  y("button", {
                    class: Ye({ active: c.value === "square" }),
                    onClick: f[5] || (f[5] = (m) => u("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Ne("", !0)
          ]),
          y("div", TB, [
            f[12] || (f[12] = y("label", null, "Path", -1)),
            y("div", EB, [
              y("label", null, [
                y("input", {
                  type: "checkbox",
                  checked: o.value.closed,
                  onChange: f[6] || (f[6] = (m) => u("closed", m.target.checked))
                }, null, 40, AB),
                f[11] || (f[11] = xt(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), DB = /* @__PURE__ */ Yt(PB, [["__scopeId", "data-v-e2af8c92"]]), kB = { class: "video-properties" }, RB = {
  key: 0,
  class: "property-section"
}, LB = { class: "section-content info-grid" }, IB = { class: "info-row" }, OB = { class: "info-value" }, FB = { class: "info-row" }, UB = { class: "info-value" }, zB = { class: "info-row" }, BB = { class: "info-value" }, NB = { class: "info-row" }, VB = { class: "info-value" }, GB = { class: "property-section" }, HB = { class: "section-content" }, WB = { class: "property-row" }, jB = { class: "property-row" }, $B = { class: "property-row" }, XB = { class: "checkbox-group" }, YB = { class: "checkbox-row" }, qB = ["checked"], ZB = { class: "checkbox-row" }, KB = ["checked"], JB = { class: "property-section" }, QB = { class: "section-header" }, eN = { class: "header-toggle" }, tN = ["checked"], nN = {
  key: 0,
  class: "section-content"
}, iN = { class: "property-row" }, sN = { class: "control-with-keyframe" }, rN = { class: "property-section" }, oN = { class: "section-content" }, aN = { class: "property-row" }, lN = ["value"], cN = {
  key: 1,
  class: "property-section"
}, uN = { class: "section-content" }, hN = { class: "checkbox-group" }, dN = { class: "checkbox-row" }, fN = ["checked"], pN = {
  key: 0,
  class: "property-row"
}, mN = { class: "control-with-keyframe" }, gN = {
  key: 1,
  class: "property-row"
}, vN = {
  key: 2,
  class: "waveform-container"
}, yN = /* @__PURE__ */ jt({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Xe(() => n.layer.data || {
      assetId: null,
      loop: !1,
      pingPong: !1,
      startTime: 0,
      endTime: void 0,
      speed: 1,
      timeRemapEnabled: !1,
      timeRemap: void 0,
      frameBlending: "none",
      audioEnabled: !0,
      audioLevel: 100,
      posterFrame: 0
    }), a = Xe(() => {
      const M = o.value.assetId;
      return M && s.assets[M] || null;
    }), l = Xe(() => {
      var M;
      return (M = n.layer.audio) == null ? void 0 : M.level;
    }), c = Xe(() => o.value.timeRemap ? o.value.timeRemap.value : 0);
    function u(M) {
      var w;
      if (!M) return "0:00";
      const C = Math.floor(M / 60), E = Math.floor(M % 60), T = Math.floor(M % 1 * (((w = a.value) == null ? void 0 : w.fps) || 30));
      return `${C}:${E.toString().padStart(2, "0")}:${T.toString().padStart(2, "0")}`;
    }
    function h(M) {
      s.updateVideoLayerData(n.layer.id, { speed: M }), i("update");
    }
    function d(M) {
      s.updateVideoLayerData(n.layer.id, { startTime: M }), i("update");
    }
    function p(M) {
      s.updateVideoLayerData(n.layer.id, { endTime: M }), i("update");
    }
    function f(M) {
      const C = M.target;
      s.updateVideoLayerData(n.layer.id, { loop: C.checked }), i("update");
    }
    function m(M) {
      const C = M.target;
      s.updateVideoLayerData(n.layer.id, { pingPong: C.checked }), i("update");
    }
    function _(M) {
      const C = M.target;
      s.updateVideoLayerData(n.layer.id, { timeRemapEnabled: C.checked }), i("update");
    }
    function g(M) {
      const C = n.layer.data;
      C.timeRemap && (C.timeRemap.value = M), i("update");
    }
    function v(M) {
      const C = M.target;
      s.updateVideoLayerData(n.layer.id, { frameBlending: C.value }), i("update");
    }
    function S(M) {
      const C = M.target;
      s.updateVideoLayerData(n.layer.id, { audioEnabled: C.checked }), i("update");
    }
    function b(M) {
      s.updateVideoLayerData(n.layer.id, { audioLevel: M }), i("update");
    }
    function x(M) {
      var C;
      (C = n.layer.audio) != null && C.level && (n.layer.audio.level.value = M, i("update"));
    }
    return (M, C) => {
      var E, T, w;
      return ie(), ue("div", kB, [
        a.value ? (ie(), ue("div", RB, [
          C[4] || (C[4] = y("div", { class: "section-header" }, "Video Info", -1)),
          y("div", LB, [
            y("div", IB, [
              C[0] || (C[0] = y("span", { class: "info-label" }, "Dimensions", -1)),
              y("span", OB, Ae(a.value.width) + "  " + Ae(a.value.height), 1)
            ]),
            y("div", FB, [
              C[1] || (C[1] = y("span", { class: "info-label" }, "Duration", -1)),
              y("span", UB, Ae(u(a.value.duration)), 1)
            ]),
            y("div", zB, [
              C[2] || (C[2] = y("span", { class: "info-label" }, "Frame Rate", -1)),
              y("span", BB, Ae(((E = a.value.fps) == null ? void 0 : E.toFixed(2)) || "?") + " fps", 1)
            ]),
            y("div", NB, [
              C[3] || (C[3] = y("span", { class: "info-label" }, "Has Audio", -1)),
              y("span", VB, Ae(a.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : Ne("", !0),
        y("div", GB, [
          C[10] || (C[10] = y("div", { class: "section-header" }, "Playback", -1)),
          y("div", HB, [
            y("div", WB, [
              C[5] || (C[5] = y("label", null, "Speed", -1)),
              Ze(Je(rt), {
                modelValue: o.value.speed,
                "onUpdate:modelValue": h,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            y("div", jB, [
              C[6] || (C[6] = y("label", null, "Start Time", -1)),
              Ze(Je(rt), {
                modelValue: o.value.startTime,
                "onUpdate:modelValue": d,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            y("div", $B, [
              C[7] || (C[7] = y("label", null, "End Time", -1)),
              Ze(Je(rt), {
                modelValue: o.value.endTime || ((T = a.value) == null ? void 0 : T.duration) || 0,
                "onUpdate:modelValue": p,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            y("div", XB, [
              y("label", YB, [
                y("input", {
                  type: "checkbox",
                  checked: o.value.loop,
                  onChange: f
                }, null, 40, qB),
                C[8] || (C[8] = y("span", null, "Loop", -1))
              ]),
              y("label", ZB, [
                y("input", {
                  type: "checkbox",
                  checked: o.value.pingPong,
                  onChange: m
                }, null, 40, KB),
                C[9] || (C[9] = y("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        y("div", JB, [
          y("div", QB, [
            C[11] || (C[11] = y("span", null, "Time Remap", -1)),
            y("label", eN, [
              y("input", {
                type: "checkbox",
                checked: o.value.timeRemapEnabled,
                onChange: _
              }, null, 40, tN)
            ])
          ]),
          o.value.timeRemapEnabled ? (ie(), ue("div", nN, [
            y("div", iN, [
              C[12] || (C[12] = y("label", null, "Remap Time", -1)),
              y("div", sN, [
                Ze(Je(rt), {
                  modelValue: c.value,
                  "onUpdate:modelValue": g,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                o.value.timeRemap ? (ie(), Et(No, {
                  key: 0,
                  property: o.value.timeRemap,
                  layerId: r.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : Ne("", !0)
              ])
            ]),
            C[13] || (C[13] = y("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : Ne("", !0)
        ]),
        y("div", rN, [
          C[16] || (C[16] = y("div", { class: "section-header" }, "Frame Blending", -1)),
          y("div", oN, [
            y("div", aN, [
              C[15] || (C[15] = y("label", null, "Mode", -1)),
              y("select", {
                value: o.value.frameBlending,
                onChange: v,
                class: "select-input"
              }, [...C[14] || (C[14] = [
                y("option", { value: "none" }, "None", -1),
                y("option", { value: "frame-mix" }, "Frame Mix", -1),
                y("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, lN)
            ])
          ])
        ]),
        ((w = a.value) == null ? void 0 : w.hasAudio) !== !1 ? (ie(), ue("div", cN, [
          C[21] || (C[21] = y("div", { class: "section-header" }, "Audio", -1)),
          y("div", uN, [
            y("div", hN, [
              y("label", dN, [
                y("input", {
                  type: "checkbox",
                  checked: o.value.audioEnabled,
                  onChange: S
                }, null, 40, fN),
                C[17] || (C[17] = y("span", null, "Audio Enabled", -1))
              ])
            ]),
            o.value.audioEnabled ? (ie(), ue("div", pN, [
              C[18] || (C[18] = y("label", null, "Level", -1)),
              y("div", mN, [
                l.value ? (ie(), Et(Je(rt), {
                  key: 0,
                  modelValue: l.value.value,
                  "onUpdate:modelValue": x,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : Ne("", !0),
                l.value ? (ie(), Et(No, {
                  key: 1,
                  property: l.value,
                  layerId: r.layer.id
                }, null, 8, ["property", "layerId"])) : Ne("", !0)
              ])
            ])) : Ne("", !0),
            o.value.audioEnabled ? (ie(), ue("div", gN, [
              C[19] || (C[19] = y("label", null, "Volume", -1)),
              Ze(Je(rt), {
                modelValue: o.value.audioLevel,
                "onUpdate:modelValue": b,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : Ne("", !0),
            o.value.audioEnabled ? (ie(), ue("div", vN, [...C[20] || (C[20] = [
              y("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : Ne("", !0)
          ])
        ])) : Ne("", !0)
      ]);
    };
  }
}), _N = /* @__PURE__ */ Yt(yN, [["__scopeId", "data-v-5f46759a"]]), xN = ["title"], bN = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
}, wN = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, SN = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, MN = ["x1", "y1", "x2", "y2"], CN = ["cx", "cy"], TN = { class: "drop-label" }, EN = /* @__PURE__ */ jt({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce(null), o = Ce(!1), a = Ce({ x: 0, y: 0 }), l = Ce({ x: 0, y: 0 }), c = Ce(null), u = Xe(() => !!n.linkedTo), h = Xe(() => n.linkedTo ? `${n.linkedTo.layerId}.${n.linkedTo.property}` : ""), d = Xe(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    })), p = Xe(() => {
      if (!c.value) return {};
      const x = c.value.rect;
      return {
        position: "fixed",
        top: `${x.top}px`,
        left: `${x.left}px`,
        width: `${x.width}px`,
        height: `${x.height}px`,
        zIndex: 9999
      };
    });
    function f() {
      const x = [];
      return document.querySelectorAll("[data-pickwhip-target]").forEach((C) => {
        const E = C, T = E.dataset.pickwhipLayerId, w = E.dataset.pickwhipTarget, A = E.dataset.pickwhipLabel || w;
        T === n.layerId && w === n.property || T && w && x.push({
          layerId: T,
          property: w,
          label: A,
          element: E,
          rect: E.getBoundingClientRect()
        });
      }), x;
    }
    function m(x, M, C) {
      for (const E of C) {
        const T = E.rect;
        if (x >= T.left && x <= T.right && M >= T.top && M <= T.bottom)
          return E;
      }
      return null;
    }
    let _ = [];
    function g(x) {
      var T;
      x.preventDefault(), x.stopPropagation();
      const M = "touches" in x ? x.touches[0].clientX : x.clientX, C = "touches" in x ? x.touches[0].clientY : x.clientY, E = (T = s.value) == null ? void 0 : T.getBoundingClientRect();
      E ? a.value = { x: E.left + E.width / 2, y: E.top + E.height / 2 } : a.value = { x: M, y: C }, l.value = { x: M, y: C }, o.value = !0, _ = f(), window.addEventListener("mousemove", v), window.addEventListener("mouseup", S), window.addEventListener("touchmove", v), window.addEventListener("touchend", S);
    }
    function v(x) {
      if (!o.value) return;
      const M = "touches" in x ? x.touches[0].clientX : x.clientX, C = "touches" in x ? x.touches[0].clientY : x.clientY;
      l.value = { x: M, y: C }, _.forEach((E) => {
        E.rect = E.element.getBoundingClientRect();
      }), c.value = m(M, C, _);
    }
    function S(x) {
      if (!o.value) return;
      const M = "changedTouches" in x ? x.changedTouches[0].clientX : x.clientX, C = "changedTouches" in x ? x.changedTouches[0].clientY : x.clientY, E = m(M, C, _);
      E && i("link", { layerId: E.layerId, property: E.property }), o.value = !1, c.value = null, _ = [], window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", S), window.removeEventListener("touchmove", v), window.removeEventListener("touchend", S);
    }
    function b() {
      i("unlink");
    }
    return Ni(() => {
      window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", S), window.removeEventListener("touchmove", v), window.removeEventListener("touchend", S);
    }), (x, M) => (ie(), ue("div", {
      class: "pickwhip-container",
      ref_key: "containerRef",
      ref: s
    }, [
      y("div", {
        class: Ye(["pickwhip-handle", { dragging: o.value, linked: u.value }]),
        onMousedown: g,
        onTouchstart: Rt(g, ["prevent"]),
        title: u.value ? `Linked to: ${h.value}` : "Drag to link property"
      }, [
        (ie(), ue("svg", bN, [
          M[0] || (M[0] = y("circle", {
            cx: "8",
            cy: "8",
            r: "3",
            fill: "currentColor"
          }, null, -1)),
          u.value ? (ie(), ue("path", SN)) : (ie(), ue("path", wN))
        ]))
      ], 42, xN),
      u.value ? (ie(), ue("button", {
        key: 0,
        class: "clear-link-btn",
        onClick: b,
        title: "Remove link"
      }, "  ")) : Ne("", !0),
      (ie(), Et(sm, { to: "body" }, [
        o.value ? (ie(), ue("svg", {
          key: 0,
          class: "pickwhip-line",
          style: Ct(d.value)
        }, [
          y("line", {
            x1: a.value.x,
            y1: a.value.y,
            x2: l.value.x,
            y2: l.value.y,
            stroke: "#4a90d9",
            "stroke-width": "2",
            "stroke-dasharray": "4 2"
          }, null, 8, MN),
          y("circle", {
            cx: l.value.x,
            cy: l.value.y,
            r: "6",
            fill: "#4a90d9",
            stroke: "#fff",
            "stroke-width": "1"
          }, null, 8, CN)
        ], 4)) : Ne("", !0)
      ])),
      (ie(), Et(sm, { to: "body" }, [
        o.value && c.value ? (ie(), ue("div", {
          key: 0,
          class: "drop-target-highlight",
          style: Ct(p.value)
        }, [
          y("span", TN, Ae(c.value.label), 1)
        ], 4)) : Ne("", !0)
      ]))
    ], 512));
  }
}), rh = /* @__PURE__ */ Yt(EN, [["__scopeId", "data-v-da1938e3"]]), AN = {
  key: 0,
  class: "driver-list"
}, PN = { class: "expand-icon" }, DN = { class: "count" }, kN = {
  key: 0,
  class: "driver-items"
}, RN = { class: "driver-header" }, LN = ["onClick"], IN = { class: "driver-info" }, ON = { class: "target" }, FN = {
  key: 0,
  class: "source"
}, UN = {
  key: 1,
  class: "source audio"
}, zN = {
  key: 2,
  class: "source time"
}, BN = ["onClick"], NN = {
  key: 0,
  class: "driver-transforms"
}, VN = ["title"], GN = {
  key: 1,
  class: "add-driver-section"
}, HN = {
  key: 0,
  class: "add-menu"
}, WN = { class: "menu-section" }, jN = { class: "menu-section" }, $N = { class: "menu-section" }, XN = { class: "menu-section" }, YN = { class: "menu-actions" }, qN = /* @__PURE__ */ jt({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(r) {
    const e = r, n = _n(), i = Ce(!0), s = Ce(!1), o = Ce({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    }), a = Xe(() => n.getDriversForLayer(e.layerId));
    function l(f) {
      return f ? {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        opacity: "Opacity"
      }[f] || f : "?";
    }
    function c(f) {
      if (!f) return "?";
      const m = n.layers.find((_) => _.id === f);
      return (m == null ? void 0 : m.name) || f.slice(0, 8);
    }
    function u(f) {
      switch (f.type) {
        case "scale":
          return `Scale: ${f.factor}`;
        case "offset":
          return `Offset: ${f.amount}`;
        case "clamp":
          return `Clamp: ${f.min}-${f.max}`;
        case "smooth":
          return `Smooth: ${f.smoothing}`;
        case "threshold":
          return `Threshold: ${f.threshold}`;
        default:
          return f.type;
      }
    }
    function h(f) {
      n.togglePropertyDriver(f);
    }
    function d(f) {
      n.removePropertyDriver(f);
    }
    function p() {
      n.createAudioPropertyDriver(
        e.layerId,
        o.value.targetProperty,
        o.value.audioFeature,
        {
          scale: o.value.scale,
          threshold: o.value.threshold > 0 ? o.value.threshold : void 0
        }
      ), s.value = !1;
    }
    return (f, m) => a.value.length > 0 ? (ie(), ue("div", AN, [
      y("div", {
        class: "driver-list-header",
        onClick: m[0] || (m[0] = (_) => i.value = !i.value)
      }, [
        y("span", PN, Ae(i.value ? "" : ""), 1),
        m[7] || (m[7] = y("span", { class: "title" }, "Property Drivers", -1)),
        y("span", DN, "(" + Ae(a.value.length) + ")", 1)
      ]),
      i.value ? (ie(), ue("div", kN, [
        (ie(!0), ue(nt, null, pt(a.value, (_) => (ie(), ue("div", {
          key: _.id,
          class: Ye(["driver-item", { disabled: !_.enabled }])
        }, [
          y("div", RN, [
            y("button", {
              class: Ye(["toggle-btn", { active: _.enabled }]),
              onClick: (g) => h(_.id),
              title: "Toggle driver"
            }, "  ", 10, LN),
            y("div", IN, [
              y("span", ON, Ae(l(_.targetProperty)), 1),
              m[8] || (m[8] = y("span", { class: "arrow" }, "", -1)),
              _.sourceType === "property" ? (ie(), ue("span", FN, Ae(c(_.sourceLayerId)) + "." + Ae(l(_.sourceProperty)), 1)) : _.sourceType === "audio" ? (ie(), ue("span", UN, "  " + Ae(_.audioFeature), 1)) : _.sourceType === "time" ? (ie(), ue("span", zN, "  Time ")) : Ne("", !0)
            ]),
            y("button", {
              class: "remove-btn",
              onClick: (g) => d(_.id),
              title: "Remove driver"
            }, "  ", 8, BN)
          ]),
          _.transforms.length > 0 ? (ie(), ue("div", NN, [
            (ie(!0), ue(nt, null, pt(_.transforms, (g, v) => (ie(), ue("span", {
              key: v,
              class: "transform-chip",
              title: u(g)
            }, Ae(g.type), 9, VN))), 128))
          ])) : Ne("", !0)
        ], 2))), 128))
      ])) : Ne("", !0),
      i.value ? (ie(), ue("div", GN, [
        y("button", {
          class: "add-driver-btn",
          onClick: m[1] || (m[1] = (_) => s.value = !s.value)
        }, " + Add Audio Driver "),
        s.value ? (ie(), ue("div", HN, [
          y("div", WN, [
            m[10] || (m[10] = y("label", null, "Audio Feature:", -1)),
            wt(y("select", {
              "onUpdate:modelValue": m[2] || (m[2] = (_) => o.value.audioFeature = _)
            }, [...m[9] || (m[9] = [
              ea('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
            ])], 512), [
              [ns, o.value.audioFeature]
            ])
          ]),
          y("div", jN, [
            m[12] || (m[12] = y("label", null, "Target Property:", -1)),
            wt(y("select", {
              "onUpdate:modelValue": m[3] || (m[3] = (_) => o.value.targetProperty = _)
            }, [...m[11] || (m[11] = [
              ea('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
            ])], 512), [
              [ns, o.value.targetProperty]
            ])
          ]),
          y("div", $N, [
            m[13] || (m[13] = y("label", null, "Scale:", -1)),
            wt(y("input", {
              type: "number",
              "onUpdate:modelValue": m[4] || (m[4] = (_) => o.value.scale = _),
              step: "10"
            }, null, 512), [
              [
                Tn,
                o.value.scale,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          y("div", XN, [
            m[14] || (m[14] = y("label", null, "Threshold:", -1)),
            wt(y("input", {
              type: "number",
              "onUpdate:modelValue": m[5] || (m[5] = (_) => o.value.threshold = _),
              min: "0",
              max: "1",
              step: "0.1"
            }, null, 512), [
              [
                Tn,
                o.value.threshold,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          y("div", YN, [
            y("button", { onClick: p }, "Create"),
            y("button", {
              onClick: m[6] || (m[6] = (_) => s.value = !1)
            }, "Cancel")
          ])
        ])) : Ne("", !0)
      ])) : Ne("", !0)
    ])) : Ne("", !0);
  }
}), ZN = /* @__PURE__ */ Yt(qN, [["__scopeId", "data-v-d3107912"]]), KN = { class: "properties-panel" }, JN = {
  key: 0,
  class: "panel-content"
}, QN = { class: "property-section" }, e6 = { class: "property-row" }, t6 = { class: "property-section" }, n6 = { class: "property-row" }, i6 = ["value"], s6 = ["value"], r6 = { class: "property-section" }, o6 = { class: "expand-icon" }, a6 = {
  key: 0,
  class: "section-content"
}, l6 = ["data-pickwhip-layer-id"], c6 = { class: "multi-value" }, u6 = { class: "multi-value" }, h6 = { class: "property-row" }, d6 = { class: "multi-value orientation-row" }, f6 = { class: "property-row" }, p6 = { class: "single-value" }, m6 = { class: "property-row" }, g6 = { class: "single-value" }, v6 = { class: "property-row" }, y6 = { class: "single-value" }, _6 = { class: "single-value" }, x6 = { class: "property-row" }, b6 = { class: "multi-value" }, w6 = { class: "single-value" }, S6 = { class: "property-section" }, M6 = { class: "property-row" }, C6 = ["value"], T6 = {
  key: 1,
  class: "empty-state"
}, E6 = /* @__PURE__ */ jt({
  __name: "PropertiesPanel",
  setup(r) {
    const e = _n(), n = Ce(["transform"]), i = Ce(!0), s = Ce(""), o = Ce({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), a = Ce("normal"), l = Ce([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], u = Xe(() => e.selectedLayer), h = Xe(() => {
      if (!u.value) return [];
      const T = u.value.id, w = (O) => {
        const U = e.layers.filter((L) => L.parentId === O);
        let D = U.map((L) => L.id);
        for (const L of U)
          D = D.concat(w(L.id));
        return D;
      }, A = new Set(w(T));
      return e.layers.filter(
        (O) => O.id !== T && !A.has(O.id) && O.type !== "camera"
        // Camera layers shouldn't be parents
      );
    }), d = Xe(() => {
      if (!u.value) return null;
      switch (u.value.type) {
        case "text":
          return cr(CO);
        case "particles":
          return cr(CU);
        case "depthflow":
          return cr(Gz);
        case "light":
          return cr(uB);
        case "spline":
          return cr(DB);
        case "video":
          return cr(_N);
        default:
          return null;
      }
    });
    At(u, (T) => {
      var w, A, O, U, D, L, P, V, ce, q, oe, ne, $, J, se, le, re, ye, H, K, G, R, z, I, Q;
      if (T) {
        s.value = T.name;
        const X = T.transform;
        o.value = {
          position: {
            x: ((A = (w = X == null ? void 0 : X.position) == null ? void 0 : w.value) == null ? void 0 : A.x) || 0,
            y: ((U = (O = X == null ? void 0 : X.position) == null ? void 0 : O.value) == null ? void 0 : U.y) || 0,
            z: ((L = (D = X == null ? void 0 : X.position) == null ? void 0 : D.value) == null ? void 0 : L.z) || 0
          },
          scale: { x: ((V = (P = X == null ? void 0 : X.scale) == null ? void 0 : P.value) == null ? void 0 : V.x) || 100, y: ((q = (ce = X == null ? void 0 : X.scale) == null ? void 0 : ce.value) == null ? void 0 : q.y) || 100 },
          rotation: ((oe = X == null ? void 0 : X.rotation) == null ? void 0 : oe.value) || 0,
          anchorPoint: { x: (($ = (ne = X == null ? void 0 : X.anchorPoint) == null ? void 0 : ne.value) == null ? void 0 : $.x) || 0, y: ((se = (J = X == null ? void 0 : X.anchorPoint) == null ? void 0 : J.value) == null ? void 0 : se.y) || 0 },
          opacity: ((le = T.opacity) == null ? void 0 : le.value) || 100,
          // 3D properties
          orientationX: ((ye = (re = X == null ? void 0 : X.orientation) == null ? void 0 : re.value) == null ? void 0 : ye.x) || 0,
          orientationY: ((K = (H = X == null ? void 0 : X.orientation) == null ? void 0 : H.value) == null ? void 0 : K.y) || 0,
          orientationZ: ((R = (G = X == null ? void 0 : X.orientation) == null ? void 0 : G.value) == null ? void 0 : R.z) || 0,
          rotationX: ((z = X == null ? void 0 : X.rotationX) == null ? void 0 : z.value) || 0,
          rotationY: ((I = X == null ? void 0 : X.rotationY) == null ? void 0 : I.value) || 0,
          rotationZ: ((Q = X == null ? void 0 : X.rotationZ) == null ? void 0 : Q.value) || 0
        }, a.value = T.blendMode || "normal";
      }
    }, { immediate: !0 }), At(() => o.value.scale.x, (T, w) => {
      if (i.value && T !== w) {
        const A = T / w;
        o.value.scale.y = Math.round(o.value.scale.y * A * 10) / 10;
      }
    });
    function p(T) {
      const w = n.value.indexOf(T);
      w >= 0 ? n.value.splice(w, 1) : n.value.push(T);
    }
    function f() {
      u.value && s.value && (u.value.name = s.value);
    }
    function m() {
      if (!u.value) return;
      const T = u.value.transform, w = o.value;
      T != null && T.position && (T.position.value = { x: w.position.x, y: w.position.y, z: w.position.z }), T != null && T.scale && (T.scale.value = { x: w.scale.x, y: w.scale.y }), T != null && T.rotation && (T.rotation.value = w.rotation), T != null && T.anchorPoint && (T.anchorPoint.value = { x: w.anchorPoint.x, y: w.anchorPoint.y }), u.value.opacity && (u.value.opacity.value = w.opacity), u.value.threeD && (T != null && T.orientation && (T.orientation.value = { x: w.orientationX, y: w.orientationY, z: w.orientationZ }), T != null && T.rotationX && (T.rotationX.value = w.rotationX), T != null && T.rotationY && (T.rotationY.value = w.rotationY), T != null && T.rotationZ && (T.rotationZ.value = w.rotationZ)), S();
    }
    function _() {
      u.value && (u.value.blendMode = a.value);
    }
    function g(T) {
      return l.value.includes(T);
    }
    function v(T) {
      const w = l.value.indexOf(T);
      w >= 0 ? l.value.splice(w, 1) : (l.value.push(T), console.log(`Added keyframe for ${T} at frame ${e.currentFrame}`));
    }
    function S(T) {
      u.value && (T && Object.keys(T).length > 0 ? e.updateLayerData(u.value.id, T) : e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
    function b(T) {
      if (!u.value) return;
      const w = T.target.value || null;
      e.setLayerParent(u.value.id, w);
    }
    function x(T) {
      if (!u.value) return null;
      const A = e.getDriversForLayer(u.value.id).find((O) => O.targetProperty === T && O.sourceType === "property");
      return A && A.sourceLayerId && A.sourceProperty ? {
        layerId: A.sourceLayerId,
        property: A.sourceProperty
      } : null;
    }
    function M(T, w) {
      u.value && (e.createPropertyLink(
        u.value.id,
        T,
        w.layerId,
        w.property,
        { blendMode: "add" }
      ), console.log(`[PropertiesPanel] Linked ${u.value.id}.${T} <- ${w.layerId}.${w.property}`));
    }
    function C(T) {
      if (!u.value) return;
      const A = e.getDriversForLayer(u.value.id).find((O) => O.targetProperty === T && O.sourceType === "property");
      A && (e.removePropertyDriver(A.id), console.log(`[PropertiesPanel] Unlinked ${u.value.id}.${T}`));
    }
    function E(T) {
      return u.value ? e.getDriversForLayer(u.value.id).some((A) => A.targetProperty === T && A.enabled) : !1;
    }
    return (T, w) => {
      var A, O, U, D, L, P, V, ce, q, oe, ne;
      return ie(), ue("div", KN, [
        w[49] || (w[49] = y("div", { class: "panel-header" }, [
          y("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        u.value ? (ie(), ue("div", JN, [
          y("div", QN, [
            y("div", e6, [
              wt(y("input", {
                type: "text",
                "onUpdate:modelValue": w[0] || (w[0] = ($) => s.value = $),
                class: "layer-name-input",
                onBlur: f,
                onKeydown: w[1] || (w[1] = zg(($) => $.target.blur(), ["enter"]))
              }, null, 544), [
                [Tn, s.value]
              ])
            ])
          ]),
          y("div", t6, [
            y("div", n6, [
              w[37] || (w[37] = y("label", null, "Parent", -1)),
              y("select", {
                class: "parent-select",
                value: ((A = u.value) == null ? void 0 : A.parentId) || "",
                onChange: b
              }, [
                w[36] || (w[36] = y("option", { value: "" }, "None", -1)),
                (ie(!0), ue(nt, null, pt(h.value, ($) => (ie(), ue("option", {
                  key: $.id,
                  value: $.id
                }, Ae($.name), 9, s6))), 128))
              ], 40, i6)
            ])
          ]),
          y("div", r6, [
            y("div", {
              class: "section-header",
              onClick: w[2] || (w[2] = ($) => p("transform"))
            }, [
              y("span", o6, Ae(n.value.includes("transform") ? "" : ""), 1),
              w[38] || (w[38] = y("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (ie(), ue("div", a6, [
              y("div", {
                class: Ye(["property-row", { "has-driver": E("transform.position.x") }])
              }, [
                u.value ? (ie(), Et(rh, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.position.x",
                  linkedTo: x("transform.position.x"),
                  onLink: w[3] || (w[3] = ($) => M("transform.position.x", $)),
                  onUnlink: w[4] || (w[4] = () => C("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Ne("", !0),
                y("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": (O = u.value) == null ? void 0 : O.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, l6),
                y("div", c6, [
                  Ze(Je(rt), {
                    modelValue: o.value.position.x,
                    "onUpdate:modelValue": [
                      w[5] || (w[5] = ($) => o.value.position.x = $),
                      m
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": (U = u.value) == null ? void 0 : U.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  Ze(Je(rt), {
                    modelValue: o.value.position.y,
                    "onUpdate:modelValue": [
                      w[6] || (w[6] = ($) => o.value.position.y = $),
                      m
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": (D = u.value) == null ? void 0 : D.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  (L = u.value) != null && L.threeD ? (ie(), Et(Je(rt), {
                    key: 0,
                    modelValue: o.value.position.z,
                    "onUpdate:modelValue": [
                      w[7] || (w[7] = ($) => o.value.position.z = $),
                      m
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": (P = u.value) == null ? void 0 : P.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : Ne("", !0)
                ]),
                y("button", {
                  class: Ye(["keyframe-btn", { active: g("position") }]),
                  onClick: w[8] || (w[8] = ($) => v("position"))
                }, "", 2)
              ], 2),
              y("div", {
                class: Ye(["property-row", { "has-driver": E("transform.scale.x") || E("transform.scale.y") }])
              }, [
                u.value ? (ie(), Et(rh, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.scale.x",
                  linkedTo: x("transform.scale.x"),
                  onLink: w[9] || (w[9] = ($) => M("transform.scale.x", $)),
                  onUnlink: w[10] || (w[10] = () => C("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Ne("", !0),
                w[39] || (w[39] = y("label", null, "Scale", -1)),
                y("div", u6, [
                  Ze(Je(rt), {
                    modelValue: o.value.scale.x,
                    "onUpdate:modelValue": [
                      w[11] || (w[11] = ($) => o.value.scale.x = $),
                      m
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": (V = u.value) == null ? void 0 : V.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  y("button", {
                    class: Ye(["link-btn", { active: i.value }]),
                    onClick: w[12] || (w[12] = ($) => i.value = !i.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  Ze(Je(rt), {
                    modelValue: o.value.scale.y,
                    "onUpdate:modelValue": [
                      w[13] || (w[13] = ($) => o.value.scale.y = $),
                      m
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": (ce = u.value) == null ? void 0 : ce.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                y("button", {
                  class: Ye(["keyframe-btn", { active: g("scale") }]),
                  onClick: w[14] || (w[14] = ($) => v("scale"))
                }, "", 2)
              ], 2),
              (q = u.value) != null && q.threeD ? (ie(), ue(nt, { key: 0 }, [
                y("div", h6, [
                  w[40] || (w[40] = y("label", null, "Orientation", -1)),
                  y("div", d6, [
                    Ze(Je(rt), {
                      modelValue: o.value.orientationX,
                      "onUpdate:modelValue": [
                        w[15] || (w[15] = ($) => o.value.orientationX = $),
                        m
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    Ze(Je(rt), {
                      modelValue: o.value.orientationY,
                      "onUpdate:modelValue": [
                        w[16] || (w[16] = ($) => o.value.orientationY = $),
                        m
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    Ze(Je(rt), {
                      modelValue: o.value.orientationZ,
                      "onUpdate:modelValue": [
                        w[17] || (w[17] = ($) => o.value.orientationZ = $),
                        m
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                y("div", f6, [
                  w[41] || (w[41] = y("label", null, "X Rotation", -1)),
                  y("div", p6, [
                    Ze(Je(rt), {
                      modelValue: o.value.rotationX,
                      "onUpdate:modelValue": [
                        w[18] || (w[18] = ($) => o.value.rotationX = $),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  y("button", {
                    class: Ye(["keyframe-btn", { active: g("rotationX") }]),
                    onClick: w[19] || (w[19] = ($) => v("rotationX"))
                  }, "", 2)
                ]),
                y("div", m6, [
                  w[42] || (w[42] = y("label", null, "Y Rotation", -1)),
                  y("div", g6, [
                    Ze(Je(rt), {
                      modelValue: o.value.rotationY,
                      "onUpdate:modelValue": [
                        w[20] || (w[20] = ($) => o.value.rotationY = $),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  y("button", {
                    class: Ye(["keyframe-btn", { active: g("rotationY") }]),
                    onClick: w[21] || (w[21] = ($) => v("rotationY"))
                  }, "", 2)
                ]),
                y("div", v6, [
                  w[43] || (w[43] = y("label", null, "Z Rotation", -1)),
                  y("div", y6, [
                    Ze(Je(rt), {
                      modelValue: o.value.rotationZ,
                      "onUpdate:modelValue": [
                        w[22] || (w[22] = ($) => o.value.rotationZ = $),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  y("button", {
                    class: Ye(["keyframe-btn", { active: g("rotationZ") }]),
                    onClick: w[23] || (w[23] = ($) => v("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (ie(), ue("div", {
                key: 1,
                class: Ye(["property-row", { "has-driver": E("transform.rotation") }])
              }, [
                u.value ? (ie(), Et(rh, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.rotation",
                  linkedTo: x("transform.rotation"),
                  onLink: w[24] || (w[24] = ($) => M("transform.rotation", $)),
                  onUnlink: w[25] || (w[25] = () => C("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : Ne("", !0),
                w[44] || (w[44] = y("label", null, "Rotation", -1)),
                y("div", _6, [
                  Ze(Je(rt), {
                    modelValue: o.value.rotation,
                    "onUpdate:modelValue": [
                      w[26] || (w[26] = ($) => o.value.rotation = $),
                      m
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": (oe = u.value) == null ? void 0 : oe.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                y("button", {
                  class: Ye(["keyframe-btn", { active: g("rotation") }]),
                  onClick: w[27] || (w[27] = ($) => v("rotation"))
                }, "", 2)
              ], 2)),
              y("div", x6, [
                w[45] || (w[45] = y("label", null, "Anchor Point", -1)),
                y("div", b6, [
                  Ze(Je(rt), {
                    modelValue: o.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      w[28] || (w[28] = ($) => o.value.anchorPoint.x = $),
                      m
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: o.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      w[29] || (w[29] = ($) => o.value.anchorPoint.y = $),
                      m
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                y("button", {
                  class: Ye(["keyframe-btn", { active: g("anchorPoint") }]),
                  onClick: w[30] || (w[30] = ($) => v("anchorPoint"))
                }, "", 2)
              ]),
              y("div", {
                class: Ye(["property-row", { "has-driver": E("opacity") }])
              }, [
                u.value ? (ie(), Et(rh, {
                  key: 0,
                  layerId: u.value.id,
                  property: "opacity",
                  linkedTo: x("opacity"),
                  onLink: w[31] || (w[31] = ($) => M("opacity", $)),
                  onUnlink: w[32] || (w[32] = () => C("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : Ne("", !0),
                w[46] || (w[46] = y("label", null, "Opacity", -1)),
                y("div", w6, [
                  Ze(Je(Di), {
                    modelValue: o.value.opacity,
                    "onUpdate:modelValue": [
                      w[33] || (w[33] = ($) => o.value.opacity = $),
                      m
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": (ne = u.value) == null ? void 0 : ne.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                y("button", {
                  class: Ye(["keyframe-btn", { active: g("opacity") }]),
                  onClick: w[34] || (w[34] = ($) => v("opacity"))
                }, "", 2)
              ], 2)
            ])) : Ne("", !0)
          ]),
          y("div", S6, [
            y("div", M6, [
              w[47] || (w[47] = y("label", null, "Blend Mode", -1)),
              wt(y("select", {
                "onUpdate:modelValue": w[35] || (w[35] = ($) => a.value = $),
                class: "blend-select",
                onChange: _
              }, [
                (ie(), ue(nt, null, pt(c, ($) => y("option", {
                  key: $.value,
                  value: $.value
                }, Ae($.label), 9, C6)), 64))
              ], 544), [
                [ns, a.value]
              ])
            ])
          ]),
          d.value ? (ie(), Et(bx(d.value), {
            key: 0,
            layer: u.value,
            onUpdate: S
          }, null, 40, ["layer"])) : Ne("", !0),
          u.value ? (ie(), Et(ZN, {
            key: 1,
            layerId: u.value.id
          }, null, 8, ["layerId"])) : Ne("", !0)
        ])) : (ie(), ue("div", T6, [...w[48] || (w[48] = [
          y("p", null, "No layer selected", -1),
          y("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), A6 = /* @__PURE__ */ Yt(E6, [["__scopeId", "data-v-a5a9c7d6"]]), P6 = { class: "camera-properties" }, D6 = { class: "panel-header" }, k6 = { class: "camera-name" }, R6 = {
  key: 0,
  class: "properties-content"
}, L6 = { class: "property-section" }, I6 = { class: "property-row" }, O6 = ["value"], F6 = { class: "property-section" }, U6 = { class: "toggle-icon" }, z6 = { class: "section-content" }, B6 = { class: "property-group" }, N6 = { class: "xyz-inputs" }, V6 = {
  key: 0,
  class: "property-group"
}, G6 = { class: "xyz-inputs" }, H6 = { class: "property-group" }, W6 = { class: "xyz-inputs" }, j6 = { class: "property-group" }, $6 = { class: "property-group" }, X6 = { class: "property-group" }, Y6 = { class: "property-section" }, q6 = { class: "toggle-icon" }, Z6 = { class: "section-content" }, K6 = { class: "preset-row" }, J6 = ["onClick"], Q6 = { class: "property-group" }, eV = { class: "property-group" }, tV = { class: "property-group" }, nV = { class: "property-group" }, iV = ["value"], sV = { class: "property-section" }, rV = { class: "toggle-icon" }, oV = { class: "section-content" }, aV = { class: "property-group checkbox-group" }, lV = ["checked"], cV = { class: "property-group" }, uV = { class: "property-group" }, hV = { class: "property-group" }, dV = { class: "property-group checkbox-group" }, fV = ["checked"], pV = { class: "property-section" }, mV = { class: "toggle-icon" }, gV = { class: "section-content" }, vV = { class: "property-group" }, yV = { class: "property-group" }, _V = { class: "property-group" }, xV = { class: "property-group" }, bV = { class: "property-group" }, wV = { class: "property-section" }, SV = { class: "toggle-icon" }, MV = { class: "section-content" }, CV = { class: "property-group" }, TV = { class: "property-group" }, EV = { class: "property-group" }, AV = { class: "property-section" }, PV = { class: "toggle-icon" }, DV = { class: "section-content" }, kV = { class: "property-group" }, RV = ["value"], LV = { class: "property-section" }, IV = { class: "toggle-icon" }, OV = { class: "section-content" }, FV = { class: "property-group" }, UV = { class: "property-group" }, zV = {
  key: 1,
  class: "no-camera"
}, BV = /* @__PURE__ */ jt({
  __name: "CameraProperties",
  setup(r) {
    const e = _n(), n = Xe(() => {
      const g = e.selectedLayer;
      if ((g == null ? void 0 : g.type) === "camera" && g.data) {
        const v = g.data;
        return e.getCamera(v.cameraId);
      }
      return e.activeCamera;
    }), i = yl({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1
    });
    function s(g) {
      i[g] = !i[g];
    }
    function o(g, v) {
      n.value && e.updateCamera(n.value.id, { [g]: v });
    }
    function a(g, v) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [g]: v }
      });
    }
    function l(g, v) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [g]: v }
      });
    }
    function c(g, v) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [g]: v }
      });
    }
    function u(g) {
      if (!n.value) return;
      const v = du(g, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: g,
        angleOfView: v
      });
    }
    function h(g) {
      if (!n.value) return;
      const v = xk(g, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: g,
        focalLength: v
      });
    }
    function d(g, v) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [g]: v }
      });
    }
    function p(g, v) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [g]: v }
      });
    }
    function f(g, v) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [g]: v }
      });
    }
    function m(g) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: g.focalLength,
        angleOfView: g.angleOfView,
        zoom: g.zoom
      });
    }
    function _() {
      e.createCameraLayer();
    }
    return (g, v) => {
      var S;
      return ie(), ue("div", P6, [
        y("div", D6, [
          v[38] || (v[38] = y("span", { class: "panel-title" }, "Camera", -1)),
          y("span", k6, Ae(((S = n.value) == null ? void 0 : S.name) ?? "No Camera"), 1)
        ]),
        n.value ? (ie(), ue("div", R6, [
          y("div", L6, [
            v[40] || (v[40] = y("div", { class: "section-header" }, "Type", -1)),
            y("div", I6, [
              y("select", {
                value: n.value.type,
                onChange: v[0] || (v[0] = (b) => o("type", b.target.value)),
                class: "type-select"
              }, [...v[39] || (v[39] = [
                y("option", { value: "one-node" }, "One-Node Camera", -1),
                y("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, O6)
            ])
          ]),
          y("div", F6, [
            y("div", {
              class: "section-header",
              onClick: v[1] || (v[1] = (b) => s("transform"))
            }, [
              y("span", U6, Ae(i.transform ? "" : ""), 1),
              v[41] || (v[41] = xt(" Transform ", -1))
            ]),
            wt(y("div", z6, [
              y("div", B6, [
                v[42] || (v[42] = y("label", null, "Position", -1)),
                y("div", N6, [
                  Ze(Je(rt), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": v[2] || (v[2] = (b) => a("x", b)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": v[3] || (v[3] = (b) => a("y", b)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": v[4] || (v[4] = (b) => a("z", b)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (ie(), ue("div", V6, [
                v[43] || (v[43] = y("label", null, "Point of Interest", -1)),
                y("div", G6, [
                  Ze(Je(rt), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": v[5] || (v[5] = (b) => l("x", b)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": v[6] || (v[6] = (b) => l("y", b)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": v[7] || (v[7] = (b) => l("z", b)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Ne("", !0),
              y("div", H6, [
                v[44] || (v[44] = y("label", null, "Orientation", -1)),
                y("div", W6, [
                  Ze(Je(rt), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": v[8] || (v[8] = (b) => c("x", b)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": v[9] || (v[9] = (b) => c("y", b)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ze(Je(rt), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": v[10] || (v[10] = (b) => c("z", b)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              y("div", j6, [
                v[45] || (v[45] = y("label", null, "X Rotation", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": v[11] || (v[11] = (b) => o("xRotation", b)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", $6, [
                v[46] || (v[46] = y("label", null, "Y Rotation", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": v[12] || (v[12] = (b) => o("yRotation", b)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", X6, [
                v[47] || (v[47] = y("label", null, "Z Rotation", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": v[13] || (v[13] = (b) => o("zRotation", b)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [_o, i.transform]
            ])
          ]),
          y("div", Y6, [
            y("div", {
              class: "section-header",
              onClick: v[14] || (v[14] = (b) => s("lens"))
            }, [
              y("span", q6, Ae(i.lens ? "" : ""), 1),
              v[48] || (v[48] = xt(" Lens ", -1))
            ]),
            wt(y("div", Z6, [
              y("div", K6, [
                (ie(!0), ue(nt, null, pt(Je(pk), (b) => (ie(), ue("button", {
                  key: b.name,
                  class: Ye({ active: Math.abs(n.value.focalLength - b.focalLength) < 0.5 }),
                  onClick: (x) => m(b)
                }, Ae(b.name), 11, J6))), 128))
              ]),
              y("div", Q6, [
                v[49] || (v[49] = y("label", null, "Focal Length", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": u,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", eV, [
                v[50] || (v[50] = y("label", null, "Angle of View", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": h,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", tV, [
                v[51] || (v[51] = y("label", null, "Film Size", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": v[15] || (v[15] = (b) => o("filmSize", b)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", nV, [
                v[53] || (v[53] = y("label", null, "Measure Film Size", -1)),
                y("select", {
                  value: n.value.measureFilmSize,
                  onChange: v[16] || (v[16] = (b) => o("measureFilmSize", b.target.value))
                }, [...v[52] || (v[52] = [
                  y("option", { value: "horizontal" }, "Horizontal", -1),
                  y("option", { value: "vertical" }, "Vertical", -1),
                  y("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, iV)
              ])
            ], 512), [
              [_o, i.lens]
            ])
          ]),
          y("div", sV, [
            y("div", {
              class: "section-header",
              onClick: v[17] || (v[17] = (b) => s("dof"))
            }, [
              y("span", rV, Ae(i.dof ? "" : ""), 1),
              v[54] || (v[54] = xt(" Depth of Field ", -1))
            ]),
            wt(y("div", oV, [
              y("div", aV, [
                y("label", null, [
                  y("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: v[18] || (v[18] = (b) => d("enabled", b.target.checked))
                  }, null, 40, lV),
                  v[55] || (v[55] = xt(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (ie(), ue(nt, { key: 0 }, [
                y("div", cV, [
                  v[56] || (v[56] = y("label", null, "Focus Distance", -1)),
                  Ze(Je(rt), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": v[19] || (v[19] = (b) => d("focusDistance", b)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                y("div", uV, [
                  v[57] || (v[57] = y("label", null, "f-Stop", -1)),
                  Ze(Je(rt), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": v[20] || (v[20] = (b) => d("fStop", b)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                y("div", hV, [
                  v[58] || (v[58] = y("label", null, "Blur Level", -1)),
                  Ze(Je(Di), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": v[21] || (v[21] = (b) => d("blurLevel", b)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                y("div", dV, [
                  y("label", null, [
                    y("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: v[22] || (v[22] = (b) => d("lockToZoom", b.target.checked))
                    }, null, 40, fV),
                    v[59] || (v[59] = xt(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Ne("", !0)
            ], 512), [
              [_o, i.dof]
            ])
          ]),
          y("div", pV, [
            y("div", {
              class: "section-header",
              onClick: v[23] || (v[23] = (b) => s("iris"))
            }, [
              y("span", mV, Ae(i.iris ? "" : ""), 1),
              v[60] || (v[60] = xt(" Iris ", -1))
            ]),
            wt(y("div", gV, [
              y("div", vV, [
                y("label", null, "Shape (" + Ae(Math.round(n.value.iris.shape)) + "-gon)", 1),
                Ze(Je(Di), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": v[24] || (v[24] = (b) => p("shape", b)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", yV, [
                v[61] || (v[61] = y("label", null, "Rotation", -1)),
                Ze(Je(fv), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": v[25] || (v[25] = (b) => p("rotation", b)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              y("div", _V, [
                v[62] || (v[62] = y("label", null, "Roundness", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": v[26] || (v[26] = (b) => p("roundness", b)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              y("div", xV, [
                v[63] || (v[63] = y("label", null, "Aspect Ratio", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": v[27] || (v[27] = (b) => p("aspectRatio", b)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              y("div", bV, [
                v[64] || (v[64] = y("label", null, "Diffraction Fringe", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": v[28] || (v[28] = (b) => p("diffractionFringe", b)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [_o, i.iris]
            ])
          ]),
          y("div", wV, [
            y("div", {
              class: "section-header",
              onClick: v[29] || (v[29] = (b) => s("highlight"))
            }, [
              y("span", SV, Ae(i.highlight ? "" : ""), 1),
              v[65] || (v[65] = xt(" Highlight ", -1))
            ]),
            wt(y("div", MV, [
              y("div", CV, [
                v[66] || (v[66] = y("label", null, "Gain", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": v[30] || (v[30] = (b) => f("gain", b)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              y("div", TV, [
                v[67] || (v[67] = y("label", null, "Threshold", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": v[31] || (v[31] = (b) => f("threshold", b)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              y("div", EV, [
                v[68] || (v[68] = y("label", null, "Saturation", -1)),
                Ze(Je(Di), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": v[32] || (v[32] = (b) => f("saturation", b)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [_o, i.highlight]
            ])
          ]),
          y("div", AV, [
            y("div", {
              class: "section-header",
              onClick: v[33] || (v[33] = (b) => s("autoOrient"))
            }, [
              y("span", PV, Ae(i.autoOrient ? "" : ""), 1),
              v[69] || (v[69] = xt(" Auto-Orient ", -1))
            ]),
            wt(y("div", DV, [
              y("div", kV, [
                y("select", {
                  value: n.value.autoOrient,
                  onChange: v[34] || (v[34] = (b) => o("autoOrient", b.target.value))
                }, [...v[70] || (v[70] = [
                  y("option", { value: "off" }, "Off", -1),
                  y("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  y("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, RV)
              ])
            ], 512), [
              [_o, i.autoOrient]
            ])
          ]),
          y("div", LV, [
            y("div", {
              class: "section-header",
              onClick: v[35] || (v[35] = (b) => s("clipping"))
            }, [
              y("span", IV, Ae(i.clipping ? "" : ""), 1),
              v[71] || (v[71] = xt(" Clipping ", -1))
            ]),
            wt(y("div", OV, [
              y("div", FV, [
                v[72] || (v[72] = y("label", null, "Near Clip", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": v[36] || (v[36] = (b) => o("nearClip", b)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              y("div", UV, [
                v[73] || (v[73] = y("label", null, "Far Clip", -1)),
                Ze(Je(rt), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": v[37] || (v[37] = (b) => o("farClip", b)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [_o, i.clipping]
            ])
          ])
        ])) : (ie(), ue("div", zV, [
          v[74] || (v[74] = y("p", null, "No camera selected", -1)),
          y("button", { onClick: _ }, "Create Camera")
        ]))
      ]);
    };
  }
}), NV = /* @__PURE__ */ Yt(BV, [["__scopeId", "data-v-1a588e9b"]]), VV = { class: "audio-properties" }, GV = { class: "property-section" }, HV = {
  key: 0,
  class: "section-content"
}, WV = { class: "property-row" }, jV = { class: "value-display" }, $V = { class: "property-row" }, XV = { class: "value-display" }, YV = { class: "property-row" }, qV = { class: "value-display" }, ZV = { class: "property-row" }, KV = {
  key: 0,
  class: "peak-count"
}, JV = { class: "property-section" }, QV = { class: "mapping-count" }, e8 = {
  key: 0,
  class: "section-content"
}, t8 = { class: "mapping-header" }, n8 = { class: "mapping-enabled" }, i8 = ["onUpdate:modelValue"], s8 = { class: "mapping-name" }, r8 = ["onClick"], o8 = {
  key: 0,
  class: "mapping-details"
}, a8 = { class: "property-row" }, l8 = ["onUpdate:modelValue"], c8 = ["value"], u8 = { class: "property-row" }, h8 = ["onUpdate:modelValue"], d8 = ["label"], f8 = ["value"], p8 = { class: "property-row" }, m8 = ["onUpdate:modelValue"], g8 = { class: "value-display" }, v8 = { class: "property-row" }, y8 = ["onUpdate:modelValue"], _8 = { class: "value-display" }, x8 = { class: "property-row" }, b8 = ["onUpdate:modelValue"], w8 = { class: "value-display" }, S8 = { class: "property-row" }, M8 = ["onUpdate:modelValue"], C8 = ["onUpdate:modelValue"], T8 = { class: "property-row" }, E8 = ["onUpdate:modelValue"], A8 = ["onClick"], P8 = { class: "property-section" }, D8 = {
  key: 0,
  class: "section-content"
}, k8 = { class: "property-row" }, R8 = ["value"], L8 = { class: "visualizer-canvas-container" }, I8 = { class: "visualizer-value" }, O8 = /* @__PURE__ */ jt({
  __name: "AudioProperties",
  setup(r) {
    const e = _n(), n = Ce(/* @__PURE__ */ new Set(["peaks", "mappings"])), i = Ce(/* @__PURE__ */ new Set()), s = Ce({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), o = Ce(null), a = Ce([]), l = Ce("amplitude"), c = Ce(null), u = Xe(() => Bk()), h = Xe(() => Nk()), d = Xe(
      () => e.currentFrame / e.frameCount * 100
    ), p = Xe(() => e.audioAnalysis ? Kc(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function f(b) {
      n.value.has(b) ? n.value.delete(b) : n.value.add(b);
    }
    function m(b) {
      i.value.has(b) ? i.value.delete(b) : i.value.add(b);
    }
    function _() {
      if (!e.audioAnalysis) return;
      const b = e.audioAnalysis.amplitudeEnvelope;
      o.value = Jb(b, s.value), e.setPeakData(o.value);
    }
    function g() {
      const b = Uk();
      a.value.push(b), i.value.add(b.id), e.addAudioMapping(b);
    }
    function v(b) {
      const x = a.value.findIndex((M) => M.id === b);
      x >= 0 && (a.value.splice(x, 1), i.value.delete(b), e.removeAudioMapping(b));
    }
    function S() {
      const b = c.value;
      if (!b || !e.audioAnalysis) return;
      const x = b.getContext("2d");
      if (!x) return;
      const M = b.width, C = b.height;
      x.fillStyle = "#1e1e1e", x.fillRect(0, 0, M, C);
      let E = [];
      const T = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          E = T.amplitudeEnvelope;
          break;
        case "rms":
          E = T.rmsEnergy;
          break;
        case "spectralCentroid":
          E = T.spectralCentroid;
          break;
        case "bass":
          E = T.frequencyBands.bass;
          break;
        case "mid":
          E = T.frequencyBands.mid;
          break;
        case "high":
          E = T.frequencyBands.high;
          break;
        case "sub":
          E = T.frequencyBands.sub;
          break;
        case "lowMid":
          E = T.frequencyBands.lowMid;
          break;
        case "highMid":
          E = T.frequencyBands.highMid;
          break;
        case "onsets":
          E = new Array(T.frameCount).fill(0);
          for (const w of T.onsets)
            w < E.length && (E[w] = 1);
          break;
        case "peaks":
          if (o.value) {
            E = new Array(T.frameCount).fill(0);
            for (const w of o.value.indices)
              w < E.length && (E[w] = 1);
          }
          break;
      }
      if (E.length !== 0) {
        x.strokeStyle = "#4a90d9", x.lineWidth = 1.5, x.beginPath();
        for (let w = 0; w < E.length; w++) {
          const A = w / E.length * M, O = C - E[w] * C * 0.9 - 5;
          w === 0 ? x.moveTo(A, O) : x.lineTo(A, O);
        }
        if (x.stroke(), o.value && l.value !== "peaks") {
          x.fillStyle = "#ff6b6b";
          for (const w of o.value.indices) {
            const A = w / E.length * M;
            x.beginPath(), x.moveTo(A, 0), x.lineTo(A, C), x.strokeStyle = "rgba(255, 107, 107, 0.3)", x.stroke();
          }
        }
      }
    }
    return At(
      () => [e.audioAnalysis, l.value, o.value],
      () => {
        S();
      }
    ), At(
      a,
      (b) => {
        for (const x of b)
          e.updateAudioMapping(x.id, x);
      },
      { deep: !0 }
    ), Xn(() => {
      S();
      const b = e.getAudioMappings();
      b.length > 0 && (a.value = [...b]);
    }), (b, x) => (ie(), ue("div", VV, [
      y("div", GV, [
        y("div", {
          class: "section-header",
          onClick: x[0] || (x[0] = (M) => f("peaks"))
        }, [
          y("i", {
            class: Ye(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[7] || (x[7] = y("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (ie(), ue("div", HV, [
          y("div", WV, [
            x[8] || (x[8] = y("label", null, "Threshold", -1)),
            wt(y("input", {
              type: "range",
              "onUpdate:modelValue": x[1] || (x[1] = (M) => s.value.threshold = M),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                Tn,
                s.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            y("span", jV, Ae(s.value.threshold.toFixed(2)), 1)
          ]),
          y("div", $V, [
            x[9] || (x[9] = y("label", null, "Min Peak Distance", -1)),
            wt(y("input", {
              type: "range",
              "onUpdate:modelValue": x[2] || (x[2] = (M) => s.value.minPeaksDistance = M),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                Tn,
                s.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            y("span", XV, Ae(s.value.minPeaksDistance) + " frames", 1)
          ]),
          y("div", YV, [
            x[10] || (x[10] = y("label", null, "Multiply", -1)),
            wt(y("input", {
              type: "range",
              "onUpdate:modelValue": x[3] || (x[3] = (M) => s.value.multiply = M),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                Tn,
                s.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            y("span", qV, Ae(s.value.multiply.toFixed(1)) + "x", 1)
          ]),
          y("div", ZV, [
            y("button", {
              class: "action-btn",
              onClick: _
            }, [...x[11] || (x[11] = [
              y("i", { class: "pi pi-bolt" }, null, -1),
              xt(" Detect Peaks ", -1)
            ])]),
            o.value ? (ie(), ue("span", KV, Ae(o.value.count) + " peaks found ", 1)) : Ne("", !0)
          ])
        ])) : Ne("", !0)
      ]),
      y("div", JV, [
        y("div", {
          class: "section-header",
          onClick: x[4] || (x[4] = (M) => f("mappings"))
        }, [
          y("i", {
            class: Ye(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[12] || (x[12] = y("span", null, "Audio Mappings", -1)),
          y("span", QV, Ae(a.value.length), 1)
        ]),
        n.value.has("mappings") ? (ie(), ue("div", e8, [
          y("button", {
            class: "action-btn add-mapping-btn",
            onClick: g
          }, [...x[13] || (x[13] = [
            y("i", { class: "pi pi-plus" }, null, -1),
            xt(" Add Mapping ", -1)
          ])]),
          (ie(!0), ue(nt, null, pt(a.value, (M) => (ie(), ue("div", {
            key: M.id,
            class: "mapping-item"
          }, [
            y("div", t8, [
              y("label", n8, [
                wt(y("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": (C) => M.enabled = C
                }, null, 8, i8), [
                  [Us, M.enabled]
                ])
              ]),
              y("span", s8, Ae(Je(Dp)(M.feature)) + "  " + Ae(Je(n1)(M.target)), 1),
              y("button", {
                class: "delete-btn",
                onClick: (C) => v(M.id)
              }, [...x[14] || (x[14] = [
                y("i", { class: "pi pi-times" }, null, -1)
              ])], 8, r8)
            ]),
            i.value.has(M.id) ? (ie(), ue("div", o8, [
              y("div", a8, [
                x[15] || (x[15] = y("label", null, "Feature", -1)),
                wt(y("select", {
                  "onUpdate:modelValue": (C) => M.feature = C
                }, [
                  (ie(!0), ue(nt, null, pt(u.value, (C) => (ie(), ue("option", {
                    key: C,
                    value: C
                  }, Ae(Je(Dp)(C)), 9, c8))), 128))
                ], 8, l8), [
                  [ns, M.feature]
                ])
              ]),
              y("div", u8, [
                x[16] || (x[16] = y("label", null, "Target", -1)),
                wt(y("select", {
                  "onUpdate:modelValue": (C) => M.target = C
                }, [
                  (ie(!0), ue(nt, null, pt(h.value, (C, E) => (ie(), ue("optgroup", {
                    key: E,
                    label: E
                  }, [
                    (ie(!0), ue(nt, null, pt(C, (T) => (ie(), ue("option", {
                      key: T,
                      value: T
                    }, Ae(Je(n1)(T)), 9, f8))), 128))
                  ], 8, d8))), 128))
                ], 8, h8), [
                  [ns, M.target]
                ])
              ]),
              y("div", p8, [
                x[17] || (x[17] = y("label", null, "Sensitivity", -1)),
                wt(y("input", {
                  type: "range",
                  "onUpdate:modelValue": (C) => M.sensitivity = C,
                  min: "0.1",
                  max: "5",
                  step: "0.1"
                }, null, 8, m8), [
                  [
                    Tn,
                    M.sensitivity,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                y("span", g8, Ae(M.sensitivity.toFixed(1)) + "x", 1)
              ]),
              y("div", v8, [
                x[18] || (x[18] = y("label", null, "Threshold", -1)),
                wt(y("input", {
                  type: "range",
                  "onUpdate:modelValue": (C) => M.threshold = C,
                  min: "0",
                  max: "1",
                  step: "0.01"
                }, null, 8, y8), [
                  [
                    Tn,
                    M.threshold,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                y("span", _8, Ae(M.threshold.toFixed(2)), 1)
              ]),
              y("div", x8, [
                x[19] || (x[19] = y("label", null, "Smoothing", -1)),
                wt(y("input", {
                  type: "range",
                  "onUpdate:modelValue": (C) => M.smoothing = C,
                  min: "0",
                  max: "0.99",
                  step: "0.01"
                }, null, 8, b8), [
                  [
                    Tn,
                    M.smoothing,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                y("span", w8, Ae(M.smoothing.toFixed(2)), 1)
              ]),
              y("div", S8, [
                x[20] || (x[20] = y("label", null, "Min/Max", -1)),
                wt(y("input", {
                  type: "number",
                  "onUpdate:modelValue": (C) => M.min = C,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, M8), [
                  [
                    Tn,
                    M.min,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                x[21] || (x[21] = y("span", { class: "separator" }, "-", -1)),
                wt(y("input", {
                  type: "number",
                  "onUpdate:modelValue": (C) => M.max = C,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, C8), [
                  [
                    Tn,
                    M.max,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              y("div", T8, [
                y("label", null, [
                  wt(y("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (C) => M.invert = C
                  }, null, 8, E8), [
                    [Us, M.invert]
                  ]),
                  x[22] || (x[22] = xt(" Invert ", -1))
                ])
              ])
            ])) : Ne("", !0),
            y("button", {
              class: "expand-btn",
              onClick: (C) => m(M.id)
            }, [
              y("i", {
                class: Ye(["pi", i.value.has(M.id) ? "pi-chevron-up" : "pi-chevron-down"])
              }, null, 2)
            ], 8, A8)
          ]))), 128))
        ])) : Ne("", !0)
      ]),
      y("div", P8, [
        y("div", {
          class: "section-header",
          onClick: x[5] || (x[5] = (M) => f("visualizer"))
        }, [
          y("i", {
            class: Ye(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[23] || (x[23] = y("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (ie(), ue("div", D8, [
          y("div", k8, [
            x[24] || (x[24] = y("label", null, "Feature", -1)),
            wt(y("select", {
              "onUpdate:modelValue": x[6] || (x[6] = (M) => l.value = M)
            }, [
              (ie(!0), ue(nt, null, pt(u.value, (M) => (ie(), ue("option", {
                key: M,
                value: M
              }, Ae(Je(Dp)(M)), 9, R8))), 128))
            ], 512), [
              [ns, l.value]
            ])
          ]),
          y("div", L8, [
            y("canvas", {
              ref_key: "visualizerCanvas",
              ref: c,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            y("div", {
              class: "visualizer-playhead",
              style: Ct({ left: `${d.value}%` })
            }, null, 4)
          ]),
          y("div", I8, " Current: " + Ae(p.value.toFixed(3)), 1)
        ])) : Ne("", !0)
      ])
    ]));
  }
}), F8 = /* @__PURE__ */ Yt(O8, [["__scopeId", "data-v-f0f6c1bb"]]), U8 = { class: "audio-panel" }, z8 = {
  key: 0,
  class: "panel-content"
}, B8 = { class: "audio-info" }, N8 = { class: "file-info" }, V8 = { class: "file-details" }, G8 = { class: "file-name" }, H8 = { class: "file-meta" }, W8 = { class: "control-section" }, j8 = { class: "control-row" }, $8 = { class: "waveform-section" }, X8 = { class: "waveform-display" }, Y8 = { class: "linker-section" }, q8 = {
  key: 1,
  class: "empty-state"
}, Z8 = /* @__PURE__ */ jt({
  __name: "AudioPanel",
  setup(r) {
    const e = _n(), n = Ce(null), i = Ce(null), s = Ce(100), o = Ce(!1), a = Xe(() => !!e.audioBuffer), l = Xe(() => {
      var _;
      return ((_ = e.audioFile) == null ? void 0 : _.name) || "Unknown";
    }), c = Xe(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), u = Xe(() => {
      if (!e.audioBuffer) return "0:00";
      const _ = Math.floor(e.audioBuffer.duration / 60), g = Math.floor(e.audioBuffer.duration % 60);
      return `${_}:${g.toString().padStart(2, "0")}`;
    });
    function h() {
      var _;
      (_ = n.value) == null || _.click();
    }
    async function d(_) {
      var v;
      const g = _.target;
      (v = g.files) != null && v.length && await e.loadAudio(g.files[0]), g.value = "";
    }
    function p() {
      e.clearAudio();
    }
    function f() {
      o.value = !o.value;
    }
    function m() {
      if (!i.value || !e.audioBuffer) return;
      const _ = i.value, g = _.getContext("2d");
      if (!g) return;
      const v = _.getBoundingClientRect();
      _.width = v.width * window.devicePixelRatio, _.height = 60 * window.devicePixelRatio, g.scale(window.devicePixelRatio, window.devicePixelRatio);
      const S = e.audioBuffer.getChannelData(0), b = Math.ceil(S.length / v.width), x = 30;
      g.fillStyle = "#1a1a1a", g.fillRect(0, 0, v.width, 60), g.beginPath(), g.strokeStyle = "#4a90d9", g.lineWidth = 1;
      for (let C = 0; C < v.width; C++) {
        let E = 1, T = -1;
        for (let w = 0; w < b; w++) {
          const A = S[C * b + w];
          A < E && (E = A), A > T && (T = A);
        }
        g.moveTo(C, (1 + E) * x), g.lineTo(C, (1 + T) * x);
      }
      g.stroke();
      const M = e.currentFrame / e.frameCount * v.width;
      g.fillStyle = "#fff", g.fillRect(M, 0, 1, 60);
    }
    return At(() => [e.audioBuffer, e.currentFrame], m), Xn(() => {
      a.value && setTimeout(m, 100);
    }), (_, g) => (ie(), ue("div", U8, [
      y("div", { class: "panel-header" }, [
        g[2] || (g[2] = y("span", { class: "panel-title" }, "Audio Source", -1)),
        y("div", { class: "header-actions" }, [
          y("button", {
            onClick: h,
            title: "Load Audio"
          }, [...g[1] || (g[1] = [
            y("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      a.value ? (ie(), ue("div", z8, [
        y("div", B8, [
          y("div", N8, [
            g[3] || (g[3] = y("span", { class: "file-icon" }, "", -1)),
            y("div", V8, [
              y("span", G8, Ae(l.value), 1),
              y("span", H8, Ae(u.value) + "  " + Ae(c.value), 1)
            ]),
            y("button", {
              class: "remove-btn",
              onClick: p,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        y("div", W8, [
          y("div", j8, [
            g[4] || (g[4] = y("label", null, "Master Vol", -1)),
            Ze(Je(Di), {
              modelValue: s.value,
              "onUpdate:modelValue": g[0] || (g[0] = (v) => s.value = v),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            y("button", {
              class: Ye(["mute-btn", { active: o.value }]),
              onClick: f,
              title: "Mute"
            }, Ae(o.value ? "" : ""), 3)
          ])
        ]),
        y("div", $8, [
          g[5] || (g[5] = y("div", { class: "section-header" }, [
            y("span", { class: "section-title" }, "Waveform")
          ], -1)),
          y("div", X8, [
            y("canvas", {
              ref_key: "waveformCanvas",
              ref: i,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        y("div", Y8, [
          g[6] || (g[6] = y("div", { class: "linker-header" }, "Audio Linker", -1)),
          Ze(F8)
        ])
      ])) : (ie(), ue("div", q8, [
        g[7] || (g[7] = y("div", { class: "empty-icon" }, "", -1)),
        g[8] || (g[8] = y("p", null, "No audio loaded", -1)),
        y("button", {
          class: "load-btn",
          onClick: h
        }, "Load Audio File"),
        g[9] || (g[9] = y("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      y("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: d
      }, null, 544)
    ]));
  }
}), K8 = /* @__PURE__ */ Yt(Z8, [["__scopeId", "data-v-66384e06"]]), r1 = 40, J8 = 30;
function Q8(r) {
  const e = [], n = "#ffcc00", i = r.position;
  let s;
  if (r.type === "two-node")
    s = xr(dv(r.pointOfInterest, i));
  else {
    const f = r.orientation.x * Math.PI / 180, m = r.orientation.y * Math.PI / 180;
    s = Mt(
      Math.sin(m) * Math.cos(f),
      -Math.sin(f),
      Math.cos(m) * Math.cos(f)
    );
  }
  const o = Mt(0, -1, 0);
  let a = xr(pl(s, o));
  isNaN(a.x) && (a = Mt(1, 0, 0));
  const l = xr(pl(a, s)), c = r1 / 2, u = Lt(i, Ut(s, -r1)), h = [];
  for (let f = 0; f < 2; f++) {
    const m = f === 0 ? i : u;
    for (let _ = -1; _ <= 1; _ += 2)
      for (let g = -1; g <= 1; g += 2)
        h.push(Lt(
          Lt(m, Ut(a, _ * c)),
          Ut(l, g * c)
        ));
  }
  e.push({ start: h[0], end: h[1], color: n }), e.push({ start: h[1], end: h[3], color: n }), e.push({ start: h[3], end: h[2], color: n }), e.push({ start: h[2], end: h[0], color: n }), e.push({ start: h[4], end: h[5], color: n }), e.push({ start: h[5], end: h[7], color: n }), e.push({ start: h[7], end: h[6], color: n }), e.push({ start: h[6], end: h[4], color: n }), e.push({ start: h[0], end: h[4], color: n }), e.push({ start: h[1], end: h[5], color: n }), e.push({ start: h[2], end: h[6], color: n }), e.push({ start: h[3], end: h[7], color: n });
  const d = Lt(i, Ut(s, J8)), p = 8;
  for (let f = 0; f < p; f++) {
    const m = f / p * Math.PI * 2, _ = (f + 1) / p * Math.PI * 2, g = Lt(
      Lt(i, Ut(a, Math.cos(m) * c * 0.5)),
      Ut(l, Math.sin(m) * c * 0.5)
    ), v = Lt(
      Lt(i, Ut(a, Math.cos(_) * c * 0.5)),
      Ut(l, Math.sin(_) * c * 0.5)
    );
    e.push({ start: g, end: v, color: n }), e.push({ start: g, end: d, color: n });
  }
  return e;
}
function eG(r, e, n, i = 2e3) {
  const s = [], o = "#7c9cff", a = du(r.focalLength, r.filmSize), l = e / n, c = r.position;
  let u;
  if (r.type === "two-node")
    u = xr(dv(r.pointOfInterest, c));
  else {
    const E = r.orientation.x * Math.PI / 180, T = r.orientation.y * Math.PI / 180;
    u = Mt(
      Math.sin(T) * Math.cos(E),
      -Math.sin(E),
      Math.cos(T) * Math.cos(E)
    );
  }
  const h = Mt(0, -1, 0);
  let d = xr(pl(u, h));
  isNaN(d.x) && (d = Mt(1, 0, 0));
  const p = xr(pl(d, u)), f = r.nearClip, m = Math.min(r.farClip, i), _ = f * Math.tan(a * Math.PI / 360), g = _ * l, v = m * Math.tan(a * Math.PI / 360), S = v * l, b = Lt(c, Ut(u, f)), x = [
    Lt(Lt(b, Ut(d, -g)), Ut(p, _)),
    Lt(Lt(b, Ut(d, g)), Ut(p, _)),
    Lt(Lt(b, Ut(d, g)), Ut(p, -_)),
    Lt(Lt(b, Ut(d, -g)), Ut(p, -_))
  ], M = Lt(c, Ut(u, m)), C = [
    Lt(Lt(M, Ut(d, -S)), Ut(p, v)),
    Lt(Lt(M, Ut(d, S)), Ut(p, v)),
    Lt(Lt(M, Ut(d, S)), Ut(p, -v)),
    Lt(Lt(M, Ut(d, -S)), Ut(p, -v))
  ];
  for (let E = 0; E < 4; E++)
    s.push({ start: x[E], end: x[(E + 1) % 4], color: o });
  for (let E = 0; E < 4; E++)
    s.push({ start: C[E], end: C[(E + 1) % 4], color: o });
  for (let E = 0; E < 4; E++)
    s.push({ start: x[E], end: C[E], color: o });
  return s;
}
function tG(r, e) {
  const n = "#00ff88", i = [
    Mt(0, 0, 0),
    Mt(r, 0, 0),
    Mt(r, e, 0),
    Mt(0, e, 0)
  ], s = [];
  for (let o = 0; o < 4; o++)
    s.push({ start: i[o], end: i[(o + 1) % 4], color: n });
  return s.push({ start: i[0], end: i[2], color: "#005533" }), s.push({ start: i[1], end: i[3], color: "#005533" }), s;
}
function nG(r) {
  return r.type !== "two-node" ? null : {
    start: r.position,
    end: r.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function iG(r, e, n) {
  if (!r.depthOfField.enabled)
    return [];
  const i = "#ff00ff", s = [], o = r.position, a = r.depthOfField.focusDistance;
  let l;
  if (r.type === "two-node")
    l = xr(dv(r.pointOfInterest, o));
  else {
    const _ = r.orientation.x * Math.PI / 180, g = r.orientation.y * Math.PI / 180;
    l = Mt(
      Math.sin(g) * Math.cos(_),
      -Math.sin(_),
      Math.cos(g) * Math.cos(_)
    );
  }
  const c = Mt(0, -1, 0);
  let u = xr(pl(l, c));
  isNaN(u.x) && (u = Mt(1, 0, 0));
  const h = xr(pl(u, l)), d = Lt(o, Ut(l, a)), p = e / 4, f = n / 4, m = [
    Lt(Lt(d, Ut(u, -p)), Ut(h, f)),
    Lt(Lt(d, Ut(u, p)), Ut(h, f)),
    Lt(Lt(d, Ut(u, p)), Ut(h, -f)),
    Lt(Lt(d, Ut(u, -p)), Ut(h, -f))
  ];
  for (let _ = 0; _ < 4; _++)
    s.push({ start: m[_], end: m[(_ + 1) % 4], color: i });
  return s;
}
function o1(r, e, n, i = !0, s = !0, o = !1) {
  return {
    body: Q8(r),
    frustum: i ? eG(r, e, n) : [],
    compositionBounds: s ? tG(e, n) : [],
    poiLine: nG(r),
    focalPlane: o ? iG(r, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function sG(r, e, n) {
  const i = e / n, s = du(r.focalLength, r.filmSize);
  let o;
  if (r.type === "two-node")
    o = r.pointOfInterest;
  else {
    const u = r.orientation.x * Math.PI / 180, h = r.orientation.y * Math.PI / 180, d = Mt(
      Math.sin(h) * Math.cos(u),
      -Math.sin(u),
      Math.cos(h) * Math.cos(u)
    );
    o = Lt(r.position, Ut(d, 1e3));
  }
  const a = Is(r.position, o, Mt(0, -1, 0)), l = vk(s, i, r.nearClip, r.farClip), c = ew(l, a);
  return { view: a, projection: l, viewProjection: c };
}
function a1(r, e, n, i) {
  const s = e / n;
  let o, a = 1e3;
  const l = e / 2, c = n / 2;
  switch (r) {
    case "front":
      o = Is(
        Mt(l, c, -2e3),
        Mt(l, c, 0),
        Mt(0, -1, 0)
      );
      break;
    case "back":
      o = Is(
        Mt(l, c, 2e3),
        Mt(l, c, 0),
        Mt(0, -1, 0)
      );
      break;
    case "left":
      o = Is(
        Mt(-2e3, c, 0),
        Mt(l, c, 0),
        Mt(0, -1, 0)
      );
      break;
    case "right":
      o = Is(
        Mt(l + 2e3, c, 0),
        Mt(l, c, 0),
        Mt(0, -1, 0)
      );
      break;
    case "top":
      o = Is(
        Mt(l, -2e3, 0),
        Mt(l, c, 0),
        Mt(0, 0, 1)
      );
      break;
    case "bottom":
      o = Is(
        Mt(l, c + 2e3, 0),
        Mt(l, c, 0),
        Mt(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (i) {
        const d = i.orbitPhi * Math.PI / 180, p = i.orbitTheta * Math.PI / 180, f = i.orbitDistance, m = Mt(
          i.orbitCenter.x + f * Math.sin(d) * Math.sin(p),
          i.orbitCenter.y + f * Math.cos(d),
          i.orbitCenter.z + f * Math.sin(d) * Math.cos(p)
        );
        o = Is(
          m,
          i.orbitCenter,
          Mt(0, -1, 0)
        ), a = 1e3 / i.orthoZoom;
      } else
        o = Is(
          Mt(l, c, -2e3),
          Mt(l, c, 0),
          Mt(0, -1, 0)
        );
      break;
    default:
      o = Is(
        Mt(l, c, -2e3),
        Mt(l, c, 0),
        Mt(0, -1, 0)
      );
  }
  const u = yk(
    -a * s,
    a * s,
    -a,
    a,
    1,
    1e4
  ), h = ew(u, o);
  return { view: o, projection: u, viewProjection: h };
}
function ew(r, e) {
  const n = r.elements, i = e.elements, s = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[o + c * 4] * i[c + a * 4];
      s[o + a * 4] = l;
    }
  return { elements: s };
}
function kp(r, e, n, i) {
  const s = _k(e, r), o = e.elements, a = r.x * o[3] + r.y * o[7] + r.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: s.z, visible: !1 };
  const l = (s.x / a * 0.5 + 0.5) * n, c = (-s.y / a * 0.5 + 0.5) * i;
  return {
    x: l,
    y: c,
    z: s.z / a,
    visible: !0
  };
}
function rG(r, e = 100) {
  return [
    { start: r, end: Lt(r, Mt(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: r, end: Lt(r, Mt(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: r, end: Lt(r, Mt(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function oG(r, e, n = 100) {
  const i = [], s = "#333333", o = "#444444", a = r / 2, l = e / 2, c = Math.max(r, e);
  for (let u = -c; u <= c + r; u += n) {
    const h = Math.abs(u - a) < n / 2;
    i.push({
      start: Mt(u, -c, 0),
      end: Mt(u, c + e, 0),
      color: h ? o : s
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const h = Math.abs(u - l) < n / 2;
    i.push({
      start: Mt(-c, u, 0),
      end: Mt(c + r, u, 0),
      color: h ? o : s
    });
  }
  return i;
}
const aG = ["onClick"], lG = { class: "view-header" }, cG = ["value", "onChange"], uG = { class: "view-tools" }, hG = ["onClick"], dG = ["onMousedown", "onWheel"], fG = { class: "view-info" }, pG = { class: "view-name" }, mG = {
  key: 0,
  class: "view-coords"
}, gG = { class: "layout-controls" }, vG = ["onClick", "title"], yG = /* @__PURE__ */ jt({
  __name: "ViewportRenderer",
  setup(r) {
    const e = _n(), n = Xe(() => e.activeCamera), i = Xe(() => e.width), s = Xe(() => e.height), o = Xe(() => e.viewportState), a = Xe(() => e.viewOptions), l = Xe(() => e.layers.filter((oe) => oe.type !== "camera").map((oe) => ({
      id: oe.id,
      name: oe.name,
      position: {
        x: oe.transform.position.value.x,
        y: oe.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(oe.id)
    }))), c = Ce([null, null, null, null]), u = Ce([null, null, null, null]), h = Ce(!1), d = Ce({ x: 0, y: 0 }), p = Ce(0), f = Ce(0), m = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], _ = Xe(() => o.value.layout), g = Xe(() => o.value.activeViewIndex), v = Xe(() => o.value.customViews), S = Xe(() => {
      switch (o.value.layout) {
        case "1-view":
          return [o.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return o.value.views.slice(0, 2);
        case "4-view":
          return o.value.views.slice(0, 4);
        default:
          return [o.value.views[0]];
      }
    });
    function b(oe, ne) {
      c.value[ne] = oe, oe && (u.value[ne] = oe.getContext("2d"));
    }
    function x(oe) {
      return oe.startsWith("custom-");
    }
    function M(oe) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[oe];
    }
    function C(oe) {
      e.updateViewportState({
        activeViewIndex: oe
      });
    }
    function E(oe, ne) {
      const $ = [...o.value.views];
      $[oe] = ne, e.updateViewportState({
        views: $
      });
    }
    function T(oe) {
      const ne = ["active-camera", "top", "front", "right"];
      let $ = [...o.value.views];
      for (; $.length < 4; )
        $.push(ne[$.length] || "front");
      e.updateViewportState({
        layout: oe,
        views: $,
        activeViewIndex: Math.min(o.value.activeViewIndex, w(oe) - 1)
      });
    }
    function w(oe) {
      switch (oe) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function A(oe) {
      const ne = {
        orbitCenter: { x: i.value / 2, y: s.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...o.value.customViews,
          [oe]: ne
        }
      });
    }
    function O(oe, ne) {
      h.value = !0, d.value = { x: oe.clientX, y: oe.clientY }, p.value = ne, f.value = oe.button, document.addEventListener("mousemove", U), document.addEventListener("mouseup", D);
    }
    function U(oe) {
      if (!h.value) return;
      const ne = oe.clientX - d.value.x, $ = oe.clientY - d.value.y;
      d.value = { x: oe.clientX, y: oe.clientY };
      const J = S.value[p.value];
      if (x(J)) {
        const se = v.value[J];
        if (f.value === 0) {
          const le = se.orbitTheta + ne * 0.5, re = Math.max(1, Math.min(179, se.orbitPhi + $ * 0.5));
          e.updateViewportState({
            customViews: {
              ...o.value.customViews,
              [J]: {
                ...se,
                orbitTheta: le,
                orbitPhi: re
              }
            }
          });
        } else (f.value === 1 || f.value === 2) && e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [J]: {
              ...se,
              orthoOffset: {
                x: se.orthoOffset.x + ne,
                y: se.orthoOffset.y + $
              }
            }
          }
        });
      }
    }
    function D() {
      h.value = !1, document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", D);
    }
    function L(oe, ne) {
      oe.preventDefault();
      const $ = S.value[ne];
      if (x($)) {
        const J = v.value[$], se = oe.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [$]: {
              ...J,
              orbitDistance: J.orbitDistance * se
            }
          }
        });
      }
    }
    function P() {
      S.value.forEach((oe, ne) => {
        const $ = c.value[ne], J = u.value[ne];
        if (!$ || !J) return;
        const se = $.getBoundingClientRect(), le = window.devicePixelRatio || 1;
        $.width = se.width * le, $.height = se.height * le, J.scale(le, le), J.fillStyle = "#1a1a1a", J.fillRect(0, 0, se.width, se.height);
        let re;
        oe === "active-camera" && n.value ? re = sG(n.value, i.value, s.value) : x(oe) ? re = a1(oe, i.value, s.value, v.value[oe]) : re = a1(oe, i.value, s.value);
        const ye = [];
        if (a.value.showGrid && ye.push(...oG(i.value, s.value)), a.value.show3DReferenceAxes && ye.push(...rG(Mt(i.value / 2, s.value / 2, 0))), a.value.showCompositionBounds) {
          const H = o1(
            n.value ?? V(),
            i.value,
            s.value,
            !1,
            !0,
            !1
          );
          ye.push(...H.compositionBounds);
        }
        if (oe !== "active-camera" && n.value && (a.value.cameraWireframes === "always" || a.value.cameraWireframes === "selected")) {
          const K = o1(
            n.value,
            i.value,
            s.value,
            !0,
            !1,
            a.value.showFocalPlane
          );
          ye.push(...K.body), ye.push(...K.frustum), ye.push(...K.focalPlane), K.poiLine && ye.push(K.poiLine);
        }
        for (const H of ye) {
          const K = kp(H.start, re.viewProjection, se.width, se.height), G = kp(H.end, re.viewProjection, se.width, se.height);
          !K.visible && !G.visible || (J.beginPath(), J.strokeStyle = H.color, J.lineWidth = 1, J.moveTo(K.x, K.y), J.lineTo(G.x, G.y), J.stroke());
        }
        if (a.value.showLayerHandles)
          for (const H of l.value) {
            const K = kp(H.position, re.viewProjection, se.width, se.height);
            K.visible && (J.beginPath(), J.fillStyle = H.selected ? "#ffcc00" : "#888888", J.arc(K.x, K.y, H.selected ? 6 : 4, 0, Math.PI * 2), J.fill(), J.fillStyle = "#ffffff", J.font = "10px sans-serif", J.fillText(H.name, K.x + 8, K.y + 4));
          }
      });
    }
    function V() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: i.value / 2, y: s.value / 2, z: -1500 },
        pointOfInterest: { x: i.value / 2, y: s.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let ce;
    function q() {
      P(), ce = requestAnimationFrame(q);
    }
    return Xn(() => {
      q();
    }), Ni(() => {
      cancelAnimationFrame(ce);
    }), At([n, o, a, l], () => {
    }, { deep: !0 }), (oe, ne) => (ie(), ue("div", {
      class: Ye(["viewport-renderer", [`layout-${_.value}`]])
    }, [
      (ie(!0), ue(nt, null, pt(S.value, ($, J) => {
        var se, le;
        return ie(), ue("div", {
          key: J,
          class: Ye(["view-panel", { active: J === g.value }]),
          onClick: (re) => C(J)
        }, [
          y("div", lG, [
            y("select", {
              value: $,
              onChange: (re) => E(J, re.target.value),
              class: "view-select"
            }, [...ne[1] || (ne[1] = [
              ea('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, cG),
            y("div", uG, [
              x($) ? (ie(), ue("button", {
                key: 0,
                onClick: Rt((re) => A($), ["stop"]),
                title: "Reset View"
              }, [...ne[2] || (ne[2] = [
                y("span", { class: "icon" }, "", -1)
              ])], 8, hG)) : Ne("", !0)
            ])
          ]),
          y("canvas", {
            ref_for: !0,
            ref: (re) => b(re, J),
            class: "view-canvas",
            onMousedown: (re) => O(re, J),
            onWheel: (re) => L(re, J),
            onContextmenu: ne[0] || (ne[0] = Rt(() => {
            }, ["prevent"]))
          }, null, 40, dG),
          y("div", fG, [
            y("span", pG, Ae(M($)), 1),
            x($) ? (ie(), ue("span", mG, " : " + Ae(Math.round(((se = v.value[$]) == null ? void 0 : se.orbitTheta) ?? 0)) + " : " + Ae(Math.round(((le = v.value[$]) == null ? void 0 : le.orbitPhi) ?? 0)) + " ", 1)) : Ne("", !0)
          ])
        ], 10, aG);
      }), 128)),
      y("div", gG, [
        (ie(), ue(nt, null, pt(m, ($) => y("button", {
          key: $.value,
          class: Ye({ active: _.value === $.value }),
          onClick: (J) => T($.value),
          title: $.label
        }, Ae($.icon), 11, vG)), 64))
      ])
    ], 2));
  }
}), _G = /* @__PURE__ */ Yt(yG, [["__scopeId", "data-v-cdf0e094"]]);
function Re(r, e, n) {
  return (e = function(i) {
    var s = function(o, a) {
      if (typeof o != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var c = l.call(o, a);
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(o);
    }(i, "string");
    return typeof s == "symbol" ? s : s + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = n, r;
}
function l1(r, e) {
  var n = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Ie(r) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? l1(Object(n), !0).forEach(function(i) {
      Re(r, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(n)) : l1(Object(n)).forEach(function(i) {
      Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return r;
}
function pn(r, e) {
  if (r == null) return {};
  var n, i, s = function(a, l) {
    if (a == null) return {};
    var c = {};
    for (var u in a) if ({}.hasOwnProperty.call(a, u)) {
      if (l.indexOf(u) >= 0) continue;
      c[u] = a[u];
    }
    return c;
  }(r, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(r);
    for (i = 0; i < o.length; i++) n = o[i], e.indexOf(n) >= 0 || {}.propertyIsEnumerable.call(r, n) && (s[n] = r[n]);
  }
  return s;
}
function Ys(r, e) {
  return e || (e = r.slice(0)), Object.freeze(Object.defineProperties(r, { raw: { value: Object.freeze(e) } }));
}
class c1 {
  constructor() {
    Re(this, "browserShadowBlurConstant", 1), Re(this, "DPI", 96), Re(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), Re(this, "perfLimitSizeTotal", 2097152), Re(this, "maxCacheSideLimit", 4096), Re(this, "minCacheSideLimit", 256), Re(this, "disableStyleCopyPaste", !1), Re(this, "enableGLFiltering", !0), Re(this, "textureSize", 4096), Re(this, "forceGLPutImageData", !1), Re(this, "cachesBoundsOfCurve", !1), Re(this, "fontPaths", {}), Re(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const Gt = new class extends c1 {
  constructor(r) {
    super(), this.configure(r);
  }
  configure() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, r);
  }
  addFonts() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = Ie(Ie({}, this.fontPaths), r);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((r) => {
      delete this.fontPaths[r];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(r) {
    const e = new c1(), n = (r == null ? void 0 : r.reduce((i, s) => (i[s] = e[s], i), {})) || e;
    this.configure(n);
  }
}(), lo = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
  return console[r]("fabric", ...n);
};
class Ns extends Error {
  constructor(e, n) {
    super("fabric: ".concat(e), n);
  }
}
class xG extends Ns {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class bG {
}
class wG extends bG {
  testPrecision(e, n) {
    const i = "precision ".concat(n, ` float;
void main(){}`), s = e.createShader(e.FRAGMENT_SHADER);
    return !!s && (e.shaderSource(s, i), e.compileShader(s), !!e.getShaderParameter(s, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const n = e.getContext("webgl");
    n && (this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((i) => this.testPrecision(n, i)), n.getExtension("WEBGL_lose_context").loseContext(), lo("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const SG = {};
let u1;
const $s = () => u1 || (u1 = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new wG(), dispose() {
}, copyPasteData: SG }), wl = () => $s().document, df = () => $s().window, tw = () => {
  var r;
  return Math.max((r = Gt.devicePixelRatio) !== null && r !== void 0 ? r : df().devicePixelRatio, 1);
}, Ac = new class {
  constructor() {
    Re(this, "boundsOfCurveCache", {}), this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  getFontCache(r) {
    let { fontFamily: e, fontStyle: n, fontWeight: i } = r;
    e = e.toLowerCase();
    const s = this.charWidthsCache;
    s.has(e) || s.set(e, /* @__PURE__ */ new Map());
    const o = s.get(e), a = "".concat(n.toLowerCase(), "_").concat((i + "").toLowerCase());
    return o.has(a) || o.set(a, /* @__PURE__ */ new Map()), o.get(a);
  }
  clearFontCache(r) {
    r ? this.charWidthsCache.delete((r || "").toLowerCase()) : this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  limitDimsByArea(r) {
    const { perfLimitSizeTotal: e } = Gt, n = Math.sqrt(e * r);
    return [Math.floor(n), Math.floor(e / n)];
  }
}(), ig = "6.9.0";
function Jh() {
}
const fu = Math.PI / 2, Td = 2 * Math.PI, pv = Math.PI / 180, Si = Object.freeze([1, 0, 0, 1, 0, 0]), mv = 16, jr = 0.4477152502, It = "center", Qt = "left", Fi = "top", sg = "bottom", In = "right", Ui = "none", gv = /\r?\n/, nw = "moving", ff = "scaling", iw = "rotating", vv = "rotate", sw = "skewing", Qc = "resizing", MG = "modifyPoly", CG = "modifyPath", Ed = "changed", pf = "scale", Bi = "scaleX", ss = "scaleY", Sl = "skewX", Ml = "skewY", Hn = "fill", zi = "stroke", Ad = "modified", Pa = "json", Rp = "svg", ht = new class {
  constructor() {
    this[Pa] = /* @__PURE__ */ new Map(), this[Rp] = /* @__PURE__ */ new Map();
  }
  has(r) {
    return this[Pa].has(r);
  }
  getClass(r) {
    const e = this[Pa].get(r);
    if (!e) throw new Ns("No class registered for ".concat(r));
    return e;
  }
  setClass(r, e) {
    e ? this[Pa].set(e, r) : (this[Pa].set(r.type, r), this[Pa].set(r.type.toLowerCase(), r));
  }
  getSVGClass(r) {
    return this[Rp].get(r);
  }
  setSVGClass(r, e) {
    this[Rp].set(e ?? r.type.toLowerCase(), r);
  }
}(), Pd = new class extends Array {
  remove(r) {
    const e = this.indexOf(r);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const r = this.splice(0);
    return r.forEach((e) => e.abort()), r;
  }
  cancelByCanvas(r) {
    if (!r) return [];
    const e = this.filter((n) => {
      var i;
      return n.target === r || typeof n.target == "object" && ((i = n.target) === null || i === void 0 ? void 0 : i.canvas) === r;
    });
    return e.forEach((n) => n.abort()), e;
  }
  cancelByTarget(r) {
    if (!r) return [];
    const e = this.filter((n) => n.target === r);
    return e.forEach((n) => n.abort()), e;
  }
}();
class TG {
  constructor() {
    Re(this, "__eventListeners", {});
  }
  on(e, n) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((i) => {
      let [s, o] = i;
      this.on(s, o);
    }), () => this.off(e);
    if (n) {
      const i = e;
      return this.__eventListeners[i] || (this.__eventListeners[i] = []), this.__eventListeners[i].push(n), () => this.off(i, n);
    }
    return () => !1;
  }
  once(e, n) {
    if (typeof e == "object") {
      const i = [];
      return Object.entries(e).forEach((s) => {
        let [o, a] = s;
        i.push(this.once(o, a));
      }), () => i.forEach((s) => s());
    }
    if (n) {
      const i = this.on(e, function() {
        for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
        n.call(this, ...o), i();
      });
      return i;
    }
    return () => !1;
  }
  _removeEventListener(e, n) {
    if (this.__eventListeners[e]) if (n) {
      const i = this.__eventListeners[e], s = i.indexOf(n);
      s > -1 && i.splice(s, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, n) {
    if (this.__eventListeners) if (e === void 0) for (const i in this.__eventListeners) this._removeEventListener(i);
    else typeof e == "object" ? Object.entries(e).forEach((i) => {
      let [s, o] = i;
      this._removeEventListener(s, o);
    }) : this._removeEventListener(e, n);
  }
  fire(e, n) {
    var i;
    if (!this.__eventListeners) return;
    const s = (i = this.__eventListeners[e]) === null || i === void 0 ? void 0 : i.concat();
    if (s) for (let o = 0; o < s.length; o++) s[o].call(this, n || {});
  }
}
const Fa = (r, e) => {
  const n = r.indexOf(e);
  return n !== -1 && r.splice(n, 1), r;
}, Er = (r) => {
  if (r === 0) return 1;
  switch (Math.abs(r) / fu) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(r);
}, Ar = (r) => {
  if (r === 0) return 0;
  const e = r / fu, n = Math.sign(r);
  switch (e) {
    case 1:
      return n;
    case 2:
      return 0;
    case 3:
      return -n;
  }
  return Math.sin(r);
};
class He {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = n);
  }
  add(e) {
    return new He(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new He(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new He(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new He(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new He(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new He(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new He(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new He(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return n = Math.max(Math.min(1, n), 0), new He(this.x + (e.x - this.x) * n, this.y + (e.y - this.y) * n);
  }
  distanceFrom(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return Math.sqrt(n * n + i * i);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new He(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new He(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, n) {
    return this.x = e, this.y = n, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const n = this.x, i = this.y;
    this.x = e.x, this.y = e.y, e.x = n, e.y = i;
  }
  clone() {
    return new He(this.x, this.y);
  }
  rotate(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yv;
    const i = Ar(e), s = Er(e), o = this.subtract(n);
    return new He(o.x * s - o.y * i, o.x * i + o.y * s).add(n);
  }
  transform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new He(e[0] * this.x + e[2] * this.y + (n ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (n ? 0 : e[5]));
  }
}
const yv = new He(0, 0), Qh = (r) => !!r && Array.isArray(r._objects);
function rw(r) {
  class e extends r {
    constructor() {
      super(...arguments), Re(this, "_objects", []);
    }
    _onObjectAdded(i) {
    }
    _onObjectRemoved(i) {
    }
    _onStackOrderChanged(i) {
    }
    add() {
      for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++) s[o] = arguments[o];
      const a = this._objects.push(...s);
      return s.forEach((l) => this._onObjectAdded(l)), a;
    }
    insertAt(i) {
      for (var s = arguments.length, o = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++) o[a - 1] = arguments[a];
      return this._objects.splice(i, 0, ...o), o.forEach((l) => this._onObjectAdded(l)), this._objects.length;
    }
    remove() {
      const i = this._objects, s = [];
      for (var o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
      return a.forEach((c) => {
        const u = i.indexOf(c);
        u !== -1 && (i.splice(u, 1), s.push(c), this._onObjectRemoved(c));
      }), s;
    }
    forEachObject(i) {
      this.getObjects().forEach((s, o, a) => i(s, o, a));
    }
    getObjects() {
      for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++) s[o] = arguments[o];
      return s.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...s));
    }
    item(i) {
      return this._objects[i];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(i, s) {
      return !!this._objects.includes(i) || !!s && this._objects.some((o) => o instanceof e && o.contains(i, !0));
    }
    complexity() {
      return this._objects.reduce((i, s) => i += s.complexity ? s.complexity() : 0, 0);
    }
    sendObjectToBack(i) {
      return !(!i || i === this._objects[0]) && (Fa(this._objects, i), this._objects.unshift(i), this._onStackOrderChanged(i), !0);
    }
    bringObjectToFront(i) {
      return !(!i || i === this._objects[this._objects.length - 1]) && (Fa(this._objects, i), this._objects.push(i), this._onStackOrderChanged(i), !0);
    }
    sendObjectBackwards(i, s) {
      if (!i) return !1;
      const o = this._objects.indexOf(i);
      if (o !== 0) {
        const a = this.findNewLowerIndex(i, o, s);
        return Fa(this._objects, i), this._objects.splice(a, 0, i), this._onStackOrderChanged(i), !0;
      }
      return !1;
    }
    bringObjectForward(i, s) {
      if (!i) return !1;
      const o = this._objects.indexOf(i);
      if (o !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(i, o, s);
        return Fa(this._objects, i), this._objects.splice(a, 0, i), this._onStackOrderChanged(i), !0;
      }
      return !1;
    }
    moveObjectTo(i, s) {
      return i !== this._objects[s] && (Fa(this._objects, i), this._objects.splice(s, 0, i), this._onStackOrderChanged(i), !0);
    }
    findNewLowerIndex(i, s, o) {
      let a;
      if (o) {
        a = s;
        for (let l = s - 1; l >= 0; --l) if (i.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = s - 1;
      return a;
    }
    findNewUpperIndex(i, s, o) {
      let a;
      if (o) {
        a = s;
        for (let l = s + 1; l < this._objects.length; ++l) if (i.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = s + 1;
      return a;
    }
    collectObjects(i) {
      let { left: s, top: o, width: a, height: l } = i, { includeIntersecting: c = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const u = [], h = new He(s, o), d = h.add(new He(a, l));
      for (let p = this._objects.length - 1; p >= 0; p--) {
        const f = this._objects[p];
        f.selectable && f.visible && (c && f.intersectsWithRect(h, d) || f.isContainedWithinRect(h, d) || c && f.containsPoint(h) || c && f.containsPoint(d)) && u.push(f);
      }
      return u;
    }
  }
  return e;
}
class ow extends TG {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const n in e) this.set(n, e[n]);
  }
  _setObject(e) {
    for (const n in e) this._set(n, e[n]);
  }
  set(e, n) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, n), this;
  }
  _set(e, n) {
    this[e] = n;
  }
  toggle(e) {
    const n = this.get(e);
    return typeof n == "boolean" && this.set(e, !n), this;
  }
  get(e) {
    return this[e];
  }
}
function ed(r) {
  return df().requestAnimationFrame(r);
}
function EG(r) {
  return df().cancelAnimationFrame(r);
}
let AG = 0;
const co = () => AG++, Pr = () => {
  const r = wl().createElement("canvas");
  if (!r || r.getContext === void 0) throw new Ns("Failed to create `canvas` element");
  return r;
}, PG = () => wl().createElement("img"), rs = (r) => {
  const e = Pr();
  return e.width = r.width, e.height = r.height, e;
}, aw = (r, e, n) => r.toDataURL("image/".concat(e), n), lw = (r, e, n) => new Promise((i, s) => {
  r.toBlob(i, "image/".concat(e), n);
}), On = (r) => r * pv, Dr = (r) => r / pv, DG = (r) => r.every((e, n) => e === Si[n]), ki = (r, e, n) => new He(r).transform(e, n), bs = (r) => {
  const e = 1 / (r[0] * r[3] - r[1] * r[2]), n = [e * r[3], -e * r[1], -e * r[2], e * r[0], 0, 0], { x: i, y: s } = new He(r[4], r[5]).transform(n, !0);
  return n[4] = -i, n[5] = -s, n;
}, ni = (r, e, n) => [r[0] * e[0] + r[2] * e[1], r[1] * e[0] + r[3] * e[1], r[0] * e[2] + r[2] * e[3], r[1] * e[2] + r[3] * e[3], n ? 0 : r[0] * e[4] + r[2] * e[5] + r[4], n ? 0 : r[1] * e[4] + r[3] * e[5] + r[5]], _v = (r, e) => r.reduceRight((n, i) => i && n ? ni(i, n, e) : i || n, void 0) || Si.concat(), cw = (r) => {
  let [e, n] = r;
  return Math.atan2(n, e);
}, Dd = (r) => {
  const e = cw(r), n = Math.pow(r[0], 2) + Math.pow(r[1], 2), i = Math.sqrt(n), s = (r[0] * r[3] - r[2] * r[1]) / i, o = Math.atan2(r[0] * r[2] + r[1] * r[3], n);
  return { angle: Dr(e), scaleX: i, scaleY: s, skewX: Dr(o), skewY: 0, translateX: r[4] || 0, translateY: r[5] || 0 };
}, pu = function(r) {
  return [1, 0, 0, 1, r, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function Cl() {
  let { angle: r = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: n = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const i = On(r), s = Er(i), o = Ar(i);
  return [s, o, -o, s, e ? e - (s * e - o * n) : 0, n ? n - (o * e + s * n) : 0];
}
const xv = function(r) {
  return [r, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r, 0, 0];
}, uw = (r) => Math.tan(On(r)), hw = (r) => [1, 0, uw(r), 1, 0, 0], dw = (r) => [1, uw(r), 0, 1, 0, 0], mf = (r) => {
  let { scaleX: e = 1, scaleY: n = 1, flipX: i = !1, flipY: s = !1, skewX: o = 0, skewY: a = 0 } = r, l = xv(i ? -e : e, s ? -n : n);
  return o && (l = ni(l, hw(o), !0)), a && (l = ni(l, dw(a), !0)), l;
}, kG = (r) => {
  const { translateX: e = 0, translateY: n = 0, angle: i = 0 } = r;
  let s = pu(e, n);
  i && (s = ni(s, Cl({ angle: i })));
  const o = mf(r);
  return DG(o) || (s = ni(s, o)), s;
}, td = function(r) {
  let { signal: e, crossOrigin: n = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(i, s) {
    if (e && e.aborted) return s(new xG("loadImage"));
    const o = PG();
    let a;
    e && (a = function(c) {
      o.src = "", s(c);
    }, e.addEventListener("abort", a, { once: !0 }));
    const l = function() {
      o.onload = o.onerror = null, a && (e == null || e.removeEventListener("abort", a)), i(o);
    };
    r ? (o.onload = l, o.onerror = function() {
      a && (e == null || e.removeEventListener("abort", a)), s(new Ns("Error loading ".concat(o.src)));
    }, n && (o.crossOrigin = n), o.src = r) : l();
  });
}, eu = function(r) {
  let { signal: e, reviver: n = Jh } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((i, s) => {
    const o = [];
    e && e.addEventListener("abort", s, { once: !0 }), Promise.all(r.map((a) => ht.getClass(a.type).fromObject(a, { signal: e }).then((l) => (n(a, l), o.push(l), l)))).then(i).catch((a) => {
      o.forEach((l) => {
        l.dispose && l.dispose();
      }), s(a);
    }).finally(() => {
      e && e.removeEventListener("abort", s);
    });
  });
}, gf = function(r) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, i) => {
    const s = [];
    e && e.addEventListener("abort", i, { once: !0 });
    const o = Object.values(r).map((l) => l && l.type && ht.has(l.type) ? eu([l], { signal: e }).then((c) => {
      let [u] = c;
      return s.push(u), u;
    }) : l), a = Object.keys(r);
    Promise.all(o).then((l) => l.reduce((c, u, h) => (c[a[h]] = u, c), {})).then(n).catch((l) => {
      s.forEach((c) => {
        c.dispose && c.dispose();
      }), i(l);
    }).finally(() => {
      e && e.removeEventListener("abort", i);
    });
  });
}, Tl = function(r) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, n) => (n in r && (e[n] = r[n]), e), {});
}, bv = (r, e) => Object.keys(r).reduce((n, i) => (e(r[i], i, r) && (n[i] = r[i]), n), {}), hn = (r, e) => parseFloat(Number(r).toFixed(e)), tu = (r) => "matrix(" + r.map((e) => hn(e, Gt.NUM_FRACTION_DIGITS)).join(" ") + ")", es = (r) => !!r && r.toLive !== void 0, h1 = (r) => !!r && typeof r.toObject == "function", d1 = (r) => !!r && r.offsetX !== void 0 && "source" in r, Vo = (r) => !!r && "multiSelectionStacking" in r;
function fw(r) {
  const e = r && _s(r);
  let n = 0, i = 0;
  if (!r || !e) return { left: n, top: i };
  let s = r;
  const o = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; s && (s.parentNode || s.host) && (s = s.parentNode || s.host, s === e ? (n = a.scrollLeft || o.scrollLeft || 0, i = a.scrollTop || o.scrollTop || 0) : (n += s.scrollLeft || 0, i += s.scrollTop || 0), s.nodeType !== 1 || s.style.position !== "fixed"); ) ;
  return { left: n, top: i };
}
const _s = (r) => r.ownerDocument || null, pw = (r) => {
  var e;
  return ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, mw = function(r, e, n) {
  let { width: i, height: s } = n, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  r.width = i, r.height = s, o > 1 && (r.setAttribute("width", (i * o).toString()), r.setAttribute("height", (s * o).toString()), e.scale(o, o));
}, rg = (r, e) => {
  let { width: n, height: i } = e;
  n && (r.style.width = typeof n == "number" ? "".concat(n, "px") : n), i && (r.style.height = typeof i == "number" ? "".concat(i, "px") : i);
};
function f1(r) {
  return r.onselectstart !== void 0 && (r.onselectstart = () => !1), r.style.userSelect = Ui, r;
}
class gw {
  constructor(e) {
    Re(this, "_originalCanvasStyle", void 0), Re(this, "lower", void 0);
    const n = this.createLowerCanvas(e);
    this.lower = { el: n, ctx: n.getContext("2d") };
  }
  createLowerCanvas(e) {
    const n = (i = e) && i.getContext !== void 0 ? e : e && wl().getElementById(e) || Pr();
    var i;
    if (n.hasAttribute("data-fabric")) throw new Ns("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = n.style.cssText, n.setAttribute("data-fabric", "main"), n.classList.add("lower-canvas"), n;
  }
  cleanupDOM(e) {
    let { width: n, height: i } = e;
    const { el: s } = this.lower;
    s.classList.remove("lower-canvas"), s.removeAttribute("data-fabric"), s.setAttribute("width", "".concat(n)), s.setAttribute("height", "".concat(i)), s.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, n) {
    const { el: i, ctx: s } = this.lower;
    mw(i, s, e, n);
  }
  setCSSDimensions(e) {
    rg(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var n;
      const i = e && _s(e), s = { left: 0, top: 0 };
      if (!i) return s;
      const o = ((n = pw(e)) === null || n === void 0 ? void 0 : n.getComputedStyle(e, null)) || {};
      s.left += parseInt(o.borderLeftWidth, 10) || 0, s.top += parseInt(o.borderTopWidth, 10) || 0, s.left += parseInt(o.paddingLeft, 10) || 0, s.top += parseInt(o.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const l = i.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const c = fw(e);
      return { left: a.left + c.left - (l.clientLeft || 0) + s.left, top: a.top + c.top - (l.clientTop || 0) + s.top };
    }(this.lower.el);
  }
  dispose() {
    $s().dispose(this.lower.el), delete this.lower;
  }
}
const RG = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...Si] }, LG = ["objects"];
class mu extends rw(ow) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return mu.ownDefaults;
  }
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(n), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new gw(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) i[s - 1] = arguments[s];
    const o = super.insertAt(e, ...i);
    return i.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), o;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (lo("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? tw() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, n) {
    return this.setDimensions({ width: e }, n);
  }
  setHeight(e, n) {
    return this.setDimensions({ height: e }, n);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: n = !1, backstoreOnly: i = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!n) {
      const s = Ie({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(s, this.getRetinaScaling()), this.hasLostContext = !0, this.width = s.width, this.height = s.height;
    }
    i || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, n) {
    this._setDimensionsImpl(e, n), n && n.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, n) {
    const i = e, s = [...this.viewportTransform], o = ki(e, bs(s));
    s[0] = n, s[3] = n;
    const a = ki(o, s);
    s[4] += i.x - a.x, s[5] += i.y - a.y, this.setViewportTransform(s);
  }
  setZoom(e) {
    this.zoomToPoint(new He(0, 0), e);
  }
  absolutePan(e) {
    const n = [...this.viewportTransform];
    return n[4] = -e.x, n[5] = -e.y, this.setViewportTransform(n);
  }
  relativePan(e) {
    return this.absolutePan(new He(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = ed(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, n = this.height, i = bs(this.viewportTransform), s = ki({ x: 0, y: 0 }, i), o = ki({ x: e, y: n }, i), a = s.min(o), l = s.max(o);
    return this.vptCoords = { tl: a, tr: new He(l.x, a.y), bl: new He(a.x, l.y), br: l };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (EG(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, n) {
    if (this.destroyed) return;
    const i = this.viewportTransform, s = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this._renderObjects(e, n), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), s && (s._set("canvas", this), s.shouldCache(), s._transformDone = !0, s.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, s)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, n) {
    const i = this.viewportTransform;
    e.save(), e.transform(...i), e.globalCompositeOperation = "destination-in", n.transform(e), e.scale(1 / n.zoomX, 1 / n.zoomY), e.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), e.restore();
  }
  _renderObjects(e, n) {
    for (let i = 0, s = n.length; i < s; ++i) n[i] && n[i].render(e);
  }
  _renderBackgroundOrOverlay(e, n) {
    const i = this["".concat(n, "Color")], s = this["".concat(n, "Image")], o = this.viewportTransform, a = this["".concat(n, "Vpt")];
    if (!i && !s) return;
    const l = es(i);
    if (i) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = l ? i.toLive(e) : i, a && e.transform(...o), l) {
        e.transform(1, 0, 0, 1, i.offsetX || 0, i.offsetY || 0);
        const c = i.gradientTransform || i.patternTransform;
        c && e.transform(...c);
      }
      e.fill(), e.restore();
    }
    if (s) {
      e.save();
      const { skipOffscreen: c } = this;
      this.skipOffscreen = a, a && e.transform(...o), s.render(e), this.skipOffscreen = c, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new He(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new He(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new He(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new He(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new He(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return ki(this.getCenterPoint(), bs(this.viewportTransform));
  }
  _centerObject(e, n) {
    e.setXY(n, It, It), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, n) {
    const i = this.clipPath, s = i && !i.excludeFromExport ? this._toObject(i, e, n) : null;
    return Ie(Ie(Ie({ version: ig }, Tl(this, n)), {}, { objects: this._objects.filter((o) => !o.excludeFromExport).map((o) => this._toObject(o, e, n)) }, this.__serializeBgOverlay(e, n)), s ? { clipPath: s } : null);
  }
  _toObject(e, n, i) {
    let s;
    this.includeDefaultValues || (s = e.includeDefaultValues, e.includeDefaultValues = !1);
    const o = e[n](i);
    return this.includeDefaultValues || (e.includeDefaultValues = !!s), o;
  }
  __serializeBgOverlay(e, n) {
    const i = {}, s = this.backgroundImage, o = this.overlayImage, a = this.backgroundColor, l = this.overlayColor;
    return es(a) ? a.excludeFromExport || (i.background = a.toObject(n)) : a && (i.background = a), es(l) ? l.excludeFromExport || (i.overlay = l.toObject(n)) : l && (i.overlay = l), s && !s.excludeFromExport && (i.backgroundImage = this._toObject(s, e, n)), o && !o.excludeFromExport && (i.overlayImage = this._toObject(o, e, n)), i;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = n;
    const i = [];
    return this._setSVGPreamble(i, e), this._setSVGHeader(i, e), this.clipPath && i.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(i, "background"), this._setSVGBgOverlayImage(i, "backgroundImage", n), this._setSVGObjects(i, n), this.clipPath && i.push(`</g>
`), this._setSVGBgOverlayColor(i, "overlay"), this._setSVGBgOverlayImage(i, "overlayImage", n), i.push("</svg>"), i.join("");
  }
  _setSVGPreamble(e, n) {
    n.suppressPreamble || e.push('<?xml version="1.0" encoding="', n.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, n) {
    const i = n.width || "".concat(this.width), s = n.height || "".concat(this.height), o = Gt.NUM_FRACTION_DIGITS, a = n.viewBox;
    let l;
    if (a) l = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const c = this.viewportTransform;
      l = 'viewBox="'.concat(hn(-c[4] / c[0], o), " ").concat(hn(-c[5] / c[3], o), " ").concat(hn(this.width / c[0], o), " ").concat(hn(this.height / c[3], o), '" ');
    } else l = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', i, '" ', 'height="', s, '" ', l, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", ig, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(n), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const n = this.clipPath;
    return n ? (n.clipPathId = "CLIPPATH_".concat(co()), '<clipPath id="'.concat(n.clipPathId, `" >
`).concat(n.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const n = this["".concat(e, "Color")];
      if (es(n)) {
        const i = this["".concat(e, "Vpt")], s = this.viewportTransform, o = { isType: () => !1, width: this.width / (i ? s[0] : 1), height: this.height / (i ? s[3] : 1) };
        return n.toSVG(o, { additionalTransform: i ? tu(s) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], n = {}, i = Gt.fontPaths;
    this._objects.forEach(function o(a) {
      e.push(a), Qh(a) && a._objects.forEach(o);
    }), e.forEach((o) => {
      if (!(a = o) || typeof a._renderText != "function") return;
      var a;
      const { styles: l, fontFamily: c } = o;
      !n[c] && i[c] && (n[c] = !0, l && Object.values(l).forEach((u) => {
        Object.values(u).forEach((h) => {
          let { fontFamily: d = "" } = h;
          !n[d] && i[d] && (n[d] = !0);
        });
      }));
    });
    const s = Object.keys(n).map((o) => `		@font-face {
			font-family: '`.concat(o, `';
			src: url('`).concat(i[o], `');
		}
`)).join("");
    return s ? `	<style type="text/css"><![CDATA[
`.concat(s, `]]></style>
`) : "";
  }
  _setSVGObjects(e, n) {
    this.forEachObject((i) => {
      i.excludeFromExport || this._setSVGObject(e, i, n);
    });
  }
  _setSVGObject(e, n, i) {
    e.push(n.toSVG(i));
  }
  _setSVGBgOverlayImage(e, n, i) {
    const s = this[n];
    s && !s.excludeFromExport && s.toSVG && e.push(s.toSVG(i));
  }
  _setSVGBgOverlayColor(e, n) {
    const i = this["".concat(n, "Color")];
    if (i) if (es(i)) {
      const s = i.repeat || "", o = this.width, a = this.height, l = this["".concat(n, "Vpt")] ? tu(bs(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(l, " translate(").concat(o / 2, ",").concat(a / 2, ')" x="').concat(i.offsetX - o / 2, '" y="').concat(i.offsetY - a / 2, '" width="').concat(s !== "repeat-y" && s !== "no-repeat" || !d1(i) ? o : i.source.width, '" height="').concat(s !== "repeat-x" && s !== "no-repeat" || !d1(i) ? a : i.source.height, '" fill="url(#SVGID_').concat(i.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', i, '"', `></rect>
`);
  }
  loadFromJSON(e, n) {
    let { signal: i } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new Ns("`json` is undefined"));
    const s = typeof e == "string" ? JSON.parse(e) : e, { objects: o = [] } = s, a = pn(s, LG), { backgroundImage: l, background: c, overlayImage: u, overlay: h, clipPath: d } = a, p = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([eu(o, { reviver: n, signal: i }), gf({ backgroundImage: l, backgroundColor: c, overlayImage: u, overlayColor: h, clipPath: d }, { signal: i })]).then((f) => {
      let [m, _] = f;
      return this.clear(), this.add(...m), this.set(a), this.set(_), this.renderOnAddRemove = p, this;
    });
  }
  clone(e) {
    const n = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(n);
  }
  cloneWithoutData() {
    const e = rs(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: i = 1, multiplier: s = 1, enableRetinaScaling: o = !1 } = e, a = s * (o ? this.getRetinaScaling() : 1);
    return aw(this.toCanvasElement(a, e), n, i);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: i = 1, multiplier: s = 1, enableRetinaScaling: o = !1 } = e, a = s * (o ? this.getRetinaScaling() : 1);
    return lw(this.toCanvasElement(a, e), n, i);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: n, height: i, left: s, top: o, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const l = (n || this.width) * e, c = (i || this.height) * e, u = this.getZoom(), h = this.width, d = this.height, p = this.skipControlsDrawing, f = u * e, m = this.viewportTransform, _ = [f, 0, 0, f, (m[4] - (s || 0)) * e, (m[5] - (o || 0)) * e], g = this.enableRetinaScaling, v = rs({ width: l, height: c }), S = a ? this._objects.filter((b) => a(b)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = _, this.width = l, this.height = c, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(v.getContext("2d"), S), this.viewportTransform = m, this.width = h, this.height = d, this.calcViewportBoundaries(), this.enableRetinaScaling = g, this.skipControlsDrawing = p, v;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), Pd.cancelByCanvas(this), this.disposed = !0, new Promise((e, n) => {
      const i = () => {
        this.destroy(), e(!0);
      };
      i.kill = n, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = i : i();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
Re(mu, "ownDefaults", RG);
const IG = ["touchstart", "touchmove", "touchend"], OG = (r) => {
  const e = fw(r.target), n = function(i) {
    const s = i.changedTouches;
    return s && s[0] ? s[0] : i;
  }(r);
  return new He(n.clientX + e.left, n.clientY + e.top);
}, og = (r) => IG.includes(r.type) || r.pointerType === "touch", p1 = (r) => {
  r.preventDefault(), r.stopPropagation();
}, br = (r) => {
  let e = 0, n = 0, i = 0, s = 0;
  for (let o = 0, a = r.length; o < a; o++) {
    const { x: l, y: c } = r[o];
    (l > i || !o) && (i = l), (l < e || !o) && (e = l), (c > s || !o) && (s = c), (c < n || !o) && (n = c);
  }
  return { left: e, top: n, width: i - e, height: s - n };
}, FG = ["translateX", "translateY", "scaleX", "scaleY"], UG = (r, e) => kd(r, ni(e, r.calcOwnMatrix())), kd = (r, e) => {
  const n = Dd(e), { translateX: i, translateY: s, scaleX: o, scaleY: a } = n, l = pn(n, FG), c = new He(i, s);
  r.flipX = !1, r.flipY = !1, Object.assign(r, l), r.set({ scaleX: o, scaleY: a }), r.setPositionByOrigin(c, It, It);
}, zG = (r) => {
  r.scaleX = 1, r.scaleY = 1, r.skewX = 0, r.skewY = 0, r.flipX = !1, r.flipY = !1, r.rotate(0);
}, vw = (r) => ({ scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, angle: r.angle, left: r.left, flipX: r.flipX, flipY: r.flipY, top: r.top }), wv = (r, e, n) => {
  const i = r / 2, s = e / 2, o = [new He(-i, -s), new He(i, -s), new He(-i, s), new He(i, s)].map((l) => l.transform(n)), a = br(o);
  return new He(a.width, a.height);
}, vf = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Si;
  return ni(bs(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Si), r);
}, el = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Si, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Si;
  return r.transform(vf(e, n));
}, BG = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Si, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Si;
  return r.transform(vf(e, n), !0);
}, NG = (r, e, n) => {
  const i = vf(e, n);
  return kd(r, ni(i, r.calcOwnMatrix())), i;
}, yw = (r, e) => {
  var n;
  const { transform: { target: i } } = e;
  (n = i.canvas) === null || n === void 0 || n.fire("object:".concat(r), Ie(Ie({}, e), {}, { target: i })), i.fire(r, e);
}, VG = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, Vn = (r) => typeof r == "string" ? VG[r] : r - 0.5, Rd = "not-allowed";
function _w(r) {
  return Vn(r.originX) === Vn(It) && Vn(r.originY) === Vn(It);
}
function m1(r) {
  return 0.5 - Vn(r);
}
const Ms = (r, e) => r[e], xw = (r, e, n, i) => ({ e: r, transform: e, pointer: new He(n, i) });
function bw(r, e) {
  const n = r.getTotalAngle() + Dr(Math.atan2(e.y, e.x)) + 360;
  return Math.round(n % 360 / 45);
}
function Sv(r, e, n, i, s) {
  var o;
  let { target: a, corner: l } = r;
  const c = a.controls[l], u = ((o = a.canvas) === null || o === void 0 ? void 0 : o.getZoom()) || 1, h = a.padding / u, d = function(p, f, m, _) {
    const g = p.getRelativeCenterPoint(), v = m !== void 0 && _ !== void 0 ? p.translateToGivenOrigin(g, It, It, m, _) : new He(p.left, p.top);
    return (p.angle ? f.rotate(-On(p.angle), g) : f).subtract(v);
  }(a, new He(i, s), e, n);
  return d.x >= h && (d.x -= h), d.x <= -h && (d.x += h), d.y >= h && (d.y -= h), d.y <= h && (d.y += h), d.x -= c.offsetX, d.y -= c.offsetY, d;
}
const GG = (r, e, n, i) => {
  const { target: s, offsetX: o, offsetY: a } = e, l = n - o, c = i - a, u = !Ms(s, "lockMovementX") && s.left !== l, h = !Ms(s, "lockMovementY") && s.top !== c;
  return u && s.set(Qt, l), h && s.set(Fi, c), (u || h) && yw(nw, xw(r, e, n, i)), u || h;
}, Ld = (r) => r.replace(/\s+/g, " "), g1 = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, Lp = (r, e, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + 6 * (e - r) * n : n < 0.5 ? e : n < 2 / 3 ? r + (e - r) * (2 / 3 - n) * 6 : r), v1 = (r, e, n, i) => {
  r /= 255, e /= 255, n /= 255;
  const s = Math.max(r, e, n), o = Math.min(r, e, n);
  let a, l;
  const c = (s + o) / 2;
  if (s === o) a = l = 0;
  else {
    const u = s - o;
    switch (l = c > 0.5 ? u / (2 - s - o) : u / (s + o), s) {
      case r:
        a = (e - n) / u + (e < n ? 6 : 0);
        break;
      case e:
        a = (n - r) / u + 2;
        break;
      case n:
        a = (r - e) / u + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * l), Math.round(100 * c), i];
}, y1 = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(r) / (r.endsWith("%") ? 100 : 1);
}, oh = (r) => Math.min(Math.round(r), 255).toString(16).toUpperCase().padStart(2, "0"), _1 = (r) => {
  let [e, n, i, s = 1] = r;
  const o = Math.round(0.3 * e + 0.59 * n + 0.11 * i);
  return [o, o, o, s];
};
class sn {
  constructor(e) {
    if (Re(this, "isUnrecognised", !1), e) if (e instanceof sn) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [n, i, s, o = 1] = e;
      this.setSource([n, i, s, o]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in g1 && (e = g1[e]), e === "transparent" ? [255, 255, 255, 0] : sn.sourceFromHex(e) || sn.sourceFromRgb(e) || sn.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, n, i] = this.getSource();
    return "rgb(".concat(e, ",").concat(n, ",").concat(i, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, n, i] = v1(...this.getSource());
    return "hsl(".concat(e, ",").concat(n, "%,").concat(i, "%)");
  }
  toHsla() {
    const [e, n, i, s] = v1(...this.getSource());
    return "hsla(".concat(e, ",").concat(n, "%,").concat(i, "%,").concat(s, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, n, i, s] = this.getSource();
    return "".concat(oh(e)).concat(oh(n)).concat(oh(i)).concat(oh(Math.round(255 * s)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(_1(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [n, , , i] = _1(this.getSource()), s = n < (e || 127) ? 0 : 255;
    return this.setSource([s, s, s, i]), this;
  }
  overlayWith(e) {
    e instanceof sn || (e = new sn(e));
    const n = this.getSource(), i = e.getSource(), [s, o, a] = n.map((l, c) => Math.round(0.5 * l + 0.5 * i[c]));
    return this.setSource([s, o, a, n[3]]), this;
  }
  static fromRgb(e) {
    return sn.fromRgba(e);
  }
  static fromRgba(e) {
    return new sn(sn.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const n = Ld(e).match(/^rgba?\(\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d{0,3}(?:\.\d+)?%?)\s?)?\)$/i);
    if (n) {
      const [i, s, o] = n.slice(1, 4).map((a) => {
        const l = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * l) : l;
      });
      return [i, s, o, y1(n[4])];
    }
  }
  static fromHsl(e) {
    return sn.fromHsla(e);
  }
  static fromHsla(e) {
    return new sn(sn.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const n = Ld(e).match(/^hsla?\(\s?([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d*(?:\.\d+)?%?)\s?)?\)$/i);
    if (!n) return;
    const i = (sn.parseAngletoDegrees(n[1]) % 360 + 360) % 360 / 360, s = parseFloat(n[2]) / 100, o = parseFloat(n[3]) / 100;
    let a, l, c;
    if (s === 0) a = l = c = o;
    else {
      const u = o <= 0.5 ? o * (s + 1) : o + s - o * s, h = 2 * o - u;
      a = Lp(h, u, i + 1 / 3), l = Lp(h, u, i), c = Lp(h, u, i - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * l), Math.round(255 * c), y1(n[4])];
  }
  static fromHex(e) {
    return new sn(sn.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const n = e.slice(e.indexOf("#") + 1);
      let i;
      i = n.length <= 4 ? n.split("").map((c) => c + c) : n.match(/.{2}/g);
      const [s, o, a, l = 255] = i.map((c) => parseInt(c, 16));
      return [s, o, a, l / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const n = e.toLowerCase(), i = parseFloat(n);
    return n.includes("rad") ? Dr(i) : n.includes("turn") ? 360 * i : i;
  }
}
const tl = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mv;
  const n = /\D{0,2}$/.exec(r), i = parseFloat(r), s = Gt.DPI;
  switch (n == null ? void 0 : n[0]) {
    case "mm":
      return i * s / 25.4;
    case "cm":
      return i * s / 2.54;
    case "in":
      return i * s;
    case "pt":
      return i * s / 72;
    case "pc":
      return i * s / 72 * 12;
    case "em":
      return i * e;
    default:
      return i;
  }
}, HG = (r) => {
  const [e, n] = r.trim().split(" "), [i, s] = (o = e) && o !== Ui ? [o.slice(1, 4), o.slice(5, 8)] : o === Ui ? [o, o] : ["Mid", "Mid"];
  var o;
  return { meetOrSlice: n || "meet", alignX: i, alignY: s };
}, nu = function(r, e) {
  let n, i, s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) n = "url(#SVGID_".concat(e.id, ")");
  else {
    const o = new sn(e), a = o.getAlpha();
    n = o.toRgb(), a !== 1 && (i = a.toString());
  }
  else n = "none";
  return s ? "".concat(r, ": ").concat(n, "; ").concat(i ? "".concat(r, "-opacity: ").concat(i, "; ") : "") : "".concat(r, '="').concat(n, '" ').concat(i ? "".concat(r, '-opacity="').concat(i, '" ') : "");
};
class ww {
  getSvgStyles(e) {
    const n = this.fillRule ? this.fillRule : "nonzero", i = this.strokeWidth ? this.strokeWidth : "0", s = this.strokeDashArray ? this.strokeDashArray.join(" ") : Ui, o = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", l = this.strokeLineJoin ? this.strokeLineJoin : "miter", c = this.strokeMiterLimit ? this.strokeMiterLimit : "4", u = this.opacity !== void 0 ? this.opacity : "1", h = this.visible ? "" : " visibility: hidden;", d = e ? "" : this.getSvgFilter(), p = nu(Hn, this.fill);
    return [nu(zi, this.stroke), "stroke-width: ", i, "; ", "stroke-dasharray: ", s, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", o, "; ", "stroke-linejoin: ", l, "; ", "stroke-miterlimit: ", c, "; ", p, "fill-rule: ", n, "; ", "opacity: ", u, ";", d, h].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const i = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), s = 'transform="'.concat(tu(i));
    return "".concat(s).concat(n, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: n, additionalTransform: i = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = [this.getSvgTransform(!0, i), this.getSvgCommons()].join(""), o = e.indexOf("COMMON_PARTS");
    return e[o] = s, n ? n(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: n, reviver: i, withShadow: s, additionalTransform: o } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = n ? "" : 'style="'.concat(this.getSvgStyles(), '" '), l = s ? 'style="'.concat(this.getSvgFilter(), '" ') : "", c = this.clipPath, u = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", h = c && c.absolutePositioned, d = this.stroke, p = this.fill, f = this.shadow, m = [], _ = e.indexOf("COMMON_PARTS");
    let g;
    c && (c.clipPathId = "CLIPPATH_".concat(co()), g = '<clipPath id="'.concat(c.clipPathId, `" >
`).concat(c.toClipPathSVG(i), `</clipPath>
`)), h && m.push("<g ", l, this.getSvgCommons(), ` >
`), m.push("<g ", this.getSvgTransform(!1), h ? "" : l + this.getSvgCommons(), ` >
`);
    const v = [a, u, n ? "" : this.addPaintOrder(), " ", o ? 'transform="'.concat(o, '" ') : ""].join("");
    return e[_] = v, es(p) && m.push(p.toSVG(this)), es(d) && m.push(d.toSVG(this)), f && m.push(f.toSVG(this)), c && m.push(g), m.push(e.join("")), m.push(`</g>
`), h && m.push(`</g>
`), i ? i(m.join("")) : m.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Hn ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function yf(r) {
  return new RegExp("^(" + r.join("|") + ")\\b", "i");
}
const ia = "textDecorationThickness", Sw = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], Mw = ["underline", "overline", "linethrough"], Cw = [...Sw, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], Tw = [...Cw, ...Mw, "textBackgroundColor", "direction", ia], WG = [...Sw, ...Mw, zi, "strokeWidth", Hn, "deltaY", "textBackgroundColor", ia], jG = { _reNewline: gv, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: Qt, fontStyle: "normal", lineHeight: 1.16, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: Qt, pathAlign: "baseline", charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.28167, overline: -0.81333 }, _fontSizeMult: 1.13, [ia]: 66.667 }, Bs = "justify", Id = "justify-left", Pc = "justify-right", Dc = "justify-center";
var x1, b1, w1;
const ws = String.raw(x1 || (x1 = Ys(["[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"], ["[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"]))), Ip = String.raw(b1 || (b1 = Ys(["(?:s*,?s+|s*,s*)"], ["(?:\\s*,?\\s+|\\s*,\\s*)"]))), $G = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + ws + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + ws + "))?\\s+(.*)"), XG = { cx: Qt, x: Qt, r: "radius", cy: Fi, y: Fi, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing", "text-decoration-thickness": ia }, Op = "font-size", Fp = "clip-path";
yf(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
yf(["symbol", "image", "marker", "pattern", "view", "svg"]);
const S1 = yf(["symbol", "g", "a", "svg", "clipPath", "defs"]);
new RegExp(String.raw(w1 || (w1 = Ys(["^s*(", ")", "(", ")", "(", ")", "(", ")s*$"], ["^\\s*(", ")", "(", ")", "(", ")", "(", ")\\s*$"])), ws, Ip, ws, Ip, ws, Ip, ws));
const YG = new He(1, 0), Ew = new He(), Aw = (r, e) => r.rotate(e), ag = (r, e) => new He(e).subtract(r), lg = (r) => r.distanceFrom(Ew), cg = (r, e) => Math.atan2(kc(r, e), ZG(r, e)), qG = (r) => cg(YG, r), Mv = (r) => r.eq(Ew) ? r : r.scalarDivide(lg(r)), Pw = function(r) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return Mv(new He(-r.y, r.x).scalarMultiply(e ? 1 : -1));
}, kc = (r, e) => r.x * e.y - r.y * e.x, ZG = (r, e) => r.x * e.x + r.y * e.y, M1 = (r, e, n) => {
  if (r.eq(e) || r.eq(n)) return !0;
  const i = kc(e, n), s = kc(e, r), o = kc(n, r);
  return i >= 0 ? s >= 0 && o <= 0 : !(s <= 0 && o >= 0);
}, C1 = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", T1 = new RegExp("(?:\\s|^)" + C1 + C1 + "(" + ws + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class wr {
  constructor(e) {
    const n = typeof e == "string" ? wr.parseShadow(e) : e;
    Object.assign(this, wr.ownDefaults, n), this.id = co();
  }
  static parseShadow(e) {
    const n = e.trim(), [, i = 0, s = 0, o = 0] = (T1.exec(n) || []).map((a) => parseFloat(a) || 0);
    return { color: (n.replace(T1, "") || "rgb(0,0,0)").trim(), offsetX: i, offsetY: s, blur: o };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const n = Aw(new He(this.offsetX, this.offsetY), On(-e.angle)), i = new sn(this.color);
    let s = 40, o = 40;
    return e.width && e.height && (s = 100 * hn((Math.abs(n.x) + this.blur) / e.width, Gt.NUM_FRACTION_DIGITS) + 20, o = 100 * hn((Math.abs(n.y) + this.blur) / e.height, Gt.NUM_FRACTION_DIGITS) + 20), e.flipX && (n.x *= -1), e.flipY && (n.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(o, '%" height="').concat(100 + 2 * o, '%" x="-').concat(s, '%" width="').concat(100 + 2 * s, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(hn(this.blur ? this.blur / 2 : 0, Gt.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(hn(n.x, Gt.NUM_FRACTION_DIGITS), '" dy="').concat(hn(n.y, Gt.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(i.toRgb(), '" flood-opacity="').concat(i.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, n = wr.ownDefaults;
    return this.includeDefaultValues ? e : bv(e, (i, s) => i !== n[s]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
Re(wr, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), Re(wr, "type", "shadow"), ht.setClass(wr, "shadow");
const ml = (r, e, n) => Math.max(r, Math.min(e, n)), KG = [Fi, Qt, Bi, ss, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", Sl, Ml], Rr = [Hn, zi, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], JG = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: Qt, originY: Fi, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Hn, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, QG = (r, e, n, i) => -n * Math.cos(r / i * fu) + n + e, eH = () => !1;
class Cv {
  constructor(e) {
    let { startValue: n, byValue: i, duration: s = 500, delay: o = 0, easing: a = QG, onStart: l = Jh, onChange: c = Jh, onComplete: u = Jh, abort: h = eH, target: d } = e;
    Re(this, "_state", "pending"), Re(this, "durationProgress", 0), Re(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = s, this.delay = o, this.easing = a, this._onStart = l, this._onChange = c, this._onComplete = u, this._abort = h, this.target = d, this.startValue = n, this.byValue = i, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (n) => {
      this._state === "pending" && (this.startTime = n || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => ed(e), this.delay) : ed(e);
  }
  tick(e) {
    const n = (e || +/* @__PURE__ */ new Date()) - this.startTime, i = Math.min(n, this.duration);
    this.durationProgress = i / this.duration;
    const { value: s, valueProgress: o } = this.calculate(i);
    this.value = Object.freeze(s), this.valueProgress = o, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : n >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), ed(this.tick)));
  }
  register() {
    Pd.push(this);
  }
  unregister() {
    Pd.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const tH = ["startValue", "endValue"];
class nH extends Cv {
  constructor(e) {
    let { startValue: n = 0, endValue: i = 100 } = e;
    super(Ie(Ie({}, pn(e, tH)), {}, { startValue: n, byValue: i - n }));
  }
  calculate(e) {
    const n = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: n, valueProgress: Math.abs((n - this.startValue) / this.byValue) };
  }
}
const iH = ["startValue", "endValue"];
class sH extends Cv {
  constructor(e) {
    let { startValue: n = [0], endValue: i = [100] } = e;
    super(Ie(Ie({}, pn(e, iH)), {}, { startValue: n, byValue: i.map((s, o) => s - n[o]) }));
  }
  calculate(e) {
    const n = this.startValue.map((i, s) => this.easing(e, i, this.byValue[s], this.duration, s));
    return { value: n, valueProgress: Math.abs((n[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const rH = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], oH = (r, e, n, i) => e + n * (1 - Math.cos(r / i * fu)), Up = (r) => r && ((e, n, i) => r(new sn(e).toRgba(), n, i));
class aH extends Cv {
  constructor(e) {
    let { startValue: n, endValue: i, easing: s = oH, onChange: o, onComplete: a, abort: l } = e, c = pn(e, rH);
    const u = new sn(n).getSource(), h = new sn(i).getSource();
    super(Ie(Ie({}, c), {}, { startValue: u, byValue: h.map((d, p) => d - u[p]), easing: s, onChange: Up(o), onComplete: Up(a), abort: Up(l) }));
  }
  calculate(e) {
    const [n, i, s, o] = this.startValue.map((l, c) => this.easing(e, l, this.byValue[c], this.duration, c)), a = [...[n, i, s].map(Math.round), ml(0, o, 1)];
    return { value: a, valueProgress: a.map((l, c) => this.byValue[c] !== 0 ? Math.abs((l - this.startValue[c]) / this.byValue[c]) : 0).find((l) => l !== 0) || 0 };
  }
}
function Dw(r) {
  const e = ((n) => Array.isArray(n.startValue) || Array.isArray(n.endValue))(r) ? new sH(r) : new nH(r);
  return e.start(), e;
}
function lH(r) {
  const e = new aH(r);
  return e.start(), e;
}
class xn {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((n) => n.eq(e));
  }
  append() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    return this.points = this.points.concat(n.filter((s) => !this.includes(s))), this;
  }
  static isPointContained(e, n, i) {
    let s = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (n.eq(i)) return e.eq(n);
    if (n.x === i.x) return e.x === n.x && (s || e.y >= Math.min(n.y, i.y) && e.y <= Math.max(n.y, i.y));
    if (n.y === i.y) return e.y === n.y && (s || e.x >= Math.min(n.x, i.x) && e.x <= Math.max(n.x, i.x));
    {
      const o = ag(n, i), a = ag(n, e).divide(o);
      return s ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, n) {
    const i = new He(e).setX(Math.min(e.x - 1, ...n.map((o) => o.x)));
    let s = 0;
    for (let o = 0; o < n.length; o++) {
      const a = this.intersectSegmentSegment(n[o], n[(o + 1) % n.length], e, i);
      if (a.includes(e)) return !0;
      s += +(a.status === "Intersection");
    }
    return s % 2 == 1;
  }
  static intersectLineLine(e, n, i, s) {
    let o = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const l = n.x - e.x, c = n.y - e.y, u = s.x - i.x, h = s.y - i.y, d = e.x - i.x, p = e.y - i.y, f = u * p - h * d, m = l * p - c * d, _ = h * l - u * c;
    if (_ !== 0) {
      const g = f / _, v = m / _;
      return (o || 0 <= g && g <= 1) && (a || 0 <= v && v <= 1) ? new xn("Intersection").append(new He(e.x + g * l, e.y + g * c)) : new xn();
    }
    if (f === 0 || m === 0) {
      const g = o || a || xn.isPointContained(e, i, s) || xn.isPointContained(n, i, s) || xn.isPointContained(i, e, n) || xn.isPointContained(s, e, n);
      return new xn(g ? "Coincident" : void 0);
    }
    return new xn("Parallel");
  }
  static intersectSegmentLine(e, n, i, s) {
    return xn.intersectLineLine(e, n, i, s, !1, !0);
  }
  static intersectSegmentSegment(e, n, i, s) {
    return xn.intersectLineLine(e, n, i, s, !1, !1);
  }
  static intersectLinePolygon(e, n, i) {
    let s = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const o = new xn(), a = i.length;
    for (let l, c, u, h = 0; h < a; h++) {
      if (l = i[h], c = i[(h + 1) % a], u = xn.intersectLineLine(e, n, l, c, s, !1), u.status === "Coincident") return u;
      o.append(...u.points);
    }
    return o.points.length > 0 && (o.status = "Intersection"), o;
  }
  static intersectSegmentPolygon(e, n, i) {
    return xn.intersectLinePolygon(e, n, i, !1);
  }
  static intersectPolygonPolygon(e, n) {
    const i = new xn(), s = e.length, o = [];
    for (let a = 0; a < s; a++) {
      const l = e[a], c = e[(a + 1) % s], u = xn.intersectSegmentPolygon(l, c, n);
      u.status === "Coincident" ? (o.push(u), i.append(l, c)) : i.append(...u.points);
    }
    return o.length > 0 && o.length === e.length ? new xn("Coincident") : (i.points.length > 0 && (i.status = "Intersection"), i);
  }
  static intersectPolygonRectangle(e, n, i) {
    const s = n.min(i), o = n.max(i), a = new He(o.x, s.y), l = new He(s.x, o.y);
    return xn.intersectPolygonPolygon(e, [s, a, o, l]);
  }
}
class cH extends ow {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? ki(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, n, i) {
    this.group && (e = ki(e, bs(this.group.calcTransformMatrix()))), this.setRelativeXY(e, n, i);
  }
  getRelativeXY() {
    return new He(this.left, this.top);
  }
  setRelativeXY(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, n, i);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: n, br: i, bl: s } = this.aCoords || (this.aCoords = this.calcACoords()), o = [e, n, i, s];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return o.map((l) => ki(l, a));
    }
    return o;
  }
  intersectsWithRect(e, n) {
    return xn.intersectPolygonRectangle(this.getCoords(), e, n).status === "Intersection";
  }
  intersectsWithObject(e) {
    const n = xn.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return n.status === "Intersection" || n.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((n) => e.containsPoint(n));
  }
  isContainedWithinRect(e, n) {
    const { left: i, top: s, width: o, height: a } = this.getBoundingRect();
    return i >= e.x && i + o <= n.x && s >= e.y && s + a <= n.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return xn.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return !!this.getCoords().some((i) => i.x <= n.x && i.x >= e.x && i.y <= n.y && i.y >= e.y) || !!this.intersectsWithRect(e, n) || this.containsPoint(e.midPointFrom(n));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, n) ? !0 : this.getCoords().every((i) => (i.x >= n.x || i.x <= e.x) && (i.y >= n.y || i.y <= e.y)) && this.containsPoint(e.midPointFrom(n));
  }
  getBoundingRect() {
    return br(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(Bi, e), this._set(ss, e), this.setCoords();
  }
  scaleToWidth(e) {
    const n = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / n);
  }
  scaleToHeight(e) {
    const n = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / n);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? Dr(cw(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || Si.concat();
  }
  calcACoords() {
    const e = Cl({ angle: this.angle }), { x: n, y: i } = this.getRelativeCenterPoint(), s = pu(n, i), o = ni(s, e), a = this._getTransformedDimensions(), l = a.x / 2, c = a.y / 2;
    return { tl: ki({ x: -l, y: -c }, o), tr: ki({ x: l, y: -c }, o), bl: ki({ x: -l, y: c }, o), br: ki({ x: l, y: c }, o) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = [];
    return !e && this.group && (n = this.group.transformMatrixKey(e)), n.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, Vn(this.originX), Vn(this.originY)), n;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = this.calcOwnMatrix();
    if (e || !this.group) return n;
    const i = this.transformMatrixKey(e), s = this.matrixCache;
    return s && s.key.every((o, a) => o === i[a]) ? s.value : (this.group && (n = ni(this.group.calcTransformMatrix(!1), n)), this.matrixCache = { key: i, value: n }, n);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), n = this.ownMatrixCache;
    if (n && n.key === e) return n.value;
    const i = this.getRelativeCenterPoint(), s = { angle: this.angle, translateX: i.x, translateY: i.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, o = kG(s);
    return this.ownMatrixCache = { key: e, value: o }, o;
  }
  _getNonTransformedDimensions() {
    return new He(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = Ie({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), i = n.strokeWidth;
    let s = i, o = 0;
    this.strokeUniform && (s = 0, o = i);
    const a = n.width + s, l = n.height + s;
    let c;
    return c = n.skewX === 0 && n.skewY === 0 ? new He(a * n.scaleX, l * n.scaleY) : wv(a, l, mf(n)), c.scalarAdd(o);
  }
  translateToGivenOrigin(e, n, i, s, o) {
    let a = e.x, l = e.y;
    const c = Vn(s) - Vn(n), u = Vn(o) - Vn(i);
    if (c || u) {
      const h = this._getTransformedDimensions();
      a += c * h.x, l += u * h.y;
    }
    return new He(a, l);
  }
  translateToCenterPoint(e, n, i) {
    if (n === It && i === It) return e;
    const s = this.translateToGivenOrigin(e, n, i, It, It);
    return this.angle ? s.rotate(On(this.angle), e) : s;
  }
  translateToOriginPoint(e, n, i) {
    const s = this.translateToGivenOrigin(e, It, It, n, i);
    return this.angle ? s.rotate(On(this.angle), e) : s;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? ki(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new He(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, n) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, n);
  }
  setPositionByOrigin(e, n, i) {
    const s = this.translateToCenterPoint(e, n, i), o = this.translateToOriginPoint(s, this.originX, this.originY);
    this.set({ left: o.x, top: o.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), Qt, Fi);
  }
}
const uH = ["type"], hH = ["extraParam"];
let ar = class nd extends cH {
  static getDefaults() {
    return nd.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    lo("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), Re(this, "_cacheContext", null), Object.assign(this, nd.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = Pr(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const n = e.width, i = e.height, s = Gt.maxCacheSideLimit, o = Gt.minCacheSideLimit;
    if (n <= s && i <= s && n * i <= Gt.perfLimitSizeTotal) return n < o && (e.width = o), i < o && (e.height = o), e;
    const a = n / i, [l, c] = Ac.limitDimsByArea(a), u = ml(o, l, s), h = ml(o, c, s);
    return n > u && (e.zoomX /= n / u, e.width = u, e.capped = !0), i > h && (e.zoomY /= i / h, e.height = h, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), n = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), i = n.x * e.x / this.scaleX, s = n.y * e.y / this.scaleY;
    return { width: Math.ceil(i + 2), height: Math.ceil(s + 2), zoomX: e.x, zoomY: e.y, x: i, y: s };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, n = this._cacheContext, { width: i, height: s, zoomX: o, zoomY: a, x: l, y: c } = this._limitCacheSize(this._getCacheCanvasDimensions()), u = i !== e.width || s !== e.height, h = this.zoomX !== o || this.zoomY !== a;
    if (!e || !n) return !1;
    if (u || h) {
      i !== e.width || s !== e.height ? (e.width = i, e.height = s) : (n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, e.width, e.height));
      const d = l / 2, p = c / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - d) + d, this.cacheTranslationY = Math.round(e.height / 2 - p) + p, n.translate(this.cacheTranslationX, this.cacheTranslationY), n.scale(o, a), this.zoomX = o, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const n = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, i = this.calcTransformMatrix(!n);
    e.transform(i[0], i[1], i[2], i[3], i[4], i[5]);
  }
  getObjectScaling() {
    if (!this.group) return new He(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = Dd(this.calcTransformMatrix());
    return new He(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const n = this.canvas.getZoom(), i = this.getCanvasRetinaScaling();
      return e.scalarMultiply(n * i);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, n) {
    e !== Bi && e !== ss || (n = this._constrainScale(n)), e === Bi && n < 0 ? (this.flipX = !this.flipX, n *= -1) : e === "scaleY" && n < 0 ? (this.flipY = !this.flipY, n *= -1) : e !== "shadow" || !n || n instanceof wr || (n = new wr(n));
    const i = this[e] !== n;
    return this[e] = n, i && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || i && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: n, zoomY: i, cacheTranslationX: s, cacheTranslationY: o } = this, { width: a, height: l } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: n, zoomY: i, cacheTranslationX: s, cacheTranslationY: o, width: a, height: l, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === zi && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, n, i) {
    e.save(), n.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(i, 0, 0), e.restore();
  }
  drawObject(e, n, i) {
    const s = this.fill, o = this.stroke;
    n ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, i), this.fill = s, this.stroke = o;
  }
  createClipPathLayer(e, n) {
    const i = rs(n), s = i.getContext("2d");
    if (s.translate(n.cacheTranslationX, n.cacheTranslationY), s.scale(n.zoomX, n.zoomY), e._cacheCanvas = i, n.parentClipPaths.forEach((o) => {
      o.transform(s);
    }), n.parentClipPaths.push(e), e.absolutePositioned) {
      const o = bs(this.calcTransformMatrix());
      s.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
    }
    return e.transform(s), e.drawObject(s, !0, n), i;
  }
  _drawClipPath(e, n, i) {
    if (!n) return;
    n._transformDone = !0;
    const s = this.createClipPathLayer(n, i);
    this.drawClipPathOnCache(e, n, s);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const n = this._cacheCanvas, i = this._cacheContext;
    return !(!n || !i || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (n && i && !e && (i.save(), i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(0, 0, n.width, n.height), i.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const n = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, n) {
    const i = n.stroke;
    i && (e.lineWidth = n.strokeWidth, e.lineCap = n.strokeLineCap, e.lineDashOffset = n.strokeDashOffset, e.lineJoin = n.strokeLineJoin, e.miterLimit = n.strokeMiterLimit, es(i) ? i.gradientUnits === "percentage" || i.gradientTransform || i.patternTransform ? this._applyPatternForTransformedGradient(e, i) : (e.strokeStyle = i.toLive(e), this._applyPatternGradientTransform(e, i)) : e.strokeStyle = n.stroke);
  }
  _setFillStyles(e, n) {
    let { fill: i } = n;
    i && (es(i) ? (e.fillStyle = i.toLive(e), this._applyPatternGradientTransform(e, i)) : e.fillStyle = i);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, n) {
    n && n.length !== 0 && e.setLineDash(n);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const n = this.shadow, i = this.canvas, s = this.getCanvasRetinaScaling(), [o, , , a] = (i == null ? void 0 : i.viewportTransform) || Si, l = o * s, c = a * s, u = n.nonScaling ? new He(1, 1) : this.getObjectScaling();
    e.shadowColor = n.color, e.shadowBlur = n.blur * Gt.browserShadowBlurConstant * (l + c) * (u.x + u.y) / 4, e.shadowOffsetX = n.offsetX * l * u.x, e.shadowOffsetY = n.offsetY * c * u.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, n) {
    if (!es(n)) return { offsetX: 0, offsetY: 0 };
    const i = n.gradientTransform || n.patternTransform, s = -this.width / 2 + n.offsetX || 0, o = -this.height / 2 + n.offsetY || 0;
    return n.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, s, o) : e.transform(1, 0, 0, 1, s, o), i && e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), { offsetX: s, offsetY: o };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === zi ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const n = this.getObjectScaling();
        e.scale(1 / n.x, 1 / n.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, n) {
    var i;
    const s = this._limitCacheSize(this._getCacheCanvasDimensions()), o = this.getCanvasRetinaScaling(), a = s.x / this.scaleX / o, l = s.y / this.scaleY / o, c = rs({ width: Math.ceil(a), height: Math.ceil(l) }), u = c.getContext("2d");
    u && (u.beginPath(), u.moveTo(0, 0), u.lineTo(a, 0), u.lineTo(a, l), u.lineTo(0, l), u.closePath(), u.translate(a / 2, l / 2), u.scale(s.zoomX / this.scaleX / o, s.zoomY / this.scaleY / o), this._applyPatternGradientTransform(u, n), u.fillStyle = n.toLive(e), u.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(o * this.scaleX / s.zoomX, o * this.scaleY / s.zoomY), e.strokeStyle = (i = u.createPattern(c, "no-repeat")) !== null && i !== void 0 ? i : "");
  }
  _findCenterFromElement() {
    return new He(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const n = this.toObject(e);
    return this.constructor.fromObject(n);
  }
  cloneAsImage(e) {
    const n = this.toCanvasElement(e);
    return new (ht.getClass("image"))(n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = vw(this), i = this.group, s = this.shadow, o = Math.abs, a = e.enableRetinaScaling ? tw() : 1, l = (e.multiplier || 1) * a, c = e.canvasProvider || ((S) => new mu(S, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && zG(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && NG(this, this.getViewportTransform()), this.setCoords();
    const u = Pr(), h = this.getBoundingRect(), d = this.shadow, p = new He();
    if (d) {
      const S = d.blur, b = d.nonScaling ? new He(1, 1) : this.getObjectScaling();
      p.x = 2 * Math.round(o(d.offsetX) + S) * o(b.x), p.y = 2 * Math.round(o(d.offsetY) + S) * o(b.y);
    }
    const f = h.width + p.x, m = h.height + p.y;
    u.width = Math.ceil(f), u.height = Math.ceil(m);
    const _ = c(u);
    e.format === "jpeg" && (_.backgroundColor = "#fff"), this.setPositionByOrigin(new He(_.width / 2, _.height / 2), It, It);
    const g = this.canvas;
    _._objects = [this], this.set("canvas", _), this.setCoords();
    const v = _.toCanvasElement(l || 1, e);
    return this.set("canvas", g), this.shadow = s, i && (this.group = i), this.set(n), this.setCoords(), _._objects = [], _.destroy(), v;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return aw(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return lw(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    return n.includes(this.constructor.type) || n.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: n, originX: i, originY: s } = this;
    if (n) {
      const { x: o, y: a } = this.getRelativeCenterPoint();
      this.originX = It, this.originY = It, this.left = o, this.top = a;
    }
    if (this.set("angle", e), n) {
      const { x: o, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), i, s);
      this.left = o, this.top = a, this.originX = i, this.originY = s;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    Pd.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && $s().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, n) {
    return Object.entries(e).reduce((i, s) => {
      let [o, a] = s;
      return i[o] = this._animate(o, a, n), i;
    }, {});
  }
  _animate(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = e.split("."), o = this.constructor.colorProperties.includes(s[s.length - 1]), { abort: a, startValue: l, onChange: c, onComplete: u } = i, h = Ie(Ie({}, i), {}, { target: this, startValue: l ?? s.reduce((d, p) => d[p], this), endValue: n, abort: a == null ? void 0 : a.bind(this), onChange: (d, p, f) => {
      s.reduce((m, _, g) => (g === s.length - 1 && (m[_] = d), m[_]), this), c && c(d, p, f);
    }, onComplete: (d, p, f) => {
      this.setCoords(), u && u(d, p, f);
    } });
    return o ? lH(h) : Dw(h);
  }
  isDescendantOf(e) {
    const { parent: n, group: i } = this;
    return n === e || i === e || !!n && n.isDescendantOf(e) || !!i && i !== n && i.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let n = this;
    do
      n = n.parent, n && e.push(n);
    while (n);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const n = this.getAncestors(), i = e.getAncestors();
    if (n.length === 0 && i.length > 0 && this === i[i.length - 1]) return { fork: [], otherFork: [e, ...i.slice(0, i.length - 1)], common: [this] };
    for (let s, o = 0; o < n.length; o++) {
      if (s = n[o], s === e) return { fork: [this, ...n.slice(0, o)], otherFork: [], common: n.slice(o) };
      for (let a = 0; a < i.length; a++) {
        if (this === i[a]) return { fork: [], otherFork: [e, ...i.slice(0, a)], common: [this, ...n] };
        if (s === i[a]) return { fork: [this, ...n.slice(0, o)], otherFork: [e, ...i.slice(0, a)], common: n.slice(o) };
      }
    }
    return { fork: [this, ...n], otherFork: [e, ...i], common: [] };
  }
  hasCommonAncestors(e) {
    const n = this.findCommonAncestors(e);
    return n && !!n.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const n = this.findCommonAncestors(e);
    if (n.fork.includes(e)) return !0;
    if (n.otherFork.includes(this)) return !1;
    const i = n.common[0] || this.canvas;
    if (!i) return;
    const s = n.fork.pop(), o = n.otherFork.pop(), a = i._objects.indexOf(s), l = i._objects.indexOf(o);
    return a > -1 && a > l;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(nd.customProperties, this.constructor.customProperties || []);
    let n;
    const i = Gt.NUM_FRACTION_DIGITS, { clipPath: s, fill: o, stroke: a, shadow: l, strokeDashArray: c, left: u, top: h, originX: d, originY: p, width: f, height: m, strokeWidth: _, strokeLineCap: g, strokeDashOffset: v, strokeLineJoin: S, strokeUniform: b, strokeMiterLimit: x, scaleX: M, scaleY: C, angle: E, flipX: T, flipY: w, opacity: A, visible: O, backgroundColor: U, fillRule: D, paintFirst: L, globalCompositeOperation: P, skewX: V, skewY: ce } = this;
    s && !s.excludeFromExport && (n = s.toObject(e.concat("inverted", "absolutePositioned")));
    const q = (ne) => hn(ne, i), oe = Ie(Ie({}, Tl(this, e)), {}, { type: this.constructor.type, version: ig, originX: d, originY: p, left: q(u), top: q(h), width: q(f), height: q(m), fill: h1(o) ? o.toObject() : o, stroke: h1(a) ? a.toObject() : a, strokeWidth: q(_), strokeDashArray: c && c.concat(), strokeLineCap: g, strokeDashOffset: v, strokeLineJoin: S, strokeUniform: b, strokeMiterLimit: q(x), scaleX: q(M), scaleY: q(C), angle: q(E), flipX: T, flipY: w, opacity: q(A), shadow: l && l.toObject(), visible: O, backgroundColor: U, fillRule: D, paintFirst: L, globalCompositeOperation: P, skewX: q(V), skewY: q(ce) }, n ? { clipPath: n } : null);
    return this.includeDefaultValues ? oe : this._removeDefaultValues(oe);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const n = this.constructor.getDefaults(), i = Object.keys(n).length > 0 ? n : Object.getPrototypeOf(this);
    return bv(e, (s, o) => {
      if (o === Qt || o === Fi || o === "type") return !0;
      const a = i[o];
      return s !== a && !(Array.isArray(s) && Array.isArray(a) && s.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let n = pn(e, uH), i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: s } = i, o = pn(i, hH);
    return gf(n, o).then((a) => s ? (delete a[s], new this(n[s], a)) : new this(a));
  }
  static fromObject(e, n) {
    return this._fromObject(e, n);
  }
};
Re(ar, "stateProperties", KG), Re(ar, "cacheProperties", Rr), Re(ar, "ownDefaults", JG), Re(ar, "type", "FabricObject"), Re(ar, "colorProperties", [Hn, zi, "backgroundColor"]), Re(ar, "customProperties", []), ht.setClass(ar), ht.setClass(ar, "object");
const El = (r, e, n) => (i, s, o, a) => {
  const l = e(i, s, o, a);
  return l && yw(r, Ie(Ie({}, xw(i, s, o, a)), n)), l;
};
function Al(r) {
  return (e, n, i, s) => {
    const { target: o, originX: a, originY: l } = n, c = o.getRelativeCenterPoint(), u = o.translateToOriginPoint(c, a, l), h = r(e, n, i, s);
    return o.setPositionByOrigin(u, n.originX, n.originY), h;
  };
}
const E1 = El(Qc, Al((r, e, n, i) => {
  const s = Sv(e, e.originX, e.originY, n, i);
  if (Vn(e.originX) === Vn(It) || Vn(e.originX) === Vn(In) && s.x < 0 || Vn(e.originX) === Vn(Qt) && s.x > 0) {
    const { target: o } = e, a = o.strokeWidth / (o.strokeUniform ? o.scaleX : 1), l = _w(e) ? 2 : 1, c = o.width, u = Math.abs(s.x * l / o.scaleX) - a;
    return o.set("width", Math.max(u, 1)), c !== o.width;
  }
  return !1;
}));
function dH(r, e, n, i, s) {
  i = i || {};
  const o = this.sizeX || i.cornerSize || s.cornerSize, a = this.sizeY || i.cornerSize || s.cornerSize, l = i.transparentCorners !== void 0 ? i.transparentCorners : s.transparentCorners, c = l ? zi : Hn, u = !l && (i.cornerStrokeColor || s.cornerStrokeColor);
  let h, d = e, p = n;
  r.save(), r.fillStyle = i.cornerColor || s.cornerColor || "", r.strokeStyle = i.cornerStrokeColor || s.cornerStrokeColor || "", o > a ? (h = o, r.scale(1, a / o), p = n * o / a) : a > o ? (h = a, r.scale(o / a, 1), d = e * a / o) : h = o, r.beginPath(), r.arc(d, p, h / 2, 0, Td, !1), r[c](), u && r.stroke(), r.restore();
}
function fH(r, e, n, i, s) {
  i = i || {};
  const o = this.sizeX || i.cornerSize || s.cornerSize, a = this.sizeY || i.cornerSize || s.cornerSize, l = i.transparentCorners !== void 0 ? i.transparentCorners : s.transparentCorners, c = l ? zi : Hn, u = !l && (i.cornerStrokeColor || s.cornerStrokeColor), h = o / 2, d = a / 2;
  r.save(), r.fillStyle = i.cornerColor || s.cornerColor || "", r.strokeStyle = i.cornerStrokeColor || s.cornerStrokeColor || "", r.translate(e, n);
  const p = s.getTotalAngle();
  r.rotate(On(p)), r["".concat(c, "Rect")](-h, -d, o, a), u && r.strokeRect(-h, -d, o, a), r.restore();
}
class ps {
  constructor(e) {
    Re(this, "visible", !0), Re(this, "actionName", pf), Re(this, "angle", 0), Re(this, "x", 0), Re(this, "y", 0), Re(this, "offsetX", 0), Re(this, "offsetY", 0), Re(this, "sizeX", 0), Re(this, "sizeY", 0), Re(this, "touchSizeX", 0), Re(this, "touchSizeY", 0), Re(this, "cursorStyle", "crosshair"), Re(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, n, i, s) {
    var o;
    let { tl: a, tr: l, br: c, bl: u } = s;
    return ((o = n.canvas) === null || o === void 0 ? void 0 : o.getActiveObject()) === n && n.isControlVisible(e) && xn.isPointInPolygon(i, [a, l, c, u]);
  }
  getActionHandler(e, n, i) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, n, i) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, n, i) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, n, i) {
    return n.cursorStyle;
  }
  getActionName(e, n, i) {
    return n.actionName;
  }
  getVisibility(e, n) {
    var i, s;
    return (i = (s = e._controlsVisibility) === null || s === void 0 ? void 0 : s[n]) !== null && i !== void 0 ? i : this.visible;
  }
  setVisibility(e, n, i) {
    this.visible = e;
  }
  positionHandler(e, n, i, s) {
    return new He(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(n);
  }
  calcCornerCoords(e, n, i, s, o, a) {
    const l = _v([pu(i, s), Cl({ angle: e }), xv((o ? this.touchSizeX : this.sizeX) || n, (o ? this.touchSizeY : this.sizeY) || n)]);
    return { tl: new He(-0.5, -0.5).transform(l), tr: new He(0.5, -0.5).transform(l), br: new He(0.5, 0.5).transform(l), bl: new He(-0.5, 0.5).transform(l) };
  }
  render(e, n, i, s, o) {
    ((s = s || {}).cornerStyle || o.cornerStyle) === "circle" ? dH.call(this, e, n, i, s, o) : fH.call(this, e, n, i, s, o);
  }
}
const pH = (r, e, n) => n.lockRotation ? Rd : e.cursorStyle, mH = El(iw, Al((r, e, n, i) => {
  let { target: s, ex: o, ey: a, theta: l, originX: c, originY: u } = e;
  const h = s.translateToOriginPoint(s.getRelativeCenterPoint(), c, u);
  if (Ms(s, "lockRotation")) return !1;
  const d = Math.atan2(a - h.y, o - h.x), p = Math.atan2(i - h.y, n - h.x);
  let f = Dr(p - d + l);
  if (s.snapAngle && s.snapAngle > 0) {
    const _ = s.snapAngle, g = s.snapThreshold || _, v = Math.ceil(f / _) * _, S = Math.floor(f / _) * _;
    Math.abs(f - S) < g ? f = S : Math.abs(f - v) < g && (f = v);
  }
  f < 0 && (f = 360 + f), f %= 360;
  const m = s.angle !== f;
  return s.angle = f, m;
}));
function kw(r, e) {
  const n = e.canvas, i = r[n.uniScaleKey];
  return n.uniformScaling && !i || !n.uniformScaling && i;
}
function Rw(r, e, n) {
  const i = Ms(r, "lockScalingX"), s = Ms(r, "lockScalingY");
  if (i && s || !e && (i || s) && n || i && e === "x" || s && e === "y") return !0;
  const { width: o, height: a, strokeWidth: l } = r;
  return o === 0 && l === 0 && e !== "y" || a === 0 && l === 0 && e !== "x";
}
const gH = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], cc = (r, e, n) => {
  const i = kw(r, n);
  if (Rw(n, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", i)) return Rd;
  const s = bw(n, e);
  return "".concat(gH[s], "-resize");
};
function Tv(r, e, n, i) {
  let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const o = e.target, a = s.by, l = kw(r, o);
  let c, u, h, d, p, f;
  if (Rw(o, a, l)) return !1;
  if (e.gestureScale) u = e.scaleX * e.gestureScale, h = e.scaleY * e.gestureScale;
  else {
    if (c = Sv(e, e.originX, e.originY, n, i), p = a !== "y" ? Math.sign(c.x || e.signX || 1) : 1, f = a !== "x" ? Math.sign(c.y || e.signY || 1) : 1, e.signX || (e.signX = p), e.signY || (e.signY = f), Ms(o, "lockScalingFlip") && (e.signX !== p || e.signY !== f)) return !1;
    if (d = o._getTransformedDimensions(), l && !a) {
      const g = Math.abs(c.x) + Math.abs(c.y), { original: v } = e, S = g / (Math.abs(d.x * v.scaleX / o.scaleX) + Math.abs(d.y * v.scaleY / o.scaleY));
      u = v.scaleX * S, h = v.scaleY * S;
    } else u = Math.abs(c.x * o.scaleX / d.x), h = Math.abs(c.y * o.scaleY / d.y);
    _w(e) && (u *= 2, h *= 2), e.signX !== p && a !== "y" && (e.originX = m1(e.originX), u *= -1, e.signX = p), e.signY !== f && a !== "x" && (e.originY = m1(e.originY), h *= -1, e.signY = f);
  }
  const m = o.scaleX, _ = o.scaleY;
  return a ? (a === "x" && o.set(Bi, u), a === "y" && o.set(ss, h)) : (!Ms(o, "lockScalingX") && o.set(Bi, u), !Ms(o, "lockScalingY") && o.set(ss, h)), m !== o.scaleX || _ !== o.scaleY;
}
const ah = El(ff, Al((r, e, n, i) => Tv(r, e, n, i))), vH = El(ff, Al((r, e, n, i) => Tv(r, e, n, i, { by: "x" }))), yH = El(ff, Al((r, e, n, i) => Tv(r, e, n, i, { by: "y" }))), _H = ["target", "ex", "ey", "skewingSide"], zp = { x: { counterAxis: "y", scale: Bi, skew: Sl, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: ss, skew: Ml, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, xH = ["ns", "nesw", "ew", "nwse"], bH = (r, e, n) => {
  if (e.x !== 0 && Ms(n, "lockSkewingY") || e.y !== 0 && Ms(n, "lockSkewingX")) return Rd;
  const i = bw(n, e) % 4;
  return "".concat(xH[i], "-resize");
};
function Lw(r, e, n, i, s) {
  const { target: o } = n, { counterAxis: a, origin: l, lockSkewing: c, skew: u, flip: h } = zp[r];
  if (Ms(o, c)) return !1;
  const { origin: d, flip: p } = zp[a], f = Vn(n[d]) * (o[p] ? -1 : 1), m = -Math.sign(f) * (o[h] ? -1 : 1), _ = 0.5 * -((o[u] === 0 && Sv(n, It, It, i, s)[r] > 0 || o[u] > 0 ? 1 : -1) * m) + 0.5;
  return El(sw, Al((v, S, b, x) => function(M, C, E) {
    let { target: T, ex: w, ey: A, skewingSide: O } = C, U = pn(C, _H);
    const { skew: D } = zp[M], L = E.subtract(new He(w, A)).divide(new He(T.scaleX, T.scaleY))[M], P = T[D], V = U[D], ce = Math.tan(On(V)), q = M === "y" ? T._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : T._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, oe = 2 * L * O / Math.max(q, 1) + ce, ne = Dr(Math.atan(oe));
    T.set(D, ne);
    const $ = P !== T[D];
    if ($ && M === "y") {
      const { skewX: J, scaleX: se } = T, le = T._getTransformedDimensions({ skewY: P }), re = T._getTransformedDimensions(), ye = J !== 0 ? le.x / re.x : 1;
      ye !== 1 && T.set(Bi, ye * se);
    }
    return $;
  }(r, S, new He(b, x))))(e, Ie(Ie({}, n), {}, { [l]: _, skewingSide: m }), i, s);
}
const wH = (r, e, n, i) => Lw("x", r, e, n, i), SH = (r, e, n, i) => Lw("y", r, e, n, i);
function _f(r, e) {
  return r[e.canvas.altActionKey];
}
const lh = (r, e, n) => {
  const i = _f(r, n);
  return e.x === 0 ? i ? Sl : ss : e.y === 0 ? i ? Ml : Bi : "";
}, Ha = (r, e, n) => _f(r, n) ? bH(0, e, n) : cc(r, e, n), A1 = (r, e, n, i) => _f(r, e.target) ? SH(r, e, n, i) : vH(r, e, n, i), P1 = (r, e, n, i) => _f(r, e.target) ? wH(r, e, n, i) : yH(r, e, n, i), Iw = () => ({ ml: new ps({ x: -0.5, y: 0, cursorStyleHandler: Ha, actionHandler: A1, getActionName: lh }), mr: new ps({ x: 0.5, y: 0, cursorStyleHandler: Ha, actionHandler: A1, getActionName: lh }), mb: new ps({ x: 0, y: 0.5, cursorStyleHandler: Ha, actionHandler: P1, getActionName: lh }), mt: new ps({ x: 0, y: -0.5, cursorStyleHandler: Ha, actionHandler: P1, getActionName: lh }), tl: new ps({ x: -0.5, y: -0.5, cursorStyleHandler: cc, actionHandler: ah }), tr: new ps({ x: 0.5, y: -0.5, cursorStyleHandler: cc, actionHandler: ah }), bl: new ps({ x: -0.5, y: 0.5, cursorStyleHandler: cc, actionHandler: ah }), br: new ps({ x: 0.5, y: 0.5, cursorStyleHandler: cc, actionHandler: ah }), mtr: new ps({ x: 0, y: -0.5, actionHandler: mH, cursorStyleHandler: pH, offsetY: -40, withConnection: !0, actionName: vv }) }), MH = () => ({ mr: new ps({ x: 0.5, y: 0, actionHandler: E1, cursorStyleHandler: Ha, actionName: Qc }), ml: new ps({ x: -0.5, y: 0, actionHandler: E1, cursorStyleHandler: Ha, actionName: Qc }) }), CH = () => Ie(Ie({}, Iw()), MH());
class iu extends ar {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), iu.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), iu.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: Iw() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const n = e._currentTransform, i = n.target, s = n.action;
      if (this === i && s && s.startsWith(pf)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const i = Object.entries(this.oCoords);
    for (let s = i.length - 1; s >= 0; s--) {
      const [o, a] = i[s], l = this.controls[o];
      if (l.shouldActivate(o, this, e, n ? a.touchCorner : a.corner)) return this.__corner = o, { key: o, control: l, coord: this.oCoords[o] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), n = this.getCenterPoint(), i = pu(n.x, n.y), s = Cl({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), o = ni(i, s), a = ni(e, o), l = ni(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), c = this.group ? Dd(this.calcTransformMatrix()) : void 0;
    c && (c.scaleX = Math.abs(c.scaleX), c.scaleY = Math.abs(c.scaleY));
    const u = this._calculateCurrentDimensions(c), h = {};
    return this.forEachControl((d, p) => {
      const f = d.positionHandler(u, l, this, d);
      h[p] = Object.assign(f, this._calcCornerCoords(d, f));
    }), h;
  }
  _calcCornerCoords(e, n) {
    const i = this.getTotalAngle();
    return { corner: e.calcCornerCoords(i, this.cornerSize, n.x, n.y, !1, this), touchCorner: e.calcCornerCoords(i, this.touchCornerSize, n.x, n.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const n in this.controls) e(this.controls[n], n, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const n = this.getRelativeCenterPoint(), i = this._calculateCurrentDimensions(), s = this.getViewportTransform();
    e.translate(n.x, n.y), e.scale(1 / s[0], 1 / s[3]), e.rotate(On(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-i.x / 2, -i.y / 2, i.x, i.y), e.restore();
  }
  strokeBorders(e, n) {
    e.strokeRect(-n.x / 2, -n.y / 2, n.x, n.y);
  }
  _drawBorders(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const s = Ie({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, i);
    e.save(), e.strokeStyle = s.borderColor, this._setLineDash(e, s.borderDashArray), this.strokeBorders(e, n), s.hasControls && this.drawControlsConnectingLines(e, n), e.restore();
  }
  _renderControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: i, hasControls: s } = this, o = Ie({ hasBorders: i, hasControls: s }, n), a = this.getViewportTransform(), l = o.hasBorders, c = o.hasControls, u = ni(a, this.calcTransformMatrix()), h = Dd(u);
    e.save(), e.translate(h.translateX, h.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (h.angle -= 180), e.rotate(On(this.group ? h.angle : this.angle)), l && this.drawBorders(e, h, n), c && this.drawControls(e, n), e.restore();
  }
  drawBorders(e, n, i) {
    let s;
    if (i && i.forActiveSelection || this.group) {
      const o = wv(this.width, this.height, mf(n)), a = this.isStrokeAccountedForInDimensions() ? yv : (this.strokeUniform ? new He().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new He(n.scaleX, n.scaleY)).scalarMultiply(this.strokeWidth);
      s = o.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else s = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, s, i);
  }
  drawControlsConnectingLines(e, n) {
    let i = !1;
    e.beginPath(), this.forEachControl((s, o) => {
      s.withConnection && s.getVisibility(this, o) && (i = !0, e.moveTo(s.x * n.x, s.y * n.y), e.lineTo(s.x * n.x + s.offsetX, s.y * n.y + s.offsetY));
    }), i && e.stroke();
  }
  drawControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const i = this.getCanvasRetinaScaling(), { cornerStrokeColor: s, cornerDashArray: o, cornerColor: a } = this, l = Ie({ cornerStrokeColor: s, cornerDashArray: o, cornerColor: a }, n);
    e.setTransform(i, 0, 0, i, 0, 0), e.strokeStyle = e.fillStyle = l.cornerColor, this.transparentCorners || (e.strokeStyle = l.cornerStrokeColor), this._setLineDash(e, l.cornerDashArray), this.forEachControl((c, u) => {
      if (c.getVisibility(this, u)) {
        const h = this.oCoords[u];
        c.render(e, h.x, h.y, l, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, n) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = n;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((n) => {
      let [i, s] = n;
      return this.setControlVisible(i, s);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const n = this.canvas.contextTop;
    if (!n) return;
    const i = this.canvas.viewportTransform;
    n.save(), n.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this.transform(n);
    const s = this.width + 4, o = this.height + 4;
    return n.clearRect(-s / 2, -o / 2, s, o), e || n.restore(), n;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function Ow(r, e) {
  return e.forEach((n) => {
    Object.getOwnPropertyNames(n.prototype).forEach((i) => {
      i !== "constructor" && Object.defineProperty(r.prototype, i, Object.getOwnPropertyDescriptor(n.prototype, i) || /* @__PURE__ */ Object.create(null));
    });
  }), r;
}
Re(iu, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class pi extends iu {
}
Ow(pi, [ww]), ht.setClass(pi), ht.setClass(pi, "object");
const TH = (r, e, n, i) => {
  const s = 2 * (i = Math.round(i)) + 1, { data: o } = r.getImageData(e - i, n - i, s, s);
  for (let a = 3; a < o.length; a += 4)
    if (o[a] > 0) return !1;
  return !0;
};
class Fw {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new He(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new He(1 / this.options.scaleX, 1 / this.options.scaleY) : new He(1, 1);
  }
  createSideVector(e, n) {
    const i = ag(e, n);
    return this.options.strokeUniform ? i.multiply(this.scale) : i;
  }
  projectOrthogonally(e, n, i) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, n, i)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const n = new He(e);
    return n.y += n.x * Math.tan(On(this.options.skewY)), n.x += n.y * Math.tan(On(this.options.skewX)), n;
  }
  scaleUnitVector(e, n) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(n);
  }
}
const EH = new He();
class nl extends Fw {
  static getOrthogonalRotationFactor(e, n) {
    const i = n ? cg(e, n) : qG(e);
    return Math.abs(i) < fu ? -1 : 1;
  }
  constructor(e, n, i, s) {
    super(s), Re(this, "AB", void 0), Re(this, "AC", void 0), Re(this, "alpha", void 0), Re(this, "bisector", void 0), this.A = new He(e), this.B = new He(n), this.C = new He(i), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = cg(this.AB, this.AC), this.bisector = Mv(Aw(this.AB.eq(EH) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const s = this.createSideVector(e, n), o = Pw(s), a = nl.getOrthogonalRotationFactor(o, this.bisector);
    return this.scaleUnitVector(o, i * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % Td == 0 ? [this.B] : [this.B, this.C]).forEach((n) => {
      e.push(this.projectOrthogonally(this.A, n)), e.push(this.projectOrthogonally(this.A, n, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], n = Math.abs(this.alpha), i = 1 / Math.sin(n / 2), s = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * i), o = this.options.strokeUniform ? lg(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return lg(s) / this.strokeProjectionMagnitude <= o && e.push(this.applySkew(this.A.add(s))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, n) {
    const i = [], s = new He(nl.getOrthogonalRotationFactor(this.bisector), nl.getOrthogonalRotationFactor(new He(this.bisector.y, this.bisector.x)));
    return [new He(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(s), new He(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(s)].forEach((o) => {
      M1(o, e, n) && i.push(this.A.add(o));
    }), i;
  }
  projectRoundWithSkew(e, n) {
    const i = [], { skewX: s, skewY: o, scaleX: a, scaleY: l, strokeUniform: c } = this.options, u = new He(Math.tan(On(s)), Math.tan(On(o))), h = this.strokeProjectionMagnitude, d = c ? h / l / Math.sqrt(1 / l ** 2 + 1 / a ** 2 * u.y ** 2) : h / Math.sqrt(1 + u.y ** 2), p = new He(Math.sqrt(Math.max(h ** 2 - d ** 2, 0)), d), f = c ? h / Math.sqrt(1 + u.x ** 2 * (1 / l) ** 2 / (1 / a + 1 / a * u.x * u.y) ** 2) : h / Math.sqrt(1 + u.x ** 2 / (1 + u.x * u.y) ** 2), m = new He(f, Math.sqrt(Math.max(h ** 2 - f ** 2, 0)));
    return [m, m.scalarMultiply(-1), p, p.scalarMultiply(-1)].map((_) => this.applySkew(c ? _.multiply(this.strokeUniformScalar) : _)).forEach((_) => {
      M1(_, e, n) && i.push(this.applySkew(this.A).add(_));
    }), i;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const n = this.alpha % Td == 0, i = this.applySkew(this.A), s = e[n ? 0 : 2].subtract(i), o = e[n ? 1 : 0].subtract(i), a = n ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), l = kc(s, a) > 0, c = l ? s : o, u = l ? o : s;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(c, u)) : e.push(...this.projectRoundNoSkew(c, u)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class D1 extends Fw {
  constructor(e, n, i) {
    super(i), this.A = new He(e), this.T = new He(n);
  }
  calcOrthogonalProjection(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const s = this.createSideVector(e, n);
    return this.scaleUnitVector(Pw(s), i);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const n = new He(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(n)), this.applySkew(this.A.subtract(n)));
    } else e.push(...new nl(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const n = new He(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(n), this.A.subtract(n));
    } else {
      const n = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), i = this.scaleUnitVector(Mv(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), s = this.A.add(i);
      e.push(s.add(n), s.subtract(n));
    }
    return e.map((n) => this.applySkew(n));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const AH = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const i = [];
  if (r.length === 0) return i;
  const s = r.reduce((o, a) => (o[o.length - 1].eq(a) || o.push(new He(a)), o), [new He(r[0])]);
  if (s.length === 1) n = !0;
  else if (!n) {
    const o = s[0], a = ((l, c) => {
      for (let u = l.length - 1; u >= 0; u--) if (c(l[u], u, l)) return u;
      return -1;
    })(s, (l) => !l.eq(o));
    s.splice(a + 1);
  }
  return s.forEach((o, a, l) => {
    let c, u;
    a === 0 ? (u = l[1], c = n ? o : l[l.length - 1]) : a === l.length - 1 ? (c = l[a - 1], u = n ? o : l[0]) : (c = l[a - 1], u = l[a + 1]), n && l.length === 1 ? i.push(...new D1(o, o, e).project()) : !n || a !== 0 && a !== l.length - 1 ? i.push(...new nl(o, c, u, e).project()) : i.push(...new D1(o, a === 0 ? u : c, e).project());
  }), i;
}, Ev = (r) => {
  const e = {};
  return Object.keys(r).forEach((n) => {
    e[n] = {}, Object.keys(r[n]).forEach((i) => {
      e[n][i] = Ie({}, r[n][i]);
    });
  }), e;
}, PH = (r) => r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
let ql;
const Av = (r) => {
  if (ql || ql || (ql = "Intl" in df() && "Segmenter" in Intl && new Intl.Segmenter(void 0, { granularity: "grapheme" })), ql) {
    const e = ql.segment(r);
    return Array.from(e).map((n) => {
      let { segment: i } = n;
      return i;
    });
  }
  return DH(r);
}, DH = (r) => {
  const e = [];
  for (let n, i = 0; i < r.length; i++) (n = kH(r, i)) !== !1 && e.push(n);
  return e;
}, kH = (r, e) => {
  const n = r.charCodeAt(e);
  if (isNaN(n)) return "";
  if (n < 55296 || n > 57343) return r.charAt(e);
  if (55296 <= n && n <= 56319) {
    if (r.length <= e + 1) throw "High surrogate without following low surrogate";
    const s = r.charCodeAt(e + 1);
    if (56320 > s || s > 57343) throw "High surrogate without following low surrogate";
    return r.charAt(e) + r.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const i = r.charCodeAt(e - 1);
  if (55296 > i || i > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
}, Pv = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return r.fill !== e.fill || r.stroke !== e.stroke || r.strokeWidth !== e.strokeWidth || r.fontSize !== e.fontSize || r.fontFamily !== e.fontFamily || r.fontWeight !== e.fontWeight || r.fontStyle !== e.fontStyle || r.textDecorationThickness !== e.textDecorationThickness || r.textBackgroundColor !== e.textBackgroundColor || r.deltaY !== e.deltaY || n && (r.overline !== e.overline || r.underline !== e.underline || r.linethrough !== e.linethrough);
}, RH = (r, e) => {
  const n = e.split(`
`), i = [];
  let s = -1, o = {};
  r = Ev(r);
  for (let a = 0; a < n.length; a++) {
    const l = Av(n[a]);
    if (r[a]) for (let c = 0; c < l.length; c++) {
      s++;
      const u = r[a][c];
      u && Object.keys(u).length > 0 && (Pv(o, u, !0) ? i.push({ start: s, end: s + 1, style: u }) : i[i.length - 1].end++), o = u || {};
    }
    else s += l.length, o = {};
  }
  return i;
}, LH = (r, e) => {
  if (!Array.isArray(r)) return Ev(r);
  const n = e.split(gv), i = {};
  let s = -1, o = 0;
  for (let a = 0; a < n.length; a++) {
    const l = Av(n[a]);
    for (let c = 0; c < l.length; c++) s++, r[o] && r[o].start <= s && s < r[o].end && (i[a] = i[a] || {}, i[a][c] = Ie({}, r[o].style), s === r[o].end - 1 && o++);
  }
  return i;
}, go = ["display", "transform", Hn, "fill-opacity", "fill-rule", "opacity", zi, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function k1(r, e) {
  const n = r.nodeName, i = r.getAttribute("class"), s = r.getAttribute("id"), o = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + n, "i"), e = e.replace(a, ""), s && e.length && (a = new RegExp("#" + s + o, "i"), e = e.replace(a, "")), i && e.length) {
    const l = i.split(" ");
    for (let c = l.length; c--; ) a = new RegExp("\\." + l[c] + o, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function IH(r, e) {
  let n = !0;
  const i = k1(r, e.pop());
  return i && e.length && (n = function(s, o) {
    let a, l = !0;
    for (; s.parentElement && s.parentElement.nodeType === 1 && o.length; ) l && (a = o.pop()), l = k1(s = s.parentElement, a);
    return o.length === 0;
  }(r, e)), i && n && e.length === 0;
}
const OH = (r) => {
  var e;
  return (e = XG[r]) !== null && e !== void 0 ? e : r;
}, FH = new RegExp("(".concat(ws, ")"), "gi"), UH = (r) => Ld(r.replace(FH, " $1 ").replace(/,/gi, " "));
var R1, L1, I1, O1, F1, U1, z1;
const wi = "(".concat(ws, ")"), zH = String.raw(R1 || (R1 = Ys(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), wi), BH = String.raw(L1 || (L1 = Ys(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), wi), NH = String.raw(I1 || (I1 = Ys(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), wi, wi, wi), VH = String.raw(O1 || (O1 = Ys(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), wi, wi), GH = String.raw(F1 || (F1 = Ys(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), wi, wi), HH = String.raw(U1 || (U1 = Ys(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), wi, wi, wi, wi, wi, wi), Dv = "(?:".concat(HH, "|").concat(GH, "|").concat(NH, "|").concat(VH, "|").concat(zH, "|").concat(BH, ")"), WH = "(?:".concat(Dv, "*)"), jH = String.raw(z1 || (z1 = Ys(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), WH), $H = new RegExp(jH), XH = new RegExp(Dv), YH = new RegExp(Dv, "g");
function ug(r) {
  const e = [];
  if (!(r = UH(r).replace(/\s*([()])\s*/gi, "$1")) || r && !$H.test(r)) return [...Si];
  for (const n of r.matchAll(YH)) {
    const i = XH.exec(n[0]);
    if (!i) continue;
    let s = Si;
    const o = i.filter((m) => !!m), [, a, ...l] = o, [c, u, h, d, p, f] = l.map((m) => parseFloat(m));
    switch (a) {
      case "translate":
        s = pu(c, u);
        break;
      case vv:
        s = Cl({ angle: c }, { x: u, y: h });
        break;
      case pf:
        s = xv(c, u);
        break;
      case Sl:
        s = hw(c);
        break;
      case Ml:
        s = dw(c);
        break;
      case "matrix":
        s = [c, u, h, d, p, f];
    }
    e.push(s);
  }
  return _v(e);
}
function qH(r, e, n, i) {
  const s = Array.isArray(e);
  let o, a = e;
  if (r !== Hn && r !== zi || e !== Ui) {
    if (r === "strokeUniform") return e === "non-scaling-stroke";
    if (r === "strokeDashArray") a = e === Ui ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (r === "transformMatrix") a = n && n.transformMatrix ? ni(n.transformMatrix, ug(e)) : ug(e);
    else if (r === "visible") a = e !== Ui && e !== "hidden", n && n.visible === !1 && (a = !1);
    else if (r === "opacity") a = parseFloat(e), n && n.opacity !== void 0 && (a *= n.opacity);
    else if (r === "textAnchor") a = e === "start" ? Qt : e === "end" ? In : It;
    else if (r === "charSpacing" || r === ia) o = tl(e, i) / i * 1e3;
    else if (r === "paintFirst") {
      const l = e.indexOf(Hn), c = e.indexOf(zi);
      a = Hn, (l > -1 && c > -1 && c < l || l === -1 && c > -1) && (a = zi);
    } else {
      if (r === "href" || r === "xlink:href" || r === "font" || r === "id") return e;
      if (r === "imageSmoothing") return e === "optimizeQuality";
      o = s ? e.map(tl) : tl(e, i);
    }
  } else a = "";
  return !s && isNaN(o) ? a : o;
}
function ZH(r, e) {
  const n = r.match($G);
  if (!n) return;
  const i = n[1], s = n[3], o = n[4], a = n[5], l = n[6];
  i && (e.fontStyle = i), s && (e.fontWeight = isNaN(parseFloat(s)) ? s : parseFloat(s)), o && (e.fontSize = tl(o)), l && (e.fontFamily = l), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function KH(r, e) {
  r.replace(/;\s*$/, "").split(";").forEach((n) => {
    if (!n) return;
    const [i, s] = n.split(":");
    e[i.trim().toLowerCase()] = s.trim();
  });
}
function JH(r) {
  const e = {}, n = r.getAttribute("style");
  return n && (typeof n == "string" ? KH(n, e) : function(i, s) {
    Object.entries(i).forEach((o) => {
      let [a, l] = o;
      l !== void 0 && (s[a.toLowerCase()] = l);
    });
  }(n, e)), e;
}
const QH = { stroke: "strokeOpacity", fill: "fillOpacity" };
function Lr(r, e, n) {
  if (!r) return {};
  let i, s = {}, o = mv;
  r.parentNode && S1.test(r.parentNode.nodeName) && (s = Lr(r.parentElement, e, n), s.fontSize && (i = o = tl(s.fontSize)));
  const a = Ie(Ie(Ie({}, e.reduce((u, h) => {
    const d = r.getAttribute(h);
    return d && (u[h] = d), u;
  }, {})), function(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = {};
    for (const p in h) IH(u, p.split(" ")) && (d = Ie(Ie({}, d), h[p]));
    return d;
  }(r, n)), JH(r));
  a[Fp] && r.setAttribute(Fp, a[Fp]), a[Op] && (i = tl(a[Op], o), a[Op] = "".concat(i));
  const l = {};
  for (const u in a) {
    const h = OH(u), d = qH(h, a[u], s, i);
    l[h] = d;
  }
  l && l.font && ZH(l.font, l);
  const c = Ie(Ie({}, s), l);
  return S1.test(r.nodeName) ? c : function(u) {
    const h = pi.getDefaults();
    return Object.entries(QH).forEach((d) => {
      let [p, f] = d;
      if (u[f] === void 0 || u[p] === "") return;
      if (u[p] === void 0) {
        if (!h[p]) return;
        u[p] = h[p];
      }
      if (u[p].indexOf("url(") === 0) return;
      const m = new sn(u[p]);
      u[p] = m.setAlpha(hn(m.getAlpha() * u[f], 2)).toRgba();
    }), u;
  }(c);
}
const eW = ["left", "top", "width", "height", "visible"], Uw = ["rx", "ry"];
class Nn extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), Nn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Nn.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: n } = this;
    e && !n ? this.ry = e : n && !e && (this.rx = n);
  }
  _render(e) {
    const { width: n, height: i } = this, s = -n / 2, o = -i / 2, a = this.rx ? Math.min(this.rx, n / 2) : 0, l = this.ry ? Math.min(this.ry, i / 2) : 0, c = a !== 0 || l !== 0;
    e.beginPath(), e.moveTo(s + a, o), e.lineTo(s + n - a, o), c && e.bezierCurveTo(s + n - jr * a, o, s + n, o + jr * l, s + n, o + l), e.lineTo(s + n, o + i - l), c && e.bezierCurveTo(s + n, o + i - jr * l, s + n - jr * a, o + i, s + n - a, o + i), e.lineTo(s + a, o + i), c && e.bezierCurveTo(s + jr * a, o + i, s, o + i - jr * l, s, o + i - l), e.lineTo(s, o + l), c && e.bezierCurveTo(s, o + jr * l, s + jr * a, o, s + a, o), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Uw, ...e]);
  }
  _toSVG() {
    const { width: e, height: n, rx: i, ry: s } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-n / 2, '" rx="').concat(i, '" ry="').concat(s, '" width="').concat(e, '" height="').concat(n, `" />
`)];
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, this.ATTRIBUTE_NAMES, i), { left: o = 0, top: a = 0, width: l = 0, height: c = 0, visible: u = !0 } = s, h = pn(s, eW);
    return new this(Ie(Ie(Ie({}, n), h), {}, { left: o, top: a, width: l, height: c, visible: !!(u && l && c) }));
  }
}
Re(Nn, "type", "Rect"), Re(Nn, "cacheProperties", [...Rr, ...Uw]), Re(Nn, "ownDefaults", { rx: 0, ry: 0 }), Re(Nn, "ATTRIBUTE_NAMES", [...go, "x", "y", "rx", "ry", "width", "height"]), ht.setClass(Nn), ht.setSVGClass(Nn);
const mr = "initialization", Od = "added", kv = "removed", Fd = "imperative", zw = (r, e) => {
  const { strokeUniform: n, strokeWidth: i, width: s, height: o, group: a } = e, l = a && a !== r ? vf(a.calcTransformMatrix(), r.calcTransformMatrix()) : null, c = l ? e.getRelativeCenterPoint().transform(l) : e.getRelativeCenterPoint(), u = !e.isStrokeAccountedForInDimensions(), h = n && u ? BG(new He(i, i), void 0, r.calcTransformMatrix()) : yv, d = !n && u ? i : 0, p = wv(s + d, o + d, _v([l, e.calcOwnMatrix()], !0)).add(h).scalarDivide(2);
  return [c.subtract(p), c.add(p)];
};
class xf {
  calcLayoutResult(e, n) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(n, e);
  }
  shouldPerformLayout(e) {
    let { type: n, prevStrategy: i, strategy: s } = e;
    return n === mr || n === Fd || !!i && s !== i;
  }
  shouldLayoutClipPath(e) {
    let { type: n, target: { clipPath: i } } = e;
    return n !== mr && i && !i.absolutePositioned;
  }
  getInitialSize(e, n) {
    return n.size;
  }
  calcBoundingBox(e, n) {
    const { type: i, target: s } = n;
    if (i === Fd && n.overrides) return n.overrides;
    if (e.length === 0) return;
    const { left: o, top: a, width: l, height: c } = br(e.map((d) => zw(s, d)).reduce((d, p) => d.concat(p), [])), u = new He(l, c), h = new He(o, a).add(u.scalarDivide(2));
    if (i === mr) {
      const d = this.getInitialSize(n, { size: u, center: h });
      return { center: h, relativeCorrection: new He(0, 0), size: d };
    }
    return { center: h.transform(s.calcOwnMatrix()), size: u };
  }
}
Re(xf, "type", "strategy");
class hg extends xf {
  shouldPerformLayout(e) {
    return !0;
  }
}
Re(hg, "type", "fit-content"), ht.setClass(hg);
const tW = ["strategy"], nW = ["target", "strategy", "bubbles", "prevStrategy"], Bw = "layoutManager";
class su {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new hg();
    Re(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const n = Ie(Ie({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(n);
    const i = this.getLayoutResult(n);
    i && this.commitLayout(n, i), this.onAfterLayout(n, i), this._prevLayoutStrategy = n.strategy;
  }
  attachHandlers(e, n) {
    const { target: i } = n;
    return [Ad, nw, Qc, iw, ff, sw, Ed, MG, CG].map((s) => e.on(s, (o) => this.performLayout(s === Ad ? { type: "object_modified", trigger: s, e: o, target: i } : { type: "object_modifying", trigger: s, e: o, target: i })));
  }
  subscribe(e, n) {
    this.unsubscribe(e, n);
    const i = this.attachHandlers(e, n);
    this._subscriptions.set(e, i);
  }
  unsubscribe(e, n) {
    (this._subscriptions.get(e) || []).forEach((i) => i()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((n) => this.unsubscribe(n, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((n) => this.subscribe(n, e));
  }
  onBeforeLayout(e) {
    const { target: n, type: i } = e, { canvas: s } = n;
    if (i === mr || i === Od ? this.subscribeTargets(e) : i === kv && this.unsubscribeTargets(e), n.fire("layout:before", { context: e }), s && s.fire("object:layout:before", { target: n, context: e }), i === Fd && e.deep) {
      const o = pn(e, tW);
      n.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(Ie(Ie({}, o), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: n, strategy: i, type: s } = e, o = i.calcLayoutResult(e, n.getObjects());
    if (!o) return;
    const a = s === mr ? new He() : n.getRelativeCenterPoint(), { center: l, correction: c = new He(), relativeCorrection: u = new He() } = o, h = a.subtract(l).add(c).transform(s === mr ? Si : bs(n.calcOwnMatrix()), !0).add(u);
    return { result: o, prevCenter: a, nextCenter: l, offset: h };
  }
  commitLayout(e, n) {
    const { target: i } = e, { result: { size: s }, nextCenter: o } = n;
    var a, l;
    i.set({ width: s.x, height: s.y }), this.layoutObjects(e, n), e.type === mr ? i.set({ left: (a = e.x) !== null && a !== void 0 ? a : o.x + s.x * Vn(i.originX), top: (l = e.y) !== null && l !== void 0 ? l : o.y + s.y * Vn(i.originY) }) : (i.setPositionByOrigin(o, It, It), i.setCoords(), i.set("dirty", !0));
  }
  layoutObjects(e, n) {
    const { target: i } = e;
    i.forEachObject((s) => {
      s.group === i && this.layoutObject(e, n, s);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, n, i.clipPath);
  }
  layoutObject(e, n, i) {
    let { offset: s } = n;
    i.set({ left: i.left + s.x, top: i.top + s.y });
  }
  onAfterLayout(e, n) {
    const { target: i, strategy: s, bubbles: o, prevStrategy: a } = e, l = pn(e, nW), { canvas: c } = i;
    i.fire("layout:after", { context: e, result: n }), c && c.fire("object:layout:after", { context: e, result: n, target: i });
    const u = i.parent;
    o && u != null && u.layoutManager && ((l.path || (l.path = [])).push(i), u.layoutManager.performLayout(Ie(Ie({}, l), {}, { target: u }))), i.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((n) => n.forEach((i) => i())), e.clear();
  }
  toObject() {
    return { type: Bw, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
ht.setClass(su, Bw);
const iW = ["type", "objects", "layoutManager"];
class sW extends su {
  performLayout() {
  }
}
class oo extends rw(pi) {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), oo.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Re(this, "_activeObjects", []), Re(this, "__objectSelectionTracker", void 0), Re(this, "__objectSelectionDisposer", void 0), Object.assign(this, oo.ownDefaults), this.setOptions(n), this.groupInit(e, n);
  }
  groupInit(e, n) {
    var i;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((s) => {
      this.enterGroup(s, !1);
    }), this.layoutManager = (i = n.layoutManager) !== null && i !== void 0 ? i : new su(), this.layoutManager.performLayout({ type: mr, target: this, targets: [...e], x: n.left, y: n.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (lo("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (lo("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((n, i, s) => this.canEnterGroup(n) && s.indexOf(n) === i);
  }
  add() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    const s = this._filterObjectsBeforeEnteringGroup(n), o = super.add(...s);
    return this._onAfterObjectsChange(Od, s), o;
  }
  insertAt(e) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) i[s - 1] = arguments[s];
    const o = this._filterObjectsBeforeEnteringGroup(i), a = super.insertAt(e, ...o);
    return this._onAfterObjectsChange(Od, o), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(kv, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, n) {
    this.exitGroup(e, n), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, n) {
    this.layoutManager.performLayout({ type: e, targets: n, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, n) {
    const i = this[e];
    return super._set(e, n), e === "canvas" && i !== n && (this._objects || []).forEach((s) => {
      s._set(e, n);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, n) {
    let { target: i } = n;
    const s = this._activeObjects;
    if (e) s.push(i), this._set("dirty", !0);
    else if (s.length > 0) {
      const o = s.indexOf(i);
      o > -1 && (s.splice(o, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, n) {
    e && this._watchObject(!1, n), e ? (n.on("selected", this.__objectSelectionTracker), n.on("deselected", this.__objectSelectionDisposer)) : (n.off("selected", this.__objectSelectionTracker), n.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, n) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, n);
  }
  _enterGroup(e, n) {
    n && kd(e, ni(bs(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const i = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    i && (i === e || e.isDescendantOf(i)) && this._activeObjects.push(e);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, n) {
    e._set("group", void 0), n || (kd(e, ni(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const i = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    i > -1 && this._activeObjects.splice(i, 1);
  }
  shouldCache() {
    const e = pi.prototype.shouldCache.call(this);
    if (e) {
      for (let n = 0; n < this._objects.length; n++) if (this._objects[n].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, n, i) {
    this._renderBackground(e);
    for (let o = 0; o < this._objects.length; o++) {
      var s;
      const a = this._objects[o];
      (s = this.canvas) !== null && s !== void 0 && s.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...bs(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, i);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(Ie({ target: this, type: Fd }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, n) {
    const i = this.includeDefaultValues;
    return this._objects.filter(function(s) {
      return !s.excludeFromExport;
    }).map(function(s) {
      const o = s.includeDefaultValues;
      s.includeDefaultValues = i;
      const a = s[e || "toObject"](n);
      return s.includeDefaultValues = o, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.layoutManager.toObject();
    return Ie(Ie(Ie({}, super.toObject(["subTargetCheck", "interactive", ...e])), n.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: n } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const n = Nn.prototype._toSVG.call(this), i = n.indexOf("COMMON_PARTS");
    n[i] = 'for="group" ';
    const s = n.join("");
    return e ? e(s) : s;
  }
  _toSVG(e) {
    const n = ["<g ", "COMMON_PARTS", ` >
`], i = this._createSVGBgRect(e);
    i && n.push("		", i);
    for (let s = 0; s < this._objects.length; s++) n.push("		", this._objects[s].toSVG(e));
    return n.push(`</g>
`), n;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", n = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), n].join("");
  }
  toClipPathSVG(e) {
    const n = [], i = this._createSVGBgRect(e);
    i && n.push("	", i);
    for (let s = 0; s < this._objects.length; s++) n.push("	", this._objects[s].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(n, { reviver: e });
  }
  static fromObject(e, n) {
    let { type: i, objects: s = [], layoutManager: o } = e, a = pn(e, iW);
    return Promise.all([eu(s, n), gf(a, n)]).then((l) => {
      let [c, u] = l;
      const h = new this(c, Ie(Ie(Ie({}, a), u), {}, { layoutManager: new sW() }));
      if (o) {
        const d = ht.getClass(o.type), p = ht.getClass(o.strategy);
        h.layoutManager = new d(new p());
      } else h.layoutManager = new su();
      return h.layoutManager.subscribeTargets({ type: mr, target: h, targets: h.getObjects() }), h.setCoords(), h;
    });
  }
}
Re(oo, "type", "Group"), Re(oo, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), ht.setClass(oo);
const rW = (r, e) => Math.min(e.width / r.width, e.height / r.height), oW = (r, e) => Math.max(e.width / r.width, e.height / r.height), dg = "\\s*,?\\s*", Zl = "".concat(dg, "(").concat(ws, ")"), aW = "".concat(Zl).concat(Zl).concat(Zl).concat(dg, "([01])").concat(dg, "([01])").concat(Zl).concat(Zl), lW = { m: "l", M: "L" }, cW = (r, e, n, i, s, o, a, l, c, u, h) => {
  const d = Er(r), p = Ar(r), f = Er(e), m = Ar(e), _ = n * s * f - i * o * m + a, g = i * s * f + n * o * m + l;
  return ["C", u + c * (-n * s * p - i * o * d), h + c * (-i * s * p + n * o * d), _ + c * (n * s * m + i * o * f), g + c * (i * s * m - n * o * f), _, g];
}, B1 = (r, e, n, i) => {
  const s = Math.atan2(e, r), o = Math.atan2(i, n);
  return o >= s ? o - s : 2 * Math.PI - (s - o);
};
function N1(r, e, n, i, s, o, a, l) {
  let c;
  if (Gt.cachesBoundsOfCurve && (c = [...arguments].join(), Ac.boundsOfCurveCache[c])) return Ac.boundsOfCurveCache[c];
  const u = Math.sqrt, h = Math.abs, d = [], p = [[0, 0], [0, 0]];
  let f = 6 * r - 12 * n + 6 * s, m = -3 * r + 9 * n - 9 * s + 3 * a, _ = 3 * n - 3 * r;
  for (let x = 0; x < 2; ++x) {
    if (x > 0 && (f = 6 * e - 12 * i + 6 * o, m = -3 * e + 9 * i - 9 * o + 3 * l, _ = 3 * i - 3 * e), h(m) < 1e-12) {
      if (h(f) < 1e-12) continue;
      const w = -_ / f;
      0 < w && w < 1 && d.push(w);
      continue;
    }
    const M = f * f - 4 * _ * m;
    if (M < 0) continue;
    const C = u(M), E = (-f + C) / (2 * m);
    0 < E && E < 1 && d.push(E);
    const T = (-f - C) / (2 * m);
    0 < T && T < 1 && d.push(T);
  }
  let g = d.length;
  const v = g, S = Nw(r, e, n, i, s, o, a, l);
  for (; g--; ) {
    const { x, y: M } = S(d[g]);
    p[0][g] = x, p[1][g] = M;
  }
  p[0][v] = r, p[1][v] = e, p[0][v + 1] = a, p[1][v + 1] = l;
  const b = [new He(Math.min(...p[0]), Math.min(...p[1])), new He(Math.max(...p[0]), Math.max(...p[1]))];
  return Gt.cachesBoundsOfCurve && (Ac.boundsOfCurveCache[c] = b), b;
}
const uW = (r, e, n) => {
  let [i, s, o, a, l, c, u, h] = n;
  const d = ((p, f, m, _, g, v, S) => {
    if (m === 0 || _ === 0) return [];
    let b = 0, x = 0, M = 0;
    const C = Math.PI, E = S * pv, T = Ar(E), w = Er(E), A = 0.5 * (-w * p - T * f), O = 0.5 * (-w * f + T * p), U = m ** 2, D = _ ** 2, L = O ** 2, P = A ** 2, V = U * D - U * L - D * P;
    let ce = Math.abs(m), q = Math.abs(_);
    if (V < 0) {
      const R = Math.sqrt(1 - V / (U * D));
      ce *= R, q *= R;
    } else M = (g === v ? -1 : 1) * Math.sqrt(V / (U * L + D * P));
    const oe = M * ce * O / q, ne = -M * q * A / ce, $ = w * oe - T * ne + 0.5 * p, J = T * oe + w * ne + 0.5 * f;
    let se = B1(1, 0, (A - oe) / ce, (O - ne) / q), le = B1((A - oe) / ce, (O - ne) / q, (-A - oe) / ce, (-O - ne) / q);
    v === 0 && le > 0 ? le -= 2 * C : v === 1 && le < 0 && (le += 2 * C);
    const re = Math.ceil(Math.abs(le / C * 2)), ye = [], H = le / re, K = 8 / 3 * Math.sin(H / 4) * Math.sin(H / 4) / Math.sin(H / 2);
    let G = se + H;
    for (let R = 0; R < re; R++) ye[R] = cW(se, G, w, T, ce, q, $, J, K, b, x), b = ye[R][5], x = ye[R][6], se = G, G += H;
    return ye;
  })(u - r, h - e, s, o, l, c, a);
  for (let p = 0, f = d.length; p < f; p++) d[p][1] += r, d[p][2] += e, d[p][3] += r, d[p][4] += e, d[p][5] += r, d[p][6] += e;
  return d;
}, hW = (r) => {
  let e = 0, n = 0, i = 0, s = 0;
  const o = [];
  let a, l = 0, c = 0;
  for (const u of r) {
    const h = [...u];
    let d;
    switch (h[0]) {
      case "l":
        h[1] += e, h[2] += n;
      case "L":
        e = h[1], n = h[2], d = ["L", e, n];
        break;
      case "h":
        h[1] += e;
      case "H":
        e = h[1], d = ["L", e, n];
        break;
      case "v":
        h[1] += n;
      case "V":
        n = h[1], d = ["L", e, n];
        break;
      case "m":
        h[1] += e, h[2] += n;
      case "M":
        e = h[1], n = h[2], i = h[1], s = h[2], d = ["M", e, n];
        break;
      case "c":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n, h[5] += e, h[6] += n;
      case "C":
        l = h[3], c = h[4], e = h[5], n = h[6], d = ["C", h[1], h[2], l, c, e, n];
        break;
      case "s":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n;
      case "S":
        a === "C" ? (l = 2 * e - l, c = 2 * n - c) : (l = e, c = n), e = h[3], n = h[4], d = ["C", l, c, h[1], h[2], e, n], l = d[3], c = d[4];
        break;
      case "q":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n;
      case "Q":
        l = h[1], c = h[2], e = h[3], n = h[4], d = ["Q", l, c, e, n];
        break;
      case "t":
        h[1] += e, h[2] += n;
      case "T":
        a === "Q" ? (l = 2 * e - l, c = 2 * n - c) : (l = e, c = n), e = h[1], n = h[2], d = ["Q", l, c, e, n];
        break;
      case "a":
        h[6] += e, h[7] += n;
      case "A":
        uW(e, n, h).forEach((p) => o.push(p)), e = h[6], n = h[7];
        break;
      case "z":
      case "Z":
        e = i, n = s, d = ["Z"];
    }
    d ? (o.push(d), a = d[0]) : a = "";
  }
  return o;
}, Ud = (r, e, n, i) => Math.sqrt((n - r) ** 2 + (i - e) ** 2), Nw = (r, e, n, i, s, o, a, l) => (c) => {
  const u = c ** 3, h = ((f) => 3 * f ** 2 * (1 - f))(c), d = ((f) => 3 * f * (1 - f) ** 2)(c), p = ((f) => (1 - f) ** 3)(c);
  return new He(a * u + s * h + n * d + r * p, l * u + o * h + i * d + e * p);
}, Vw = (r) => r ** 2, Gw = (r) => 2 * r * (1 - r), Hw = (r) => (1 - r) ** 2, dW = (r, e, n, i, s, o, a, l) => (c) => {
  const u = Vw(c), h = Gw(c), d = Hw(c), p = 3 * (d * (n - r) + h * (s - n) + u * (a - s)), f = 3 * (d * (i - e) + h * (o - i) + u * (l - o));
  return Math.atan2(f, p);
}, fW = (r, e, n, i, s, o) => (a) => {
  const l = Vw(a), c = Gw(a), u = Hw(a);
  return new He(s * l + n * c + r * u, o * l + i * c + e * u);
}, pW = (r, e, n, i, s, o) => (a) => {
  const l = 1 - a, c = 2 * (l * (n - r) + a * (s - n)), u = 2 * (l * (i - e) + a * (o - i));
  return Math.atan2(u, c);
}, V1 = (r, e, n) => {
  let i = new He(e, n), s = 0;
  for (let o = 1; o <= 100; o += 1) {
    const a = r(o / 100);
    s += Ud(i.x, i.y, a.x, a.y), i = a;
  }
  return s;
}, mW = (r, e) => {
  let n, i = 0, s = 0, o = { x: r.x, y: r.y }, a = Ie({}, o), l = 0.01, c = 0;
  const u = r.iterator, h = r.angleFinder;
  for (; s < e && l > 1e-4; ) a = u(i), c = i, n = Ud(o.x, o.y, a.x, a.y), n + s > e ? (i -= l, l /= 2) : (o = a, i += l, s += n);
  return Ie(Ie({}, a), {}, { angle: h(c) });
}, Ww = (r) => {
  let e, n, i = 0, s = 0, o = 0, a = 0, l = 0;
  const c = [];
  for (const u of r) {
    const h = { x: s, y: o, command: u[0], length: 0 };
    switch (u[0]) {
      case "M":
        n = h, n.x = a = s = u[1], n.y = l = o = u[2];
        break;
      case "L":
        n = h, n.length = Ud(s, o, u[1], u[2]), s = u[1], o = u[2];
        break;
      case "C":
        e = Nw(s, o, u[1], u[2], u[3], u[4], u[5], u[6]), n = h, n.iterator = e, n.angleFinder = dW(s, o, u[1], u[2], u[3], u[4], u[5], u[6]), n.length = V1(e, s, o), s = u[5], o = u[6];
        break;
      case "Q":
        e = fW(s, o, u[1], u[2], u[3], u[4]), n = h, n.iterator = e, n.angleFinder = pW(s, o, u[1], u[2], u[3], u[4]), n.length = V1(e, s, o), s = u[3], o = u[4];
        break;
      case "Z":
        n = h, n.destX = a, n.destY = l, n.length = Ud(s, o, a, l), s = a, o = l;
    }
    i += n.length, c.push(n);
  }
  return c.push({ length: i, x: s, y: o }), c;
}, gW = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ww(r), i = 0;
  for (; e - n[i].length > 0 && i < n.length - 2; ) e -= n[i].length, i++;
  const s = n[i], o = e / s.length, a = r[i];
  switch (s.command) {
    case "M":
      return { x: s.x, y: s.y, angle: 0 };
    case "Z":
      return Ie(Ie({}, new He(s.x, s.y).lerp(new He(s.destX, s.destY), o)), {}, { angle: Math.atan2(s.destY - s.y, s.destX - s.x) });
    case "L":
      return Ie(Ie({}, new He(s.x, s.y).lerp(new He(a[1], a[2]), o)), {}, { angle: Math.atan2(a[2] - s.y, a[1] - s.x) });
    case "C":
    case "Q":
      return mW(s, e);
  }
}, vW = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), G1 = new RegExp(aW, "g"), yW = new RegExp(ws, "gi"), _W = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, xW = (r) => {
  var e;
  const n = [], i = (e = r.match(vW)) !== null && e !== void 0 ? e : [];
  for (const s of i) {
    const o = s[0];
    if (o === "z" || o === "Z") {
      n.push([o]);
      continue;
    }
    const a = _W[o.toLowerCase()];
    let l = [];
    if (o === "a" || o === "A") {
      G1.lastIndex = 0;
      for (let c = null; c = G1.exec(s); ) l.push(...c.slice(1));
    } else l = s.match(yW) || [];
    for (let c = 0; c < l.length; c += a) {
      const u = new Array(a), h = lW[o];
      u[0] = c > 0 && h ? h : o;
      for (let d = 0; d < a; d++) u[d + 1] = parseFloat(l[c + d]);
      n.push(u);
    }
  }
  return n;
}, bW = (r, e) => r.map((n) => n.map((i, s) => s === 0 || e === void 0 ? i : hn(i, e)).join(" ")).join(" ");
function fg(r, e) {
  const n = r.style;
  n && e && (typeof e == "string" ? n.cssText += ";" + e : Object.entries(e).forEach((i) => {
    let [s, o] = i;
    return n.setProperty(s, o);
  }));
}
class wW extends gw {
  constructor(e) {
    let { allowTouchScrolling: n = !1, containerClass: i = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), Re(this, "upper", void 0), Re(this, "container", void 0);
    const { el: s } = this.lower, o = this.createUpperCanvas();
    this.upper = { el: o, ctx: o.getContext("2d") }, this.applyCanvasStyle(s, { allowTouchScrolling: n }), this.applyCanvasStyle(o, { allowTouchScrolling: n, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(i), s.parentNode && s.parentNode.replaceChild(a, s), a.append(s, o), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, n = Pr();
    return n.className = e.className, n.classList.remove("lower-canvas"), n.classList.add("upper-canvas"), n.setAttribute("data-fabric", "top"), n.style.cssText = e.style.cssText, n.setAttribute("draggable", "true"), n;
  }
  createContainerElement() {
    const e = wl().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), fg(e, { position: "relative" }), f1(e), e;
  }
  applyCanvasStyle(e, n) {
    const { styles: i, allowTouchScrolling: s } = n;
    fg(e, Ie(Ie({}, i), {}, { "touch-action": s ? "manipulation" : Ui })), f1(e);
  }
  setDimensions(e, n) {
    super.setDimensions(e, n);
    const { el: i, ctx: s } = this.upper;
    mw(i, s, e, n);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), rg(this.upper.el, e), rg(this.container, e);
  }
  cleanupDOM(e) {
    const n = this.container, { el: i } = this.lower, { el: s } = this.upper;
    super.cleanupDOM(e), n.removeChild(s), n.removeChild(i), n.parentNode && n.parentNode.replaceChild(i, n);
  }
  dispose() {
    super.dispose(), $s().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class bf extends mu {
  constructor() {
    super(...arguments), Re(this, "targets", []), Re(this, "_hoveredTargets", []), Re(this, "_currentTransform", null), Re(this, "_groupSelector", null), Re(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), bf.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new wW(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((n) => !n.group && n !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const n = this.getRetinaScaling(), i = Math.ceil((2 * e + 1) * n);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = i, this.pixelFindContext.scale(n, n);
  }
  isTargetTransparent(e, n, i) {
    const s = this.targetFindTolerance, o = this.pixelFindContext;
    this.clearContext(o), o.save(), o.translate(-n + s, -i + s), o.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(o), e.selectionBackgroundColor = a, o.restore();
    const l = Math.round(s * this.getRetinaScaling());
    return TH(o, l, l, l);
  }
  _isSelectionKeyPressed(e) {
    const n = this.selectionKey;
    return !!n && (Array.isArray(n) ? !!n.find((i) => !!i && e[i] === !0) : e[n]);
  }
  _shouldClearSelection(e, n) {
    const i = this.getActiveObjects(), s = this._activeObject;
    return !!(!n || n && s && i.length > 1 && i.indexOf(n) === -1 && s !== n && !this._isSelectionKeyPressed(e) || n && !n.evented || n && !n.selectable && s && s !== n);
  }
  _shouldCenterTransform(e, n, i) {
    if (!e) return;
    let s;
    return n === pf || n === Bi || n === ss || n === Qc ? s = this.centeredScaling || e.centeredScaling : n === vv && (s = this.centeredRotation || e.centeredRotation), s ? !i : i;
  }
  _getOriginFromCorner(e, n) {
    const i = { x: e.originX, y: e.originY };
    return n && (["ml", "tl", "bl"].includes(n) ? i.x = In : ["mr", "tr", "br"].includes(n) && (i.x = Qt), ["tl", "mt", "tr"].includes(n) ? i.y = sg : ["bl", "mb", "br"].includes(n) && (i.y = Fi)), i;
  }
  _setupCurrentTransform(e, n, i) {
    var s;
    const o = n.group ? el(this.getScenePoint(e), void 0, n.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: l } = n.getActiveControl() || {}, c = i && l ? (s = l.getActionHandler(e, n, l)) === null || s === void 0 ? void 0 : s.bind(l) : GG, u = ((f, m, _, g) => {
      if (!m || !f) return "drag";
      const v = g.controls[m];
      return v.getActionName(_, v, g);
    })(i, a, e, n), h = e[this.centeredKey], d = this._shouldCenterTransform(n, u, h) ? { x: It, y: It } : this._getOriginFromCorner(n, a), p = { target: n, action: u, actionHandler: c, actionPerformed: !1, corner: a, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, offsetX: o.x - n.left, offsetY: o.y - n.top, originX: d.x, originY: d.y, ex: o.x, ey: o.y, lastX: o.x, lastY: o.y, theta: On(n.angle), width: n.width, height: n.height, shiftKey: e.shiftKey, altKey: h, original: Ie(Ie({}, vw(n)), {}, { originX: d.x, originY: d.y }) };
    this._currentTransform = p, this.fire("before:transform", { e, transform: p });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: n, y: i, deltaX: s, deltaY: o } = this._groupSelector, a = new He(n, i).transform(this.viewportTransform), l = new He(n + s, i + o).transform(this.viewportTransform), c = this.selectionLineWidth / 2;
    let u = Math.min(a.x, l.x), h = Math.min(a.y, l.y), d = Math.max(a.x, l.x), p = Math.max(a.y, l.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(u, h, d - u, p - h)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, u += c, h += c, d -= c, p -= c, pi.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(u, h, d - u, p - h));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const n = this.getViewportPoint(e), i = this._activeObject, s = this.getActiveObjects();
    if (this.targets = [], i && s.length >= 1) {
      if (i.findControl(n, og(e)) || s.length > 1 && this.searchPossibleTargets([i], n)) return i;
      if (i === this.searchPossibleTargets([i], n)) {
        if (this.preserveObjectStacking) {
          const o = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, n);
          return e[this.altSelectionKey] && a && a !== i ? (this.targets = o, i) : a;
        }
        return i;
      }
    }
    return this.searchPossibleTargets(this._objects, n);
  }
  _pointIsInObjectSelectionArea(e, n) {
    let i = e.getCoords();
    const s = this.getZoom(), o = e.padding / s;
    if (o) {
      const [a, l, c, u] = i, h = Math.atan2(l.y - a.y, l.x - a.x), d = Er(h) * o, p = Ar(h) * o, f = d + p, m = d - p;
      i = [new He(a.x - m, a.y - f), new He(l.x + f, l.y - m), new He(c.x + m, c.y + f), new He(u.x - f, u.y + m)];
    }
    return xn.isPointInPolygon(n, i);
  }
  _checkTarget(e, n) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, el(n, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, n.x, n.y)));
  }
  _searchPossibleTargets(e, n) {
    let i = e.length;
    for (; i--; ) {
      const s = e[i];
      if (this._checkTarget(s, n)) {
        if (Qh(s) && s.subTargetCheck) {
          const o = this._searchPossibleTargets(s._objects, n);
          o && this.targets.push(o);
        }
        return s;
      }
    }
  }
  searchPossibleTargets(e, n) {
    const i = this._searchPossibleTargets(e, n);
    if (i && Qh(i) && i.interactive && this.targets[0]) {
      const s = this.targets;
      for (let o = s.length - 1; o > 0; o--) {
        const a = s[o];
        if (!Qh(a) || !a.interactive) return a;
      }
      return s[0];
    }
    return i;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const i = this.upperCanvasEl, s = i.getBoundingClientRect();
    let o = OG(e), a = s.width || 0, l = s.height || 0;
    a && l || (Fi in s && sg in s && (l = Math.abs(s.top - s.bottom)), In in s && Qt in s && (a = Math.abs(s.right - s.left))), this.calcOffset(), o.x = o.x - this._offset.left, o.y = o.y - this._offset.top, n || (o = el(o, void 0, this.viewportTransform));
    const c = this.getRetinaScaling();
    c !== 1 && (o.x /= c, o.y /= c);
    const u = a === 0 || l === 0 ? new He(1, 1) : new He(i.width / a, i.height / l);
    return o.multiply(u);
  }
  _setDimensionsImpl(e, n) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, n), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = Pr(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return Vo(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, n) {
    let i = !1, s = !1;
    const o = this.getActiveObjects(), a = [], l = [];
    e.forEach((c) => {
      o.includes(c) || (i = !0, c.fire("deselected", { e: n, target: c }), l.push(c));
    }), o.forEach((c) => {
      e.includes(c) || (i = !0, c.fire("selected", { e: n, target: c }), a.push(c));
    }), e.length > 0 && o.length > 0 ? (s = !0, i && this.fire("selection:updated", { e: n, selected: a, deselected: l })) : o.length > 0 ? (s = !0, this.fire("selection:created", { e: n, selected: a })) : e.length > 0 && (s = !0, this.fire("selection:cleared", { e: n, deselected: l })), s && (this._objectsToRender = void 0);
  }
  setActiveObject(e, n) {
    const i = this.getActiveObjects(), s = this._setActiveObject(e, n);
    return this._fireSelectionEvents(i, n), s;
  }
  _setActiveObject(e, n) {
    const i = this._activeObject;
    return i !== e && !(!this._discardActiveObject(n, e) && this._activeObject) && !e.onSelect({ e: n }) && (this._activeObject = e, Vo(e) && i !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, n) {
    const i = this._activeObject;
    return !!i && !i.onDeselect({ e, object: n }) && (this._currentTransform && this._currentTransform.target === i && this.endCurrentTransform(e), Vo(i) && i === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const n = this.getActiveObjects(), i = this.getActiveObject();
    n.length && this.fire("before:selection:cleared", { e, deselected: [i] });
    const s = this._discardActiveObject(e);
    return this._fireSelectionEvents(n, e), s;
  }
  endCurrentTransform(e) {
    const n = this._currentTransform;
    this._finalizeCurrentTransform(e), n && n.target && (n.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const n = this._currentTransform, i = n.target, s = { e, target: i, transform: n, action: n.action };
    i._scaling && (i._scaling = !1), i.setCoords(), n.actionPerformed && (this.fire("object:modified", s), i.fire(Ad, s));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const n = this._activeObject;
    n && n.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    Vo(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const n = this._activeObject;
    n && n._renderControls(e);
  }
  _toObject(e, n, i) {
    const s = this._realizeGroupTransformOnObject(e), o = super._toObject(e, n, i);
    return e.set(s), o;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: n } = e;
    if (n && Vo(n) && this._activeObject === n) {
      const i = Tl(e, ["angle", "flipX", "flipY", Qt, Bi, ss, Sl, Ml, Fi]);
      return UG(e, n.calcOwnMatrix()), i;
    }
    return {};
  }
  _setSVGObject(e, n, i) {
    const s = this._realizeGroupTransformOnObject(n);
    super._setSVGObject(e, n, i), n.set(s);
  }
}
Re(bf, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class SW {
  constructor(e) {
    Re(this, "targets", []), Re(this, "__disposer", void 0);
    const n = () => {
      const { hiddenTextarea: s } = e.getActiveObject() || {};
      s && s.focus();
    }, i = e.upperCanvasEl;
    i.addEventListener("click", n), this.__disposer = () => i.removeEventListener("click", n);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), Fa(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var n;
    !((n = this.target) === null || n === void 0) && n.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const MW = ["target", "oldTarget", "fireCanvas", "e"], $i = { passive: !1 }, Da = (r, e) => {
  const n = r.getViewportPoint(e), i = r.getScenePoint(e);
  return { viewportPoint: n, scenePoint: i, pointer: n, absolutePointer: i };
}, $r = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
  return r.addEventListener(...n);
}, Ji = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
  return r.removeEventListener(...n);
}, CW = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class pg extends bf {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), Re(this, "_isClick", void 0), Re(this, "textEditingManager", new SW(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((n) => {
      this[n] = this[n].bind(this);
    }), this.addOrRemove($r, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, n) {
    const i = this.upperCanvasEl, s = this._getEventPrefix();
    e(pw(i), "resize", this._onResize), e(i, s + "down", this._onMouseDown), e(i, "".concat(s, "move"), this._onMouseMove, $i), e(i, "".concat(s, "out"), this._onMouseOut), e(i, "".concat(s, "enter"), this._onMouseEnter), e(i, "wheel", this._onMouseWheel, { passive: !1 }), e(i, "contextmenu", this._onContextMenu), e(i, "click", this._onClick), e(i, "dblclick", this._onClick), e(i, "dragstart", this._onDragStart), e(i, "dragend", this._onDragEnd), e(i, "dragover", this._onDragOver), e(i, "dragenter", this._onDragEnter), e(i, "dragleave", this._onDragLeave), e(i, "drop", this._onDrop), this.enablePointerEvents || e(i, "touchstart", this._onTouchStart, $i);
  }
  removeListeners() {
    this.addOrRemove(Ji, "remove");
    const e = this._getEventPrefix(), n = _s(this.upperCanvasEl);
    Ji(n, "".concat(e, "up"), this._onMouseUp), Ji(n, "touchend", this._onTouchEnd, $i), Ji(n, "".concat(e, "move"), this._onMouseMove, $i), Ji(n, "touchmove", this._onMouseMove, $i), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const n = this._hoveredTarget, i = Ie({ e }, Da(this, e));
    this.fire("mouse:out", Ie(Ie({}, i), {}, { target: n })), this._hoveredTarget = void 0, n && n.fire("mouseout", Ie({}, i)), this._hoveredTargets.forEach((s) => {
      this.fire("mouse:out", Ie(Ie({}, i), {}, { target: s })), s && s.fire("mouseout", Ie({}, i));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", Ie({ e }, Da(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const n = this.getActiveObject();
    if (n && n.onDragStart(e)) {
      this._dragSource = n;
      const i = { e, target: n };
      return this.fire("dragstart", i), n.fire("dragstart", i), void $r(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    p1(e);
  }
  _renderDragEffects(e, n, i) {
    let s = !1;
    const o = this._dropTarget;
    o && o !== n && o !== i && (o.clearContextTop(), s = !0), n == null || n.clearContextTop(), i !== n && (i == null || i.clearContextTop());
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), n && (a.save(), n.transform(a), n.renderDragSourceEffect(e), a.restore(), s = !0), i && (a.save(), i.transform(a), i.renderDropTargetEffect(e), a.restore(), s = !0), a.restore(), s && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const n = !!e.dataTransfer && e.dataTransfer.dropEffect !== Ui, i = n ? this._activeObject : void 0, s = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: n, dropTarget: i };
    Ji(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", s), this._dragSource && this._dragSource.fire("dragend", s), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const n = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", n), this._dragSource && this._dragSource.fire("drag", n);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const n = "dragover", { target: i, targets: s } = this.findDragTargets(e), o = this._dragSource, a = { e, target: i, subTargets: s, dragSource: o, canDrop: !1, dropTarget: void 0 };
    let l;
    this.fire(n, a), this._fireEnterLeaveEvents(i, a), i && (i.canDrop(e) && (l = i), i.fire(n, a));
    for (let c = 0; c < s.length; c++) {
      const u = s[c];
      u.canDrop(e) && (l = u), u.fire(n, a);
    }
    this._renderDragEffects(e, o, l), this._dropTarget = l;
  }
  _onDragEnter(e) {
    const { target: n, targets: i } = this.findDragTargets(e), s = { e, target: n, subTargets: i, dragSource: this._dragSource };
    this.fire("dragenter", s), this._fireEnterLeaveEvents(n, s);
  }
  _onDragLeave(e) {
    const n = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", n), this._fireEnterLeaveEvents(void 0, n), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: n, targets: i } = this.findDragTargets(e), s = this._basicEventHandler("drop:before", Ie({ e, target: n, subTargets: i, dragSource: this._dragSource }, Da(this, e)));
    s.didDrop = !1, s.dropTarget = void 0, this._basicEventHandler("drop", s), this.fire("drop:after", s);
  }
  _onContextMenu(e) {
    const n = this.findTarget(e), i = this.targets || [], s = this._basicEventHandler("contextmenu:before", { e, target: n, subTargets: i });
    return this.stopContextMenu && p1(e), this._basicEventHandler("contextmenu", s), !1;
  }
  _onClick(e) {
    const n = e.detail;
    n > 3 || n < 2 || (this._cacheTransformEventData(e), n == 2 && e.type === "dblclick" && this._handleEvent(e, "dblclick"), n == 3 && this._handleEvent(e, "tripleclick"), this._resetTransformEventData());
  }
  getPointerId(e) {
    const n = e.changedTouches;
    return n ? n[0] && n[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let n = !this.allowTouchScrolling;
    const i = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || i && this._target === i) && (n = !0), n && e.preventDefault(), this._resetTransformEventData();
    const s = this.upperCanvasEl, o = this._getEventPrefix(), a = _s(s);
    $r(a, "touchend", this._onTouchEnd, $i), n && $r(a, "touchmove", this._onMouseMove, $i), Ji(s, "".concat(o, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, i = this._getEventPrefix();
    Ji(n, "".concat(i, "move"), this._onMouseMove, $i);
    const s = _s(n);
    $r(s, "".concat(i, "up"), this._onMouseUp), $r(s, "".concat(i, "move"), this._onMouseMove, $i);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const n = this._getEventPrefix(), i = _s(this.upperCanvasEl);
    Ji(i, "touchend", this._onTouchEnd, $i), Ji(i, "touchmove", this._onMouseMove, $i), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      $r(this.upperCanvasEl, "".concat(n, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, i = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const s = _s(this.upperCanvasEl);
      Ji(s, "".concat(i, "up"), this._onMouseUp), Ji(s, "".concat(i, "move"), this._onMouseMove, $i), $r(n, "".concat(i, "move"), this._onMouseMove, $i);
    }
  }
  _onMouseMove(e) {
    const n = this.getActiveObject();
    !this.allowTouchScrolling && (!n || !n.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const n = this.getActiveObject();
    return !!n != !!e || n && e && n !== e;
  }
  __onMouseUp(e) {
    var n;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const i = this._currentTransform, s = this._isClick, o = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let l, c, u = !1;
    if (i && (this._finalizeCurrentTransform(e), u = i.actionPerformed), !s) {
      const h = o === this._activeObject;
      this.handleSelection(e), u || (u = this._shouldRender(o) || !h && o === this._activeObject);
    }
    if (o) {
      const h = o.findControl(this.getViewportPoint(e), og(e)), { key: d, control: p } = h || {};
      if (c = d, o.selectable && o !== this._activeObject && o.activeOn === "up") this.setActiveObject(o, e), u = !0;
      else if (p) {
        const f = p.getMouseUpHandler(e, o, p);
        f && (l = this.getScenePoint(e), f.call(p, e, i, l.x, l.y));
      }
      o.isMoving = !1;
    }
    if (i && (i.target !== o || i.corner !== c)) {
      const h = i.target && i.target.controls[i.corner], d = h && h.getMouseUpHandler(e, i.target, h);
      l = l || this.getScenePoint(e), d && d.call(h, e, i, l.x, l.y);
    }
    this._setCursorFromEvent(e, o), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, o && (o.__corner = void 0), u ? this.requestRenderAll() : s || (n = this._activeObject) !== null && n !== void 0 && n.isEditing || this.renderTop();
  }
  _basicEventHandler(e, n) {
    const { target: i, subTargets: s = [] } = n;
    this.fire(e, n), i && i.fire(e, n);
    for (let o = 0; o < s.length; o++) s[o] !== i && s[o].fire(e, n);
    return n;
  }
  _handleEvent(e, n, i) {
    const s = this._target, o = this.targets || [], a = Ie(Ie(Ie({ e, target: s, subTargets: o }, Da(this, e)), {}, { transform: this._currentTransform }, n === "up:before" || n === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {}), n === "down:before" || n === "down" ? i : {});
    this.fire("mouse:".concat(n), a), s && s.fire("mouse".concat(n), a);
    for (let l = 0; l < o.length; l++) o[l] !== s && o[l].fire("mouse".concat(n), a);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const n = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(n, { e, pointer: n }), this._handleEvent(e, "down", { alreadySelected: !1 });
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const n = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(n, { e, pointer: n });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const n = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: n }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let n = this._target, i = !!n && n === this._activeObject;
    const { button: s } = e;
    if (s) return (this.fireMiddleClick && s === 1 || this.fireRightClick && s === 2) && this._handleEvent(e, "down", { alreadySelected: i }), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let o = this._shouldRender(n), a = !1;
    if (this.handleMultiSelection(e, n) ? (n = this._activeObject, a = !0, o = !0) : this._shouldClearSelection(e, n) && this.discardActiveObject(e), this.selection && (!n || !n.selectable && !n.isEditing && n !== this._activeObject)) {
      const l = this.getScenePoint(e);
      this._groupSelector = { x: l.x, y: l.y, deltaY: 0, deltaX: 0 };
    }
    if (i = !!n && n === this._activeObject, n) {
      n.selectable && n.activeOn === "down" && this.setActiveObject(n, e);
      const l = n.findControl(this.getViewportPoint(e), og(e));
      if (n === this._activeObject && (l || !a)) {
        this._setupCurrentTransform(e, n, i);
        const c = l ? l.control : void 0, u = this.getScenePoint(e), h = c && c.getMouseDownHandler(e, n, c);
        h && h.call(c, e, this._currentTransform, u.x, u.y);
      }
    }
    o && (this._objectsToRender = void 0), this._handleEvent(e, "down", { alreadySelected: i }), o && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = el(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const n = this._groupSelector;
    if (n) {
      const i = this.getScenePoint(e);
      n.deltaX = i.x - n.x, n.deltaY = i.y - n.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const i = this.findTarget(e);
      this._setCursorFromEvent(e, i), this._fireOverOutEvents(e, i);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, n) {
    const i = this._hoveredTarget, s = this._hoveredTargets, o = this.targets, a = Math.max(s.length, o.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: n, oldTarget: i, fireCanvas: !0 });
    for (let l = 0; l < a; l++) o[l] === n || s[l] && s[l] === i || this.fireSyntheticInOutEvents("mouse", { e, target: o[l], oldTarget: s[l] });
    this._hoveredTarget = n, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, n) {
    const i = this._draggedoverTarget, s = this._hoveredTargets, o = this.targets, a = Math.max(s.length, o.length);
    this.fireSyntheticInOutEvents("drag", Ie(Ie({}, n), {}, { target: e, oldTarget: i, fireCanvas: !0 }));
    for (let l = 0; l < a; l++) this.fireSyntheticInOutEvents("drag", Ie(Ie({}, n), {}, { target: o[l], oldTarget: s[l] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, n) {
    let { target: i, oldTarget: s, fireCanvas: o, e: a } = n, l = pn(n, MW);
    const { targetIn: c, targetOut: u, canvasIn: h, canvasOut: d } = CW[e], p = s !== i;
    if (s && p) {
      const f = Ie(Ie({}, l), {}, { e: a, target: s, nextTarget: i }, Da(this, a));
      o && this.fire(d, f), s.fire(u, f);
    }
    if (i && p) {
      const f = Ie(Ie({}, l), {}, { e: a, target: i, previousTarget: s }, Da(this, a));
      o && this.fire(h, f), i.fire(c, f);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const n = this.getScenePoint(e), i = this._currentTransform, s = i.target, o = s.group ? el(n, void 0, s.group.calcTransformMatrix()) : n;
    i.shiftKey = e.shiftKey, i.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, i, o), i.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, n, i) {
    const { action: s, actionHandler: o, target: a } = n, l = !!o && o(e, n, i.x, i.y);
    l && a.setCoords(), s === "drag" && l && (n.target.isMoving = !0, this.setCursor(n.target.moveCursor || this.moveCursor)), n.actionPerformed = n.actionPerformed || l;
  }
  _setCursorFromEvent(e, n) {
    if (!n) return void this.setCursor(this.defaultCursor);
    let i = n.hoverCursor || this.hoverCursor;
    const s = Vo(this._activeObject) ? this._activeObject : null, o = (!s || n.group !== s) && n.findControl(this.getViewportPoint(e));
    if (o) {
      const a = o.control;
      this.setCursor(a.cursorStyleHandler(e, a, n));
    } else n.subTargetCheck && this.targets.concat().reverse().map((a) => {
      i = a.hoverCursor || i;
    }), this.setCursor(i);
  }
  handleMultiSelection(e, n) {
    const i = this._activeObject, s = Vo(i);
    if (i && this._isSelectionKeyPressed(e) && this.selection && n && n.selectable && (i !== n || s) && (s || !n.isDescendantOf(i) && !i.isDescendantOf(n)) && !n.onSelect({ e }) && !i.getActiveControl()) {
      if (s) {
        const o = i.getObjects();
        if (n === i) {
          const a = this.getViewportPoint(e);
          if (!(n = this.searchPossibleTargets(o, a) || this.searchPossibleTargets(this._objects, a)) || !n.selectable) return !1;
        }
        n.group === i ? (i.remove(n), this._hoveredTarget = n, this._hoveredTargets = [...this.targets], i.size() === 1 && this._setActiveObject(i.item(0), e)) : (i.multiSelectAdd(n), this._hoveredTarget = i, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(o, e);
      } else {
        i.isEditing && i.exitEditing();
        const o = new (ht.getClass("ActiveSelection"))([], { canvas: this });
        o.multiSelectAdd(i, n), this._hoveredTarget = o, this._setActiveObject(o, e), this._fireSelectionEvents([i], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: n, y: i, deltaX: s, deltaY: o } = this._groupSelector, a = new He(n, i), l = a.add(new He(s, o)), c = a.min(l), u = a.max(l).subtract(c), h = this.collectObjects({ left: c.x, top: c.y, width: u.x, height: u.y }, { includeIntersecting: !this.selectionFullyContained }), d = a.eq(l) ? h[0] ? [h[0]] : [] : h.length > 1 ? h.filter((p) => !p.onSelect({ e })).reverse() : h;
    if (d.length === 1) this.setActiveObject(d[0], e);
    else if (d.length > 1) {
      const p = ht.getClass("ActiveSelection");
      this.setActiveObject(new p(d, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const jw = { x1: 0, y1: 0, x2: 0, y2: 0 }, TW = Ie(Ie({}, jw), {}, { r1: 0, r2: 0 }), Wa = (r, e) => isNaN(r) && typeof e == "number" ? e : r;
function $w(r) {
  return r && /%$/.test(r) && Number.isFinite(parseFloat(r));
}
function Xw(r, e) {
  const n = typeof r == "number" ? r : typeof r == "string" ? parseFloat(r) / ($w(r) ? 100 : 1) : NaN;
  return ml(0, Wa(n, e), 1);
}
const EW = /\s*;\s*/, AW = /\s*:\s*/;
function PW(r, e) {
  let n, i;
  const s = r.getAttribute("style");
  if (s) {
    const a = s.split(EW);
    a[a.length - 1] === "" && a.pop();
    for (let l = a.length; l--; ) {
      const [c, u] = a[l].split(AW).map((h) => h.trim());
      c === "stop-color" ? n = u : c === "stop-opacity" && (i = u);
    }
  }
  const o = new sn(n || r.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: Xw(r.getAttribute("offset"), 0), color: o.toRgb(), opacity: Wa(parseFloat(i || r.getAttribute("stop-opacity") || ""), 1) * o.getAlpha() * e };
}
function DW(r, e) {
  const n = [], i = r.getElementsByTagName("stop"), s = Xw(e, 1);
  for (let o = i.length; o--; ) n.push(PW(i[o], s));
  return n;
}
function Yw(r) {
  return r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function qw(r) {
  return r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function ds(r, e) {
  return r.getAttribute(e);
}
function kW(r, e) {
  return function(n, i) {
    let s, { width: o, height: a, gradientUnits: l } = i;
    return Object.entries(n).reduce((c, u) => {
      let [h, d] = u;
      if (d === "Infinity") s = 1;
      else if (d === "-Infinity") s = 0;
      else {
        const p = typeof d == "string";
        s = p ? parseFloat(d) : d, p && $w(d) && (s *= 0.01, l === "pixels" && (h !== "x1" && h !== "x2" && h !== "r2" || (s *= o), h !== "y1" && h !== "y2" || (s *= a)));
      }
      return c[h] = s, c;
    }, {});
  }(Yw(r) === "linear" ? function(n) {
    return { x1: ds(n, "x1") || 0, y1: ds(n, "y1") || 0, x2: ds(n, "x2") || "100%", y2: ds(n, "y2") || 0 };
  }(r) : function(n) {
    return { x1: ds(n, "fx") || ds(n, "cx") || "50%", y1: ds(n, "fy") || ds(n, "cy") || "50%", r1: 0, x2: ds(n, "cx") || "50%", y2: ds(n, "cy") || "50%", r2: ds(n, "r") || "50%" };
  }(r), Ie(Ie({}, e), {}, { gradientUnits: qw(r) }));
}
class ch {
  constructor(e) {
    const { type: n = "linear", gradientUnits: i = "pixels", coords: s = {}, colorStops: o = [], offsetX: a = 0, offsetY: l = 0, gradientTransform: c, id: u } = e || {};
    Object.assign(this, { type: n, gradientUnits: i, coords: Ie(Ie({}, n === "radial" ? TW : jw), s), colorStops: o, offsetX: a, offsetY: l, gradientTransform: c, id: u ? "".concat(u, "_").concat(co()) : co() });
  }
  addColorStop(e) {
    for (const n in e) {
      const i = new sn(e[n]);
      this.colorStops.push({ offset: parseFloat(n), color: i.toRgb(), opacity: i.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return Ie(Ie({}, Tl(this, e)), {}, { type: this.type, coords: Ie({}, this.coords), colorStops: this.colorStops.map((n) => Ie({}, n)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = [], s = this.gradientTransform ? this.gradientTransform.concat() : Si.concat(), o = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((d) => Ie({}, d)).sort((d, p) => d.offset - p.offset);
    let l = -this.offsetX, c = -this.offsetY;
    var u;
    o === "objectBoundingBox" ? (l /= e.width, c /= e.height) : (l += e.width / 2, c += e.height / 2), (u = e) && typeof u._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (l -= e.pathOffset.x, c -= e.pathOffset.y), s[4] -= l, s[5] -= c;
    const h = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(o, '"'), 'gradientTransform="'.concat(n ? n + " " : "").concat(tu(s), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: d, y1: p, x2: f, y2: m } = this.coords;
      i.push("<linearGradient ", h, ' x1="', d, '" y1="', p, '" x2="', f, '" y2="', m, `">
`);
    } else if (this.type === "radial") {
      const { x1: d, y1: p, x2: f, y2: m, r1: _, r2: g } = this.coords, v = _ > g;
      i.push("<radialGradient ", h, ' cx="', v ? d : f, '" cy="', v ? p : m, '" r="', v ? _ : g, '" fx="', v ? f : d, '" fy="', v ? m : p, `">
`), v && (a.reverse(), a.forEach((b) => {
        b.offset = 1 - b.offset;
      }));
      const S = Math.min(_, g);
      if (S > 0) {
        const b = S / Math.max(_, g);
        a.forEach((x) => {
          x.offset += b * (1 - x.offset);
        });
      }
    }
    return a.forEach((d) => {
      let { color: p, offset: f, opacity: m } = d;
      i.push("<stop ", 'offset="', 100 * f + "%", '" style="stop-color:', p, m !== void 0 ? ";stop-opacity: " + m : ";", `"/>
`);
    }), i.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), i.join("");
  }
  toLive(e) {
    const { x1: n, y1: i, x2: s, y2: o, r1: a, r2: l } = this.coords, c = this.type === "linear" ? e.createLinearGradient(n, i, s, o) : e.createRadialGradient(n, i, a, s, o, l);
    return this.colorStops.forEach((u) => {
      let { color: h, opacity: d, offset: p } = u;
      c.addColorStop(p, d !== void 0 ? new sn(h).setAlpha(d).toRgba() : h);
    }), c;
  }
  static async fromObject(e) {
    const { colorStops: n, gradientTransform: i } = e;
    return new this(Ie(Ie({}, e), {}, { colorStops: n ? n.map((s) => Ie({}, s)) : void 0, gradientTransform: i ? [...i] : void 0 }));
  }
  static fromElement(e, n, i) {
    const s = qw(e), o = n._findCenterFromElement();
    return new this(Ie({ id: e.getAttribute("id") || void 0, type: Yw(e), coords: kW(e, { width: i.viewBoxWidth || i.width, height: i.viewBoxHeight || i.height }), colorStops: DW(e, i.opacity), gradientUnits: s, gradientTransform: ug(e.getAttribute("gradientTransform") || "") }, s === "pixels" ? { offsetX: n.width / 2 - o.x, offsetY: n.height / 2 - o.y } : { offsetX: 0, offsetY: 0 }));
  }
}
Re(ch, "type", "Gradient"), ht.setClass(ch, "gradient"), ht.setClass(ch, "linear"), ht.setClass(ch, "radial");
const RW = ["type", "source", "patternTransform"];
class Bp {
  get type() {
    return "pattern";
  }
  set type(e) {
    lo("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    Re(this, "repeat", "repeat"), Re(this, "offsetX", 0), Re(this, "offsetY", 0), Re(this, "crossOrigin", ""), this.id = co(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: n, crossOrigin: i } = this;
    return Ie(Ie({}, Tl(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: n, crossOrigin: i, offsetX: hn(this.offsetX, Gt.NUM_FRACTION_DIGITS), offsetY: hn(this.offsetY, Gt.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: n, height: i } = e;
    const { source: s, repeat: o, id: a } = this, l = Wa(this.offsetX / n, 0), c = Wa(this.offsetY / i, 0), u = o === "repeat-y" || o === "no-repeat" ? 1 + Math.abs(l || 0) : Wa(s.width / n, 0), h = o === "repeat-x" || o === "no-repeat" ? 1 + Math.abs(c || 0) : Wa(s.height / i, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(l, '" y="').concat(c, '" width="').concat(u, '" height="').concat(h, '">'), '<image x="0" y="0" width="'.concat(s.width, '" height="').concat(s.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, n) {
    let { type: i, source: s, patternTransform: o } = e, a = pn(e, RW);
    const l = await td(s, Ie(Ie({}, n), {}, { crossOrigin: a.crossOrigin }));
    return new this(Ie(Ie({}, a), {}, { patternTransform: o && o.slice(0), source: l }));
  }
}
Re(Bp, "type", "Pattern"), ht.setClass(Bp), ht.setClass(Bp, "pattern");
const LW = ["path", "left", "top"], IW = ["d"];
class io extends pi {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: i, left: s, top: o } = n, a = pn(n, LW);
    super(), Object.assign(this, io.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof s == "number" && this.set(Qt, s), typeof o == "number" && this.set(Fi, o);
  }
  _setPath(e, n) {
    this.path = hW(Array.isArray(e) ? e : xW(e)), this.setBoundingBox(n);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new He(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const n = -this.pathOffset.x, i = -this.pathOffset.y;
    e.beginPath();
    for (const s of this.path) switch (s[0]) {
      case "L":
        e.lineTo(s[1] + n, s[2] + i);
        break;
      case "M":
        e.moveTo(s[1] + n, s[2] + i);
        break;
      case "C":
        e.bezierCurveTo(s[1] + n, s[2] + i, s[3] + n, s[4] + i, s[5] + n, s[6] + i);
        break;
      case "Q":
        e.quadraticCurveTo(s[1] + n, s[2] + i, s[3] + n, s[4] + i);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Ie(Ie({}, super.toObject(e)), {}, { path: this.path.map((n) => n.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.toObject(e);
    return this.sourcePath && (delete n.path, n.sourcePath = this.sourcePath), n;
  }
  _toSVG() {
    const e = bW(this.path, Gt.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = Gt.NUM_FRACTION_DIGITS;
    return " translate(".concat(hn(-this.pathOffset.x, e), ", ").concat(hn(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const n = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  toSVG(e) {
    const n = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: n, height: i, pathOffset: s } = this._calcDimensions();
    this.set({ width: n, height: i, pathOffset: s }), e && this.setPositionByOrigin(s, It, It);
  }
  _calcBoundsFromPath() {
    const e = [];
    let n = 0, i = 0, s = 0, o = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        s = a[1], o = a[2], e.push({ x: n, y: i }, { x: s, y: o });
        break;
      case "M":
        s = a[1], o = a[2], n = s, i = o;
        break;
      case "C":
        e.push(...N1(s, o, a[1], a[2], a[3], a[4], a[5], a[6])), s = a[5], o = a[6];
        break;
      case "Q":
        e.push(...N1(s, o, a[1], a[2], a[1], a[2], a[3], a[4])), s = a[3], o = a[4];
        break;
      case "Z":
        s = n, o = i;
    }
    return br(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return Ie(Ie({}, e), {}, { pathOffset: new He(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, this.ATTRIBUTE_NAMES, i), { d: o } = s;
    return new this(o, Ie(Ie(Ie({}, pn(s, IW)), n), {}, { left: void 0, top: void 0 }));
  }
}
Re(io, "type", "Path"), Re(io, "cacheProperties", [...Rr, "path", "fillRule"]), Re(io, "ATTRIBUTE_NAMES", [...go, "d"]), ht.setClass(io), ht.setSVGClass(io);
const OW = ["left", "top", "radius"], Zw = ["radius", "startAngle", "endAngle", "counterClockwise"];
class ur extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), ur.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, ur.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    return super._set(e, n), e === "radius" && this.setRadius(n), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, On(this.startAngle), On(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(Bi);
  }
  getRadiusY() {
    return this.get("radius") * this.get(ss);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Zw, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: n } = this, i = On(this.startAngle), s = On(this.endAngle), o = Er(i) * n, a = Ar(i) * n, l = Er(s) * n, c = Ar(s) * n, u = e > 180 ? 1 : 0, h = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(o, " ").concat(a, " A ").concat(n, " ").concat(n, " 0 ").concat(u, " ").concat(h, " ").concat(l, " ").concat(c, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, this.ATTRIBUTE_NAMES, i), { left: o = 0, top: a = 0, radius: l = 0 } = s;
    return new this(Ie(Ie({}, pn(s, OW)), {}, { radius: l, left: o - l, top: a - l }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
Re(ur, "type", "Circle"), Re(ur, "cacheProperties", [...Rr, ...Zw]), Re(ur, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), Re(ur, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...go]), ht.setClass(ur), ht.setSVGClass(ur);
const FW = ["x1", "y1", "x2", "y2"], UW = ["x1", "y1", "x2", "y2"], mg = ["x1", "x2", "y1", "y2"];
class Go extends pi {
  constructor() {
    let [e, n, i, s] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Go.ownDefaults), this.setOptions(o), this.x1 = e, this.x2 = i, this.y1 = n, this.y2 = s, this._setWidthHeight();
    const { left: a, top: l } = o;
    typeof a == "number" && this.set(Qt, a), typeof l == "number" && this.set(Fi, l);
  }
  _setWidthHeight() {
    const { x1: e, y1: n, x2: i, y2: s } = this;
    this.width = Math.abs(i - e), this.height = Math.abs(s - n);
    const { left: o, top: a, width: l, height: c } = br([{ x: e, y: n }, { x: i, y: s }]), u = new He(o + l / 2, a + c / 2);
    this.setPositionByOrigin(u, It, It);
  }
  _set(e, n) {
    return super._set(e, n), mg.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const n = this.calcLinePoints();
    e.moveTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineWidth = this.strokeWidth;
    const i = e.strokeStyle;
    var s;
    es(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (s = this.stroke) !== null && s !== void 0 ? s : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = i;
  }
  _findCenterFromElement() {
    return new He((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Ie(Ie({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: n, y1: i, y2: s, width: o, height: a } = this, l = e <= n ? -1 : 1, c = i <= s ? -1 : 1;
    return { x1: l * o / 2, x2: l * -o / 2, y1: c * a / 2, y2: c * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: n, y1: i, y2: s } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(i, '" x2="').concat(n, '" y2="').concat(s, `" />
`)];
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, this.ATTRIBUTE_NAMES, i), { x1: o = 0, y1: a = 0, x2: l = 0, y2: c = 0 } = s;
    return new this([o, a, l, c], pn(s, FW));
  }
  static fromObject(e) {
    let { x1: n, y1: i, x2: s, y2: o } = e, a = pn(e, UW);
    return this._fromObject(Ie(Ie({}, a), {}, { points: [n, i, s, o] }), { extraParam: "points" });
  }
}
Re(Go, "type", "Line"), Re(Go, "cacheProperties", [...Rr, ...mg]), Re(Go, "ATTRIBUTE_NAMES", go.concat(mg)), ht.setClass(Go), ht.setSVGClass(Go);
class $o extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), $o.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, $o.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const n = this.width / 2, i = this.height / 2;
    e.beginPath(), e.moveTo(-n, i), e.lineTo(0, -i), e.lineTo(n, i), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, n = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(n, ",0 ").concat(-n, ",").concat(e, " ").concat(n), '" />'];
  }
}
Re($o, "type", "Triangle"), Re($o, "ownDefaults", { width: 100, height: 100 }), ht.setClass($o), ht.setSVGClass($o);
const Kw = ["rx", "ry"];
class hr extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), hr.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, hr.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    switch (super._set(e, n), e) {
      case "rx":
        this.rx = n, this.set("width", 2 * n);
        break;
      case "ry":
        this.ry = n, this.set("height", 2 * n);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(Bi);
  }
  getRy() {
    return this.get("ry") * this.get(ss);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Kw, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, Td, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, this.ATTRIBUTE_NAMES, i);
    return s.left = (s.left || 0) - s.rx, s.top = (s.top || 0) - s.ry, new this(s);
  }
}
function zW(r) {
  if (!r) return [];
  const e = r.replace(/,/g, " ").trim().split(/\s+/), n = [];
  for (let i = 0; i < e.length; i += 2) n.push({ x: parseFloat(e[i]), y: parseFloat(e[i + 1]) });
  return n;
}
Re(hr, "type", "Ellipse"), Re(hr, "cacheProperties", [...Rr, ...Kw]), Re(hr, "ownDefaults", { rx: 0, ry: 0 }), Re(hr, "ATTRIBUTE_NAMES", [...go, "cx", "cy", "rx", "ry"]), ht.setClass(hr), ht.setSVGClass(hr);
const BW = ["left", "top"], Jw = { exactBoundingBox: !1 };
class ms extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), ms.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Re(this, "strokeDiff", void 0), Object.assign(this, ms.ownDefaults), this.setOptions(n), this.points = e;
    const { left: i, top: s } = n;
    this.initialized = !0, this.setBoundingBox(!0), typeof i == "number" && this.set(Qt, i), typeof s == "number" && this.set(Fi, s);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return AH(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = Ie({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const n = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((u) => u.projectedPoint) : this.points;
    if (n.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new He(), strokeOffset: new He(), strokeDiff: new He() };
    const i = br(n), s = mf(Ie(Ie({}, e), {}, { scaleX: 1, scaleY: 1 })), o = br(this.points.map((u) => ki(u, s, !0))), a = new He(this.scaleX, this.scaleY);
    let l = i.left + i.width / 2, c = i.top + i.height / 2;
    return this.exactBoundingBox && (l -= c * Math.tan(On(this.skewX)), c -= l * Math.tan(On(this.skewY))), Ie(Ie({}, i), {}, { pathOffset: new He(l, c), strokeOffset: new He(o.left, o.top).subtract(new He(i.left, i.top)).multiply(a), strokeDiff: new He(i.width, i.height).subtract(new He(o.width, o.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = br(this.points);
    return new He(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: n, top: i, width: s, height: o, pathOffset: a, strokeOffset: l, strokeDiff: c } = this._calcDimensions();
    this.set({ width: s, height: o, pathOffset: a, strokeOffset: l, strokeDiff: c }), e && this.setPositionByOrigin(new He(n + s / 2, i + o / 2), It, It);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new He(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((l) => this.strokeUniform || this.constructor.layoutProperties.includes(l))) {
        var n, i;
        const { width: l, height: c } = this._calcDimensions(e);
        a = new He((n = e.width) !== null && n !== void 0 ? n : l, (i = e.height) !== null && i !== void 0 ? i : c);
      } else {
        var s, o;
        a = new He((s = e.width) !== null && s !== void 0 ? s : this.width, (o = e.height) !== null && o !== void 0 ? o : this.height);
      }
      return a.multiply(new He(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, n) {
    const i = this.initialized && this[e] !== n, s = super._set(e, n);
    return this.exactBoundingBox && i && ((e === Bi || e === ss) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), s;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Ie(Ie({}, super.toObject(e)), {}, { points: this.points.map((n) => {
      let { x: i, y: s } = n;
      return { x: i, y: s };
    }) });
  }
  _toSVG() {
    const e = [], n = this.pathOffset.x, i = this.pathOffset.y, s = Gt.NUM_FRACTION_DIGITS;
    for (let o = 0, a = this.points.length; o < a; o++) e.push(hn(this.points[o].x - n, s), ",", hn(this.points[o].y - i, s), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const n = this.points.length, i = this.pathOffset.x, s = this.pathOffset.y;
    if (n && !isNaN(this.points[n - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - i, this.points[0].y - s);
      for (let o = 0; o < n; o++) {
        const a = this.points[o];
        e.lineTo(a.x - i, a.y - s);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, n, i) {
    return new this(zW(e.getAttribute("points")), Ie(Ie({}, pn(Lr(e, this.ATTRIBUTE_NAMES, i), BW)), n));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
Re(ms, "ownDefaults", Jw), Re(ms, "type", "Polyline"), Re(ms, "layoutProperties", [Sl, Ml, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), Re(ms, "cacheProperties", [...Rr, "points"]), Re(ms, "ATTRIBUTE_NAMES", [...go]), ht.setClass(ms), ht.setSVGClass(ms);
class uh extends ms {
  isOpen() {
    return !1;
  }
}
Re(uh, "ownDefaults", Jw), Re(uh, "type", "Polygon"), ht.setClass(uh), ht.setSVGClass(uh);
class Qw extends pi {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const n = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const i in n) for (const s in n[i]) for (const o in n[i][s]) return !1;
    return !0;
  }
  styleHas(e, n) {
    if (!this.styles || n !== void 0 && !this.styles[n]) return !1;
    const i = n === void 0 ? this.styles : { 0: this.styles[n] };
    for (const s in i) for (const o in i[s]) if (i[s][o][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const n = this.styles;
    let i, s, o = 0, a = !0, l = 0;
    for (const c in n) {
      i = 0;
      for (const u in n[c]) {
        const h = n[c][u] || {};
        o++, h[e] !== void 0 ? (s ? h[e] !== s && (a = !1) : s = h[e], h[e] === this[e] && delete h[e]) : a = !1, Object.keys(h).length !== 0 ? i++ : delete n[c][u];
      }
      i === 0 && delete n[c];
    }
    for (let c = 0; c < this._textLines.length; c++) l += this._textLines[c].length;
    a && o === l && (this[e] = s, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const n = this.styles;
    let i, s, o;
    for (s in n) {
      for (o in i = n[s], i) delete i[o][e], Object.keys(i[o]).length === 0 && delete i[o];
      Object.keys(i).length === 0 && delete n[s];
    }
  }
  _extendStyles(e, n) {
    const { lineIndex: i, charIndex: s } = this.get2DCursorLocation(e);
    this._getLineStyle(i) || this._setLineStyle(i);
    const o = bv(Ie(Ie({}, this._getStyleDeclaration(i, s)), n), (a) => a !== void 0);
    this._setStyleDeclaration(i, s, o);
  }
  getSelectionStyles(e, n, i) {
    const s = [];
    for (let o = e; o < (n || e); o++) s.push(this.getStyleAtPosition(o, i));
    return s;
  }
  getStyleAtPosition(e, n) {
    const { lineIndex: i, charIndex: s } = this.get2DCursorLocation(e);
    return n ? this.getCompleteStyleDeclaration(i, s) : this._getStyleDeclaration(i, s);
  }
  setSelectionStyles(e, n, i) {
    for (let s = n; s < (i || n); s++) this._extendStyles(s, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, n) {
    var i;
    const s = this.styles && this.styles[e];
    return s && (i = s[n]) !== null && i !== void 0 ? i : {};
  }
  getCompleteStyleDeclaration(e, n) {
    return Ie(Ie({}, Tl(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, n));
  }
  _setStyleDeclaration(e, n, i) {
    this.styles[e][n] = i;
  }
  _deleteStyleDeclaration(e, n) {
    delete this.styles[e][n];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
Re(Qw, "_styleProperties", WG);
const NW = /  +/g, VW = /"/g;
function Np(r, e, n, i, s) {
  return "		".concat(function(o, a) {
    let { left: l, top: c, width: u, height: h } = a, d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Gt.NUM_FRACTION_DIGITS;
    const p = nu(Hn, o, !1), [f, m, _, g] = [l, c, u, h].map((v) => hn(v, d));
    return "<rect ".concat(p, ' x="').concat(f, '" y="').concat(m, '" width="').concat(_, '" height="').concat(g, '"></rect>');
  }(r, { left: e, top: n, width: i, height: s }), `
`);
}
const GW = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let Vp;
class ui extends Qw {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), ui.ownDefaults);
  }
  constructor(e, n) {
    super(), Re(this, "__charBounds", []), Object.assign(this, ui.ownDefaults), this.setOptions(n), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = Ww(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(Bs) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, n, i, s, o, a, l;
    for (let c = 0, u = this._textLines.length; c < u; c++) if ((this.textAlign === Bs || c !== u - 1 && !this.isEndOfWrapping(c)) && (s = 0, o = this._textLines[c], n = this.getLineWidth(c), n < this.width && (l = this.textLines[c].match(this._reSpacesAndTabs)))) {
      i = l.length, e = (this.width - n) / i;
      for (let h = 0; h <= o.length; h++) a = this.__charBounds[c][h], this._reSpaceAndTab.test(o[h]) ? (a.width += e, a.kernedWidth += e, a.left += s, s += e) : a.left += s;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, n) {
    const i = n ? this._unwrappedTextLines : this._textLines;
    let s;
    for (s = 0; s < i.length; s++) {
      if (e <= i[s].length) return { lineIndex: s, charIndex: e };
      e -= i[s].length + this.missingNewlineOffset(s, n);
    }
    return { lineIndex: s - 1, charIndex: i[s - 1].length < e ? i[s - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), n = this.fontSize;
    return e.width += n * e.zoomX, e.height += n * e.zoomY, e;
  }
  _render(e) {
    const n = this.path;
    n && !n.isNotVisible() && n._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === zi ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, n, i) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case It:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = Fi;
        break;
      case "descender":
        e.textBaseline = sg;
    }
    e.font = this._getFontDeclaration(n, i);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let n = 1, i = this._textLines.length; n < i; n++) {
      const s = this.getLineWidth(n);
      s > e && (e = s);
    }
    return e;
  }
  _renderTextLine(e, n, i, s, o, a) {
    this._renderChars(e, n, i, s, o, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const n = e.fillStyle, i = this._getLeftOffset();
    let s = this._getTopOffset();
    for (let o = 0, a = this._textLines.length; o < a; o++) {
      const l = this.getHeightOfLine(o);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", o)) {
        s += l;
        continue;
      }
      const c = this._textLines[o].length, u = this._getLineLeftOffset(o);
      let h, d, p = 0, f = 0, m = this.getValueOfPropertyAt(o, 0, "textBackgroundColor");
      const _ = this.getHeightOfLineImpl(o);
      for (let g = 0; g < c; g++) {
        const v = this.__charBounds[o][g];
        d = this.getValueOfPropertyAt(o, g, "textBackgroundColor"), this.path ? (e.save(), e.translate(v.renderLeft, v.renderTop), e.rotate(v.angle), e.fillStyle = d, d && e.fillRect(-v.width / 2, -_ * (1 - this._fontSizeFraction), v.width, _), e.restore()) : d !== m ? (h = i + u + f, this.direction === "rtl" && (h = this.width - h - p), e.fillStyle = m, m && e.fillRect(h, s, p, _), f = v.left, p = v.width, m = d) : p += v.kernedWidth;
      }
      d && !this.path && (h = i + u + f, this.direction === "rtl" && (h = this.width - h - p), e.fillStyle = d, e.fillRect(h, s, p, _)), s += l;
    }
    e.fillStyle = n, this._removeShadow(e);
  }
  _measureChar(e, n, i, s) {
    const o = Ac.getFontCache(n), a = this._getFontDeclaration(n), l = i + e, c = i && a === this._getFontDeclaration(s), u = n.fontSize / this.CACHE_FONT_SIZE;
    let h, d, p, f;
    if (i && o.has(i) && (p = o.get(i)), o.has(e) && (f = h = o.get(e)), c && o.has(l) && (d = o.get(l), f = d - p), h === void 0 || p === void 0 || d === void 0) {
      const m = function() {
        return Vp || (Vp = rs({ width: 0, height: 0 }).getContext("2d")), Vp;
      }();
      this._setTextStyles(m, n, !0), h === void 0 && (f = h = m.measureText(e).width, o.set(e, h)), p === void 0 && c && i && (p = m.measureText(i).width, o.set(i, p)), c && d === void 0 && (d = m.measureText(l).width, o.set(l, d), f = d - p);
    }
    return { width: h * u, kernedWidth: f * u };
  }
  getHeightOfChar(e, n) {
    return this.getValueOfPropertyAt(e, n, "fontSize");
  }
  measureLine(e) {
    const n = this._measureLine(e);
    return this.charSpacing !== 0 && (n.width -= this._getWidthOfCharSpacing()), n.width < 0 && (n.width = 0), n;
  }
  _measureLine(e) {
    let n, i, s = 0;
    const o = this.pathSide === In, a = this.path, l = this._textLines[e], c = l.length, u = new Array(c);
    this.__charBounds[e] = u;
    for (let h = 0; h < c; h++) {
      const d = l[h];
      i = this._getGraphemeBox(d, e, h, n), u[h] = i, s += i.kernedWidth, n = d;
    }
    if (u[c] = { left: i ? i.left + i.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let h = 0;
      const d = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case Qt:
          h = o ? d - s : 0;
          break;
        case It:
          h = (d - s) / 2;
          break;
        case In:
          h = o ? 0 : d - s;
      }
      h += this.pathStartOffset * (o ? -1 : 1);
      for (let p = o ? c - 1 : 0; o ? p >= 0 : p < c; o ? p-- : p++) i = u[p], h > d ? h %= d : h < 0 && (h += d), this._setGraphemeOnPath(h, i), h += i.kernedWidth;
    }
    return { width: s, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, n) {
    const i = e + n.kernedWidth / 2, s = this.path, o = gW(s.path, i, s.segmentsInfo);
    n.renderLeft = o.x - s.pathOffset.x, n.renderTop = o.y - s.pathOffset.y, n.angle = o.angle + (this.pathSide === In ? Math.PI : 0);
  }
  _getGraphemeBox(e, n, i, s, o) {
    const a = this.getCompleteStyleDeclaration(n, i), l = s ? this.getCompleteStyleDeclaration(n, i - 1) : {}, c = this._measureChar(e, a, s, l);
    let u, h = c.kernedWidth, d = c.width;
    this.charSpacing !== 0 && (u = this._getWidthOfCharSpacing(), d += u, h += u);
    const p = { width: d, left: 0, height: a.fontSize, kernedWidth: h, deltaY: a.deltaY };
    if (i > 0 && !o) {
      const f = this.__charBounds[n][i - 1];
      p.left = f.left + f.width + c.kernedWidth - c.width;
    }
    return p;
  }
  getHeightOfLineImpl(e) {
    const n = this.__lineHeights;
    if (n[e]) return n[e];
    let i = this.getHeightOfChar(e, 0);
    for (let s = 1, o = this._textLines[e].length; s < o; s++) i = Math.max(this.getHeightOfChar(e, s), i);
    return n[e] = i * this._fontSizeMult;
  }
  getHeightOfLine(e) {
    return this.getHeightOfLineImpl(e) * this.lineHeight;
  }
  calcTextHeight() {
    let e = 0;
    for (let n = 0, i = this._textLines.length; n < i; n++) e += n === i - 1 ? this.getHeightOfLineImpl(n) : this.getHeightOfLine(n);
    return e;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, n) {
    e.save();
    let i = 0;
    const s = this._getLeftOffset(), o = this._getTopOffset();
    for (let a = 0, l = this._textLines.length; a < l; a++) this._renderTextLine(n, e, this._textLines[a], s + this._getLineLeftOffset(a), o + i + this.getHeightOfLineImpl(a), a), i += this.getHeightOfLine(a);
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Hn)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, n, i, s, o, a) {
    const l = this.textAlign.includes(Bs), c = this.path, u = !l && this.charSpacing === 0 && this.isEmptyStyles(a) && !c, h = this.direction === "ltr", d = this.direction === "ltr" ? 1 : -1, p = n.direction;
    let f, m, _, g, v, S = "", b = 0;
    if (n.save(), p !== this.direction && (n.canvas.setAttribute("dir", h ? "ltr" : "rtl"), n.direction = h ? "ltr" : "rtl", n.textAlign = h ? Qt : In), o -= this.getHeightOfLineImpl(a) * this._fontSizeFraction, u) return this._renderChar(e, n, a, 0, i.join(""), s, o), void n.restore();
    for (let x = 0, M = i.length - 1; x <= M; x++) g = x === M || this.charSpacing || c, S += i[x], _ = this.__charBounds[a][x], b === 0 ? (s += d * (_.kernedWidth - _.width), b += _.width) : b += _.kernedWidth, l && !g && this._reSpaceAndTab.test(i[x]) && (g = !0), g || (f = f || this.getCompleteStyleDeclaration(a, x), m = this.getCompleteStyleDeclaration(a, x + 1), g = Pv(f, m, !1)), g && (c ? (n.save(), n.translate(_.renderLeft, _.renderTop), n.rotate(_.angle), this._renderChar(e, n, a, x, S, -b / 2, 0), n.restore()) : (v = s, this._renderChar(e, n, a, x, S, v, o)), S = "", f = m, s += d * b, b = 0);
    n.restore();
  }
  _applyPatternGradientTransformText(e) {
    const n = this.width + this.strokeWidth, i = this.height + this.strokeWidth, s = rs({ width: n, height: i }), o = s.getContext("2d");
    return s.width = n, s.height = i, o.beginPath(), o.moveTo(0, 0), o.lineTo(n, 0), o.lineTo(n, i), o.lineTo(0, i), o.closePath(), o.translate(n / 2, i / 2), o.fillStyle = e.toLive(o), this._applyPatternGradientTransform(o, e), o.fill(), o.createPattern(s, "no-repeat");
  }
  handleFiller(e, n, i) {
    let s, o;
    return es(i) ? i.gradientUnits === "percentage" || i.gradientTransform || i.patternTransform ? (s = -this.width / 2, o = -this.height / 2, e.translate(s, o), e[n] = this._applyPatternGradientTransformText(i), { offsetX: s, offsetY: o }) : (e[n] = i.toLive(e), this._applyPatternGradientTransform(e, i)) : (e[n] = i, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, n) {
    let { stroke: i, strokeWidth: s } = n;
    return e.lineWidth = s, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", i);
  }
  _setFillStyles(e, n) {
    let { fill: i } = n;
    return this.handleFiller(e, "fillStyle", i);
  }
  _renderChar(e, n, i, s, o, a, l) {
    const c = this._getStyleDeclaration(i, s), u = this.getCompleteStyleDeclaration(i, s), h = e === "fillText" && u.fill, d = e === "strokeText" && u.stroke && u.strokeWidth;
    if (d || h) {
      if (n.save(), n.font = this._getFontDeclaration(u), c.textBackgroundColor && this._removeShadow(n), c.deltaY && (l += c.deltaY), h) {
        const p = this._setFillStyles(n, u);
        n.fillText(o, a - p.offsetX, l - p.offsetY);
      }
      if (d) {
        const p = this._setStrokeStyles(n, u);
        n.strokeText(o, a - p.offsetX, l - p.offsetY);
      }
      n.restore();
    }
  }
  setSuperscript(e, n) {
    this._setScript(e, n, this.superscript);
  }
  setSubscript(e, n) {
    this._setScript(e, n, this.subscript);
  }
  _setScript(e, n, i) {
    const s = this.get2DCursorLocation(e, !0), o = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "fontSize"), a = this.getValueOfPropertyAt(s.lineIndex, s.charIndex, "deltaY"), l = { fontSize: o * i.size, deltaY: a + o * i.baseline };
    this.setSelectionStyles(l, e, n);
  }
  _getLineLeftOffset(e) {
    const n = this.getLineWidth(e), i = this.width - n, s = this.textAlign, o = this.direction, a = this.isEndOfWrapping(e);
    let l = 0;
    return s === Bs || s === Dc && !a || s === Pc && !a || s === Id && !a ? 0 : (s === It && (l = i / 2), s === In && (l = i), s === Dc && (l = i / 2), s === Pc && (l = i), o === "rtl" && (s === In || s === Bs || s === Pc ? l = 0 : s === Qt || s === Id ? l = -i : s !== It && s !== Dc || (l = -i / 2)), l);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: n } = this.measureLine(e);
    return this.__lineWidths[e] = n, n;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, n, i) {
    var s;
    return (s = this._getStyleDeclaration(e, n)[i]) !== null && s !== void 0 ? s : this[i];
  }
  _renderTextDecoration(e, n) {
    if (!this[n] && !this.styleHas(n)) return;
    let i = this._getTopOffset();
    const s = this._getLeftOffset(), o = this.path, a = this._getWidthOfCharSpacing(), l = n === "linethrough" ? 0.5 : n === "overline" ? 1 : 0, c = this.offsets[n];
    for (let u = 0, h = this._textLines.length; u < h; u++) {
      const d = this.getHeightOfLine(u);
      if (!this[n] && !this.styleHas(n, u)) {
        i += d;
        continue;
      }
      const p = this._textLines[u], f = d / this.lineHeight, m = this._getLineLeftOffset(u);
      let _ = 0, g = 0, v = this.getValueOfPropertyAt(u, 0, n), S = this.getValueOfPropertyAt(u, 0, Hn), b = this.getValueOfPropertyAt(u, 0, ia), x = v, M = S, C = b;
      const E = i + f * (1 - this._fontSizeFraction);
      let T = this.getHeightOfChar(u, 0), w = this.getValueOfPropertyAt(u, 0, "deltaY");
      for (let U = 0, D = p.length; U < D; U++) {
        const L = this.__charBounds[u][U];
        x = this.getValueOfPropertyAt(u, U, n), M = this.getValueOfPropertyAt(u, U, Hn), C = this.getValueOfPropertyAt(u, U, ia);
        const P = this.getHeightOfChar(u, U), V = this.getValueOfPropertyAt(u, U, "deltaY");
        if (o && x && M) {
          const ce = this.fontSize * C / 1e3;
          e.save(), e.fillStyle = S, e.translate(L.renderLeft, L.renderTop), e.rotate(L.angle), e.fillRect(-L.kernedWidth / 2, c * P + V - l * ce, L.kernedWidth, ce), e.restore();
        } else if ((x !== v || M !== S || P !== T || C !== b || V !== w) && g > 0) {
          const ce = this.fontSize * b / 1e3;
          let q = s + m + _;
          this.direction === "rtl" && (q = this.width - q - g), v && S && b && (e.fillStyle = S, e.fillRect(q, E + c * T + w - l * ce, g, ce)), _ = L.left, g = L.width, v = x, b = C, S = M, T = P, w = V;
        } else g += L.kernedWidth;
      }
      let A = s + m + _;
      this.direction === "rtl" && (A = this.width - A - g), e.fillStyle = M;
      const O = this.fontSize * C / 1e3;
      x && M && C && e.fillRect(A, E + c * T + w - l * O, g - a, O), i += d;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: n = this.fontStyle, fontWeight: i = this.fontWeight, fontSize: s = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || ui.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [n, i, "".concat(o ? this.CACHE_FONT_SIZE : s, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return Av(e);
  }
  _splitTextIntoLines(e) {
    const n = e.split(this._reNewline), i = new Array(n.length), s = [`
`];
    let o = [];
    for (let a = 0; a < n.length; a++) i[a] = this.graphemeSplit(n[a]), o = o.concat(i[a], s);
    return o.pop(), { _unwrappedLines: i, lines: n, graphemeText: o, graphemeLines: i };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Ie(Ie({}, super.toObject([...Tw, ...e])), {}, { styles: RH(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, n) {
    const { textLayoutProperties: i } = this.constructor;
    super.set(e, n);
    let s = !1, o = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), s = s || i.includes(a), o = o || a === "path";
    else s = i.includes(e), o = e === "path";
    return o && this.setPathInfo(), s && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, n, i) {
    const s = Lr(e, ui.ATTRIBUTE_NAMES, i), o = Ie(Ie({}, n), s), { textAnchor: a = Qt, textDecoration: l = "", dx: c = 0, dy: u = 0, top: h = 0, left: d = 0, fontSize: p = mv, strokeWidth: f = 1 } = o, m = pn(o, GW), _ = new this(Ld(e.textContent || "").trim(), Ie({ left: d + c, top: h + u, underline: l.includes("underline"), overline: l.includes("overline"), linethrough: l.includes("line-through"), strokeWidth: 0, fontSize: p }, m)), g = _.getScaledHeight() / _.height, v = ((_.height + _.strokeWidth) * _.lineHeight - _.height) * g, S = _.getScaledHeight() + v;
    let b = 0;
    return a === It && (b = _.getScaledWidth() / 2), a === In && (b = _.getScaledWidth()), _.set({ left: _.left - b, top: _.top - (S - _.fontSize * (0.07 + _._fontSizeFraction)) / _.lineHeight, strokeWidth: f }), _;
  }
  static fromObject(e) {
    return this._fromObject(Ie(Ie({}, e), {}, { styles: LH(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
Re(ui, "textLayoutProperties", Cw), Re(ui, "cacheProperties", [...Rr, ...Tw]), Re(ui, "ownDefaults", jG), Re(ui, "type", "Text"), Re(ui, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), Re(ui, "ATTRIBUTE_NAMES", go.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), Ow(ui, [class extends ww {
  _toSVG() {
    const r = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(r.textTop, r.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(r) {
    const e = this._createBaseSVGMarkup(this._toSVG(), { reviver: r, noStyle: !0, withShadow: !0 }), n = this.path;
    return n ? e + n._createBaseSVGMarkup(n._toSVG(), { reviver: r, withShadow: !0, additionalTransform: tu(this.calcOwnMatrix()) }) : e;
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(r) {
    let { textBgRects: e, textSpans: n } = r;
    const i = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', 'font-family="'.concat(this.fontFamily.replace(VW, "'"), '" '), 'font-size="'.concat(this.fontSize, '" '), this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", i ? 'text-decoration="'.concat(i, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", n.join(""), `</text>
`];
  }
  _getSVGTextAndBg(r, e) {
    const n = [], i = [];
    let s, o = r;
    this.backgroundColor && i.push(...Np(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, l = this._textLines.length; a < l; a++) s = this._getLineLeftOffset(a), this.direction === "rtl" && (s += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(i, a, e + s, o), this._setSVGTextLineText(n, a, e + s, o), o += this.getHeightOfLine(a);
    return { textSpans: n, textBgRects: i };
  }
  _createTextCharSpan(r, e, n, i, s) {
    const o = Gt.NUM_FRACTION_DIGITS, a = this.getSvgSpanStyles(e, r !== r.trim() || !!r.match(NW)), l = a ? 'style="'.concat(a, '"') : "", c = e.deltaY, u = c ? ' dy="'.concat(hn(c, o), '" ') : "", { angle: h, renderLeft: d, renderTop: p, width: f } = s;
    let m = "";
    if (d !== void 0) {
      const _ = f / 2;
      h && (m = ' rotate="'.concat(hn(Dr(h), o), '"'));
      const g = Cl({ angle: Dr(h) });
      g[4] = d, g[5] = p;
      const v = new He(-_, 0).transform(g);
      n = v.x, i = v.y;
    }
    return '<tspan x="'.concat(hn(n, o), '" y="').concat(hn(i, o), '" ').concat(u).concat(m).concat(l, ">").concat(PH(r), "</tspan>");
  }
  _setSVGTextLineText(r, e, n, i) {
    const s = this.getHeightOfLine(e), o = this.textAlign.includes(Bs), a = this._textLines[e];
    let l, c, u, h, d, p = "", f = 0;
    i += s * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let m = 0, _ = a.length - 1; m <= _; m++) d = m === _ || this.charSpacing || this.path, p += a[m], u = this.__charBounds[e][m], f === 0 ? (n += u.kernedWidth - u.width, f += u.width) : f += u.kernedWidth, o && !d && this._reSpaceAndTab.test(a[m]) && (d = !0), d || (l = l || this.getCompleteStyleDeclaration(e, m), c = this.getCompleteStyleDeclaration(e, m + 1), d = Pv(l, c, !0)), d && (h = this._getStyleDeclaration(e, m), r.push(this._createTextCharSpan(p, h, n, i, u)), p = "", l = c, this.direction === "rtl" ? n -= f : n += f, f = 0);
  }
  _setSVGTextLineBg(r, e, n, i) {
    const s = this._textLines[e], o = this.getHeightOfLine(e) / this.lineHeight;
    let a, l = 0, c = 0, u = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let h = 0; h < s.length; h++) {
      const { left: d, width: p, kernedWidth: f } = this.__charBounds[e][h];
      a = this.getValueOfPropertyAt(e, h, "textBackgroundColor"), a !== u ? (u && r.push(...Np(u, n + c, i, l, o)), c = d, l = p, u = a) : l += f;
    }
    a && r.push(...Np(u, n + c, i, l, o));
  }
  _getSVGLineTopOffset(r) {
    let e, n = 0;
    for (e = 0; e < r; e++) n += this.getHeightOfLine(e);
    const i = this.getHeightOfLine(e);
    return { lineTop: n, offset: (this._fontSizeMult - this._fontSizeFraction) * i / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(r) {
    return "".concat(super.getSvgStyles(r), " text-decoration-thickness: ").concat(hn(this.textDecorationThickness * this.getObjectScaling().y / 10, Gt.NUM_FRACTION_DIGITS), "%; white-space: pre;");
  }
  getSvgSpanStyles(r, e) {
    const { fontFamily: n, strokeWidth: i, stroke: s, fill: o, fontSize: a, fontStyle: l, fontWeight: c, deltaY: u, textDecorationThickness: h, linethrough: d, overline: p, underline: f } = r, m = this.getSvgTextDecoration({ underline: f ?? this.underline, overline: p ?? this.overline, linethrough: d ?? this.linethrough }), _ = h || this.textDecorationThickness;
    return [s ? nu(zi, s) : "", i ? "stroke-width: ".concat(i, "; ") : "", n ? "font-family: ".concat(n.includes("'") || n.includes('"') ? n : "'".concat(n, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", l ? "font-style: ".concat(l, "; ") : "", c ? "font-weight: ".concat(c, "; ") : "", m ? "text-decoration: ".concat(m, "; text-decoration-thickness: ").concat(hn(_ * this.getObjectScaling().y / 10, Gt.NUM_FRACTION_DIGITS), "%; ") : "", o ? nu(Hn, o) : "", u ? "baseline-shift: ".concat(-u, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(r) {
    return ["overline", "underline", "line-through"].filter((e) => r[e.replace("-", "")]).join(" ");
  }
}]), ht.setClass(ui), ht.setSVGClass(ui);
class HW {
  constructor(e) {
    Re(this, "target", void 0), Re(this, "__mouseDownInPlace", !1), Re(this, "__dragStartFired", !1), Re(this, "__isDraggingOver", !1), Re(this, "__dragStartSelection", void 0), Re(this, "__dragImageDisposer", void 0), Re(this, "_dispose", void 0), this.target = e;
    const n = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      n.forEach((i) => i()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const n = this.target, i = n.getSelectionStartFromPointer(e);
    return n.isEditing && i >= n.selectionStart && i <= n.selectionEnd && n.selectionStart < n.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const n = this.isActive();
    return n && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, n;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, n) {
    var i;
    let { selectionStart: s, selectionEnd: o } = n;
    const a = this.target, l = a.canvas, c = new He(a.flipX ? -1 : 1, a.flipY ? -1 : 1), u = a._getCursorBoundaries(s), h = new He(u.left + u.leftOffset, u.top + u.topOffset).multiply(c).transform(a.calcTransformMatrix()), d = l.getScenePoint(e).subtract(h), p = a.getCanvasRetinaScaling(), f = a.getBoundingRect(), m = h.subtract(new He(f.left, f.top)), _ = l.viewportTransform, g = m.add(d).transform(_, !0), v = a.backgroundColor, S = Ev(a.styles);
    a.backgroundColor = "";
    const b = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(b, 0, s), a.setSelectionStyles(b, o, a.text.length), a.dirty = !0;
    const x = a.toCanvasElement({ enableRetinaScaling: l.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = v, a.styles = S, a.dirty = !0, fg(x, { position: "fixed", left: "".concat(-x.width, "px"), border: Ui, width: "".concat(x.width / p, "px"), height: "".concat(x.height / p, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      x.remove();
    }, _s(e.target || this.target.hiddenTextarea).body.appendChild(x), (i = e.dataTransfer) === null || i === void 0 || i.setDragImage(x, g.x, g.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const n = this.target, i = this.isActive();
    if (i && e.dataTransfer) {
      const s = this.__dragStartSelection = { selectionStart: n.selectionStart, selectionEnd: n.selectionEnd }, o = n._text.slice(s.selectionStart, s.selectionEnd).join(""), a = Ie({ text: n.text, value: o }, s);
      e.dataTransfer.setData("text/plain", o), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: o, styles: n.getSelectionStyles(s.selectionStart, s.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return n.abortCursorAnimation(), i;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const n = this.target.getSelectionStartFromPointer(e), i = this.__dragStartSelection;
        return n < i.selectionStart || n > i.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: n } = e;
    const i = this.targetCanDrop(n);
    !this.__isDraggingOver && i && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: n } = e, i = this.targetCanDrop(n);
    !this.__isDraggingOver && i ? this.__isDraggingOver = !0 : this.__isDraggingOver && !i && (this.__isDraggingOver = !1), this.__isDraggingOver && (n.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var n;
    const { e: i } = e, s = i.defaultPrevented;
    this.__isDraggingOver = !1, i.preventDefault();
    let o = (n = i.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain");
    if (o && !s) {
      const a = this.target, l = a.canvas;
      let c = a.getSelectionStartFromPointer(i);
      const { styles: u } = i.dataTransfer.types.includes("application/fabric") ? JSON.parse(i.dataTransfer.getData("application/fabric")) : {}, h = o[Math.max(0, o.length - 1)], d = 0;
      if (this.__dragStartSelection) {
        const p = this.__dragStartSelection.selectionStart, f = this.__dragStartSelection.selectionEnd;
        c > p && c <= f ? c = p : c > f && (c -= f - p), a.removeChars(p, f), delete this.__dragStartSelection;
      }
      a._reNewline.test(h) && (a._reNewline.test(a._text[c]) || c === a._text.length) && (o = o.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(o, u, c), l.setActiveObject(a), a.enterEditing(i), a.selectionStart = Math.min(c + d, a._text.length), a.selectionEnd = Math.min(a.selectionStart + o.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(Ed, { index: c + d, action: "drop" }), l.fire("text:changed", { target: a }), l.contextTopDirty = !0, l.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: n } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var i;
      const s = this.target, o = this.target.canvas, { selectionStart: a, selectionEnd: l } = this.__dragStartSelection, c = ((i = n.dataTransfer) === null || i === void 0 ? void 0 : i.dropEffect) || Ui;
      c === Ui ? (s.selectionStart = a, s.selectionEnd = l, s._updateTextarea(), s.hiddenTextarea.focus()) : (s.clearContextTop(), c === "move" && (s.removeChars(a, l), s.selectionStart = s.selectionEnd = a, s.hiddenTextarea && (s.hiddenTextarea.value = s.text), s._updateTextarea(), s.fire(Ed, { index: a, action: "dragend" }), o.fire("text:changed", { target: s }), o.requestRenderAll()), s.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const H1 = /[ \n\.,;!\?\-]/;
class WW extends ui {
  constructor() {
    super(...arguments), Re(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: n, duration: i, delay: s, onComplete: o } = e;
    return Dw({ startValue: this._currentCursorOpacity, endValue: n, duration: i, delay: s, onComplete: o, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((n) => {
      n && !n.isDone() && (e = !0, n.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  cmdAll() {
    this.selectAll(), this.renderCursorOrSelection();
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let n = 0, i = e - 1;
    if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]); ) n++, i--;
    for (; /\S/.test(this._text[i]) && i > -1; ) n++, i--;
    return e - n;
  }
  findWordBoundaryRight(e) {
    let n = 0, i = e;
    if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]); ) n++, i++;
    for (; /\S/.test(this._text[i]) && i < this._text.length; ) n++, i++;
    return e + n;
  }
  findLineBoundaryLeft(e) {
    let n = 0, i = e - 1;
    for (; !/\n/.test(this._text[i]) && i > -1; ) n++, i--;
    return e - n;
  }
  findLineBoundaryRight(e) {
    let n = 0, i = e;
    for (; !/\n/.test(this._text[i]) && i < this._text.length; ) n++, i++;
    return e + n;
  }
  searchWordBoundary(e, n) {
    const i = this._text;
    let s = e > 0 && this._reSpace.test(i[e]) && (n === -1 || !gv.test(i[e - 1])) ? e - 1 : e, o = i[s];
    for (; s > 0 && s < i.length && !H1.test(o); ) s += n, o = i[s];
    return n === -1 && H1.test(o) && s++, s;
  }
  selectWord(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const i = this.searchWordBoundary(e, -1), s = Math.max(i, this.searchWordBoundary(e, 1));
    this.selectionStart = i, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const i = this.findLineBoundaryLeft(e), s = this.findLineBoundaryRight(e);
    this.selectionStart = i, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea();
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const n = this.hiddenTextarea;
    _s(n).activeElement !== n && n.focus();
    const i = this.getSelectionStartFromPointer(e), s = this.selectionStart, o = this.selectionEnd;
    (i === this.__selectionStartOnMouseDown && s !== o || s !== i && o !== i) && (i > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = i) : (this.selectionStart = i, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === s && this.selectionEnd === o || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, n, i) {
    const s = i.slice(0, e), o = this.graphemeSplit(s).length;
    if (e === n) return { selectionStart: o, selectionEnd: o };
    const a = i.slice(e, n);
    return { selectionStart: o, selectionEnd: o + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, n, i) {
    const s = i.slice(0, e).join("").length;
    return e === n ? { selectionStart: s, selectionEnd: s } : { selectionStart: s, selectionEnd: s + i.slice(e, n).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const n = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = n.selectionEnd, this.inCompositionMode || (this.selectionStart = n.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, n = this._getCursorBoundaries(e), i = this.get2DCursorLocation(e), s = i.lineIndex, o = i.charIndex, a = this.getValueOfPropertyAt(s, o, "fontSize") * this.lineHeight, l = n.leftOffset, c = this.getCanvasRetinaScaling(), u = this.canvas.upperCanvasEl, h = u.width / c, d = u.height / c, p = h - a, f = d - a, m = new He(n.left + l, n.top + n.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new He(u.clientWidth / h, u.clientHeight / d));
    return m.x < 0 && (m.x = 0), m.x > p && (m.x = p), m.y < 0 && (m.y = 0), m.y > f && (m.y = f), m.x += this.canvas._offset.left, m.y += this.canvas._offset.top, { left: "".concat(m.x, "px"), top: "".concat(m.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(Ad), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, n) {
    const { lineIndex: i, charIndex: s } = this.get2DCursorLocation(e, !0), { lineIndex: o, charIndex: a } = this.get2DCursorLocation(n, !0);
    if (i !== o) {
      if (this.styles[i]) for (let l = s; l < this._unwrappedTextLines[i].length; l++) delete this.styles[i][l];
      if (this.styles[o]) for (let l = a; l < this._unwrappedTextLines[o].length; l++) {
        const c = this.styles[o][l];
        c && (this.styles[i] || (this.styles[i] = {}), this.styles[i][s + l - a] = c);
      }
      for (let l = i + 1; l <= o; l++) delete this.styles[l];
      this.shiftLineStyles(o, i - o);
    } else if (this.styles[i]) {
      const l = this.styles[i], c = a - s;
      for (let u = s; u < a; u++) delete l[u];
      for (const u in this.styles[i]) {
        const h = parseInt(u, 10);
        h >= a && (l[h - c] = l[u], delete l[u]);
      }
    }
  }
  shiftLineStyles(e, n) {
    const i = Object.assign({}, this.styles);
    for (const s in this.styles) {
      const o = parseInt(s, 10);
      o > e && (this.styles[o + n] = i[o], i[o - n] || delete this.styles[o]);
    }
  }
  insertNewlineStyleObject(e, n, i, s) {
    const o = {}, a = this._unwrappedTextLines[e].length, l = a === n;
    let c = !1;
    i || (i = 1), this.shiftLineStyles(e, i);
    const u = this.styles[e] ? this.styles[e][n === 0 ? n : n - 1] : void 0;
    for (const d in this.styles[e]) {
      const p = parseInt(d, 10);
      p >= n && (c = !0, o[p - n] = this.styles[e][d], l && n === 0 || delete this.styles[e][d]);
    }
    let h = !1;
    for (c && !l && (this.styles[e + i] = o, h = !0), (h || a > n) && i--; i > 0; ) s && s[i - 1] ? this.styles[e + i] = { 0: Ie({}, s[i - 1]) } : u ? this.styles[e + i] = { 0: Ie({}, u) } : delete this.styles[e + i], i--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, n, i, s) {
    this.styles || (this.styles = {});
    const o = this.styles[e], a = o ? Ie({}, o) : {};
    i || (i = 1);
    for (const c in a) {
      const u = parseInt(c, 10);
      u >= n && (o[u + i] = a[u], a[u - i] || delete o[u]);
    }
    if (this._forceClearCache = !0, s) {
      for (; i--; ) Object.keys(s[i]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][n + i] = Ie({}, s[i]));
      return;
    }
    if (!o) return;
    const l = o[n ? n - 1 : 1];
    for (; l && i--; ) this.styles[e][n + i] = Ie({}, l);
  }
  insertNewStyleBlock(e, n, i) {
    const s = this.get2DCursorLocation(n, !0), o = [0];
    let a, l = 0;
    for (let c = 0; c < e.length; c++) e[c] === `
` ? (l++, o[l] = 0) : o[l]++;
    for (o[0] > 0 && (this.insertCharStyleObject(s.lineIndex, s.charIndex, o[0], i), i = i && i.slice(o[0] + 1)), l && this.insertNewlineStyleObject(s.lineIndex, s.charIndex + o[0], l), a = 1; a < l; a++) o[a] > 0 ? this.insertCharStyleObject(s.lineIndex + a, 0, o[a], i) : i && this.styles[s.lineIndex + a] && i[0] && (this.styles[s.lineIndex + a][0] = i[0]), i = i && i.slice(o[a] + 1);
    o[a] > 0 && this.insertCharStyleObject(s.lineIndex + a, 0, o[a], i);
  }
  removeChars(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, n), this._text.splice(e, n - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, n, i) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : i;
    s > i && this.removeStyleFromTo(i, s);
    const o = this.graphemeSplit(e);
    this.insertNewStyleBlock(o, i, n), this._text = [...this._text.slice(0, i), ...o, ...this._text.slice(s)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, n, i) {
    i <= e ? (n === e ? this._selectionDirection = Qt : this._selectionDirection === In && (this._selectionDirection = Qt, this.selectionEnd = e), this.selectionStart = i) : i > e && i < n ? this._selectionDirection === In ? this.selectionEnd = i : this.selectionStart = i : (n === e ? this._selectionDirection = In : this._selectionDirection === Qt && (this._selectionDirection = In, this.selectionStart = n), this.selectionEnd = i);
  }
}
class jW extends WW {
  initHiddenTextarea() {
    const e = this.canvas && _s(this.canvas.getElement()) || wl(), n = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off", name: "fabricTextarea" }).map((a) => {
      let [l, c] = a;
      return n.setAttribute(l, c);
    });
    const { top: i, left: s, fontSize: o } = this._calcTextareaPosition();
    n.style.cssText = "position: absolute; top: ".concat(i, "; left: ").concat(s, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(o, ";"), (this.hiddenTextareaContainer || e.body).appendChild(n), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [l, c] = a;
      return n.addEventListener(l, this[c].bind(this));
    }), this.hiddenTextarea = n;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const n = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in n) this[n[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const n = this.fromPaste, { value: i, selectionStart: s, selectionEnd: o } = this.hiddenTextarea;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const a = () => {
      this.updateFromTextArea(), this.fire(Ed), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void a();
    const l = this._splitTextIntoLines(i).graphemeText, c = this._text.length, u = l.length, h = this.selectionStart, d = this.selectionEnd, p = h !== d;
    let f, m, _, g, v = u - c;
    const S = this.fromStringToGraphemeSelection(s, o, i), b = h > S.selectionStart;
    p ? (m = this._text.slice(h, d), v += d - h) : u < c && (m = b ? this._text.slice(d + v, d) : this._text.slice(h, h - v));
    const x = l.slice(S.selectionEnd - v, S.selectionEnd);
    if (m && m.length && (x.length && (f = this.getSelectionStyles(h, h + 1, !1), f = x.map(() => f[0])), p ? (_ = h, g = d) : b ? (_ = d - m.length, g = d) : (_ = d, g = d + m.length), this.removeStyleFromTo(_, g)), x.length) {
      const { copyPasteData: M } = $s();
      n && x.join("") === M.copiedText && !Gt.disableStyleCopyPaste && (f = M.copiedTextStyle), this.insertNewStyleBlock(x, h, f);
    }
    a();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: n } = e;
    const { selectionStart: i, selectionEnd: s } = n;
    this.compositionStart = i, this.compositionEnd = s, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = $s();
    e.copiedText = this.getSelectedText(), Gt.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, n) {
    let i, s = this._getLineLeftOffset(e);
    return n > 0 && (i = this.__charBounds[e][n - 1], s += i.left + i.width), s;
  }
  getDownCursorOffset(e, n) {
    const i = this._getSelectionForOffset(e, n), s = this.get2DCursorLocation(i), o = s.lineIndex;
    if (o === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - i;
    const a = s.charIndex, l = this._getWidthBeforeCursor(o, a), c = this._getIndexOnLine(o + 1, l);
    return this._textLines[o].slice(a).length + c + 1 + this.missingNewlineOffset(o);
  }
  _getSelectionForOffset(e, n) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && n ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, n) {
    const i = this._getSelectionForOffset(e, n), s = this.get2DCursorLocation(i), o = s.lineIndex;
    if (o === 0 || e.metaKey || e.keyCode === 33) return -i;
    const a = s.charIndex, l = this._getWidthBeforeCursor(o, a), c = this._getIndexOnLine(o - 1, l), u = this._textLines[o].slice(0, a), h = this.missingNewlineOffset(o - 1);
    return -this._textLines[o - 1].length + c - u.length + (1 - h);
  }
  _getIndexOnLine(e, n) {
    const i = this._textLines[e];
    let s, o, a = this._getLineLeftOffset(e), l = 0;
    for (let c = 0, u = i.length; c < u; c++) if (s = this.__charBounds[e][c].width, a += s, a > n) {
      o = !0;
      const h = a - s, d = a, p = Math.abs(h - n);
      l = Math.abs(d - n) < p ? c : c - 1;
      break;
    }
    return o || (l = i.length - 1), l;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, n) {
    const i = this["get".concat(e, "CursorOffset")](n, this._selectionDirection === In);
    if (n.shiftKey ? this.moveCursorWithShift(i) : this.moveCursorWithoutShift(i), i !== 0) {
      const s = this.text.length;
      this.selectionStart = ml(0, this.selectionStart, s), this.selectionEnd = ml(0, this.selectionEnd, s), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const n = this._selectionDirection === Qt ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, n), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, n, i) {
    let s;
    if (e.altKey) s = this["findWordBoundary".concat(i)](this[n]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[n] += i === "Left" ? -1 : 1, !0;
      s = this["findLineBoundary".concat(i)](this[n]);
    }
    return s !== void 0 && this[n] !== s && (this[n] = s, !0);
  }
  _moveLeft(e, n) {
    return this._move(e, n, "Left");
  }
  _moveRight(e, n) {
    return this._move(e, n, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = Qt, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (n = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, n;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === In && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = Qt, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, n) {
    const i = "moveCursor".concat(e).concat(n.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[i](n) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === Qt && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = In, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = In, this.selectionStart === this.selectionEnd ? (n = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, n;
  }
}
const W1 = (r) => !!r.button;
class $W extends jW {
  constructor() {
    super(...arguments), Re(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("mousetripleclick", this.tripleClickHandler), this.draggableTextDelegate = new HW(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  doubleClickHandler(e) {
    this.isEditing && (this.selectWord(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  tripleClickHandler(e) {
    this.isEditing && (this.selectLine(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  _mouseDownHandler(e) {
    let { e: n, alreadySelected: i } = e;
    this.canvas && this.editable && !W1(n) && !this.getActiveControl() && (this.draggableTextDelegate.start(n) || (this.canvas.textEditingManager.register(this), i && (this.inCompositionMode = !1, this.setCursorByClick(n)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()), this.selected || (this.selected = i || this.isEditing)));
  }
  mouseUpHandler(e) {
    let { e: n, transform: i } = e;
    const s = this.draggableTextDelegate.end(n);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const o = this.canvas._activeObject;
      if (o && o !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || i && i.actionPerformed || W1(n) || s || this.selected && !this.getActiveControl() && (this.enterEditing(n), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection());
  }
  setCursorByClick(e) {
    const n = this.getSelectionStartFromPointer(e), i = this.selectionStart, s = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(i, s, n) : (this.selectionStart = n, this.selectionEnd = n), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const n = this.canvas.getScenePoint(e).transform(bs(this.calcTransformMatrix())).add(new He(-this._getLeftOffset(), -this._getTopOffset()));
    let i = 0, s = 0, o = 0;
    for (let u = 0; u < this._textLines.length && i <= n.y; u++) i += this.getHeightOfLine(u), o = u, u > 0 && (s += this._textLines[u - 1].length + this.missingNewlineOffset(u - 1));
    let a = Math.abs(this._getLineLeftOffset(o));
    const l = this._textLines[o].length, c = this.__charBounds[o];
    for (let u = 0; u < l; u++) {
      const h = a + c[u].kernedWidth;
      if (n.x <= h) {
        Math.abs(n.x - h) <= Math.abs(n.x - a) && s++;
        break;
      }
      a = h, s++;
    }
    return Math.min(this.flipX ? l - s : s, this._text.length);
  }
}
const hh = "moveCursorUp", dh = "moveCursorDown", fh = "moveCursorLeft", ph = "moveCursorRight", mh = "exitEditing", j1 = (r, e) => {
  const n = e.getRetinaScaling();
  r.setTransform(n, 0, 0, n, 0, 0);
  const i = e.viewportTransform;
  r.transform(i[0], i[1], i[2], i[3], i[4], i[5]);
}, XW = Ie({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: mh, 27: mh, 33: hh, 34: dh, 35: ph, 36: fh, 37: fh, 38: hh, 39: ph, 40: dh }, keysMapRtl: { 9: mh, 27: mh, 33: hh, 34: dh, 35: fh, 36: ph, 37: ph, 38: hh, 39: fh, 40: dh }, ctrlKeysMapDown: { 65: "cmdAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class gr extends $W {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), gr.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, n) {
    super(e, Ie(Ie({}, gr.ownDefaults), n)), this.initBehavior();
  }
  _set(e, n) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = n, this) : (e === "canvas" && (this.canvas instanceof pg && this.canvas.textEditingManager.remove(this), n instanceof pg && n.textEditingManager.add(this)), super._set(e, n));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, n) {
    this[e] !== n && (this._fireSelectionChanged(), this[e] = n), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, i = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, n, i);
  }
  setSelectionStyles(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, n, i);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, n);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const n = this.isEditing;
    this.isEditing = !1;
    const i = super.toCanvasElement(e);
    return this.isEditing = n, i;
  }
  renderCursorOrSelection() {
    if (!this.isEditing || !this.canvas) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const n = this._getCursorBoundaries(), i = this.findAncestorsWithClipPath(), s = i.length > 0;
    let o, a = e;
    if (s) {
      o = rs(e.canvas), a = o.getContext("2d"), j1(a, this.canvas);
      const l = this.calcTransformMatrix();
      a.transform(l[0], l[1], l[2], l[3], l[4], l[5]);
    }
    if (this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(a, n) : this.renderCursor(a, n), s) for (const l of i) {
      const c = l.clipPath, u = rs(e.canvas), h = u.getContext("2d");
      if (j1(h, this.canvas), !c.absolutePositioned) {
        const d = l.calcTransformMatrix();
        h.transform(d[0], d[1], d[2], d[3], d[4], d[5]);
      }
      c.transform(h), c.drawObject(h, !0, {}), this.drawClipPathOnCache(a, c, u);
    }
    s && (e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(o, 0, 0)), this.canvas.contextTopDirty = !0, e.restore();
  }
  findAncestorsWithClipPath() {
    const e = [];
    let n = this;
    for (; n; ) n.clipPath && e.push(n), n = n.parent;
    return e;
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    const i = this._getLeftOffset(), s = this._getTopOffset(), o = this._getCursorBoundariesOffsets(e, n);
    return { left: i, top: s, leftOffset: o.left, topOffset: o.top };
  }
  _getCursorBoundariesOffsets(e, n) {
    return n ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let n = 0, i = 0;
    const { charIndex: s, lineIndex: o } = this.get2DCursorLocation(e);
    for (let u = 0; u < o; u++) n += this.getHeightOfLine(u);
    const a = this._getLineLeftOffset(o), l = this.__charBounds[o][s];
    l && (i = l.left), this.charSpacing !== 0 && s === this._textLines[o].length && (i -= this._getWidthOfCharSpacing());
    const c = { top: n, left: a + (i > 0 ? i : 0) };
    return this.direction === "rtl" && (this.textAlign === In || this.textAlign === Bs || this.textAlign === Pc ? c.left *= -1 : this.textAlign === Qt || this.textAlign === Id ? c.left = a - (i > 0 ? i : 0) : this.textAlign !== It && this.textAlign !== Dc || (c.left = a - (i > 0 ? i : 0))), c;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, n) {
    this._renderCursor(e, n, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const i = this.get2DCursorLocation(e), s = i.lineIndex, o = i.charIndex > 0 ? i.charIndex - 1 : 0, a = this.getValueOfPropertyAt(s, o, "fontSize"), l = this.getObjectScaling().x * this.canvas.getZoom(), c = this.cursorWidth / l, u = this.getValueOfPropertyAt(s, o, "deltaY"), h = n.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(s) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(s, o, "fill"), opacity: this._currentCursorOpacity, left: n.left + n.leftOffset - c / 2, top: h + n.top + u, width: c, height: a };
  }
  _renderCursor(e, n, i) {
    const { color: s, opacity: o, left: a, top: l, width: c, height: u } = this.getCursorRenderingData(i, n);
    e.fillStyle = s, e.globalAlpha = o, e.fillRect(a, l, c, u);
  }
  renderSelection(e, n) {
    const i = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, i, n);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const n = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(n);
  }
  _renderSelection(e, n, i) {
    const s = n.selectionStart, o = n.selectionEnd, a = this.textAlign.includes(Bs), l = this.get2DCursorLocation(s), c = this.get2DCursorLocation(o), u = l.lineIndex, h = c.lineIndex, d = l.charIndex < 0 ? 0 : l.charIndex, p = c.charIndex < 0 ? 0 : c.charIndex;
    for (let f = u; f <= h; f++) {
      const m = this._getLineLeftOffset(f) || 0;
      let _ = this.getHeightOfLine(f), g = 0, v = 0, S = 0;
      if (f === u && (v = this.__charBounds[u][d].left), f >= u && f < h) S = a && !this.isEndOfWrapping(f) ? this.width : this.getLineWidth(f) || 5;
      else if (f === h) if (p === 0) S = this.__charBounds[h][p].left;
      else {
        const E = this._getWidthOfCharSpacing();
        S = this.__charBounds[h][p - 1].left + this.__charBounds[h][p - 1].width - E;
      }
      g = _, (this.lineHeight < 1 || f === h && this.lineHeight > 1) && (_ /= this.lineHeight);
      let b = i.left + m + v, x = _, M = 0;
      const C = S - v;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", x = 1, M = _) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === In || this.textAlign === Bs || this.textAlign === Pc ? b = this.width - b - C : this.textAlign === Qt || this.textAlign === Id ? b = i.left + m - S : this.textAlign !== It && this.textAlign !== Dc || (b = i.left + m - S)), e.fillRect(b, i.top + i.topOffset + M, C, x), i.topOffset += g;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Hn);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), n = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: n };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
Re(gr, "ownDefaults", XW), Re(gr, "type", "IText"), ht.setClass(gr), ht.setClass(gr, "i-text");
class Xo extends gr {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), Xo.ownDefaults);
  }
  constructor(e, n) {
    super(e, Ie(Ie({}, Xo.ownDefaults), n));
  }
  static createControls() {
    return { controls: CH() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(Bs) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let n = 0, i = 0, s = 0;
    const o = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[s] === `
` && a > 0 ? (i = 0, s++, n++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[s]) && a > 0 && (i++, s++), o[a] = { line: n, offset: i }, s += e.graphemeLines[a].length, i += e.graphemeLines[a].length;
    return o;
  }
  styleHas(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const i = this._styleMap[n];
      i && (n = i.line);
    }
    return super.styleHas(e, n);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let n, i = 0, s = e + 1, o = !1;
    const a = this._styleMap[e], l = this._styleMap[e + 1];
    a && (e = a.line, i = a.offset), l && (s = l.line, o = s === e, n = l.offset);
    const c = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const u in c) for (const h in c[u]) {
      const d = parseInt(h, 10);
      if (d >= i && (!o || d < n)) for (const p in c[u][h]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const i = this._styleMap[e];
      if (!i) return {};
      e = i.line, n = i.offset + n;
    }
    return super._getStyleDeclaration(e, n);
  }
  _setStyleDeclaration(e, n, i) {
    const s = this._styleMap[e];
    super._setStyleDeclaration(s.line, s.offset + n, i);
  }
  _deleteStyleDeclaration(e, n) {
    const i = this._styleMap[e];
    super._deleteStyleDeclaration(i.line, i.offset + n);
  }
  _getLineStyle(e) {
    const n = this._styleMap[e];
    return !!this.styles[n.line];
  }
  _setLineStyle(e) {
    const n = this._styleMap[e];
    super._setLineStyle(n.line);
  }
  _wrapText(e, n) {
    this.isWrapping = !0;
    const i = this.getGraphemeDataForRender(e), s = [];
    for (let o = 0; o < i.wordsData.length; o++) s.push(...this._wrapLine(o, n, i));
    return this.isWrapping = !1, s;
  }
  getGraphemeDataForRender(e) {
    const n = this.splitByGrapheme, i = n ? "" : " ";
    let s = 0;
    return { wordsData: e.map((o, a) => {
      let l = 0;
      const c = n ? this.graphemeSplit(o) : this.wordSplit(o);
      return c.length === 0 ? [{ word: [], width: 0 }] : c.map((u) => {
        const h = n ? [u] : this.graphemeSplit(u), d = this._measureWord(h, a, l);
        return s = Math.max(d, s), l += h.length + i.length, { word: h, width: d };
      });
    }), largestWordWidth: s };
  }
  _measureWord(e, n) {
    let i, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = 0;
    for (let a = 0, l = e.length; a < l; a++)
      o += this._getGraphemeBox(e[a], n, a + s, i, !0).kernedWidth, i = e[a];
    return o;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, n, i) {
    let { largestWordWidth: s, wordsData: o } = i, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const l = this._getWidthOfCharSpacing(), c = this.splitByGrapheme, u = [], h = c ? "" : " ";
    let d = 0, p = [], f = 0, m = 0, _ = !0;
    n -= a;
    const g = Math.max(n, s, this.dynamicMinWidth), v = o[e];
    let S;
    for (f = 0, S = 0; S < v.length; S++) {
      const { word: b, width: x } = v[S];
      f += b.length, d += m + x - l, d > g && !_ ? (u.push(p), p = [], d = x, _ = !0) : d += l, _ || c || p.push(h), p = p.concat(b), m = c ? 0 : this._measureWord([h], e, f), f++, _ = !1;
    }
    return S && u.push(p), s + a > this.dynamicMinWidth && (this.dynamicMinWidth = s - l + a), u;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, n) {
    return this.splitByGrapheme && !n ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const n = super._splitTextIntoLines(e), i = this._wrapText(n.lines, this.width), s = new Array(i.length);
    for (let o = 0; o < i.length; o++) s[o] = i[o].join("");
    return n.lines = s, n.graphemeLines = i, n;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const n in this._styleMap) {
      const i = parseInt(n, 10);
      if (this._textLines[i]) {
        const s = this._styleMap[n].line;
        e.set("".concat(s), !0);
      }
    }
    for (const n in this.styles) e.has(n) || delete this.styles[n];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
Re(Xo, "type", "Textbox"), Re(Xo, "textLayoutProperties", [...gr.textLayoutProperties, "width"]), Re(Xo, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), ht.setClass(Xo);
class $1 extends xf {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, n) {
    const { target: i } = e, { clipPath: s, group: o } = i;
    if (!s || !this.shouldPerformLayout(e)) return;
    const { width: a, height: l } = br(zw(i, s)), c = new He(a, l);
    if (s.absolutePositioned)
      return { center: el(s.getRelativeCenterPoint(), void 0, o ? o.calcTransformMatrix() : void 0), size: c };
    {
      const u = s.getRelativeCenterPoint().transform(i.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: h = new He(), correction: d = new He() } = this.calcBoundingBox(n, e) || {};
        return { center: h.add(u), correction: d.subtract(u), size: c };
      }
      return { center: i.getRelativeCenterPoint().add(u), size: c };
    }
  }
}
Re($1, "type", "clip-path"), ht.setClass($1);
class X1 extends xf {
  getInitialSize(e, n) {
    let { target: i } = e, { size: s } = n;
    return new He(i.width || s.x, i.height || s.y);
  }
}
Re(X1, "type", "fixed"), ht.setClass(X1);
class YW extends su {
  subscribeTargets(e) {
    const n = e.target;
    e.targets.reduce((i, s) => (s.parent && i.add(s.parent), i), /* @__PURE__ */ new Set()).forEach((i) => {
      i.layoutManager.subscribeTargets({ target: i, targets: [n] });
    });
  }
  unsubscribeTargets(e) {
    const n = e.target, i = n.getObjects();
    e.targets.reduce((s, o) => (o.parent && s.add(o.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {
      !i.some((o) => o.parent === s) && s.layoutManager.unsubscribeTargets({ target: s, targets: [n] });
    });
  }
}
class Yo extends oo {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), Yo.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Yo.ownDefaults), this.setOptions(n);
    const { left: i, top: s, layoutManager: o } = n;
    this.groupInit(e, { left: i, top: s, layoutManager: o ?? new YW() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    this.multiSelectionStacking === "selection-order" ? this.add(...n) : n.forEach((s) => {
      const o = this._objects.findIndex((l) => l.isInFrontOf(s)), a = o === -1 ? this.size() : o;
      this.insertAt(a, s);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((n) => n.isDescendantOf(e) || e.isDescendantOf(n)) ? (lo("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, n) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, n);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, n) {
    super._onAfterObjectsChange(e, n);
    const i = /* @__PURE__ */ new Set();
    n.forEach((s) => {
      const { parent: o } = s;
      o && i.add(o);
    }), e === kv ? i.forEach((s) => {
      s._onAfterObjectsChange(Od, n);
    }) : i.forEach((s) => {
      s._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, n, i) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const s = Ie(Ie({ hasControls: !1 }, i), {}, { forActiveSelection: !0 });
    for (let o = 0; o < this._objects.length; o++) this._objects[o]._renderControls(e, s);
    super._renderControls(e, n), e.restore();
  }
}
Re(Yo, "type", "ActiveSelection"), Re(Yo, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), ht.setClass(Yo), ht.setClass(Yo, "activeSelection");
class qW {
  constructor() {
    Re(this, "resources", {});
  }
  applyFilters(e, n, i, s, o) {
    const a = o.getContext("2d");
    if (!a) return;
    a.drawImage(n, 0, 0, i, s);
    const l = { sourceWidth: i, sourceHeight: s, imageData: a.getImageData(0, 0, i, s), originalEl: n, originalImageData: a.getImageData(0, 0, i, s), canvasEl: o, ctx: a, filterBackend: this };
    e.forEach((u) => {
      u.applyTo(l);
    });
    const { imageData: c } = l;
    return c.width === i && c.height === s || (o.width = c.width, o.height = c.height), a.putImageData(c, 0, 0), l;
  }
}
class eS {
  constructor() {
    let { tileSize: e = Gt.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Re(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), Re(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, n) {
    this.dispose(), this.createWebGLCanvas(e, n);
  }
  createWebGLCanvas(e, n) {
    const i = rs({ width: e, height: n }), s = i.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    s && (s.clearColor(0, 0, 0, 0), this.canvas = i, this.gl = s);
  }
  applyFilters(e, n, i, s, o, a) {
    const l = this.gl, c = o.getContext("2d");
    if (!l || !c) return;
    let u;
    a && (u = this.getCachedTexture(a, n));
    const h = { originalWidth: n.width || n.naturalWidth || 0, originalHeight: n.height || n.naturalHeight || 0, sourceWidth: i, sourceHeight: s, destinationWidth: i, destinationHeight: s, context: l, sourceTexture: this.createTexture(l, i, s, u ? void 0 : n), targetTexture: this.createTexture(l, i, s), originalTexture: u || this.createTexture(l, i, s, u ? void 0 : n), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: o }, d = l.createFramebuffer();
    return l.bindFramebuffer(l.FRAMEBUFFER, d), e.forEach((p) => {
      p && p.applyTo(h);
    }), function(p) {
      const f = p.targetCanvas, m = f.width, _ = f.height, g = p.destinationWidth, v = p.destinationHeight;
      m === g && _ === v || (f.width = g, f.height = v);
    }(h), this.copyGLTo2D(l, h), l.bindTexture(l.TEXTURE_2D, null), l.deleteTexture(h.sourceTexture), l.deleteTexture(h.targetTexture), l.deleteFramebuffer(d), c.setTransform(1, 0, 0, 1, 0, 0), h;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, n, i, s, o) {
    const { NEAREST: a, TEXTURE_2D: l, RGBA: c, UNSIGNED_BYTE: u, CLAMP_TO_EDGE: h, TEXTURE_MAG_FILTER: d, TEXTURE_MIN_FILTER: p, TEXTURE_WRAP_S: f, TEXTURE_WRAP_T: m } = e, _ = e.createTexture();
    return e.bindTexture(l, _), e.texParameteri(l, d, o || a), e.texParameteri(l, p, o || a), e.texParameteri(l, f, h), e.texParameteri(l, m, h), s ? e.texImage2D(l, 0, c, c, u, s) : e.texImage2D(l, 0, c, n, i, 0, c, u, null), _;
  }
  getCachedTexture(e, n, i) {
    const { textureCache: s } = this;
    if (s[e]) return s[e];
    {
      const o = this.createTexture(this.gl, n.width, n.height, n, i);
      return o && (s[e] = o), o;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, n) {
    const i = e.canvas, s = n.targetCanvas, o = s.getContext("2d");
    if (!o) return;
    o.translate(0, s.height), o.scale(1, -1);
    const a = i.height - s.height;
    o.drawImage(i, 0, a, s.width, s.height, 0, 0, s.width, s.height);
  }
  copyGLTo2DPutImageData(e, n) {
    const i = n.targetCanvas.getContext("2d"), s = n.destinationWidth, o = n.destinationHeight, a = s * o * 4;
    if (!i) return;
    const l = new Uint8Array(this.imageBuffer, 0, a), c = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, s, o, e.RGBA, e.UNSIGNED_BYTE, l);
    const u = new ImageData(c, s, o);
    i.putImageData(u, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, n = { renderer: "", vendor: "" };
    if (!e) return n;
    const i = e.getExtension("WEBGL_debug_renderer_info");
    if (i) {
      const s = e.getParameter(i.UNMASKED_RENDERER_WEBGL), o = e.getParameter(i.UNMASKED_VENDOR_WEBGL);
      s && (n.renderer = s.toLowerCase()), o && (n.vendor = o.toLowerCase());
    }
    return this.gpuInfo = n, n;
  }
}
let Gp;
function ZW() {
  const { WebGLProbe: r } = $s();
  return r.queryWebGL(Pr()), Gt.enableGLFiltering && r.isSupported(Gt.textureSize) ? new eS({ tileSize: Gt.textureSize }) : new qW();
}
function Hp() {
  return !Gp && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (Gp = ZW()), Gp;
}
const KW = ["filters", "resizeFilter", "src", "crossOrigin", "type"], tS = ["cropX", "cropY"];
class Ri extends pi {
  static getDefaults() {
    return Ie(Ie({}, super.getDefaults()), Ri.ownDefaults);
  }
  constructor(e, n) {
    super(), Re(this, "_lastScaleX", 1), Re(this, "_lastScaleY", 1), Re(this, "_filterScalingX", 1), Re(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, Ri.ownDefaults), this.setOptions(n), this.cacheKey = "texture".concat(co()), this.setElement(typeof e == "string" ? (this.canvas && _s(this.canvas.getElement()) || wl()).getElementById(e) : e, n);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    var n;
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(i), (n = e.classList) === null || n === void 0 || n.add(Ri.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const n = Hp(!1);
    n instanceof eS && n.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const n = this[e];
      n && $s().dispose(n), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const n = this.width / 2, i = this.height / 2;
    e.beginPath(), e.moveTo(-n, -i), e.lineTo(n, -i), e.lineTo(n, i), e.lineTo(-n, i), e.lineTo(-n, -i), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = [];
    return this.filters.forEach((i) => {
      i && n.push(i.toObject());
    }), Ie(Ie({}, super.toObject([...tS, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: n }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], n = this._element, i = -this.width / 2, s = -this.height / 2;
    let o = [], a = [], l = "", c = "";
    if (!n) return [];
    if (this.hasCrop()) {
      const u = co();
      o.push('<clipPath id="imageCrop_' + u + `">
`, '	<rect x="' + i + '" y="' + s + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), l = ' clip-path="url(#imageCrop_' + u + ')" ';
    }
    if (this.imageSmoothing || (c = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(i - this.cropX, '" y="').concat(s - this.cropY, '" width="').concat(n.width || n.naturalWidth, '" height="').concat(n.height || n.naturalHeight, '"').concat(c).concat(l, `></image>
`)), this.stroke || this.strokeDashArray) {
      const u = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(i, '" y="').concat(s, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = u;
    }
    return o = this.paintFirst !== Hn ? o.concat(a, e) : o.concat(e, a), o;
  }
  getSrc(e) {
    const n = e ? this._element : this._originalElement;
    return n ? n.toDataURL ? n.toDataURL() : this.srcFromAttribute ? n.getAttribute("src") || "" : n.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: n, signal: i } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return td(e, { crossOrigin: n, signal: i }).then((s) => {
      n !== void 0 && this.set({ crossOrigin: n }), this.setElement(s);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, n = this.minimumScaleTrigger, i = this.getTotalObjectScaling(), s = i.x, o = i.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || s > n && o > n) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = s, void (this._lastScaleY = o);
    const l = rs(a), { width: c, height: u } = a;
    this._element = l, this._lastScaleX = e.scaleX = s, this._lastScaleY = e.scaleY = o, Hp().applyFilters([e], a, c, u, this._element), this._filterScalingX = l.width / this._originalElement.width, this._filterScalingY = l.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((o) => o && !o.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const n = this._originalElement, i = n.naturalWidth || n.width, s = n.naturalHeight || n.height;
    if (this._element === this._originalElement) {
      const o = rs({ width: i, height: s });
      this._element = o, this._filteredEl = o;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, i, s), this._lastScaleX = 1, this._lastScaleY = 1);
    Hp().applyFilters(e, this._originalElement, i, s, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const n = this._element;
    if (!n) return;
    const i = this._filterScalingX, s = this._filterScalingY, o = this.width, a = this.height, l = Math.max(this.cropX, 0), c = Math.max(this.cropY, 0), u = n.naturalWidth || n.width, h = n.naturalHeight || n.height, d = l * i, p = c * s, f = Math.min(o * i, u - d), m = Math.min(a * s, h - p), _ = -o / 2, g = -a / 2, v = Math.min(o, u / i - l), S = Math.min(a, h / s - c);
    n && e.drawImage(n, d, p, f, m, _, g, v, S);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: n } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const i = this.getOriginalSize();
    this.width = e || i.width, this.height = n || i.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = HG(this.preserveAspectRatio || ""), n = this.width, i = this.height, s = { width: n, height: i };
    let o, a = this._element.width, l = this._element.height, c = 1, u = 1, h = 0, d = 0, p = 0, f = 0;
    return !e || e.alignX === Ui && e.alignY === Ui ? (c = n / a, u = i / l) : (e.meetOrSlice === "meet" && (c = u = rW(this._element, s), o = (n - a * c) / 2, e.alignX === "Min" && (h = -o), e.alignX === "Max" && (h = o), o = (i - l * u) / 2, e.alignY === "Min" && (d = -o), e.alignY === "Max" && (d = o)), e.meetOrSlice === "slice" && (c = u = oW(this._element, s), o = a - n / c, e.alignX === "Mid" && (p = o / 2), e.alignX === "Max" && (p = o), o = l - i / u, e.alignY === "Mid" && (f = o / 2), e.alignY === "Max" && (f = o), a = n / c, l = i / u)), { width: a, height: l, scaleX: c, scaleY: u, offsetLeft: h, offsetTop: d, cropX: p, cropY: f };
  }
  static fromObject(e, n) {
    let { filters: i, resizeFilter: s, src: o, crossOrigin: a, type: l } = e, c = pn(e, KW);
    return Promise.all([td(o, Ie(Ie({}, n), {}, { crossOrigin: a })), i && eu(i, n), s && eu([s], n), gf(c, n)]).then((u) => {
      let [h, d = [], [p] = [], f = {}] = u;
      return new this(h, Ie(Ie({}, c), {}, { src: o, filters: d, resizeFilter: p }, f));
    });
  }
  static fromURL(e) {
    let { crossOrigin: n = null, signal: i } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
    return td(e, { crossOrigin: n, signal: i }).then((o) => new this(o, s));
  }
  static async fromElement(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
    const s = Lr(e, this.ATTRIBUTE_NAMES, i);
    return this.fromURL(s["xlink:href"] || s.href, n, s).catch((o) => (lo("log", "Unable to parse Image", o), null));
  }
}
Re(Ri, "type", "Image"), Re(Ri, "cacheProperties", [...Rr, ...tS]), Re(Ri, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), Re(Ri, "CSS_CANVAS", "canvas-img"), Re(Ri, "ATTRIBUTE_NAMES", [...go, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "href", "crossOrigin", "image-rendering"]), ht.setClass(Ri), ht.setSVGClass(Ri);
yf(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const wf = (r) => r.webgl !== void 0, Rv = "precision highp float", JW = `
    `.concat(Rv, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), QW = ["type"], e9 = ["type"], t9 = new RegExp(Rv, "g");
class $n {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = pn(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, QW);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return JW;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: s = "highp" } } = $s();
    s !== "highp" && (n = n.replace(t9, Rv.replace("highp", s)));
    const o = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), l = e.createProgram();
    if (!o || !a || !l) throw new Ns("Vertex, fragment shader or program creation error");
    if (e.shaderSource(o, i), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS)) throw new Ns("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(o)));
    if (e.shaderSource(a, n), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new Ns("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(l, o), e.attachShader(l, a), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS)) throw new Ns('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(l)));
    const c = this.getUniformLocations(e, l) || {};
    return c.uStepW = e.getUniformLocation(l, "uStepW"), c.uStepH = e.getUniformLocation(l, "uStepH"), { program: l, attributeLocations: this.getAttributeLocations(e, l), uniformLocations: c };
  }
  getAttributeLocations(e, n) {
    return { aPosition: e.getAttribLocation(n, "aPosition") };
  }
  getUniformLocations(e, n) {
    const i = this.constructor.uniformLocations, s = {};
    for (let o = 0; o < i.length; o++) s[i[o]] = e.getUniformLocation(n, i[o]);
    return s;
  }
  sendAttributeData(e, n, i) {
    const s = n.aPosition, o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.enableVertexAttribArray(s), e.vertexAttribPointer(s, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, i, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const n = e.context;
    if (e.passes > 1) {
      const i = e.destinationWidth, s = e.destinationHeight;
      e.sourceWidth === i && e.sourceHeight === s || (n.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(n, i, s)), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.targetTexture, 0);
    } else n.bindFramebuffer(n.FRAMEBUFFER, null), n.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const n = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = n;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    wf(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const n = this.getCacheKey();
    return e.programCache[n] || (e.programCache[n] = this.createProgram(e.context)), e.programCache[n];
  }
  applyToWebGL(e) {
    const n = e.context, i = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? n.bindTexture(n.TEXTURE_2D, e.originalTexture) : n.bindTexture(n.TEXTURE_2D, e.sourceTexture), n.useProgram(i.program), this.sendAttributeData(n, i.attributeLocations, e.aPosition), n.uniform1f(i.uniformLocations.uStepW, 1 / e.sourceWidth), n.uniform1f(i.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(n, i.uniformLocations), n.viewport(0, 0, e.destinationWidth, e.destinationHeight), n.drawArrays(n.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, n, i) {
    e.activeTexture(i), e.bindTexture(e.TEXTURE_2D, n), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, n) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: n, sourceHeight: i } = e, s = rs({ width: n, height: i });
      e.helpLayer = s;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return Ie({ type: this.type }, e.reduce((n, i) => (n[i] = this[i], n), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, n) {
    return new this(pn(e, e9));
  }
}
Re($n, "type", "BaseFilter"), Re($n, "uniformLocations", []);
const n9 = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class gh extends $n {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(n9[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = new sn(this.color).getSource(), s = this.alpha, o = i[0] * s, a = i[1] * s, l = i[2] * s, c = 1 - s;
    for (let u = 0; u < n.length; u += 4) {
      const h = n[u], d = n[u + 1], p = n[u + 2];
      let f, m, _;
      switch (this.mode) {
        case "multiply":
          f = h * o / 255, m = d * a / 255, _ = p * l / 255;
          break;
        case "screen":
          f = 255 - (255 - h) * (255 - o) / 255, m = 255 - (255 - d) * (255 - a) / 255, _ = 255 - (255 - p) * (255 - l) / 255;
          break;
        case "add":
          f = h + o, m = d + a, _ = p + l;
          break;
        case "difference":
          f = Math.abs(h - o), m = Math.abs(d - a), _ = Math.abs(p - l);
          break;
        case "subtract":
          f = h - o, m = d - a, _ = p - l;
          break;
        case "darken":
          f = Math.min(h, o), m = Math.min(d, a), _ = Math.min(p, l);
          break;
        case "lighten":
          f = Math.max(h, o), m = Math.max(d, a), _ = Math.max(p, l);
          break;
        case "overlay":
          f = o < 128 ? 2 * h * o / 255 : 255 - 2 * (255 - h) * (255 - o) / 255, m = a < 128 ? 2 * d * a / 255 : 255 - 2 * (255 - d) * (255 - a) / 255, _ = l < 128 ? 2 * p * l / 255 : 255 - 2 * (255 - p) * (255 - l) / 255;
          break;
        case "exclusion":
          f = o + h - 2 * o * h / 255, m = a + d - 2 * a * d / 255, _ = l + p - 2 * l * p / 255;
          break;
        case "tint":
          f = o + h * c, m = a + d * c, _ = l + p * c;
      }
      n[u] = f, n[u + 1] = m, n[u + 2] = _;
    }
  }
  sendUniformData(e, n) {
    const i = new sn(this.color).getSource();
    i[0] = this.alpha * i[0] / 255, i[1] = this.alpha * i[1] / 255, i[2] = this.alpha * i[2] / 255, i[3] = this.alpha, e.uniform4fv(n.uColor, i);
  }
}
Re(gh, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), Re(gh, "type", "BlendColor"), Re(gh, "uniformLocations", ["uColor"]), ht.setClass(gh);
const i9 = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, s9 = ["type", "image"];
class vh extends $n {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return i9[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const n = e.context, i = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(n, i, n.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(n, n.TEXTURE1);
  }
  createTexture(e, n) {
    return e.getCachedTexture(n.cacheKey, n.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: n, height: i } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / n, -e.top / i, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: i, height: s }, filterBackend: { resources: o } } = e;
    const a = this.image;
    o.blendImage || (o.blendImage = Pr());
    const l = o.blendImage, c = l.getContext("2d");
    l.width !== i || l.height !== s ? (l.width = i, l.height = s) : c.clearRect(0, 0, i, s), c.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), c.drawImage(a.getElement(), 0, 0, i, s);
    const u = c.getImageData(0, 0, i, s).data;
    for (let h = 0; h < n.length; h += 4) {
      const d = n[h], p = n[h + 1], f = n[h + 2], m = n[h + 3], _ = u[h], g = u[h + 1], v = u[h + 2], S = u[h + 3];
      switch (this.mode) {
        case "multiply":
          n[h] = d * _ / 255, n[h + 1] = p * g / 255, n[h + 2] = f * v / 255, n[h + 3] = m * S / 255;
          break;
        case "mask":
          n[h + 3] = S;
      }
    }
  }
  sendUniformData(e, n) {
    const i = this.calculateMatrix();
    e.uniform1i(n.uImage, 1), e.uniformMatrix3fv(n.uTransformMatrix, !1, i);
  }
  toObject() {
    return Ie(Ie({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, n) {
    let { type: i, image: s } = e, o = pn(e, s9);
    return Ri.fromObject(s, n).then((a) => new this(Ie(Ie({}, o), {}, { image: a })));
  }
}
Re(vh, "type", "BlendImage"), Re(vh, "defaults", { mode: "multiply", alpha: 1 }), Re(vh, "uniformLocations", ["uTransformMatrix", "uImage"]), ht.setClass(vh);
class yh extends $n {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float totalC = 0.0;
      float totalA = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);
        float weight = 1.0 - abs(percent);
        float alpha = weight * sample.a;
        color.rgb += sample.rgb * alpha;
        color.a += alpha;
        totalA += weight;
        totalC += alpha;
      }
      gl_FragColor.rgb = color.rgb / totalC;
      gl_FragColor.a = color.a / totalA;
    }
  `;
  }
  applyTo(e) {
    wf(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: i, height: s } } = e;
    this.aspectRatio = i / s, this.horizontal = !0;
    let o = this.getBlurValue() * i;
    const a = new Uint8ClampedArray(n), l = 15, c = 4 * i;
    for (let u = 0; u < n.length; u += 4) {
      let h = 0, d = 0, p = 0, f = 0, m = 0;
      const _ = u - u % c, g = _ + c;
      for (let v = -14; v < l; v++) {
        const S = v / l, b = 4 * Math.floor(o * S), x = 1 - Math.abs(S);
        let M = u + b;
        M < _ ? M = _ : M > g && (M = g);
        const C = n[M + 3] * x;
        h += n[M] * C, d += n[M + 1] * C, p += n[M + 2] * C, f += C, m += x;
      }
      a[u] = h / f, a[u + 1] = d / f, a[u + 2] = p / f, a[u + 3] = f / m;
    }
    this.horizontal = !1, o = this.getBlurValue() * s;
    for (let u = 0; u < a.length; u += 4) {
      let h = 0, d = 0, p = 0, f = 0, m = 0;
      const _ = u % c, g = a.length - c + _;
      for (let v = -14; v < l; v++) {
        const S = v / l, b = Math.floor(o * S) * c, x = 1 - Math.abs(S);
        let M = u + b;
        M < _ ? M = _ : M > g && (M = g);
        const C = a[M + 3] * x;
        h += a[M] * C, d += a[M + 1] * C, p += a[M + 2] * C, f += C, m += x;
      }
      n[u] = h / f, n[u + 1] = d / f, n[u + 2] = p / f, n[u + 3] = f / m;
    }
  }
  sendUniformData(e, n) {
    const i = this.chooseRightDelta();
    e.uniform2fv(n.uDelta, i);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  getBlurValue() {
    let e = 1;
    const { horizontal: n, aspectRatio: i } = this;
    return n ? i > 1 && (e = 1 / i) : i < 1 && (e = i), e * this.blur * 0.12;
  }
  chooseRightDelta() {
    const e = this.getBlurValue();
    return this.horizontal ? [e, 0] : [0, e];
  }
}
Re(yh, "type", "Blur"), Re(yh, "defaults", { blur: 0 }), Re(yh, "uniformLocations", ["uDelta"]), ht.setClass(yh);
class _h extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = Math.round(255 * this.brightness);
    for (let s = 0; s < n.length; s += 4) n[s] += i, n[s + 1] += i, n[s + 2] += i;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBrightness, this.brightness);
  }
}
Re(_h, "type", "Brightness"), Re(_h, "defaults", { brightness: 0 }), Re(_h, "uniformLocations", ["uBrightness"]), ht.setClass(_h);
const nS = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class ja extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const n = e.imageData.data, i = this.matrix, s = this.colorsOnly;
    for (let o = 0; o < n.length; o += 4) {
      const a = n[o], l = n[o + 1], c = n[o + 2];
      if (n[o] = a * i[0] + l * i[1] + c * i[2] + 255 * i[4], n[o + 1] = a * i[5] + l * i[6] + c * i[7] + 255 * i[9], n[o + 2] = a * i[10] + l * i[11] + c * i[12] + 255 * i[14], !s) {
        const u = n[o + 3];
        n[o] += u * i[3], n[o + 1] += u * i[8], n[o + 2] += u * i[13], n[o + 3] = a * i[15] + l * i[16] + c * i[17] + u * i[18] + 255 * i[19];
      }
    }
  }
  sendUniformData(e, n) {
    const i = this.matrix, s = [i[0], i[1], i[2], i[3], i[5], i[6], i[7], i[8], i[10], i[11], i[12], i[13], i[15], i[16], i[17], i[18]], o = [i[4], i[9], i[14], i[19]];
    e.uniformMatrix4fv(n.uColorMatrix, !1, s), e.uniform4fv(n.uConstants, o);
  }
  toObject() {
    return Ie(Ie({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function aa(r, e) {
  var n;
  const i = (Re(n = class extends ja {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", r), Re(n, "defaults", { colorsOnly: !1, matrix: e }), n);
  return ht.setClass(i, r), i;
}
Re(ja, "type", "ColorMatrix"), Re(ja, "defaults", nS), Re(ja, "uniformLocations", ["uColorMatrix", "uConstants"]), ht.setClass(ja);
aa("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
aa("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
aa("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
aa("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
aa("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
aa("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
aa("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class Y1 extends $n {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    wf(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((n) => {
      n.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, n) {
    return Promise.all((e.subFilters || []).map((i) => ht.getClass(i.type).fromObject(i, n))).then((i) => new this({ subFilters: i }));
  }
}
Re(Y1, "type", "Composed"), ht.setClass(Y1);
class xh extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = Math.floor(255 * this.contrast), s = 259 * (i + 255) / (255 * (259 - i));
    for (let o = 0; o < n.length; o += 4) n[o] = s * (n[o] - 128) + 128, n[o + 1] = s * (n[o + 1] - 128) + 128, n[o + 2] = s * (n[o + 2] - 128) + 128;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uContrast, this.contrast);
  }
}
Re(xh, "type", "Contrast"), Re(xh, "defaults", { contrast: 0 }), Re(xh, "uniformLocations", ["uContrast"]), ht.setClass(xh);
const r9 = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class bh extends $n {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return r9[this.getCacheKey()];
  }
  applyTo2d(e) {
    const n = e.imageData, i = n.data, s = this.matrix, o = Math.round(Math.sqrt(s.length)), a = Math.floor(o / 2), l = n.width, c = n.height, u = e.ctx.createImageData(l, c), h = u.data, d = this.opaque ? 1 : 0;
    let p, f, m, _, g, v, S, b, x, M, C, E, T;
    for (C = 0; C < c; C++) for (M = 0; M < l; M++) {
      for (g = 4 * (C * l + M), p = 0, f = 0, m = 0, _ = 0, T = 0; T < o; T++) for (E = 0; E < o; E++) S = C + T - a, v = M + E - a, S < 0 || S >= c || v < 0 || v >= l || (b = 4 * (S * l + v), x = s[T * o + E], p += i[b] * x, f += i[b + 1] * x, m += i[b + 2] * x, d || (_ += i[b + 3] * x));
      h[g] = p, h[g + 1] = f, h[g + 2] = m, h[g + 3] = d ? i[g + 3] : _;
    }
    e.imageData = u;
  }
  sendUniformData(e, n) {
    e.uniform1fv(n.uMatrix, this.matrix);
  }
  toObject() {
    return Ie(Ie({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
Re(bh, "type", "Convolute"), Re(bh, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), Re(bh, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), ht.setClass(bh);
const iS = "Gamma";
class wh extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = this.gamma, s = 1 / i[0], o = 1 / i[1], a = 1 / i[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const l = this.rgbValues;
    for (let c = 0; c < 256; c++) l.r[c] = 255 * Math.pow(c / 255, s), l.g[c] = 255 * Math.pow(c / 255, o), l.b[c] = 255 * Math.pow(c / 255, a);
    for (let c = 0; c < n.length; c += 4) n[c] = l.r[n[c]], n[c + 1] = l.g[n[c + 1]], n[c + 2] = l.b[n[c + 2]];
  }
  sendUniformData(e, n) {
    e.uniform3fv(n.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: iS, gamma: this.gamma.concat() };
  }
}
Re(wh, "type", iS), Re(wh, "defaults", { gamma: [1, 1, 1] }), Re(wh, "uniformLocations", ["uGamma"]), ht.setClass(wh);
const o9 = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class Sh extends $n {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let i, s = 0; s < n.length; s += 4) {
      const o = n[s], a = n[s + 1], l = n[s + 2];
      switch (this.mode) {
        case "average":
          i = (o + a + l) / 3;
          break;
        case "lightness":
          i = (Math.min(o, a, l) + Math.max(o, a, l)) / 2;
          break;
        case "luminosity":
          i = 0.21 * o + 0.72 * a + 0.07 * l;
      }
      n[s + 2] = n[s + 1] = n[s] = i;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return o9[this.mode];
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
Re(Sh, "type", "Grayscale"), Re(Sh, "defaults", { mode: "average" }), Re(Sh, "uniformLocations", ["uMode"]), ht.setClass(Sh);
const a9 = Ie(Ie({}, nS), {}, { rotation: 0 });
class Wp extends ja {
  calculateMatrix() {
    const e = this.rotation * Math.PI, n = Er(e), i = Ar(e), s = 1 / 3, o = Math.sqrt(s) * i, a = 1 - n;
    this.matrix = [n + a / 3, s * a - o, s * a + o, 0, 0, s * a + o, n + s * a, s * a - o, 0, 0, s * a - o, s * a + o, n + s * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
Re(Wp, "type", "HueRotation"), Re(Wp, "defaults", a9), ht.setClass(Wp);
class Mh extends $n {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let i = 0; i < n.length; i += 4) n[i] = 255 - n[i], n[i + 1] = 255 - n[i + 1], n[i + 2] = 255 - n[i + 2], this.alpha && (n[i + 3] = 255 - n[i + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uInvert, Number(this.invert)), e.uniform1i(n.uAlpha, Number(this.alpha));
  }
}
Re(Mh, "type", "Invert"), Re(Mh, "defaults", { alpha: !1, invert: !0 }), Re(Mh, "uniformLocations", ["uInvert", "uAlpha"]), ht.setClass(Mh);
class Ch extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = this.noise;
    for (let s = 0; s < n.length; s += 4) {
      const o = (0.5 - Math.random()) * i;
      n[s] += o, n[s + 1] += o, n[s + 2] += o;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uNoise, this.noise / 255), e.uniform1f(n.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
Re(Ch, "type", "Noise"), Re(Ch, "defaults", { noise: 0 }), Re(Ch, "uniformLocations", ["uNoise", "uSeed"]), ht.setClass(Ch);
class Th extends $n {
  applyTo2d(e) {
    let { imageData: { data: n, width: i, height: s } } = e;
    for (let o = 0; o < s; o += this.blocksize) for (let a = 0; a < i; a += this.blocksize) {
      const l = 4 * o * i + 4 * a, c = n[l], u = n[l + 1], h = n[l + 2], d = n[l + 3];
      for (let p = o; p < Math.min(o + this.blocksize, s); p++) for (let f = a; f < Math.min(a + this.blocksize, i); f++) {
        const m = 4 * p * i + 4 * f;
        n[m] = c, n[m + 1] = u, n[m + 2] = h, n[m + 3] = d;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBlocksize, this.blocksize);
  }
}
Re(Th, "type", "Pixelate"), Re(Th, "defaults", { blocksize: 4 }), Re(Th, "uniformLocations", ["uBlocksize"]), ht.setClass(Th);
class Eh extends $n {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = 255 * this.distance, s = new sn(this.color).getSource(), o = [s[0] - i, s[1] - i, s[2] - i], a = [s[0] + i, s[1] + i, s[2] + i];
    for (let l = 0; l < n.length; l += 4) {
      const c = n[l], u = n[l + 1], h = n[l + 2];
      c > o[0] && u > o[1] && h > o[2] && c < a[0] && u < a[1] && h < a[2] && (n[l + 3] = 0);
    }
  }
  sendUniformData(e, n) {
    const i = new sn(this.color).getSource(), s = this.distance, o = [0 + i[0] / 255 - s, 0 + i[1] / 255 - s, 0 + i[2] / 255 - s, 1], a = [i[0] / 255 + s, i[1] / 255 + s, i[2] / 255 + s, 1];
    e.uniform4fv(n.uLow, o), e.uniform4fv(n.uHigh, a);
  }
}
Re(Eh, "type", "RemoveColor"), Re(Eh, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), Re(Eh, "uniformLocations", ["uLow", "uHigh"]), ht.setClass(Eh);
class Ah extends $n {
  sendUniformData(e, n) {
    e.uniform2fv(n.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(n.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), n = this.tempScale, i = this.getFilterWindow(), s = new Array(i);
    for (let o = 1; o <= i; o++) s[o - 1] = e(o * n);
    return s;
  }
  generateShader(e) {
    const n = new Array(e);
    for (let i = 1; i <= e; i++) n[i - 1] = "".concat(i, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(n.map((i, s) => `
              color += texture2D(uTexture, vTexCoord + `.concat(i, ") * uTaps[").concat(s, "] + texture2D(uTexture, vTexCoord - ").concat(i, ") * uTaps[").concat(s, `];
              sum += 2.0 * uTaps[`).concat(s, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    wf(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (n) => {
      if (n >= e || n <= -e) return 0;
      if (n < 11920929e-14 && n > -11920929e-14) return 1;
      const i = (n *= Math.PI) / e;
      return Math.sin(n) / n * Math.sin(i) / i;
    };
  }
  applyTo2d(e) {
    const n = e.imageData, i = this.scaleX, s = this.scaleY;
    this.rcpScaleX = 1 / i, this.rcpScaleY = 1 / s;
    const o = n.width, a = n.height, l = Math.round(o * i), c = Math.round(a * s);
    let u;
    u = this.resizeType === "sliceHack" ? this.sliceByTwo(e, o, a, l, c) : this.resizeType === "hermite" ? this.hermiteFastResize(e, o, a, l, c) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, o, a, l, c) : this.resizeType === "lanczos" ? this.lanczosResize(e, o, a, l, c) : new ImageData(l, c), e.imageData = u;
  }
  sliceByTwo(e, n, i, s, o) {
    const a = e.imageData, l = 0.5;
    let c = !1, u = !1, h = n * l, d = i * l;
    const p = e.filterBackend.resources;
    let f = 0, m = 0;
    const _ = n;
    let g = 0;
    p.sliceByTwo || (p.sliceByTwo = Pr());
    const v = p.sliceByTwo;
    (v.width < 1.5 * n || v.height < i) && (v.width = 1.5 * n, v.height = i);
    const S = v.getContext("2d");
    for (S.clearRect(0, 0, 1.5 * n, i), S.putImageData(a, 0, 0), s = Math.floor(s), o = Math.floor(o); !c || !u; ) n = h, i = d, s < Math.floor(h * l) ? h = Math.floor(h * l) : (h = s, c = !0), o < Math.floor(d * l) ? d = Math.floor(d * l) : (d = o, u = !0), S.drawImage(v, f, m, n, i, _, g, h, d), f = _, m = g, g += d;
    return S.getImageData(f, m, s, o);
  }
  lanczosResize(e, n, i, s, o) {
    const a = e.imageData.data, l = e.ctx.createImageData(s, o), c = l.data, u = this.lanczosCreate(this.lanczosLobes), h = this.rcpScaleX, d = this.rcpScaleY, p = 2 / this.rcpScaleX, f = 2 / this.rcpScaleY, m = Math.ceil(h * this.lanczosLobes / 2), _ = Math.ceil(d * this.lanczosLobes / 2), g = {}, v = { x: 0, y: 0 }, S = { x: 0, y: 0 };
    return function b(x) {
      let M, C, E, T, w, A, O, U, D, L, P;
      for (v.x = (x + 0.5) * h, S.x = Math.floor(v.x), M = 0; M < o; M++) {
        for (v.y = (M + 0.5) * d, S.y = Math.floor(v.y), w = 0, A = 0, O = 0, U = 0, D = 0, C = S.x - m; C <= S.x + m; C++) if (!(C < 0 || C >= n)) {
          L = Math.floor(1e3 * Math.abs(C - v.x)), g[L] || (g[L] = {});
          for (let V = S.y - _; V <= S.y + _; V++) V < 0 || V >= i || (P = Math.floor(1e3 * Math.abs(V - v.y)), g[L][P] || (g[L][P] = u(Math.sqrt(Math.pow(L * p, 2) + Math.pow(P * f, 2)) / 1e3)), E = g[L][P], E > 0 && (T = 4 * (V * n + C), w += E, A += E * a[T], O += E * a[T + 1], U += E * a[T + 2], D += E * a[T + 3]));
        }
        T = 4 * (M * s + x), c[T] = A / w, c[T + 1] = O / w, c[T + 2] = U / w, c[T + 3] = D / w;
      }
      return ++x < s ? b(x) : l;
    }(0);
  }
  bilinearFiltering(e, n, i, s, o) {
    let a, l, c, u, h, d, p, f, m, _, g, v, S, b = 0;
    const x = this.rcpScaleX, M = this.rcpScaleY, C = 4 * (n - 1), E = e.imageData.data, T = e.ctx.createImageData(s, o), w = T.data;
    for (p = 0; p < o; p++) for (f = 0; f < s; f++) for (h = Math.floor(x * f), d = Math.floor(M * p), m = x * f - h, _ = M * p - d, S = 4 * (d * n + h), g = 0; g < 4; g++) a = E[S + g], l = E[S + 4 + g], c = E[S + C + g], u = E[S + C + 4 + g], v = a * (1 - m) * (1 - _) + l * m * (1 - _) + c * _ * (1 - m) + u * m * _, w[b++] = v;
    return T;
  }
  hermiteFastResize(e, n, i, s, o) {
    const a = this.rcpScaleX, l = this.rcpScaleY, c = Math.ceil(a / 2), u = Math.ceil(l / 2), h = e.imageData.data, d = e.ctx.createImageData(s, o), p = d.data;
    for (let f = 0; f < o; f++) for (let m = 0; m < s; m++) {
      const _ = 4 * (m + f * s);
      let g = 0, v = 0, S = 0, b = 0, x = 0, M = 0, C = 0;
      const E = (f + 0.5) * l;
      for (let T = Math.floor(f * l); T < (f + 1) * l; T++) {
        const w = Math.abs(E - (T + 0.5)) / u, A = (m + 0.5) * a, O = w * w;
        for (let U = Math.floor(m * a); U < (m + 1) * a; U++) {
          let D = Math.abs(A - (U + 0.5)) / c;
          const L = Math.sqrt(O + D * D);
          L > 1 && L < -1 || (g = 2 * L * L * L - 3 * L * L + 1, g > 0 && (D = 4 * (U + T * n), C += g * h[D + 3], S += g, h[D + 3] < 255 && (g = g * h[D + 3] / 250), b += g * h[D], x += g * h[D + 1], M += g * h[D + 2], v += g));
        }
      }
      p[_] = b / v, p[_ + 1] = x / v, p[_ + 2] = M / v, p[_ + 3] = C / S;
    }
    return d;
  }
}
Re(Ah, "type", "Resize"), Re(Ah, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), Re(Ah, "uniformLocations", ["uDelta", "uTaps"]), ht.setClass(Ah);
class Ph extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = -this.saturation;
    for (let s = 0; s < n.length; s += 4) {
      const o = n[s], a = n[s + 1], l = n[s + 2], c = Math.max(o, a, l);
      n[s] += c !== o ? (c - o) * i : 0, n[s + 1] += c !== a ? (c - a) * i : 0, n[s + 2] += c !== l ? (c - l) * i : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
Re(Ph, "type", "Saturation"), Re(Ph, "defaults", { saturation: 0 }), Re(Ph, "uniformLocations", ["uSaturation"]), ht.setClass(Ph);
class Dh extends $n {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const i = -this.vibrance;
    for (let s = 0; s < n.length; s += 4) {
      const o = n[s], a = n[s + 1], l = n[s + 2], c = Math.max(o, a, l), u = (o + a + l) / 3, h = 2 * Math.abs(c - u) / 255 * i;
      n[s] += c !== o ? (c - o) * h : 0, n[s + 1] += c !== a ? (c - a) * h : 0, n[s + 2] += c !== l ? (c - l) * h : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
Re(Dh, "type", "Vibrance"), Re(Dh, "defaults", { vibrance: 0 }), Re(Dh, "uniformLocations", ["uVibrance"]), ht.setClass(Dh);
const q1 = l9(), Z1 = c9();
function l9() {
  const r = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, i = Math.round(255 * il(0.267004 + n * (4874e-6 + n * (-0.259027 + n * (2.066795 + n * (-2.131557 + n * 0.736987)))))), s = Math.round(255 * il(4874e-6 + n * (1.404613 + n * (-0.598103 + n * (-0.229949 + n * (0.659864 + n * -0.238132)))))), o = Math.round(255 * il(0.329415 + n * (1.384613 + n * (-1.860504 + n * (1.592785 + n * (-0.730173 + n * 0.13561))))));
    r[e * 4] = i, r[e * 4 + 1] = s, r[e * 4 + 2] = o, r[e * 4 + 3] = 255;
  }
  return r;
}
function c9() {
  const r = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, i = Math.round(255 * il(0.050383 + n * (2.689401 + n * (-1.802775 + n * (-0.391194 + n * (0.706557 + n * -0.218185)))))), s = Math.round(255 * il(0.029803 + n * (-0.177105 + n * (0.96833 + n * (0.419198 + n * (-0.991163 + n * 0.517737)))))), o = Math.round(255 * il(0.527975 + n * (1.546816 + n * (-4.246533 + n * (6.585146 + n * (-4.621553 + n * 1.205227))))));
    r[e * 4] = i, r[e * 4 + 1] = s, r[e * 4 + 2] = o, r[e * 4 + 3] = 255;
  }
  return r;
}
function il(r) {
  return Math.max(0, Math.min(1, r));
}
const Ho = class Ho extends Ri {
  constructor(e, n = {}) {
    super(e, {
      ...Ho.ownDefaults,
      ...n
    }), this.colormap = n.colormap || "viridis", this._colorizedCanvas = null, this._webglContext = null, this._webglProgram = null, this._sourceImageData = null, this._initializeColorization();
  }
  /**
   * Initialize the colorization system (WebGL or Canvas2D fallback)
   */
  _initializeColorization() {
    const e = this.getElement();
    e && (this._colorizedCanvas = document.createElement("canvas"), this._colorizedCanvas.width = e.width || e.naturalWidth, this._colorizedCanvas.height = e.height || e.naturalHeight, this._initWebGL() ? this._applyColormapWebGL() : this._applyColormapCanvas2D());
  }
  /**
   * Initialize WebGL context and shader program
   */
  _initWebGL() {
    if (!this._colorizedCanvas) return !1;
    try {
      const e = this._colorizedCanvas.getContext("webgl", {
        preserveDrawingBuffer: !0,
        alpha: !0
      });
      if (!e) return !1;
      this._webglContext = e;
      const n = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `, i = `
        precision mediump float;
        uniform sampler2D u_image;
        uniform sampler2D u_colormap;
        varying vec2 v_texCoord;
        void main() {
          vec4 depth = texture2D(u_image, v_texCoord);
          float gray = dot(depth.rgb, vec3(0.299, 0.587, 0.114));
          vec4 color = texture2D(u_colormap, vec2(gray, 0.5));
          gl_FragColor = vec4(color.rgb, depth.a);
        }
      `, s = this._compileShader(e, e.VERTEX_SHADER, n), o = this._compileShader(e, e.FRAGMENT_SHADER, i);
      if (!s || !o) return !1;
      const a = e.createProgram();
      return a ? (e.attachShader(a, s), e.attachShader(a, o), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) ? (this._webglProgram = a, !0) : (console.error("[DepthMapImage] Program link error:", e.getProgramInfoLog(a)), !1)) : !1;
    } catch (e) {
      return console.warn("[DepthMapImage] WebGL init failed:", e), !1;
    }
  }
  _compileShader(e, n, i) {
    const s = e.createShader(n);
    return s ? (e.shaderSource(s, i), e.compileShader(s), e.getShaderParameter(s, e.COMPILE_STATUS) ? s : (console.error("[DepthMapImage] Shader compile error:", e.getShaderInfoLog(s)), e.deleteShader(s), null)) : null;
  }
  /**
   * Apply colormap using WebGL
   */
  _applyColormapWebGL() {
    const e = this._webglContext, n = this._webglProgram;
    if (!e || !n || !this._colorizedCanvas) return;
    e.useProgram(n);
    const i = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, i), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW);
    const s = e.getAttribLocation(n, "a_position");
    e.enableVertexAttribArray(s), e.vertexAttribPointer(s, 2, e.FLOAT, !1, 0, 0);
    const o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
    const a = e.getAttribLocation(n, "a_texCoord");
    e.enableVertexAttribArray(a), e.vertexAttribPointer(a, 2, e.FLOAT, !1, 0, 0);
    const l = e.createTexture();
    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, l), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.getElement());
    const c = e.createTexture();
    e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, c), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR);
    const u = this.colormap === "plasma" ? Z1 : q1;
    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 256, 1, 0, e.RGBA, e.UNSIGNED_BYTE, u), e.uniform1i(e.getUniformLocation(n, "u_image"), 0), e.uniform1i(e.getUniformLocation(n, "u_colormap"), 1), e.viewport(0, 0, this._colorizedCanvas.width, this._colorizedCanvas.height), e.drawArrays(e.TRIANGLES, 0, 6);
  }
  /**
   * Apply colormap using Canvas2D (fallback)
   */
  _applyColormapCanvas2D() {
    if (!this._colorizedCanvas) return;
    const e = this._colorizedCanvas.getContext("2d");
    if (!e) return;
    const n = this.getElement(), i = this._colorizedCanvas.width, s = this._colorizedCanvas.height;
    e.drawImage(n, 0, 0, i, s);
    const o = e.getImageData(0, 0, i, s), a = o.data, l = this.colormap === "plasma" ? Z1 : this.colormap === "viridis" ? q1 : null;
    if (l) {
      for (let c = 0; c < a.length; c += 4) {
        const u = Math.round(
          a[c] * 0.299 + a[c + 1] * 0.587 + a[c + 2] * 0.114
        );
        a[c] = l[u * 4], a[c + 1] = l[u * 4 + 1], a[c + 2] = l[u * 4 + 2];
      }
      e.putImageData(o, 0, 0);
    }
  }
  /**
   * Set the colormap and re-apply
   */
  setColormap(e) {
    var n;
    this.colormap = e, this._webglContext && this._webglProgram ? this._applyColormapWebGL() : this._applyColormapCanvas2D(), this.dirty = !0, (n = this.canvas) == null || n.requestRenderAll();
  }
  /**
   * Override render to use colorized canvas
   */
  render(e) {
    if (this._colorizedCanvas && this.colormap !== "grayscale") {
      const n = this.getElement();
      this.setElement(this._colorizedCanvas), super.render(e), this.setElement(n);
    } else
      super.render(e);
  }
  /**
   * Get serializable properties including colormap
   */
  getSerializableData() {
    return {
      colormap: this.colormap
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    return new Promise((n, i) => {
      if (!e.src) {
        i(new Error("DepthMapImage requires a src property"));
        return;
      }
      const s = new Image();
      s.crossOrigin = "anonymous", s.onload = () => {
        n(new Ho(s, {
          colormap: e.colormap,
          ...e
        }));
      }, s.onerror = i, s.src = e.src;
    });
  }
  /**
   * Create from base64 data
   */
  static fromBase64(e, n = {}) {
    return new Promise((i, s) => {
      const o = new Image();
      o.crossOrigin = "anonymous", o.onload = () => {
        i(new Ho(o, n));
      }, o.onerror = s, o.src = e.startsWith("data:") ? e : `data:image/png;base64,${e}`;
    });
  }
};
pe(Ho, "type", "DepthMapImage"), pe(Ho, "ownDefaults", {
  colormap: "viridis",
  opacity: 0.5,
  visible: !0
});
let zd = Ho;
ht.setClass(zd);
const $a = class $a extends io {
  constructor(e, n = {}) {
    super(e, {
      ...$a.ownDefaults,
      ...n
    }), this.controlPoints = n.controlPoints || [], this._animationKeyframes = [];
  }
  /**
   * Update path data from control points
   */
  updatePathFromControlPoints() {
    if (this.controlPoints.length < 2) {
      this.set("path", []);
      return;
    }
    const e = [], n = this.controlPoints;
    e.push(["M", n[0].x, n[0].y]);
    for (let i = 0; i < n.length - 1; i++) {
      const s = n[i], o = n[i + 1], a = s.handleOut || { x: s.x, y: s.y }, l = o.handleIn || { x: o.x, y: o.y };
      e.push([
        "C",
        a.x,
        a.y,
        l.x,
        l.y,
        o.x,
        o.y
      ]);
    }
    this.set("path", e), this.setCoords();
  }
  /**
   * Add a new control point at position
   */
  addControlPoint(e, n, i) {
    const s = {
      id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      x: e,
      y: n,
      depth: i,
      handleIn: null,
      handleOut: null,
      type: "corner"
    };
    return this.controlPoints.push(s), this.updatePathFromControlPoints(), s;
  }
  /**
   * Move a control point
   */
  moveControlPoint(e, n, i) {
    const s = this.controlPoints.find((l) => l.id === e);
    if (!s) return;
    const o = n - s.x, a = i - s.y;
    s.x = n, s.y = i, s.handleIn && (s.handleIn.x += o, s.handleIn.y += a), s.handleOut && (s.handleOut.x += o, s.handleOut.y += a), this.updatePathFromControlPoints();
  }
  /**
   * Set handle position for a control point
   */
  setHandle(e, n, i, s, o = !1) {
    const a = this.controlPoints.find((l) => l.id === e);
    if (a) {
      if (n === "in" ? a.handleIn = { x: i, y: s } : a.handleOut = { x: i, y: s }, !o && a.type === "smooth") {
        const l = n === "in" ? a.handleIn : a.handleOut, c = n === "in" ? "handleOut" : "handleIn";
        if (l) {
          const u = l.x - a.x, h = l.y - a.y;
          a[c] = {
            x: a.x - u,
            y: a.y - h
          };
        }
      }
      this.updatePathFromControlPoints();
    }
  }
  /**
   * Delete a control point
   */
  deleteControlPoint(e) {
    const n = this.controlPoints.findIndex((i) => i.id === e);
    n !== -1 && (this.controlPoints.splice(n, 1), this.updatePathFromControlPoints());
  }
  /**
   * Get spline data for serialization
   */
  getSplineData() {
    var e;
    return {
      pathData: ((e = this.path) == null ? void 0 : e.map((n) => n.join(" ")).join(" ")) || "",
      controlPoints: this.controlPoints,
      closed: !1,
      stroke: this.stroke,
      strokeWidth: this.strokeWidth,
      fill: this.fill
    };
  }
  /**
   * Get serializable properties
   */
  getSerializableData() {
    return {
      controlPoints: this.controlPoints,
      _animationKeyframes: this._animationKeyframes
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    var i;
    const n = ((i = e.path) == null ? void 0 : i.map((s) => s.join(" ")).join(" ")) || "";
    return Promise.resolve(new $a(n, {
      ...e,
      controlPoints: e.controlPoints || []
    }));
  }
};
// Type identifier for serialization
pe($a, "type", "SplinePath"), // Default values
pe($a, "ownDefaults", {
  stroke: "#00ff00",
  strokeWidth: 2,
  fill: "",
  selectable: !0,
  controlPoints: []
});
let Bd = $a;
ht.setClass(Bd);
const Xa = class Xa extends oo {
  constructor(e = {}) {
    super([], {
      ...Xa.ownDefaults,
      ...e,
      subTargetCheck: !0,
      interactive: !1
    }), this.textContent = e.text || "Text", this.fontFamily = e.fontFamily || "Arial", this.fontSize = e.fontSize || 48, this.fontWeight = e.fontWeight || "400", this.fontStyle = e.fontStyle || "normal", this.textFill = e.fill || "#ffffff", this.textStroke = e.stroke || "", this.textStrokeWidth = e.strokeWidth || 0, this.letterSpacing = e.letterSpacing || 0, this.textAlign = e.textAlign || "left", this.pathLayerId = e.pathLayerId || null, this.pathOffset = e.pathOffset || 0, this._letterObjects = [], this._createLetterObjects();
  }
  /**
   * Create individual letter objects for per-character animation
   */
  _createLetterObjects() {
    this.removeAll(), this._letterObjects = [], console.log("[AnimatedText] Creating letters for text:", this.textContent, "fontSize:", this.fontSize, "fill:", this.textFill);
    const n = document.createElement("canvas").getContext("2d");
    for (const i of this.textContent) {
      const s = new ui(i, {
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontWeight: this.fontWeight,
        fontStyle: this.fontStyle,
        fill: this.textFill,
        stroke: this.textStroke,
        strokeWidth: this.textStrokeWidth,
        originX: "center",
        originY: "center",
        selectable: !1,
        evented: !1
      });
      let o = s.width;
      (!o || o === 0) && n && (n.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`, o = n.measureText(i).width, s.set({ width: o })), console.log("[AnimatedText] Letter:", i, "width:", o, "height:", s.height || this.fontSize), this._letterObjects.push(s), this.add(s);
    }
    this._layoutLettersHorizontal();
  }
  /**
   * Layout letters horizontally and update group bounds
   */
  _layoutLettersHorizontal() {
    const n = document.createElement("canvas").getContext("2d");
    n && (n.font = `${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`);
    let i = 0;
    for (const c of this._letterObjects) {
      let u = c.width;
      (!u || u === 0) && (n ? (u = n.measureText(c.text || " ").width, c.set({ width: u })) : u = this.fontSize * 0.6), i += u + this.letterSpacing;
    }
    i -= this.letterSpacing;
    const s = -i / 2;
    let o = 0;
    for (const c of this._letterObjects) {
      const u = c.width || this.fontSize * 0.6;
      c.set({
        left: s + o + u / 2,
        top: 0,
        angle: 0
      }), o += u + this.letterSpacing;
    }
    const a = Math.max(i, 10), l = this.fontSize * 1.5;
    this.set({
      width: a,
      height: l,
      // Disable clipping
      clipPath: void 0
    }), this.setCoords(), console.log("[AnimatedText] Layout complete. Group width:", a, "height:", l, "letterCount:", this._letterObjects.length, "totalTextWidth:", i);
  }
  /**
   * Position letters along a bezier path
   */
  positionOnPath(e, n) {
    const i = e.totalLength;
    let s = n * i, o = 0, a = 0;
    for (const l of this._letterObjects) {
      const c = l.width || this.fontSize * 0.6, u = Math.max(0, Math.min(s, i)), { point: h, tangent: d } = e.getPointAtDistance(u), p = Math.atan2(d.y, d.x) * (180 / Math.PI);
      l.set({
        left: h.x,
        top: h.y,
        angle: p
      }), o = Math.max(o, h.x + c), a = Math.max(a, h.y + this.fontSize), s += c + this.letterSpacing;
    }
    this.set({ width: o || 100, height: a || this.fontSize * 1.2 }), this.setCoords(), this.dirty = !0;
  }
  setText(e) {
    this.textContent = e, this._createLetterObjects(), this.dirty = !0, this.canvas && this.canvas.requestRenderAll();
  }
  setFont(e, n, i, s) {
    this.fontFamily = e, this.fontSize = n, i && (this.fontWeight = i), s && (this.fontStyle = s), this._createLetterObjects();
  }
  setFontStyle(e) {
    this.fontStyle = e;
    for (const n of this._letterObjects)
      n.set("fontStyle", e);
    this.dirty = !0;
  }
  setTextAlign(e) {
    this.textAlign = e, this._layoutLettersHorizontal(), this.dirty = !0;
  }
  setFillColor(e) {
    this.textFill = e;
    for (const n of this._letterObjects)
      n.set("fill", e);
    this.dirty = !0;
  }
  setStroke(e, n) {
    this.textStroke = e, this.textStrokeWidth = n;
    for (const i of this._letterObjects)
      i.set({ stroke: e, strokeWidth: n });
    this.dirty = !0;
  }
  setLetterSpacing(e) {
    this.letterSpacing = e, this.pathLayerId || this._layoutLettersHorizontal();
  }
  getTextWidth() {
    let e = 0;
    for (const n of this._letterObjects)
      e += (n.width || 0) + this.letterSpacing;
    return Math.max(0, e - this.letterSpacing);
  }
  getTextData() {
    return {
      text: this.textContent,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontStyle: "normal",
      fill: this.textFill,
      stroke: this.textStroke,
      strokeWidth: this.textStrokeWidth,
      letterSpacing: this.letterSpacing,
      lineHeight: 1.2,
      textAlign: "left",
      pathLayerId: this.pathLayerId,
      pathOffset: this.pathOffset,
      pathAlign: "left"
    };
  }
  getSerializableData() {
    return {
      textContent: this.textContent,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      textFill: this.textFill,
      textStroke: this.textStroke,
      textStrokeWidth: this.textStrokeWidth,
      letterSpacing: this.letterSpacing,
      pathLayerId: this.pathLayerId,
      pathOffset: this.pathOffset
    };
  }
  static fromObject(e) {
    return Promise.resolve(new Xa({
      text: e.textContent,
      fontFamily: e.fontFamily,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fill: e.textFill,
      stroke: e.textStroke,
      strokeWidth: e.textStrokeWidth,
      letterSpacing: e.letterSpacing,
      pathLayerId: e.pathLayerId,
      pathOffset: e.pathOffset
    }));
  }
};
pe(Xa, "type", "AnimatedText"), pe(Xa, "ownDefaults", {
  text: "Text",
  fontFamily: "Arial",
  fontSize: 48,
  fontWeight: "400",
  fontStyle: "normal",
  fill: "#ffffff",
  stroke: "",
  strokeWidth: 0,
  letterSpacing: 0,
  textAlign: "left",
  pathLayerId: null,
  pathOffset: 0,
  selectable: !0
});
let Nd = Xa;
ht.setClass(Nd);
const u9 = { class: "spline-editor" }, h9 = ["viewBox"], d9 = ["x1", "y1", "x2", "y2"], f9 = ["x1", "y1", "x2", "y2"], p9 = ["cx", "cy", "onMousedown"], m9 = ["cx", "cy", "onMousedown"], g9 = ["cx", "cy", "onMousedown"], v9 = ["cx", "cy"], y9 = /* @__PURE__ */ jt({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(r, { expose: e, emit: n }) {
    const i = r, s = n, o = _n(), a = Ce(null), l = Ce(null), c = Ce(null), u = Xe(() => {
      if (!i.layerId) return [];
      const S = o.layers.find((x) => x.id === i.layerId);
      return !S || S.type !== "spline" || !S.data ? [] : S.data.controlPoints || [];
    });
    function h(S, b) {
      const x = i.viewportTransform, M = (S - x[4]) / x[0], C = (b - x[5]) / x[3];
      return { x: M, y: C };
    }
    function d(S) {
      const x = S.currentTarget.getBoundingClientRect(), M = S.clientX - x.left, C = S.clientY - x.top;
      return h(M, C);
    }
    function p(S) {
      if (!i.isPenMode) return;
      const b = d(S);
      if (i.layerId) {
        const x = o.layers.find((M) => M.id === i.layerId);
        if (x && x.type === "spline") {
          const M = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: b.x,
            y: b.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          o.addSplineControlPoint(i.layerId, M), a.value = M.id, c.value = {
            type: "handleOut",
            pointId: M.id,
            startX: b.x,
            startY: b.y
          }, s("pointAdded", M), s("pathUpdated");
        }
      }
    }
    function f(S) {
      var x;
      const b = d(S);
      if (i.isPenMode && (l.value = b), c.value && i.layerId) {
        const M = o.layers.find((T) => T.id === i.layerId);
        if (!M || M.type !== "spline") return;
        const E = (x = M.data.controlPoints) == null ? void 0 : x.find((T) => T.id === c.value.pointId);
        if (!E) return;
        if (c.value.type === "point") {
          const T = b.x - E.x, w = b.y - E.y, A = { x: b.x, y: b.y };
          E.handleIn && (A.handleIn = { x: E.handleIn.x + T, y: E.handleIn.y + w }), E.handleOut && (A.handleOut = { x: E.handleOut.x + T, y: E.handleOut.y + w }), o.updateSplineControlPoint(i.layerId, E.id, A), s("pointMoved", E.id, b.x, b.y);
        } else if (c.value.type === "handleIn") {
          const T = { handleIn: { x: b.x, y: b.y } };
          if (E.type === "smooth") {
            const w = b.x - E.x, A = b.y - E.y;
            T.handleOut = { x: E.x - w, y: E.y - A };
          }
          o.updateSplineControlPoint(i.layerId, E.id, T), s("handleMoved", E.id, "in", b.x, b.y);
        } else if (c.value.type === "handleOut") {
          const T = { handleOut: { x: b.x, y: b.y } };
          if (E.type === "smooth") {
            const w = b.x - E.x, A = b.y - E.y;
            T.handleIn = { x: E.x - w, y: E.y - A };
          }
          o.updateSplineControlPoint(i.layerId, E.id, T), s("handleMoved", E.id, "out", b.x, b.y);
        }
        s("pathUpdated");
      }
    }
    function m() {
      var S;
      if (c.value && i.layerId) {
        const b = o.layers.find((x) => x.id === i.layerId);
        if (b && b.type === "spline") {
          const M = (S = b.data.controlPoints) == null ? void 0 : S.find((C) => C.id === c.value.pointId);
          if (M && M.handleOut) {
            const C = M.handleOut.x - M.x, E = M.handleOut.y - M.y;
            Math.sqrt(C * C + E * E) > 5 ? o.updateSplineControlPoint(i.layerId, M.id, {
              type: "smooth",
              handleIn: { x: M.x - C, y: M.y - E }
            }) : o.updateSplineControlPoint(i.layerId, M.id, {
              handleOut: null
            });
          }
        }
        c.value = null, s("pathUpdated");
      }
    }
    function _(S, b) {
      if (a.value = S, !i.isPenMode) {
        const x = d(b);
        c.value = {
          type: "point",
          pointId: S,
          startX: x.x,
          startY: x.y
        };
      }
    }
    function g(S, b, x) {
      const M = d(x);
      c.value = {
        type: b === "in" ? "handleIn" : "handleOut",
        pointId: S,
        startX: M.x,
        startY: M.y
      };
    }
    function v(S) {
      if ((S.key === "Delete" || S.key === "Backspace") && a.value && i.layerId) {
        const b = o.layers.find((x) => x.id === i.layerId);
        if (b && b.type === "spline") {
          const x = a.value;
          o.deleteSplineControlPoint(i.layerId, x), s("pointDeleted", x), s("pathUpdated"), a.value = null;
        }
      }
    }
    return Xn(() => {
      window.addEventListener("keydown", v);
    }), Ni(() => {
      window.removeEventListener("keydown", v);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (S, b) => (ie(), ue("div", u9, [
      (ie(), ue("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${r.canvasWidth} ${r.canvasHeight}`,
        onMousedown: p,
        onMousemove: f,
        onMouseup: m,
        onMouseleave: m
      }, [
        (ie(!0), ue(nt, null, pt(u.value, (x) => (ie(), ue(nt, {
          key: `handles-${x.id}`
        }, [
          x.handleIn && a.value === x.id ? (ie(), ue("line", {
            key: 0,
            x1: x.x,
            y1: x.y,
            x2: x.handleIn.x,
            y2: x.handleIn.y,
            class: "handle-line"
          }, null, 8, d9)) : Ne("", !0),
          x.handleOut && a.value === x.id ? (ie(), ue("line", {
            key: 1,
            x1: x.x,
            y1: x.y,
            x2: x.handleOut.x,
            y2: x.handleOut.y,
            class: "handle-line"
          }, null, 8, f9)) : Ne("", !0)
        ], 64))), 128)),
        (ie(!0), ue(nt, null, pt(u.value, (x) => {
          var M, C;
          return ie(), ue(nt, {
            key: `handle-points-${x.id}`
          }, [
            x.handleIn && a.value === x.id ? (ie(), ue("circle", {
              key: 0,
              cx: x.handleIn.x,
              cy: x.handleIn.y,
              r: "4",
              class: Ye(["handle-point", { active: ((M = c.value) == null ? void 0 : M.type) === "handleIn" && c.value.pointId === x.id }]),
              onMousedown: Rt((E) => g(x.id, "in", E), ["stop"])
            }, null, 42, p9)) : Ne("", !0),
            x.handleOut && a.value === x.id ? (ie(), ue("circle", {
              key: 1,
              cx: x.handleOut.x,
              cy: x.handleOut.y,
              r: "4",
              class: Ye(["handle-point", { active: ((C = c.value) == null ? void 0 : C.type) === "handleOut" && c.value.pointId === x.id }]),
              onMousedown: Rt((E) => g(x.id, "out", E), ["stop"])
            }, null, 42, m9)) : Ne("", !0)
          ], 64);
        }), 128)),
        (ie(!0), ue(nt, null, pt(u.value, (x) => (ie(), ue("circle", {
          key: `point-${x.id}`,
          cx: x.x,
          cy: x.y,
          r: "6",
          class: Ye(["control-point", {
            selected: a.value === x.id,
            corner: x.type === "corner",
            smooth: x.type === "smooth"
          }]),
          onMousedown: Rt((M) => _(x.id, M), ["stop"])
        }, null, 42, g9))), 128)),
        l.value && r.isPenMode ? (ie(), ue("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, v9)) : Ne("", !0)
      ], 40, h9))
    ]));
  }
}), sS = /* @__PURE__ */ Yt(y9, [["__scopeId", "data-v-55bdee8d"]]), rS = /* @__PURE__ */ Math.sqrt(3), _9 = 0.5 * (rS - 1), Kl = (3 - rS) / 6, K1 = (r) => Math.floor(r) | 0, J1 = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function x9(r = Math.random) {
  const e = b9(r), n = new Float64Array(e).map((s) => J1[s % 12 * 2]), i = new Float64Array(e).map((s) => J1[s % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, c = 0, u = 0;
    const h = (o + a) * _9, d = K1(o + h), p = K1(a + h), f = (d + p) * Kl, m = d - f, _ = p - f, g = o - m, v = a - _;
    let S, b;
    g > v ? (S = 1, b = 0) : (S = 0, b = 1);
    const x = g - S + Kl, M = v - b + Kl, C = g - 1 + 2 * Kl, E = v - 1 + 2 * Kl, T = d & 255, w = p & 255;
    let A = 0.5 - g * g - v * v;
    if (A >= 0) {
      const D = T + e[w], L = n[D], P = i[D];
      A *= A, l = A * A * (L * g + P * v);
    }
    let O = 0.5 - x * x - M * M;
    if (O >= 0) {
      const D = T + S + e[w + b], L = n[D], P = i[D];
      O *= O, c = O * O * (L * x + P * M);
    }
    let U = 0.5 - C * C - E * E;
    if (U >= 0) {
      const D = T + 1 + e[w + 1], L = n[D], P = i[D];
      U *= U, u = U * U * (L * C + P * E);
    }
    return 70 * (l + c + u);
  };
}
function b9(r) {
  const n = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    n[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const s = i + ~~(r() * (256 - i)), o = n[i];
    n[i] = n[s], n[s] = o;
  }
  for (let i = 256; i < 512; i++)
    n[i] = n[i - 256];
  return n;
}
function w9() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function S9() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function Q1() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: w9()
  };
}
class Sf {
  constructor(e = {}) {
    pe(this, "particles", []);
    pe(this, "emitters", /* @__PURE__ */ new Map());
    pe(this, "gravityWells", /* @__PURE__ */ new Map());
    pe(this, "vortices", /* @__PURE__ */ new Map());
    pe(this, "modulations", []);
    pe(this, "config");
    pe(this, "boundaryMask", null);
    pe(this, "frameCount", 0);
    pe(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    pe(this, "nextParticleId", 0);
    pe(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    pe(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    pe(this, "noise2D");
    pe(this, "noiseTime", 0);
    // Render options cache for spatial grid
    pe(this, "renderOptions", Q1());
    this.config = { ...S9(), ...e }, this.noise2D = x9();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let i = 0; i < n; i++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const i = this.gravityWells.get(e);
    i && Object.assign(i, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const i = this.vortices.get(e);
    i && Object.assign(i, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((i) => i.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, i) {
    const s = i ? `${i}:${e}` : `*:${e}`;
    this.featureOverrides.set(s, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((u, h) => {
      if (!u.enabled) return;
      const p = (this.getFeatureValue("emissionRate", h) ?? u.emissionRate) * e;
      let f = (this.emissionAccumulators.get(h) || 0) + p;
      for (; f >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(u), f -= 1;
      this.emissionAccumulators.set(h, f);
    });
    const n = this.config.windDirection * Math.PI / 180, i = Math.cos(n) * this.config.windStrength * 1e-3, s = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = i * (a / Math.max(1, this.config.windStrength)), c = s * (a / Math.max(1, this.config.windStrength));
    for (let u = this.particles.length - 1; u >= 0; u--) {
      const h = this.particles[u];
      if (h.prevX = h.x, h.prevY = h.y, this.trailHistory.has(h.id)) {
        const p = this.trailHistory.get(h.id);
        p.unshift({ x: h.x, y: h.y }), p.length > 20 && p.pop();
      }
      h.vy += o * 1e-3 * e, h.vx += l * e, h.vy += c * e, this.gravityWells.forEach((p) => {
        if (!p.enabled) return;
        const f = p.x - h.x, m = p.y - h.y, _ = Math.sqrt(f * f + m * m);
        if (_ < p.radius && _ > 1e-3) {
          let g = p.strength * 1e-4;
          switch (p.falloff) {
            case "linear":
              g *= 1 - _ / p.radius;
              break;
            case "quadratic":
              g *= Math.pow(1 - _ / p.radius, 2);
              break;
          }
          const v = f / _, S = m / _;
          h.vx += v * g * e, h.vy += S * g * e;
        }
      }), this.vortices.forEach((p) => {
        if (!p.enabled) return;
        const f = p.x - h.x, m = p.y - h.y, _ = Math.sqrt(f * f + m * m);
        if (_ < p.radius && _ > 1e-3) {
          const g = 1 - _ / p.radius, v = p.strength * 1e-4 * g, S = f / _, b = m / _, x = -b, M = S;
          h.vx += x * v * e, h.vy += M * v * e;
          const C = p.inwardPull * 1e-4 * g;
          h.vx += S * C * e, h.vy += b * C * e;
        }
      }), this.applyTurbulence(h, e);
      const d = 1 - this.config.friction;
      h.vx *= d, h.vy *= d, h.x += h.vx * e, h.y += h.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(h), this.handleCanvasBoundary(h), this.applyModulations(h), h.age += e, h.age > h.lifetime && (h.isSubParticle || this.triggerSubEmitters(h), this.particles.splice(u, 1), this.trailHistory.delete(h.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, s = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), c = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), u = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(s) * a,
      vy: Math.sin(s) * a,
      age: 0,
      lifetime: c,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(u), this.trailHistory.set(u.id, [{ x: u.x, y: u.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), i = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || i < 0 || i >= this.boundaryMask.height)
      return;
    const s = (i * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[s] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const i of this.modulations) {
      if (i.emitterId !== "*" && i.emitterId !== e.emitterId) continue;
      const s = i.easing, o = wd[s] || wd.linear, a = ck(n, o), l = i.startValue + (i.endValue - i.startValue) * a;
      switch (i.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const i = this.config.turbulenceFields || [];
    for (const s of i) {
      if (!s.enabled) continue;
      const o = e.x * s.scale * 1e3, a = e.y * s.scale * 1e3, l = this.noiseTime * s.evolutionSpeed, c = this.noise2D(o + l, a + l) * Math.PI * 2, u = s.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var s;
    const i = (s = this.config.turbulenceFields) == null ? void 0 : s.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const i of n)
      if (i.enabled && !(i.parentEmitterId !== "*" && i.parentEmitterId !== e.emitterId))
        for (let s = 0; s < i.spawnCount; s++) {
          const o = (Math.random() - 0.5) * i.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * i.inheritVelocity, u = i.speed * 1e-3 + c, h = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * i.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * i.inheritVelocity,
            age: 0,
            lifetime: i.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: i.size * (1 + (Math.random() - 0.5) * i.sizeVariance / i.size),
            baseSize: i.size,
            color: [...i.color, 255],
            baseColor: [...i.color, 255],
            emitterId: i.id,
            isSubParticle: !0
          };
          this.particles.push(h), this.trailHistory.set(h.id, [{ x: h.x, y: h.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var s;
    const i = (s = this.config.subEmitters) == null ? void 0 : s.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const i = this.emitters.get(e);
    if (!i || !i.enabled) return;
    const s = n ?? i.burstCount ?? 20;
    for (let o = 0; o < s; o++)
      this.spawnParticle(i);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var i;
    const e = ((i = this.renderOptions.connections) == null ? void 0 : i.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const s of this.particles) {
      const o = Math.floor(s.x * 1e3 / e), a = Math.floor(s.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(s);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const i = Math.floor(e.x * 1e3 / n.cellSize), s = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const c = `${i + a},${s + l}`, u = n.cells.get(c);
        u && o.push(...u);
      }
    return o;
  }
  renderConnections(e, n, i) {
    const s = this.renderOptions.connections;
    if (!(s != null && s.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = s.maxDistance / 1e3, l = a * a;
    e.lineWidth = s.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, o);
      let h = 0;
      for (const d of u) {
        if (d.id <= c.id) continue;
        if (h >= s.maxConnections) break;
        const p = d.x - c.x, f = d.y - c.y, m = p * p + f * f;
        if (m < l) {
          const _ = Math.sqrt(m);
          let g = s.lineOpacity;
          s.fadeByDistance && (g *= 1 - _ / a);
          const v = Math.round((c.color[0] + d.color[0]) / 2), S = Math.round((c.color[1] + d.color[1]) / 2), b = Math.round((c.color[2] + d.color[2]) / 2);
          e.strokeStyle = `rgba(${v},${S},${b},${g})`, e.beginPath(), e.moveTo(c.x * n, c.y * i), e.lineTo(d.x * n, d.y * i), e.stroke(), h++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, i, s = Q1()) {
    switch (this.renderOptions = s, e.save(), s.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, i);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * i, c = o.size;
      if (s.renderTrails) {
        const u = this.trailHistory.get(o.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const h = Math.min(u.length, s.trailLength);
          for (let d = 0; d < h; d++) {
            const p = u[d], f = o.color[3] * Math.pow(s.trailOpacityFalloff, d + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${f / 255})`, e.lineWidth = c * Math.pow(s.trailOpacityFalloff, d), e.lineTo(p.x * n, p.y * i);
          }
          e.stroke();
        }
      }
      s.glowEnabled ? (e.shadowBlur = s.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${s.glowIntensity})`) : e.shadowBlur = 0, s.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, c, n, i, s) : this.renderParticleShape(e, a, l, c, o.color, s.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, i, s, o, a, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, i, s, o, n.color, c.particleShape);
      return;
    }
    const h = c.motionBlurStrength * u * 500, d = Math.min(c.motionBlurSamples, 16), p = n.vx / u, f = n.vy / u, m = Math.min(h * o, o * 10);
    for (let _ = 0; _ < d; _++) {
      const g = _ / (d - 1), v = (1 - g * 0.8) / d, S = i - p * m * g, b = s - f * m * g, x = o * (1 - g * 0.3), M = n.color[3] / 255 * v * d;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, M)})`, this.renderParticleShape(e, S, b, x, null, c.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, i, s, o, n.color, c.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, i, s, o, a) {
    switch (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, i, s / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - s / 2, i - s / 2, s, s);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, i - s / 2), e.lineTo(n - s / 2, i + s / 2), e.lineTo(n + s / 2, i + s / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, i, 5, s / 2, s / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, i, s, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < s; c++) {
      const u = n + Math.cos(l) * o, h = i + Math.sin(l) * o;
      c === 0 ? e.moveTo(u, h) : e.lineTo(u, h), l += Math.PI / s;
      const d = n + Math.cos(l) * a, p = i + Math.sin(l) * a;
      e.lineTo(d, p), l += Math.PI / s;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const s = new OffscreenCanvas(e, n).getContext("2d");
    s.fillStyle = "#FFFFFF", s.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (s.strokeStyle = "#000000", s.lineWidth = o.lineWidth * 2, this.renderConnections(s, e, n)), s.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, c = a.y * n, u = a.size * 1.5;
      s.beginPath(), s.arc(l, c, u / 2, 0, Math.PI * 2), s.fill();
    }
    return s.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new Sf(e.config);
    if (e.emitters)
      for (const i of e.emitters)
        n.addEmitter(i);
    if (e.gravityWells)
      for (const i of e.gravityWells)
        n.addGravityWell(i);
    if (e.vortices)
      for (const i of e.vortices)
        n.addVortex(i);
    if (e.modulations)
      for (const i of e.modulations)
        n.addModulation(i);
    return n;
  }
}
function M9() {
  return {
    preset: "static",
    zoom: 1,
    offsetX: 0,
    offsetY: 0,
    rotation: 0,
    depthScale: 1,
    focusDepth: 0.5,
    dollyZoom: 0,
    orbitRadius: 0.1,
    orbitSpeed: 2,
    swingAmplitude: 0.1,
    swingFrequency: 0.5,
    edgeDilation: 5,
    inpaintEdges: !0
  };
}
const C9 = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
  v_texCoord = a_texCoord;
}
`, T9 = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_source;
uniform sampler2D u_depth;
uniform float u_zoom;
uniform vec2 u_offset;
uniform float u_rotation;
uniform float u_depthScale;
uniform float u_focusDepth;
uniform float u_edgeDilation;
uniform vec2 u_resolution;

vec2 rotate2D(vec2 p, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  return vec2(p.x * c - p.y * s, p.x * s + p.y * c);
}

void main() {
  // Get depth at current pixel
  float depth = texture(u_depth, v_texCoord).r;

  // Calculate parallax offset based on depth
  // Objects closer than focus depth move more, objects further move less
  float depthDiff = (depth - u_focusDepth) * u_depthScale;

  // Transform texture coordinates
  vec2 center = vec2(0.5, 0.5);
  vec2 coord = v_texCoord - center;

  // Apply rotation
  float rotRad = u_rotation * 3.14159265 / 180.0;
  coord = rotate2D(coord, rotRad);

  // Apply zoom
  coord /= u_zoom;

  // Apply parallax offset based on depth
  vec2 parallaxOffset = u_offset * depthDiff;
  coord += parallaxOffset;

  // Apply camera offset
  coord -= u_offset * 0.5;

  coord += center;

  // Edge handling with dilation
  float dilatePixels = u_edgeDilation / u_resolution.x;

  // Clamp coordinates
  vec2 clampedCoord = clamp(coord, vec2(dilatePixels), vec2(1.0 - dilatePixels));

  // Check if we're sampling outside bounds
  float outOfBounds = step(0.0, coord.x) * step(coord.x, 1.0) *
                      step(0.0, coord.y) * step(coord.y, 1.0);

  // Sample source texture
  vec4 color = texture(u_source, clampedCoord);

  // Fade edges if out of bounds
  if (outOfBounds < 0.5) {
    // Sample from clamped position with reduced alpha
    color = texture(u_source, clampedCoord);
    color.a *= 0.3;
  }

  outColor = color;
}
`;
class E9 {
  constructor() {
    pe(this, "sourceCanvas");
    pe(this, "depthCanvas");
    pe(this, "outputCanvas");
    pe(this, "gl", null);
    pe(this, "program", null);
    pe(this, "useWebGL", !1);
    // WebGL resources
    pe(this, "sourceTexture", null);
    pe(this, "depthTexture", null);
    pe(this, "positionBuffer", null);
    pe(this, "texCoordBuffer", null);
    // Uniform locations
    pe(this, "uniforms", {});
    // Current config
    pe(this, "config", M9());
    // Source dimensions
    pe(this, "width", 0);
    pe(this, "height", 0);
    this.sourceCanvas = document.createElement("canvas"), this.depthCanvas = document.createElement("canvas"), this.outputCanvas = document.createElement("canvas"), this.initWebGL();
  }
  initWebGL() {
    const e = this.outputCanvas.getContext("webgl2", {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    });
    if (!e) {
      console.warn("[Depthflow] WebGL2 not available, using Canvas2D fallback"), this.useWebGL = !1;
      return;
    }
    this.gl = e, this.useWebGL = !0;
    const n = this.compileShader(e, e.VERTEX_SHADER, C9), i = this.compileShader(e, e.FRAGMENT_SHADER, T9);
    if (!n || !i) {
      this.useWebGL = !1;
      return;
    }
    const s = e.createProgram();
    if (e.attachShader(s, n), e.attachShader(s, i), e.linkProgram(s), !e.getProgramParameter(s, e.LINK_STATUS)) {
      console.error("[Depthflow] Program link error:", e.getProgramInfoLog(s)), this.useWebGL = !1;
      return;
    }
    this.program = s, this.uniforms = {
      u_source: e.getUniformLocation(s, "u_source"),
      u_depth: e.getUniformLocation(s, "u_depth"),
      u_zoom: e.getUniformLocation(s, "u_zoom"),
      u_offset: e.getUniformLocation(s, "u_offset"),
      u_rotation: e.getUniformLocation(s, "u_rotation"),
      u_depthScale: e.getUniformLocation(s, "u_depthScale"),
      u_focusDepth: e.getUniformLocation(s, "u_focusDepth"),
      u_edgeDilation: e.getUniformLocation(s, "u_edgeDilation"),
      u_resolution: e.getUniformLocation(s, "u_resolution")
    }, this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW), this.texCoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texCoordBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
  }
  compileShader(e, n, i) {
    const s = e.createShader(n);
    return e.shaderSource(s, i), e.compileShader(s), e.getShaderParameter(s, e.COMPILE_STATUS) ? s : (console.error("[Depthflow] Shader compile error:", e.getShaderInfoLog(s)), e.deleteShader(s), null);
  }
  setSource(e) {
    e instanceof ImageData ? (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").drawImage(e, 0, 0)), this.width = this.sourceCanvas.width, this.height = this.sourceCanvas.height, this.outputCanvas.width = this.width, this.outputCanvas.height = this.height, this.useWebGL && this.gl && this.updateTexture("source");
  }
  setDepthMap(e) {
    e instanceof ImageData ? (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").drawImage(e, 0, 0)), this.useWebGL && this.gl && this.updateTexture("depth");
  }
  updateTexture(e) {
    const n = this.gl, i = e === "source" ? this.sourceCanvas : this.depthCanvas;
    e === "source" ? (this.sourceTexture && n.deleteTexture(this.sourceTexture), this.sourceTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture)) : (this.depthTexture && n.deleteTexture(this.depthTexture), this.depthTexture = n.createTexture(), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture)), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, i);
  }
  setConfig(e) {
    this.config = { ...this.config, ...e };
  }
  getConfig() {
    return { ...this.config };
  }
  /**
   * Get animated camera parameters for a specific frame based on preset
   */
  getAnimatedParams(e, n) {
    const i = n > 1 ? e / (n - 1) : 0, { preset: s, orbitRadius: o, orbitSpeed: a, swingAmplitude: l, swingFrequency: c } = this.config;
    let u = this.config.zoom, h = this.config.offsetX, d = this.config.offsetY, p = this.config.rotation, f = this.config.depthScale;
    switch (s) {
      case "static":
        break;
      case "zoom_in":
        u = 1 + i * 0.3;
        break;
      case "zoom_out":
        u = 1 - i * 0.3;
        break;
      case "dolly_zoom_in":
        u = 1 + i * 0.4, f = this.config.depthScale * (1 - i * 0.5);
        break;
      case "dolly_zoom_out":
        u = 1 - i * 0.3, f = this.config.depthScale * (1 + i * 0.5);
        break;
      case "pan_left":
        h = -i * 0.3;
        break;
      case "pan_right":
        h = i * 0.3;
        break;
      case "pan_up":
        d = -i * 0.3;
        break;
      case "pan_down":
        d = i * 0.3;
        break;
      case "circle_cw": {
        const m = i * Math.PI * 2 * (a / 360);
        h = Math.cos(m) * o, d = Math.sin(m) * o;
        break;
      }
      case "circle_ccw": {
        const m = -i * Math.PI * 2 * (a / 360);
        h = Math.cos(m) * o, d = Math.sin(m) * o;
        break;
      }
      case "horizontal_swing":
        h = Math.sin(i * Math.PI * 2 * c) * l;
        break;
      case "vertical_swing":
        d = Math.sin(i * Math.PI * 2 * c) * l;
        break;
    }
    return { zoom: u, offsetX: h, offsetY: d, rotation: p, depthScale: f };
  }
  renderFrame(e, n) {
    const i = this.getAnimatedParams(e, n);
    return this.useWebGL && this.gl && this.program ? this.renderWebGL(i) : this.renderCanvas2D(i);
  }
  renderWebGL(e) {
    const n = this.gl;
    n.viewport(0, 0, this.width, this.height), n.useProgram(this.program), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture), n.uniform1i(this.uniforms.u_source, 0), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture), n.uniform1i(this.uniforms.u_depth, 1), n.uniform1f(this.uniforms.u_zoom, e.zoom), n.uniform2f(this.uniforms.u_offset, e.offsetX, e.offsetY), n.uniform1f(this.uniforms.u_rotation, e.rotation), n.uniform1f(this.uniforms.u_depthScale, e.depthScale), n.uniform1f(this.uniforms.u_focusDepth, this.config.focusDepth), n.uniform1f(this.uniforms.u_edgeDilation, this.config.edgeDilation), n.uniform2f(this.uniforms.u_resolution, this.width, this.height);
    const i = n.getAttribLocation(this.program, "a_position");
    n.bindBuffer(n.ARRAY_BUFFER, this.positionBuffer), n.enableVertexAttribArray(i), n.vertexAttribPointer(i, 2, n.FLOAT, !1, 0, 0);
    const s = n.getAttribLocation(this.program, "a_texCoord");
    n.bindBuffer(n.ARRAY_BUFFER, this.texCoordBuffer), n.enableVertexAttribArray(s), n.vertexAttribPointer(s, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.TRIANGLES, 0, 6);
    const o = new Uint8ClampedArray(this.width * this.height * 4);
    n.readPixels(0, 0, this.width, this.height, n.RGBA, n.UNSIGNED_BYTE, o);
    const a = new Uint8ClampedArray(o.length);
    for (let l = 0; l < this.height; l++) {
      const c = (this.height - 1 - l) * this.width * 4, u = l * this.width * 4;
      a.set(o.subarray(c, c + this.width * 4), u);
    }
    return new ImageData(a, this.width, this.height);
  }
  renderCanvas2D(e) {
    const n = this.outputCanvas.getContext("2d"), i = this.sourceCanvas.getContext("2d"), s = this.depthCanvas.getContext("2d"), o = i.getImageData(0, 0, this.width, this.height), a = s.getImageData(0, 0, this.width, this.height), l = n.createImageData(this.width, this.height), { zoom: c, offsetX: u, offsetY: h, rotation: d, depthScale: p } = e, { focusDepth: f } = this.config, m = d * Math.PI / 180, _ = Math.cos(m), g = Math.sin(m);
    for (let v = 0; v < this.height; v++)
      for (let S = 0; S < this.width; S++) {
        const b = (v * this.width + S) * 4, M = (a.data[b] / 255 - f) * p;
        let C = S / this.width - 0.5, E = v / this.height - 0.5;
        const T = C * _ - E * g, w = C * g + E * _;
        C = T, E = w, C /= c, E /= c, C += u * M, E += h * M, C -= u * 0.5, E -= h * 0.5, C = (C + 0.5) * this.width, E = (E + 0.5) * this.height;
        const A = Math.floor(C), O = Math.floor(E), U = A + 1, D = O + 1, L = C - A, P = E - O, V = Math.max(0, Math.min(this.width - 1, A)), ce = Math.max(0, Math.min(this.height - 1, O)), q = Math.max(0, Math.min(this.width - 1, U)), oe = Math.max(0, Math.min(this.height - 1, D)), ne = (ce * this.width + V) * 4, $ = (ce * this.width + q) * 4, J = (oe * this.width + V) * 4, se = (oe * this.width + q) * 4;
        for (let le = 0; le < 4; le++) {
          const re = o.data[ne + le], ye = o.data[$ + le], H = o.data[J + le], K = o.data[se + le], G = re * (1 - L) + ye * L, R = H * (1 - L) + K * L;
          l.data[b + le] = Math.round(G * (1 - P) + R * P);
        }
        (C < 0 || C >= this.width || E < 0 || E >= this.height) && (l.data[b + 3] = Math.round(l.data[b + 3] * 0.3));
      }
    return n.putImageData(l, 0, 0), l;
  }
  renderSequence(e, n) {
    const i = [];
    for (let s = 0; s < e; s++)
      i.push(this.renderFrame(s, e)), n && n(s);
    return i;
  }
  /**
   * Get preset configuration with optional intensity modifier
   */
  getPresetConfig(e, n = 1) {
    const i = { preset: e };
    switch (e) {
      case "zoom_in":
      case "zoom_out":
        return { ...i, depthScale: 1 * n };
      case "dolly_zoom_in":
      case "dolly_zoom_out":
        return { ...i, depthScale: 1.5 * n, dollyZoom: 0.5 * n };
      case "pan_left":
      case "pan_right":
      case "pan_up":
      case "pan_down":
        return { ...i, depthScale: 0.8 * n };
      case "circle_cw":
      case "circle_ccw":
        return { ...i, orbitRadius: 0.1 * n, orbitSpeed: 360 };
      case "horizontal_swing":
      case "vertical_swing":
        return { ...i, swingAmplitude: 0.1 * n, swingFrequency: 1 };
      default:
        return i;
    }
  }
  getOutputCanvas() {
    return this.outputCanvas;
  }
  dispose() {
    this.gl && (this.sourceTexture && this.gl.deleteTexture(this.sourceTexture), this.depthTexture && this.gl.deleteTexture(this.depthTexture), this.positionBuffer && this.gl.deleteBuffer(this.positionBuffer), this.texCoordBuffer && this.gl.deleteBuffer(this.texCoordBuffer), this.program && this.gl.deleteProgram(this.program)), this.sourceTexture = null, this.depthTexture = null, this.positionBuffer = null, this.texCoordBuffer = null, this.program = null, this.gl = null;
  }
}
const A9 = {
  key: 1,
  class: "overlay-controls"
}, P9 = {
  key: 2,
  class: "loading-overlay"
}, D9 = /* @__PURE__ */ jt({
  __name: "CompositionCanvas",
  setup(r, { expose: e }) {
    const n = _n(), i = Ce(null), s = Ce(null), o = Ce(null), a = Ce(null), l = Ce(null), c = Ce(null), u = Ce(/* @__PURE__ */ new Map()), h = Ce(/* @__PURE__ */ new Map()), d = Ce(/* @__PURE__ */ new Map()), p = Ce(/* @__PURE__ */ new Map()), f = Ce(null), m = Ce(!1), _ = Ce(1), g = Ce(!0), v = Ce("viridis"), S = Ce(50), b = Ce(800), x = Ce(600), M = Ce(/* @__PURE__ */ new Map()), C = Ce(/* @__PURE__ */ new Map()), E = Ce(null), T = Ce(null), w = Ce(null), A = Ce(/* @__PURE__ */ new Map()), O = Ce(/* @__PURE__ */ new Map()), U = Ce(!1), D = Ce(!1), L = Xe(() => n.depthMap !== null), P = Xe(() => n.currentTool === "pen"), V = Xe(() => {
      const ae = n.selectedLayer;
      if ((ae == null ? void 0 : ae.type) === "spline")
        return ae.id;
      if (P.value && n.layers.filter((de) => de.type === "spline").length === 0)
        return null;
      if (P.value) {
        const de = n.layers.filter((Ee) => Ee.type === "spline");
        return de.length > 0 ? de[de.length - 1].id : null;
      }
      return null;
    }), ce = Xe(() => {
      var de;
      const ae = (de = a.value) == null ? void 0 : de.viewportTransform;
      return ae ? Array.from(ae) : [1, 0, 0, 1, 0, 0];
    });
    Xn(() => {
      if (!s.value || !i.value) return;
      const ae = i.value, de = ae.getBoundingClientRect();
      b.value = de.width, x.value = de.height, a.value = new pg(s.value, {
        width: de.width,
        height: de.height,
        backgroundColor: "#1a1a1a",
        selection: !0,
        preserveObjectStacking: !0
      }), q(), Gs(() => {
        oe();
      }), new ResizeObserver(J).observe(ae), At(() => n.sourceImage, se, { immediate: !0 }), At(() => n.depthMap, le, { immediate: !0 }), At(() => n.layers, () => {
        ye(), H(), K(), G(), k(), ee();
      }, { deep: !0, immediate: !0 }), At(() => n.currentFrame, () => {
        ye(), H(), K(), G();
      }), At(() => [n.width, n.height], ne, { immediate: !1 }), E.value = document.createElement("canvas"), T.value = E.value.getContext("2d"), Z();
    }), Ni(() => {
      var ae;
      w.value !== null && cancelAnimationFrame(w.value), M.value.forEach((de) => de.reset()), M.value.clear(), C.value.forEach((de) => de.dispose()), C.value.clear(), h.value.clear(), u.value.clear(), d.value.clear(), p.value.clear(), (ae = a.value) == null || ae.dispose();
    });
    function q() {
      const ae = a.value;
      if (!ae) return;
      let de = !1, Ee = !1, be = 0, ke = 0, ze = 0, Te = 1;
      const Pe = i.value;
      Pe && (Pe.addEventListener("mousedown", (Ge) => {
        Ge.button === 1 && Ge.preventDefault();
      }), Pe.addEventListener("auxclick", (Ge) => {
        Ge.button === 1 && Ge.preventDefault();
      })), ae.on("mouse:wheel", (Ge) => {
        const Ve = Ge.e.deltaY;
        let Qe = ae.getZoom() * (Ve > 0 ? 0.9 : 1.1);
        Qe = Math.min(Math.max(Qe, 0.1), 10);
        const _e = new He(Ge.e.offsetX, Ge.e.offsetY);
        ae.zoomToPoint(_e, Qe), _.value = Qe, Ge.e.preventDefault(), Ge.e.stopPropagation();
      }), ae.on("mouse:down", (Ge) => {
        const Ve = Ge.e, Qe = n.currentTool;
        if (Ve.button === 1 || Qe === "hand" || Ve.button === 0 && Ve.altKey) {
          de = !0, be = Ve.clientX, ke = Ve.clientY, ae.selection = !1, ae.defaultCursor = "grabbing", ae.discardActiveObject(), Ve.preventDefault(), Ve.stopPropagation();
          return;
        }
        if (Qe === "zoom") {
          if (Ve.shiftKey) {
            const _e = Math.max(ae.getZoom() * 0.7, 0.1), Ue = new He(Ve.offsetX, Ve.offsetY);
            ae.zoomToPoint(Ue, _e), _.value = _e;
          } else
            Ee = !0, ze = Ve.clientY, Te = ae.getZoom();
          return;
        }
        if (Qe === "text") {
          const _e = ae.getScenePoint(Ve), Ue = n.createLayer("text");
          Ue.transform && Ue.transform.position && (Ue.transform.position.value = { x: _e.x, y: _e.y }), n.updateLayer(Ue.id, {
            transform: {
              ...Ue.transform,
              position: {
                ...Ue.transform.position,
                value: { x: _e.x, y: _e.y }
              }
            }
          }), n.selectLayer(Ue.id), n.setTool("select"), G();
          return;
        }
      }), ae.on("mouse:move", (Ge) => {
        const Ve = Ge.e;
        if (de) {
          const _e = ae.viewportTransform;
          _e && (_e[4] += Ve.clientX - be, _e[5] += Ve.clientY - ke, ae.requestRenderAll()), be = Ve.clientX, ke = Ve.clientY, Ve.preventDefault();
          return;
        }
        if (Ee) {
          const Ue = 1 + (ze - Ve.clientY) * 0.01, Fe = Math.max(0.1, Math.min(10, Te * Ue));
          ae.setZoom(Fe), _.value = Fe, ae.requestRenderAll();
          return;
        }
        const Qe = n.currentTool;
        Qe === "hand" ? ae.defaultCursor = "grab" : Qe === "zoom" ? ae.defaultCursor = "zoom-in" : Qe === "text" ? ae.defaultCursor = "text" : Qe === "pen" ? ae.defaultCursor = "crosshair" : ae.defaultCursor = "default";
      }), ae.on("mouse:up", (Ge) => {
        const Ve = Ge.e;
        de && (de = !1, ae.selection = !0, ae.defaultCursor = n.currentTool === "hand" ? "grab" : "default", Ve.preventDefault()), Ee && (Ee = !1);
      }), ae.on("selection:created", (Ge) => {
        var Qe;
        const Ve = (Qe = Ge.selected) == null ? void 0 : Qe[0];
        Ve && Ve.layerId && n.selectLayer(Ve.layerId);
      }), ae.on("selection:updated", (Ge) => {
        var Qe;
        const Ve = (Qe = Ge.selected) == null ? void 0 : Qe[0];
        Ve && Ve.layerId && n.selectLayer(Ve.layerId);
      }), ae.on("selection:cleared", () => {
        n.clearSelection();
      });
    }
    function oe() {
      const ae = a.value;
      if (!ae) return;
      const de = n.width || 1920, Ee = n.height || 1080;
      f.value && ae.remove(f.value), f.value = new Nn({
        left: 0,
        top: 0,
        width: de,
        height: Ee,
        fill: "transparent",
        stroke: "#4a90d9",
        strokeWidth: 2,
        selectable: !1,
        evented: !1,
        strokeUniform: !0
      }), ae.add(f.value), ae.sendObjectToBack(f.value), $(), ae.requestRenderAll();
    }
    function ne() {
      const ae = a.value;
      if (!ae || !f.value) return;
      const de = n.width || 1920, Ee = n.height || 1080;
      f.value.set({ width: de, height: Ee }), f.value.setCoords(), $(), ae.requestRenderAll();
    }
    function $() {
      const ae = a.value, de = i.value;
      if (!ae || !de) return;
      const Ee = n.width || 1920, be = n.height || 1080, ke = de.getBoundingClientRect(), ze = 60, Te = (ke.width - ze * 2) / Ee, Pe = (ke.height - ze * 2) / be, Ge = Math.min(Te, Pe, 1), Ve = ae.viewportTransform;
      Ve && (Ve[0] = Ge, Ve[3] = Ge, Ve[4] = (ke.width - Ee * Ge) / 2, Ve[5] = (ke.height - be * Ge) / 2), _.value = Ge;
    }
    function J(ae) {
      const de = a.value;
      if (!(!de || !de.lowerCanvasEl)) {
        for (const Ee of ae) {
          const { width: be, height: ke } = Ee.contentRect;
          be > 0 && ke > 0 && (de.setDimensions({ width: be, height: ke }), b.value = be, x.value = ke);
        }
        de.requestRenderAll();
      }
    }
    async function se(ae) {
      const de = a.value;
      if (!(!de || !ae)) {
        m.value = !0;
        try {
          l.value && de.remove(l.value);
          const Ee = await Q(ae);
          l.value = new Ri(Ee, { selectable: !1, evented: !1, left: 0, top: 0 }), de.add(l.value), de.sendObjectToBack(l.value), X();
        } catch (Ee) {
          console.error("[CompositionCanvas] Failed to load source image:", Ee);
        } finally {
          m.value = !1;
        }
      }
    }
    async function le(ae) {
      const de = a.value;
      if (!(!de || !ae))
        try {
          if (c.value && de.remove(c.value), c.value = await zd.fromBase64(ae, {
            colormap: v.value,
            opacity: S.value / 100,
            visible: g.value
          }), c.value.set({ selectable: !1, evented: !1, left: 0, top: 0 }), de.add(c.value), l.value) {
            const Ee = de.getObjects().indexOf(l.value);
            de.moveObjectTo(c.value, Ee + 1);
          }
          de.requestRenderAll();
        } catch (Ee) {
          console.error("[CompositionCanvas] Failed to load depth map:", Ee);
        }
    }
    function re(ae, de) {
      return ae ? fn(ae, n.currentFrame) : de;
    }
    function ye() {
      var be, ke, ze;
      const ae = a.value;
      if (!ae) return;
      const de = n.layers.filter((Te) => Te.type === "spline");
      for (const Te of de) {
        const Pe = Te.data;
        if (!Pe) continue;
        let Ge = u.value.get(Te.id);
        const Ve = re((be = Te.transform) == null ? void 0 : be.position, { x: 0, y: 0, z: 0 }), Qe = re((ke = Te.transform) == null ? void 0 : ke.scale, { x: 100, y: 100 }), _e = re((ze = Te.transform) == null ? void 0 : ze.rotation, 0), Ue = re(Te.opacity, 100) / 100;
        Ge ? (Ge.controlPoints = Pe.controlPoints || [], Ge.set({
          stroke: Pe.stroke,
          strokeWidth: Pe.strokeWidth,
          fill: Pe.fill
        })) : (Ge = new Bd("", {
          stroke: Pe.stroke || "#00ff00",
          strokeWidth: Pe.strokeWidth || 2,
          fill: Pe.fill || "",
          controlPoints: Pe.controlPoints || [],
          selectable: !Te.locked
        }), Ge.layerId = Te.id, u.value.set(Te.id, Ge), ae.add(Ge)), Ge.set({
          left: Ve.x,
          top: Ve.y,
          scaleX: Qe.x / 100,
          // Convert from percentage (100 = 100%) to multiplier (1.0)
          scaleY: Qe.y / 100,
          angle: _e,
          opacity: Ue,
          visible: Te.visible,
          selectable: !Te.locked
        }), Ge.updatePathFromControlPoints(), Ge.setCoords();
      }
      const Ee = new Set(de.map((Te) => Te.id));
      for (const [Te, Pe] of u.value)
        Ee.has(Te) || (ae.remove(Pe), u.value.delete(Te));
      ae.requestRenderAll();
    }
    function H() {
      var be, ke, ze;
      const ae = a.value;
      if (!ae) return;
      const de = n.layers.filter((Te) => Te.type === "solid");
      d.value || (d.value = /* @__PURE__ */ new Map());
      for (const Te of de) {
        let Pe = d.value.get(Te.id);
        const Ge = re((be = Te.transform) == null ? void 0 : be.position, { x: 0, y: 0, z: 0 }), Ve = re((ke = Te.transform) == null ? void 0 : ke.scale, { x: 100, y: 100 }), Qe = re((ze = Te.transform) == null ? void 0 : ze.rotation, 0), _e = re(Te.opacity, 100) / 100, Ue = Te.data, Fe = (Ue == null ? void 0 : Ue.color) || "#808080", je = n.width || 1920, Ke = n.height || 1080;
        Pe ? Pe.set({ fill: Fe, width: je, height: Ke }) : (Pe = new Nn({
          left: Ge.x,
          top: Ge.y,
          width: je,
          height: Ke,
          fill: Fe,
          selectable: !Te.locked,
          evented: !Te.locked
        }), Pe.layerId = Te.id, d.value.set(Te.id, Pe), ae.add(Pe)), Pe.set({
          left: Ge.x,
          top: Ge.y,
          scaleX: Ve.x / 100,
          // Convert from percentage (100 = 100%) to multiplier (1.0)
          scaleY: Ve.y / 100,
          angle: Qe,
          opacity: _e,
          visible: Te.visible,
          selectable: !Te.locked
        }), Pe.setCoords();
      }
      const Ee = new Set(de.map((Te) => Te.id));
      for (const [Te, Pe] of d.value)
        Ee.has(Te) || (ae.remove(Pe), d.value.delete(Te));
      ae.requestRenderAll();
    }
    function K() {
      var be, ke, ze;
      const ae = a.value;
      if (!ae) return;
      const de = n.layers.filter((Te) => Te.type === "null");
      p.value || (p.value = /* @__PURE__ */ new Map());
      for (const Te of de) {
        let Pe = p.value.get(Te.id);
        const Ge = re((be = Te.transform) == null ? void 0 : be.position, { x: 0, y: 0, z: 0 }), Ve = re((ke = Te.transform) == null ? void 0 : ke.scale, { x: 100, y: 100 }), Qe = re((ze = Te.transform) == null ? void 0 : ze.rotation, 0), _e = re(Te.opacity, 100) / 100, Ue = (n.width || 1920) / 2, Fe = (n.height || 1080) / 2, je = Ge.x !== void 0 && Ge.x !== null ? Ge.x : Ue, Ke = Ge.y !== void 0 && Ge.y !== null ? Ge.y : Fe, qe = 40;
        if (!Pe) {
          const dt = new Nn({
            left: je - qe / 2,
            top: Ke - 1,
            width: qe,
            height: 2,
            fill: "#ff9900",
            selectable: !1,
            evented: !1
          }), mt = new Nn({
            left: je - 1,
            top: Ke - qe / 2,
            width: 2,
            height: qe,
            fill: "#ff9900",
            selectable: !1,
            evented: !1
          });
          dt.layerId = Te.id, mt.layerId = Te.id, p.value.set(Te.id, { h: dt, v: mt }), ae.add(dt), ae.add(mt), Pe = { h: dt, v: mt };
        }
        const ut = Ve.x / 100, ot = Ve.y / 100;
        Pe.h.set({
          left: je - qe * ut / 2,
          top: Ke - 1,
          width: qe * ut,
          scaleX: 1,
          scaleY: ot,
          angle: Qe,
          opacity: _e,
          visible: Te.visible
        }), Pe.v.set({
          left: je - 1,
          top: Ke - qe * ot / 2,
          width: 2,
          height: qe * ot,
          scaleX: ut,
          scaleY: 1,
          angle: Qe,
          opacity: _e,
          visible: Te.visible
        }), Pe.h.setCoords(), Pe.v.setCoords();
      }
      const Ee = new Set(de.map((Te) => Te.id));
      for (const [Te, Pe] of p.value)
        Ee.has(Te) || (ae.remove(Pe.h), ae.remove(Pe.v), p.value.delete(Te));
      ae.requestRenderAll();
    }
    function G() {
      var be, ke, ze, Te, Pe, Ge, Ve;
      const ae = a.value;
      if (!ae) return;
      const de = n.layers.filter((Qe) => Qe.type === "text");
      for (const Qe of de) {
        const _e = Qe.data;
        if (!_e) continue;
        let Ue = h.value.get(Qe.id);
        const Fe = re((be = Qe.transform) == null ? void 0 : be.position, { x: 0, y: 0, z: 0 }), je = re((ke = Qe.transform) == null ? void 0 : ke.anchorPoint, { x: 0, y: 0, z: 0 }), Ke = re((ze = Qe.transform) == null ? void 0 : ze.scale, { x: 100, y: 100, z: 100 }), qe = re(Qe.opacity, 100) / 100;
        let ut = 0, ot = 0, dt = 0;
        Qe.threeD ? (ot = re((Te = Qe.transform) == null ? void 0 : Te.rotationX, 0), dt = re((Pe = Qe.transform) == null ? void 0 : Pe.rotationY, 0), ut = re((Ge = Qe.transform) == null ? void 0 : Ge.rotationZ, 0)) : ut = re((Ve = Qe.transform) == null ? void 0 : Ve.rotation, 0);
        const mt = (n.width || 1920) / 2, Bt = (n.height || 1080) / 2, $t = Fe.x !== void 0 && Fe.x !== null ? Fe.x : mt, on = Fe.y !== void 0 && Fe.y !== null ? Fe.y : Bt;
        Ue ? (_e.text !== Ue.textContent && Ue.setText(_e.text || "Text"), (_e.fontFamily !== Ue.fontFamily || _e.fontSize !== Ue.fontSize || _e.fontWeight !== Ue.fontWeight || _e.fontStyle !== Ue.fontStyle) && Ue.setFont(
          _e.fontFamily || "Arial",
          _e.fontSize || 72,
          _e.fontWeight || "400",
          _e.fontStyle || "normal"
        ), _e.fill !== Ue.textFill && Ue.setFillColor(_e.fill || "#ffffff"), (_e.stroke !== Ue.textStroke || _e.strokeWidth !== Ue.textStrokeWidth) && Ue.setStroke(_e.stroke || "", _e.strokeWidth || 0), _e.letterSpacing !== Ue.letterSpacing && Ue.setLetterSpacing(_e.letterSpacing || 0), _e.textAlign !== Ue.textAlign && Ue.setTextAlign(_e.textAlign || "left"), Ue.pathLayerId = _e.pathLayerId || null, Ue.pathOffset = _e.pathOffset || 0) : (Ue = new Nd({
          text: _e.text || "Text",
          fontFamily: _e.fontFamily || "Arial",
          fontSize: _e.fontSize || 72,
          fontWeight: _e.fontWeight || "400",
          fontStyle: _e.fontStyle || "normal",
          fill: _e.fill || "#ffffff",
          stroke: _e.stroke || "",
          strokeWidth: _e.strokeWidth || 0,
          letterSpacing: _e.letterSpacing || 0,
          textAlign: _e.textAlign || "left",
          pathLayerId: _e.pathLayerId,
          pathOffset: _e.pathOffset || 0,
          selectable: !Qe.locked
        }), Ue.layerId = Qe.id, h.value.set(Qe.id, Ue), ae.add(Ue), Ue.setText(Ue.textContent), ae.bringObjectToFront(Ue));
        let Rn = Ke.x / 100, dn = Ke.y / 100;
        if (Qe.threeD) {
          const Ln = 1e3 / (1e3 - (Fe.z || 0));
          if (Rn *= Ln, dn *= Ln, ot !== 0) {
            const wn = ot * Math.PI / 180;
            dn *= Math.cos(wn);
          }
          if (dt !== 0) {
            const wn = dt * Math.PI / 180;
            Rn *= Math.cos(wn);
          }
        }
        if (Ue.set({
          left: $t,
          top: on,
          originX: "center",
          originY: "center",
          scaleX: Rn,
          scaleY: dn,
          angle: ut,
          opacity: qe,
          visible: Qe.visible,
          selectable: !Qe.locked
        }), je.x !== 0 || je.y !== 0) {
          const Un = je.x * Rn, qn = je.y * dn, Ln = ut * Math.PI / 180, wn = Un * Math.cos(Ln) - qn * Math.sin(Ln), Sn = Un * Math.sin(Ln) + qn * Math.cos(Ln);
          Ue.set({
            left: $t - wn,
            top: on - Sn
          });
        }
        Ue.setCoords();
      }
      const Ee = new Set(de.map((Qe) => Qe.id));
      for (const [Qe, _e] of h.value)
        Ee.has(Qe) || (ae.remove(_e), h.value.delete(Qe));
      ae.requestRenderAll(), R();
    }
    function R() {
      const ae = a.value;
      if (!ae) return;
      const de = [], Ee = (be) => {
        var ze, Te;
        if (!be.threeD) return 0;
        const ke = (Te = (ze = be.transform) == null ? void 0 : ze.position) == null ? void 0 : Te.value;
        return (ke == null ? void 0 : ke.z) ?? 0;
      };
      for (const be of n.layers) {
        const ke = Ee(be), ze = h.value.get(be.id);
        ze && de.push({ layerId: be.id, zPos: ke, obj: ze });
        const Te = u.value.get(be.id);
        Te && de.push({ layerId: be.id, zPos: ke, obj: Te });
        const Pe = d.value.get(be.id);
        Pe && de.push({ layerId: be.id, zPos: ke, obj: Pe });
        const Ge = p.value.get(be.id);
        Ge && (de.push({ layerId: be.id, zPos: ke, obj: Ge.h }), de.push({ layerId: be.id, zPos: ke, obj: Ge.v }));
      }
      de.sort((be, ke) => be.zPos - ke.zPos), de.forEach((be, ke) => {
        const ze = f.value ? 1 : 0;
        ae.moveTo(be.obj, ze + ke);
      });
    }
    function z(ae) {
      if (!V.value) {
        const de = n.createLayer("spline");
        n.selectLayer(de.id);
      }
    }
    function I() {
      ye();
    }
    At(g, (ae) => {
      var de;
      c.value && (c.value.set("visible", ae), (de = a.value) == null || de.requestRenderAll());
    }), At(v, (ae) => {
      c.value && c.value.setColormap(ae);
    }), At(S, (ae) => {
      var de;
      c.value && (c.value.set("opacity", ae / 100), (de = a.value) == null || de.requestRenderAll());
    });
    function Q(ae) {
      return new Promise((de, Ee) => {
        const be = new Image();
        be.crossOrigin = "anonymous", be.onload = () => de(be), be.onerror = Ee, be.src = ae.startsWith("data:") ? ae : `data:image/png;base64,${ae}`;
      });
    }
    function X() {
      const ae = a.value, de = i.value;
      if (!ae || !de || !l.value) return;
      const Ee = de.getBoundingClientRect(), be = l.value.width || 1, ke = l.value.height || 1, ze = 40, Te = (Ee.width - ze * 2) / be, Pe = (Ee.height - ze * 2) / ke, Ge = Math.min(Te, Pe, 1), Ve = ae.viewportTransform;
      Ve && (Ve[0] = Ge, Ve[3] = Ge, Ve[4] = (Ee.width - be * Ge) / 2, Ve[5] = (Ee.height - ke * Ge) / 2), _.value = Ge, ae.requestRenderAll();
    }
    function k() {
      var Ee;
      const ae = n.layers.filter((be) => be.type === "particles"), de = new Set(ae.map((be) => be.id));
      for (const be of ae)
        if (M.value.has(be.id)) {
          const ke = M.value.get(be.id), ze = be.data;
          if (ze) {
            ke.setConfig(ze.systemConfig);
            const Te = ke.getEmitters();
            for (const Pe of ze.emitters)
              Te.find((Ve) => Ve.id === Pe.id) ? ke.updateEmitter(Pe.id, Pe) : ke.addEmitter(Pe);
          }
        } else {
          const ke = be.data;
          if (ke) {
            const ze = new Sf(ke.systemConfig);
            ke.emitters.forEach((Te) => ze.addEmitter(Te)), ke.gravityWells.forEach((Te) => ze.addGravityWell(Te)), ke.vortices.forEach((Te) => ze.addVortex(Te)), ke.modulations.forEach((Te) => ze.addModulation(Te)), M.value.set(be.id, ze);
          }
        }
      for (const [be] of M.value)
        de.has(be) || ((Ee = M.value.get(be)) == null || Ee.reset(), M.value.delete(be));
    }
    function ee() {
      var Ee;
      const ae = n.layers.filter((be) => be.type === "depthflow"), de = new Set(ae.map((be) => be.id));
      for (const be of ae)
        if (C.value.has(be.id)) {
          const ke = C.value.get(be.id), ze = be.data;
          ze && ke.setConfig(ze.config);
        } else {
          const ke = be.data;
          if (ke) {
            const ze = new E9();
            ze.setConfig(ke.config), C.value.set(be.id, ze);
          }
        }
      for (const [be] of C.value)
        de.has(be) || ((Ee = C.value.get(be)) == null || Ee.dispose(), C.value.delete(be));
    }
    function Z() {
      const ae = () => {
        (n.isPlaying || n.audioAnalysis) && F(), n.isPlaying && N(), fe(), j(), B(), w.value = requestAnimationFrame(ae);
      };
      w.value = requestAnimationFrame(ae);
    }
    function N() {
      var de;
      const ae = ((de = n.audioAnalysis) == null ? void 0 : de.onsets.includes(n.currentFrame)) ?? !1;
      M.value.forEach((Ee, be) => {
        const ke = n.getActiveMappingsForLayer(be);
        for (const ze of ke) {
          const Pe = n.getAudioFeatureAtFrame(ze.feature) * ze.sensitivity, Ge = ze.target.split("."), Ve = Ge.length > 1 ? Ge[1] : ze.target;
          Ee.setFeatureValue(Ve, Pe, ze.targetEmitterId);
        }
        ae && Ee.triggerAllBursts(), Ee.step(1);
      });
    }
    function j() {
      const ae = a.value;
      if (!ae || !E.value || !T.value) return;
      const de = n.layers.filter((ke) => ke.type === "particles" && ke.visible);
      if (de.length === 0) return;
      (E.value.width !== ae.width || E.value.height !== ae.height) && (E.value.width = ae.width || 800, E.value.height = ae.height || 600);
      const Ee = T.value;
      Ee.clearRect(0, 0, E.value.width, E.value.height);
      for (const ke of de) {
        const ze = M.value.get(ke.id), Te = ke.data;
        if (ze && Te) {
          Ee.save();
          const Pe = ae.viewportTransform;
          Pe && Ee.transform(Pe[0], Pe[1], Pe[2], Pe[3], Pe[4], Pe[5]), ze.renderToCanvas(Ee, n.width, n.height, Te.renderOptions), Ee.restore();
        }
      }
      const be = ae.getContext();
      be && de.length > 0 && be.drawImage(E.value, 0, 0);
    }
    function te(ae) {
      const de = M.value.get(ae);
      return (de == null ? void 0 : de.getParticleCount()) ?? 0;
    }
    function F() {
      n.updatePathAnimators();
      for (const ae of n.layers) {
        const de = n.getPathAnimator(ae.id);
        de && A.value.set(ae.id, de.getState());
      }
    }
    function B() {
      const ae = a.value;
      if (!ae || !E.value || !T.value) return;
      const de = n.layers.filter((be) => be.type === "text" && be.visible);
      if (de.length === 0) return;
      const Ee = T.value;
      for (const be of de) {
        const ke = be.data;
        if (!(ke != null && ke.pathLayerId)) continue;
        const ze = n.getPathAnimator(be.id);
        if (!ze) continue;
        const Te = A.value.get(be.id);
        if (!Te) continue;
        const Pe = n.layers.find((Ue) => Ue.id === ke.pathLayerId);
        if (!Pe) continue;
        const Ge = Pe.data;
        if (!(Ge != null && Ge.pathData)) continue;
        Ee.save();
        const Ve = ae.viewportTransform;
        Ve && Ee.transform(Ve[0], Ve[1], Ve[2], Ve[3], Ve[4], Ve[5]);
        const Qe = ze.getConfig(), _e = Math.abs(Te.position - Te.previousPosition);
        if (Qe.motionBlur && _e > 1e-3) {
          const Ue = ze.getMotionBlurTrail(8);
          Ee.lineCap = "round", Ee.lineJoin = "round";
          for (let Fe = 0; Fe < Ue.length - 1; Fe++) {
            const je = Ue[Fe], Ke = Ue[Fe + 1], qe = je.opacity * Qe.motionBlurStrength * 0.5;
            Ee.strokeStyle = `rgba(255, 255, 255, ${qe})`, Ee.lineWidth = Math.max(2, (ke.fontSize || 48) * 0.1 * (1 - Fe / Ue.length)), Ee.beginPath(), Ee.moveTo(je.x, je.y), Ee.lineTo(Ke.x, Ke.y), Ee.stroke();
          }
        }
        Ee.restore();
      }
    }
    function Y(ae) {
      const de = n.getPathAnimator(ae);
      if (!de) return null;
      const Ee = A.value.get(ae);
      if (!Ee) return null;
      const be = de.getPositionOnPath(Ee.position);
      return { x: be.x, y: be.y, angle: be.angle };
    }
    function fe() {
      if (!a.value) return;
      const de = n.currentFrame;
      for (const Ee of n.layers) {
        if (!Ee.visible || !Ee.effects || !Xb(Ee.effects)) continue;
        let be = null;
        if (Ee.type === "spline" ? be = u.value.get(Ee.id) : Ee.type === "text" && (be = h.value.get(Ee.id)), !be) continue;
        const ke = ge(be);
        if (!ke) continue;
        const ze = $b(Ee.effects, ke, de);
        O.value.set(Ee.id, ze.canvas), xe(be, ze.canvas);
      }
    }
    function ge(ae) {
      const de = ae.getBoundingRect();
      if (de.width <= 0 || de.height <= 0) return null;
      const Ee = document.createElement("canvas");
      Ee.width = Math.ceil(de.width), Ee.height = Math.ceil(de.height);
      const be = Ee.getContext("2d");
      if (!be) return null;
      const ke = ae.left || 0, ze = ae.top || 0;
      return ae.set({ left: -de.left, top: -de.top }), ae.render(be), ae.set({ left: ke, top: ze }), Ee;
    }
    function xe(ae, de) {
      var Ee;
      ae._effectCanvas = de, (Ee = a.value) == null || Ee.requestRenderAll();
    }
    function De() {
      const ae = a.value;
      if (!ae) return;
      const de = n.width || 1920, Ee = n.height || 1080;
      if (ae.getObjects().filter((ke) => ke.isGridOrGuide).forEach((ke) => ae.remove(ke)), U.value) {
        for (let ze = 0; ze <= de; ze += 100) {
          const Te = new Nn({ left: ze, top: 0, width: 1, height: Ee, fill: "rgba(80, 80, 80, 0.4)", selectable: !1, evented: !1 });
          Te.isGridOrGuide = !0, ae.add(Te), ae.sendObjectToBack(Te);
        }
        for (let ze = 0; ze <= Ee; ze += 100) {
          const Te = new Nn({ left: 0, top: ze, width: de, height: 1, fill: "rgba(80, 80, 80, 0.4)", selectable: !1, evented: !1 });
          Te.isGridOrGuide = !0, ae.add(Te), ae.sendObjectToBack(Te);
        }
      }
      if (D.value) {
        [de / 3, de * 2 / 3].forEach((Ve) => {
          const Qe = new Nn({ left: Ve, top: 0, width: 1, height: Ee, fill: "rgba(0, 180, 255, 0.4)", selectable: !1, evented: !1 });
          Qe.isGridOrGuide = !0, ae.add(Qe);
        }), [Ee / 3, Ee * 2 / 3].forEach((Ve) => {
          const Qe = new Nn({ left: 0, top: Ve, width: de, height: 1, fill: "rgba(0, 180, 255, 0.4)", selectable: !1, evented: !1 });
          Qe.isGridOrGuide = !0, ae.add(Qe);
        });
        const ke = de / 2, ze = Ee / 2, Te = 30, Pe = new Nn({ left: ke - Te, top: ze, width: Te * 2, height: 1, fill: "rgba(255, 100, 100, 0.6)", selectable: !1, evented: !1 }), Ge = new Nn({ left: ke, top: ze - Te, width: 1, height: Te * 2, fill: "rgba(255, 100, 100, 0.6)", selectable: !1, evented: !1 });
        Pe.isGridOrGuide = !0, Ge.isGridOrGuide = !0, ae.add(Pe), ae.add(Ge);
      }
      f.value && ae.bringObjectForward(f.value), ae.requestRenderAll();
    }
    return At(U, De), At(D, De), e({
      fabricCanvas: a,
      fitToView: X,
      zoom: _,
      showGrid: U,
      showGuides: D,
      renderGridAndGuides: De,
      particleSystems: M,
      depthflowRenderers: C,
      textObjects: h,
      splineObjects: u,
      solidObjects: d,
      nullObjects: p,
      getParticleCount: te,
      getTextPathPosition: Y,
      pathAnimationStates: A,
      effectCanvases: O
    }), (ae, de) => (ie(), ue("div", {
      class: "composition-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      y("canvas", {
        ref_key: "canvasRef",
        ref: s
      }, null, 512),
      V.value || P.value ? (ie(), Et(sS, {
        key: 0,
        layerId: V.value,
        canvasWidth: b.value,
        canvasHeight: x.value,
        zoom: _.value,
        viewportTransform: ce.value,
        isPenMode: P.value,
        onPointAdded: z,
        onPathUpdated: I,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Ne("", !0),
      L.value ? (ie(), ue("div", A9, [
        y("label", null, [
          wt(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": de[0] || (de[0] = (Ee) => g.value = Ee)
          }, null, 512), [
            [Us, g.value]
          ]),
          de[3] || (de[3] = xt(" Depth Overlay ", -1))
        ]),
        wt(y("select", {
          "onUpdate:modelValue": de[1] || (de[1] = (Ee) => v.value = Ee),
          class: "colormap-select"
        }, [...de[4] || (de[4] = [
          y("option", { value: "viridis" }, "Viridis", -1),
          y("option", { value: "plasma" }, "Plasma", -1),
          y("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [ns, v.value]
        ]),
        wt(y("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": de[2] || (de[2] = (Ee) => S.value = Ee),
          class: "opacity-slider"
        }, null, 512), [
          [
            Tn,
            S.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Ne("", !0),
      m.value ? (ie(), ue("div", P9, [...de[5] || (de[5] = [
        y("div", { class: "loading-spinner" }, null, -1),
        y("span", null, "Loading...", -1)
      ])])) : Ne("", !0)
    ], 512));
  }
}), k9 = /* @__PURE__ */ Yt(D9, [["__scopeId", "data-v-5563ee45"]]), Ao = new hv(), li = new he(), Xr = new he(), mn = new xi(), e_ = {
  X: new he(1, 0, 0),
  Y: new he(0, 1, 0),
  Z: new he(0, 0, 1)
}, jp = { type: "change" }, t_ = { type: "mouseDown", mode: null }, n_ = { type: "mouseUp", mode: null }, i_ = { type: "objectChange" };
class R9 extends ek {
  constructor(e, n = null) {
    super(void 0, n);
    const i = new z9(this);
    this._root = i;
    const s = new B9();
    this._gizmo = s, i.add(s);
    const o = new N9();
    this._plane = o, i.add(o);
    const a = this;
    function l(b, x) {
      let M = x;
      Object.defineProperty(a, b, {
        get: function() {
          return M !== void 0 ? M : x;
        },
        set: function(C) {
          M !== C && (M = C, o[b] = C, s[b] = C, a.dispatchEvent({ type: b + "-changed", value: C }), a.dispatchEvent(jp));
        }
      }), a[b] = x, o[b] = x, s[b] = x;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0), l("minX", -1 / 0), l("maxX", 1 / 0), l("minY", -1 / 0), l("maxY", 1 / 0), l("minZ", -1 / 0), l("maxZ", 1 / 0);
    const c = new he(), u = new he(), h = new xi(), d = new xi(), p = new he(), f = new xi(), m = new he(), _ = new he(), g = new he(), v = 0, S = new he();
    l("worldPosition", c), l("worldPositionStart", u), l("worldQuaternion", h), l("worldQuaternionStart", d), l("cameraPosition", p), l("cameraQuaternion", f), l("pointStart", m), l("pointEnd", _), l("rotationAxis", g), l("rotationAngle", v), l("eye", S), this._offset = new he(), this._startNorm = new he(), this._endNorm = new he(), this._cameraScale = new he(), this._parentPosition = new he(), this._parentQuaternion = new xi(), this._parentQuaternionInv = new xi(), this._parentScale = new he(), this._worldScaleStart = new he(), this._worldQuaternionInv = new xi(), this._worldScale = new he(), this._positionStart = new he(), this._quaternionStart = new xi(), this._scaleStart = new he(), this._getPointer = L9.bind(this), this._onPointerDown = O9.bind(this), this._onPointerHover = I9.bind(this), this._onPointerMove = F9.bind(this), this._onPointerUp = U9.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && Ao.setFromCamera(e, this.camera);
    const n = $p(this._gizmo.picker[this.mode], Ao);
    n ? this.axis = n.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Ao.setFromCamera(e, this.camera);
      const n = $p(this._plane, Ao, !0);
      n && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(n.point).sub(this.worldPositionStart)), this.dragging = !0, t_.mode = this.mode, this.dispatchEvent(t_);
    }
  }
  pointerMove(e) {
    const n = this.axis, i = this.mode, s = this.object;
    let o = this.space;
    if (i === "scale" ? o = "local" : (n === "E" || n === "XYZE" || n === "XYZ") && (o = "world"), s === void 0 || n === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && Ao.setFromCamera(e, this.camera);
    const a = $p(this._plane, Ao, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && n !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), n.indexOf("X") === -1 && (this._offset.x = 0), n.indexOf("Y") === -1 && (this._offset.y = 0), n.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && n !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), s.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (s.position.applyQuaternion(mn.copy(this._quaternionStart).invert()), n.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.position.applyQuaternion(this._quaternionStart)), o === "world" && (s.parent && s.position.add(li.setFromMatrixPosition(s.parent.matrixWorld)), n.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.parent && s.position.sub(li.setFromMatrixPosition(s.parent.matrixWorld)))), s.position.x = Math.max(this.minX, Math.min(this.maxX, s.position.x)), s.position.y = Math.max(this.minY, Math.min(this.maxY, s.position.y)), s.position.z = Math.max(this.minZ, Math.min(this.maxZ, s.position.z));
      else if (i === "scale") {
        if (n.search("XYZ") !== -1) {
          let l = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (l *= -1), Xr.set(l, l, l);
        } else
          li.copy(this.pointStart), Xr.copy(this.pointEnd), li.applyQuaternion(this._worldQuaternionInv), Xr.applyQuaternion(this._worldQuaternionInv), Xr.divide(li), n.search("X") === -1 && (Xr.x = 1), n.search("Y") === -1 && (Xr.y = 1), n.search("Z") === -1 && (Xr.z = 1);
        s.scale.copy(this._scaleStart).multiply(Xr), this.scaleSnap && (n.search("X") !== -1 && (s.scale.x = Math.round(s.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Y") !== -1 && (s.scale.y = Math.round(s.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Z") !== -1 && (s.scale.z = Math.round(s.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const l = 20 / this.worldPosition.distanceTo(li.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        n === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(li.copy(this.rotationAxis).cross(this.eye)) * l) : (n === "X" || n === "Y" || n === "Z") && (this.rotationAxis.copy(e_[n]), li.copy(e_[n]), o === "local" && li.applyQuaternion(this.worldQuaternion), li.cross(this.eye), li.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(li.normalize()) * l), (n === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && n !== "E" && n !== "XYZE" ? (s.quaternion.copy(this._quaternionStart), s.quaternion.multiply(mn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), s.quaternion.copy(mn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), s.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(jp), this.dispatchEvent(i_);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (n_.mode = this.mode, this.dispatchEvent(n_)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(jp), this.dispatchEvent(i_), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Ao;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function L9(r) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: r.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (r.clientX - e.left) / e.width * 2 - 1,
      y: -(r.clientY - e.top) / e.height * 2 + 1,
      button: r.button
    };
  }
}
function I9(r) {
  if (this.enabled)
    switch (r.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(r));
        break;
    }
}
function O9(r) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(r.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(r)), this.pointerDown(this._getPointer(r)));
}
function F9(r) {
  this.enabled && this.pointerMove(this._getPointer(r));
}
function U9(r) {
  this.enabled && (this.domElement.releasePointerCapture(r.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(r)));
}
function $p(r, e, n) {
  const i = e.intersectObject(r, !0);
  for (let s = 0; s < i.length; s++)
    if (i[s].object.visible || n)
      return i[s];
  return !1;
}
const kh = new Zi(), an = new he(0, 1, 0), s_ = new he(0, 0, 0), r_ = new rn(), Rh = new xi(), id = new xi(), Ls = new he(), o_ = new rn(), uc = new he(1, 0, 0), Oo = new he(0, 1, 0), hc = new he(0, 0, 1), Lh = new he(), Jl = new he(), Ql = new he();
class z9 extends vn {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const n = this.controls;
    n.object !== void 0 && (n.object.updateMatrixWorld(), n.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : n.object.parent.matrixWorld.decompose(n._parentPosition, n._parentQuaternion, n._parentScale), n.object.matrixWorld.decompose(n.worldPosition, n.worldQuaternion, n._worldScale), n._parentQuaternionInv.copy(n._parentQuaternion).invert(), n._worldQuaternionInv.copy(n.worldQuaternion).invert()), n.camera.updateMatrixWorld(), n.camera.matrixWorld.decompose(n.cameraPosition, n.cameraQuaternion, n._cameraScale), n.camera.isOrthographicCamera ? n.camera.getWorldDirection(n.eye).negate() : n.eye.copy(n.cameraPosition).sub(n.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class B9 extends vn {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Gn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = new As({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const s = n.clone();
    s.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const l = e.clone();
    l.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const h = e.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const d = e.clone();
    d.opacity = 0.25;
    const p = e.clone();
    p.color.setHex(16776960), p.opacity = 0.25, e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const _ = new Qn(0, 0.04, 0.1, 12);
    _.translate(0, 0.05, 0);
    const g = new Cn(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const v = new Wt();
    v.setAttribute("position", new Ot([0, 0, 0, 1, 0, 0], 3));
    const S = new Qn(75e-4, 75e-4, 0.5, 3);
    S.translate(0, 0.25, 0);
    function b(P, V) {
      const ce = new zo(P, 75e-4, 3, 64, V * Math.PI * 2);
      return ce.rotateY(Math.PI / 2), ce.rotateX(Math.PI / 2), ce;
    }
    function x() {
      const P = new Wt();
      return P.setAttribute("position", new Ot([0, 0, 0, 1, 1, 1], 3)), P;
    }
    const M = {
      X: [
        [new tt(_, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(_, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new tt(S, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new tt(_, a), [0, 0.5, 0]],
        [new tt(_, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new tt(S, a)]
      ],
      Z: [
        [new tt(_, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new tt(_, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new tt(S, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Na(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new tt(new Cn(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Cn(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Cn(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, C = {
      X: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Na(0.2, 0), i)]
      ],
      XY: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, E = {
      START: [
        [new tt(new Na(0.01, 2), s), null, null, null, "helper"]
      ],
      END: [
        [new tt(new Na(0.01, 2), s), null, null, null, "helper"]
      ],
      DELTA: [
        [new gn(x(), s), null, null, null, "helper"]
      ],
      X: [
        [new gn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new gn(v, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new gn(v, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, T = {
      XYZE: [
        [new tt(b(0.5, 1), m), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new tt(b(0.5, 0.5), o)]
      ],
      Y: [
        [new tt(b(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new tt(b(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new tt(b(0.75, 1), p), null, [0, Math.PI / 2, 0]]
      ]
    }, w = {
      AXIS: [
        [new gn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, A = {
      XYZE: [
        [new tt(new cf(0.25, 10, 8), i)]
      ],
      X: [
        [new tt(new zo(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new tt(new zo(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new tt(new zo(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new tt(new zo(0.75, 0.1, 2, 24), i)]
      ]
    }, O = {
      X: [
        [new tt(g, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(S, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(g, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(g, a), [0, 0.5, 0]],
        [new tt(S, a)],
        [new tt(g, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(g, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new tt(S, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new tt(g, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new tt(new Cn(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Cn(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Cn(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Cn(0.1, 0.1, 0.1), d.clone())]
      ]
    }, U = {
      X: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new tt(new Qn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new tt(new Cn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new tt(new Cn(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, D = {
      X: [
        [new gn(v, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new gn(v, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new gn(v, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function L(P) {
      const V = new vn();
      for (const ce in P)
        for (let q = P[ce].length; q--; ) {
          const oe = P[ce][q][0].clone(), ne = P[ce][q][1], $ = P[ce][q][2], J = P[ce][q][3], se = P[ce][q][4];
          oe.name = ce, oe.tag = se, ne && oe.position.set(ne[0], ne[1], ne[2]), $ && oe.rotation.set($[0], $[1], $[2]), J && oe.scale.set(J[0], J[1], J[2]), oe.updateMatrix();
          const le = oe.geometry.clone();
          le.applyMatrix4(oe.matrix), oe.geometry = le, oe.renderOrder = 1 / 0, oe.position.set(0, 0, 0), oe.rotation.set(0, 0, 0), oe.scale.set(1, 1, 1), V.add(oe);
        }
      return V;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = L(M)), this.add(this.gizmo.rotate = L(T)), this.add(this.gizmo.scale = L(O)), this.add(this.picker.translate = L(C)), this.add(this.picker.rotate = L(A)), this.add(this.picker.scale = L(U)), this.add(this.helper.translate = L(E)), this.add(this.helper.rotate = L(w)), this.add(this.helper.scale = L(D)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : id;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let s = [];
    s = s.concat(this.picker[this.mode].children), s = s.concat(this.gizmo[this.mode].children), s = s.concat(this.helper[this.mode].children);
    for (let o = 0; o < s.length; o++) {
      const a = s[o];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let l;
      if (this.camera.isOrthographicCamera ? l = (this.camera.top - this.camera.bottom) / this.camera.zoom : l = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(l * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (mn.setFromEuler(kh.set(0, 0, 0)), a.quaternion.copy(i).multiply(mn), Math.abs(an.copy(uc).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (mn.setFromEuler(kh.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(mn), Math.abs(an.copy(Oo).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (mn.setFromEuler(kh.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(mn), Math.abs(an.copy(hc).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (mn.setFromEuler(kh.set(0, Math.PI / 2, 0)), an.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(r_.lookAt(s_, an, Oo)), a.quaternion.multiply(mn), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), li.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), li.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(li), a.visible = this.dragging) : (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(an.copy(uc).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(an.copy(Oo).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(an.copy(hc).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(an.copy(hc).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(an.copy(uc).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(an.copy(Oo).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (Rh.copy(i), an.copy(this.eye).applyQuaternion(mn.copy(i).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(r_.lookAt(this.eye, s_, Oo)), a.name === "X" && (mn.setFromAxisAngle(uc, Math.atan2(-an.y, an.z)), mn.multiplyQuaternions(Rh, mn), a.quaternion.copy(mn)), a.name === "Y" && (mn.setFromAxisAngle(Oo, Math.atan2(an.x, an.z)), mn.multiplyQuaternions(Rh, mn), a.quaternion.copy(mn)), a.name === "Z" && (mn.setFromAxisAngle(hc, Math.atan2(an.y, an.x)), mn.multiplyQuaternions(Rh, mn), a.quaternion.copy(mn))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(c) {
        return a.name === c;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class N9 extends tt {
  constructor() {
    super(
      new yn(1e5, 1e5, 2, 2),
      new Gn({ visible: !1, wireframe: !0, side: Pn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let n = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (n = "local"), Lh.copy(uc).applyQuaternion(n === "local" ? this.worldQuaternion : id), Jl.copy(Oo).applyQuaternion(n === "local" ? this.worldQuaternion : id), Ql.copy(hc).applyQuaternion(n === "local" ? this.worldQuaternion : id), an.copy(Jl), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            an.copy(this.eye).cross(Lh), Ls.copy(Lh).cross(an);
            break;
          case "Y":
            an.copy(this.eye).cross(Jl), Ls.copy(Jl).cross(an);
            break;
          case "Z":
            an.copy(this.eye).cross(Ql), Ls.copy(Ql).cross(an);
            break;
          case "XY":
            Ls.copy(Ql);
            break;
          case "YZ":
            Ls.copy(Lh);
            break;
          case "XZ":
            an.copy(Ql), Ls.copy(Jl);
            break;
          case "XYZ":
          case "E":
            Ls.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Ls.set(0, 0, 0);
    }
    Ls.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (o_.lookAt(li.set(0, 0, 0), Ls, an), this.quaternion.setFromRotationMatrix(o_)), super.updateMatrixWorld(e);
  }
}
class V9 {
  constructor(e = null) {
    /** The main Three.js scene */
    pe(this, "scene");
    /** Group for composition layers (rendered content) */
    pe(this, "compositionGroup");
    /** Group for UI overlay elements */
    pe(this, "overlayGroup");
    /** Group for debug helpers */
    pe(this, "debugGroup");
    /** Composition bounds frame */
    pe(this, "compositionBounds", null);
    /** Composition dimensions */
    pe(this, "compositionWidth", 1920);
    pe(this, "compositionHeight", 1080);
    this.scene = new a3(), this.scene.name = "WeylScene", e ? this.scene.background = new Tt(e) : this.scene.background = null, this.compositionGroup = new ts(), this.compositionGroup.name = "composition", this.scene.add(this.compositionGroup), this.overlayGroup = new ts(), this.overlayGroup.name = "overlay", this.overlayGroup.renderOrder = 1e3, this.scene.add(this.overlayGroup), this.debugGroup = new ts(), this.debugGroup.name = "debug", this.debugGroup.visible = !1, this.scene.add(this.debugGroup), this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const e = new Hb(16777215, 0.6);
    e.name = "ambientLight", this.scene.add(e);
    const n = new Va(16777215, 0.8);
    n.name = "keyLight", n.position.set(1e3, -1e3, 2e3), n.castShadow = !0, n.shadow.mapSize.width = 2048, n.shadow.mapSize.height = 2048, this.scene.add(n);
    const i = new Va(16777215, 0.3);
    i.name = "fillLight", i.position.set(-500, 500, 1e3), this.scene.add(i);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(e) {
    this.compositionGroup.add(e), this.sortByZ();
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(e) {
    this.compositionGroup.remove(e);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   */
  sortByZ() {
    this.compositionGroup.children.sort((e, n) => (e.position.z || 0) - (n.position.z || 0));
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(e) {
    this.overlayGroup.add(e);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(e) {
    this.overlayGroup.remove(e);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    for (; this.overlayGroup.children.length > 0; ) {
      const e = this.overlayGroup.children[0];
      this.overlayGroup.remove(e), this.disposeObject(e);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(e) {
    this.scene.add(e);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(e) {
    this.scene.remove(e);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(e) {
    this.debugGroup.visible = e;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(e = 500) {
    const n = this.debugGroup.getObjectByName("axisHelper");
    n && this.debugGroup.remove(n);
    const i = new Q3(e);
    i.name = "axisHelper", this.debugGroup.add(i);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(e = 2e3, n = 40) {
    const i = this.debugGroup.getObjectByName("gridHelper");
    i && this.debugGroup.remove(i);
    const s = new K3(e, n, 4473924, 2236962);
    s.name = "gridHelper", s.rotation.x = Math.PI / 2, this.debugGroup.add(s);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(e) {
    e ? this.scene.background = new Tt(e) : this.scene.background = null;
  }
  /**
   * Get current background color
   */
  getBackground() {
    return this.scene.background instanceof Tt ? "#" + this.scene.background.getHexString() : null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(e, n) {
    this.compositionWidth = e, this.compositionHeight = n, this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    this.compositionBounds && (this.overlayGroup.remove(this.compositionBounds), this.compositionBounds.geometry.dispose(), this.compositionBounds.material.dispose());
    const e = this.compositionWidth, n = this.compositionHeight, i = [
      new he(0, 0, 0),
      new he(e, 0, 0),
      new he(e, -n, 0),
      new he(0, -n, 0)
    ], s = new Wt().setFromPoints(i), o = new As({
      color: 4886745,
      linewidth: 2,
      depthTest: !1
    });
    this.compositionBounds = new l3(s, o), this.compositionBounds.name = "compositionBounds", this.compositionBounds.renderOrder = 998, this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(e) {
    this.compositionBounds && (this.compositionBounds.visible = e);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(e) {
    return e.intersectObjects(this.compositionGroup.children, !0);
  }
  /**
   * Find layer object by ID
   */
  findLayerById(e) {
    return this.compositionGroup.children.find(
      (n) => n.userData.layerId === e
    ) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(e) {
    var n;
    for (e instanceof tt && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => {
      this.disposeMaterial(i);
    }) : e.material && this.disposeMaterial(e.material)); e.children.length > 0; ) {
      const i = e.children[0];
      e.remove(i), this.disposeObject(i);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(e) {
    var i, s, o, a, l, c, u, h;
    const n = e;
    (i = n.map) == null || i.dispose(), (s = n.normalMap) == null || s.dispose(), (o = n.roughnessMap) == null || o.dispose(), (a = n.metalnessMap) == null || a.dispose(), (l = n.aoMap) == null || l.dispose(), (c = n.emissiveMap) == null || c.dispose(), (u = n.alphaMap) == null || u.dispose(), (h = n.envMap) == null || h.dispose(), e.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    for (; this.compositionGroup.children.length > 0; ) {
      const e = this.compositionGroup.children[0];
      this.compositionGroup.remove(e), this.disposeObject(e);
    }
    for (this.clearOverlay(); this.debugGroup.children.length > 0; ) {
      const e = this.debugGroup.children[0];
      this.debugGroup.remove(e), this.disposeObject(e);
    }
    this.scene.clear();
  }
}
const G9 = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Pl {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const H9 = new rf(-1, 1, 1, -1, 0, 1);
class W9 extends Wt {
  constructor() {
    super(), this.setAttribute("position", new Ot([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Ot([0, 2, 0, 0, 2, 0], 2));
  }
}
const j9 = new W9();
class Lv {
  constructor(e) {
    this._mesh = new tt(j9, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, H9);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class $9 extends Pl {
  constructor(e, n) {
    super(), this.textureID = n !== void 0 ? n : "tDiffuse", e instanceof si ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = uu.clone(e.uniforms), this.material = new si({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Lv(this.material);
  }
  render(e, n, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class a_ extends Pl {
  constructor(e, n) {
    super(), this.scene = e, this.camera = n, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, n, i) {
    const s = e.getContext(), o = e.state;
    o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0);
    let a, l;
    this.inverse ? (a = 0, l = 1) : (a = 1, l = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.buffers.stencil.setFunc(s.ALWAYS, a, 4294967295), o.buffers.stencil.setClear(l), o.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.color.setMask(!0), o.buffers.depth.setMask(!0), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.buffers.stencil.setLocked(!0);
  }
}
class X9 extends Pl {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class Y9 {
  constructor(e, n) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), n === void 0) {
      const i = e.getSize(new ct());
      this._width = i.width, this._height = i.height, n = new Es(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: po }), n.texture.name = "EffectComposer.rt1";
    } else
      this._width = n.width, this._height = n.height;
    this.renderTarget1 = n, this.renderTarget2 = n.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new $9(G9), this.copyPass.material.blending = Hs, this.clock = new q3();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, n) {
    this.passes.splice(n, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const n = this.passes.indexOf(e);
    n !== -1 && this.passes.splice(n, 1);
  }
  isLastEnabledPass(e) {
    for (let n = e + 1; n < this.passes.length; n++)
      if (this.passes[n].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const n = this.renderer.getRenderTarget();
    let i = !1;
    for (let s = 0, o = this.passes.length; s < o; s++) {
      const a = this.passes[s];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        a_ !== void 0 && (a instanceof a_ ? i = !0 : a instanceof X9 && (i = !1));
      }
    }
    this.renderer.setRenderTarget(n);
  }
  reset(e) {
    if (e === void 0) {
      const n = this.renderer.getSize(new ct());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, n) {
    this._width = e, this._height = n;
    const i = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, s), this.renderTarget2.setSize(i, s);
    for (let o = 0; o < this.passes.length; o++)
      this.passes[o].setSize(i, s);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class q9 extends Pl {
  constructor(e, n, i = null, s = null, o = null) {
    super(), this.scene = e, this.camera = n, this.overrideMaterial = i, this.clearColor = s, this.clearAlpha = o, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Tt();
  }
  render(e, n, i) {
    const s = e.autoClear;
    e.autoClear = !1;
    let o, a;
    this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (o = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(o), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = s;
  }
}
const Z9 = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class K9 extends Pl {
  constructor() {
    super();
    const e = Z9;
    this.uniforms = uu.clone(e.uniforms), this.material = new B3({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new Lv(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, n, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, Nt.getTransfer(this._outputColorSpace) === nn && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === sb ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === rb ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === ob ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === Ng ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === ab ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === lb && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const J9 = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
  )
};
class Q9 extends Pl {
  constructor(e, n, i) {
    super(), this.scene = e, this.camera = n;
    const s = i.focus !== void 0 ? i.focus : 1, o = i.aperture !== void 0 ? i.aperture : 0.025, a = i.maxblur !== void 0 ? i.maxblur : 1;
    this.renderTargetDepth = new Es(1, 1, {
      // will be resized later
      minFilter: ii,
      magFilter: ii,
      type: po
    }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new tv(), this.materialDepth.depthPacking = Xg, this.materialDepth.blending = Hs;
    const l = J9, c = uu.clone(l.uniforms);
    c.tDepth.value = this.renderTargetDepth.texture, c.focus.value = s, c.aspect.value = n.aspect, c.aperture.value = o, c.maxblur.value = a, c.nearClip.value = n.near, c.farClip.value = n.far, this.materialBokeh = new si({
      defines: Object.assign({}, l.defines),
      uniforms: c,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.uniforms = c, this.fsQuad = new Lv(this.materialBokeh), this._oldClearColor = new Tt();
  }
  render(e, n, i) {
    this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
    const s = e.getClearAlpha(), o = e.autoClear;
    e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(s), e.autoClear = o;
  }
  setSize(e, n) {
    this.materialBokeh.uniforms.aspect.value = e / n, this.renderTargetDepth.setSize(e, n);
  }
  dispose() {
    this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose();
  }
}
class e7 {
  constructor(e, n, i) {
    pe(this, "renderer");
    pe(this, "composer");
    pe(this, "scene");
    pe(this, "camera");
    // Render targets
    pe(this, "colorTarget");
    pe(this, "depthTarget");
    // Frame capture
    pe(this, "captureCanvas");
    pe(this, "captureCtx");
    // Depth capture material
    pe(this, "depthMaterial");
    // Normal material for normal pass
    pe(this, "normalMaterial");
    // Dimensions
    pe(this, "width");
    pe(this, "height");
    pe(this, "pixelRatio");
    // Render mode
    pe(this, "renderMode", "color");
    // DOF pass
    pe(this, "bokehPass", null);
    pe(this, "dofConfig", {
      enabled: !1,
      focusDistance: 500,
      aperture: 0.025,
      maxBlur: 0.01
    });
    this.scene = n, this.camera = i, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio ?? Math.min(window.devicePixelRatio, 2), this.renderer = new o3({
      canvas: e.canvas,
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      preserveDrawingBuffer: !0,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: !1,
      depth: !0
    }), this.renderer.setPixelRatio(this.pixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.outputColorSpace = An, this.renderer.toneMapping = Ng, this.renderer.toneMappingExposure = 1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = Jx;
    const s = Math.floor(this.width * this.pixelRatio), o = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(s, o), this.depthTarget = this.createDepthTarget(s, o), this.composer = new Y9(this.renderer, this.colorTarget), this.setupDefaultPasses(), this.captureCanvas = new OffscreenCanvas(s, o), this.captureCtx = this.captureCanvas.getContext("2d"), this.depthMaterial = this.createDepthMaterial(), this.normalMaterial = new V3();
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(e, n) {
    return new Es(e, n, {
      minFilter: Kt,
      magFilter: Kt,
      format: fi,
      type: po,
      colorSpace: An,
      depthBuffer: !0,
      stencilBuffer: !1,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(e, n) {
    const i = new Es(e, n, {
      minFilter: ii,
      magFilter: ii,
      format: fi,
      type: Ii,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    return i.depthTexture = new ev(e, n), i.depthTexture.format = Ko, i.depthTexture.type = Ii, i;
  }
  createDepthMaterial() {
    return new si({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: !1,
      depthTest: !1
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const e = new q9(this.scene.scene, this.camera.camera);
    this.composer.addPass(e);
    const n = new K9();
    this.composer.addPass(n);
  }
  /**
   * Add a post-processing pass
   */
  addPass(e) {
    const n = this.composer.passes.findIndex(
      (i) => i.constructor.name === "OutputPass"
    );
    n > -1 ? this.composer.insertPass(e, n) : this.composer.addPass(e);
  }
  /**
   * Remove a post-processing pass
   */
  removePass(e) {
    this.composer.removePass(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(e) {
    this.dofConfig = { ...this.dofConfig, ...e }, this.dofConfig.enabled ? (this.bokehPass || this.createBokehPass(), this.updateBokehPass()) : this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    Math.floor(this.width * this.pixelRatio), Math.floor(this.height * this.pixelRatio), this.bokehPass = new Q9(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    ), this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const e = this.bokehPass.uniforms;
    e && (e.focus.value = this.dofConfig.focusDistance, e.aperture.value = this.dofConfig.aperture, e.maxblur.value = this.dofConfig.maxBlur);
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(e) {
    this.setDOF({ focusDistance: e });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(e) {
    this.setDOF({ aperture: e });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(e) {
    this.setDOF({ enabled: e });
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ(), this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(e) {
    const n = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene.scene, this.camera.camera), this.renderer.setRenderTarget(n);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, e === "depth" || e === "normal" ? this.scene.scene.overrideMaterial = e === "depth" ? this.depthMaterial : this.normalMaterial : this.scene.scene.overrideMaterial = null;
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio), i = new Uint8Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      e,
      n,
      i
    );
    const s = new Uint8ClampedArray(i.length), o = e * 4;
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * o, c = a * o;
      s.set(i.subarray(l, l + o), c);
    }
    return new ImageData(s, e, n);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const i = new Float32Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      e,
      n,
      i
    );
    const s = new Float32Array(e * n);
    for (let a = 0; a < e * n; a++)
      s[a] = i[a * 4];
    const o = new Float32Array(e * n);
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * e, c = a * e;
      o.set(s.subarray(l, l + e), c);
    }
    return o;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(e, n) {
    this.width = e, this.height = n;
    const i = Math.floor(e * this.pixelRatio), s = Math.floor(n * this.pixelRatio);
    this.renderer.setSize(e, n), this.composer.setSize(i, s), this.colorTarget.dispose(), this.depthTarget.dispose(), this.colorTarget = this.createColorTarget(i, s), this.depthTarget = this.createDepthTarget(i, s), this.composer.renderTarget1.dispose(), this.composer.renderTarget2.dispose(), this.composer.renderTarget1 = this.colorTarget.clone(), this.composer.renderTarget2 = this.colorTarget.clone(), this.captureCanvas.width = i, this.captureCanvas.height = s, this.bokehPass && this.dofConfig.enabled && (this.composer.removePass(this.bokehPass), this.bokehPass = null, this.createBokehPass());
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null), this.colorTarget.dispose(), this.depthTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.composer.dispose(), this.renderer.dispose();
  }
}
class t7 extends Ps {
  constructor(n, i) {
    super(n);
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    pe(this, "texture", null);
    /** Resource manager for texture loading */
    pe(this, "resources");
    /** Image dimensions */
    pe(this, "imageWidth", 100);
    pe(this, "imageHeight", 100);
    /** Source URL or asset ID */
    pe(this, "sourceUrl", null);
    /** Original (unprocessed) texture for effects source */
    pe(this, "originalTexture", null);
    /** Canvas for rendering texture to 2D for effect processing */
    pe(this, "textureCanvas", null);
    pe(this, "textureCanvasCtx", null);
    this.resources = i, this.geometry = new yn(1, 1), this.material = new Gn({
      color: 16777215,
      transparent: !0,
      side: Pn,
      depthWrite: !1
    }), this.mesh = new tt(this.geometry, this.material), this.mesh.name = `image_${this.id}`, this.group.add(this.mesh);
    const s = this.extractImageData(n);
    s.source && this.loadImage(s.source), this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(n) {
    const i = n.data;
    return {
      source: (i == null ? void 0 : i.source) ?? (i == null ? void 0 : i.url) ?? (i == null ? void 0 : i.assetId) ?? null,
      width: (i == null ? void 0 : i.width) ?? 100,
      height: (i == null ? void 0 : i.height) ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(n) {
    this.sourceUrl = n;
    try {
      const i = await this.resources.loadTexture(n, {
        minFilter: Kt,
        magFilter: Kt,
        generateMipmaps: !1,
        colorSpace: An
      });
      this.setTexture(i);
    } catch (i) {
      console.error(`[ImageLayer] Failed to load image: ${n}`, i);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(n) {
    this.texture = n, this.originalTexture = n, this.material.map = n, this.material.needsUpdate = !0, n.image && (this.imageWidth = n.image.width || n.image.videoWidth || 100, this.imageHeight = n.image.height || n.image.videoHeight || 100, this.updateMeshSize(), this.textureCanvas = null, this.textureCanvasCtx = null, this.effectsDirty = !0);
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(n) {
    const i = this.resources.createTextureFromImageData(
      n,
      `layer_${this.id}_imagedata`,
      {
        minFilter: Kt,
        magFilter: Kt,
        generateMipmaps: !1,
        colorSpace: An
      }
    );
    this.setTexture(i);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_canvas`,
      {
        minFilter: Kt,
        magFilter: Kt,
        generateMipmaps: !1,
        colorSpace: An
      }
    );
    this.setTexture(i);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose(), this.geometry = new yn(this.imageWidth, this.imageHeight), this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(n, i) {
    this.imageWidth = n, this.imageHeight = i, this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(n) {
    this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215), this.material.needsUpdate = !0;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    var i;
    if (!((i = this.originalTexture) != null && i.image))
      return null;
    const n = this.originalTexture.image;
    return (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) && (this.textureCanvas = document.createElement("canvas"), this.textureCanvas.width = this.imageWidth, this.textureCanvas.height = this.imageHeight, this.textureCanvasCtx = this.textureCanvas.getContext("2d")), this.textureCanvasCtx ? (this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight), this.textureCanvasCtx.drawImage(n, 0, 0, this.imageWidth, this.imageHeight), this.textureCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Kt,
        magFilter: Kt,
        generateMipmaps: !1,
        colorSpace: An
      }
    );
    this.texture = i, this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.evaluateEffects(n);
  }
  onUpdate(n) {
    const i = n.data;
    if (i != null && i.source || i != null && i.url || i != null && i.assetId) {
      const s = i.source ?? i.url ?? i.assetId;
      s !== this.sourceUrl && this.loadImage(s);
    }
    ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.imageWidth,
      i.height ?? this.imageHeight
    );
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class n7 extends Ps {
  constructor(n) {
    super(n);
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    /** Solid color */
    pe(this, "color");
    /** Solid dimensions */
    pe(this, "width");
    pe(this, "height");
    const i = this.extractSolidData(n);
    this.color = i.color, this.width = i.width, this.height = i.height, this.geometry = new yn(this.width, this.height), this.material = new Gn({
      color: this.color,
      transparent: !0,
      side: Pn,
      depthWrite: !1
    }), this.mesh = new tt(this.geometry, this.material), this.mesh.name = `solid_${this.id}`, this.group.add(this.mesh), this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(n) {
    const i = n.data;
    return {
      color: (i == null ? void 0 : i.color) ?? "#808080",
      width: (i == null ? void 0 : i.width) ?? 1920,
      height: (i == null ? void 0 : i.height) ?? 1080
    };
  }
  /**
   * Set solid color
   */
  setColor(n) {
    this.color = n, this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new yn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    (i == null ? void 0 : i.color) !== void 0 && this.setColor(i.color), ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.width,
      i.height ?? this.height
    ), i === void 0 && n.labelColor !== void 0 && this.setColor(n.labelColor);
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class l_ extends Ps {
  constructor(n, i = !0) {
    super(n);
    /** Visual indicator (crosshair) for editor visibility */
    pe(this, "indicator", null);
    /** Whether to show the null indicator */
    pe(this, "showIndicator");
    /** Indicator size */
    pe(this, "indicatorSize");
    this.showIndicator = i, this.indicatorSize = 50, this.showIndicator && this.createIndicator();
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new ts(), this.indicator.name = `null_indicator_${this.id}`;
    const n = this.indicatorSize, i = 16737792, s = new As({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), o = [
      new he(-n / 2, 0, 0),
      new he(n / 2, 0, 0)
    ], a = new Wt().setFromPoints(o), l = new gn(a, s);
    this.indicator.add(l);
    const c = [
      new he(0, -n / 2, 0),
      new he(0, n / 2, 0)
    ], u = new Wt().setFromPoints(c), h = new gn(u, s);
    if (this.indicator.add(h), this.threeD) {
      const m = [
        new he(0, 0, -n / 2),
        new he(0, 0, n / 2)
      ], _ = new Wt().setFromPoints(m), g = new gn(_, s);
      this.indicator.add(g);
    }
    const d = new af(3, 16), p = new Gn({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1,
      side: Pn
    }), f = new tt(d, p);
    this.indicator.add(f), this.group.add(this.indicator), this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(n) {
    this.indicator && (this.indicator.visible = n);
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(n) {
    n !== this.indicatorSize && (this.indicatorSize = n, this.indicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    this.indicator && (this.indicator.traverse((n) => {
      n instanceof gn && (n.geometry.dispose(), n.material.dispose()), n instanceof tt && (n.geometry.dispose(), n.material.dispose());
    }), this.indicator.clear(), this.indicator = null);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    n.threeD !== void 0 && n.threeD !== this.threeD && (this.threeD = n.threeD, this.indicator && this.showIndicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  onDispose() {
    this.disposeIndicator();
  }
}
function i7() {
  var r = /* @__PURE__ */ Object.create(null);
  function e(s, o) {
    var a = s.id, l = s.name, c = s.dependencies;
    c === void 0 && (c = []);
    var u = s.init;
    u === void 0 && (u = function() {
    });
    var h = s.getTransferables;
    if (h === void 0 && (h = null), !r[a])
      try {
        c = c.map(function(p) {
          return p && p.isWorkerModule && (e(p, function(f) {
            if (f instanceof Error)
              throw f;
          }), p = r[p.id].value), p;
        }), u = i("<" + l + ">.init", u), h && (h = i("<" + l + ">.getTransferables", h));
        var d = null;
        typeof u == "function" ? d = u.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), r[a] = {
          id: a,
          value: d,
          getTransferables: h
        }, o(d);
      } catch (p) {
        p && p.noLog || console.error(p), o(p);
      }
  }
  function n(s, o) {
    var a, l = s.id, c = s.args;
    (!r[l] || typeof r[l].value != "function") && o(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
    try {
      var u = (a = r[l]).value.apply(a, c);
      u && typeof u.then == "function" ? u.then(h, function(d) {
        return o(d instanceof Error ? d : new Error("" + d));
      }) : h(u);
    } catch (d) {
      o(d);
    }
    function h(d) {
      try {
        var p = r[l].getTransferables && r[l].getTransferables(d);
        (!p || !Array.isArray(p) || !p.length) && (p = void 0), o(d, p);
      } catch (f) {
        console.error(f), o(f);
      }
    }
  }
  function i(s, o) {
    var a = void 0;
    self.troikaDefine = function(c) {
      return a = c;
    };
    var l = URL.createObjectURL(
      new Blob(
        ["/** " + s.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(s) {
    var o = s.data, a = o.messageId, l = o.action, c = o.data;
    try {
      l === "registerModule" && e(c, function(u) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof u == "function" }
        });
      }), l === "callModule" && n(c, function(u, h) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: u
        }, h || void 0);
      });
    } catch (u) {
      postMessage({
        messageId: a,
        success: !1,
        error: u.stack
      });
    }
  });
}
function s7(r) {
  var e = function() {
    for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];
    return e._getInitResult().then(function(s) {
      if (typeof s == "function")
        return s.apply(void 0, n);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var n = r.dependencies, i = r.init;
    n = Array.isArray(n) ? n.map(function(o) {
      return o && (o = o.onMainThread || o, o._getInitResult && (o = o._getInitResult())), o;
    }) : [];
    var s = Promise.all(n).then(function(o) {
      return i.apply(null, o);
    });
    return e._getInitResult = function() {
      return s;
    }, s;
  }, e;
}
var oS = function() {
  var r = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), r = !0;
    } catch (n) {
      console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + n.message + "]"
      );
    }
  return oS = function() {
    return r;
  }, r;
}, r7 = 0, o7 = 0, Xp = !1, Rc = /* @__PURE__ */ Object.create(null), Lc = /* @__PURE__ */ Object.create(null), gg = /* @__PURE__ */ Object.create(null);
function Dl(r) {
  if ((!r || typeof r.init != "function") && !Xp)
    throw new Error("requires `options.init` function");
  var e = r.dependencies, n = r.init, i = r.getTransferables, s = r.workerId, o = s7(r);
  s == null && (s = "#default");
  var a = "workerModule" + ++r7, l = r.name || a, c = null;
  e = e && e.map(function(h) {
    return typeof h == "function" && !h.workerModuleData && (Xp = !0, h = Dl({
      workerId: s,
      name: "<" + l + "> function dependency: " + h.name,
      init: `function(){return (
` + sd(h) + `
)}`
    }), Xp = !1), h && h.workerModuleData && (h = h.workerModuleData), h;
  });
  function u() {
    for (var h = [], d = arguments.length; d--; ) h[d] = arguments[d];
    if (!oS())
      return o.apply(void 0, h);
    if (!c) {
      c = c_(s, "registerModule", u.workerModuleData);
      var p = function() {
        c = null, Lc[s].delete(p);
      };
      (Lc[s] || (Lc[s] = /* @__PURE__ */ new Set())).add(p);
    }
    return c.then(function(f) {
      var m = f.isCallable;
      if (m)
        return c_(s, "callModule", { id: a, args: h });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return u.workerModuleData = {
    isWorkerModule: !0,
    id: a,
    name: l,
    dependencies: e,
    init: sd(n),
    getTransferables: i && sd(i)
  }, u.onMainThread = o, u;
}
function a7(r) {
  Lc[r] && Lc[r].forEach(function(e) {
    e();
  }), Rc[r] && (Rc[r].terminate(), delete Rc[r]);
}
function sd(r) {
  var e = r.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function l7(r) {
  var e = Rc[r];
  if (!e) {
    var n = sd(i7);
    e = Rc[r] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + r.replace(/\*/g, "") + ` **/

;(` + n + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var s = i.data, o = s.messageId, a = gg[o];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete gg[o], a(s);
    };
  }
  return e;
}
function c_(r, e, n) {
  return new Promise(function(i, s) {
    var o = ++o7;
    gg[o] = function(a) {
      a.success ? i(a.result) : s(new Error("Error in worker " + e + " call: " + a.error));
    }, l7(r).postMessage({
      messageId: o,
      action: e,
      data: n
    });
  });
}
function aS() {
  var r = function(e) {
    function n(oe, ne, $, J, se, le, re, ye) {
      var H = 1 - re;
      ye.x = H * H * oe + 2 * H * re * $ + re * re * se, ye.y = H * H * ne + 2 * H * re * J + re * re * le;
    }
    function i(oe, ne, $, J, se, le, re, ye, H, K) {
      var G = 1 - H;
      K.x = G * G * G * oe + 3 * G * G * H * $ + 3 * G * H * H * se + H * H * H * re, K.y = G * G * G * ne + 3 * G * G * H * J + 3 * G * H * H * le + H * H * H * ye;
    }
    function s(oe, ne) {
      for (var $ = /([MLQCZ])([^MLQCZ]*)/g, J, se, le, re, ye; J = $.exec(oe); ) {
        var H = J[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(K) {
          return parseFloat(K);
        });
        switch (J[1]) {
          case "M":
            re = se = H[0], ye = le = H[1];
            break;
          case "L":
            (H[0] !== re || H[1] !== ye) && ne("L", re, ye, re = H[0], ye = H[1]);
            break;
          case "Q": {
            ne("Q", re, ye, re = H[2], ye = H[3], H[0], H[1]);
            break;
          }
          case "C": {
            ne("C", re, ye, re = H[4], ye = H[5], H[0], H[1], H[2], H[3]);
            break;
          }
          case "Z":
            (re !== se || ye !== le) && ne("L", re, ye, se, le);
            break;
        }
      }
    }
    function o(oe, ne, $) {
      $ === void 0 && ($ = 16);
      var J = { x: 0, y: 0 };
      s(oe, function(se, le, re, ye, H, K, G, R, z) {
        switch (se) {
          case "L":
            ne(le, re, ye, H);
            break;
          case "Q": {
            for (var I = le, Q = re, X = 1; X < $; X++)
              n(
                le,
                re,
                K,
                G,
                ye,
                H,
                X / ($ - 1),
                J
              ), ne(I, Q, J.x, J.y), I = J.x, Q = J.y;
            break;
          }
          case "C": {
            for (var k = le, ee = re, Z = 1; Z < $; Z++)
              i(
                le,
                re,
                K,
                G,
                R,
                z,
                ye,
                H,
                Z / ($ - 1),
                J
              ), ne(k, ee, J.x, J.y), k = J.x, ee = J.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), u = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function h(oe, ne) {
      var $ = oe.getContext ? oe.getContext("webgl", u) : oe, J = c.get($);
      if (!J) {
        let G = function(k) {
          var ee = le[k];
          if (!ee && (ee = le[k] = $.getExtension(k), !ee))
            throw new Error(k + " not supported");
          return ee;
        }, R = function(k, ee) {
          var Z = $.createShader(ee);
          return $.shaderSource(Z, k), $.compileShader(Z), Z;
        }, z = function(k, ee, Z, N) {
          if (!re[k]) {
            var j = {}, te = {}, F = $.createProgram();
            $.attachShader(F, R(ee, $.VERTEX_SHADER)), $.attachShader(F, R(Z, $.FRAGMENT_SHADER)), $.linkProgram(F), re[k] = {
              program: F,
              transaction: function(Y) {
                $.useProgram(F), Y({
                  setUniform: function(ge, xe) {
                    for (var De = [], ae = arguments.length - 2; ae-- > 0; ) De[ae] = arguments[ae + 2];
                    var de = te[xe] || (te[xe] = $.getUniformLocation(F, xe));
                    $["uniform" + ge].apply($, [de].concat(De));
                  },
                  setAttribute: function(ge, xe, De, ae, de) {
                    var Ee = j[ge];
                    Ee || (Ee = j[ge] = {
                      buf: $.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: $.getAttribLocation(F, ge),
                      data: null
                    }), $.bindBuffer($.ARRAY_BUFFER, Ee.buf), $.vertexAttribPointer(Ee.loc, xe, $.FLOAT, !1, 0, 0), $.enableVertexAttribArray(Ee.loc), se ? $.vertexAttribDivisor(Ee.loc, ae) : G("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ee.loc, ae), de !== Ee.data && ($.bufferData($.ARRAY_BUFFER, de, De), Ee.data = de);
                  }
                });
              }
            };
          }
          re[k].transaction(N);
        }, I = function(k, ee) {
          H++;
          try {
            $.activeTexture($.TEXTURE0 + H);
            var Z = ye[k];
            Z || (Z = ye[k] = $.createTexture(), $.bindTexture($.TEXTURE_2D, Z), $.texParameteri($.TEXTURE_2D, $.TEXTURE_MIN_FILTER, $.NEAREST), $.texParameteri($.TEXTURE_2D, $.TEXTURE_MAG_FILTER, $.NEAREST)), $.bindTexture($.TEXTURE_2D, Z), ee(Z, H);
          } finally {
            H--;
          }
        }, Q = function(k, ee, Z) {
          var N = $.createFramebuffer();
          K.push(N), $.bindFramebuffer($.FRAMEBUFFER, N), $.activeTexture($.TEXTURE0 + ee), $.bindTexture($.TEXTURE_2D, k), $.framebufferTexture2D($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_2D, k, 0);
          try {
            Z(N);
          } finally {
            $.deleteFramebuffer(N), $.bindFramebuffer($.FRAMEBUFFER, K[--K.length - 1] || null);
          }
        }, X = function() {
          le = {}, re = {}, ye = {}, H = -1, K.length = 0;
        };
        var se = typeof WebGL2RenderingContext < "u" && $ instanceof WebGL2RenderingContext, le = {}, re = {}, ye = {}, H = -1, K = [];
        $.canvas.addEventListener("webglcontextlost", function(k) {
          X(), k.preventDefault();
        }, !1), c.set($, J = {
          gl: $,
          isWebGL2: se,
          getExtension: G,
          withProgram: z,
          withTexture: I,
          withTextureFramebuffer: Q,
          handleContextLoss: X
        });
      }
      ne(J);
    }
    function d(oe, ne, $, J, se, le, re, ye) {
      re === void 0 && (re = 15), ye === void 0 && (ye = null), h(oe, function(H) {
        var K = H.gl, G = H.withProgram, R = H.withTexture;
        R("copy", function(z, I) {
          K.texImage2D(K.TEXTURE_2D, 0, K.RGBA, se, le, 0, K.RGBA, K.UNSIGNED_BYTE, ne), G("copy", a, l, function(Q) {
            var X = Q.setUniform, k = Q.setAttribute;
            k("aUV", 2, K.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), X("1i", "image", I), K.bindFramebuffer(K.FRAMEBUFFER, ye || null), K.disable(K.BLEND), K.colorMask(re & 8, re & 4, re & 2, re & 1), K.viewport($, J, se, le), K.scissor($, J, se, le), K.drawArrays(K.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function p(oe, ne, $) {
      var J = oe.width, se = oe.height;
      h(oe, function(le) {
        var re = le.gl, ye = new Uint8Array(J * se * 4);
        re.readPixels(0, 0, J, se, re.RGBA, re.UNSIGNED_BYTE, ye), oe.width = ne, oe.height = $, d(re, ye, 0, 0, J, se);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: h,
      renderImageData: d,
      resizeWebGLCanvasWithoutClearing: p
    });
    function m(oe, ne, $, J, se, le) {
      le === void 0 && (le = 1);
      var re = new Uint8Array(oe * ne), ye = J[2] - J[0], H = J[3] - J[1], K = [];
      o($, function(k, ee, Z, N) {
        K.push({
          x1: k,
          y1: ee,
          x2: Z,
          y2: N,
          minX: Math.min(k, Z),
          minY: Math.min(ee, N),
          maxX: Math.max(k, Z),
          maxY: Math.max(ee, N)
        });
      }), K.sort(function(k, ee) {
        return k.maxX - ee.maxX;
      });
      for (var G = 0; G < oe; G++)
        for (var R = 0; R < ne; R++) {
          var z = Q(
            J[0] + ye * (G + 0.5) / oe,
            J[1] + H * (R + 0.5) / ne
          ), I = Math.pow(1 - Math.abs(z) / se, le) / 2;
          z < 0 && (I = 1 - I), I = Math.max(0, Math.min(255, Math.round(I * 255))), re[R * oe + G] = I;
        }
      return re;
      function Q(k, ee) {
        for (var Z = 1 / 0, N = 1 / 0, j = K.length; j--; ) {
          var te = K[j];
          if (te.maxX + N <= k)
            break;
          if (k + N > te.minX && ee - N < te.maxY && ee + N > te.minY) {
            var F = v(k, ee, te.x1, te.y1, te.x2, te.y2);
            F < Z && (Z = F, N = Math.sqrt(Z));
          }
        }
        return X(k, ee) && (N = -N), N;
      }
      function X(k, ee) {
        for (var Z = 0, N = K.length; N--; ) {
          var j = K[N];
          if (j.maxX <= k)
            break;
          var te = j.y1 > ee != j.y2 > ee && k < (j.x2 - j.x1) * (ee - j.y1) / (j.y2 - j.y1) + j.x1;
          te && (Z += j.y1 < j.y2 ? 1 : -1);
        }
        return Z !== 0;
      }
    }
    function _(oe, ne, $, J, se, le, re, ye, H, K) {
      le === void 0 && (le = 1), ye === void 0 && (ye = 0), H === void 0 && (H = 0), K === void 0 && (K = 0), g(oe, ne, $, J, se, le, re, null, ye, H, K);
    }
    function g(oe, ne, $, J, se, le, re, ye, H, K, G) {
      le === void 0 && (le = 1), H === void 0 && (H = 0), K === void 0 && (K = 0), G === void 0 && (G = 0);
      for (var R = m(oe, ne, $, J, se, le), z = new Uint8Array(R.length * 4), I = 0; I < R.length; I++)
        z[I * 4 + G] = R[I];
      d(re, z, H, K, oe, ne, 1 << 3 - G, ye);
    }
    function v(oe, ne, $, J, se, le) {
      var re = se - $, ye = le - J, H = re * re + ye * ye, K = H ? Math.max(0, Math.min(1, ((oe - $) * re + (ne - J) * ye) / H)) : 0, G = oe - ($ + K * re), R = ne - (J + K * ye);
      return G * G + R * R;
    }
    var S = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: m,
      generateIntoCanvas: _,
      generateIntoFramebuffer: g
    }), b = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", M = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", C = new Float32Array([0, 0, 2, 0, 0, 2]), E = null, T = !1, w = {}, A = /* @__PURE__ */ new WeakMap();
    function O(oe) {
      if (!T && !P(oe))
        throw new Error("WebGL generation not supported");
    }
    function U(oe, ne, $, J, se, le, re) {
      if (le === void 0 && (le = 1), re === void 0 && (re = null), !re && (re = E, !re)) {
        var ye = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!ye)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        re = E = ye.getContext("webgl", { depth: !1 });
      }
      O(re);
      var H = new Uint8Array(oe * ne * 4);
      h(re, function(z) {
        var I = z.gl, Q = z.withTexture, X = z.withTextureFramebuffer;
        Q("readable", function(k, ee) {
          I.texImage2D(I.TEXTURE_2D, 0, I.RGBA, oe, ne, 0, I.RGBA, I.UNSIGNED_BYTE, null), X(k, ee, function(Z) {
            L(
              oe,
              ne,
              $,
              J,
              se,
              le,
              I,
              Z,
              0,
              0,
              0
              // red channel
            ), I.readPixels(0, 0, oe, ne, I.RGBA, I.UNSIGNED_BYTE, H);
          });
        });
      });
      for (var K = new Uint8Array(oe * ne), G = 0, R = 0; G < H.length; G += 4)
        K[R++] = H[G];
      return K;
    }
    function D(oe, ne, $, J, se, le, re, ye, H, K) {
      le === void 0 && (le = 1), ye === void 0 && (ye = 0), H === void 0 && (H = 0), K === void 0 && (K = 0), L(oe, ne, $, J, se, le, re, null, ye, H, K);
    }
    function L(oe, ne, $, J, se, le, re, ye, H, K, G) {
      le === void 0 && (le = 1), H === void 0 && (H = 0), K === void 0 && (K = 0), G === void 0 && (G = 0), O(re);
      var R = [];
      o($, function(z, I, Q, X) {
        R.push(z, I, Q, X);
      }), R = new Float32Array(R), h(re, function(z) {
        var I = z.gl, Q = z.isWebGL2, X = z.getExtension, k = z.withProgram, ee = z.withTexture, Z = z.withTextureFramebuffer, N = z.handleContextLoss;
        if (ee("rawDistances", function(j, te) {
          (oe !== j._lastWidth || ne !== j._lastHeight) && I.texImage2D(
            I.TEXTURE_2D,
            0,
            I.RGBA,
            j._lastWidth = oe,
            j._lastHeight = ne,
            0,
            I.RGBA,
            I.UNSIGNED_BYTE,
            null
          ), k("main", b, x, function(F) {
            var B = F.setAttribute, Y = F.setUniform, fe = !Q && X("ANGLE_instanced_arrays"), ge = !Q && X("EXT_blend_minmax");
            B("aUV", 2, I.STATIC_DRAW, 0, C), B("aLineSegment", 4, I.DYNAMIC_DRAW, 1, R), Y.apply(void 0, ["4f", "uGlyphBounds"].concat(J)), Y("1f", "uMaxDistance", se), Y("1f", "uExponent", le), Z(j, te, function(xe) {
              I.enable(I.BLEND), I.colorMask(!0, !0, !0, !0), I.viewport(0, 0, oe, ne), I.scissor(0, 0, oe, ne), I.blendFunc(I.ONE, I.ONE), I.blendEquationSeparate(I.FUNC_ADD, Q ? I.MAX : ge.MAX_EXT), I.clear(I.COLOR_BUFFER_BIT), Q ? I.drawArraysInstanced(I.TRIANGLES, 0, 3, R.length / 4) : fe.drawArraysInstancedANGLE(I.TRIANGLES, 0, 3, R.length / 4);
            });
          }), k("post", a, M, function(F) {
            F.setAttribute("aUV", 2, I.STATIC_DRAW, 0, C), F.setUniform("1i", "tex", te), I.bindFramebuffer(I.FRAMEBUFFER, ye), I.disable(I.BLEND), I.colorMask(G === 0, G === 1, G === 2, G === 3), I.viewport(H, K, oe, ne), I.scissor(H, K, oe, ne), I.drawArrays(I.TRIANGLES, 0, 3);
          });
        }), I.isContextLost())
          throw N(), new Error("webgl context lost");
      });
    }
    function P(oe) {
      var ne = !oe || oe === E ? w : oe.canvas || oe, $ = A.get(ne);
      if ($ === void 0) {
        T = !0;
        var J = null;
        try {
          var se = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], le = U(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            oe
          );
          $ = le && se.length === le.length && le.every(function(re, ye) {
            return re === se[ye];
          }), $ || (J = "bad trial run results", console.info(se, le));
        } catch (re) {
          $ = !1, J = re.message;
        }
        J && console.warn("WebGL SDF generation not supported:", J), T = !1, A.set(ne, $);
      }
      return $;
    }
    var V = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: U,
      generateIntoCanvas: D,
      generateIntoFramebuffer: L,
      isSupported: P
    });
    function ce(oe, ne, $, J, se, le) {
      se === void 0 && (se = Math.max(J[2] - J[0], J[3] - J[1]) / 2), le === void 0 && (le = 1);
      try {
        return U.apply(V, arguments);
      } catch (re) {
        return console.info("WebGL SDF generation failed, falling back to JS", re), m.apply(S, arguments);
      }
    }
    function q(oe, ne, $, J, se, le, re, ye, H, K) {
      se === void 0 && (se = Math.max(J[2] - J[0], J[3] - J[1]) / 2), le === void 0 && (le = 1), ye === void 0 && (ye = 0), H === void 0 && (H = 0), K === void 0 && (K = 0);
      try {
        return D.apply(V, arguments);
      } catch (G) {
        return console.info("WebGL SDF generation failed, falling back to JS", G), _.apply(S, arguments);
      }
    }
    return e.forEachPathCommand = s, e.generate = ce, e.generateIntoCanvas = q, e.javascript = S, e.pathToLineSegments = o, e.webgl = V, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return r;
}
function c7() {
  var r = function(e) {
    var n = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, s = {};
    i.L = 1, s[1] = "L", Object.keys(n).forEach(function(N, j) {
      i[N] = 1 << j + 1, s[i[N]] = N;
    }), Object.freeze(i);
    var o = i.LRI | i.RLI | i.FSI, a = i.L | i.R | i.AL, l = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, c = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, u = i.S | i.WS | i.B | o | i.PDI | c, h = null;
    function d() {
      if (!h) {
        h = /* @__PURE__ */ new Map();
        var N = function(te) {
          if (n.hasOwnProperty(te)) {
            var F = 0;
            n[te].split(",").forEach(function(B) {
              var Y = B.split("+"), fe = Y[0], ge = Y[1];
              fe = parseInt(fe, 36), ge = ge ? parseInt(ge, 36) : 0, h.set(F += fe, i[te]);
              for (var xe = 0; xe < ge; xe++)
                h.set(++F, i[te]);
            });
          }
        };
        for (var j in n) N(j);
      }
    }
    function p(N) {
      return d(), h.get(N.codePointAt(0)) || i.L;
    }
    function f(N) {
      return s[p(N)];
    }
    var m = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function _(N, j) {
      var te = 36, F = 0, B = /* @__PURE__ */ new Map(), Y = j && /* @__PURE__ */ new Map(), fe;
      return N.split(",").forEach(function ge(xe) {
        if (xe.indexOf("+") !== -1)
          for (var De = +xe; De--; )
            ge(fe);
        else {
          fe = xe;
          var ae = xe.split(">"), de = ae[0], Ee = ae[1];
          de = String.fromCodePoint(F += parseInt(de, te)), Ee = String.fromCodePoint(F += parseInt(Ee, te)), B.set(de, Ee), j && Y.set(Ee, de);
        }
      }), { map: B, reverseMap: Y };
    }
    var g, v, S;
    function b() {
      if (!g) {
        var N = _(m.pairs, !0), j = N.map, te = N.reverseMap;
        g = j, v = te, S = _(m.canonical, !1).map;
      }
    }
    function x(N) {
      return b(), g.get(N) || null;
    }
    function M(N) {
      return b(), v.get(N) || null;
    }
    function C(N) {
      return b(), S.get(N) || null;
    }
    var E = i.L, T = i.R, w = i.EN, A = i.ES, O = i.ET, U = i.AN, D = i.CS, L = i.B, P = i.S, V = i.ON, ce = i.BN, q = i.NSM, oe = i.AL, ne = i.LRO, $ = i.RLO, J = i.LRE, se = i.RLE, le = i.PDF, re = i.LRI, ye = i.RLI, H = i.FSI, K = i.PDI;
    function G(N, j) {
      for (var te = 125, F = new Uint32Array(N.length), B = 0; B < N.length; B++)
        F[B] = p(N[B]);
      var Y = /* @__PURE__ */ new Map();
      function fe(Ai, ls) {
        var Pi = F[Ai];
        F[Ai] = ls, Y.set(Pi, Y.get(Pi) - 1), Pi & l && Y.set(l, Y.get(l) - 1), Y.set(ls, (Y.get(ls) || 0) + 1), ls & l && Y.set(l, (Y.get(l) || 0) + 1);
      }
      for (var ge = new Uint8Array(N.length), xe = /* @__PURE__ */ new Map(), De = [], ae = null, de = 0; de < N.length; de++)
        ae || De.push(ae = {
          start: de,
          end: N.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: j === "rtl" ? 1 : j === "ltr" ? 0 : Yv(de, !1)
        }), F[de] & L && (ae.end = de, ae = null);
      for (var Ee = se | J | $ | ne | o | K | le | L, be = function(Ai) {
        return Ai + (Ai & 1 ? 1 : 2);
      }, ke = function(Ai) {
        return Ai + (Ai & 1 ? 2 : 1);
      }, ze = 0; ze < De.length; ze++) {
        ae = De[ze];
        var Te = [{
          _level: ae.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Pe = void 0, Ge = 0, Ve = 0, Qe = 0;
        Y.clear();
        for (var _e = ae.start; _e <= ae.end; _e++) {
          var Ue = F[_e];
          if (Pe = Te[Te.length - 1], Y.set(Ue, (Y.get(Ue) || 0) + 1), Ue & l && Y.set(l, (Y.get(l) || 0) + 1), Ue & Ee)
            if (Ue & (se | J)) {
              ge[_e] = Pe._level;
              var Fe = (Ue === se ? ke : be)(Pe._level);
              Fe <= te && !Ge && !Ve ? Te.push({
                _level: Fe,
                _override: 0,
                _isolate: 0
              }) : Ge || Ve++;
            } else if (Ue & ($ | ne)) {
              ge[_e] = Pe._level;
              var je = (Ue === $ ? ke : be)(Pe._level);
              je <= te && !Ge && !Ve ? Te.push({
                _level: je,
                _override: Ue & $ ? T : E,
                _isolate: 0
              }) : Ge || Ve++;
            } else if (Ue & o) {
              Ue & H && (Ue = Yv(_e + 1, !0) === 1 ? ye : re), ge[_e] = Pe._level, Pe._override && fe(_e, Pe._override);
              var Ke = (Ue === ye ? ke : be)(Pe._level);
              Ke <= te && Ge === 0 && Ve === 0 ? (Qe++, Te.push({
                _level: Ke,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: _e
              })) : Ge++;
            } else if (Ue & K) {
              if (Ge > 0)
                Ge--;
              else if (Qe > 0) {
                for (Ve = 0; !Te[Te.length - 1]._isolate; )
                  Te.pop();
                var qe = Te[Te.length - 1]._isolInitIndex;
                qe != null && (xe.set(qe, _e), xe.set(_e, qe)), Te.pop(), Qe--;
              }
              Pe = Te[Te.length - 1], ge[_e] = Pe._level, Pe._override && fe(_e, Pe._override);
            } else Ue & le ? (Ge === 0 && (Ve > 0 ? Ve-- : !Pe._isolate && Te.length > 1 && (Te.pop(), Pe = Te[Te.length - 1])), ge[_e] = Pe._level) : Ue & L && (ge[_e] = ae.level);
          else
            ge[_e] = Pe._level, Pe._override && Ue !== ce && fe(_e, Pe._override);
        }
        for (var ut = [], ot = null, dt = ae.start; dt <= ae.end; dt++) {
          var mt = F[dt];
          if (!(mt & c)) {
            var Bt = ge[dt], $t = mt & o, on = mt === K;
            ot && Bt === ot._level ? (ot._end = dt, ot._endsWithIsolInit = $t) : ut.push(ot = {
              _start: dt,
              _end: dt,
              _level: Bt,
              _startsWithPDI: on,
              _endsWithIsolInit: $t
            });
          }
        }
        for (var Rn = [], dn = 0; dn < ut.length; dn++) {
          var Un = ut[dn];
          if (!Un._startsWithPDI || Un._startsWithPDI && !xe.has(Un._start)) {
            for (var qn = [ot = Un], Ln = void 0; ot && ot._endsWithIsolInit && (Ln = xe.get(ot._end)) != null; )
              for (var wn = dn + 1; wn < ut.length; wn++)
                if (ut[wn]._start === Ln) {
                  qn.push(ot = ut[wn]);
                  break;
                }
            for (var Sn = [], Mi = 0; Mi < qn.length; Mi++)
              for (var os = qn[Mi], me = os._start; me <= os._end; me++)
                Sn.push(me);
            for (var Se = ge[Sn[0]], Oe = ae.level, $e = Sn[0] - 1; $e >= 0; $e--)
              if (!(F[$e] & c)) {
                Oe = ge[$e];
                break;
              }
            var W = Sn[Sn.length - 1], ve = ge[W], we = ae.level;
            if (!(F[W] & o)) {
              for (var Le = W + 1; Le <= ae.end; Le++)
                if (!(F[Le] & c)) {
                  we = ge[Le];
                  break;
                }
            }
            Rn.push({
              _seqIndices: Sn,
              _sosType: Math.max(Oe, Se) % 2 ? T : E,
              _eosType: Math.max(we, ve) % 2 ? T : E
            });
          }
        }
        for (var Me = 0; Me < Rn.length; Me++) {
          var We = Rn[Me], Be = We._seqIndices, st = We._sosType, lt = We._eosType, yt = ge[Be[0]] & 1 ? T : E;
          if (Y.get(q))
            for (var bt = 0; bt < Be.length; bt++) {
              var ft = Be[bt];
              if (F[ft] & q) {
                for (var Ft = st, Xt = bt - 1; Xt >= 0; Xt--)
                  if (!(F[Be[Xt]] & c)) {
                    Ft = F[Be[Xt]];
                    break;
                  }
                fe(ft, Ft & (o | K) ? V : Ft);
              }
            }
          if (Y.get(w))
            for (var qt = 0; qt < Be.length; qt++) {
              var Zn = Be[qt];
              if (F[Zn] & w)
                for (var zt = qt - 1; zt >= -1; zt--) {
                  var gt = zt === -1 ? st : F[Be[zt]];
                  if (gt & a) {
                    gt === oe && fe(Zn, U);
                    break;
                  }
                }
            }
          if (Y.get(oe))
            for (var Vi = 0; Vi < Be.length; Vi++) {
              var Vt = Be[Vi];
              F[Vt] & oe && fe(Vt, T);
            }
          if (Y.get(A) || Y.get(D))
            for (var Kn = 1; Kn < Be.length - 1; Kn++) {
              var Ds = Be[Kn];
              if (F[Ds] & (A | D)) {
                for (var zn = 0, qs = 0, en = Kn - 1; en >= 0 && (zn = F[Be[en]], !!(zn & c)); en--)
                  ;
                for (var Ci = Kn + 1; Ci < Be.length && (qs = F[Be[Ci]], !!(qs & c)); Ci++)
                  ;
                zn === qs && (F[Ds] === A ? zn === w : zn & (w | U)) && fe(Ds, zn);
              }
            }
          if (Y.get(w))
            for (var ri = 0; ri < Be.length; ri++) {
              var Ti = Be[ri];
              if (F[Ti] & w) {
                for (var Gi = ri - 1; Gi >= 0 && F[Be[Gi]] & (O | c); Gi--)
                  fe(Be[Gi], w);
                for (ri++; ri < Be.length && F[Be[ri]] & (O | c | w); ri++)
                  F[Be[ri]] !== w && fe(Be[ri], w);
              }
            }
          if (Y.get(O) || Y.get(A) || Y.get(D))
            for (var Ei = 0; Ei < Be.length; Ei++) {
              var kl = Be[Ei];
              if (F[kl] & (O | A | D)) {
                fe(kl, V);
                for (var yu = Ei - 1; yu >= 0 && F[Be[yu]] & c; yu--)
                  fe(Be[yu], V);
                for (var _u = Ei + 1; _u < Be.length && F[Be[_u]] & c; _u++)
                  fe(Be[_u], V);
              }
            }
          if (Y.get(w))
            for (var Cf = 0, Fv = st; Cf < Be.length; Cf++) {
              var Uv = Be[Cf], Tf = F[Uv];
              Tf & w ? Fv === E && fe(Uv, E) : Tf & a && (Fv = Tf);
            }
          if (Y.get(l)) {
            var Rl = T | w | U, zv = Rl | E, xu = [];
            {
              for (var la = [], ca = 0; ca < Be.length; ca++)
                if (F[Be[ca]] & l) {
                  var Ll = N[Be[ca]], Bv = void 0;
                  if (x(Ll) !== null)
                    if (la.length < 63)
                      la.push({ char: Ll, seqIndex: ca });
                    else
                      break;
                  else if ((Bv = M(Ll)) !== null)
                    for (var Il = la.length - 1; Il >= 0; Il--) {
                      var Ef = la[Il].char;
                      if (Ef === Bv || Ef === M(C(Ll)) || x(C(Ef)) === Ll) {
                        xu.push([la[Il].seqIndex, ca]), la.length = Il;
                        break;
                      }
                    }
                }
              xu.sort(function(Ai, ls) {
                return Ai[0] - ls[0];
              });
            }
            for (var Af = 0; Af < xu.length; Af++) {
              for (var Nv = xu[Af], bu = Nv[0], Pf = Nv[1], Vv = !1, as = 0, Df = bu + 1; Df < Pf; Df++) {
                var Gv = Be[Df];
                if (F[Gv] & zv) {
                  Vv = !0;
                  var Hv = F[Gv] & Rl ? T : E;
                  if (Hv === yt) {
                    as = Hv;
                    break;
                  }
                }
              }
              if (Vv && !as) {
                as = st;
                for (var kf = bu - 1; kf >= 0; kf--) {
                  var Wv = Be[kf];
                  if (F[Wv] & zv) {
                    var jv = F[Wv] & Rl ? T : E;
                    jv !== yt ? as = jv : as = yt;
                    break;
                  }
                }
              }
              if (as) {
                if (F[Be[bu]] = F[Be[Pf]] = as, as !== yt) {
                  for (var Ol = bu + 1; Ol < Be.length; Ol++)
                    if (!(F[Be[Ol]] & c)) {
                      p(N[Be[Ol]]) & q && (F[Be[Ol]] = as);
                      break;
                    }
                }
                if (as !== yt) {
                  for (var Fl = Pf + 1; Fl < Be.length; Fl++)
                    if (!(F[Be[Fl]] & c)) {
                      p(N[Be[Fl]]) & q && (F[Be[Fl]] = as);
                      break;
                    }
                }
              }
            }
            for (var Fr = 0; Fr < Be.length; Fr++)
              if (F[Be[Fr]] & l) {
                for (var $v = Fr, Rf = Fr, Lf = st, Ul = Fr - 1; Ul >= 0; Ul--)
                  if (F[Be[Ul]] & c)
                    $v = Ul;
                  else {
                    Lf = F[Be[Ul]] & Rl ? T : E;
                    break;
                  }
                for (var Xv = lt, zl = Fr + 1; zl < Be.length; zl++)
                  if (F[Be[zl]] & (l | c))
                    Rf = zl;
                  else {
                    Xv = F[Be[zl]] & Rl ? T : E;
                    break;
                  }
                for (var If = $v; If <= Rf; If++)
                  F[Be[If]] = Lf === Xv ? Lf : yt;
                Fr = Rf;
              }
          }
        }
        for (var Hi = ae.start; Hi <= ae.end; Hi++) {
          var TS = ge[Hi], wu = F[Hi];
          if (TS & 1 ? wu & (E | w | U) && ge[Hi]++ : wu & T ? ge[Hi]++ : wu & (U | w) && (ge[Hi] += 2), wu & c && (ge[Hi] = Hi === 0 ? ae.level : ge[Hi - 1]), Hi === ae.end || p(N[Hi]) & (P | L))
            for (var Su = Hi; Su >= 0 && p(N[Su]) & u; Su--)
              ge[Su] = ae.level;
        }
      }
      return {
        levels: ge,
        paragraphs: De
      };
      function Yv(Ai, ls) {
        for (var Pi = Ai; Pi < N.length; Pi++) {
          var Ur = F[Pi];
          if (Ur & (T | oe))
            return 1;
          if (Ur & (L | E) || ls && Ur === K)
            return 0;
          if (Ur & o) {
            var qv = ES(Pi);
            Pi = qv === -1 ? N.length : qv;
          }
        }
        return 0;
      }
      function ES(Ai) {
        for (var ls = 1, Pi = Ai + 1; Pi < N.length; Pi++) {
          var Ur = F[Pi];
          if (Ur & L)
            break;
          if (Ur & K) {
            if (--ls === 0)
              return Pi;
          } else Ur & o && ls++;
        }
        return -1;
      }
    }
    var R = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", z;
    function I() {
      if (!z) {
        var N = _(R, !0), j = N.map, te = N.reverseMap;
        te.forEach(function(F, B) {
          j.set(B, F);
        }), z = j;
      }
    }
    function Q(N) {
      return I(), z.get(N) || null;
    }
    function X(N, j, te, F) {
      var B = N.length;
      te = Math.max(0, te == null ? 0 : +te), F = Math.min(B - 1, F == null ? B - 1 : +F);
      for (var Y = /* @__PURE__ */ new Map(), fe = te; fe <= F; fe++)
        if (j[fe] & 1) {
          var ge = Q(N[fe]);
          ge !== null && Y.set(fe, ge);
        }
      return Y;
    }
    function k(N, j, te, F) {
      var B = N.length;
      te = Math.max(0, te == null ? 0 : +te), F = Math.min(B - 1, F == null ? B - 1 : +F);
      var Y = [];
      return j.paragraphs.forEach(function(fe) {
        var ge = Math.max(te, fe.start), xe = Math.min(F, fe.end);
        if (ge < xe) {
          for (var De = j.levels.slice(ge, xe + 1), ae = xe; ae >= ge && p(N[ae]) & u; ae--)
            De[ae] = fe.level;
          for (var de = fe.level, Ee = 1 / 0, be = 0; be < De.length; be++) {
            var ke = De[be];
            ke > de && (de = ke), ke < Ee && (Ee = ke | 1);
          }
          for (var ze = de; ze >= Ee; ze--)
            for (var Te = 0; Te < De.length; Te++)
              if (De[Te] >= ze) {
                for (var Pe = Te; Te + 1 < De.length && De[Te + 1] >= ze; )
                  Te++;
                Te > Pe && Y.push([Pe + ge, Te + ge]);
              }
        }
      }), Y;
    }
    function ee(N, j, te, F) {
      var B = Z(N, j, te, F), Y = [].concat(N);
      return B.forEach(function(fe, ge) {
        Y[ge] = (j.levels[fe] & 1 ? Q(N[fe]) : null) || N[fe];
      }), Y.join("");
    }
    function Z(N, j, te, F) {
      for (var B = k(N, j, te, F), Y = [], fe = 0; fe < N.length; fe++)
        Y[fe] = fe;
      return B.forEach(function(ge) {
        for (var xe = ge[0], De = ge[1], ae = Y.slice(xe, De + 1), de = ae.length; de--; )
          Y[De - de] = ae[de];
      }), Y;
    }
    return e.closingToOpeningBracket = M, e.getBidiCharType = p, e.getBidiCharTypeName = f, e.getCanonicalBracket = C, e.getEmbeddingLevels = G, e.getMirroredCharacter = Q, e.getMirroredCharactersMap = X, e.getReorderSegments = k, e.getReorderedIndices = Z, e.getReorderedString = ee, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return r;
}
const lS = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function vg(r) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(i, s) {
    let o = kt[s];
    return o ? vg(o) : i;
  }
  return r.replace(e, n);
}
const Jn = [];
for (let r = 0; r < 256; r++)
  Jn[r] = (r < 16 ? "0" : "") + r.toString(16);
function u7() {
  const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Jn[r & 255] + Jn[r >> 8 & 255] + Jn[r >> 16 & 255] + Jn[r >> 24 & 255] + "-" + Jn[e & 255] + Jn[e >> 8 & 255] + "-" + Jn[e >> 16 & 15 | 64] + Jn[e >> 24 & 255] + "-" + Jn[n & 63 | 128] + Jn[n >> 8 & 255] + "-" + Jn[n >> 16 & 255] + Jn[n >> 24 & 255] + Jn[i & 255] + Jn[i >> 8 & 255] + Jn[i >> 16 & 255] + Jn[i >> 24 & 255]).toUpperCase();
}
const Po = Object.assign || function() {
  let r = arguments[0];
  for (let e = 1, n = arguments.length; e < n; e++) {
    let i = arguments[e];
    if (i)
      for (let s in i)
        Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
  }
  return r;
}, h7 = Date.now(), u_ = /* @__PURE__ */ new WeakMap(), h_ = /* @__PURE__ */ new Map();
let d7 = 1e10;
function yg(r, e) {
  const n = g7(e);
  let i = u_.get(r);
  if (i || u_.set(r, i = /* @__PURE__ */ Object.create(null)), i[n])
    return new i[n]();
  const s = `_onBeforeCompile${n}`, o = function(u, h) {
    r.onBeforeCompile.call(this, u, h);
    const d = this.customProgramCacheKey() + "|" + u.vertexShader + "|" + u.fragmentShader;
    let p = h_[d];
    if (!p) {
      const f = f7(this, u, e, n);
      p = h_[d] = f;
    }
    u.vertexShader = p.vertexShader, u.fragmentShader = p.fragmentShader, Po(u.uniforms, this.uniforms), e.timeUniform && (u.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - h7;
      }
    }), this[s] && this[s](u);
  }, a = function() {
    return l(e.chained ? r : r.clone());
  }, l = function(u) {
    const h = Object.create(u, c);
    return Object.defineProperty(h, "baseMaterial", { value: r }), Object.defineProperty(h, "id", { value: d7++ }), h.uuid = u7(), h.uniforms = Po({}, u.uniforms, e.uniforms), h.defines = Po({}, u.defines, e.defines), h.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "", h.extensions = Po({}, u.extensions, e.extensions), h._listeners = void 0, h;
  }, c = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => r.type,
      set: (u) => {
        r.type = u;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        const h = this.baseMaterial;
        return u === h || h.isDerivedMaterial && h.isDerivedFrom(u) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return r.customProgramCacheKey() + "|" + n;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(u) {
        this[s] = u;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        return r.copy.call(this, u), !r.isShaderMaterial && !r.isDerivedMaterial && (Po(this.extensions, u.extensions), Po(this.defines, u.defines), Po(this.uniforms, uu.clone(u.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const u = new r.constructor();
        return l(u).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._depthMaterial;
        return u || (u = this._depthMaterial = yg(
          r.isDerivedMaterial ? r.getDepthMaterial() : new tv({ depthPacking: Xg }),
          e
        ), u.defines.IS_DEPTH_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._distanceMaterial;
        return u || (u = this._distanceMaterial = yg(
          r.isDerivedMaterial ? r.getDistanceMaterial() : new Ib(),
          e
        ), u.defines.IS_DISTANCE_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: u, _distanceMaterial: h } = this;
        u && u.dispose(), h && h.dispose(), r.dispose.call(this);
      }
    }
  };
  return i[n] = a, new a();
}
function f7(r, { vertexShader: e, fragmentShader: n }, i, s) {
  let {
    vertexDefs: o,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: c,
    fragmentDefs: u,
    fragmentMainIntro: h,
    fragmentMainOutro: d,
    fragmentColorTransform: p,
    customRewriter: f,
    timeUniform: m
  } = i;
  if (o = o || "", a = a || "", l = l || "", u = u || "", h = h || "", d = d || "", (c || f) && (e = vg(e)), (p || f) && (n = n.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), n = vg(n)), f) {
    let _ = f({ vertexShader: e, fragmentShader: n });
    e = _.vertexShader, n = _.fragmentShader;
  }
  if (p) {
    let _ = [];
    n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (_.push(g), "")
    ), d = `${p}
${_.join(`
`)}
${d}`;
  }
  if (m) {
    const _ = `
uniform float ${m};
`;
    o = _ + o, u = _ + u;
  }
  return c && (e = `vec3 troika_position_${s};
vec3 troika_normal_${s};
vec2 troika_uv_${s};
${e}
`, o = `${o}
void troikaVertexTransform${s}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, a = `
troika_position_${s} = vec3(position);
troika_normal_${s} = vec3(normal);
troika_uv_${s} = vec2(uv);
troikaVertexTransform${s}(troika_position_${s}, troika_normal_${s}, troika_uv_${s});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, g, v, S) => /\battribute\s+vec[23]\s+$/.test(S.substr(0, v)) ? g : `troika_${g}_${s}`), r.map && r.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${s}`))), e = d_(e, s, o, a, l), n = d_(n, s, u, h, d), {
    vertexShader: e,
    fragmentShader: n
  };
}
function d_(r, e, n, i, s) {
  return (i || s || n) && (r = r.replace(
    lS,
    `
${n}
void troikaOrigMain${e}() {`
  ), r += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${s}
}`), r;
}
function p7(r, e) {
  return r === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let m7 = 0;
const f_ = /* @__PURE__ */ new Map();
function g7(r) {
  const e = JSON.stringify(r, p7);
  let n = f_.get(e);
  return n == null && f_.set(e, n = ++m7), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function v7() {
  return typeof window > "u" && (self.window = self), function(r) {
    var e = { parse: function(s) {
      var o = e._bin, a = new Uint8Array(s);
      if (o.readASCII(a, 0, 4) == "ttcf") {
        var l = 4;
        o.readUshort(a, l), l += 2, o.readUshort(a, l), l += 2;
        var c = o.readUint(a, l);
        l += 4;
        for (var u = [], h = 0; h < c; h++) {
          var d = o.readUint(a, l);
          l += 4, u.push(e._readFont(a, d));
        }
        return u;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(s, o) {
      var a = e._bin, l = o;
      a.readFixed(s, o), o += 4;
      var c = a.readUshort(s, o);
      o += 2, a.readUshort(s, o), o += 2, a.readUshort(s, o), o += 2, a.readUshort(s, o), o += 2;
      for (var u = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], h = { _data: s, _offset: l }, d = {}, p = 0; p < c; p++) {
        var f = a.readASCII(s, o, 4);
        o += 4, a.readUint(s, o), o += 4;
        var m = a.readUint(s, o);
        o += 4;
        var _ = a.readUint(s, o);
        o += 4, d[f] = { offset: m, length: _ };
      }
      for (p = 0; p < u.length; p++) {
        var g = u[p];
        d[g] && (h[g.trim()] = e[g.trim()].parse(s, d[g].offset, d[g].length, h));
      }
      return h;
    }, _tabOffset: function(s, o, a) {
      for (var l = e._bin, c = l.readUshort(s, a + 4), u = a + 12, h = 0; h < c; h++) {
        var d = l.readASCII(s, u, 4);
        u += 4, l.readUint(s, u), u += 4;
        var p = l.readUint(s, u);
        if (u += 4, l.readUint(s, u), u += 4, d == o) return p;
      }
      return 0;
    } };
    e._bin = { readFixed: function(s, o) {
      return (s[o] << 8 | s[o + 1]) + (s[o + 2] << 8 | s[o + 3]) / 65540;
    }, readF2dot14: function(s, o) {
      return e._bin.readShort(s, o) / 16384;
    }, readInt: function(s, o) {
      return e._bin._view(s).getInt32(o);
    }, readInt8: function(s, o) {
      return e._bin._view(s).getInt8(o);
    }, readShort: function(s, o) {
      return e._bin._view(s).getInt16(o);
    }, readUshort: function(s, o) {
      return e._bin._view(s).getUint16(o);
    }, readUshorts: function(s, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(e._bin.readUshort(s, o + 2 * c));
      return l;
    }, readUint: function(s, o) {
      return e._bin._view(s).getUint32(o);
    }, readUint64: function(s, o) {
      return 4294967296 * e._bin.readUint(s, o) + e._bin.readUint(s, o + 4);
    }, readASCII: function(s, o, a) {
      for (var l = "", c = 0; c < a; c++) l += String.fromCharCode(s[o + c]);
      return l;
    }, readUnicode: function(s, o, a) {
      for (var l = "", c = 0; c < a; c++) {
        var u = s[o++] << 8 | s[o++];
        l += String.fromCharCode(u);
      }
      return l;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(s, o, a) {
      var l = e._bin._tdec;
      return l && o == 0 && a == s.length ? l.decode(s) : e._bin.readASCII(s, o, a);
    }, readBytes: function(s, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(s[o + c]);
      return l;
    }, readASCIIArray: function(s, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(String.fromCharCode(s[o + c]));
      return l;
    }, _view: function(s) {
      return s._dataView || (s._dataView = s.buffer ? new DataView(s.buffer, s.byteOffset, s.byteLength) : new DataView(new Uint8Array(s).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(s, o, a, l, c) {
      var u = e._bin, h = {}, d = o;
      u.readFixed(s, o), o += 4;
      var p = u.readUshort(s, o);
      o += 2;
      var f = u.readUshort(s, o);
      o += 2;
      var m = u.readUshort(s, o);
      return o += 2, h.scriptList = e._lctf.readScriptList(s, d + p), h.featureList = e._lctf.readFeatureList(s, d + f), h.lookupList = e._lctf.readLookupList(s, d + m, c), h;
    }, e._lctf.readLookupList = function(s, o, a) {
      var l = e._bin, c = o, u = [], h = l.readUshort(s, o);
      o += 2;
      for (var d = 0; d < h; d++) {
        var p = l.readUshort(s, o);
        o += 2;
        var f = e._lctf.readLookupTable(s, c + p, a);
        u.push(f);
      }
      return u;
    }, e._lctf.readLookupTable = function(s, o, a) {
      var l = e._bin, c = o, u = { tabs: [] };
      u.ltype = l.readUshort(s, o), o += 2, u.flag = l.readUshort(s, o), o += 2;
      var h = l.readUshort(s, o);
      o += 2;
      for (var d = u.ltype, p = 0; p < h; p++) {
        var f = l.readUshort(s, o);
        o += 2;
        var m = a(s, d, c + f, u);
        u.tabs.push(m);
      }
      return u;
    }, e._lctf.numOfOnes = function(s) {
      for (var o = 0, a = 0; a < 32; a++) s >>> a & 1 && o++;
      return o;
    }, e._lctf.readClassDef = function(s, o) {
      var a = e._bin, l = [], c = a.readUshort(s, o);
      if (o += 2, c == 1) {
        var u = a.readUshort(s, o);
        o += 2;
        var h = a.readUshort(s, o);
        o += 2;
        for (var d = 0; d < h; d++) l.push(u + d), l.push(u + d), l.push(a.readUshort(s, o)), o += 2;
      }
      if (c == 2) {
        var p = a.readUshort(s, o);
        for (o += 2, d = 0; d < p; d++) l.push(a.readUshort(s, o)), o += 2, l.push(a.readUshort(s, o)), o += 2, l.push(a.readUshort(s, o)), o += 2;
      }
      return l;
    }, e._lctf.getInterval = function(s, o) {
      for (var a = 0; a < s.length; a += 3) {
        var l = s[a], c = s[a + 1];
        if (s[a + 2], l <= o && o <= c) return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(s, o) {
      var a = e._bin, l = {};
      l.fmt = a.readUshort(s, o), o += 2;
      var c = a.readUshort(s, o);
      return o += 2, l.fmt == 1 && (l.tab = a.readUshorts(s, o, c)), l.fmt == 2 && (l.tab = a.readUshorts(s, o, 3 * c)), l;
    }, e._lctf.coverageIndex = function(s, o) {
      var a = s.tab;
      if (s.fmt == 1) return a.indexOf(o);
      if (s.fmt == 2) {
        var l = e._lctf.getInterval(a, o);
        if (l != -1) return a[l + 2] + (o - a[l]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(s, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readASCII(s, o, 4);
        o += 4;
        var p = a.readUshort(s, o);
        o += 2;
        var f = e._lctf.readFeatureTable(s, l + p);
        f.tag = d.trim(), c.push(f);
      }
      return c;
    }, e._lctf.readFeatureTable = function(s, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(s, o);
      o += 2, u > 0 && (c.featureParams = l + u);
      var h = a.readUshort(s, o);
      o += 2, c.tab = [];
      for (var d = 0; d < h; d++) c.tab.push(a.readUshort(s, o + 2 * d));
      return c;
    }, e._lctf.readScriptList = function(s, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readASCII(s, o, 4);
        o += 4;
        var p = a.readUshort(s, o);
        o += 2, c[d.trim()] = e._lctf.readScriptTable(s, l + p);
      }
      return c;
    }, e._lctf.readScriptTable = function(s, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(s, o);
      o += 2, u > 0 && (c.default = e._lctf.readLangSysTable(s, l + u));
      var h = a.readUshort(s, o);
      o += 2;
      for (var d = 0; d < h; d++) {
        var p = a.readASCII(s, o, 4);
        o += 4;
        var f = a.readUshort(s, o);
        o += 2, c[p.trim()] = e._lctf.readLangSysTable(s, l + f);
      }
      return c;
    }, e._lctf.readLangSysTable = function(s, o) {
      var a = e._bin, l = {};
      a.readUshort(s, o), o += 2, l.reqFeature = a.readUshort(s, o), o += 2;
      var c = a.readUshort(s, o);
      return o += 2, l.features = a.readUshorts(s, o, c), l;
    }, e.CFF = {}, e.CFF.parse = function(s, o, a) {
      var l = e._bin;
      (s = new Uint8Array(s.buffer, o, a))[o = 0], s[++o], s[++o], s[++o], o++;
      var c = [];
      o = e.CFF.readIndex(s, o, c);
      for (var u = [], h = 0; h < c.length - 1; h++) u.push(l.readASCII(s, o + c[h], c[h + 1] - c[h]));
      o += c[c.length - 1];
      var d = [];
      o = e.CFF.readIndex(s, o, d);
      var p = [];
      for (h = 0; h < d.length - 1; h++) p.push(e.CFF.readDict(s, o + d[h], o + d[h + 1]));
      o += d[d.length - 1];
      var f = p[0], m = [];
      o = e.CFF.readIndex(s, o, m);
      var _ = [];
      for (h = 0; h < m.length - 1; h++) _.push(l.readASCII(s, o + m[h], m[h + 1] - m[h]));
      if (o += m[m.length - 1], e.CFF.readSubrs(s, o, f), f.CharStrings) {
        o = f.CharStrings, m = [], o = e.CFF.readIndex(s, o, m);
        var g = [];
        for (h = 0; h < m.length - 1; h++) g.push(l.readBytes(s, o + m[h], m[h + 1] - m[h]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        o = f.FDArray;
        var v = [];
        for (o = e.CFF.readIndex(s, o, v), f.FDArray = [], h = 0; h < v.length - 1; h++) {
          var S = e.CFF.readDict(s, o + v[h], o + v[h + 1]);
          e.CFF._readFDict(s, S, _), f.FDArray.push(S);
        }
        o += v[v.length - 1], o = f.FDSelect, f.FDSelect = [];
        var b = s[o];
        if (o++, b != 3) throw b;
        var x = l.readUshort(s, o);
        for (o += 2, h = 0; h < x + 1; h++) f.FDSelect.push(l.readUshort(s, o), s[o + 2]), o += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(s, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(s, f.charset, f.CharStrings.length)), e.CFF._readFDict(s, f, _), f;
    }, e.CFF._readFDict = function(s, o, a) {
      var l;
      for (var c in o.Private && (l = o.Private[1], o.Private = e.CFF.readDict(s, l, l + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(s, l + o.Private.Subrs, o.Private)), o) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (o[c] = a[o[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(s, o, a) {
      var l = e._bin, c = [];
      o = e.CFF.readIndex(s, o, c);
      var u, h = c.length;
      u = h < 1240 ? 107 : h < 33900 ? 1131 : 32768, a.Bias = u, a.Subrs = [];
      for (var d = 0; d < c.length - 1; d++) a.Subrs.push(l.readBytes(s, o + c[d], c[d + 1] - c[d]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(s, o) {
      for (var a = 0; a < s.charset.length; a++) if (s.charset[a] == o) return a;
      return -1;
    }, e.CFF.glyphBySE = function(s, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(s, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(s, o, a) {
      e._bin;
      var l = [".notdef"], c = s[o];
      if (o++, c != 0) throw "error: unknown encoding format: " + c;
      var u = s[o];
      o++;
      for (var h = 0; h < u; h++) l.push(s[o + h]);
      return l;
    }, e.CFF.readCharset = function(s, o, a) {
      var l = e._bin, c = [".notdef"], u = s[o];
      if (o++, u == 0) for (var h = 0; h < a; h++) {
        var d = l.readUshort(s, o);
        o += 2, c.push(d);
      }
      else {
        if (u != 1 && u != 2) throw "error: format: " + u;
        for (; c.length < a; ) {
          d = l.readUshort(s, o), o += 2;
          var p = 0;
          for (u == 1 ? (p = s[o], o++) : (p = l.readUshort(s, o), o += 2), h = 0; h <= p; h++) c.push(d), d++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(s, o, a) {
      var l = e._bin, c = l.readUshort(s, o) + 1, u = s[o += 2];
      if (o++, u == 1) for (var h = 0; h < c; h++) a.push(s[o + h]);
      else if (u == 2) for (h = 0; h < c; h++) a.push(l.readUshort(s, o + 2 * h));
      else if (u == 3) for (h = 0; h < c; h++) a.push(16777215 & l.readUint(s, o + 3 * h - 1));
      else if (c != 1) throw "unsupported offset size: " + u + ", count: " + c;
      return (o += c * u) - 1;
    }, e.CFF.getCharString = function(s, o, a) {
      var l = e._bin, c = s[o], u = s[o + 1];
      s[o + 2], s[o + 3], s[o + 4];
      var h = 1, d = null, p = null;
      c <= 20 && (d = c, h = 1), c == 12 && (d = 100 * c + u, h = 2), 21 <= c && c <= 27 && (d = c, h = 1), c == 28 && (p = l.readShort(s, o + 1), h = 3), 29 <= c && c <= 31 && (d = c, h = 1), 32 <= c && c <= 246 && (p = c - 139, h = 1), 247 <= c && c <= 250 && (p = 256 * (c - 247) + u + 108, h = 2), 251 <= c && c <= 254 && (p = 256 * -(c - 251) - u - 108, h = 2), c == 255 && (p = l.readInt(s, o + 1) / 65535, h = 5), a.val = p ?? "o" + d, a.size = h;
    }, e.CFF.readCharString = function(s, o, a) {
      for (var l = o + a, c = e._bin, u = []; o < l; ) {
        var h = s[o], d = s[o + 1];
        s[o + 2], s[o + 3], s[o + 4];
        var p = 1, f = null, m = null;
        h <= 20 && (f = h, p = 1), h == 12 && (f = 100 * h + d, p = 2), h != 19 && h != 20 || (f = h, p = 2), 21 <= h && h <= 27 && (f = h, p = 1), h == 28 && (m = c.readShort(s, o + 1), p = 3), 29 <= h && h <= 31 && (f = h, p = 1), 32 <= h && h <= 246 && (m = h - 139, p = 1), 247 <= h && h <= 250 && (m = 256 * (h - 247) + d + 108, p = 2), 251 <= h && h <= 254 && (m = 256 * -(h - 251) - d - 108, p = 2), h == 255 && (m = c.readInt(s, o + 1) / 65535, p = 5), u.push(m ?? "o" + f), o += p;
      }
      return u;
    }, e.CFF.readDict = function(s, o, a) {
      for (var l = e._bin, c = {}, u = []; o < a; ) {
        var h = s[o], d = s[o + 1];
        s[o + 2], s[o + 3], s[o + 4];
        var p = 1, f = null, m = null;
        if (h == 28 && (m = l.readShort(s, o + 1), p = 3), h == 29 && (m = l.readInt(s, o + 1), p = 5), 32 <= h && h <= 246 && (m = h - 139, p = 1), 247 <= h && h <= 250 && (m = 256 * (h - 247) + d + 108, p = 2), 251 <= h && h <= 254 && (m = 256 * -(h - 251) - d - 108, p = 2), h == 255) throw m = l.readInt(s, o + 1) / 65535, p = 5, "unknown number";
        if (h == 30) {
          var _ = [];
          for (p = 1; ; ) {
            var g = s[o + p];
            p++;
            var v = g >> 4, S = 15 & g;
            if (v != 15 && _.push(v), S != 15 && _.push(S), S == 15) break;
          }
          for (var b = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], M = 0; M < _.length; M++) b += x[_[M]];
          m = parseFloat(b);
        }
        h <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][h], p = 1, h == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][d], p = 2)), f != null ? (c[f] = u.length == 1 ? u[0] : u, u = []) : u.push(m), o += p;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(s, o, a) {
      s = new Uint8Array(s.buffer, o, a), o = 0;
      var l = e._bin, c = {};
      l.readUshort(s, o), o += 2;
      var u = l.readUshort(s, o);
      o += 2;
      var h = [];
      c.tables = [];
      for (var d = 0; d < u; d++) {
        var p = l.readUshort(s, o);
        o += 2;
        var f = l.readUshort(s, o);
        o += 2;
        var m = l.readUint(s, o);
        o += 4;
        var _ = "p" + p + "e" + f, g = h.indexOf(m);
        if (g == -1) {
          var v;
          g = c.tables.length, h.push(m);
          var S = l.readUshort(s, m);
          S == 0 ? v = e.cmap.parse0(s, m) : S == 4 ? v = e.cmap.parse4(s, m) : S == 6 ? v = e.cmap.parse6(s, m) : S == 12 ? v = e.cmap.parse12(s, m) : console.debug("unknown format: " + S, p, f, m), c.tables.push(v);
        }
        if (c[_] != null) throw "multiple tables for one platform+encoding";
        c[_] = g;
      }
      return c;
    }, e.cmap.parse0 = function(s, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(s, o), o += 2;
      var c = a.readUshort(s, o);
      o += 2, a.readUshort(s, o), o += 2, l.map = [];
      for (var u = 0; u < c - 6; u++) l.map.push(s[o + u]);
      return l;
    }, e.cmap.parse4 = function(s, o) {
      var a = e._bin, l = o, c = {};
      c.format = a.readUshort(s, o), o += 2;
      var u = a.readUshort(s, o);
      o += 2, a.readUshort(s, o), o += 2;
      var h = a.readUshort(s, o);
      o += 2;
      var d = h / 2;
      c.searchRange = a.readUshort(s, o), o += 2, c.entrySelector = a.readUshort(s, o), o += 2, c.rangeShift = a.readUshort(s, o), o += 2, c.endCount = a.readUshorts(s, o, d), o += 2 * d, o += 2, c.startCount = a.readUshorts(s, o, d), o += 2 * d, c.idDelta = [];
      for (var p = 0; p < d; p++) c.idDelta.push(a.readShort(s, o)), o += 2;
      for (c.idRangeOffset = a.readUshorts(s, o, d), o += 2 * d, c.glyphIdArray = []; o < l + u; ) c.glyphIdArray.push(a.readUshort(s, o)), o += 2;
      return c;
    }, e.cmap.parse6 = function(s, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(s, o), o += 2, a.readUshort(s, o), o += 2, a.readUshort(s, o), o += 2, l.firstCode = a.readUshort(s, o), o += 2;
      var c = a.readUshort(s, o);
      o += 2, l.glyphIdArray = [];
      for (var u = 0; u < c; u++) l.glyphIdArray.push(a.readUshort(s, o)), o += 2;
      return l;
    }, e.cmap.parse12 = function(s, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(s, o), o += 2, o += 2, a.readUint(s, o), o += 4, a.readUint(s, o), o += 4;
      var c = a.readUint(s, o);
      o += 4, l.groups = [];
      for (var u = 0; u < c; u++) {
        var h = o + 12 * u, d = a.readUint(s, h + 0), p = a.readUint(s, h + 4), f = a.readUint(s, h + 8);
        l.groups.push([d, p, f]);
      }
      return l;
    }, e.glyf = {}, e.glyf.parse = function(s, o, a, l) {
      for (var c = [], u = 0; u < l.maxp.numGlyphs; u++) c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(s, o) {
      var a = e._bin, l = s._data, c = e._tabOffset(l, "glyf", s._offset) + s.loca[o];
      if (s.loca[o] == s.loca[o + 1]) return null;
      var u = {};
      if (u.noc = a.readShort(l, c), c += 2, u.xMin = a.readShort(l, c), c += 2, u.yMin = a.readShort(l, c), c += 2, u.xMax = a.readShort(l, c), c += 2, u.yMax = a.readShort(l, c), c += 2, u.xMin >= u.xMax || u.yMin >= u.yMax) return null;
      if (u.noc > 0) {
        u.endPts = [];
        for (var h = 0; h < u.noc; h++) u.endPts.push(a.readUshort(l, c)), c += 2;
        var d = a.readUshort(l, c);
        if (c += 2, l.length - c < d) return null;
        u.instructions = a.readBytes(l, c, d), c += d;
        var p = u.endPts[u.noc - 1] + 1;
        for (u.flags = [], h = 0; h < p; h++) {
          var f = l[c];
          if (c++, u.flags.push(f), (8 & f) != 0) {
            var m = l[c];
            c++;
            for (var _ = 0; _ < m; _++) u.flags.push(f), h++;
          }
        }
        for (u.xs = [], h = 0; h < p; h++) {
          var g = (2 & u.flags[h]) != 0, v = (16 & u.flags[h]) != 0;
          g ? (u.xs.push(v ? l[c] : -l[c]), c++) : v ? u.xs.push(0) : (u.xs.push(a.readShort(l, c)), c += 2);
        }
        for (u.ys = [], h = 0; h < p; h++)
          g = (4 & u.flags[h]) != 0, v = (32 & u.flags[h]) != 0, g ? (u.ys.push(v ? l[c] : -l[c]), c++) : v ? u.ys.push(0) : (u.ys.push(a.readShort(l, c)), c += 2);
        var S = 0, b = 0;
        for (h = 0; h < p; h++) S += u.xs[h], b += u.ys[h], u.xs[h] = S, u.ys[h] = b;
      } else {
        var x;
        u.parts = [];
        do {
          x = a.readUshort(l, c), c += 2;
          var M = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (u.parts.push(M), M.glyphIndex = a.readUshort(l, c), c += 2, 1 & x) {
            var C = a.readShort(l, c);
            c += 2;
            var E = a.readShort(l, c);
            c += 2;
          } else
            C = a.readInt8(l, c), c++, E = a.readInt8(l, c), c++;
          2 & x ? (M.m.tx = C, M.m.ty = E) : (M.p1 = C, M.p2 = E), 8 & x ? (M.m.a = M.m.d = a.readF2dot14(l, c), c += 2) : 64 & x ? (M.m.a = a.readF2dot14(l, c), c += 2, M.m.d = a.readF2dot14(l, c), c += 2) : 128 & x && (M.m.a = a.readF2dot14(l, c), c += 2, M.m.b = a.readF2dot14(l, c), c += 2, M.m.c = a.readF2dot14(l, c), c += 2, M.m.d = a.readF2dot14(l, c), c += 2);
        } while (32 & x);
        if (256 & x) {
          var T = a.readUshort(l, c);
          for (c += 2, u.instr = [], h = 0; h < T; h++) u.instr.push(l[c]), c++;
        }
      }
      return u;
    }, e.GDEF = {}, e.GDEF.parse = function(s, o, a, l) {
      var c = o;
      o += 4;
      var u = e._bin.readUshort(s, o);
      return { glyphClassDef: u === 0 ? null : e._lctf.readClassDef(s, c + u) };
    }, e.GPOS = {}, e.GPOS.parse = function(s, o, a, l) {
      return e._lctf.parse(s, o, a, l, e.GPOS.subt);
    }, e.GPOS.subt = function(s, o, a, l) {
      var c = e._bin, u = a, h = {};
      if (h.fmt = c.readUshort(s, a), a += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && h.fmt <= 2) {
        var d = c.readUshort(s, a);
        a += 2, h.coverage = e._lctf.readCoverage(s, d + u);
      }
      if (o == 1 && h.fmt == 1) {
        var p = c.readUshort(s, a);
        a += 2, p != 0 && (h.pos = e.GPOS.readValueRecord(s, a, p));
      } else if (o == 2 && h.fmt >= 1 && h.fmt <= 2) {
        p = c.readUshort(s, a), a += 2;
        var f = c.readUshort(s, a);
        a += 2;
        var m = e._lctf.numOfOnes(p), _ = e._lctf.numOfOnes(f);
        if (h.fmt == 1) {
          h.pairsets = [];
          var g = c.readUshort(s, a);
          a += 2;
          for (var v = 0; v < g; v++) {
            var S = u + c.readUshort(s, a);
            a += 2;
            var b = c.readUshort(s, S);
            S += 2;
            for (var x = [], M = 0; M < b; M++) {
              var C = c.readUshort(s, S);
              S += 2, p != 0 && (U = e.GPOS.readValueRecord(s, S, p), S += 2 * m), f != 0 && (D = e.GPOS.readValueRecord(s, S, f), S += 2 * _), x.push({ gid2: C, val1: U, val2: D });
            }
            h.pairsets.push(x);
          }
        }
        if (h.fmt == 2) {
          var E = c.readUshort(s, a);
          a += 2;
          var T = c.readUshort(s, a);
          a += 2;
          var w = c.readUshort(s, a);
          a += 2;
          var A = c.readUshort(s, a);
          for (a += 2, h.classDef1 = e._lctf.readClassDef(s, u + E), h.classDef2 = e._lctf.readClassDef(s, u + T), h.matrix = [], v = 0; v < w; v++) {
            var O = [];
            for (M = 0; M < A; M++) {
              var U = null, D = null;
              p != 0 && (U = e.GPOS.readValueRecord(s, a, p), a += 2 * m), f != 0 && (D = e.GPOS.readValueRecord(s, a, f), a += 2 * _), O.push({ val1: U, val2: D });
            }
            h.matrix.push(O);
          }
        }
      } else if (o == 4 && h.fmt == 1) h.markCoverage = e._lctf.readCoverage(s, c.readUshort(s, a) + u), h.baseCoverage = e._lctf.readCoverage(s, c.readUshort(s, a + 2) + u), h.markClassCount = c.readUshort(s, a + 4), h.markArray = e.GPOS.readMarkArray(s, c.readUshort(s, a + 6) + u), h.baseArray = e.GPOS.readBaseArray(s, c.readUshort(s, a + 8) + u, h.markClassCount);
      else if (o == 6 && h.fmt == 1) h.mark1Coverage = e._lctf.readCoverage(s, c.readUshort(s, a) + u), h.mark2Coverage = e._lctf.readCoverage(s, c.readUshort(s, a + 2) + u), h.markClassCount = c.readUshort(s, a + 4), h.mark1Array = e.GPOS.readMarkArray(s, c.readUshort(s, a + 6) + u), h.mark2Array = e.GPOS.readBaseArray(s, c.readUshort(s, a + 8) + u, h.markClassCount);
      else {
        if (o == 9 && h.fmt == 1) {
          var L = c.readUshort(s, a);
          a += 2;
          var P = c.readUint(s, a);
          if (a += 4, l.ltype == 9) l.ltype = L;
          else if (l.ltype != L) throw "invalid extension substitution";
          return e.GPOS.subt(s, l.ltype, u + P);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", h.fmt);
      }
      return h;
    }, e.GPOS.readValueRecord = function(s, o, a) {
      var l = e._bin, c = [];
      return c.push(1 & a ? l.readShort(s, o) : 0), o += 1 & a ? 2 : 0, c.push(2 & a ? l.readShort(s, o) : 0), o += 2 & a ? 2 : 0, c.push(4 & a ? l.readShort(s, o) : 0), o += 4 & a ? 2 : 0, c.push(8 & a ? l.readShort(s, o) : 0), o += 8 & a ? 2 : 0, c;
    }, e.GPOS.readBaseArray = function(s, o, a) {
      var l = e._bin, c = [], u = o, h = l.readUshort(s, o);
      o += 2;
      for (var d = 0; d < h; d++) {
        for (var p = [], f = 0; f < a; f++) p.push(e.GPOS.readAnchorRecord(s, u + l.readUshort(s, o))), o += 2;
        c.push(p);
      }
      return c;
    }, e.GPOS.readMarkArray = function(s, o) {
      var a = e._bin, l = [], c = o, u = a.readUshort(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = e.GPOS.readAnchorRecord(s, a.readUshort(s, o + 2) + c);
        d.markClass = a.readUshort(s, o), l.push(d), o += 4;
      }
      return l;
    }, e.GPOS.readAnchorRecord = function(s, o) {
      var a = e._bin, l = {};
      return l.fmt = a.readUshort(s, o), l.x = a.readShort(s, o + 2), l.y = a.readShort(s, o + 4), l;
    }, e.GSUB = {}, e.GSUB.parse = function(s, o, a, l) {
      return e._lctf.parse(s, o, a, l, e.GSUB.subt);
    }, e.GSUB.subt = function(s, o, a, l) {
      var c = e._bin, u = a, h = {};
      if (h.fmt = c.readUshort(s, a), a += 2, o != 1 && o != 2 && o != 4 && o != 5 && o != 6) return null;
      if (o == 1 || o == 2 || o == 4 || o == 5 && h.fmt <= 2 || o == 6 && h.fmt <= 2) {
        var d = c.readUshort(s, a);
        a += 2, h.coverage = e._lctf.readCoverage(s, u + d);
      }
      if (o == 1 && h.fmt >= 1 && h.fmt <= 2) {
        if (h.fmt == 1) h.delta = c.readShort(s, a), a += 2;
        else if (h.fmt == 2) {
          var p = c.readUshort(s, a);
          a += 2, h.newg = c.readUshorts(s, a, p), a += 2 * h.newg.length;
        }
      } else if (o == 2 && h.fmt == 1) {
        p = c.readUshort(s, a), a += 2, h.seqs = [];
        for (var f = 0; f < p; f++) {
          var m = c.readUshort(s, a) + u;
          a += 2;
          var _ = c.readUshort(s, m);
          h.seqs.push(c.readUshorts(s, m + 2, _));
        }
      } else if (o == 4)
        for (h.vals = [], p = c.readUshort(s, a), a += 2, f = 0; f < p; f++) {
          var g = c.readUshort(s, a);
          a += 2, h.vals.push(e.GSUB.readLigatureSet(s, u + g));
        }
      else if (o == 5 && h.fmt == 2) {
        if (h.fmt == 2) {
          var v = c.readUshort(s, a);
          a += 2, h.cDef = e._lctf.readClassDef(s, u + v), h.scset = [];
          var S = c.readUshort(s, a);
          for (a += 2, f = 0; f < S; f++) {
            var b = c.readUshort(s, a);
            a += 2, h.scset.push(b == 0 ? null : e.GSUB.readSubClassSet(s, u + b));
          }
        }
      } else if (o == 6 && h.fmt == 3) {
        if (h.fmt == 3) {
          for (f = 0; f < 3; f++) {
            p = c.readUshort(s, a), a += 2;
            for (var x = [], M = 0; M < p; M++) x.push(e._lctf.readCoverage(s, u + c.readUshort(s, a + 2 * M)));
            a += 2 * p, f == 0 && (h.backCvg = x), f == 1 && (h.inptCvg = x), f == 2 && (h.ahedCvg = x);
          }
          p = c.readUshort(s, a), a += 2, h.lookupRec = e.GSUB.readSubstLookupRecords(s, a, p);
        }
      } else {
        if (o == 7 && h.fmt == 1) {
          var C = c.readUshort(s, a);
          a += 2;
          var E = c.readUint(s, a);
          if (a += 4, l.ltype == 9) l.ltype = C;
          else if (l.ltype != C) throw "invalid extension substitution";
          return e.GSUB.subt(s, l.ltype, u + E);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", h.fmt);
      }
      return h;
    }, e.GSUB.readSubClassSet = function(s, o) {
      var a = e._bin.readUshort, l = o, c = [], u = a(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = a(s, o);
        o += 2, c.push(e.GSUB.readSubClassRule(s, l + d));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(s, o) {
      var a = e._bin.readUshort, l = {}, c = a(s, o), u = a(s, o += 2);
      o += 2, l.input = [];
      for (var h = 0; h < c - 1; h++) l.input.push(a(s, o)), o += 2;
      return l.substLookupRecords = e.GSUB.readSubstLookupRecords(s, o, u), l;
    }, e.GSUB.readSubstLookupRecords = function(s, o, a) {
      for (var l = e._bin.readUshort, c = [], u = 0; u < a; u++) c.push(l(s, o), l(s, o + 2)), o += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(s, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readUshort(s, o);
        o += 2, c.push(e.GSUB.readChainSubClassRule(s, l + d));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(s, o) {
      for (var a = e._bin, l = {}, c = ["backtrack", "input", "lookahead"], u = 0; u < c.length; u++) {
        var h = a.readUshort(s, o);
        o += 2, u == 1 && h--, l[c[u]] = a.readUshorts(s, o, h), o += 2 * l[c[u]].length;
      }
      return h = a.readUshort(s, o), o += 2, l.subst = a.readUshorts(s, o, 2 * h), o += 2 * l.subst.length, l;
    }, e.GSUB.readLigatureSet = function(s, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(s, o);
      o += 2;
      for (var h = 0; h < u; h++) {
        var d = a.readUshort(s, o);
        o += 2, c.push(e.GSUB.readLigature(s, l + d));
      }
      return c;
    }, e.GSUB.readLigature = function(s, o) {
      var a = e._bin, l = { chain: [] };
      l.nglyph = a.readUshort(s, o), o += 2;
      var c = a.readUshort(s, o);
      o += 2;
      for (var u = 0; u < c - 1; u++) l.chain.push(a.readUshort(s, o)), o += 2;
      return l;
    }, e.head = {}, e.head.parse = function(s, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(s, o), o += 4, c.fontRevision = l.readFixed(s, o), o += 4, l.readUint(s, o), o += 4, l.readUint(s, o), o += 4, c.flags = l.readUshort(s, o), o += 2, c.unitsPerEm = l.readUshort(s, o), o += 2, c.created = l.readUint64(s, o), o += 8, c.modified = l.readUint64(s, o), o += 8, c.xMin = l.readShort(s, o), o += 2, c.yMin = l.readShort(s, o), o += 2, c.xMax = l.readShort(s, o), o += 2, c.yMax = l.readShort(s, o), o += 2, c.macStyle = l.readUshort(s, o), o += 2, c.lowestRecPPEM = l.readUshort(s, o), o += 2, c.fontDirectionHint = l.readShort(s, o), o += 2, c.indexToLocFormat = l.readShort(s, o), o += 2, c.glyphDataFormat = l.readShort(s, o), o += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(s, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(s, o), o += 4, c.ascender = l.readShort(s, o), o += 2, c.descender = l.readShort(s, o), o += 2, c.lineGap = l.readShort(s, o), o += 2, c.advanceWidthMax = l.readUshort(s, o), o += 2, c.minLeftSideBearing = l.readShort(s, o), o += 2, c.minRightSideBearing = l.readShort(s, o), o += 2, c.xMaxExtent = l.readShort(s, o), o += 2, c.caretSlopeRise = l.readShort(s, o), o += 2, c.caretSlopeRun = l.readShort(s, o), o += 2, c.caretOffset = l.readShort(s, o), o += 2, o += 8, c.metricDataFormat = l.readShort(s, o), o += 2, c.numberOfHMetrics = l.readUshort(s, o), o += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(s, o, a, l) {
      for (var c = e._bin, u = { aWidth: [], lsBearing: [] }, h = 0, d = 0, p = 0; p < l.maxp.numGlyphs; p++) p < l.hhea.numberOfHMetrics && (h = c.readUshort(s, o), o += 2, d = c.readShort(s, o), o += 2), u.aWidth.push(h), u.lsBearing.push(d);
      return u;
    }, e.kern = {}, e.kern.parse = function(s, o, a, l) {
      var c = e._bin, u = c.readUshort(s, o);
      if (o += 2, u == 1) return e.kern.parseV1(s, o - 2, a, l);
      var h = c.readUshort(s, o);
      o += 2;
      for (var d = { glyph1: [], rval: [] }, p = 0; p < h; p++) {
        o += 2, a = c.readUshort(s, o), o += 2;
        var f = c.readUshort(s, o);
        o += 2;
        var m = f >>> 8;
        if ((m &= 15) != 0) throw "unknown kern table format: " + m;
        o = e.kern.readFormat0(s, o, d);
      }
      return d;
    }, e.kern.parseV1 = function(s, o, a, l) {
      var c = e._bin;
      c.readFixed(s, o), o += 4;
      var u = c.readUint(s, o);
      o += 4;
      for (var h = { glyph1: [], rval: [] }, d = 0; d < u; d++) {
        c.readUint(s, o), o += 4;
        var p = c.readUshort(s, o);
        o += 2, c.readUshort(s, o), o += 2;
        var f = p >>> 8;
        if ((f &= 15) != 0) throw "unknown kern table format: " + f;
        o = e.kern.readFormat0(s, o, h);
      }
      return h;
    }, e.kern.readFormat0 = function(s, o, a) {
      var l = e._bin, c = -1, u = l.readUshort(s, o);
      o += 2, l.readUshort(s, o), o += 2, l.readUshort(s, o), o += 2, l.readUshort(s, o), o += 2;
      for (var h = 0; h < u; h++) {
        var d = l.readUshort(s, o);
        o += 2;
        var p = l.readUshort(s, o);
        o += 2;
        var f = l.readShort(s, o);
        o += 2, d != c && (a.glyph1.push(d), a.rval.push({ glyph2: [], vals: [] }));
        var m = a.rval[a.rval.length - 1];
        m.glyph2.push(p), m.vals.push(f), c = d;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(s, o, a, l) {
      var c = e._bin, u = [], h = l.head.indexToLocFormat, d = l.maxp.numGlyphs + 1;
      if (h == 0) for (var p = 0; p < d; p++) u.push(c.readUshort(s, o + (p << 1)) << 1);
      if (h == 1) for (p = 0; p < d; p++) u.push(c.readUint(s, o + (p << 2)));
      return u;
    }, e.maxp = {}, e.maxp.parse = function(s, o, a) {
      var l = e._bin, c = {}, u = l.readUint(s, o);
      return o += 4, c.numGlyphs = l.readUshort(s, o), o += 2, u == 65536 && (c.maxPoints = l.readUshort(s, o), o += 2, c.maxContours = l.readUshort(s, o), o += 2, c.maxCompositePoints = l.readUshort(s, o), o += 2, c.maxCompositeContours = l.readUshort(s, o), o += 2, c.maxZones = l.readUshort(s, o), o += 2, c.maxTwilightPoints = l.readUshort(s, o), o += 2, c.maxStorage = l.readUshort(s, o), o += 2, c.maxFunctionDefs = l.readUshort(s, o), o += 2, c.maxInstructionDefs = l.readUshort(s, o), o += 2, c.maxStackElements = l.readUshort(s, o), o += 2, c.maxSizeOfInstructions = l.readUshort(s, o), o += 2, c.maxComponentElements = l.readUshort(s, o), o += 2, c.maxComponentDepth = l.readUshort(s, o), o += 2), c;
    }, e.name = {}, e.name.parse = function(s, o, a) {
      var l = e._bin, c = {};
      l.readUshort(s, o), o += 2;
      var u = l.readUshort(s, o);
      o += 2, l.readUshort(s, o);
      for (var h, d = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], p = o += 2, f = 0; f < u; f++) {
        var m = l.readUshort(s, o);
        o += 2;
        var _ = l.readUshort(s, o);
        o += 2;
        var g = l.readUshort(s, o);
        o += 2;
        var v = l.readUshort(s, o);
        o += 2;
        var S = l.readUshort(s, o);
        o += 2;
        var b = l.readUshort(s, o);
        o += 2;
        var x, M = d[v], C = p + 12 * u + b;
        if (m == 0) x = l.readUnicode(s, C, S / 2);
        else if (m == 3 && _ == 0) x = l.readUnicode(s, C, S / 2);
        else if (_ == 0) x = l.readASCII(s, C, S);
        else if (_ == 1) x = l.readUnicode(s, C, S / 2);
        else if (_ == 3) x = l.readUnicode(s, C, S / 2);
        else {
          if (m != 1) throw "unknown encoding " + _ + ", platformID: " + m;
          x = l.readASCII(s, C, S), console.debug("reading unknown MAC encoding " + _ + " as ASCII");
        }
        var E = "p" + m + "," + g.toString(16);
        c[E] == null && (c[E] = {}), c[E][M !== void 0 ? M : v] = x, c[E]._lang = g;
      }
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 1033) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 0) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 3084) return c[T];
      for (var T in c) if (c[T].postScriptName != null) return c[T];
      for (var T in c) {
        h = T;
        break;
      }
      return console.debug("returning name table with languageID " + c[h]._lang), c[h];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(s, o, a) {
      var l = e._bin.readUshort(s, o);
      o += 2;
      var c = {};
      if (l == 0) e["OS/2"].version0(s, o, c);
      else if (l == 1) e["OS/2"].version1(s, o, c);
      else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(s, o, c);
      else {
        if (l != 5) throw "unknown OS/2 table version: " + l;
        e["OS/2"].version5(s, o, c);
      }
      return c;
    }, e["OS/2"].version0 = function(s, o, a) {
      var l = e._bin;
      return a.xAvgCharWidth = l.readShort(s, o), o += 2, a.usWeightClass = l.readUshort(s, o), o += 2, a.usWidthClass = l.readUshort(s, o), o += 2, a.fsType = l.readUshort(s, o), o += 2, a.ySubscriptXSize = l.readShort(s, o), o += 2, a.ySubscriptYSize = l.readShort(s, o), o += 2, a.ySubscriptXOffset = l.readShort(s, o), o += 2, a.ySubscriptYOffset = l.readShort(s, o), o += 2, a.ySuperscriptXSize = l.readShort(s, o), o += 2, a.ySuperscriptYSize = l.readShort(s, o), o += 2, a.ySuperscriptXOffset = l.readShort(s, o), o += 2, a.ySuperscriptYOffset = l.readShort(s, o), o += 2, a.yStrikeoutSize = l.readShort(s, o), o += 2, a.yStrikeoutPosition = l.readShort(s, o), o += 2, a.sFamilyClass = l.readShort(s, o), o += 2, a.panose = l.readBytes(s, o, 10), o += 10, a.ulUnicodeRange1 = l.readUint(s, o), o += 4, a.ulUnicodeRange2 = l.readUint(s, o), o += 4, a.ulUnicodeRange3 = l.readUint(s, o), o += 4, a.ulUnicodeRange4 = l.readUint(s, o), o += 4, a.achVendID = [l.readInt8(s, o), l.readInt8(s, o + 1), l.readInt8(s, o + 2), l.readInt8(s, o + 3)], o += 4, a.fsSelection = l.readUshort(s, o), o += 2, a.usFirstCharIndex = l.readUshort(s, o), o += 2, a.usLastCharIndex = l.readUshort(s, o), o += 2, a.sTypoAscender = l.readShort(s, o), o += 2, a.sTypoDescender = l.readShort(s, o), o += 2, a.sTypoLineGap = l.readShort(s, o), o += 2, a.usWinAscent = l.readUshort(s, o), o += 2, a.usWinDescent = l.readUshort(s, o), o += 2;
    }, e["OS/2"].version1 = function(s, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version0(s, o, a), a.ulCodePageRange1 = l.readUint(s, o), o += 4, a.ulCodePageRange2 = l.readUint(s, o), o += 4;
    }, e["OS/2"].version2 = function(s, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version1(s, o, a), a.sxHeight = l.readShort(s, o), o += 2, a.sCapHeight = l.readShort(s, o), o += 2, a.usDefault = l.readUshort(s, o), o += 2, a.usBreak = l.readUshort(s, o), o += 2, a.usMaxContext = l.readUshort(s, o), o += 2;
    }, e["OS/2"].version5 = function(s, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version2(s, o, a), a.usLowerOpticalPointSize = l.readUshort(s, o), o += 2, a.usUpperOpticalPointSize = l.readUshort(s, o), o += 2;
    }, e.post = {}, e.post.parse = function(s, o, a) {
      var l = e._bin, c = {};
      return c.version = l.readFixed(s, o), o += 4, c.italicAngle = l.readFixed(s, o), o += 4, c.underlinePosition = l.readShort(s, o), o += 2, c.underlineThickness = l.readShort(s, o), o += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(s, o) {
      var a = s.cmap, l = -1;
      if (a.p0e4 != null ? l = a.p0e4 : a.p3e1 != null ? l = a.p3e1 : a.p1e0 != null ? l = a.p1e0 : a.p0e3 != null && (l = a.p0e3), l == -1) throw "no familiar platform and encoding!";
      var c = a.tables[l];
      if (c.format == 0) return o >= c.map.length ? 0 : c.map[o];
      if (c.format == 4) {
        for (var u = -1, h = 0; h < c.endCount.length; h++) if (o <= c.endCount[h]) {
          u = h;
          break;
        }
        return u == -1 || c.startCount[u] > o ? 0 : 65535 & (c.idRangeOffset[u] != 0 ? c.glyphIdArray[o - c.startCount[u] + (c.idRangeOffset[u] >> 1) - (c.idRangeOffset.length - u)] : o + c.idDelta[u]);
      }
      if (c.format == 12) {
        if (o > c.groups[c.groups.length - 1][1]) return 0;
        for (h = 0; h < c.groups.length; h++) {
          var d = c.groups[h];
          if (d[0] <= o && o <= d[1]) return d[2] + (o - d[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(s, o) {
      var a = { cmds: [], crds: [] };
      if (s.SVG && s.SVG.entries[o]) {
        var l = s.SVG.entries[o];
        return l == null ? a : (typeof l == "string" && (l = e.SVG.toPath(l), s.SVG.entries[o] = l), l);
      }
      if (s.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: s.CFF.Private ? s.CFF.Private.defaultWidthX : 0, open: !1 }, u = s.CFF, h = s.CFF.Private;
        if (u.ROS) {
          for (var d = 0; u.FDSelect[d + 2] <= o; ) d += 2;
          h = u.FDArray[u.FDSelect[d + 1]].Private;
        }
        e.U._drawCFF(s.CFF.CharStrings[o], c, u, h, a);
      } else s.glyf && e.U._drawGlyf(o, s, a);
      return a;
    }, e.U._drawGlyf = function(s, o, a) {
      var l = o.glyf[s];
      l == null && (l = o.glyf[s] = e.glyf._parseGlyf(o, s)), l != null && (l.noc > -1 ? e.U._simpleGlyph(l, a) : e.U._compoGlyph(l, o, a));
    }, e.U._simpleGlyph = function(s, o) {
      for (var a = 0; a < s.noc; a++) {
        for (var l = a == 0 ? 0 : s.endPts[a - 1] + 1, c = s.endPts[a], u = l; u <= c; u++) {
          var h = u == l ? c : u - 1, d = u == c ? l : u + 1, p = 1 & s.flags[u], f = 1 & s.flags[h], m = 1 & s.flags[d], _ = s.xs[u], g = s.ys[u];
          if (u == l) if (p) {
            if (!f) {
              e.U.P.moveTo(o, _, g);
              continue;
            }
            e.U.P.moveTo(o, s.xs[h], s.ys[h]);
          } else f ? e.U.P.moveTo(o, s.xs[h], s.ys[h]) : e.U.P.moveTo(o, (s.xs[h] + _) / 2, (s.ys[h] + g) / 2);
          p ? f && e.U.P.lineTo(o, _, g) : m ? e.U.P.qcurveTo(o, _, g, s.xs[d], s.ys[d]) : e.U.P.qcurveTo(o, _, g, (_ + s.xs[d]) / 2, (g + s.ys[d]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(s, o, a) {
      for (var l = 0; l < s.parts.length; l++) {
        var c = { cmds: [], crds: [] }, u = s.parts[l];
        e.U._drawGlyf(u.glyphIndex, o, c);
        for (var h = u.m, d = 0; d < c.crds.length; d += 2) {
          var p = c.crds[d], f = c.crds[d + 1];
          a.crds.push(p * h.a + f * h.b + h.tx), a.crds.push(p * h.c + f * h.d + h.ty);
        }
        for (d = 0; d < c.cmds.length; d++) a.cmds.push(c.cmds[d]);
      }
    }, e.U._getGlyphClass = function(s, o) {
      var a = e._lctf.getInterval(o, s);
      return a == -1 ? 0 : o[a + 2];
    }, e.U._applySubs = function(s, o, a, l) {
      for (var c = s.length - o - 1, u = 0; u < a.tabs.length; u++) if (a.tabs[u] != null) {
        var h, d = a.tabs[u];
        if (!d.coverage || (h = e._lctf.coverageIndex(d.coverage, s[o])) != -1) {
          if (a.ltype == 1) s[o], d.fmt == 1 ? s[o] = s[o] + d.delta : s[o] = d.newg[h];
          else if (a.ltype == 4) for (var p = d.vals[h], f = 0; f < p.length; f++) {
            var m = p[f], _ = m.chain.length;
            if (!(_ > c)) {
              for (var g = !0, v = 0, S = 0; S < _; S++) {
                for (; s[o + v + (1 + S)] == -1; ) v++;
                m.chain[S] != s[o + v + (1 + S)] && (g = !1);
              }
              if (g) {
                for (s[o] = m.nglyph, S = 0; S < _ + v; S++) s[o + S + 1] = -1;
                break;
              }
            }
          }
          else if (a.ltype == 5 && d.fmt == 2) for (var b = e._lctf.getInterval(d.cDef, s[o]), x = d.cDef[b + 2], M = d.scset[x], C = 0; C < M.length; C++) {
            var E = M[C], T = E.input;
            if (!(T.length > c)) {
              for (g = !0, S = 0; S < T.length; S++) {
                var w = e._lctf.getInterval(d.cDef, s[o + 1 + S]);
                if (b == -1 && d.cDef[w + 2] != T[S]) {
                  g = !1;
                  break;
                }
              }
              if (g) {
                var A = E.substLookupRecords;
                for (f = 0; f < A.length; f += 2) A[f], A[f + 1];
              }
            }
          }
          else if (a.ltype == 6 && d.fmt == 3) {
            if (!e.U._glsCovered(s, d.backCvg, o - d.backCvg.length) || !e.U._glsCovered(s, d.inptCvg, o) || !e.U._glsCovered(s, d.ahedCvg, o + d.inptCvg.length)) continue;
            var O = d.lookupRec;
            for (C = 0; C < O.length; C += 2) {
              b = O[C];
              var U = l[O[C + 1]];
              e.U._applySubs(s, o + b, U, l);
            }
          }
        }
      }
    }, e.U._glsCovered = function(s, o, a) {
      for (var l = 0; l < o.length; l++)
        if (e._lctf.coverageIndex(o[l], s[a + l]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(s, o, a) {
      for (var l = { cmds: [], crds: [] }, c = 0, u = 0; u < o.length; u++) {
        var h = o[u];
        if (h != -1) {
          for (var d = u < o.length - 1 && o[u + 1] != -1 ? o[u + 1] : 0, p = e.U.glyphToPath(s, h), f = 0; f < p.crds.length; f += 2) l.crds.push(p.crds[f] + c), l.crds.push(p.crds[f + 1]);
          for (a && l.cmds.push(a), f = 0; f < p.cmds.length; f++) l.cmds.push(p.cmds[f]);
          a && l.cmds.push("X"), c += s.hmtx.aWidth[h], u < o.length - 1 && (c += e.U.getPairAdjustment(s, h, d));
        }
      }
      return l;
    }, e.U.P = {}, e.U.P.moveTo = function(s, o, a) {
      s.cmds.push("M"), s.crds.push(o, a);
    }, e.U.P.lineTo = function(s, o, a) {
      s.cmds.push("L"), s.crds.push(o, a);
    }, e.U.P.curveTo = function(s, o, a, l, c, u, h) {
      s.cmds.push("C"), s.crds.push(o, a, l, c, u, h);
    }, e.U.P.qcurveTo = function(s, o, a, l, c) {
      s.cmds.push("Q"), s.crds.push(o, a, l, c);
    }, e.U.P.closePath = function(s) {
      s.cmds.push("Z");
    }, e.U._drawCFF = function(s, o, a, l, c) {
      for (var u = o.stack, h = o.nStems, d = o.haveWidth, p = o.width, f = o.open, m = 0, _ = o.x, g = o.y, v = 0, S = 0, b = 0, x = 0, M = 0, C = 0, E = 0, T = 0, w = 0, A = 0, O = { val: 0, size: 0 }; m < s.length; ) {
        e.CFF.getCharString(s, m, O);
        var U = O.val;
        if (m += O.size, U == "o1" || U == "o18") u.length % 2 != 0 && !d && (p = u.shift() + l.nominalWidthX), h += u.length >> 1, u.length = 0, d = !0;
        else if (U == "o3" || U == "o23")
          u.length % 2 != 0 && !d && (p = u.shift() + l.nominalWidthX), h += u.length >> 1, u.length = 0, d = !0;
        else if (U == "o4") u.length > 1 && !d && (p = u.shift() + l.nominalWidthX, d = !0), f && e.U.P.closePath(c), g += u.pop(), e.U.P.moveTo(c, _, g), f = !0;
        else if (U == "o5") for (; u.length > 0; ) _ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g);
        else if (U == "o6" || U == "o7") for (var D = u.length, L = U == "o6", P = 0; P < D; P++) {
          var V = u.shift();
          L ? _ += V : g += V, L = !L, e.U.P.lineTo(c, _, g);
        }
        else if (U == "o8" || U == "o24") {
          D = u.length;
          for (var ce = 0; ce + 6 <= D; ) v = _ + u.shift(), S = g + u.shift(), b = v + u.shift(), x = S + u.shift(), _ = b + u.shift(), g = x + u.shift(), e.U.P.curveTo(c, v, S, b, x, _, g), ce += 6;
          U == "o24" && (_ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g));
        } else {
          if (U == "o11") break;
          if (U == "o1234" || U == "o1235" || U == "o1236" || U == "o1237") U == "o1234" && (S = g, b = (v = _ + u.shift()) + u.shift(), A = x = S + u.shift(), C = x, T = g, _ = (E = (M = (w = b + u.shift()) + u.shift()) + u.shift()) + u.shift(), e.U.P.curveTo(c, v, S, b, x, w, A), e.U.P.curveTo(c, M, C, E, T, _, g)), U == "o1235" && (v = _ + u.shift(), S = g + u.shift(), b = v + u.shift(), x = S + u.shift(), w = b + u.shift(), A = x + u.shift(), M = w + u.shift(), C = A + u.shift(), E = M + u.shift(), T = C + u.shift(), _ = E + u.shift(), g = T + u.shift(), u.shift(), e.U.P.curveTo(c, v, S, b, x, w, A), e.U.P.curveTo(c, M, C, E, T, _, g)), U == "o1236" && (v = _ + u.shift(), S = g + u.shift(), b = v + u.shift(), A = x = S + u.shift(), C = x, E = (M = (w = b + u.shift()) + u.shift()) + u.shift(), T = C + u.shift(), _ = E + u.shift(), e.U.P.curveTo(c, v, S, b, x, w, A), e.U.P.curveTo(c, M, C, E, T, _, g)), U == "o1237" && (v = _ + u.shift(), S = g + u.shift(), b = v + u.shift(), x = S + u.shift(), w = b + u.shift(), A = x + u.shift(), M = w + u.shift(), C = A + u.shift(), E = M + u.shift(), T = C + u.shift(), Math.abs(E - _) > Math.abs(T - g) ? _ = E + u.shift() : g = T + u.shift(), e.U.P.curveTo(c, v, S, b, x, w, A), e.U.P.curveTo(c, M, C, E, T, _, g));
          else if (U == "o14") {
            if (u.length > 0 && !d && (p = u.shift() + a.nominalWidthX, d = !0), u.length == 4) {
              var q = u.shift(), oe = u.shift(), ne = u.shift(), $ = u.shift(), J = e.CFF.glyphBySE(a, ne), se = e.CFF.glyphBySE(a, $);
              e.U._drawCFF(a.CharStrings[J], o, a, l, c), o.x = q, o.y = oe, e.U._drawCFF(a.CharStrings[se], o, a, l, c);
            }
            f && (e.U.P.closePath(c), f = !1);
          } else if (U == "o19" || U == "o20")
            u.length % 2 != 0 && !d && (p = u.shift() + l.nominalWidthX), h += u.length >> 1, u.length = 0, d = !0, m += h + 7 >> 3;
          else if (U == "o21") u.length > 2 && !d && (p = u.shift() + l.nominalWidthX, d = !0), g += u.pop(), _ += u.pop(), f && e.U.P.closePath(c), e.U.P.moveTo(c, _, g), f = !0;
          else if (U == "o22") u.length > 1 && !d && (p = u.shift() + l.nominalWidthX, d = !0), _ += u.pop(), f && e.U.P.closePath(c), e.U.P.moveTo(c, _, g), f = !0;
          else if (U == "o25") {
            for (; u.length > 6; ) _ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g);
            v = _ + u.shift(), S = g + u.shift(), b = v + u.shift(), x = S + u.shift(), _ = b + u.shift(), g = x + u.shift(), e.U.P.curveTo(c, v, S, b, x, _, g);
          } else if (U == "o26") for (u.length % 2 && (_ += u.shift()); u.length > 0; ) v = _, S = g + u.shift(), _ = b = v + u.shift(), g = (x = S + u.shift()) + u.shift(), e.U.P.curveTo(c, v, S, b, x, _, g);
          else if (U == "o27") for (u.length % 2 && (g += u.shift()); u.length > 0; ) S = g, b = (v = _ + u.shift()) + u.shift(), x = S + u.shift(), _ = b + u.shift(), g = x, e.U.P.curveTo(c, v, S, b, x, _, g);
          else if (U == "o10" || U == "o29") {
            var le = U == "o10" ? l : a;
            if (u.length == 0) console.debug("error: empty stack");
            else {
              var re = u.pop(), ye = le.Subrs[re + le.Bias];
              o.x = _, o.y = g, o.nStems = h, o.haveWidth = d, o.width = p, o.open = f, e.U._drawCFF(ye, o, a, l, c), _ = o.x, g = o.y, h = o.nStems, d = o.haveWidth, p = o.width, f = o.open;
            }
          } else if (U == "o30" || U == "o31") {
            var H = u.length, K = (ce = 0, U == "o31");
            for (ce += H - (D = -3 & H); ce < D; ) K ? (S = g, b = (v = _ + u.shift()) + u.shift(), g = (x = S + u.shift()) + u.shift(), D - ce == 5 ? (_ = b + u.shift(), ce++) : _ = b, K = !1) : (v = _, S = g + u.shift(), b = v + u.shift(), x = S + u.shift(), _ = b + u.shift(), D - ce == 5 ? (g = x + u.shift(), ce++) : g = x, K = !0), e.U.P.curveTo(c, v, S, b, x, _, g), ce += 4;
          } else {
            if ((U + "").charAt(0) == "o") throw console.debug("Unknown operation: " + U, s), U;
            u.push(U);
          }
        }
      }
      o.x = _, o.y = g, o.nStems = h, o.haveWidth = d, o.width = p, o.open = f;
    };
    var n = e, i = { Typr: n };
    return r.Typr = n, r.default = i, Object.defineProperty(r, "__esModule", { value: !0 }), r;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function y7() {
  return function(r) {
    var e = Uint8Array, n = Uint16Array, i = Uint32Array, s = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), l = function(U, D) {
      for (var L = new n(31), P = 0; P < 31; ++P) L[P] = D += 1 << U[P - 1];
      var V = new i(L[30]);
      for (P = 1; P < 30; ++P) for (var ce = L[P]; ce < L[P + 1]; ++ce) V[ce] = ce - L[P] << 5 | P;
      return [L, V];
    }, c = l(s, 2), u = c[0], h = c[1];
    u[28] = 258, h[258] = 28;
    for (var d = l(o, 0)[0], p = new n(32768), f = 0; f < 32768; ++f) {
      var m = (43690 & f) >>> 1 | (21845 & f) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, p[f] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var _ = function(U, D, L) {
      for (var P = U.length, V = 0, ce = new n(D); V < P; ++V) ++ce[U[V] - 1];
      var q, oe = new n(D);
      for (V = 0; V < D; ++V) oe[V] = oe[V - 1] + ce[V - 1] << 1;
      {
        q = new n(1 << D);
        var ne = 15 - D;
        for (V = 0; V < P; ++V) if (U[V]) for (var $ = V << 4 | U[V], J = D - U[V], se = oe[U[V] - 1]++ << J, le = se | (1 << J) - 1; se <= le; ++se) q[p[se] >>> ne] = $;
      }
      return q;
    }, g = new e(288);
    for (f = 0; f < 144; ++f) g[f] = 8;
    for (f = 144; f < 256; ++f) g[f] = 9;
    for (f = 256; f < 280; ++f) g[f] = 7;
    for (f = 280; f < 288; ++f) g[f] = 8;
    var v = new e(32);
    for (f = 0; f < 32; ++f) v[f] = 5;
    var S = _(g, 9), b = _(v, 5), x = function(U) {
      for (var D = U[0], L = 1; L < U.length; ++L) U[L] > D && (D = U[L]);
      return D;
    }, M = function(U, D, L) {
      var P = D / 8 | 0;
      return (U[P] | U[P + 1] << 8) >> (7 & D) & L;
    }, C = function(U, D) {
      var L = D / 8 | 0;
      return (U[L] | U[L + 1] << 8 | U[L + 2] << 16) >> (7 & D);
    }, E = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(U, D, L) {
      var P = new Error(D || E[U]);
      if (P.code = U, Error.captureStackTrace && Error.captureStackTrace(P, T), !L) throw P;
      return P;
    }, w = function(U, D, L) {
      var P = U.length;
      if (!P || L && !L.l && P < 5) return D || new e(0);
      var V = !D || L, ce = !L || L.i;
      L || (L = {}), D || (D = new e(3 * P));
      var q, oe = function(Pe) {
        var Ge = D.length;
        if (Pe > Ge) {
          var Ve = new e(Math.max(2 * Ge, Pe));
          Ve.set(D), D = Ve;
        }
      }, ne = L.f || 0, $ = L.p || 0, J = L.b || 0, se = L.l, le = L.d, re = L.m, ye = L.n, H = 8 * P;
      do {
        if (!se) {
          L.f = ne = M(U, $, 1);
          var K = M(U, $ + 1, 3);
          if ($ += 3, !K) {
            var G = U[(te = ((q = $) / 8 | 0) + (7 & q && 1) + 4) - 4] | U[te - 3] << 8, R = te + G;
            if (R > P) {
              ce && T(0);
              break;
            }
            V && oe(J + G), D.set(U.subarray(te, R), J), L.b = J += G, L.p = $ = 8 * R;
            continue;
          }
          if (K == 1) se = S, le = b, re = 9, ye = 5;
          else if (K == 2) {
            var z = M(U, $, 31) + 257, I = M(U, $ + 10, 15) + 4, Q = z + M(U, $ + 5, 31) + 1;
            $ += 14;
            for (var X = new e(Q), k = new e(19), ee = 0; ee < I; ++ee) k[a[ee]] = M(U, $ + 3 * ee, 7);
            $ += 3 * I;
            var Z = x(k), N = (1 << Z) - 1, j = _(k, Z);
            for (ee = 0; ee < Q; ) {
              var te, F = j[M(U, $, N)];
              if ($ += 15 & F, (te = F >>> 4) < 16) X[ee++] = te;
              else {
                var B = 0, Y = 0;
                for (te == 16 ? (Y = 3 + M(U, $, 3), $ += 2, B = X[ee - 1]) : te == 17 ? (Y = 3 + M(U, $, 7), $ += 3) : te == 18 && (Y = 11 + M(U, $, 127), $ += 7); Y--; ) X[ee++] = B;
              }
            }
            var fe = X.subarray(0, z), ge = X.subarray(z);
            re = x(fe), ye = x(ge), se = _(fe, re), le = _(ge, ye);
          } else T(1);
          if ($ > H) {
            ce && T(0);
            break;
          }
        }
        V && oe(J + 131072);
        for (var xe = (1 << re) - 1, De = (1 << ye) - 1, ae = $; ; ae = $) {
          var de = (B = se[C(U, $) & xe]) >>> 4;
          if (($ += 15 & B) > H) {
            ce && T(0);
            break;
          }
          if (B || T(2), de < 256) D[J++] = de;
          else {
            if (de == 256) {
              ae = $, se = null;
              break;
            }
            var Ee = de - 254;
            if (de > 264) {
              var be = s[ee = de - 257];
              Ee = M(U, $, (1 << be) - 1) + u[ee], $ += be;
            }
            var ke = le[C(U, $) & De], ze = ke >>> 4;
            if (ke || T(3), $ += 15 & ke, ge = d[ze], ze > 3 && (be = o[ze], ge += C(U, $) & (1 << be) - 1, $ += be), $ > H) {
              ce && T(0);
              break;
            }
            V && oe(J + 131072);
            for (var Te = J + Ee; J < Te; J += 4) D[J] = D[J - ge], D[J + 1] = D[J + 1 - ge], D[J + 2] = D[J + 2 - ge], D[J + 3] = D[J + 3 - ge];
            J = Te;
          }
        }
        L.l = se, L.p = ae, L.b = J, se && (ne = 1, L.m = re, L.d = le, L.n = ye);
      } while (!ne);
      return J == D.length ? D : function(Pe, Ge, Ve) {
        (Ve == null || Ve > Pe.length) && (Ve = Pe.length);
        var Qe = new (Pe instanceof n ? n : Pe instanceof i ? i : e)(Ve - Ge);
        return Qe.set(Pe.subarray(Ge, Ve)), Qe;
      }(D, 0, J);
    }, A = new e(0), O = typeof TextDecoder < "u" && new TextDecoder();
    try {
      O.decode(A, { stream: !0 });
    } catch {
    }
    return r.convert_streams = function(U) {
      var D = new DataView(U), L = 0;
      function P() {
        var z = D.getUint16(L);
        return L += 2, z;
      }
      function V() {
        var z = D.getUint32(L);
        return L += 4, z;
      }
      function ce(z) {
        G.setUint16(R, z), R += 2;
      }
      function q(z) {
        G.setUint32(R, z), R += 4;
      }
      for (var oe = { signature: V(), flavor: V(), length: V(), numTables: P(), reserved: P(), totalSfntSize: V(), majorVersion: P(), minorVersion: P(), metaOffset: V(), metaLength: V(), metaOrigLength: V(), privOffset: V(), privLength: V() }, ne = 0; Math.pow(2, ne) <= oe.numTables; ) ne++;
      ne--;
      for (var $ = 16 * Math.pow(2, ne), J = 16 * oe.numTables - $, se = 12, le = [], re = 0; re < oe.numTables; re++) le.push({ tag: V(), offset: V(), compLength: V(), origLength: V(), origChecksum: V() }), se += 16;
      var ye, H = new Uint8Array(12 + 16 * le.length + le.reduce(function(z, I) {
        return z + I.origLength + 4;
      }, 0)), K = H.buffer, G = new DataView(K), R = 0;
      return q(oe.flavor), ce(oe.numTables), ce($), ce(ne), ce(J), le.forEach(function(z) {
        q(z.tag), q(z.origChecksum), q(se), q(z.origLength), z.outOffset = se, (se += z.origLength) % 4 != 0 && (se += 4 - se % 4);
      }), le.forEach(function(z) {
        var I, Q = U.slice(z.offset, z.offset + z.compLength);
        if (z.compLength != z.origLength) {
          var X = new Uint8Array(z.origLength);
          I = new Uint8Array(Q, 2), w(I, X);
        } else X = new Uint8Array(Q);
        H.set(X, z.outOffset);
        var k = 0;
        (se = z.outOffset + z.origLength) % 4 != 0 && (k = 4 - se % 4), H.set(new Uint8Array(k).buffer, z.outOffset + z.origLength), ye = se + k;
      }), K.slice(0, ye);
    }, Object.defineProperty(r, "__esModule", { value: !0 }), r;
  }({}).convert_streams;
}
function _7(r, e) {
  const n = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, s = 1, o = 2, a = 4, l = 8, c = 16, u = 32;
  let h;
  function d(E) {
    if (!h) {
      const T = {
        R: o,
        L: s,
        D: a,
        C: c,
        U: u,
        T: l
      };
      h = /* @__PURE__ */ new Map();
      for (let w in i) {
        let A = 0;
        i[w].split(",").forEach((O) => {
          let [U, D] = O.split("+");
          U = parseInt(U, 36), D = D ? parseInt(D, 36) : 0, h.set(A += U, T[w]);
          for (let L = D; L--; )
            h.set(++A, T[w]);
        });
      }
    }
    return h.get(E) || u;
  }
  const p = 1, f = 2, m = 3, _ = 4, g = [null, "isol", "init", "fina", "medi"];
  function v(E) {
    const T = new Uint8Array(E.length);
    let w = u, A = p, O = -1;
    for (let U = 0; U < E.length; U++) {
      const D = E.codePointAt(U);
      let L = d(D) | 0, P = p;
      L & l || (w & (s | a | c) ? L & (o | a | c) ? (P = m, (A === p || A === m) && T[O]++) : L & (s | u) && (A === f || A === _) && T[O]-- : w & (o | u) && (A === f || A === _) && T[O]--, A = T[U] = P, w = L, O = U, D > 65535 && U++);
    }
    return T;
  }
  function S(E, T) {
    const w = [];
    for (let O = 0; O < T.length; O++) {
      const U = T.codePointAt(O);
      U > 65535 && O++, w.push(r.U.codeToGlyph(E, U));
    }
    const A = E.GSUB;
    if (A) {
      const { lookupList: O, featureList: U } = A;
      let D;
      const L = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, P = [];
      U.forEach((V) => {
        if (L.test(V.tag))
          for (let ce = 0; ce < V.tab.length; ce++) {
            if (P[V.tab[ce]]) continue;
            P[V.tab[ce]] = !0;
            const q = O[V.tab[ce]], oe = /^(isol|init|fina|medi)$/.test(V.tag);
            oe && !D && (D = v(T));
            for (let ne = 0; ne < w.length; ne++)
              (!D || !oe || g[D[ne]] === V.tag) && r.U._applySubs(w, ne, q, O);
          }
      });
    }
    return w;
  }
  function b(E, T) {
    const w = new Int16Array(T.length * 3);
    let A = 0;
    for (; A < T.length; A++) {
      const L = T[A];
      if (L === -1) continue;
      w[A * 3 + 2] = E.hmtx.aWidth[L];
      const P = E.GPOS;
      if (P) {
        const V = P.lookupList;
        for (let ce = 0; ce < V.length; ce++) {
          const q = V[ce];
          for (let oe = 0; oe < q.tabs.length; oe++) {
            const ne = q.tabs[oe];
            if (q.ltype === 1) {
              if (r._lctf.coverageIndex(ne.coverage, L) !== -1 && ne.pos) {
                D(ne.pos, A);
                break;
              }
            } else if (q.ltype === 2) {
              let $ = null, J = O();
              if (J !== -1) {
                const se = r._lctf.coverageIndex(ne.coverage, T[J]);
                if (se !== -1) {
                  if (ne.fmt === 1) {
                    const le = ne.pairsets[se];
                    for (let re = 0; re < le.length; re++)
                      le[re].gid2 === L && ($ = le[re]);
                  } else if (ne.fmt === 2) {
                    const le = r.U._getGlyphClass(T[J], ne.classDef1), re = r.U._getGlyphClass(L, ne.classDef2);
                    $ = ne.matrix[le][re];
                  }
                  if ($) {
                    $.val1 && D($.val1, J), $.val2 && D($.val2, A);
                    break;
                  }
                }
              }
            } else if (q.ltype === 4) {
              const $ = r._lctf.coverageIndex(ne.markCoverage, L);
              if ($ !== -1) {
                const J = O(U), se = J === -1 ? -1 : r._lctf.coverageIndex(ne.baseCoverage, T[J]);
                if (se !== -1) {
                  const le = ne.markArray[$], re = ne.baseArray[se][le.markClass];
                  w[A * 3] = re.x - le.x + w[J * 3] - w[J * 3 + 2], w[A * 3 + 1] = re.y - le.y + w[J * 3 + 1];
                  break;
                }
              }
            } else if (q.ltype === 6) {
              const $ = r._lctf.coverageIndex(ne.mark1Coverage, L);
              if ($ !== -1) {
                const J = O();
                if (J !== -1) {
                  const se = T[J];
                  if (x(E, se) === 3) {
                    const le = r._lctf.coverageIndex(ne.mark2Coverage, se);
                    if (le !== -1) {
                      const re = ne.mark1Array[$], ye = ne.mark2Array[le][re.markClass];
                      w[A * 3] = ye.x - re.x + w[J * 3] - w[J * 3 + 2], w[A * 3 + 1] = ye.y - re.y + w[J * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (E.kern && !E.cff) {
        const V = O();
        if (V !== -1) {
          const ce = E.kern.glyph1.indexOf(T[V]);
          if (ce !== -1) {
            const q = E.kern.rval[ce].glyph2.indexOf(L);
            q !== -1 && (w[V * 3 + 2] += E.kern.rval[ce].vals[q]);
          }
        }
      }
    }
    return w;
    function O(L) {
      for (let P = A - 1; P >= 0; P--)
        if (T[P] !== -1 && (!L || L(T[P])))
          return P;
      return -1;
    }
    function U(L) {
      return x(E, L) === 1;
    }
    function D(L, P) {
      for (let V = 0; V < 3; V++)
        w[P * 3 + V] += L[V] || 0;
    }
  }
  function x(E, T) {
    const w = E.GDEF && E.GDEF.glyphClassDef;
    return w ? r.U._getGlyphClass(T, w) : 0;
  }
  function M(...E) {
    for (let T = 0; T < E.length; T++)
      if (typeof E[T] == "number")
        return E[T];
  }
  function C(E) {
    const T = /* @__PURE__ */ Object.create(null), w = E["OS/2"], A = E.hhea, O = E.head.unitsPerEm, U = M(w && w.sTypoAscender, A && A.ascender, O), D = {
      unitsPerEm: O,
      ascender: U,
      descender: M(w && w.sTypoDescender, A && A.descender, 0),
      capHeight: M(w && w.sCapHeight, U),
      xHeight: M(w && w.sxHeight, U),
      lineGap: M(w && w.sTypoLineGap, A && A.lineGap),
      supportsCodePoint(L) {
        return r.U.codeToGlyph(E, L) > 0;
      },
      forEachGlyph(L, P, V, ce) {
        let q = 0;
        const oe = 1 / D.unitsPerEm * P, ne = S(E, L);
        let $ = 0;
        const J = b(E, ne);
        return ne.forEach((se, le) => {
          if (se !== -1) {
            let re = T[se];
            if (!re) {
              const { cmds: ye, crds: H } = r.U.glyphToPath(E, se);
              let K = "", G = 0;
              for (let X = 0, k = ye.length; X < k; X++) {
                const ee = n[ye[X]];
                K += ye[X];
                for (let Z = 1; Z <= ee; Z++)
                  K += (Z > 1 ? "," : "") + H[G++];
              }
              let R, z, I, Q;
              if (H.length) {
                R = z = 1 / 0, I = Q = -1 / 0;
                for (let X = 0, k = H.length; X < k; X += 2) {
                  let ee = H[X], Z = H[X + 1];
                  ee < R && (R = ee), Z < z && (z = Z), ee > I && (I = ee), Z > Q && (Q = Z);
                }
              } else
                R = I = z = Q = 0;
              re = T[se] = {
                index: se,
                advanceWidth: E.hmtx.aWidth[se],
                xMin: R,
                yMin: z,
                xMax: I,
                yMax: Q,
                path: K
              };
            }
            ce.call(
              null,
              re,
              q + J[le * 3] * oe,
              J[le * 3 + 1] * oe,
              $
            ), q += J[le * 3 + 2] * oe, V && (q += V * P);
          }
          $ += L.codePointAt($) > 65535 ? 2 : 1;
        }), q;
      }
    };
    return D;
  }
  return function(T) {
    const w = new Uint8Array(T, 0, 4), A = r._bin.readASCII(w, 0, 4);
    if (A === "wOFF")
      T = e(T);
    else if (A === "wOF2")
      throw new Error("woff2 fonts not supported");
    return C(r.parse(T)[0]);
  };
}
const x7 = /* @__PURE__ */ Dl({
  name: "Typr Font Parser",
  dependencies: [v7, y7, _7],
  init(r, e, n) {
    const i = r(), s = e();
    return n(i, s);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function b7() {
  return function(r) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(b) {
      var x = b >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & b));
    }, e.prototype.has = function(b) {
      var x = this.buckets.get(b >> 5);
      return x !== void 0 && (x & 1 << (31 & b)) != 0;
    }, e.prototype.serialize = function() {
      var b = [];
      return this.buckets.forEach(function(x, M) {
        b.push((+M).toString(36) + ":" + x.toString(36));
      }), b.join(",");
    }, e.prototype.deserialize = function(b) {
      var x = this;
      this.buckets.clear(), b.split(",").forEach(function(M) {
        var C = M.split(":");
        x.buckets.set(parseInt(C[0], 36), parseInt(C[1], 36));
      });
    };
    var n = Math.pow(2, 8), i = n - 1, s = ~i;
    function o(b) {
      var x = function(C) {
        return C & s;
      }(b).toString(16), M = function(C) {
        return (C & s) + n - 1;
      }(b).toString(16);
      return "codepoint-index/plane" + (b >> 16) + "/" + x + "-" + M + ".json";
    }
    function a(b, x) {
      var M = b & i, C = x.codePointAt(M / 6 | 0);
      return ((C = (C || 48) - 48) & 1 << M % 6) != 0;
    }
    function l(b, x) {
      var M;
      (M = b, M.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(C) {
        return C.split("-").map(function(E) {
          return parseInt(E.trim(), 16);
        });
      })).forEach(function(C) {
        var E = C[0], T = C[1];
        T === void 0 && (T = E), x(E, T);
      });
    }
    function c(b, x) {
      l(b, function(M, C) {
        for (var E = M; E <= C; E++) x(E);
      });
    }
    var u = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), p = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(b) {
      var x = d.get(b);
      return x || (x = new e(), c(b.ranges, function(M) {
        return x.add(M);
      }), d.set(b, x)), x;
    }
    var m, _ = /* @__PURE__ */ new Map();
    function g(b, x, M) {
      return b[x] ? x : b[M] ? M : function(C) {
        for (var E in C) return E;
      }(b);
    }
    function v(b, x) {
      var M = x;
      if (!b.includes(M)) {
        M = 1 / 0;
        for (var C = 0; C < b.length; C++) Math.abs(b[C] - x) < Math.abs(M - x) && (M = b[C]);
      }
      return M;
    }
    function S(b) {
      return m || (m = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        m.add(x);
      })), m.has(b);
    }
    return r.CodePointSet = e, r.clearCache = function() {
      u = {}, h = {};
    }, r.getFontsForString = function(b, x) {
      x === void 0 && (x = {});
      var M, C = x.lang;
      C === void 0 && (C = new RegExp("\\p{Script=Hangul}", "u").test(M = b) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(M) ? "ja" : "en");
      var E = x.category;
      E === void 0 && (E = "sans-serif");
      var T = x.style;
      T === void 0 && (T = "normal");
      var w = x.weight;
      w === void 0 && (w = 400);
      var A = (x.dataUrl || p).replace(/\/$/g, ""), O = /* @__PURE__ */ new Map(), U = new Uint8Array(b.length), D = {}, L = {}, P = new Array(b.length), V = /* @__PURE__ */ new Map(), ce = !1;
      function q($) {
        var J = _.get($);
        return J || (J = fetch(A + "/" + $).then(function(se) {
          if (!se.ok) throw new Error(se.statusText);
          return se.json().then(function(le) {
            if (!Array.isArray(le) || le[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + le[0]);
            return le[1];
          });
        }).catch(function(se) {
          if (A !== p) return ce || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + A + '", trying default CDN. ' + se.message), ce = !0), A = p, _.delete($), q($);
          throw se;
        }), _.set($, J)), J;
      }
      for (var oe = function($) {
        var J = b.codePointAt($), se = o(J);
        P[$] = se, u[se] || V.has(se) || V.set(se, q(se).then(function(le) {
          u[se] = le;
        })), J > 65535 && ($++, ne = $);
      }, ne = 0; ne < b.length; ne++) oe(ne);
      return Promise.all(V.values()).then(function() {
        V.clear();
        for (var $ = function(se) {
          var le = b.codePointAt(se), re = null, ye = u[P[se]], H = void 0;
          for (var K in ye) {
            var G = L[K];
            if (G === void 0 && (G = L[K] = new RegExp(K).test(C || "en")), G) {
              for (var R in H = K, ye[K]) if (a(le, ye[K][R])) {
                re = R;
                break;
              }
              break;
            }
          }
          if (!re) {
            e: for (var z in ye) if (z !== H) {
              for (var I in ye[z]) if (a(le, ye[z][I])) {
                re = I;
                break e;
              }
            }
          }
          re || (console.debug("No font coverage for U+" + le.toString(16)), re = "latin"), P[se] = re, h[re] || V.has(re) || V.set(re, q("font-meta/" + re + ".json").then(function(Q) {
            h[re] = Q;
          })), le > 65535 && (se++, J = se);
        }, J = 0; J < b.length; J++) $(J);
        return Promise.all(V.values());
      }).then(function() {
        for (var $, J = null, se = 0; se < b.length; se++) {
          var le = b.codePointAt(se);
          if (J && (S(le) || f(J).has(le))) U[se] = U[se - 1];
          else {
            J = h[P[se]];
            var re = D[J.id];
            if (!re) {
              var ye = J.typeforms, H = g(ye, E, "sans-serif"), K = g(ye[H], T, "normal"), G = v(($ = ye[H]) === null || $ === void 0 ? void 0 : $[K], w);
              re = D[J.id] = A + "/font-files/" + J.id + "/" + H + "." + K + "." + G + ".woff";
            }
            var R = O.get(re);
            R == null && (R = O.size, O.set(re, R)), U[se] = R;
          }
          le > 65535 && (se++, U[se] = U[se - 1]);
        }
        return { fontUrls: Array.from(O.keys()), chars: U };
      });
    }, Object.defineProperty(r, "__esModule", { value: !0 }), r;
  }({});
}
function w7(r, e) {
  const n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(a, l) {
    const c = (u) => {
      console.error(`Failure loading font ${a}`, u);
    };
    try {
      const u = new XMLHttpRequest();
      u.open("get", a, !0), u.responseType = "arraybuffer", u.onload = function() {
        if (u.status >= 400)
          c(new Error(u.statusText));
        else if (u.status > 0)
          try {
            const h = r(u.response);
            h.src = a, l(h);
          } catch (h) {
            c(h);
          }
      }, u.onerror = c, u.send();
    } catch (u) {
      c(u);
    }
  }
  function o(a, l) {
    let c = n[a];
    c ? l(c) : i[a] ? i[a].push(l) : (i[a] = [l], s(a, (u) => {
      u.src = a, n[a] = u, i[a].forEach((h) => h(u)), delete i[a];
    }));
  }
  return function(a, l, {
    lang: c,
    fonts: u = [],
    style: h = "normal",
    weight: d = "normal",
    unicodeFontsURL: p
  } = {}) {
    const f = new Uint8Array(a.length), m = [];
    a.length || S();
    const _ = /* @__PURE__ */ new Map(), g = [];
    if (h !== "italic" && (h = "normal"), typeof d != "number" && (d = d === "bold" ? 700 : 400), u && !Array.isArray(u) && (u = [u]), u = u.slice().filter((x) => !x.lang || x.lang.test(c)).reverse(), u.length) {
      let E = 0;
      (function T(w = 0) {
        for (let A = w, O = a.length; A < O; A++) {
          const U = a.codePointAt(A);
          if (E === 1 && m[f[A - 1]].supportsCodePoint(U) || A > 0 && /\s/.test(a[A]))
            f[A] = f[A - 1], E === 2 && (g[g.length - 1][1] = A);
          else
            for (let D = f[A], L = u.length; D <= L; D++)
              if (D === L) {
                const P = E === 2 ? g[g.length - 1] : g[g.length] = [A, A];
                P[1] = A, E = 2;
              } else {
                f[A] = D;
                const { src: P, unicodeRange: V } = u[D];
                if (!V || b(U, V)) {
                  const ce = n[P];
                  if (!ce) {
                    o(P, () => {
                      T(A);
                    });
                    return;
                  }
                  if (ce.supportsCodePoint(U)) {
                    let q = _.get(ce);
                    typeof q != "number" && (q = m.length, m.push(ce), _.set(ce, q)), f[A] = q, E = 1;
                    break;
                  }
                }
              }
          U > 65535 && A + 1 < O && (f[A + 1] = f[A], A++, E === 2 && (g[g.length - 1][1] = A));
        }
        v();
      })();
    } else
      g.push([0, a.length - 1]), v();
    function v() {
      if (g.length) {
        const x = g.map((M) => a.substring(M[0], M[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: c || void 0,
          style: h,
          weight: d,
          dataUrl: p
        }).then(({ fontUrls: M, chars: C }) => {
          const E = m.length;
          let T = 0;
          g.forEach((A) => {
            for (let O = 0, U = A[1] - A[0]; O <= U; O++)
              f[A[0] + O] = C[T++] + E;
            T++;
          });
          let w = 0;
          M.forEach((A, O) => {
            o(A, (U) => {
              m[O + E] = U, ++w === M.length && S();
            });
          });
        });
      } else
        S();
    }
    function S() {
      l({
        chars: f,
        fonts: m
      });
    }
    function b(x, M) {
      for (let C = 0; C < M.length; C++) {
        const [E, T = E] = M[C];
        if (E <= x && x <= T)
          return !0;
      }
      return !1;
    }
  };
}
const S7 = /* @__PURE__ */ Dl({
  name: "FontResolver",
  dependencies: [
    w7,
    x7,
    b7
  ],
  init(r, e, n) {
    return r(e, n());
  }
});
function M7(r, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, s = "[^\\S\\u00A0]", o = new RegExp(`${s}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function a({ text: m, lang: _, fonts: g, style: v, weight: S, preResolvedFonts: b, unicodeFontsURL: x }, M) {
    const C = ({ chars: E, fonts: T }) => {
      let w, A;
      const O = [];
      for (let U = 0; U < E.length; U++)
        E[U] !== A ? (A = E[U], O.push(w = { start: U, end: U, fontObj: T[E[U]] })) : w.end = U;
      M(O);
    };
    b ? C(b) : r(
      m,
      C,
      { lang: _, fonts: g, style: v, weight: S, unicodeFontsURL: x }
    );
  }
  function l({
    text: m = "",
    font: _,
    lang: g,
    sdfGlyphSize: v = 64,
    fontSize: S = 400,
    fontWeight: b = 1,
    fontStyle: x = "normal",
    letterSpacing: M = 0,
    lineHeight: C = "normal",
    maxWidth: E = 1 / 0,
    direction: T,
    textAlign: w = "left",
    textIndent: A = 0,
    whiteSpace: O = "normal",
    overflowWrap: U = "normal",
    anchorX: D = 0,
    anchorY: L = 0,
    metricsOnly: P = !1,
    unicodeFontsURL: V,
    preResolvedFonts: ce = null,
    includeCaretPositions: q = !1,
    chunkedBoundsSize: oe = 8192,
    colorRanges: ne = null
  }, $) {
    const J = d(), se = { fontLoad: 0, typesetting: 0 };
    m.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), m = m.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), S = +S, M = +M, E = +E, C = C || "normal", A = +A, a({
      text: m,
      lang: g,
      style: x,
      weight: b,
      fonts: typeof _ == "string" ? [{ src: _ }] : _,
      unicodeFontsURL: V,
      preResolvedFonts: ce
    }, (le) => {
      se.fontLoad = d() - J;
      const re = isFinite(E);
      let ye = null, H = null, K = null, G = null, R = null, z = null, I = null, Q = null, X = 0, k = 0, ee = O !== "nowrap";
      const Z = /* @__PURE__ */ new Map(), N = d();
      let j = A, te = 0, F = new p();
      const B = [F];
      le.forEach((De) => {
        const { fontObj: ae } = De, { ascender: de, descender: Ee, unitsPerEm: be, lineGap: ke, capHeight: ze, xHeight: Te } = ae;
        let Pe = Z.get(ae);
        if (!Pe) {
          const Ue = S / be, Fe = C === "normal" ? (de - Ee + ke) * Ue : C * S, je = (Fe - (de - Ee) * Ue) / 2, Ke = Math.min(Fe, (de - Ee) * Ue), qe = (de + Ee) / 2 * Ue + Ke / 2;
          Pe = {
            index: Z.size,
            src: ae.src,
            fontObj: ae,
            fontSizeMult: Ue,
            unitsPerEm: be,
            ascender: de * Ue,
            descender: Ee * Ue,
            capHeight: ze * Ue,
            xHeight: Te * Ue,
            lineHeight: Fe,
            baseline: -je - de * Ue,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: qe,
            caretBottom: qe - Ke
          }, Z.set(ae, Pe);
        }
        const { fontSizeMult: Ge } = Pe, Ve = m.slice(De.start, De.end + 1);
        let Qe, _e;
        ae.forEachGlyph(Ve, S, M, (Ue, Fe, je, Ke) => {
          Fe += te, Ke += De.start, Qe = Fe, _e = Ue;
          const qe = m.charAt(Ke), ut = Ue.advanceWidth * Ge, ot = F.count;
          let dt;
          if ("isEmpty" in Ue || (Ue.isWhitespace = !!qe && new RegExp(s).test(qe), Ue.canBreakAfter = !!qe && o.test(qe), Ue.isEmpty = Ue.xMin === Ue.xMax || Ue.yMin === Ue.yMax || i.test(qe)), !Ue.isWhitespace && !Ue.isEmpty && k++, ee && re && !Ue.isWhitespace && Fe + ut + j > E && ot) {
            if (F.glyphAt(ot - 1).glyphObj.canBreakAfter)
              dt = new p(), j = -Fe;
            else
              for (let Bt = ot; Bt--; )
                if (Bt === 0 && U === "break-word") {
                  dt = new p(), j = -Fe;
                  break;
                } else if (F.glyphAt(Bt).glyphObj.canBreakAfter) {
                  dt = F.splitAt(Bt + 1);
                  const $t = dt.glyphAt(0).x;
                  j -= $t;
                  for (let on = dt.count; on--; )
                    dt.glyphAt(on).x -= $t;
                  break;
                }
            dt && (F.isSoftWrapped = !0, F = dt, B.push(F), X = E);
          }
          let mt = F.glyphAt(F.count);
          mt.glyphObj = Ue, mt.x = Fe + j, mt.y = je, mt.width = ut, mt.charIndex = Ke, mt.fontData = Pe, qe === `
` && (F = new p(), B.push(F), j = -(Fe + ut + M * S) + A);
        }), te = Qe + _e.advanceWidth * Ge + M * S;
      });
      let Y = 0;
      B.forEach((De) => {
        let ae = !0;
        for (let de = De.count; de--; ) {
          const Ee = De.glyphAt(de);
          ae && !Ee.glyphObj.isWhitespace && (De.width = Ee.x + Ee.width, De.width > X && (X = De.width), ae = !1);
          let { lineHeight: be, capHeight: ke, xHeight: ze, baseline: Te } = Ee.fontData;
          be > De.lineHeight && (De.lineHeight = be);
          const Pe = Te - De.baseline;
          Pe < 0 && (De.baseline += Pe, De.cap += Pe, De.ex += Pe), De.cap = Math.max(De.cap, De.baseline + ke), De.ex = Math.max(De.ex, De.baseline + ze);
        }
        De.baseline -= Y, De.cap -= Y, De.ex -= Y, Y += De.lineHeight;
      });
      let fe = 0, ge = 0;
      if (D && (typeof D == "number" ? fe = -D : typeof D == "string" && (fe = -X * (D === "left" ? 0 : D === "center" ? 0.5 : D === "right" ? 1 : u(D)))), L && (typeof L == "number" ? ge = -L : typeof L == "string" && (ge = L === "top" ? 0 : L === "top-baseline" ? -B[0].baseline : L === "top-cap" ? -B[0].cap : L === "top-ex" ? -B[0].ex : L === "middle" ? Y / 2 : L === "bottom" ? Y : L === "bottom-baseline" ? -B[B.length - 1].baseline : u(L) * Y)), !P) {
        const De = e.getEmbeddingLevels(m, T);
        ye = new Uint16Array(k), H = new Uint8Array(k), K = new Float32Array(k * 2), G = {}, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0], Q = [], q && (z = new Float32Array(m.length * 4)), ne && (R = new Uint8Array(k * 3));
        let ae = 0, de = -1, Ee = -1, be, ke;
        if (B.forEach((ze, Te) => {
          let { count: Pe, width: Ge } = ze;
          if (Pe > 0) {
            let Ve = 0;
            for (let Ke = Pe; Ke-- && ze.glyphAt(Ke).glyphObj.isWhitespace; )
              Ve++;
            let Qe = 0, _e = 0;
            if (w === "center")
              Qe = (X - Ge) / 2;
            else if (w === "right")
              Qe = X - Ge;
            else if (w === "justify" && ze.isSoftWrapped) {
              let Ke = 0;
              for (let qe = Pe - Ve; qe--; )
                ze.glyphAt(qe).glyphObj.isWhitespace && Ke++;
              _e = (X - Ge) / Ke;
            }
            if (_e || Qe) {
              let Ke = 0;
              for (let qe = 0; qe < Pe; qe++) {
                let ut = ze.glyphAt(qe);
                const ot = ut.glyphObj;
                ut.x += Qe + Ke, _e !== 0 && ot.isWhitespace && qe < Pe - Ve && (Ke += _e, ut.width += _e);
              }
            }
            const Ue = e.getReorderSegments(
              m,
              De,
              ze.glyphAt(0).charIndex,
              ze.glyphAt(ze.count - 1).charIndex
            );
            for (let Ke = 0; Ke < Ue.length; Ke++) {
              const [qe, ut] = Ue[Ke];
              let ot = 1 / 0, dt = -1 / 0;
              for (let mt = 0; mt < Pe; mt++)
                if (ze.glyphAt(mt).charIndex >= qe) {
                  let Bt = mt, $t = mt;
                  for (; $t < Pe; $t++) {
                    let on = ze.glyphAt($t);
                    if (on.charIndex > ut)
                      break;
                    $t < Pe - Ve && (ot = Math.min(ot, on.x), dt = Math.max(dt, on.x + on.width));
                  }
                  for (let on = Bt; on < $t; on++) {
                    const Rn = ze.glyphAt(on);
                    Rn.x = dt - (Rn.x + Rn.width - ot);
                  }
                  break;
                }
            }
            let Fe;
            const je = (Ke) => Fe = Ke;
            for (let Ke = 0; Ke < Pe; Ke++) {
              const qe = ze.glyphAt(Ke);
              Fe = qe.glyphObj;
              const ut = Fe.index, ot = De.levels[qe.charIndex] & 1;
              if (ot) {
                const dt = e.getMirroredCharacter(m[qe.charIndex]);
                dt && qe.fontData.fontObj.forEachGlyph(dt, 0, 0, je);
              }
              if (q) {
                const { charIndex: dt, fontData: mt } = qe, Bt = qe.x + fe, $t = qe.x + qe.width + fe;
                z[dt * 4] = ot ? $t : Bt, z[dt * 4 + 1] = ot ? Bt : $t, z[dt * 4 + 2] = ze.baseline + mt.caretBottom + ge, z[dt * 4 + 3] = ze.baseline + mt.caretTop + ge;
                const on = dt - de;
                on > 1 && h(z, de, on), de = dt;
              }
              if (ne) {
                const { charIndex: dt } = qe;
                for (; dt > Ee; )
                  Ee++, ne.hasOwnProperty(Ee) && (ke = ne[Ee]);
              }
              if (!Fe.isWhitespace && !Fe.isEmpty) {
                const dt = ae++, { fontSizeMult: mt, src: Bt, index: $t } = qe.fontData, on = G[Bt] || (G[Bt] = {});
                on[ut] || (on[ut] = {
                  path: Fe.path,
                  pathBounds: [Fe.xMin, Fe.yMin, Fe.xMax, Fe.yMax]
                });
                const Rn = qe.x + fe, dn = qe.y + ze.baseline + ge;
                K[dt * 2] = Rn, K[dt * 2 + 1] = dn;
                const Un = Rn + Fe.xMin * mt, qn = dn + Fe.yMin * mt, Ln = Rn + Fe.xMax * mt, wn = dn + Fe.yMax * mt;
                Un < I[0] && (I[0] = Un), qn < I[1] && (I[1] = qn), Ln > I[2] && (I[2] = Ln), wn > I[3] && (I[3] = wn), dt % oe === 0 && (be = { start: dt, end: dt, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, Q.push(be)), be.end++;
                const Sn = be.rect;
                if (Un < Sn[0] && (Sn[0] = Un), qn < Sn[1] && (Sn[1] = qn), Ln > Sn[2] && (Sn[2] = Ln), wn > Sn[3] && (Sn[3] = wn), ye[dt] = ut, H[dt] = $t, ne) {
                  const Mi = dt * 3;
                  R[Mi] = ke >> 16 & 255, R[Mi + 1] = ke >> 8 & 255, R[Mi + 2] = ke & 255;
                }
              }
            }
          }
        }), z) {
          const ze = m.length - de;
          ze > 1 && h(z, de, ze);
        }
      }
      const xe = [];
      Z.forEach(({ index: De, src: ae, unitsPerEm: de, ascender: Ee, descender: be, lineHeight: ke, capHeight: ze, xHeight: Te }) => {
        xe[De] = { src: ae, unitsPerEm: de, ascender: Ee, descender: be, lineHeight: ke, capHeight: ze, xHeight: Te };
      }), se.typesetting = d() - N, $({
        glyphIds: ye,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: H,
        //index into fontData for each glyph
        glyphPositions: K,
        //x,y of each glyph's origin in layout
        glyphData: G,
        //dict holding data about each glyph appearing in the text
        fontData: xe,
        //data about each font used in the text
        caretPositions: z,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: R,
        //color for each glyph, if color ranges supplied
        chunkedBounds: Q,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: S,
        //calculated em height
        topBaseline: ge + B[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          fe,
          ge - Y,
          fe + X,
          ge
        ],
        visibleBounds: I,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: se
      });
    });
  }
  function c(m, _) {
    l({ ...m, metricsOnly: !0 }, (g) => {
      const [v, S, b, x] = g.blockBounds;
      _({
        width: b - v,
        height: x - S
      });
    });
  }
  function u(m) {
    let _ = m.match(/^([\d.]+)%$/), g = _ ? parseFloat(_[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function h(m, _, g) {
    const v = m[_ * 4], S = m[_ * 4 + 1], b = m[_ * 4 + 2], x = m[_ * 4 + 3], M = (S - v) / g;
    for (let C = 0; C < g; C++) {
      const E = (_ + C) * 4;
      m[E] = v + M * C, m[E + 1] = v + M * (C + 1), m[E + 2] = b, m[E + 3] = x;
    }
  }
  function d() {
    return (self.performance || Date).now();
  }
  function p() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return p.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(m) {
      let _ = p.flyweight;
      return _.data = this.data, _.index = m, _;
    },
    splitAt(m) {
      let _ = new p();
      return _.data = this.data.splice(m * f.length), _;
    }
  }, p.flyweight = f.reduce((m, _, g, v) => (Object.defineProperty(m, _, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(S) {
      this.data[this.index * f.length + g] = S;
    }
  }), m), { data: null, index: 0 }), {
    typeset: l,
    measure: c
  };
}
const Qo = () => (self.performance || Date).now(), Mf = /* @__PURE__ */ aS();
let p_;
function C7(r, e, n, i, s, o, a, l, c, u, h = !0) {
  return h ? E7(r, e, n, i, s, o, a, l, c, u).then(
    null,
    (d) => (p_ || (console.warn("WebGL SDF generation failed, falling back to JS", d), p_ = !0), g_(r, e, n, i, s, o, a, l, c, u))
  ) : g_(r, e, n, i, s, o, a, l, c, u);
}
const rd = [], T7 = 5;
let _g = 0;
function cS() {
  const r = Qo();
  for (; rd.length && Qo() - r < T7; )
    rd.shift()();
  _g = rd.length ? setTimeout(cS, 0) : 0;
}
const E7 = (...r) => new Promise((e, n) => {
  rd.push(() => {
    const i = Qo();
    try {
      Mf.webgl.generateIntoCanvas(...r), e({ timing: Qo() - i });
    } catch (s) {
      n(s);
    }
  }), _g || (_g = setTimeout(cS, 0));
}), A7 = 4, P7 = 2e3, m_ = {};
let D7 = 0;
function g_(r, e, n, i, s, o, a, l, c, u) {
  const h = "TroikaTextSDFGenerator_JS_" + D7++ % A7;
  let d = m_[h];
  return d || (d = m_[h] = {
    workerModule: Dl({
      name: h,
      workerId: h,
      dependencies: [
        aS,
        Qo
      ],
      init(p, f) {
        const m = p().javascript.generate;
        return function(..._) {
          const g = f();
          return {
            textureData: m(..._),
            timing: f() - g
          };
        };
      },
      getTransferables(p) {
        return [p.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), d.requests++, clearTimeout(d.idleTimer), d.workerModule(r, e, n, i, s, o).then(({ textureData: p, timing: f }) => {
    const m = Qo(), _ = new Uint8Array(p.length * 4);
    for (let g = 0; g < p.length; g++)
      _[g * 4 + u] = p[g];
    return Mf.webglUtils.renderImageData(a, _, l, c, r, e, 1 << 3 - u), f += Qo() - m, --d.requests === 0 && (d.idleTimer = setTimeout(() => {
      a7(h);
    }, P7)), { timing: f };
  });
}
function k7(r) {
  r._warm || (Mf.webgl.isSupported(r), r._warm = !0);
}
const R7 = Mf.webglUtils.resizeWebGLCanvasWithoutClearing, dc = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, L7 = /* @__PURE__ */ new Tt();
function ka() {
  return (self.performance || Date).now();
}
const v_ = /* @__PURE__ */ Object.create(null);
function I7(r, e) {
  r = F7({}, r);
  const n = ka(), i = [];
  if (r.font && i.push({ label: "user", src: U7(r.font) }), r.font = i, r.text = "" + r.text, r.sdfGlyphSize = r.sdfGlyphSize || dc.sdfGlyphSize, r.unicodeFontsURL = r.unicodeFontsURL || dc.unicodeFontsURL, r.colorRanges != null) {
    let p = {};
    for (let f in r.colorRanges)
      if (r.colorRanges.hasOwnProperty(f)) {
        let m = r.colorRanges[f];
        typeof m != "number" && (m = L7.set(m).getHex()), p[f] = m;
      }
    r.colorRanges = p;
  }
  Object.freeze(r);
  const { textureWidth: s, sdfExponent: o } = dc, { sdfGlyphSize: a } = r, l = s / a * 4;
  let c = v_[a];
  if (!c) {
    const p = document.createElement("canvas");
    p.width = s, p.height = a * 256 / l, c = v_[a] = {
      glyphCount: 0,
      sdfGlyphSize: a,
      sdfCanvas: p,
      sdfTexture: new Fn(
        p,
        void 0,
        void 0,
        void 0,
        Kt,
        Kt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, O7(c);
  }
  const { sdfTexture: u, sdfCanvas: h } = c;
  dS(r).then((p) => {
    const { glyphIds: f, glyphFontIndices: m, fontData: _, glyphPositions: g, fontSize: v, timings: S } = p, b = [], x = new Float32Array(f.length * 4);
    let M = 0, C = 0;
    const E = ka(), T = _.map((D) => {
      let L = c.glyphsByFont.get(D.src);
      return L || c.glyphsByFont.set(D.src, L = /* @__PURE__ */ new Map()), L;
    });
    f.forEach((D, L) => {
      const P = m[L], { src: V, unitsPerEm: ce } = _[P];
      let q = T[P].get(D);
      if (!q) {
        const { path: se, pathBounds: le } = p.glyphData[V][D], re = Math.max(le[2] - le[0], le[3] - le[1]) / a * (dc.sdfMargin * a + 0.5), ye = c.glyphCount++, H = [
          le[0] - re,
          le[1] - re,
          le[2] + re,
          le[3] + re
        ];
        T[P].set(D, q = { path: se, atlasIndex: ye, sdfViewBox: H }), b.push(q);
      }
      const { sdfViewBox: oe } = q, ne = g[C++], $ = g[C++], J = v / ce;
      x[M++] = ne + oe[0] * J, x[M++] = $ + oe[1] * J, x[M++] = ne + oe[2] * J, x[M++] = $ + oe[3] * J, f[L] = q.atlasIndex;
    }), S.quads = (S.quads || 0) + (ka() - E);
    const w = ka();
    S.sdf = {};
    const A = h.height, O = Math.ceil(c.glyphCount / l), U = Math.pow(2, Math.ceil(Math.log2(O * a)));
    U > A && (console.info(`Increasing SDF texture size ${A}->${U}`), R7(h, s, U), u.dispose()), Promise.all(b.map(
      (D) => uS(D, c, r.gpuAccelerateSDF).then(({ timing: L }) => {
        S.sdf[D.atlasIndex] = L;
      })
    )).then(() => {
      b.length && !c.contextLost && (hS(c), u.needsUpdate = !0), S.sdfTotal = ka() - w, S.total = ka() - n, e(Object.freeze({
        parameters: r,
        sdfTexture: u,
        sdfGlyphSize: a,
        sdfExponent: o,
        glyphBounds: x,
        glyphAtlasIndices: f,
        glyphColors: p.glyphColors,
        caretPositions: p.caretPositions,
        chunkedBounds: p.chunkedBounds,
        ascender: p.ascender,
        descender: p.descender,
        lineHeight: p.lineHeight,
        capHeight: p.capHeight,
        xHeight: p.xHeight,
        topBaseline: p.topBaseline,
        blockBounds: p.blockBounds,
        visibleBounds: p.visibleBounds,
        timings: p.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || k7(h);
  });
}
function uS({ path: r, atlasIndex: e, sdfViewBox: n }, { sdfGlyphSize: i, sdfCanvas: s, contextLost: o }, a) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: c } = dc, u = Math.max(n[2] - n[0], n[3] - n[1]), h = Math.floor(e / 4), d = h % (l / i) * i, p = Math.floor(h / (l / i)) * i, f = e % 4;
  return C7(i, i, r, n, u, c, s, d, p, f, a);
}
function O7(r) {
  const e = r.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), r.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (n) => {
    console.log("Context Restored", n), r.contextLost = !1;
    const i = [];
    r.glyphsByFont.forEach((s) => {
      s.forEach((o) => {
        i.push(uS(o, r, !0));
      });
    }), Promise.all(i).then(() => {
      hS(r), r.sdfTexture.needsUpdate = !0;
    });
  });
}
function F7(r, e) {
  for (let n in e)
    e.hasOwnProperty(n) && (r[n] = e[n]);
  return r;
}
let Ih;
function U7(r) {
  return Ih || (Ih = typeof document > "u" ? {} : document.createElement("a")), Ih.href = r, Ih.href;
}
function hS(r) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = r, { width: i, height: s } = e, o = r.sdfCanvas.getContext("webgl");
    let a = n.image.data;
    (!a || a.length !== i * s * 4) && (a = new Uint8Array(i * s * 4), n.image = { width: i, height: s, data: a }, n.flipY = !1, n.isDataTexture = !0), o.readPixels(0, 0, i, s, o.RGBA, o.UNSIGNED_BYTE, a);
  }
}
const z7 = /* @__PURE__ */ Dl({
  name: "Typesetter",
  dependencies: [
    M7,
    S7,
    c7
  ],
  init(r, e, n) {
    return r(e, n());
  }
}), dS = /* @__PURE__ */ Dl({
  name: "Typesetter",
  dependencies: [
    z7
  ],
  init(r) {
    return function(e) {
      return new Promise((n) => {
        r.typeset(e, n);
      });
    };
  },
  getTransferables(r) {
    const e = [];
    for (let n in r)
      r[n] && r[n].buffer && e.push(r[n].buffer);
    return e;
  }
});
dS.onMainThread;
const y_ = {};
function B7(r) {
  let e = y_[r];
  return e || (e = y_[r] = new yn(1, 1, r, r).translate(0.5, 0.5, 0)), e;
}
const N7 = "aTroikaGlyphBounds", __ = "aTroikaGlyphIndex", V7 = "aTroikaGlyphColor";
class G7 extends Wb {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new cu(), this.boundingBox = new mo();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let n = B7(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = n.attributes[i].clone();
      }), this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, n, i, s, o) {
    this.updateAttributeData(N7, e, 4), this.updateAttributeData(__, n, 1), this.updateAttributeData(V7, o, 3), this._blockBounds = i, this._chunkedBounds = s, this.instanceCount = n.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: i } = this;
      if (n) {
        const { PI: s, floor: o, min: a, max: l, sin: c, cos: u } = Math, h = s / 2, d = s * 2, p = Math.abs(n), f = e[0] / p, m = e[2] / p, _ = o((f + h) / d) !== o((m + h) / d) ? -p : a(c(f) * p, c(m) * p), g = o((f - h) / d) !== o((m - h) / d) ? p : l(c(f) * p, c(m) * p), v = o((f + s) / d) !== o((m + s) / d) ? p * 2 : l(p - u(f) * p, p - u(m) * p);
        i.min.set(_, e[1], n < 0 ? -v : 0), i.max.set(g, e[3], n < 0 ? 0 : v);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let n = this.getAttribute(__).count, i = this._chunkedBounds;
    if (i)
      for (let s = i.length; s--; ) {
        n = i[s].end;
        let o = i[s].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x)
          break;
      }
    this.instanceCount = n;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, n, i) {
    const s = this.getAttribute(e);
    n ? s && s.array.length === n.length ? (s.array.set(n), s.needsUpdate = !0) : (this.setAttribute(e, new Io(n, i)), delete this._maxInstanceCount, this.dispose()) : s && this.deleteAttribute(e);
  }
}
const H7 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, W7 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, j7 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, $7 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function X7(r) {
  const e = yg(r, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new ct() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Jt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Jt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new ct() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Tt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Dt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: H7,
    vertexTransform: W7,
    fragmentDefs: j7,
    fragmentColorTransform: $7,
    customRewriter({ vertexShader: n, fragmentShader: i }) {
      let s = /\buniform\s+vec3\s+diffuse\b/;
      return s.test(i) && (i = i.replace(s, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), s.test(n) || (n = n.replace(
        lS,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: n, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Iv = /* @__PURE__ */ new Gn({
  color: 16777215,
  side: Pn,
  transparent: !0
}), x_ = 8421504, b_ = /* @__PURE__ */ new rn(), Oh = /* @__PURE__ */ new he(), Yp = /* @__PURE__ */ new he(), ec = [], Y7 = /* @__PURE__ */ new he(), qp = "+x+y";
function w_(r) {
  return Array.isArray(r) ? r[0] : r;
}
let fS = () => {
  const r = new tt(
    new yn(1, 1),
    Iv
  );
  return fS = () => r, r;
}, pS = () => {
  const r = new tt(
    new yn(1, 1, 32, 1),
    Iv
  );
  return pS = () => r, r;
};
const q7 = { type: "syncstart" }, Z7 = { type: "synccomplete" }, mS = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], K7 = mS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class xg extends tt {
  constructor() {
    const e = new G7();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = x_, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = qp, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(q7), I7({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (n) => {
      this._isSyncing = !1, this._textRenderInfo = n, this.geometry.updateGlyphs(
        n.glyphBounds,
        n.glyphAtlasIndices,
        n.blockBounds,
        n.chunkedBounds,
        n.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((s) => s && s());
      })), this.dispatchEvent(Z7), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, n, i, s, o, a) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return X7(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const n = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Iv.clone());
    if ((!e || !e.isDerivedFrom(n)) && (e = this._derivedMaterial = this.createDerivedMaterial(n), n.addEventListener("dispose", function i() {
      n.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function s() {
        e.removeEventListener("dispose", s), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return w_(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {
  }
  get customDistanceMaterial() {
    return w_(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {
  }
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial, i = e.uniforms, s = this.textRenderInfo;
    if (s) {
      const { sdfTexture: l, blockBounds: c } = s;
      i.uTroikaSDFTexture.value = l, i.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), i.uTroikaSDFGlyphSize.value = s.sdfGlyphSize, i.uTroikaSDFExponent.value = s.sdfExponent, i.uTroikaTotalBounds.value.fromArray(c), i.uTroikaUseGlyphColors.value = !n && !!s.glyphColors;
      let u = 0, h = 0, d = 0, p, f, m, _ = 0, g = 0;
      if (n) {
        let { outlineWidth: S, outlineOffsetX: b, outlineOffsetY: x, outlineBlur: M, outlineOpacity: C } = this;
        u = this._parsePercent(S) || 0, h = Math.max(0, this._parsePercent(M) || 0), p = C, _ = this._parsePercent(b) || 0, g = this._parsePercent(x) || 0;
      } else
        d = Math.max(0, this._parsePercent(this.strokeWidth) || 0), d && (m = this.strokeColor, i.uTroikaStrokeColor.value.set(m ?? x_), f = this.strokeOpacity, f == null && (f = 1)), p = this.fillOpacity;
      i.uTroikaEdgeOffset.value = u, i.uTroikaPositionOffset.value.set(_, g), i.uTroikaBlurRadius.value = h, i.uTroikaStrokeWidth.value = d, i.uTroikaStrokeOpacity.value = f, i.uTroikaFillOpacity.value = p ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let v = this.clipRect;
      if (v && Array.isArray(v) && v.length === 4)
        i.uTroikaClipRect.value.fromArray(v);
      else {
        const S = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          c[0] - S,
          c[1] - S,
          c[2] + S,
          c[3] + S
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null)
      delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : e.color = new Tt();
      (o !== l._input || typeof o == "object") && l.set(l._input = o);
    }
    let a = this.orientation || qp;
    if (a !== e._orientation) {
      let l = i.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let c = a !== qp && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, u, h, d, p] = c;
        Oh.set(0, 0, 0)[h] = u === "-" ? 1 : -1, Yp.set(0, 0, 0)[p] = d === "-" ? -1 : 1, b_.lookAt(Y7, Oh.cross(Yp), Yp), l.setFromMatrix4(b_);
      } else
        l.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/), i = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, n = new ct()) {
    n.copy(e);
    const i = this.curveRadius;
    return i && (n.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), n;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, n = new ct()) {
    return Oh.copy(e), this.localPositionToTextCoords(this.worldToLocal(Oh), n);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, n) {
    const { textRenderInfo: i, curveRadius: s } = this;
    if (i) {
      const o = i.blockBounds, a = s ? pS() : fS(), l = a.geometry, { position: c, uv: u } = l.attributes;
      for (let h = 0; h < u.count; h++) {
        let d = o[0] + u.getX(h) * (o[2] - o[0]);
        const p = o[1] + u.getY(h) * (o[3] - o[1]);
        let f = 0;
        s && (f = s - Math.cos(d / s) * s, d = Math.sin(d / s) * s), c.setXYZ(h, d, p, f);
      }
      l.boundingSphere = this.geometry.boundingSphere, l.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, ec.length = 0, a.raycast(e, ec);
      for (let h = 0; h < ec.length; h++)
        ec[h].object = this, n.push(ec[h]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return super.copy(e), this.geometry = n, K7.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
mS.forEach((r) => {
  const e = "_private_" + r;
  Object.defineProperty(xg.prototype, r, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && (this[e] = n, this._needsSync = !0);
    }
  });
});
new mo();
new Tt();
class S_ {
  constructor(e, n = 500) {
    pe(this, "entries", []);
    pe(this, "totalLength", 0);
    this.curve = e, this.build(n);
  }
  build(e) {
    this.entries = [];
    let n = 0, i = this.curve.getPointAt(0);
    for (let s = 0; s <= e; s++) {
      const o = s / e, a = this.curve.getPointAt(o), l = this.curve.getTangentAt(o);
      s > 0 && (n += a.distanceTo(i)), this.entries.push({
        t: o,
        distance: n,
        position: a.clone(),
        tangent: l.clone().normalize()
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.entries.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.entries[l].distance < e ? n = l + 1 : i = l;
    }
    const s = this.entries[n], o = this.entries[Math.max(0, n - 1)];
    if (s.distance === o.distance)
      return s.t;
    const a = (e - o.distance) / (s.distance - o.distance);
    return o.t + a * (s.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e), i = this.curve.getPointAt(n), s = this.curve.getTangentAt(n).normalize(), o = new he(-s.y, s.x, 0).normalize();
    return {
      position: i,
      tangent: s,
      normal: o,
      t: n,
      distance: e
    };
  }
}
class J7 {
  constructor() {
    pe(this, "arcLengthTable", null);
    pe(this, "curve", null);
  }
  /**
   * Set the path from control points
   */
  setPath(e, n = !1) {
    var i, s, o, a, l, c, u, h;
    if (e.length < 2) {
      this.curve = null, this.arcLengthTable = null;
      return;
    }
    this.curve = new rv();
    for (let d = 0; d < e.length - 1; d++) {
      const p = e[d], f = e[d + 1], m = p.depth ?? 0, _ = f.depth ?? 0, g = new $c(
        new he(p.x, -p.y, m),
        new he(
          p.x + (((i = p.handleOut) == null ? void 0 : i.x) ?? 0),
          -(p.y + (((s = p.handleOut) == null ? void 0 : s.y) ?? 0)),
          m
        ),
        new he(
          f.x + (((o = f.handleIn) == null ? void 0 : o.x) ?? 0),
          -(f.y + (((a = f.handleIn) == null ? void 0 : a.y) ?? 0)),
          _
        ),
        new he(f.x, -f.y, _)
      );
      this.curve.add(g);
    }
    if (n && e.length > 2) {
      const d = e[e.length - 1], p = e[0], f = d.depth ?? 0, m = p.depth ?? 0, _ = new $c(
        new he(d.x, -d.y, f),
        new he(
          d.x + (((l = d.handleOut) == null ? void 0 : l.x) ?? 0),
          -(d.y + (((c = d.handleOut) == null ? void 0 : c.y) ?? 0)),
          f
        ),
        new he(
          p.x + (((u = p.handleIn) == null ? void 0 : u.x) ?? 0),
          -(p.y + (((h = p.handleIn) == null ? void 0 : h.y) ?? 0)),
          m
        ),
        new he(p.x, -p.y, m)
      );
      this.curve.add(_);
    }
    this.arcLengthTable = new S_(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(e) {
    this.curve = e, this.arcLengthTable = new S_(e);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    var e;
    return ((e = this.arcLengthTable) == null ? void 0 : e.totalLength) ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(e, n, i = 0, s = 72) {
    if (!this.arcLengthTable || e.length === 0)
      return [];
    const o = this.arcLengthTable.totalLength, a = [], l = i / 1e3 * s;
    let c = 0;
    for (let f = 0; f < e.length; f++)
      c += e[f], f < e.length - 1 && (c += l);
    const u = o - n.firstMargin - n.lastMargin;
    let h;
    switch (n.align) {
      case "center":
        h = n.firstMargin + (u - c) / 2;
        break;
      case "right":
        h = n.firstMargin + u - c;
        break;
      default:
        h = n.firstMargin;
    }
    const d = n.offset / 100 * u;
    h += d, n.reversed && (h = o - h - c);
    let p = h;
    for (let f = 0; f < e.length; f++) {
      const m = e[f];
      let g = p + m / 2, v = !0;
      (g < 0 || g > o) && (n.forceAlignment ? g = (g % o + o) % o : (v = g >= -m && g <= o + m, g = Math.max(0, Math.min(o, g))));
      const S = this.arcLengthTable.getPointAtDistance(g);
      let b;
      if (n.perpendicularToPath) {
        const x = Math.atan2(S.tangent.y, S.tangent.x);
        b = new Zi(0, 0, n.reversed ? x + Math.PI : x);
      } else
        b = new Zi(0, 0, 0);
      a.push({
        index: f,
        position: S.position.clone(),
        rotation: b,
        scale: 1,
        pathDistance: g,
        pathT: S.t,
        visible: v
      }), p += m + l;
    }
    return a;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(e) {
    if (!this.arcLengthTable) return null;
    const n = e / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(n);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(e) {
    if (!this.arcLengthTable || e < 2) return [];
    const n = [], i = this.arcLengthTable.totalLength / (e - 1);
    for (let s = 0; s < e; s++) {
      const o = s * i;
      n.push(this.arcLengthTable.getPointAtDistance(o));
    }
    return n;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null, this.arcLengthTable = null;
  }
}
function Q7() {
  return {
    pathLayerId: null,
    reversed: !1,
    perpendicularToPath: !0,
    forceAlignment: !1,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}
class ej extends Ps {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Text rendering
    pe(this, "textMesh");
    pe(this, "perCharacterGroup", null);
    pe(this, "characterMeshes", []);
    // Text data from layer
    pe(this, "textData");
    // Animatable text properties (from layer.properties)
    pe(this, "fontSizeProp");
    pe(this, "trackingProp");
    pe(this, "lineSpacingProp");
    pe(this, "fillColorProp");
    pe(this, "strokeColorProp");
    pe(this, "strokeWidthProp");
    pe(this, "pathOffsetProp");
    pe(this, "firstMarginProp");
    pe(this, "lastMarginProp");
    pe(this, "characterOffsetProp");
    // Per-character animation
    pe(this, "characterTransforms");
    // Path following service
    pe(this, "textOnPath");
    pe(this, "pathConfig");
    pe(this, "pathControlPoints", []);
    pe(this, "pathClosed", !1);
    // Character width cache (recalculated when text/font changes)
    pe(this, "characterWidths", []);
    pe(this, "characterWidthsDirty", !0);
    // Additional evaluator for text-specific properties
    pe(this, "textEvaluator");
    this.resources = i, this.textEvaluator = new hu(), this.textOnPath = new J7(), this.pathConfig = Q7(), this.textData = this.extractTextData(n), this.extractAnimatableProperties(n), this.textMesh = this.createTextMesh(), this.group.add(this.textMesh), (this.textData.perCharacter3D || this.textData.pathLayerId) && this.enablePerCharacter3D(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(n) {
    const i = n.data;
    return {
      text: (i == null ? void 0 : i.text) ?? "Text",
      fontFamily: (i == null ? void 0 : i.fontFamily) ?? "Impact",
      fontSize: (i == null ? void 0 : i.fontSize) ?? 72,
      fontWeight: (i == null ? void 0 : i.fontWeight) ?? "400",
      fontStyle: (i == null ? void 0 : i.fontStyle) ?? "normal",
      fill: (i == null ? void 0 : i.fill) ?? "#ffffff",
      stroke: (i == null ? void 0 : i.stroke) ?? "",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 0,
      // Character properties
      tracking: (i == null ? void 0 : i.tracking) ?? 0,
      lineSpacing: (i == null ? void 0 : i.lineSpacing) ?? 0,
      lineAnchor: (i == null ? void 0 : i.lineAnchor) ?? 50,
      characterOffset: (i == null ? void 0 : i.characterOffset) ?? 0,
      characterValue: (i == null ? void 0 : i.characterValue) ?? 0,
      blur: (i == null ? void 0 : i.blur) ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: (i == null ? void 0 : i.letterSpacing) ?? (i == null ? void 0 : i.tracking) ?? 0,
      lineHeight: (i == null ? void 0 : i.lineHeight) ?? (i == null ? void 0 : i.lineSpacing) ?? 1.2,
      textAlign: (i == null ? void 0 : i.textAlign) ?? "left",
      // Path options (full AE parity)
      pathLayerId: (i == null ? void 0 : i.pathLayerId) ?? null,
      pathReversed: (i == null ? void 0 : i.pathReversed) ?? !1,
      pathPerpendicularToPath: (i == null ? void 0 : i.pathPerpendicularToPath) ?? !0,
      pathForceAlignment: (i == null ? void 0 : i.pathForceAlignment) ?? !1,
      pathFirstMargin: (i == null ? void 0 : i.pathFirstMargin) ?? 0,
      pathLastMargin: (i == null ? void 0 : i.pathLastMargin) ?? 0,
      pathOffset: (i == null ? void 0 : i.pathOffset) ?? 0,
      pathAlign: (i == null ? void 0 : i.pathAlign) ?? "left",
      // More Options
      anchorPointGrouping: (i == null ? void 0 : i.anchorPointGrouping) ?? "character",
      groupingAlignment: (i == null ? void 0 : i.groupingAlignment) ?? { x: 0, y: 0 },
      fillAndStroke: (i == null ? void 0 : i.fillAndStroke) ?? "fill-over-stroke",
      interCharacterBlending: (i == null ? void 0 : i.interCharacterBlending) ?? "normal",
      // 3D
      perCharacter3D: (i == null ? void 0 : i.perCharacter3D) ?? !1
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(n) {
    if (n.properties) {
      for (const i of n.properties)
        switch (i.name) {
          case "Font Size":
            this.fontSizeProp = i;
            break;
          case "Tracking":
            this.trackingProp = i;
            break;
          case "Line Spacing":
            this.lineSpacingProp = i;
            break;
          case "Fill Color":
            this.fillColorProp = i;
            break;
          case "Stroke Color":
            this.strokeColorProp = i;
            break;
          case "Stroke Width":
            this.strokeWidthProp = i;
            break;
          case "Path Offset":
            this.pathOffsetProp = i;
            break;
          case "First Margin":
            this.firstMarginProp = i;
            break;
          case "Last Margin":
            this.lastMarginProp = i;
            break;
          case "Character Offset":
            this.characterOffsetProp = i;
            break;
        }
      this.syncPathConfig();
    }
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId, this.pathConfig.reversed = this.textData.pathReversed, this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath, this.pathConfig.forceAlignment = this.textData.pathForceAlignment, this.pathConfig.firstMargin = this.textData.pathFirstMargin, this.pathConfig.lastMargin = this.textData.pathLastMargin, this.pathConfig.offset = this.textData.pathOffset, this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const n = new xg();
    return n.text = this.textData.text, n.font = this.getFontUrl(this.textData.fontFamily) ?? null, n.fontSize = this.textData.fontSize, n.color = this.textData.fill, this.textData.stroke && this.textData.strokeWidth > 0 && (n.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, n.outlineColor = this.textData.stroke), n.letterSpacing = (this.textData.tracking || 0) / 1e3, n.lineHeight = this.textData.lineHeight || 1.2, n.textAlign = this.textData.textAlign, n.anchorX = this.getAnchorX(), n.anchorY = "middle", n.depthOffset = 0, n.renderOrder = 0, n.sync(), n;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(n) {
    return [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ].includes(n) ? void 0 : {
      Roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      Lato: "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      Montserrat: "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      Oswald: "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      Poppins: "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    }[n];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(n, i = !1) {
    this.pathControlPoints = n, this.pathClosed = i, n.length >= 2 ? (this.textOnPath.setPath(n, i), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout()) : (this.textOnPath.dispose(), this.resetPathLayout());
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(n) {
    this.textOnPath.setCurve(n), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null, this.pathConfig.pathLayerId = null, this.textOnPath.dispose(), this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup)
      return;
    this.ensureCharacterWidths();
    const n = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(n);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(n) {
    for (let i = 0; i < this.characterMeshes.length && i < n.length; i++) {
      const s = this.characterMeshes[i], o = n[i];
      s.position.copy(o.position), s.rotation.copy(o.rotation), s.scale.setScalar(o.scale), s.visible = o.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    this.textData.perCharacter3D ? this.createCharacterMeshes() : this.disablePerCharacter3D();
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const n = this.textData.text, i = this.textData.fontSize * 0.6;
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      `iIl1|!.,;:'"`.includes(o) ? this.characterWidths.push(i * 0.4) : "mwMW".includes(o) ? this.characterWidths.push(i * 1.3) : o === " " ? this.characterWidths.push(i * 0.5) : this.characterWidths.push(i);
    }
    this.characterWidthsDirty = !1;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    this.perCharacterGroup || (this.textMesh.visible = !1, this.perCharacterGroup = new ts(), this.perCharacterGroup.name = `text_chars_${this.id}`, this.group.add(this.perCharacterGroup), this.createCharacterMeshes());
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    this.perCharacterGroup && (this.textMesh.visible = !0, this.disposeCharacterMeshes(), this.group.remove(this.perCharacterGroup), this.perCharacterGroup = null);
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes(), this.characterWidthsDirty = !0;
    const n = this.textData.text;
    let i = 0;
    this.ensureCharacterWidths();
    const s = this.characterWidths.reduce((a, l) => a + l, 0) + (n.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let o = 0;
    switch (this.textData.textAlign) {
      case "center":
        o = -s / 2;
        break;
      case "right":
        o = -s;
        break;
      default:
        o = 0;
    }
    i = o;
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = new xg();
      c.text = l, c.font = this.getFontUrl(this.textData.fontFamily) ?? null, c.fontSize = this.textData.fontSize, c.color = this.textData.fill, c.anchorX = "center", c.anchorY = "middle", this.textData.stroke && this.textData.strokeWidth > 0 && (c.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, c.outlineColor = this.textData.stroke);
      const u = this.characterWidths[a];
      c.position.x = i + u / 2, c.position.y = 0, c.position.z = 0, i += u + this.textData.tracking / 1e3 * this.textData.fontSize, c.sync(), this.characterMeshes.push(c), this.perCharacterGroup.add(c);
    }
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    var n;
    for (const i of this.characterMeshes)
      i.dispose(), (n = this.perCharacterGroup) == null || n.remove(i);
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(n) {
    this.textData.text = n, this.textMesh.text = n, this.textMesh.sync(), this.characterWidthsDirty = !0, this.perCharacterGroup && this.createCharacterMeshes();
  }
  setFontFamily(n) {
    this.textData.fontFamily = n;
    const i = this.getFontUrl(n) ?? null;
    this.textMesh.font = i, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const s of this.characterMeshes)
      s.font = i, s.sync();
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setFontSize(n) {
    this.textData.fontSize = n, this.textMesh.fontSize = n, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const i of this.characterMeshes)
      i.fontSize = n, i.sync();
    this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setFillColor(n) {
    this.textData.fill = n, this.textMesh.color = n;
    for (const i of this.characterMeshes)
      i.color = n;
  }
  setStroke(n, i) {
    this.textData.stroke = n, this.textData.strokeWidth = i;
    const s = i / this.textData.fontSize;
    this.textMesh.outlineWidth = s, this.textMesh.outlineColor = n;
    for (const o of this.characterMeshes)
      o.outlineWidth = s, o.outlineColor = n;
  }
  setTracking(n) {
    this.textData.tracking = n, this.textMesh.letterSpacing = n / 1e3, this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setTextAlign(n) {
    this.textData.textAlign = n, this.textMesh.textAlign = n, this.textMesh.anchorX = this.getAnchorX(), this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? (this.pathConfig.align = n, this.updatePathLayout()) : this.createCharacterMeshes());
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(n) {
    this.textData.pathOffset = n, this.pathConfig.offset = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(n) {
    this.textData.pathFirstMargin = n, this.pathConfig.firstMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(n) {
    this.textData.pathLastMargin = n, this.pathConfig.lastMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set path reversed
   */
  setPathReversed(n) {
    this.textData.pathReversed = n, this.pathConfig.reversed = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(n) {
    this.textData.pathPerpendicularToPath = n, this.pathConfig.perpendicularToPath = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set force alignment
   */
  setForceAlignment(n) {
    this.textData.pathForceAlignment = n, this.pathConfig.forceAlignment = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setAnchorPointGrouping(n) {
    this.textData.anchorPointGrouping = n;
  }
  setFillAndStroke(n) {
    this.textData.fillAndStroke = n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, s, o, a, l, c, u;
    if ((i = this.fontSizeProp) != null && i.animated) {
      const h = this.textEvaluator.evaluate(this.fontSizeProp, n);
      this.setFontSize(h);
    }
    if ((s = this.trackingProp) != null && s.animated) {
      const h = this.textEvaluator.evaluate(this.trackingProp, n);
      this.setTracking(h);
    }
    if ((o = this.fillColorProp) != null && o.animated) {
      const h = this.textEvaluator.evaluate(this.fillColorProp, n);
      this.setFillColor(h);
    }
    if ((a = this.strokeColorProp) != null && a.animated && this.strokeWidthProp) {
      const h = this.textEvaluator.evaluate(this.strokeColorProp, n), d = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, n) : this.textData.strokeWidth;
      this.setStroke(h, d);
    }
    if (this.pathOffsetProp) {
      const h = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, n) : this.textData.pathOffset;
      this.setPathOffset(h);
    }
    if ((l = this.firstMarginProp) != null && l.animated) {
      const h = this.textEvaluator.evaluate(this.firstMarginProp, n);
      this.setFirstMargin(h);
    }
    if ((c = this.lastMarginProp) != null && c.animated) {
      const h = this.textEvaluator.evaluate(this.lastMarginProp, n);
      this.setLastMargin(h);
    }
    (u = this.characterTransforms) != null && u.animated && this.perCharacterGroup && this.applyCharacterTransforms(n);
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(n) {
    if (!this.characterTransforms) return;
    const i = this.textEvaluator.evaluate(this.characterTransforms, n);
    for (let s = 0; s < this.characterMeshes.length && s < i.length; s++) {
      const o = this.characterMeshes[s], a = i[s];
      o.position.x += a.position.x, o.position.y += a.position.y, o.position.z += a.position.z, o.rotation.x += En.degToRad(a.rotation.x), o.rotation.y += En.degToRad(a.rotation.y), o.rotation.z += En.degToRad(a.rotation.z), o.scale.x *= a.scale.x, o.scale.y *= a.scale.y, o.material && (o.material.opacity *= a.opacity);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.text !== void 0 && this.setText(i.text), i.fontFamily !== void 0 && this.setFontFamily(i.fontFamily), i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.fill !== void 0 && this.setFillColor(i.fill), (i.stroke !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.stroke ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.tracking !== void 0 && this.setTracking(i.tracking), i.textAlign !== void 0 && this.setTextAlign(i.textAlign), i.pathLayerId !== void 0 && (this.textData.pathLayerId = i.pathLayerId, this.pathConfig.pathLayerId = i.pathLayerId), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.pathFirstMargin !== void 0 && this.setFirstMargin(i.pathFirstMargin), i.pathLastMargin !== void 0 && this.setLastMargin(i.pathLastMargin), i.pathReversed !== void 0 && this.setPathReversed(i.pathReversed), i.pathPerpendicularToPath !== void 0 && this.setPerpendicularToPath(i.pathPerpendicularToPath), i.pathForceAlignment !== void 0 && this.setForceAlignment(i.pathForceAlignment), i.perCharacter3D !== void 0 && (i.perCharacter3D && !this.perCharacterGroup ? this.enablePerCharacter3D() : !i.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup && this.disablePerCharacter3D()), i.anchorPointGrouping !== void 0 && this.setAnchorPointGrouping(i.anchorPointGrouping), i.fillAndStroke !== void 0 && this.setFillAndStroke(i.fillAndStroke)), n.properties && this.extractAnimatableProperties(n);
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    var i;
    const n = (i = this.textMesh.textRenderInfo) == null ? void 0 : i.blockBounds;
    return n ? {
      width: n[2] - n[0],
      height: n[3] - n[1]
    } : { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose(), this.disposeCharacterMeshes(), this.textOnPath.dispose(), this.perCharacterGroup && this.group.remove(this.perCharacterGroup);
  }
}
class tj extends Ps {
  constructor(n) {
    super(n);
    /** The line mesh for the spline */
    pe(this, "lineMesh", null);
    /** The fill mesh (if closed path with fill) */
    pe(this, "fillMesh", null);
    /** Spline data */
    pe(this, "splineData");
    /** Cached curve for path calculations */
    pe(this, "curve", null);
    this.splineData = this.extractSplineData(n), this.buildSpline(), this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(n) {
    const i = n.data;
    return {
      controlPoints: (i == null ? void 0 : i.controlPoints) ?? [],
      closed: (i == null ? void 0 : i.closed) ?? !1,
      stroke: (i == null ? void 0 : i.stroke) ?? "#00ff00",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 2,
      fill: (i == null ? void 0 : i.fill) ?? "",
      pathData: (i == null ? void 0 : i.pathData) ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    var a, l, c, u, h, d, p, f;
    this.clearMeshes();
    const n = this.splineData.controlPoints;
    if (n.length < 2) return;
    this.curve = new rv();
    for (let m = 0; m < n.length - 1; m++) {
      const _ = n[m], g = n[m + 1], v = _.depth ?? 0, S = g.depth ?? 0, b = new $c(
        new he(_.x, -_.y, v),
        new he(
          _.x + (((a = _.handleOut) == null ? void 0 : a.x) ?? 0),
          -(_.y + (((l = _.handleOut) == null ? void 0 : l.y) ?? 0)),
          v
        ),
        new he(
          g.x + (((c = g.handleIn) == null ? void 0 : c.x) ?? 0),
          -(g.y + (((u = g.handleIn) == null ? void 0 : u.y) ?? 0)),
          S
        ),
        new he(g.x, -g.y, S)
      );
      this.curve.add(b);
    }
    if (this.splineData.closed && n.length > 2) {
      const m = n[n.length - 1], _ = n[0], g = m.depth ?? 0, v = _.depth ?? 0, S = new $c(
        new he(m.x, -m.y, g),
        new he(
          m.x + (((h = m.handleOut) == null ? void 0 : h.x) ?? 0),
          -(m.y + (((d = m.handleOut) == null ? void 0 : d.y) ?? 0)),
          g
        ),
        new he(
          _.x + (((p = _.handleIn) == null ? void 0 : p.x) ?? 0),
          -(_.y + (((f = _.handleIn) == null ? void 0 : f.y) ?? 0)),
          v
        ),
        new he(_.x, -_.y, v)
      );
      this.curve.add(S);
    }
    const i = this.curve.getPoints(n.length * 20), s = new Wt().setFromPoints(i), o = new As({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new gn(s, o), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(n) {
    if (n.length < 3) return;
    const i = new Bb();
    i.moveTo(n[0].x, n[0].y);
    for (let a = 1; a < n.length; a++)
      i.lineTo(n[a].x, n[a].y);
    i.closePath();
    const s = new lv(i), o = new Gn({
      color: this.splineData.fill,
      transparent: !0,
      side: Pn,
      depthWrite: !1
    });
    this.fillMesh = new tt(s, o), this.fillMesh.name = `spline_fill_${this.id}`, this.fillMesh.position.z = -0.1, this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    this.lineMesh && (this.group.remove(this.lineMesh), this.lineMesh.geometry.dispose(), this.lineMesh.material.dispose(), this.lineMesh = null), this.fillMesh && (this.group.remove(this.fillMesh), this.fillMesh.geometry.dispose(), this.fillMesh.material.dispose(), this.fillMesh = null), this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(n) {
    return this.curve ? this.curve.getPointAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(n) {
    return this.curve ? this.curve.getTangentAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    return this.curve ? this.curve.getLength() : 0;
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(n) {
    const i = this.getPointAt(n), s = this.getTangentAt(n);
    if (!i || !s) return null;
    const o = Math.atan2(s.y, s.x) * (180 / Math.PI);
    return { position: i, rotation: o };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(n) {
    this.splineData.stroke = n, this.lineMesh && this.lineMesh.material.color.set(n);
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(n) {
    this.splineData.strokeWidth = n, this.lineMesh && (this.lineMesh.material.linewidth = n);
  }
  /**
   * Set fill color
   */
  setFill(n) {
    if (this.splineData.fill = n, this.fillMesh)
      this.fillMesh.material.color.set(n);
    else if (n && this.splineData.closed && this.curve) {
      const i = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(i);
    }
  }
  /**
   * Update control points
   */
  setControlPoints(n) {
    this.splineData.controlPoints = n, this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(n) {
    this.splineData.closed !== n && (this.splineData.closed = n, this.buildSpline());
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    if (i) {
      let s = !1;
      i.controlPoints !== void 0 && (this.splineData.controlPoints = i.controlPoints, s = !0), i.closed !== void 0 && i.closed !== this.splineData.closed && (this.splineData.closed = i.closed, s = !0), i.stroke !== void 0 && this.setStroke(i.stroke), i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.fill !== void 0 && this.setFill(i.fill), s && this.buildSpline();
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}
const ir = 16, nj = 50;
function M_(r) {
  return {
    id: r || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: !0,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: !1,
    beatEmissionMultiplier: 5
  };
}
function ij(r, e) {
  const n = {
    id: e || `force_${Date.now()}`,
    name: r.charAt(0).toUpperCase() + r.slice(1),
    type: r,
    enabled: !0,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (r) {
    case "gravity":
      n.direction = { x: 0, y: 1, z: 0 }, n.strength = 98;
      break;
    case "vortex":
      n.vortexAxis = { x: 0, y: 0, z: 1 }, n.inwardForce = 20;
      break;
    case "turbulence":
      n.noiseScale = 5e-3, n.noiseSpeed = 0.5, n.noiseOctaves = 3, n.noiseLacunarity = 2, n.noiseGain = 0.5;
      break;
    case "drag":
      n.linearDrag = 0.1, n.quadraticDrag = 0.01;
      break;
    case "wind":
      n.windDirection = { x: 1, y: 0, z: 0 }, n.gustStrength = 50, n.gustFrequency = 0.1;
      break;
    case "lorenz":
      n.lorenzSigma = 10, n.lorenzRho = 28, n.lorenzBeta = 2.667;
      break;
  }
  return n;
}
function gS() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: !0,
      depthWrite: !1,
      depthTest: !0,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: !1,
        receiveShadows: !1,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: !1,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: !1,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: !1,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: !1,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: !1,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: nj,
    updateFrequency: 1,
    cullOffscreen: !0
  };
}
class C_ {
  constructor(e = {}) {
    pe(this, "config");
    pe(this, "gl", null);
    pe(this, "renderer", null);
    // Double-buffered particle data
    pe(this, "particleBufferA");
    pe(this, "particleBufferB");
    pe(this, "currentBuffer", "A");
    // WebGL resources
    pe(this, "transformFeedbackProgram", null);
    pe(this, "renderProgram", null);
    pe(this, "vaoA", null);
    pe(this, "vaoB", null);
    pe(this, "particleVboA", null);
    pe(this, "particleVboB", null);
    pe(this, "transformFeedbackA", null);
    pe(this, "transformFeedbackB", null);
    // Three.js integration
    pe(this, "particleMesh", null);
    pe(this, "instancedGeometry", null);
    pe(this, "material", null);
    // Textures for modulation curves
    pe(this, "sizeOverLifetimeTexture", null);
    pe(this, "opacityOverLifetimeTexture", null);
    pe(this, "colorOverLifetimeTexture", null);
    // Emitter state
    pe(this, "emitters", /* @__PURE__ */ new Map());
    pe(this, "forceFields", /* @__PURE__ */ new Map());
    pe(this, "subEmitters", /* @__PURE__ */ new Map());
    // Runtime state
    pe(this, "state", {
      particleCount: 0,
      activeEmitters: 0,
      simulationTime: 0,
      frameCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0,
      gpuMemoryBytes: 0,
      currentAudioFeatures: /* @__PURE__ */ new Map()
    });
    // Audio reactivity
    pe(this, "audioFeatures", /* @__PURE__ */ new Map());
    // Spatial hash for neighbor queries (flocking)
    pe(this, "spatialHash", /* @__PURE__ */ new Map());
    // Event system
    pe(this, "eventHandlers", /* @__PURE__ */ new Map());
    // Pool of free particle indices
    pe(this, "freeIndices", []);
    pe(this, "nextParticleIndex", 0);
    // Random number generator with seed
    pe(this, "rng");
    this.config = { ...gS(), ...e };
    const n = this.config.maxParticles * ir;
    this.particleBufferA = new Float32Array(n), this.particleBufferB = new Float32Array(n);
    for (let i = this.config.maxParticles - 1; i >= 0; i--)
      this.freeIndices.push(i);
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now()), this.config.emitters.forEach((i) => this.addEmitter(i)), this.config.forceFields.forEach((i) => this.addForceField(i)), this.config.subEmitters.forEach((i) => this.addSubEmitter(i));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(e) {
    if (this.renderer = e, this.gl = e.getContext(), !this.gl)
      throw new Error("WebGL2 context required for GPU particle system");
    this.createModulationTextures(), this.createParticleMesh(), this.state.gpuMemoryBytes = this.config.maxParticles * ir * 4 * 2;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const n = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, n), this.sizeOverLifetimeTexture = new Sc(
      n,
      256,
      1,
      gd,
      Ii
    ), this.sizeOverLifetimeTexture.needsUpdate = !0;
    const i = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, i), this.opacityOverLifetimeTexture = new Sc(
      i,
      256,
      1,
      gd,
      Ii
    ), this.opacityOverLifetimeTexture.needsUpdate = !0;
    const s = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ], o = new Float32Array(256 * 4);
    for (let a = 0; a < 256; a++) {
      const l = a / 255, c = this.sampleColorGradient(s, l);
      o[a * 4] = c[0], o[a * 4 + 1] = c[1], o[a * 4 + 2] = c[2], o[a * 4 + 3] = c[3];
    }
    this.colorOverLifetimeTexture = new Sc(
      o,
      256,
      1,
      fi,
      Ii
    ), this.colorOverLifetimeTexture.needsUpdate = !0;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(e, n) {
    const i = n.length;
    if (!e) {
      n.fill(1);
      return;
    }
    for (let s = 0; s < i; s++) {
      const o = s / (i - 1);
      n[s] = this.evaluateModulationCurve(e, o);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(e, n) {
    switch (e.type) {
      case "constant":
        return e.value;
      case "linear":
        return e.start + (e.end - e.start) * n;
      case "curve": {
        const i = e.points;
        if (i.length === 0) return 1;
        if (i.length === 1) return i[0].value;
        let s = i[0], o = i[i.length - 1];
        for (let f = 0; f < i.length - 1; f++)
          if (n >= i[f].time && n <= i[f + 1].time) {
            s = i[f], o = i[f + 1];
            break;
          }
        const a = (n - s.time) / (o.time - s.time), l = a * a, c = l * a, u = 2 * c - 3 * l + 1, h = -2 * c + 3 * l, d = c - 2 * l + a, p = c - l;
        return u * s.value + h * o.value + d * (s.outTangent ?? 0) + p * (o.inTangent ?? 0);
      }
      case "random":
        return e.min + this.rng() * (e.max - e.min);
      case "randomCurve": {
        const i = this.evaluateModulationCurve(e.minCurve, n), s = this.evaluateModulationCurve(e.maxCurve, n);
        return i + this.rng() * (s - i);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(e, n) {
    if (e.length === 0) return [1, 1, 1, 1];
    if (e.length === 1) return e[0].color;
    let i = e[0], s = e[e.length - 1];
    for (let a = 0; a < e.length - 1; a++)
      if (n >= e[a].time && n <= e[a + 1].time) {
        i = e[a], s = e[a + 1];
        break;
      }
    const o = (n - i.time) / (s.time - i.time);
    return [
      i.color[0] + (s.color[0] - i.color[0]) * o,
      i.color[1] + (s.color[1] - i.color[1]) * o,
      i.color[2] + (s.color[2] - i.color[2]) * o,
      i.color[3] + (s.color[3] - i.color[3]) * o
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const e = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]), n = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new Wb(), this.instancedGeometry.setAttribute("position", new qi(e, 2)), this.instancedGeometry.setAttribute("uv", new qi(n, 2));
    const i = new Io(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), s = new Io(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), o = new Io(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), a = new Io(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), l = new Io(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), c = new Io(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    i.setUsage(fa), s.setUsage(fa), o.setUsage(fa), a.setUsage(fa), l.setUsage(fa), c.setUsage(fa), this.instancedGeometry.setAttribute("i_position", i), this.instancedGeometry.setAttribute("i_velocity", s), this.instancedGeometry.setAttribute("i_life", o), this.instancedGeometry.setAttribute("i_physical", a), this.instancedGeometry.setAttribute("i_rotation", l), this.instancedGeometry.setAttribute("i_color", c), this.material = new si({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: !0,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    }), this.particleMesh = new tt(this.instancedGeometry, this.material), this.particleMesh.frustumCulled = !1;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    this.emitters.set(e.id, {
      ...e,
      accumulator: 0,
      velocity: new he()
    }), this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(e) {
    this.forceFields.set(e.id, e);
  }
  updateForceField(e, n) {
    const i = this.forceFields.get(e);
    i && Object.assign(i, n);
  }
  removeForceField(e) {
    this.forceFields.delete(e);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(e) {
    this.subEmitters.set(e.id, e);
  }
  removeSubEmitter(e) {
    this.subEmitters.delete(e);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(e) {
    var s;
    const n = performance.now(), i = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : e * this.config.timeScale;
    this.emitParticles(i), this.updatePhysics(i), this.processSubEmitters(), (s = this.config.flocking) != null && s.enabled && (this.updateSpatialHash(), this.applyFlocking(i)), this.applyAudioModulation(), this.updateInstanceBuffers(), this.state.simulationTime += i, this.state.frameCount++, this.state.updateTimeMs = performance.now() - n;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(e) {
    for (const n of this.emitters.values()) {
      if (!n.enabled) continue;
      let i = n.emissionRate;
      const s = this.getAudioModulation("emitter", n.id, "emissionRate");
      if (s !== void 0 && (i *= s), n.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const o = Math.floor(n.burstCount * n.beatEmissionMultiplier);
        for (let a = 0; a < o; a++)
          this.spawnParticle(n);
      }
      for (n.accumulator += i * e; n.accumulator >= 1; )
        this.spawnParticle(n), n.accumulator -= 1;
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(e) {
    if (this.freeIndices.length === 0) {
      let h = 0, d = 0;
      const p = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let f = 0; f < this.config.maxParticles; f++) {
        const m = p[f * ir + 6];
        m > d && (d = m, h = f);
      }
      this.freeIndices.push(h);
    }
    const n = this.freeIndices.pop(), i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, s = n * ir, o = this.getEmitterPosition(e), a = this.getEmissionDirection(e), l = e.initialSpeed + (this.rng() - 0.5) * 2 * e.speedVariance, c = e.velocity.clone().multiplyScalar(e.inheritEmitterVelocity);
    i[s + 0] = o.x, i[s + 1] = o.y, i[s + 2] = o.z, i[s + 3] = a.x * l + c.x, i[s + 4] = a.y * l + c.y, i[s + 5] = a.z * l + c.z, i[s + 6] = 0, i[s + 7] = e.lifetime + (this.rng() - 0.5) * 2 * e.lifetimeVariance, i[s + 8] = e.initialMass + (this.rng() - 0.5) * 2 * e.massVariance, i[s + 9] = e.initialSize + (this.rng() - 0.5) * 2 * e.sizeVariance, i[s + 10] = e.initialRotation + this.rng() * e.rotationVariance, i[s + 11] = e.initialAngularVelocity + (this.rng() - 0.5) * 2 * e.angularVelocityVariance;
    const u = this.rng() * e.colorVariance;
    return i[s + 12] = e.colorStart[0] + (e.colorEnd[0] - e.colorStart[0]) * u, i[s + 13] = e.colorStart[1] + (e.colorEnd[1] - e.colorStart[1]) * u, i[s + 14] = e.colorStart[2] + (e.colorEnd[2] - e.colorStart[2]) * u, i[s + 15] = e.colorStart[3], this.state.particleCount++, this.emit("particleBirth", { index: n, emitterId: e.id }), n;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(e) {
    const n = e.shape, i = new he(e.position.x, e.position.y, e.position.z);
    switch (n.type) {
      case "point":
        return i;
      case "circle": {
        const s = this.rng() * Math.PI * 2;
        let o = n.radius ?? 50;
        return n.emitFromEdge || (o *= Math.sqrt(this.rng())), i.add(new he(
          Math.cos(s) * o,
          Math.sin(s) * o,
          0
        ));
      }
      case "sphere": {
        const s = this.rng() * Math.PI * 2, o = Math.acos(2 * this.rng() - 1);
        let a = n.radius ?? 50;
        return n.emitFromEdge || (a *= Math.cbrt(this.rng())), i.add(new he(
          Math.sin(o) * Math.cos(s) * a,
          Math.sin(o) * Math.sin(s) * a,
          Math.cos(o) * a
        ));
      }
      case "box": {
        const s = n.boxSize ?? { x: 100, y: 100, z: 100 };
        return i.add(new he(
          (this.rng() - 0.5) * s.x,
          (this.rng() - 0.5) * s.y,
          (this.rng() - 0.5) * s.z
        ));
      }
      case "line": {
        const s = n.lineStart ?? { x: -50, y: 0, z: 0 }, o = n.lineEnd ?? { x: 50, y: 0, z: 0 }, a = this.rng();
        return i.add(new he(
          s.x + (o.x - s.x) * a,
          s.y + (o.y - s.y) * a,
          s.z + (o.z - s.z) * a
        ));
      }
      case "cone": {
        const s = this.rng() * Math.PI * 2, o = this.rng(), a = o * (n.coneRadius ?? 50), l = o * (n.coneLength ?? 100);
        return i.add(new he(
          Math.cos(s) * a,
          l,
          Math.sin(s) * a
        ));
      }
      case "image": {
        if (!n.imageData) return i;
        const { width: s, height: o, data: a } = n.imageData, l = n.emissionThreshold ?? 0.1;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * s), h = Math.floor(this.rng() * o), d = (h * s + u) * 4;
          if (a[d + 3] / 255 > l)
            return i.add(new he(
              u - s / 2,
              -(h - o / 2),
              // Flip Y for screen coords
              0
            ));
        }
        return i;
      }
      case "depthEdge": {
        if (!n.depthData || !n.imageData) return i;
        const { width: s, height: o } = n.imageData, a = n.depthData, l = n.emissionThreshold ?? 0.05;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * (s - 2)) + 1, h = Math.floor(this.rng() * (o - 2)) + 1, d = h * s + u, p = a[d], f = a[d - 1], m = a[d + 1], _ = a[d - s], g = a[d + s], v = Math.abs(m - f), S = Math.abs(g - _);
          if (Math.sqrt(v * v + S * S) > l) {
            const x = p * 500;
            return i.add(new he(
              u - s / 2,
              -(h - o / 2),
              // Flip Y for screen coords
              x
            ));
          }
        }
        return i;
      }
      default:
        return i;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(e) {
    const n = new he(
      e.emissionDirection.x,
      e.emissionDirection.y,
      e.emissionDirection.z
    ).normalize();
    if (e.emissionSpread <= 0)
      return n;
    const i = e.emissionSpread * Math.PI / 180, s = this.rng() * Math.PI * 2, o = Math.acos(1 - this.rng() * (1 - Math.cos(i))), a = Math.abs(n.y) < 0.99 ? new he(0, 1, 0) : new he(1, 0, 0), l = new he().crossVectors(a, n).normalize(), c = new he().crossVectors(n, l);
    return new he().addScaledVector(n, Math.cos(o)).addScaledVector(l, Math.sin(o) * Math.cos(s)).addScaledVector(c, Math.sin(o) * Math.sin(s)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(e) {
    const n = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const s = i * ir, o = n[s + 6], a = n[s + 7];
      if (a <= 0 || o >= a) continue;
      let l = n[s + 0], c = n[s + 1], u = n[s + 2], h = n[s + 3], d = n[s + 4], p = n[s + 5];
      const f = n[s + 8];
      let m = 0, _ = 0, g = 0;
      for (const T of this.forceFields.values()) {
        if (!T.enabled) continue;
        const w = this.calculateForceField(T, l, c, u, h, d, p, f);
        m += w.x, _ += w.y, g += w.z;
      }
      const v = m / Math.max(f, 0.1), S = _ / Math.max(f, 0.1), b = g / Math.max(f, 0.1);
      h += v * e, d += S * e, p += b * e, l += h * e, c += d * e, u += p * e;
      const x = o / a, M = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        x
      ), C = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        x
      ), E = n[s + 10] + n[s + 11] * e;
      n[s + 0] = l, n[s + 1] = c, n[s + 2] = u, n[s + 3] = h, n[s + 4] = d, n[s + 5] = p, n[s + 6] = o + e, n[s + 9] *= M, n[s + 10] = E, n[s + 15] *= C, o + e >= a && (this.freeIndices.push(i), this.state.particleCount--, this.emit("particleDeath", { index: i }));
    }
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(e, n, i, s, o, a, l, c) {
    var g, v, S, b, x, M, C, E, T;
    const u = new he(), h = n - e.position.x, d = i - e.position.y, p = s - e.position.z, f = Math.sqrt(h * h + d * d + p * p);
    let m = 1;
    if (f > e.falloffStart) {
      const w = Math.min((f - e.falloffStart) / (e.falloffEnd - e.falloffStart), 1);
      switch (e.falloffType) {
        case "linear":
          m = 1 - w;
          break;
        case "quadratic":
          m = 1 - w * w;
          break;
        case "exponential":
          m = Math.exp(-w * 3);
          break;
        case "smoothstep":
          m = 1 - (3 * w * w - 2 * w * w * w);
          break;
      }
    }
    const _ = e.strength * m;
    switch (e.type) {
      case "gravity":
        u.set(
          (((g = e.direction) == null ? void 0 : g.x) ?? 0) * _,
          (((v = e.direction) == null ? void 0 : v.y) ?? 1) * _,
          (((S = e.direction) == null ? void 0 : S.z) ?? 0) * _
        );
        break;
      case "point":
        if (f > 1e-3) {
          const w = new he(-h, -d, -p).normalize();
          u.copy(w).multiplyScalar(_ / c);
        }
        break;
      case "vortex":
        if (f > 1e-3) {
          const w = new he(
            ((b = e.vortexAxis) == null ? void 0 : b.x) ?? 0,
            ((x = e.vortexAxis) == null ? void 0 : x.y) ?? 0,
            ((M = e.vortexAxis) == null ? void 0 : M.z) ?? 1
          ).normalize(), A = new he(h, d, p), O = new he().crossVectors(w, A).normalize(), U = A.normalize().multiplyScalar(-(e.inwardForce ?? 0));
          u.copy(O).multiplyScalar(_).add(U);
        }
        break;
      case "turbulence": {
        const w = e.noiseScale ?? 0.01, A = e.noiseSpeed ?? 0.5, O = this.state.simulationTime * A, U = Math.sin(n * w + O) * Math.cos(i * w * 1.3) * _, D = Math.sin(i * w + O * 1.1) * Math.cos(s * w * 1.2) * _, L = Math.sin(s * w + O * 0.9) * Math.cos(n * w * 1.1) * _;
        u.set(U, D, L);
        break;
      }
      case "drag": {
        const w = Math.sqrt(o * o + a * a + l * l);
        if (w > 1e-3) {
          const A = (e.linearDrag ?? 0.1) * w + (e.quadraticDrag ?? 0.01) * w * w;
          u.set(-o, -a, -l).normalize().multiplyScalar(-A * _);
        }
        break;
      }
      case "wind": {
        const w = new he(
          ((C = e.windDirection) == null ? void 0 : C.x) ?? 1,
          ((E = e.windDirection) == null ? void 0 : E.y) ?? 0,
          ((T = e.windDirection) == null ? void 0 : T.z) ?? 0
        ).normalize(), A = Math.sin(this.state.simulationTime * (e.gustFrequency ?? 0.5)) * (e.gustStrength ?? 0);
        u.copy(w).multiplyScalar(_ + A);
        break;
      }
      case "lorenz": {
        const w = e.lorenzSigma ?? 10, A = e.lorenzRho ?? 28, O = e.lorenzBeta ?? 2.667;
        u.set(
          w * (d - h),
          h * (A - p) - d,
          h * d - O * p
        ).multiplyScalar(_ * 0.01);
        break;
      }
    }
    return u;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const s = i * ir;
      if (e[s + 7] <= 0) continue;
      const a = e[s + 0], l = e[s + 1], c = e[s + 2], u = Math.floor(a / n), h = Math.floor(l / n), d = Math.floor(c / n), p = `${u},${h},${d}`;
      this.spatialHash.has(p) || this.spatialHash.set(p, []), this.spatialHash.get(p).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(e) {
    const n = this.config.flocking;
    if (!(n != null && n.enabled)) return;
    const i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, s = this.config.spatialHashCellSize;
    for (let o = 0; o < this.config.maxParticles; o++) {
      const a = o * ir;
      if (i[a + 7] <= 0) continue;
      const c = i[a + 0], u = i[a + 1], h = i[a + 2], d = Math.floor(c / s), p = Math.floor(u / s), f = Math.floor(h / s), m = new he(), _ = new he(), g = new he();
      let v = 0, S = 0, b = 0;
      for (let C = d - 1; C <= d + 1; C++)
        for (let E = p - 1; E <= p + 1; E++)
          for (let T = f - 1; T <= f + 1; T++) {
            const w = this.spatialHash.get(`${C},${E},${T}`);
            if (w)
              for (const A of w) {
                if (A === o) continue;
                const O = A * ir, U = i[O + 0], D = i[O + 1], L = i[O + 2], P = c - U, V = u - D, ce = h - L, q = Math.sqrt(P * P + V * V + ce * ce);
                q < n.separationRadius && q > 0 && (m.add(new he(P, V, ce).divideScalar(q)), v++), q < n.alignmentRadius && (_.add(new he(
                  i[O + 3],
                  i[O + 4],
                  i[O + 5]
                )), S++), q < n.cohesionRadius && (g.add(new he(U, D, L)), b++);
              }
          }
      v > 0 && m.divideScalar(v).normalize().multiplyScalar(n.separationWeight), S > 0 && _.divideScalar(S).normalize().multiplyScalar(n.alignmentWeight), b > 0 && (g.divideScalar(b), g.sub(new he(c, u, h)).normalize().multiplyScalar(n.cohesionWeight));
      const x = m.add(_).add(g);
      x.length() > n.maxForce && x.normalize().multiplyScalar(n.maxForce), i[a + 3] += x.x * e, i[a + 4] += x.y * e, i[a + 5] += x.z * e;
      const M = Math.sqrt(
        i[a + 3] ** 2 + i[a + 4] ** 2 + i[a + 5] ** 2
      );
      if (M > n.maxSpeed) {
        const C = n.maxSpeed / M;
        i[a + 3] *= C, i[a + 4] *= C, i[a + 5] *= C;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const e of this.config.audioBindings) {
      const s = ((this.audioFeatures.get(e.feature) ?? 0) - e.min) / (e.max - e.min);
      let o = e.outputMin + s * (e.outputMax - e.outputMin);
      if (e.curve === "exponential" ? o = e.outputMin + Math.pow(s, 2) * (e.outputMax - e.outputMin) : e.curve === "logarithmic" && (o = e.outputMin + Math.sqrt(s) * (e.outputMax - e.outputMin)), e.target === "emitter") {
        const a = this.emitters.get(e.targetId);
        a && (a[e.parameter] = o);
      } else if (e.target === "forceField") {
        const a = this.forceFields.get(e.targetId);
        a && (a[e.parameter] = o);
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(e, n, i) {
    for (const s of this.config.audioBindings)
      if (s.target === e && s.targetId === n && s.parameter === i) {
        const a = ((this.audioFeatures.get(s.feature) ?? 0) - s.min) / (s.max - s.min);
        return s.outputMin + a * (s.outputMax - s.outputMin);
      }
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.instancedGeometry.getAttribute("i_position"), i = this.instancedGeometry.getAttribute("i_velocity"), s = this.instancedGeometry.getAttribute("i_life"), o = this.instancedGeometry.getAttribute("i_physical"), a = this.instancedGeometry.getAttribute("i_rotation"), l = this.instancedGeometry.getAttribute("i_color");
    for (let c = 0; c < this.config.maxParticles; c++) {
      const u = c * ir;
      n.setXYZ(c, e[u + 0], e[u + 1], e[u + 2]), i.setXYZ(c, e[u + 3], e[u + 4], e[u + 5]), s.setXY(c, e[u + 6], e[u + 7]), o.setXY(c, e[u + 8], e[u + 9]), a.setXY(c, e[u + 10], e[u + 11]), l.setXYZW(c, e[u + 12], e[u + 13], e[u + 14], e[u + 15]);
    }
    n.needsUpdate = !0, i.needsUpdate = !0, s.needsUpdate = !0, o.needsUpdate = !0, a.needsUpdate = !0, l.needsUpdate = !0;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(e, n) {
    this.audioFeatures.set(e, n), this.state.currentAudioFeatures.set(e, n);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1), requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(e) {
    if (e) {
      const n = this.emitters.get(e);
      if (n)
        for (let i = 0; i < n.burstCount; i++)
          this.spawnParticle(n);
    } else
      for (const n of this.emitters.values())
        if (n.burstOnBeat && n.enabled)
          for (let i = 0; i < n.burstCount; i++)
            this.spawnParticle(n);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return Gc;
      case "multiply":
        return Ja;
      case "screen":
        return Fo;
      default:
        return xs;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var s;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (s = this.eventHandlers.get(e)) == null || s.forEach((o) => o(i));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(e) {
    let n = e;
    return () => (n = n * 1103515245 + 12345 & 2147483647, n / 2147483647);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleBufferA.fill(0), this.particleBufferB.fill(0), this.freeIndices = [];
    for (let e = this.config.maxParticles - 1; e >= 0; e--)
      this.freeIndices.push(e);
    this.state.particleCount = 0, this.state.simulationTime = 0, this.state.frameCount = 0, this.spatialHash.clear();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    var e, n, i, s, o;
    (e = this.instancedGeometry) == null || e.dispose(), (n = this.material) == null || n.dispose(), (i = this.sizeOverLifetimeTexture) == null || i.dispose(), (s = this.opacityOverLifetimeTexture) == null || s.dispose(), (o = this.colorOverLifetimeTexture) == null || o.dispose(), this.emitters.clear(), this.forceFields.clear(), this.subEmitters.clear(), this.eventHandlers.clear();
  }
}
class sj extends Ps {
  constructor(n) {
    super(n);
    /** The GPU particle system instance */
    pe(this, "particleSystem");
    /** Particle system configuration */
    pe(this, "systemConfig");
    /** Whether the system has been initialized with a renderer */
    pe(this, "initialized", !1);
    /** Stored renderer reference for reinitialization */
    pe(this, "rendererRef", null);
    /** Composition FPS for time calculation */
    pe(this, "fps", 60);
    /** Performance stats */
    pe(this, "stats", {
      particleCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0
    });
    this.systemConfig = this.buildSystemConfig(n), this.particleSystem = new C_(this.systemConfig), this.initializeBlendMode();
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(n) {
    const i = n.data, s = gS();
    if (!i)
      return s.emitters = [M_("default")], s;
    if (i.systemConfig) {
      if (s.maxParticles = i.systemConfig.maxParticles ?? 1e5, s.timeScale = 1, i.systemConfig.gravity !== 0 && s.forceFields.push({
        id: "global_gravity",
        name: "Gravity",
        type: "gravity",
        enabled: !0,
        strength: i.systemConfig.gravity * 10,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        direction: { x: 0, y: 1, z: 0 }
      }), i.systemConfig.windStrength !== 0) {
        const o = (i.systemConfig.windDirection ?? 0) * Math.PI / 180;
        s.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: !0,
          strength: i.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(o),
            y: Math.sin(o),
            z: 0
          },
          gustStrength: i.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (i.systemConfig.friction > 0 && s.forceFields.push({
        id: "global_drag",
        name: "Friction",
        type: "drag",
        enabled: !0,
        strength: 1,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        linearDrag: i.systemConfig.friction,
        quadraticDrag: i.systemConfig.friction * 0.1
      }), i.systemConfig.turbulenceFields)
        for (const o of i.systemConfig.turbulenceFields)
          o.enabled && s.forceFields.push({
            id: o.id,
            name: "Turbulence",
            type: "turbulence",
            enabled: !0,
            strength: o.strength,
            position: { x: 0, y: 0, z: 0 },
            falloffStart: 0,
            falloffEnd: 1e4,
            falloffType: "none",
            noiseScale: o.scale,
            noiseSpeed: o.evolutionSpeed,
            noiseOctaves: 3,
            noiseLacunarity: 2,
            noiseGain: 0.5
          });
    }
    if (i.emitters)
      for (const o of i.emitters) {
        if (!o.enabled) continue;
        const a = (o.direction ?? 0) * Math.PI / 180, l = {
          id: o.id,
          name: o.name,
          enabled: !0,
          position: { x: o.x, y: o.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: o.emissionRate,
          emissionRateVariance: 0,
          burstCount: o.burstCount,
          burstInterval: 0,
          initialSpeed: o.speed,
          speedVariance: o.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: o.size,
          sizeVariance: o.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: o.particleLifetime,
          lifetimeVariance: o.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            1
          ],
          colorEnd: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(a),
            y: Math.sin(a),
            z: 0
          },
          emissionSpread: o.spread,
          burstOnBeat: o.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        s.emitters.push(l);
      }
    if (i.gravityWells)
      for (const o of i.gravityWells)
        o.enabled && s.forceFields.push({
          id: o.id,
          name: o.name,
          type: "point",
          enabled: !0,
          strength: o.strength,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: o.falloff === "linear" ? "linear" : o.falloff === "quadratic" ? "quadratic" : "none"
        });
    if (i.vortices)
      for (const o of i.vortices)
        o.enabled && s.forceFields.push({
          id: o.id,
          name: o.name,
          type: "vortex",
          enabled: !0,
          strength: o.strength * o.rotationSpeed,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: o.inwardPull
        });
    if (i.modulations) {
      const o = i.modulations.filter((l) => l.property === "size");
      if (o.length > 0) {
        const l = o[0];
        s.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
      const a = i.modulations.filter((l) => l.property === "opacity");
      if (a.length > 0) {
        const l = a[0];
        s.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
    }
    return i.renderOptions && (s.render.blendMode = i.renderOptions.blendMode ?? "normal", s.render.motionBlur = i.renderOptions.motionBlur ?? !1, s.render.motionBlurStrength = i.renderOptions.motionBlurStrength ?? 0.5, s.render.motionBlurSamples = i.renderOptions.motionBlurSamples ?? 4, i.renderOptions.renderTrails && (s.render.mode = "trail", s.render.trailLength = i.renderOptions.trailLength, s.render.trailWidthEnd = 1 - (i.renderOptions.trailOpacityFalloff ?? 0.8)), s.render.texture.proceduralType = i.renderOptions.particleShape === "star" ? "star" : i.renderOptions.particleShape === "square" ? "square" : "circle"), s;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(n) {
    if (this.initialized) return;
    this.rendererRef = n, this.particleSystem.initialize(n), this.initialized = !0;
    const i = this.particleSystem.getMesh();
    i && this.group.add(i);
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(n) {
    this.rendererRef = n, this.initialized || this.initializeWithRenderer(n);
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.fps = n;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(n) {
    const i = M_();
    return n && Object.assign(i, n), this.particleSystem.addEmitter(i), i.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(n, i) {
    this.particleSystem.updateEmitter(n, i);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(n) {
    this.particleSystem.removeEmitter(n);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(n, i) {
    const s = ij(n);
    return i && Object.assign(s, i), this.particleSystem.addForceField(s), s.id;
  }
  /**
   * Update a force field
   */
  updateForceField(n, i) {
    this.particleSystem.updateForceField(n, i);
  }
  /**
   * Remove a force field
   */
  removeForceField(n) {
    this.particleSystem.removeForceField(n);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(n, i) {
    this.particleSystem.setAudioFeature(n, i);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(n) {
    this.particleSystem.triggerBurst(n);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(n) {
    if (!this.initialized) return;
    this.particleSystem.step(n);
    const i = this.particleSystem.getState();
    this.stats.particleCount = i.particleCount, this.stats.updateTimeMs = i.updateTimeMs, this.stats.renderTimeMs = i.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleSystem.reset();
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    const i = 1 / this.fps;
    this.step(i);
  }
  onUpdate(n) {
    if (n.data) {
      const s = this.particleSystem.getMesh();
      s && this.group.remove(s), this.systemConfig = this.buildSystemConfig({
        ...n,
        id: this.id,
        type: "particles"
      }), this.particleSystem.dispose(), this.particleSystem = new C_(this.systemConfig), this.rendererRef && (this.initialized = !1, this.initializeWithRenderer(this.rendererRef));
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}
class rj extends Ps {
  constructor(n) {
    super(n);
    // Precomp data
    pe(this, "precompData");
    // Render context (provided by LayerManager)
    pe(this, "renderContext", null);
    // Display mesh
    pe(this, "mesh", null);
    pe(this, "material", null);
    // Cached render texture
    pe(this, "renderTexture", null);
    // Animation evaluator for time remap
    pe(this, "precompEvaluator");
    // Cached composition reference
    pe(this, "cachedComposition", null);
    // Parent composition FPS for frame rate conversion
    pe(this, "parentFPS", 30);
    this.precompEvaluator = new hu(), this.precompData = this.extractPrecompData(n), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(n) {
    const i = n.data;
    return {
      compositionId: (i == null ? void 0 : i.compositionId) ?? "",
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      collapseTransformations: (i == null ? void 0 : i.collapseTransformations) ?? !1,
      overrideFrameRate: (i == null ? void 0 : i.overrideFrameRate) ?? !1,
      frameRate: i == null ? void 0 : i.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new yn(1, 1);
    this.material = new Gn({
      color: 4473924,
      transparent: !0,
      side: Pn
    }), this.mesh = new tt(n, this.material), this.mesh.name = `precomp_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(n) {
    this.renderContext = n, this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(n) {
    this.parentFPS = n;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    !this.renderContext || !this.precompData.compositionId || (this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    ), this.cachedComposition && this.resizeMesh(
      this.cachedComposition.settings.width,
      this.cachedComposition.settings.height
    ));
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new yn(n, i));
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(n) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const i = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, n) : this.precompData.timeRemap.value, s = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(i * s);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const i = this.parentFPS, s = this.precompData.frameRate;
      return Math.floor(n * (s / i));
    }
    return n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.renderContext || !this.cachedComposition)
      return;
    const i = this.calculateNestedFrame(n), s = Math.max(
      0,
      Math.min(i, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      s
    ), this.material && (this.renderTexture ? (this.material.map = this.renderTexture, this.material.color.setHex(16777215)) : (this.material.map = null, this.material.color.setHex(4473924)), this.material.needsUpdate = !0);
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(n) {
    this.precompData.compositionId = n, this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(n) {
    this.precompData.timeRemapEnabled = n;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(n) {
    this.precompData.timeRemap = n;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(n) {
    this.precompData.collapseTransformations = n;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(n, i) {
    this.precompData.overrideFrameRate = n, this.precompData.frameRate = i;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.compositionId !== void 0 && this.setComposition(i.compositionId), i.timeRemapEnabled !== void 0 && this.setTimeRemapEnabled(i.timeRemapEnabled), i.timeRemap !== void 0 && this.setTimeRemap(i.timeRemap), i.collapseTransformations !== void 0 && this.setCollapseTransformations(i.collapseTransformations), (i.overrideFrameRate !== void 0 || i.frameRate !== void 0) && this.setFrameRateOverride(
      i.overrideFrameRate ?? this.precompData.overrideFrameRate,
      i.frameRate ?? this.precompData.frameRate
    ));
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh)), this.renderTexture = null, this.cachedComposition = null;
  }
}
class oj extends Ps {
  constructor(n) {
    super(n);
    // Camera data reference
    pe(this, "cameraData");
    // Callbacks to store
    pe(this, "cameraGetter");
    pe(this, "cameraAtFrameGetter");
    pe(this, "cameraUpdater");
    // Track current frame for interpolation
    pe(this, "currentFrame", 0);
    // Visual wireframe (shown in editor)
    pe(this, "wireframe", null);
    pe(this, "wireframeVisible", !0);
    // Frustum visualization
    pe(this, "frustumHelper", null);
    pe(this, "showFrustum", !0);
    // Track last camera state for frustum updates
    pe(this, "lastFrustumState", null);
    this.threeD = !0, this.cameraData = this.extractCameraData(n), this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(n) {
    const i = n.data;
    return {
      cameraId: (i == null ? void 0 : i.cameraId) ?? "",
      isActiveCamera: (i == null ? void 0 : i.isActiveCamera) ?? !1
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(n, i, s) {
    this.cameraGetter = n, this.cameraUpdater = i, this.cameraAtFrameGetter = s;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new ts(), this.wireframe.name = `camera_wireframe_${this.id}`;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200, i = 40, s = new Cn(i, i * 0.6, i * 0.8), o = new Gn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), a = new tt(s, o);
    this.wireframe.add(a);
    const l = new ov(i * 0.3, i * 0.6, 8), c = new Gn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.6,
      depthTest: !1
    }), u = new tt(l, c);
    u.rotation.x = Math.PI / 2, u.position.z = i * 0.7, this.wireframe.add(u);
    const h = new yn(i * 0.8, i * 0.5), d = new Gn({
      color: n,
      transparent: !0,
      opacity: 0.2,
      side: Pn,
      depthTest: !1
    }), p = new tt(h, d);
    p.position.z = -i * 0.4, this.wireframe.add(p);
    const f = [
      new he(0, i * 0.4, 0),
      new he(0, i * 0.7, 0),
      new he(-i * 0.1, i * 0.55, 0),
      new he(0, i * 0.7, 0),
      new he(i * 0.1, i * 0.55, 0)
    ], m = new Wt().setFromPoints(f), _ = new As({
      color: 65280,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), g = new gn(m, _);
    this.wireframe.add(g), this.group.add(this.wireframe), this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const n = this.getCamera();
    if (!n) return;
    this.frustumHelper = new ts(), this.frustumHelper.name = `camera_frustum_${this.id}`;
    const i = this.cameraData.isActiveCamera ? 43775 : 16755200, s = n.nearClip, o = Math.min(n.farClip, 2e3), a = n.angleOfView * (Math.PI / 180), l = 16 / 9, c = 2 * Math.tan(a / 2) * s, u = c * l, h = 2 * Math.tan(a / 2) * o, d = h * l, p = new As({
      color: i,
      transparent: !0,
      opacity: 0.3,
      depthTest: !1
    }), f = new he(-u / 2, c / 2, s), m = new he(u / 2, c / 2, s), _ = new he(-u / 2, -c / 2, s), g = new he(u / 2, -c / 2, s), v = new he(-d / 2, h / 2, o), S = new he(d / 2, h / 2, o), b = new he(-d / 2, -h / 2, o), x = new he(d / 2, -h / 2, o), M = new Wt().setFromPoints([
      f,
      m,
      g,
      _,
      f
    ]);
    this.frustumHelper.add(new gn(M, p));
    const C = new Wt().setFromPoints([
      v,
      S,
      x,
      b,
      v
    ]);
    this.frustumHelper.add(new gn(C, p));
    const E = [
      [f, v],
      [m, S],
      [_, b],
      [g, x]
    ];
    for (const [T, w] of E) {
      const A = new Wt().setFromPoints([T, w]);
      this.frustumHelper.add(new gn(A, p));
    }
    this.group.add(this.frustumHelper), this.frustumHelper.renderOrder = 997, this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((i) => {
      if (i instanceof tt || i instanceof gn) {
        const s = i.material;
        if (s.color.getHex() === 65280) return;
        s.color.setHex(n);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    return !this.cameraGetter || !this.cameraData.cameraId ? null : this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    return this.cameraData.cameraId ? this.cameraAtFrameGetter ? this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame) : this.getCamera() : null;
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(n) {
    this.cameraData.isActiveCamera = n, this.updateWireframeColor(), this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum(), this.createFrustum());
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(n) {
    this.wireframeVisible = n, this.wireframe && (this.wireframe.visible = n);
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(n) {
    this.showFrustum = n, this.frustumHelper && (this.frustumHelper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.currentFrame = n;
    const i = this.getCameraAtCurrentFrame();
    if (!i) return;
    this.group.position.set(
      i.position.x,
      i.position.y,
      i.position.z
    );
    const s = Math.PI / 180;
    if (i.type === "two-node" && i.pointOfInterest) {
      const l = new he(
        i.pointOfInterest.x,
        i.pointOfInterest.y,
        i.pointOfInterest.z
      );
      this.group.lookAt(l), this.group.rotation.z += i.zRotation * s;
    } else
      this.group.rotation.set(
        (i.orientation.x + i.xRotation) * s,
        (i.orientation.y + i.yRotation) * s,
        (i.orientation.z + i.zRotation) * s,
        "YXZ"
        // Standard After Effects rotation order
      );
    const o = {
      fov: i.angleOfView,
      near: i.nearClip,
      far: i.farClip
    };
    (!this.lastFrustumState || this.lastFrustumState.fov !== o.fov || this.lastFrustumState.near !== o.near || this.lastFrustumState.far !== o.far) && (this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum(), this.lastFrustumState = o);
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.cameraId !== void 0 && (this.cameraData.cameraId = i.cameraId, this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum()), i.isActiveCamera !== void 0 && this.setActiveCamera(i.isActiveCamera));
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const n = this.getCameraAtCurrentFrame();
    return n ? {
      position: { ...n.position },
      rotation: {
        x: n.orientation.x + n.xRotation,
        y: n.orientation.y + n.yRotation,
        z: n.orientation.z + n.zRotation
      },
      fov: n.angleOfView,
      focalLength: n.focalLength,
      nearClip: n.nearClip,
      farClip: n.farClip
    } : null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    this.wireframe && (this.wireframe.traverse((n) => {
      (n instanceof tt || n instanceof gn) && (n.geometry.dispose(), n.material.dispose());
    }), this.wireframe.clear(), this.wireframe = null);
  }
  disposeFrustum() {
    this.frustumHelper && (this.frustumHelper.traverse((n) => {
      n instanceof gn && (n.geometry.dispose(), n.material.dispose());
    }), this.frustumHelper.clear(), this.frustumHelper = null);
  }
  onDispose() {
    this.disposeWireframe(), this.disposeFrustum();
  }
}
class aj extends Ps {
  constructor(n) {
    super(n);
    pe(this, "light");
    pe(this, "helper", null);
    pe(this, "lightData");
    this.lightData = this.extractLightData(n), this.light = this.createLight(), this.group.add(this.light), this.createHelper(), this.initializeBlendMode();
  }
  /**
   * Extract light data from layer object
   */
  extractLightData(n) {
    const i = n.data;
    return {
      lightType: (i == null ? void 0 : i.lightType) ?? "point",
      color: (i == null ? void 0 : i.color) ?? "#ffffff",
      intensity: (i == null ? void 0 : i.intensity) ?? 100,
      radius: (i == null ? void 0 : i.radius) ?? 500,
      falloff: (i == null ? void 0 : i.falloff) ?? "none",
      falloffDistance: (i == null ? void 0 : i.falloffDistance) ?? 500,
      castShadows: (i == null ? void 0 : i.castShadows) ?? !1,
      shadowDarkness: (i == null ? void 0 : i.shadowDarkness) ?? 100,
      shadowDiffusion: (i == null ? void 0 : i.shadowDiffusion) ?? 0,
      coneAngle: (i == null ? void 0 : i.coneAngle) ?? 90,
      coneFeather: (i == null ? void 0 : i.coneFeather) ?? 50,
      animatedIntensity: i == null ? void 0 : i.animatedIntensity,
      animatedConeAngle: i == null ? void 0 : i.animatedConeAngle
    };
  }
  /**
   * Create the Three.js light based on type
   */
  createLight() {
    const n = new Tt(this.lightData.color), i = this.lightData.intensity / 100;
    switch (this.lightData.lightType) {
      case "point": {
        const s = new Yl(n, i);
        return s.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, s.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, this.configureShadows(s), s;
      }
      case "spot": {
        const s = new Wr(n, i);
        return s.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, s.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, s.angle = En.degToRad((this.lightData.coneAngle ?? 90) / 2), s.penumbra = (this.lightData.coneFeather ?? 50) / 100, this.configureShadows(s), s;
      }
      case "parallel": {
        const s = new Va(n, i);
        return this.configureShadows(s), s;
      }
      case "ambient":
        return new Hb(n, i);
      default:
        return console.warn(`[LightLayer] Unknown light type: ${this.lightData.lightType}, defaulting to point`), new Yl(n, i);
    }
  }
  /**
   * Configure shadow settings for shadow-capable lights
   */
  configureShadows(n) {
    n.castShadow = this.lightData.castShadows, n.castShadow && (n.shadow.mapSize.width = 1024, n.shadow.mapSize.height = 1024, n.shadow.bias = -1e-4 * (100 - this.lightData.shadowDarkness) / 100, n.shadow.radius = 1 + this.lightData.shadowDiffusion / 10, (n instanceof Wr || n instanceof Va) && (n.shadow.camera.near = 1, n.shadow.camera.far = this.lightData.falloffDistance * 2));
  }
  /**
   * Create helper visualization for the editor
   */
  createHelper() {
    switch (this.helper && (this.group.remove(this.helper), this.helper.dispose && this.helper.dispose()), this.lightData.lightType) {
      case "point": {
        const n = new Z3(this.light, this.lightData.radius / 10);
        this.helper = n, this.group.add(n);
        break;
      }
      case "spot": {
        const n = new Tp(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
      case "parallel": {
        const n = new J3(this.light, 50);
        this.helper = n, this.group.add(n);
        break;
      }
    }
  }
  /**
   * Update light type (requires recreating the light)
   */
  setLightType(n) {
    n !== this.lightData.lightType && (this.lightData.lightType = n, this.group.remove(this.light), this.light.dispose && this.light.dispose(), this.light = this.createLight(), this.group.add(this.light), this.createHelper());
  }
  /**
   * Set light color
   */
  setColor(n) {
    this.lightData.color = n, this.light.color.set(n);
  }
  /**
   * Set light intensity
   */
  setIntensity(n) {
    this.lightData.intensity = n, this.light.intensity = n / 100;
  }
  /**
   * Set falloff distance
   */
  setFalloffDistance(n) {
    this.lightData.falloffDistance = n, (this.light instanceof Yl || this.light instanceof Wr) && (this.light.distance = this.lightData.falloff === "none" ? 0 : n);
  }
  /**
   * Set cone angle (spot lights only)
   */
  setConeAngle(n) {
    this.light instanceof Wr && (this.lightData.coneAngle = n, this.light.angle = En.degToRad(n / 2), this.helper instanceof Tp && this.helper.update());
  }
  /**
   * Set cone feather (spot lights only)
   */
  setConeFeather(n) {
    this.light instanceof Wr && (this.lightData.coneFeather = n, this.light.penumbra = n / 100);
  }
  /**
   * Toggle shadow casting
   */
  setCastShadows(n) {
    this.lightData.castShadows = n, (this.light instanceof Yl || this.light instanceof Wr || this.light instanceof Va) && (this.light.castShadow = n);
  }
  /**
   * Get the underlying Three.js light
   */
  getLight() {
    return this.light;
  }
  /**
   * Get light data
   */
  getLightData() {
    return { ...this.lightData };
  }
  /**
   * Show/hide editor helper
   */
  setHelperVisible(n) {
    this.helper && (this.helper.visible = n);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    if (this.lightData.animatedIntensity) {
      const i = this.evaluator.evaluate(this.lightData.animatedIntensity, n);
      this.light.intensity = i / 100;
    }
    if (this.lightData.animatedConeAngle && this.light instanceof Wr) {
      const i = this.evaluator.evaluate(this.lightData.animatedConeAngle, n);
      this.light.angle = En.degToRad(i / 2), this.helper instanceof Tp && this.helper.update();
    }
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.lightType !== void 0 && i.lightType !== this.lightData.lightType && this.setLightType(i.lightType), i.color !== void 0 && this.setColor(i.color), i.intensity !== void 0 && this.setIntensity(i.intensity), i.falloffDistance !== void 0 && this.setFalloffDistance(i.falloffDistance), i.falloff !== void 0 && (this.lightData.falloff = i.falloff, this.setFalloffDistance(this.lightData.falloffDistance)), i.coneAngle !== void 0 && this.setConeAngle(i.coneAngle), i.coneFeather !== void 0 && this.setConeFeather(i.coneFeather), i.castShadows !== void 0 && this.setCastShadows(i.castShadows), (i.shadowDarkness !== void 0 || i.shadowDiffusion !== void 0) && (this.lightData.shadowDarkness = i.shadowDarkness ?? this.lightData.shadowDarkness, this.lightData.shadowDiffusion = i.shadowDiffusion ?? this.lightData.shadowDiffusion, (this.light instanceof Yl || this.light instanceof Wr || this.light instanceof Va) && this.configureShadows(this.light)), i.animatedIntensity !== void 0 && (this.lightData.animatedIntensity = i.animatedIntensity), i.animatedConeAngle !== void 0 && (this.lightData.animatedConeAngle = i.animatedConeAngle));
  }
  onDispose() {
    this.light.dispose && this.light.dispose(), this.helper && this.helper.dispose && this.helper.dispose();
  }
}
const lj = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, cj = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class uj extends Ps {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Textures
    pe(this, "sourceTexture", null);
    pe(this, "depthTexture", null);
    // Mesh and material
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    // Layer data
    pe(this, "depthflowData");
    // Dimensions
    pe(this, "width", 1920);
    pe(this, "height", 1080);
    // Animation state
    pe(this, "animationTime", 0);
    this.resources = i, this.depthflowData = this.extractDepthflowData(n), this.geometry = new yn(this.width, this.height), this.material = new si({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new ct(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: lj,
      fragmentShader: cj,
      transparent: !0,
      side: Pn,
      depthWrite: !1
    }), this.mesh = new tt(this.geometry, this.material), this.mesh.name = `depthflow_${this.id}`, this.group.add(this.mesh), this.loadTextures(), this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(n) {
    var s, o, a, l, c, u, h, d, p, f, m, _, g, v;
    const i = n.data;
    return {
      sourceLayerId: (i == null ? void 0 : i.sourceLayerId) ?? "",
      depthLayerId: (i == null ? void 0 : i.depthLayerId) ?? "",
      config: {
        preset: ((s = i == null ? void 0 : i.config) == null ? void 0 : s.preset) ?? "static",
        zoom: ((o = i == null ? void 0 : i.config) == null ? void 0 : o.zoom) ?? 1,
        offsetX: ((a = i == null ? void 0 : i.config) == null ? void 0 : a.offsetX) ?? 0,
        offsetY: ((l = i == null ? void 0 : i.config) == null ? void 0 : l.offsetY) ?? 0,
        rotation: ((c = i == null ? void 0 : i.config) == null ? void 0 : c.rotation) ?? 0,
        depthScale: ((u = i == null ? void 0 : i.config) == null ? void 0 : u.depthScale) ?? 0.1,
        focusDepth: ((h = i == null ? void 0 : i.config) == null ? void 0 : h.focusDepth) ?? 0.5,
        dollyZoom: ((d = i == null ? void 0 : i.config) == null ? void 0 : d.dollyZoom) ?? 0,
        orbitRadius: ((p = i == null ? void 0 : i.config) == null ? void 0 : p.orbitRadius) ?? 0.1,
        orbitSpeed: ((f = i == null ? void 0 : i.config) == null ? void 0 : f.orbitSpeed) ?? 1,
        swingAmplitude: ((m = i == null ? void 0 : i.config) == null ? void 0 : m.swingAmplitude) ?? 0.05,
        swingFrequency: ((_ = i == null ? void 0 : i.config) == null ? void 0 : _.swingFrequency) ?? 1,
        edgeDilation: ((g = i == null ? void 0 : i.config) == null ? void 0 : g.edgeDilation) ?? 0,
        inpaintEdges: ((v = i == null ? void 0 : i.config) == null ? void 0 : v.inpaintEdges) ?? !1
      },
      animatedZoom: i == null ? void 0 : i.animatedZoom,
      animatedOffsetX: i == null ? void 0 : i.animatedOffsetX,
      animatedOffsetY: i == null ? void 0 : i.animatedOffsetY,
      animatedRotation: i == null ? void 0 : i.animatedRotation,
      animatedDepthScale: i == null ? void 0 : i.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      n && (this.sourceTexture = n, this.material.uniforms.sourceTexture.value = n, n.image && this.setDimensions(n.image.width, n.image.height));
    }
    if (this.depthflowData.depthLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      n && (this.depthTexture = n, this.material.uniforms.depthTexture.value = n);
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(n) {
    const i = this.resources.getLayerTexture(n);
    return i || (console.warn(`[DepthflowLayer] Could not load texture for layer ${n}`), null);
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new yn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Set source layer
   */
  async setSourceLayer(n) {
    var s;
    this.depthflowData.sourceLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((s = this.sourceTexture) == null || s.dispose(), this.sourceTexture = i, this.material.uniforms.sourceTexture.value = i);
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(n) {
    var s;
    this.depthflowData.depthLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((s = this.depthTexture) == null || s.dispose(), this.depthTexture = i, this.material.uniforms.depthTexture.value = i);
  }
  /**
   * Update config values
   */
  updateConfig(n) {
    Object.assign(this.depthflowData.config, n), n.depthScale !== void 0 && (this.material.uniforms.depthScale.value = n.depthScale), n.focusDepth !== void 0 && (this.material.uniforms.focusDepth.value = n.focusDepth), n.zoom !== void 0 && (this.material.uniforms.zoom.value = n.zoom), n.rotation !== void 0 && (this.material.uniforms.rotation.value = En.degToRad(n.rotation)), n.edgeDilation !== void 0 && (this.material.uniforms.edgeDilation.value = n.edgeDilation);
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(n, i = 30) {
    const s = this.depthflowData.config, o = this.outPoint - this.inPoint, a = o > 0 ? (n - this.inPoint) / o : 0, l = n / i;
    let c = s.zoom, u = s.offsetX, h = s.offsetY, d = s.rotation;
    switch (s.preset) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + a * 0.5;
        break;
      case "zoom_out":
        c = 1.5 - a * 0.5;
        break;
      case "dolly_zoom_in":
        c = 1 + a * 0.5, this.material.uniforms.depthScale.value = s.depthScale * (1 + s.dollyZoom * a);
        break;
      case "dolly_zoom_out":
        c = 1.5 - a * 0.5, this.material.uniforms.depthScale.value = s.depthScale * (1 + s.dollyZoom * (1 - a));
        break;
      case "pan_left":
        u = a * 0.2;
        break;
      case "pan_right":
        u = -a * 0.2;
        break;
      case "pan_up":
        h = a * 0.2;
        break;
      case "pan_down":
        h = -a * 0.2;
        break;
      case "circle_cw":
        u = Math.sin(a * Math.PI * 2) * s.orbitRadius, h = Math.cos(a * Math.PI * 2) * s.orbitRadius;
        break;
      case "circle_ccw":
        u = -Math.sin(a * Math.PI * 2) * s.orbitRadius, h = Math.cos(a * Math.PI * 2) * s.orbitRadius;
        break;
      case "horizontal_swing":
        u = Math.sin(l * s.swingFrequency * Math.PI * 2) * s.swingAmplitude;
        break;
      case "vertical_swing":
        h = Math.sin(l * s.swingFrequency * Math.PI * 2) * s.swingAmplitude;
        break;
    }
    return { zoom: c, offsetX: u, offsetY: h, rotation: d };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.depthflowData.config;
    const i = this.calculatePresetValues(n);
    let s = i.zoom, o = i.offsetX, a = i.offsetY, l = i.rotation;
    this.depthflowData.animatedZoom && (s = this.evaluator.evaluate(this.depthflowData.animatedZoom, n)), this.depthflowData.animatedOffsetX && (o = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, n)), this.depthflowData.animatedOffsetY && (a = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, n)), this.depthflowData.animatedRotation && (l = this.evaluator.evaluate(this.depthflowData.animatedRotation, n)), this.depthflowData.animatedDepthScale && (this.material.uniforms.depthScale.value = this.evaluator.evaluate(
      this.depthflowData.animatedDepthScale,
      n
    )), s = this.getDrivenOrBase("depthflow.zoom", s), o = this.getDrivenOrBase("depthflow.offsetX", o), a = this.getDrivenOrBase("depthflow.offsetY", a), l = this.getDrivenOrBase("depthflow.rotation", l), this.material.uniforms.zoom.value = s, this.material.uniforms.offset.value.set(o, a), this.material.uniforms.rotation.value = En.degToRad(l), this.material.uniforms.time.value = n / 30, this.material.needsUpdate = !0;
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.sourceLayerId !== void 0 && i.sourceLayerId !== this.depthflowData.sourceLayerId && this.setSourceLayer(i.sourceLayerId), i.depthLayerId !== void 0 && i.depthLayerId !== this.depthflowData.depthLayerId && this.setDepthLayer(i.depthLayerId), i.config && this.updateConfig(i.config), i.animatedZoom !== void 0 && (this.depthflowData.animatedZoom = i.animatedZoom), i.animatedOffsetX !== void 0 && (this.depthflowData.animatedOffsetX = i.animatedOffsetX), i.animatedOffsetY !== void 0 && (this.depthflowData.animatedOffsetY = i.animatedOffsetY), i.animatedRotation !== void 0 && (this.depthflowData.animatedRotation = i.animatedRotation), i.animatedDepthScale !== void 0 && (this.depthflowData.animatedDepthScale = i.animatedDepthScale));
  }
  onDispose() {
    var n, i;
    (n = this.sourceTexture) == null || n.dispose(), (i = this.depthTexture) == null || i.dispose(), this.geometry.dispose(), this.material.dispose();
  }
}
class hj {
  constructor(e, n) {
    pe(this, "scene");
    pe(this, "resources");
    pe(this, "layers");
    // Callbacks
    pe(this, "onVideoMetadataLoaded");
    pe(this, "precompRenderContext", null);
    pe(this, "cameraGetter");
    pe(this, "cameraAtFrameGetter");
    pe(this, "cameraUpdater");
    // Renderer reference for particle systems
    pe(this, "rendererRef", null);
    // Composition FPS for particle timing
    pe(this, "compositionFPS", 60);
    // Camera reference for particles
    pe(this, "cameraRef", null);
    // Audio reactive callback
    pe(this, "audioReactiveGetter", null);
    this.scene = e, this.resources = n, this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(e) {
    this.onVideoMetadataLoaded = e;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(e) {
    this.precompRenderContext = e;
    for (const n of this.layers.values())
      n.type === "precomp" && n.setRenderContext(e);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(e, n, i) {
    this.cameraGetter = e, this.cameraUpdater = n, this.cameraAtFrameGetter = i;
    for (const s of this.layers.values())
      s.type === "camera" && s.setCameraCallbacks(e, n, i);
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(e) {
    this.rendererRef = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setRenderer(e);
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(e) {
    this.compositionFPS = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setFPS(e), n.type === "video" && n.setFPS(e), n.type === "precomp" && n.setFPS(e);
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(e) {
    this.cameraRef = e;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(e) {
    if (this.layers.has(e.id))
      return console.warn(`[LayerManager] Layer ${e.id} already exists, updating instead`), this.update(e.id, e), this.layers.get(e.id);
    const n = this.createLayerInstance(e);
    if (this.layers.set(e.id, n), this.setupLayerCallbacks(n, e), e.parentId) {
      const i = this.layers.get(e.parentId);
      i && n.setParent(i);
    }
    return n.hasParent() || this.scene.addToComposition(n.getObject()), n;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(e, n) {
    if (e.type === "video" && this.onVideoMetadataLoaded && e.setMetadataCallback((s) => {
      this.onVideoMetadataLoaded(n.id, s);
    }), e.type === "precomp" && this.precompRenderContext && e.setRenderContext(this.precompRenderContext), e.type === "camera" && this.cameraGetter && this.cameraUpdater && e.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter), e.type === "particles") {
      const i = e;
      this.rendererRef && i.setRenderer(this.rendererRef), i.setFPS(this.compositionFPS);
    }
    e.type === "video" && e.setFPS(this.compositionFPS), e.type === "precomp" && e.setFPS(this.compositionFPS);
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(e) {
    switch (e.type) {
      case "image":
        return new t7(e, this.resources);
      case "solid":
        return new n7(e);
      case "null":
        return new l_(e);
      case "text":
        return new ej(e, this.resources);
      case "spline":
        return new tj(e);
      case "particles":
        return new sj(e);
      case "video":
        return new hk(e, this.resources);
      case "precomp":
        return new rj(e);
      case "camera":
        return new oj(e);
      case "light":
        return new aj(e);
      case "depthflow":
        return new uj(e, this.resources);
      default:
        return console.warn(`[LayerManager] Unknown layer type: ${e.type}, creating NullLayer`), new l_(e);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(e, n) {
    const i = this.layers.get(e);
    if (!i) {
      console.warn(`[LayerManager] Layer ${e} not found for update`);
      return;
    }
    i.update(n);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(e) {
    for (const { id: n, properties: i } of e)
      this.update(n, i);
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(e) {
    const n = this.layers.get(e);
    if (!n) {
      console.warn(`[LayerManager] Layer ${e} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(n.getObject()), n.dispose(), this.layers.delete(e);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(e) {
    for (const n of e)
      this.remove(n);
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [e, n] of this.layers)
      this.scene.removeFromComposition(n.getObject()), n.dispose();
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all layers at a given frame
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(e, n) {
    this.updateTextPathConnections();
    const i = n ?? this.audioReactiveGetter;
    for (const s of this.layers.values()) {
      if (i) {
        const o = i(s.id, e);
        o.size > 0 && s.setAudioReactiveValues(o);
      }
      s.evaluateFrame(e);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    const i = this.layers.get(e);
    i && i.setDrivenValues(n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    const n = this.layers.get(e);
    n && n.clearDrivenValues();
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const e of this.layers.values())
      e.clearDrivenValues();
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   */
  updateTextPathConnections() {
    for (const e of this.layers.values())
      if (e.type === "text") {
        const n = e, i = n.getTextData();
        if (i.pathLayerId) {
          const s = this.layers.get(i.pathLayerId);
          if (s && s.type === "spline") {
            const o = s.getCurve();
            o && n.setPathFromCurve(o);
          }
        }
      }
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(e, n) {
    const i = this.layers.get(e);
    if (!i || i.type !== "text") {
      console.warn(`[LayerManager] Text layer ${e} not found`);
      return;
    }
    if (!n) {
      i.clearPath();
      return;
    }
    const s = this.layers.get(n);
    if (!s || s.type !== "spline") {
      console.warn(`[LayerManager] Spline layer ${n} not found`);
      return;
    }
    const o = s.getCurve();
    o && i.setPathFromCurve(o);
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(e) {
    var n;
    return ((n = this.layers.get(e)) == null ? void 0 : n.getObject()) ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(e) {
    return this.layers.get(e) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(e) {
    return Array.from(this.layers.values()).filter(
      (n) => n.type === e
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(e) {
    return this.layers.has(e);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const e of this.layers.values())
      if (e.hasParent()) {
        const n = e.getParent();
        n && n.getObject().remove(e.getObject());
      }
    for (const e of this.layers.values()) {
      const n = e.getParentId();
      if (n) {
        const i = this.layers.get(n);
        i ? e.setParent(i) : (e.setParent(null), this.scene.addToComposition(e.getObject()));
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(e, n) {
    const i = this.layers.get(e);
    if (i) {
      if (i.hasParent()) {
        const s = i.getParent();
        s && s.getObject().remove(i.getObject());
      } else
        this.scene.removeFromComposition(i.getObject());
      if (n) {
        const s = this.layers.get(n);
        s ? i.setParent(s) : (i.setParent(null), this.scene.addToComposition(i.getObject()));
      } else
        i.setParent(null), this.scene.addToComposition(i.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(e, n) {
    const i = this.layers.get(e);
    i && (i.getObject().position.z = n, this.scene.sortByZ());
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(e, n) {
    const i = this.layers.get(e);
    i && i.setVisible(n);
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(e) {
    const n = this.layers.get(e);
    if (n) {
      const i = !n.getObject().visible;
      return n.setVisible(i), i;
    }
    return !1;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(e) {
    for (const [n, i] of this.layers)
      i.setVisible(n === e);
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const e of this.layers.values())
      e.setVisible(!0);
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(e, n, i) {
    const s = new hv(), o = new ct(e, n);
    s.setFromCamera(o, i);
    const a = this.scene.raycastComposition(s), l = /* @__PURE__ */ new Set();
    for (const c of a) {
      let u = c.object;
      for (; u; ) {
        if (u.userData.layerId) {
          l.add(u.userData.layerId);
          break;
        }
        u = u.parent;
      }
    }
    return Array.from(l).map((c) => this.layers.get(c)).filter((c) => c !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const e of this.layers.values())
      this.scene.removeFromComposition(e.getObject()), e.dispose();
    this.layers.clear();
  }
}
class dj {
  constructor(e, n) {
    /** The main camera */
    pe(this, "camera");
    /** Keyframe evaluator for animations */
    pe(this, "evaluator");
    /** Composition dimensions */
    pe(this, "width");
    pe(this, "height");
    /** Animation properties */
    pe(this, "positionProp");
    pe(this, "targetProp");
    pe(this, "fovProp");
    /** Current target position (for lookAt) */
    pe(this, "target");
    // ============================================================================
    // VIEWPORT ZOOM/PAN
    // ============================================================================
    /** Pan offset for viewport navigation */
    pe(this, "panOffset", new ct(0, 0));
    pe(this, "zoomLevel", 1);
    this.width = e, this.height = n, this.evaluator = new hu(), this.camera = new Li(
      50,
      // Field of view
      e / n,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const i = En.degToRad(this.camera.fov), s = n / 2 / Math.tan(i / 2);
    this.camera.position.set(e / 2, -n / 2, s), this.target = new he(e / 2, -n / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(e, n, i) {
    this.camera.rotation.set(
      En.degToRad(e),
      En.degToRad(n),
      En.degToRad(i)
    ), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(e) {
    this.camera.fov = En.clamp(e, 1, 179), this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(e, n) {
    this.camera.near = Math.max(1e-3, e), this.camera.far = Math.max(this.camera.near + 1, n), this.camera.updateProjectionMatrix();
  }
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(e) {
    this.zoomLevel = Math.max(0.1, Math.min(10, e)), this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(e, n) {
    this.panOffset.set(e, n), this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const e = En.degToRad(this.camera.fov), i = this.height / 2 / Math.tan(e / 2) / this.zoomLevel, s = this.width / 2 - this.panOffset.x / this.zoomLevel, o = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(s, -o, i), this.target.set(s, -o, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(e) {
    this.positionProp = e.position, this.targetProp = e.target, this.fovProp = e.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0, this.targetProp = void 0, this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(e) {
    if (this.positionProp) {
      const n = this.evaluator.evaluate(this.positionProp, e);
      this.setPosition(n.x, n.y, n.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const n = this.evaluator.evaluate(this.targetProp, e);
      this.setTarget(n.x, n.y, n.z ?? 0);
    }
    if (this.fovProp) {
      const n = this.evaluator.evaluate(this.fovProp, e);
      this.setFOV(n);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(e, n) {
    this.width = e, this.height = n, this.camera.aspect = e / n, this.camera.updateProjectionMatrix();
    const i = En.degToRad(this.camera.fov), s = n / 2 / Math.tan(i / 2);
    this.camera.position.x = e / 2, this.camera.position.y = -n / 2, this.camera.position.z = s, this.target.set(e / 2, -n / 2, 0), this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(e, n, i = 0) {
    const s = e / this.width * 2 - 1, o = -(n / this.height) * 2 + 1, a = new he(s, o, 0.5);
    a.unproject(this.camera);
    const l = a.sub(this.camera.position).normalize(), c = (i - this.camera.position.z) / l.z;
    return this.camera.position.clone().add(l.multiplyScalar(c));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(e, n, i = 0) {
    const s = new he(e, -n, i);
    return s.project(this.camera), {
      x: (s.x + 1) / 2 * this.width,
      y: (-s.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(e) {
    e.position && this.setPosition(e.position.x, e.position.y, e.position.z), e.target && this.setTarget(e.target.x, e.target.y, e.target.z), e.fov !== void 0 && this.setFOV(e.fov), (e.near !== void 0 || e.far !== void 0) && this.setClipPlanes(
      e.near ?? this.camera.near,
      e.far ?? this.camera.far
    );
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const e = En.degToRad(50), n = this.height / 2 / Math.tan(e / 2);
    this.camera.fov = 50, this.camera.position.set(this.width / 2, -this.height / 2, n), this.target.set(this.width / 2, -this.height / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const e = new rf(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    return e.position.set(0, 0, 1e3), e.lookAt(0, 0, 0), e;
  }
}
class fj {
  constructor() {
    // Texture cache (keyed by URL or ID)
    pe(this, "textures");
    // Geometry cache (keyed by type and parameters)
    pe(this, "geometries");
    // Material cache (keyed by configuration hash)
    pe(this, "materials");
    // Texture loader
    pe(this, "textureLoader");
    // Asset getter callback (set by WeylEngine)
    pe(this, "assetGetter");
    // Statistics
    pe(this, "stats", {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    });
    this.textures = /* @__PURE__ */ new Map(), this.geometries = /* @__PURE__ */ new Map(), this.materials = /* @__PURE__ */ new Map(), this.textureLoader = new j3(), this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(e) {
    this.assetGetter = e;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(e) {
    var n;
    return (n = this.assetGetter) == null ? void 0 : n.call(this, e);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const e = new yn(1, 1, 1, 1);
    this.geometries.set("plane:1:1", e);
    const n = new yn(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", n);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(e, n) {
    const i = this.getTextureCacheKey(e, n), s = this.textures.get(i);
    return s ? (this.stats.texturesFromCache++, s) : new Promise((o, a) => {
      this.textureLoader.load(
        e,
        (l) => {
          this.applyTextureOptions(l, n), this.textures.set(i, l), this.stats.texturesLoaded++, o(l);
        },
        void 0,
        // Progress callback
        (l) => {
          console.error("[ResourceManager] Failed to load texture:", e, l), a(l);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(e, n, i) {
    const s = this.textures.get(n);
    if (s instanceof Sc)
      return s.image = e, s.needsUpdate = !0, s;
    const o = new Sc(
      e.data,
      e.width,
      e.height,
      fi,
      js
    );
    return this.applyTextureOptions(o, i), o.needsUpdate = !0, this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(e, n, i) {
    const s = this.textures.get(n);
    if (s instanceof Ly)
      return s.needsUpdate = !0, s;
    const o = new Ly(e);
    return this.applyTextureOptions(o, i), this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Get a cached texture
   */
  getTexture(e) {
    return this.textures.get(e);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(e, n) {
    if (!n) {
      e.minFilter = Kt, e.magFilter = Kt, e.generateMipmaps = !1, e.colorSpace = An;
      return;
    }
    n.wrapS !== void 0 && (e.wrapS = n.wrapS), n.wrapT !== void 0 && (e.wrapT = n.wrapT), n.minFilter !== void 0 && (e.minFilter = n.minFilter), n.magFilter !== void 0 && (e.magFilter = n.magFilter), n.generateMipmaps !== void 0 && (e.generateMipmaps = n.generateMipmaps), n.flipY !== void 0 && (e.flipY = n.flipY), n.colorSpace !== void 0 && (e.colorSpace = n.colorSpace);
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(e, n) {
    return n ? `${e}:${JSON.stringify(n)}` : e;
  }
  /**
   * Release a texture
   */
  releaseTexture(e) {
    const n = this.textures.get(e);
    n && (n.dispose(), this.textures.delete(e));
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(e) {
    const n = `layer:${e}`, i = this.textures.get(n);
    return i || null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(e, n) {
    const i = `layer:${e}`;
    this.textures.set(i, n);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(e = 1, n = 1) {
    const i = `plane:${e}:${n}`;
    let s = this.geometries.get(i);
    return s ? (this.stats.geometriesFromCache++, s) : (s = new yn(e, n, 1, 1), this.geometries.set(i, s), this.stats.geometriesCreated++, s);
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(e = 1, n = 32) {
    const i = `circle:${e}:${n}`;
    let s = this.geometries.get(i);
    return s ? (this.stats.geometriesFromCache++, s) : (s = new af(e, n), this.geometries.set(i, s), this.stats.geometriesCreated++, s);
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(e = 1, n = 1, i = 1) {
    const s = `box:${e}:${n}:${i}`;
    let o = this.geometries.get(s);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new Cn(e, n, i), this.geometries.set(s, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(e) {
    const n = `basic:${JSON.stringify(e)}`;
    let i = this.materials.get(n);
    return i || (i = new Gn({
      color: e.color ?? 16777215,
      transparent: e.transparent ?? !0,
      opacity: e.opacity ?? 1,
      map: e.map,
      side: e.side ?? Pn
    }), this.materials.set(n, i), i);
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(e) {
    switch (e) {
      case "basic":
        return new Gn({
          transparent: !0,
          side: Pn
        });
      case "standard":
        return new N3({
          transparent: !0,
          side: Pn
        });
      case "shader":
        return new si();
      default:
        return new Gn();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const e of this.textures.values())
      e.dispose();
    this.textures.clear();
    for (const e of this.geometries.values())
      e.dispose();
    this.geometries.clear();
    for (const e of this.materials.values())
      e.dispose();
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    console.log("[ResourceManager] Resource stats:", this.getStats());
  }
}
class pj {
  constructor() {
    // Frame timing
    pe(this, "frameCount", 0);
    pe(this, "lastTime", 0);
    pe(this, "frameTimes", []);
    pe(this, "maxFrameTimes", 60);
    // FPS calculation
    pe(this, "fps", 0);
    pe(this, "fpsUpdateInterval", 500);
    // ms
    pe(this, "lastFpsUpdate", 0);
    pe(this, "framesInInterval", 0);
    // Frame start time (for measuring frame duration)
    pe(this, "frameStartTime", 0);
    // Last captured stats
    pe(this, "lastStats", {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(e) {
    const n = performance.now(), i = n - this.frameStartTime;
    this.frameTimes.push(i), this.frameTimes.length > this.maxFrameTimes && this.frameTimes.shift(), this.frameCount++, this.framesInInterval++;
    const s = n - this.lastFpsUpdate;
    s >= this.fpsUpdateInterval && (this.fps = Math.round(this.framesInInterval * 1e3 / s), this.framesInInterval = 0, this.lastFpsUpdate = n);
    const o = e.info, a = performance.memory, l = (a == null ? void 0 : a.usedJSHeapSize) ?? 0, c = this.frameTimes.length > 0 ? this.frameTimes.reduce((u, h) => u + h, 0) / this.frameTimes.length : 0;
    return this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(c * 100) / 100,
      drawCalls: o.render.calls,
      triangles: o.render.triangles,
      textures: o.memory.textures,
      geometries: o.memory.geometries,
      memoryUsed: l
    }, this.lastTime = n, this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    return this.frameTimes.length === 0 ? 0 : this.frameTimes.reduce((e, n) => e + n, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    return this.frameTimes.length === 0 ? { min: 0, max: 0 } : {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0, this.frameTimes = [], this.fps = 0, this.framesInInterval = 0, this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime, this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(e = 30) {
    return this.fps > 0 && this.fps < e;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const e = this.lastStats, n = this.getFrameTimeRange();
    return [
      `FPS: ${e.fps}`,
      `Frame Time: ${e.frameTime.toFixed(2)}ms (min: ${n.min.toFixed(2)}, max: ${n.max.toFixed(2)})`,
      `Draw Calls: ${e.drawCalls}`,
      `Triangles: ${e.triangles.toLocaleString()}`,
      `Textures: ${e.textures}`,
      `Geometries: ${e.geometries}`,
      `Memory: ${(e.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join(`
`);
  }
}
class mj {
  constructor(e) {
    // Core subsystems
    pe(this, "scene");
    pe(this, "renderer");
    pe(this, "layers");
    pe(this, "camera");
    pe(this, "resources");
    pe(this, "performance");
    // State
    pe(this, "state");
    pe(this, "animationFrameId", null);
    // Background and overlay images
    pe(this, "backgroundImage", null);
    pe(this, "depthMapMesh", null);
    pe(this, "depthMapSettings", { colormap: "viridis", opacity: 0.5, visible: !1 });
    // Viewport transform for pan/zoom
    pe(this, "viewportTransform", [1, 0, 0, 1, 0, 0]);
    // Render mode
    pe(this, "renderMode", "color");
    // Audio reactivity
    pe(this, "audioReactiveGetter", null);
    // Transform controls for layer manipulation
    pe(this, "transformControls", null);
    pe(this, "selectedLayerId", null);
    pe(this, "transformMode", "translate");
    // Transform change callback
    pe(this, "onTransformChange", null);
    // Event system
    pe(this, "eventHandlers");
    // Configuration
    pe(this, "config");
    // Active camera tracking
    pe(this, "activeCameraGetter");
    pe(this, "activeCameraId", null);
    this.validateConfig(e), this.config = {
      canvas: e.canvas,
      width: e.width,
      height: e.height,
      compositionWidth: e.compositionWidth ?? e.width,
      compositionHeight: e.compositionHeight ?? e.height,
      pixelRatio: e.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      backgroundColor: e.backgroundColor ?? null,
      debug: e.debug ?? !1,
      powerPreference: e.powerPreference ?? "high-performance"
    }, this.state = {
      currentFrame: 0,
      isRendering: !1,
      isDisposed: !1,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    }, this.eventHandlers = /* @__PURE__ */ new Map(), this.resources = new fj(), this.scene = new V9(this.config.backgroundColor), this.camera = new dj(this.config.width, this.config.height), this.renderer = new e7({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera), this.layers = new hj(this.scene, this.resources), this.performance = new pj(), this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    ), this.setupContextLossHandling(), this.config.debug && console.log("[WeylEngine] Initialized", this.config);
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(e) {
    if (!(e.canvas instanceof HTMLCanvasElement))
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    if (e.width <= 0 || e.height <= 0)
      throw new Error("WeylEngine requires positive width and height");
    if (e.width > 8192 || e.height > 8192)
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(e) {
    this.assertNotDisposed(), this.layers.create(e), this.emit("layerAdded", { layerId: e.id }), this.config.debug && console.log("[WeylEngine] Layer added:", e.id, e.type);
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(e, n) {
    this.assertNotDisposed(), this.layers.update(e, n), this.emit("layerUpdated", { layerId: e, properties: n });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(e) {
    this.assertNotDisposed(), this.layers.remove(e), this.emit("layerRemoved", { layerId: e }), this.config.debug && console.log("[WeylEngine] Layer removed:", e);
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(e) {
    return this.layers.getObject(e);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(e) {
    this.assertNotDisposed();
    const n = new Set(this.layers.getLayerIds()), i = new Set(e.map((s) => s.id));
    for (const s of n)
      i.has(s) || this.layers.remove(s);
    for (const s of e)
      n.has(s.id) ? this.layers.update(s.id, s) : this.layers.create(s);
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(e) {
    this.resources.setAssetGetter(e);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(e) {
    this.layers.setVideoMetadataCallback(e);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(e) {
    this.layers.setPrecompRenderContext(e);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(e, n, i) {
    this.layers.setCameraCallbacks(e, n, i), this.activeCameraGetter = e;
  }
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(e) {
    this.activeCameraId = e;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter)
      return;
    const e = this.layers.getLayer(this.activeCameraId);
    if (!e || e.type !== "camera")
      return;
    const n = e, i = n.getExportData();
    if (!i)
      return;
    this.camera.setPosition(i.position.x, i.position.y, i.position.z), this.camera.setRotation(i.rotation.x, i.rotation.y, i.rotation.z), this.camera.setFOV(i.fov), this.camera.setClipPlanes(i.nearClip, i.farClip);
    const s = n.getCameraAtCurrentFrame();
    s && s.depthOfField && this.setDOFFromCamera(s.depthOfField);
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(e) {
    this.layers.setCompositionFPS(e);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer()), this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const e = this.camera.camera;
    return {
      projectionMatrix: e.projectionMatrix.clone(),
      viewMatrix: e.matrixWorldInverse.clone(),
      projectionMatrixInverse: e.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    this.layers.setLayerDrivenValues(e, n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    this.layers.clearLayerDrivenValues(e);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Set the current frame for animation evaluation
   * @param frame - The frame number (0-indexed)
   */
  setFrame(e) {
    this.assertNotDisposed(), this.state.currentFrame = e, this.layers.evaluateFrame(e, this.audioReactiveGetter), this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e);
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e, this.layers.setAudioReactiveCallback(e);
  }
  /**
   * Get the current frame
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed(), this.performance.beginFrame(), this.emit("frameStart", { frame: this.state.currentFrame }), this.renderer.render(), this.emit("frameEnd", { frame: this.state.currentFrame }), this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    if (this.assertNotDisposed(), this.animationFrameId !== null)
      return;
    this.state.isRendering = !0;
    const e = () => {
      !this.state.isRendering || this.state.isDisposed || (this.render(), this.animationFrameId = requestAnimationFrame(e));
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = !1, this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(e, n, i, s) {
    if (this.assertNotDisposed(), e <= 0 || n <= 0) {
      console.warn("[WeylEngine] Invalid resize dimensions:", e, n);
      return;
    }
    this.state.viewport = { width: e, height: n }, this.renderer.resize(e, n);
    const o = i ?? e, a = s ?? n;
    this.camera.resize(o, a), this.emit("resize", { width: e, height: n, compositionWidth: i, compositionHeight: s });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(e, n, i) {
    this.camera.setPosition(e, n, i);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(e, n, i) {
    this.camera.setTarget(e, n, i);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(e) {
    this.camera.setFOV(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(e) {
    this.renderer.setDOF({
      enabled: e.enabled,
      focusDistance: e.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: e.aperture * 1e-4,
      maxBlur: e.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(e) {
    this.renderer.setDOFEnabled(e);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(e) {
    this.renderer.setFocusDistance(e);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(e) {
    this.renderer.setAperture(e * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(e) {
    this.viewportTransform = [...e];
    const n = e[0], i = e[4], s = e[5];
    this.camera.setZoom(n), this.camera.setPan(i, s);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(e) {
    this.assertNotDisposed(), this.backgroundImage && (this.scene.removeFromComposition(this.backgroundImage), this.backgroundImage.geometry.dispose(), this.backgroundImage.material.dispose());
    const n = new Fn(e);
    n.needsUpdate = !0, n.colorSpace = An;
    const i = new yn(e.width, e.height), s = new Gn({
      map: n,
      transparent: !0,
      depthWrite: !1
    });
    this.backgroundImage = new tt(i, s), this.backgroundImage.position.set(e.width / 2, e.height / 2, -1e3), this.backgroundImage.userData.isBackground = !0, this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(e, n) {
    this.assertNotDisposed(), this.depthMapSettings = {
      colormap: n.colormap ?? this.depthMapSettings.colormap,
      opacity: n.opacity ?? this.depthMapSettings.opacity,
      visible: n.visible ?? this.depthMapSettings.visible
    }, this.depthMapMesh && (this.scene.removeFromComposition(this.depthMapMesh), this.depthMapMesh.geometry.dispose(), this.depthMapMesh.material.dispose());
    const i = new Fn(e);
    i.needsUpdate = !0;
    const s = this.createColormapMaterial(i, this.depthMapSettings), o = new yn(e.width, e.height);
    this.depthMapMesh = new tt(o, s), this.depthMapMesh.position.set(e.width / 2, e.height / 2, -999), this.depthMapMesh.visible = this.depthMapSettings.visible, this.depthMapMesh.userData.isDepthOverlay = !0, this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(e, n) {
    const i = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, s = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `, o = n.colormap === "viridis" ? 0 : n.colormap === "plasma" ? 1 : 2;
    return new si({
      uniforms: {
        depthMap: { value: e },
        opacity: { value: n.opacity },
        colormap: { value: o }
      },
      vertexShader: i,
      fragmentShader: s,
      transparent: !0,
      depthWrite: !1
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(e) {
    this.depthMapSettings.visible = e, this.depthMapMesh && (this.depthMapMesh.visible = e);
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(e) {
    if (this.depthMapSettings.colormap = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material, i = e === "viridis" ? 0 : e === "plasma" ? 1 : 2;
      n.uniforms.colormap.value = i;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(e) {
    if (this.depthMapSettings.opacity = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material;
      n.uniforms.opacity.value = e;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, this.renderer.setRenderMode(e);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(e, n) {
    const i = new hv(), s = new ct(e, n);
    i.setFromCamera(s, this.camera.getCamera());
    const o = this.scene.raycastComposition(i);
    for (const a of o) {
      let l = a.object;
      for (; l; ) {
        if (l.userData.layerId)
          return l.userData.layerId;
        if (l.userData.isBackground || l.userData.isDepthOverlay)
          break;
        l = l.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    if (this.assertNotDisposed(), this.transformControls)
      return;
    const e = this.camera.getCamera(), n = this.renderer.getDomElement();
    this.transformControls = new R9(e, n), this.transformControls.setMode(this.transformMode), this.transformControls.setSpace("world"), this.transformControls.setSize(1), this.scene.addUIElement(this.transformControls), this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const i = this.transformControls.object;
      if (!i) return;
      const s = {
        position: {
          x: i.position.x,
          y: i.position.y,
          z: i.position.z
        },
        rotationX: En.radToDeg(i.rotation.x),
        rotationY: En.radToDeg(i.rotation.y),
        rotationZ: En.radToDeg(i.rotation.z),
        scale: {
          x: i.scale.x * 100,
          // Convert back to percentage
          y: i.scale.y * 100,
          z: i.scale.z * 100
        }
      };
      s.rotation = s.rotationZ, this.onTransformChange && this.onTransformChange(this.selectedLayerId, s);
    }), this.transformControls.addEventListener("dragging-changed", (i) => {
      this.emit("transform-dragging", { dragging: i.value });
    }), this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(e) {
    this.onTransformChange = e;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(e) {
    if (this.assertNotDisposed(), this.transformControls || this.initializeTransformControls(), this.selectedLayerId && this.transformControls && this.transformControls.detach(), this.selectedLayerId = e, !e || !this.transformControls)
      return;
    const n = this.getLayerObject(e);
    n && this.transformControls.attach(n);
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(e) {
    this.transformMode = e, this.transformControls && this.transformControls.setMode(e);
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(e) {
    this.transformControls && (this.transformControls.visible = e, this.transformControls.enabled = e);
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    var e;
    return ((e = this.transformControls) == null ? void 0 : e.dragging) ?? !1;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const e = this.renderer.captureFrame();
    return {
      imageData: e,
      width: e.width,
      height: e.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(e = "png", n = 0.95) {
    this.assertNotDisposed();
    const { imageData: i, width: s, height: o } = this.captureFrame(), a = new OffscreenCanvas(s, o);
    return a.getContext("2d").putImageData(i, 0, 0), a.convertToBlob({
      type: `image/${e}`,
      quality: n
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const e = this.renderer.captureDepth(), n = this.camera.getState();
    return {
      depthBuffer: e,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: n.near,
      far: n.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var s;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (s = this.eventHandlers.get(e)) == null || s.forEach((o) => {
      try {
        o(i);
      } catch (a) {
        console.error(`[WeylEngine] Event handler error for ${e}:`, a);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const e = this.config.canvas;
    e.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), this.stopRenderLoop(), this.emit("contextLost", null), console.warn("[WeylEngine] WebGL context lost");
    }), e.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null), console.log("[WeylEngine] WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed)
      throw new Error("WeylEngine has been disposed");
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    this.state.isDisposed || (this.stopRenderLoop(), this.layers.dispose(), this.renderer.dispose(), this.scene.dispose(), this.resources.dispose(), this.eventHandlers.clear(), this.state.isDisposed = !0, this.emit("dispose", null), this.config.debug && console.log("[WeylEngine] Disposed"));
  }
}
const gj = {
  key: 1,
  class: "overlay-controls"
}, vj = { class: "render-mode-controls" }, yj = {
  key: 2,
  class: "transform-mode-controls"
}, _j = {
  key: 3,
  class: "performance-overlay"
}, xj = {
  key: 4,
  class: "loading-overlay"
}, bj = /* @__PURE__ */ jt({
  __name: "ThreeCanvas",
  setup(r, { expose: e }) {
    const n = _n(), i = Ce(null), s = Ce(null), o = Ce(null), a = lM(null), l = Ce(!1), c = Ce(1), u = Ce(800), h = Ce(600), d = Ce(!1), p = Ce("viridis"), f = Ce(50), m = Ce("color"), _ = Ce(!1), g = Ce({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    }), v = Ce([1, 0, 0, 1, 0, 0]), S = Ce("translate"), b = Xe(() => n.depthMap !== null), x = Xe(() => n.currentTool === "pen"), M = Xe(() => {
      const H = n.selectedLayer;
      if ((H == null ? void 0 : H.type) === "spline")
        return H.id;
      if (x.value) {
        const K = n.layers.filter((G) => G.type === "spline");
        return K.length > 0 ? K[K.length - 1].id : null;
      }
      return null;
    }), C = Xe(() => v.value);
    Xn(async () => {
      if (!s.value || !i.value) return;
      const H = i.value, K = H.getBoundingClientRect();
      u.value = K.width, h.value = K.height;
      const G = {
        canvas: s.value,
        width: K.width,
        height: K.height,
        compositionWidth: n.width || 1920,
        compositionHeight: n.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: !0,
        alpha: !0,
        powerPreference: "high-performance"
      };
      try {
        l.value = !0, a.value = new mj(G), a.value.setAssetGetter((z) => n.assets[z]), a.value.setVideoMetadataCallback((z, I) => {
          n.onVideoMetadataLoaded(z, I);
        }), a.value.setCameraCallbacks(
          (z) => n.getCamera(z),
          (z, I) => n.updateCamera(z, I),
          (z, I) => n.getCameraAtFrame(z, I)
        ), a.value.setAudioReactiveCallback(
          (z, I) => n.getAudioReactiveValuesForLayer(z, I)
        ), a.value.initializeTransformControls(), a.value.setTransformChangeCallback((z, I) => {
          P(z, I);
        }), a.value.initializeParticleSystems(), a.value.setCompositionFPS(n.fps || 60), a.value.start(), await Gs(), T(), n.initializePropertyDriverSystem(), a.value.setFrame(n.currentFrame), D(), new ResizeObserver(ce).observe(H), q();
      } catch (R) {
        console.error("[ThreeCanvas] Failed to initialize engine:", R);
      } finally {
        l.value = !1;
      }
      E();
    }), Ni(() => {
      a.value && (a.value.stop(), a.value.dispose(), a.value = null);
    });
    function E() {
      At(
        () => n.layers,
        () => {
          T(), a.value && a.value.setFrame(n.currentFrame);
        },
        { deep: !0 }
      ), At(
        () => n.currentFrame,
        (H) => {
          a.value && (w(), a.value.setFrame(H));
        }
      ), At(
        () => [n.width, n.height],
        ([H, K]) => {
          a.value && (a.value.resize(u.value, h.value, H, K), q());
        }
      ), At(
        () => n.sourceImage,
        async (H) => {
          a.value && H && await A(H);
        },
        { immediate: !0 }
      ), At(
        () => n.depthMap,
        async (H) => {
          a.value && H && await O(H);
        },
        { immediate: !0 }
      ), At(
        () => {
          var H;
          return (H = a.value) == null ? void 0 : H.getPerformanceStats();
        },
        (H) => {
          H && (g.value = H);
        }
      ), At(
        () => n.activeCameraId,
        (H) => {
          if (!a.value) return;
          if (!H) {
            a.value.setActiveCameraLayer(null);
            return;
          }
          const K = n.layers.find(
            (G) => {
              var R;
              return G.type === "camera" && ((R = G.data) == null ? void 0 : R.cameraId) === H;
            }
          );
          K && a.value.setActiveCameraLayer(K.id);
        },
        { immediate: !0 }
      ), At(
        () => n.selectedLayerIds,
        (H) => {
          if (!a.value) return;
          const K = H.length > 0 ? H[0] : null;
          a.value.selectLayer(K);
        },
        { deep: !0 }
      );
    }
    function T() {
      if (!a.value) return;
      const H = new Set(a.value.getLayerIds()), K = new Set(n.layers.map((G) => G.id));
      for (const G of H)
        K.has(G) || a.value.removeLayer(G);
      for (const G of n.layers)
        H.has(G.id) ? a.value.updateLayer(G.id, G) : a.value.addLayer(G);
    }
    function w() {
      if (a.value) {
        a.value.clearAllDrivenValues();
        for (const H of n.layers) {
          const K = n.getDrivenValuesForLayer(H.id);
          K.size > 0 && a.value.setLayerDrivenValues(H.id, K);
        }
      }
    }
    async function A(H) {
      if (a.value)
        try {
          l.value = !0;
          const K = await U(H);
          a.value.setBackgroundImage(K);
        } catch (K) {
          console.error("[ThreeCanvas] Failed to load source image:", K);
        } finally {
          l.value = !1;
        }
    }
    async function O(H) {
      if (a.value)
        try {
          const K = await U(H);
          a.value.setDepthMap(K, {
            colormap: p.value,
            opacity: f.value / 100,
            visible: d.value
          });
        } catch (K) {
          console.error("[ThreeCanvas] Failed to load depth map:", K);
        }
    }
    function U(H) {
      return new Promise((K, G) => {
        const R = new Image();
        R.crossOrigin = "anonymous", R.onload = () => K(R), R.onerror = G, R.src = H.startsWith("data:") ? H : `data:image/png;base64,${H}`;
      });
    }
    function D() {
      const H = i.value, K = s.value;
      if (!H || !K) return;
      let G = !1, R = !1, z = 0, I = 0, Q = 0, X = 1;
      H.addEventListener("mousedown", (k) => {
        k.button === 1 && k.preventDefault();
      }), H.addEventListener("auxclick", (k) => {
        k.button === 1 && k.preventDefault();
      }), K.addEventListener("wheel", (k) => {
        k.preventDefault();
        const ee = k.deltaY;
        let Z = c.value * (ee > 0 ? 0.9 : 1.1);
        Z = Math.min(Math.max(Z, 0.1), 10);
        const N = K.getBoundingClientRect(), j = k.clientX - N.left, te = k.clientY - N.top, F = Z / c.value;
        v.value[4] = j - F * (j - v.value[4]), v.value[5] = te - F * (te - v.value[5]), v.value[0] = Z, v.value[3] = Z, c.value = Z, a.value && a.value.setViewportTransform(v.value);
      }, { passive: !1 }), K.addEventListener("mousedown", (k) => {
        var Z, N;
        const ee = n.currentTool;
        if (k.button === 1 || ee === "hand" || k.button === 0 && k.altKey) {
          G = !0, z = k.clientX, I = k.clientY, K.style.cursor = "grabbing", k.preventDefault();
          return;
        }
        if (ee === "zoom") {
          if (k.shiftKey) {
            const j = Math.max(c.value * 0.7, 0.1);
            c.value = j, v.value[0] = j, v.value[3] = j, a.value && a.value.setViewportTransform(v.value);
          } else
            R = !0, Q = k.clientY, X = c.value;
          return;
        }
        if (ee === "text") {
          const j = K.getBoundingClientRect(), te = L(k.clientX - j.left, k.clientY - j.top), F = n.createLayer("text");
          (Z = F.transform) != null && Z.position && (F.transform.position.value = { x: te.x, y: te.y, z: 0 }), n.updateLayer(F.id, {
            transform: {
              ...F.transform,
              position: {
                ...F.transform.position,
                value: { x: te.x, y: te.y, z: 0 }
              }
            }
          }), n.selectLayer(F.id), n.setTool("select");
          return;
        }
        if (ee === "select" && k.button === 0) {
          if ((N = a.value) != null && N.isTransformDragging())
            return;
          const j = K.getBoundingClientRect(), te = (k.clientX - j.left) / j.width * 2 - 1, F = -((k.clientY - j.top) / j.height) * 2 + 1;
          if (a.value) {
            const B = a.value.raycastLayers(te, F);
            B ? (n.selectLayer(B), a.value.selectLayer(B)) : (n.clearSelection(), a.value.selectLayer(null));
          }
        }
      }), K.addEventListener("mousemove", (k) => {
        if (G) {
          const Z = k.clientX - z, N = k.clientY - I;
          v.value[4] += Z, v.value[5] += N, z = k.clientX, I = k.clientY, a.value && a.value.setViewportTransform(v.value);
          return;
        }
        if (R) {
          const N = 1 + (Q - k.clientY) * 0.01, j = Math.max(0.1, Math.min(10, X * N));
          c.value = j, v.value[0] = j, v.value[3] = j, a.value && a.value.setViewportTransform(v.value);
          return;
        }
        const ee = n.currentTool;
        ee === "hand" ? K.style.cursor = "grab" : ee === "zoom" ? K.style.cursor = "zoom-in" : ee === "text" ? K.style.cursor = "text" : ee === "pen" ? K.style.cursor = "crosshair" : K.style.cursor = "default";
      }), K.addEventListener("mouseup", () => {
        G && (G = !1, K.style.cursor = n.currentTool === "hand" ? "grab" : "default"), R && (R = !1);
      }), K.addEventListener("mouseleave", () => {
        G = !1, R = !1;
      });
    }
    function L(H, K) {
      const G = v.value;
      return {
        x: (H - G[4]) / G[0],
        y: (K - G[5]) / G[3]
      };
    }
    function P(H, K) {
      var z, I, Q, X;
      const G = n.layers.find((k) => k.id === H);
      if (!G) return;
      const R = {};
      K.position && G.transform && (R.transform = {
        ...G.transform,
        position: {
          ...G.transform.position,
          value: {
            x: K.position.x,
            y: K.position.y,
            z: K.position.z ?? ((I = (z = G.transform.position) == null ? void 0 : z.value) == null ? void 0 : I.z) ?? 0
          }
        }
      }), G.threeD ? (K.rotationX !== void 0 || K.rotationY !== void 0 || K.rotationZ !== void 0) && (!R.transform && G.transform && (R.transform = { ...G.transform }), R.transform && (K.rotationX !== void 0 && (R.transform.rotationX = { ...G.transform.rotationX, value: K.rotationX }), K.rotationY !== void 0 && (R.transform.rotationY = { ...G.transform.rotationY, value: K.rotationY }), K.rotationZ !== void 0 && (R.transform.rotationZ = { ...G.transform.rotationZ, value: K.rotationZ }))) : K.rotation !== void 0 && G.transform && (R.transform || (R.transform = { ...G.transform }), R.transform.rotation = { ...G.transform.rotation, value: K.rotation }), K.scale && G.transform && (R.transform || (R.transform = { ...G.transform }), R.transform.scale = {
        ...G.transform.scale,
        value: {
          x: K.scale.x,
          y: K.scale.y,
          z: K.scale.z ?? ((X = (Q = G.transform.scale) == null ? void 0 : Q.value) == null ? void 0 : X.z) ?? 100
        }
      }), Object.keys(R).length > 0 && n.updateLayer(H, R);
    }
    function V(H) {
      S.value = H, a.value && a.value.setTransformMode(H);
    }
    function ce(H) {
      for (const K of H) {
        const { width: G, height: R } = K.contentRect;
        G > 0 && R > 0 && (u.value = G, h.value = R, a.value && a.value.resize(G, R));
      }
    }
    function q() {
      const H = i.value;
      if (!H || !a.value) return;
      const K = n.width || 1920, G = n.height || 1080, R = H.getBoundingClientRect(), z = 60, I = (R.width - z * 2) / K, Q = (R.height - z * 2) / G, X = Math.min(I, Q, 1);
      v.value = [
        X,
        0,
        0,
        X,
        (R.width - K * X) / 2,
        (R.height - G * X) / 2
      ], c.value = X, a.value.setViewportTransform(v.value);
    }
    function oe(H) {
      m.value = H, a.value && a.value.setRenderMode(H);
    }
    function ne(H) {
      if (!M.value) {
        const K = n.createLayer("spline");
        n.selectLayer(K.id);
      }
    }
    function $() {
      T();
    }
    function J() {
      const H = Math.min(c.value * 1.2, 10);
      c.value = H, v.value[0] = H, v.value[3] = H, a.value && a.value.setViewportTransform(v.value);
    }
    function se() {
      const H = Math.max(c.value * 0.8, 0.1);
      c.value = H, v.value[0] = H, v.value[3] = H, a.value && a.value.setViewportTransform(v.value);
    }
    function le() {
      q();
    }
    async function re() {
      if (!a.value) return null;
      const H = a.value.captureFrame();
      if (!(H != null && H.imageData)) return null;
      const K = document.createElement("canvas");
      K.width = H.width, K.height = H.height;
      const G = K.getContext("2d");
      return G ? (G.putImageData(H.imageData, 0, 0), K.toDataURL("image/png")) : null;
    }
    async function ye() {
      if (!a.value) return null;
      const H = a.value.captureDepth();
      if (!(H != null && H.depthBuffer)) return null;
      const K = document.createElement("canvas");
      K.width = H.width, K.height = H.height;
      const G = K.getContext("2d");
      if (!G) return null;
      const R = G.createImageData(H.width, H.height);
      for (let z = 0; z < H.depthBuffer.length; z++) {
        const I = Math.floor(H.depthBuffer[z] * 255), Q = z * 4;
        R.data[Q] = I, R.data[Q + 1] = I, R.data[Q + 2] = I, R.data[Q + 3] = 255;
      }
      return G.putImageData(R, 0, 0), K.toDataURL("image/png");
    }
    return At(d, (H) => {
      a.value && a.value.setDepthOverlayVisible(H);
    }), At(p, (H) => {
      a.value && a.value.setDepthColormap(H);
    }), At(f, (H) => {
      a.value && a.value.setDepthOpacity(H / 100);
    }), e({
      engine: a,
      fitToView: le,
      zoomIn: J,
      zoomOut: se,
      zoom: c,
      captureFrame: re,
      captureDepth: ye,
      showPerformance: _,
      performanceStats: g,
      renderMode: m,
      setRenderMode: oe,
      transformMode: S,
      setTransformModeTo: V
    }), (H, K) => (ie(), ue("div", {
      class: "three-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      y("canvas", {
        ref_key: "canvasRef",
        ref: s
      }, null, 512),
      M.value || x.value ? (ie(), Et(sS, {
        key: 0,
        layerId: M.value,
        canvasWidth: u.value,
        canvasHeight: h.value,
        zoom: c.value,
        viewportTransform: C.value,
        isPenMode: x.value,
        onPointAdded: ne,
        onPathUpdated: $,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Ne("", !0),
      b.value ? (ie(), ue("div", gj, [
        y("label", null, [
          wt(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": K[0] || (K[0] = (G) => d.value = G)
          }, null, 512), [
            [Us, d.value]
          ]),
          K[9] || (K[9] = xt(" Depth Overlay ", -1))
        ]),
        wt(y("select", {
          "onUpdate:modelValue": K[1] || (K[1] = (G) => p.value = G),
          class: "colormap-select"
        }, [...K[10] || (K[10] = [
          y("option", { value: "viridis" }, "Viridis", -1),
          y("option", { value: "plasma" }, "Plasma", -1),
          y("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [ns, p.value]
        ]),
        wt(y("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": K[2] || (K[2] = (G) => f.value = G),
          class: "opacity-slider"
        }, null, 512), [
          [
            Tn,
            f.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Ne("", !0),
      y("div", vj, [
        y("button", {
          class: Ye({ active: m.value === "color" }),
          onClick: K[3] || (K[3] = (G) => oe("color")),
          title: "Color View"
        }, [...K[11] || (K[11] = [
          y("i", { class: "pi pi-image" }, null, -1)
        ])], 2),
        y("button", {
          class: Ye({ active: m.value === "depth" }),
          onClick: K[4] || (K[4] = (G) => oe("depth")),
          title: "Depth View"
        }, [...K[12] || (K[12] = [
          y("i", { class: "pi pi-box" }, null, -1)
        ])], 2),
        y("button", {
          class: Ye({ active: m.value === "normal" }),
          onClick: K[5] || (K[5] = (G) => oe("normal")),
          title: "Normal View"
        }, [...K[13] || (K[13] = [
          y("i", { class: "pi pi-compass" }, null, -1)
        ])], 2)
      ]),
      Je(n).selectedLayerIds.length > 0 ? (ie(), ue("div", yj, [
        y("button", {
          class: Ye({ active: S.value === "translate" }),
          onClick: K[6] || (K[6] = (G) => V("translate")),
          title: "Move (V)"
        }, [...K[14] || (K[14] = [
          y("i", { class: "pi pi-arrows-alt" }, null, -1)
        ])], 2),
        y("button", {
          class: Ye({ active: S.value === "rotate" }),
          onClick: K[7] || (K[7] = (G) => V("rotate")),
          title: "Rotate (R)"
        }, [...K[15] || (K[15] = [
          y("i", { class: "pi pi-sync" }, null, -1)
        ])], 2),
        y("button", {
          class: Ye({ active: S.value === "scale" }),
          onClick: K[8] || (K[8] = (G) => V("scale")),
          title: "Scale (S)"
        }, [...K[16] || (K[16] = [
          y("i", { class: "pi pi-expand" }, null, -1)
        ])], 2)
      ])) : Ne("", !0),
      _.value ? (ie(), ue("div", _j, [
        y("span", null, "FPS: " + Ae(g.value.fps), 1),
        y("span", null, "Draw: " + Ae(g.value.drawCalls), 1),
        y("span", null, "Tris: " + Ae(g.value.triangles), 1)
      ])) : Ne("", !0),
      l.value ? (ie(), ue("div", xj, [...K[17] || (K[17] = [
        y("div", { class: "loading-spinner" }, null, -1),
        y("span", null, "Loading...", -1)
      ])])) : Ne("", !0)
    ], 512));
  }
}), wj = /* @__PURE__ */ Yt(bj, [["__scopeId", "data-v-0bc9e0bc"]]), Sj = { class: "prop-wrapper" }, Mj = { class: "prop-content" }, Cj = { class: "prop-name" }, Tj = { class: "prop-inputs" }, Ej = {
  key: 0,
  class: "vec-item"
}, Aj = {
  key: 1,
  class: "color-input-wrapper"
}, Pj = ["value"], Dj = { class: "color-hex" }, kj = { class: "vec-item" }, Rj = { class: "vec-item" }, Lj = {
  key: 1,
  class: "prop-track"
}, Ij = /* @__PURE__ */ jt({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  setup(r) {
    const e = r, n = _n(), i = Xe(() => {
      var h;
      return (h = e.property.keyframes) == null ? void 0 : h.some((d) => d.frame === n.currentFrame);
    }), s = Xe(() => n.selectedPropertyPath === e.propertyPath);
    function o() {
      n.setPropertyAnimated(e.layerId, e.propertyPath, !e.property.animated);
    }
    function a() {
      n.addKeyframe(e.layerId, e.propertyPath, e.property.value);
    }
    function l(h) {
      n.setPropertyValue(e.layerId, e.propertyPath, h);
    }
    function c(h, d) {
      const p = { ...e.property.value, [h]: d };
      n.setPropertyValue(e.layerId, e.propertyPath, p);
    }
    function u() {
      n.selectProperty(e.propertyPath);
    }
    return (h, d) => {
      var p;
      return ie(), ue("div", Sj, [
        r.layoutMode === "sidebar" ? (ie(), ue("div", {
          key: 0,
          class: Ye(["prop-sidebar", { selected: s.value }]),
          style: Ct(r.gridStyle),
          onClick: u
        }, [
          d[7] || (d[7] = y("div", { class: "indent-spacer" }, null, -1)),
          y("div", {
            class: "icon-box",
            onClick: Rt(a, ["stop"])
          }, [
            y("span", {
              class: Ye(["kf-btn", { active: i.value }])
            }, "", 2)
          ]),
          y("div", {
            class: "icon-box",
            onClick: Rt(o, ["stop"])
          }, [
            y("span", {
              class: Ye(["stopwatch", { active: r.property.animated }])
            }, "", 2)
          ]),
          y("div", Mj, [
            y("span", Cj, Ae(r.name), 1),
            y("div", Tj, [
              r.name === "Z Position" ? (ie(), ue("div", Ej, [
                d[4] || (d[4] = y("span", { class: "label z-label" }, "Z", -1)),
                Ze(rt, {
                  modelValue: ((p = r.property.value) == null ? void 0 : p.z) ?? 0,
                  "onUpdate:modelValue": d[0] || (d[0] = (f) => c("z", f))
                }, null, 8, ["modelValue"])
              ])) : r.property.type === "color" ? (ie(), ue("div", Aj, [
                y("input", {
                  type: "color",
                  value: r.property.value,
                  onInput: d[1] || (d[1] = (f) => l(f.target.value))
                }, null, 40, Pj),
                y("span", Dj, Ae(r.property.value), 1)
              ])) : typeof r.property.value == "object" ? (ie(), ue(nt, { key: 2 }, [
                y("div", kj, [
                  d[5] || (d[5] = y("span", { class: "label x-label" }, "X", -1)),
                  Ze(rt, {
                    modelValue: r.property.value.x,
                    "onUpdate:modelValue": d[2] || (d[2] = (f) => c("x", f))
                  }, null, 8, ["modelValue"])
                ]),
                y("div", Rj, [
                  d[6] || (d[6] = y("span", { class: "label y-label" }, "Y", -1)),
                  Ze(rt, {
                    modelValue: r.property.value.y,
                    "onUpdate:modelValue": d[3] || (d[3] = (f) => c("y", f))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof r.property.value == "number" ? (ie(), Et(rt, {
                key: 3,
                modelValue: r.property.value,
                "onUpdate:modelValue": l,
                precision: 1
              }, null, 8, ["modelValue"])) : Ne("", !0)
            ])
          ])
        ], 6)) : (ie(), ue("div", Lj, [
          (ie(!0), ue(nt, null, pt(r.property.keyframes, (f) => (ie(), ue("div", {
            key: f.id,
            class: "keyframe",
            style: Ct({ left: `${f.frame * r.pixelsPerFrame}px` })
          }, null, 4))), 128))
        ]))
      ]);
    };
  }
}), T_ = /* @__PURE__ */ Yt(Ij, [["__scopeId", "data-v-813d2144"]]), Oj = {
  key: 0,
  class: "track-wrapper"
}, Fj = { class: "arrow" }, Uj = { class: "layer-id" }, zj = { class: "type-icon" }, Bj = {
  key: 0,
  class: "name-text"
}, Nj = { class: "col-mode" }, Vj = ["value"], Gj = { class: "col-parent" }, Hj = ["value"], Wj = ["value"], jj = {
  key: 0,
  class: "children-container"
}, $j = ["onMousedown"], Xj = { class: "arrow-col" }, Yj = { class: "arrow" }, qj = { class: "group-label" }, Zj = { key: 0 }, Kj = {
  key: 0,
  class: "children-container"
}, Jj = { key: 0 }, Qj = /* @__PURE__ */ jt({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = _n(), o = Ce(!1), a = Xe(() => n.isExpandedExternal ?? o.value), l = Xe(() => s.selectedLayerIds.includes(n.layer.id)), c = Ce(["Transform", "Text", "More Options"]), u = Ce(!1), h = Ce(""), d = Ce(null), p = Xe(() => {
      var O;
      return ((O = n.allLayers) == null ? void 0 : O.filter((U) => U.id !== n.layer.id)) || [];
    }), f = Xe(() => {
      const O = {}, U = n.layer.transform, D = [], L = (P, V, ce) => {
        ce && D.push({ path: P, name: V, property: ce });
      };
      return L("transform.anchorPoint", "Anchor Point", U.anchorPoint), L("transform.position", "Position", U.position), n.layer.threeD && D.push({
        path: "transform.position.z",
        name: "Z Position",
        property: U.position
        // Pass full position property, PropertyTrack handles .z
      }), L("transform.scale", "Scale", U.scale), n.layer.threeD ? (U.orientation && D.push({ path: "transform.orientation", name: "Orientation", property: U.orientation }), U.rotationX && D.push({ path: "transform.rotationX", name: "X Rotation", property: U.rotationX }), U.rotationY && D.push({ path: "transform.rotationY", name: "Y Rotation", property: U.rotationY }), U.rotationZ && D.push({ path: "transform.rotationZ", name: "Z Rotation", property: U.rotationZ })) : U.rotation && D.push({ path: "transform.rotation", name: "Rotation", property: U.rotation }), n.layer.opacity && D.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), O.Transform = D, n.layer.properties && n.layer.properties.forEach((P) => {
        const V = P.group || "Properties";
        O[V] || (O[V] = []), O[V].push({ path: P.name, name: P.name, property: P });
      }), O;
    }), m = Xe(() => {
      const O = n.pixelsPerFrame || 10;
      return { left: `${n.layer.inPoint * O}px`, width: `${(n.layer.outPoint - n.layer.inPoint + 1) * O}px` };
    });
    function _() {
      i("select", n.layer.id);
    }
    function g() {
      i("toggleExpand", n.layer.id, !a.value);
    }
    function v(O) {
      c.value.includes(O) ? c.value = c.value.filter((U) => U !== O) : c.value.push(O);
    }
    function S(O) {
      return { text: "T", solid: "", camera: "" }[O] || "";
    }
    function b() {
      u.value = !0, h.value = n.layer.name, Gs(() => {
        var O;
        return (O = d.value) == null ? void 0 : O.focus();
      });
    }
    function x() {
      i("updateLayer", n.layer.id, { name: h.value }), u.value = !1;
    }
    function M(O) {
      i("updateLayer", n.layer.id, { parentId: O.target.value || null });
    }
    function C(O) {
      i("updateLayer", n.layer.id, { blendMode: O.target.value });
    }
    function E() {
    }
    function T() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function w() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function A() {
    }
    return (O, U) => r.layer ? (ie(), ue("div", Oj, [
      r.layoutMode === "sidebar" ? (ie(), ue(nt, { key: 0 }, [
        y("div", {
          class: Ye(["sidebar-row", { selected: l.value }]),
          style: Ct(r.gridStyle),
          onMousedown: _
        }, [
          y("div", {
            class: "arrow-col",
            onMousedown: Rt(g, ["stop"])
          }, [
            y("span", Fj, Ae(a.value ? "" : ""), 1)
          ], 32),
          y("div", {
            class: "label-box",
            onMousedown: Rt(A, ["stop"]),
            style: Ct({ background: r.layer.labelColor || "#999" })
          }, null, 36),
          y("div", Uj, Ae(r.index), 1),
          y("div", {
            class: "icon-col",
            onMousedown: Rt(T, ["stop"])
          }, Ae(r.layer.visible ? "" : ""), 33),
          y("div", {
            class: "icon-col",
            onMousedown: Rt(w, ["stop"])
          }, Ae(r.layer.locked ? "" : ""), 33),
          y("div", {
            class: Ye(["icon-col cube-icon", { active: r.layer.threeD }]),
            onMousedown: U[0] || (U[0] = Rt((D) => Je(s).toggleLayer3D(r.layer.id), ["stop"]))
          }, "", 34),
          y("div", {
            class: "layer-name-col",
            onDblclick: Rt(b, ["stop"])
          }, [
            y("span", zj, Ae(S(r.layer.type)), 1),
            u.value ? wt((ie(), ue("input", {
              key: 1,
              "onUpdate:modelValue": U[1] || (U[1] = (D) => h.value = D),
              onBlur: x,
              onKeydown: zg(x, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: d
            }, null, 544)), [
              [Tn, h.value]
            ]) : (ie(), ue("span", Bj, Ae(r.layer.name), 1))
          ], 32),
          y("div", Nj, [
            y("select", {
              value: r.layer.blendMode,
              class: "mini-select",
              onChange: C,
              onMousedown: U[2] || (U[2] = Rt(() => {
              }, ["stop"]))
            }, [...U[4] || (U[4] = [
              ea('<optgroup label="Normal" data-v-2e49d8a3><option value="normal" data-v-2e49d8a3>Normal</option><option value="dissolve" data-v-2e49d8a3>Dissolve</option></optgroup><optgroup label="Darken" data-v-2e49d8a3><option value="darken" data-v-2e49d8a3>Darken</option><option value="multiply" data-v-2e49d8a3>Multiply</option><option value="colorBurn" data-v-2e49d8a3>Color Burn</option><option value="linearBurn" data-v-2e49d8a3>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-2e49d8a3><option value="add" data-v-2e49d8a3>Add</option><option value="lighten" data-v-2e49d8a3>Lighten</option><option value="screen" data-v-2e49d8a3>Screen</option><option value="colorDodge" data-v-2e49d8a3>Color Dodge</option><option value="linearDodge" data-v-2e49d8a3>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-2e49d8a3><option value="overlay" data-v-2e49d8a3>Overlay</option><option value="softLight" data-v-2e49d8a3>Soft Light</option><option value="hardLight" data-v-2e49d8a3>Hard Light</option><option value="vividLight" data-v-2e49d8a3>Vivid Light</option><option value="linearLight" data-v-2e49d8a3>Linear Light</option><option value="pinLight" data-v-2e49d8a3>Pin Light</option><option value="hardMix" data-v-2e49d8a3>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-2e49d8a3><option value="difference" data-v-2e49d8a3>Difference</option><option value="exclusion" data-v-2e49d8a3>Exclusion</option><option value="subtract" data-v-2e49d8a3>Subtract</option><option value="divide" data-v-2e49d8a3>Divide</option></optgroup><optgroup label="Component" data-v-2e49d8a3><option value="hue" data-v-2e49d8a3>Hue</option><option value="saturation" data-v-2e49d8a3>Saturation</option><option value="color" data-v-2e49d8a3>Color</option><option value="luminosity" data-v-2e49d8a3>Luminosity</option></optgroup>', 6)
            ])], 40, Vj)
          ]),
          y("div", Gj, [
            y("select", {
              value: r.layer.parentId || "",
              class: "mini-select",
              onChange: M,
              onMousedown: U[3] || (U[3] = Rt(() => {
              }, ["stop"]))
            }, [
              U[5] || (U[5] = y("option", { value: "" }, "None", -1)),
              (ie(!0), ue(nt, null, pt(p.value, (D) => (ie(), ue("option", {
                key: D.id,
                value: D.id
              }, Ae(D.index), 9, Wj))), 128))
            ], 40, Hj)
          ])
        ], 38),
        a.value ? (ie(), ue("div", jj, [
          (ie(!0), ue(nt, null, pt(f.value, (D, L) => (ie(), ue("div", {
            key: L,
            class: "property-group"
          }, [
            y("div", {
              class: "group-header sidebar-row",
              style: Ct(r.gridStyle),
              onMousedown: Rt((P) => v(L), ["stop"])
            }, [
              y("div", Xj, [
                y("span", Yj, Ae(c.value.includes(L) ? "" : ""), 1)
              ]),
              y("div", qj, Ae(L), 1)
            ], 44, $j),
            c.value.includes(L) ? (ie(), ue("div", Zj, [
              (ie(!0), ue(nt, null, pt(D, (P) => (ie(), Et(T_, {
                key: P.path,
                layerId: r.layer.id,
                propertyPath: P.path,
                name: P.name,
                property: P.property,
                layoutMode: "sidebar",
                gridStyle: r.gridStyle,
                pixelsPerFrame: r.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]))), 128))
            ])) : Ne("", !0)
          ]))), 128))
        ])) : Ne("", !0)
      ], 64)) : (ie(), ue(nt, { key: 1 }, [
        y("div", {
          class: "layer-row track-bg",
          onMousedown: _
        }, [
          y("div", {
            class: "duration-bar",
            style: Ct(m.value),
            onMousedown: Rt(E, ["stop"])
          }, [
            y("div", {
              class: "bar-fill",
              style: Ct({ background: r.layer.labelColor || "#777" })
            }, null, 4)
          ], 36)
        ], 32),
        a.value ? (ie(), ue("div", Kj, [
          (ie(!0), ue(nt, null, pt(f.value, (D, L) => (ie(), ue("div", {
            key: L,
            class: "property-group"
          }, [
            U[6] || (U[6] = y("div", { class: "group-header track-bg" }, null, -1)),
            c.value.includes(L) ? (ie(), ue("div", Jj, [
              (ie(!0), ue(nt, null, pt(D, (P) => (ie(), Et(T_, {
                key: P.path,
                layerId: r.layer.id,
                propertyPath: P.path,
                name: P.name,
                property: P.property,
                layoutMode: "track",
                pixelsPerFrame: r.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]))), 128))
            ])) : Ne("", !0)
          ]))), 128))
        ])) : Ne("", !0)
      ], 64))
    ])) : Ne("", !0);
  }
}), E_ = /* @__PURE__ */ Yt(Qj, [["__scopeId", "data-v-2e49d8a3"]]), e$ = { class: "timeline-header" }, t$ = { class: "header-left" }, n$ = { class: "timecode" }, i$ = { class: "frame-display" }, s$ = ["value"], r$ = { class: "fps-label" }, o$ = { class: "header-center" }, a$ = {
  key: 0,
  class: "add-layer-menu"
}, l$ = { class: "tool-group" }, c$ = ["disabled"], u$ = { class: "header-right" }, h$ = { class: "timeline-content" }, d$ = { class: "sidebar-scroll-area" }, f$ = { class: "layer-bars-container" }, p$ = /* @__PURE__ */ jt({
  __name: "TimelinePanel",
  setup(r) {
    const e = _n(), n = Ce(10), i = Ce(450), s = Ce({}), o = Ce(!1), a = Ce(null), l = Ce(null), c = Ce(null), u = Ce(1e3), h = Xe(() => e.layers || []), d = Xe(() => e.currentFrame * n.value), p = Xe(() => {
      const D = e.frameCount * n.value;
      return Math.max(D, u.value) + "px";
    }), f = Xe(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function m() {
      o.value = !o.value;
    }
    function _(D) {
      D === "text" ? e.createTextLayer() : D === "video" ? e.createLayer("video") : D === "camera" ? e.createCameraLayer() : e.createLayer(D), o.value = !1;
    }
    function g(D) {
      e.selectLayer(D);
    }
    function v(D, L) {
      e.updateLayer(D, L);
    }
    function S() {
      e.selectedLayerIds.forEach((D) => e.deleteLayer(D));
    }
    function b(D) {
      e.setFrame(parseInt(D.target.value) || 0);
    }
    function x() {
      e.togglePlayback();
    }
    function M(D, L) {
      s.value[D] = L;
    }
    function C(D) {
      const L = e.fps, P = Math.floor(D / L), V = Math.floor(D % L), ce = P % 60, q = Math.floor(P / 60) % 60, oe = Math.floor(P / 3600), ne = ($, J = 2) => String($).padStart(J, "0");
      return `${ne(oe)};${ne(q)};${ne(ce)};${ne(V)}`;
    }
    function E() {
      const D = c.value;
      if (!D) return;
      const L = D.getContext("2d");
      if (!L) return;
      const P = e.frameCount * n.value, V = Math.max(P, u.value);
      D.width = V, D.height = 30, L.fillStyle = "#222", L.fillRect(0, 0, D.width, D.height), L.strokeStyle = "#666", L.fillStyle = "#aaa", L.font = "11px sans-serif";
      const ce = n.value;
      let q, oe;
      ce >= 20 ? (q = 1, oe = 0) : ce >= 10 ? (q = 5, oe = 1) : ce >= 5 ? (q = 10, oe = 5) : ce >= 2 ? (q = 20, oe = 10) : ce >= 1 ? (q = 50, oe = 25) : ce >= 0.5 ? (q = 100, oe = 50) : (q = 200, oe = 0);
      for (let ne = 0; ne <= e.frameCount; ne++) {
        const $ = ne * ce;
        if (ne % q === 0) {
          L.strokeStyle = "#888", L.beginPath(), L.moveTo($, 12), L.lineTo($, 30), L.stroke();
          const J = String(ne), se = L.measureText(J), le = (ne + q) * ce, re = se.width + 20;
          (le - $ >= re || ne === 0 || ne >= e.frameCount - q) && (L.fillStyle = "#ccc", L.fillText(J, $ + 3, 10));
        } else oe > 0 && ne % oe === 0 && (L.strokeStyle = "#555", L.beginPath(), L.moveTo($, 22), L.lineTo($, 30), L.stroke());
      }
      L.strokeStyle = "#444", L.beginPath(), L.moveTo(0, 29.5), L.lineTo(D.width, 29.5), L.stroke();
    }
    function T(D) {
      var ce;
      const L = c.value.getBoundingClientRect(), P = ((ce = l.value) == null ? void 0 : ce.scrollLeft) || 0, V = (q) => {
        const oe = q.clientX - L.left + P, ne = Math.max(0, Math.min(e.frameCount - 1, oe / n.value));
        e.setFrame(Math.round(ne));
      };
      V(D), window.addEventListener("mousemove", V), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", V), { once: !0 });
    }
    function w(D) {
      const L = D.clientX, P = i.value, V = (ce) => {
        i.value = Math.max(300, P + (ce.clientX - L));
      };
      window.addEventListener("mousemove", V), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", V), { once: !0 });
    }
    function A(D) {
    }
    function O(D) {
      D.target instanceof HTMLInputElement || D.target instanceof HTMLTextAreaElement || D.code === "Space" && (D.preventDefault(), x());
    }
    let U = null;
    return Xn(() => {
      window.addEventListener("mousedown", (D) => {
        a.value && !a.value.contains(D.target) && (o.value = !1);
      }), l.value && (U = new ResizeObserver((D) => {
        for (const L of D)
          u.value = L.contentRect.width, E();
      }), U.observe(l.value)), setTimeout(E, 100);
    }), Ni(() => {
      U && U.disconnect();
    }), At(() => [p.value, n.value, e.frameCount], () => Gs(E)), (D, L) => (ie(), ue("div", {
      class: "timeline-panel",
      tabindex: "0",
      onKeydown: O
    }, [
      y("div", e$, [
        y("div", t$, [
          y("span", n$, Ae(C(Je(e).currentFrame)), 1),
          y("div", i$, [
            y("input", {
              type: "number",
              value: Je(e).currentFrame,
              onChange: b,
              class: "frame-input"
            }, null, 40, s$),
            y("span", r$, Ae(Je(e).fps) + " fps", 1)
          ])
        ]),
        y("div", o$, [
          y("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: a
          }, [
            y("button", {
              class: Ye(["add-layer-btn", { active: o.value }]),
              onMousedown: Rt(m, ["stop", "prevent"])
            }, [...L[8] || (L[8] = [
              y("span", { class: "icon" }, "+", -1),
              xt(" Layer ", -1)
            ])], 34),
            o.value ? (ie(), ue("div", a$, [
              y("button", {
                onMousedown: L[0] || (L[0] = (P) => _("solid"))
              }, [...L[9] || (L[9] = [
                y("span", { class: "icon" }, "", -1),
                xt(" Solid", -1)
              ])], 32),
              y("button", {
                onMousedown: L[1] || (L[1] = (P) => _("text"))
              }, [...L[10] || (L[10] = [
                y("span", { class: "icon" }, "T", -1),
                xt(" Text", -1)
              ])], 32),
              y("button", {
                onMousedown: L[2] || (L[2] = (P) => _("spline"))
              }, [...L[11] || (L[11] = [
                y("span", { class: "icon" }, "~", -1),
                xt(" Shape", -1)
              ])], 32),
              y("button", {
                onMousedown: L[3] || (L[3] = (P) => _("null"))
              }, [...L[12] || (L[12] = [
                y("span", { class: "icon" }, "", -1),
                xt(" Null", -1)
              ])], 32),
              y("button", {
                onMousedown: L[4] || (L[4] = (P) => _("camera"))
              }, [...L[13] || (L[13] = [
                y("span", { class: "icon" }, "", -1),
                xt(" Camera", -1)
              ])], 32),
              y("button", {
                onMousedown: L[5] || (L[5] = (P) => _("light"))
              }, [...L[14] || (L[14] = [
                y("span", { class: "icon" }, "", -1),
                xt(" Light", -1)
              ])], 32),
              y("button", {
                onMousedown: L[6] || (L[6] = (P) => _("video"))
              }, [...L[15] || (L[15] = [
                y("span", { class: "icon" }, "", -1),
                xt(" Video", -1)
              ])], 32)
            ])) : Ne("", !0)
          ], 512),
          y("div", l$, [
            y("button", {
              class: "delete-btn",
              onClick: S,
              disabled: Je(e).selectedLayerIds.length === 0
            }, "", 8, c$)
          ])
        ]),
        y("div", u$, [
          wt(y("input", {
            type: "range",
            min: "0.1",
            max: "50",
            step: "0.1",
            "onUpdate:modelValue": L[7] || (L[7] = (P) => n.value = P),
            class: "zoom-slider",
            title: "Zoom Timeline"
          }, null, 512), [
            [
              Tn,
              n.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      y("div", h$, [
        y("div", {
          class: "timeline-sidebar",
          style: Ct({ width: i.value + "px" })
        }, [
          L[16] || (L[16] = ea('<div class="sidebar-header-row" data-v-fed6336d><div class="col-header col-arrow" data-v-fed6336d></div><div class="col-header col-name" data-v-fed6336d>Layer Name</div><div class="col-header col-mode" data-v-fed6336d>Mode</div><div class="col-header col-parent" data-v-fed6336d>Parent</div></div>', 1)),
          y("div", d$, [
            (ie(!0), ue(nt, null, pt(h.value, (P, V) => (ie(), Et(E_, {
              key: P.id,
              layer: P,
              index: V + 1,
              layoutMode: "sidebar",
              isExpandedExternal: s.value[P.id],
              allLayers: Je(e).layers,
              gridStyle: f.value,
              onToggleExpand: M,
              onSelect: g,
              onUpdateLayer: v
            }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]))), 128))
          ])
        ], 4),
        y("div", {
          class: "sidebar-resizer",
          onMousedown: w
        }, null, 32),
        y("div", {
          class: "track-viewport",
          ref_key: "trackViewportRef",
          ref: l,
          onScroll: A
        }, [
          y("div", {
            class: "track-scroll-content",
            style: Ct({ width: p.value })
          }, [
            y("div", {
              class: "time-ruler",
              onMousedown: T
            }, [
              y("canvas", {
                ref_key: "rulerCanvas",
                ref: c,
                height: "30"
              }, null, 512),
              y("div", {
                class: "playhead-head",
                style: Ct({ left: d.value + "px" })
              }, null, 4),
              y("div", {
                class: "playhead-hit-area",
                style: Ct({ left: d.value + "px" }),
                onMousedown: Rt(T, ["stop"])
              }, null, 36)
            ], 32),
            y("div", f$, [
              L[17] || (L[17] = y("div", { class: "grid-background" }, null, -1)),
              (ie(!0), ue(nt, null, pt(h.value, (P) => (ie(), Et(E_, {
                key: P.id,
                layer: P,
                layoutMode: "track",
                frameCount: Je(e).frameCount,
                pixelsPerFrame: n.value,
                isExpandedExternal: s.value[P.id],
                onSelect: g,
                onUpdateLayer: v
              }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]))), 128)),
              y("div", {
                class: "playhead-line",
                style: Ct({ left: d.value + "px" })
              }, null, 4)
            ])
          ], 4)
        ], 544)
      ])
    ], 32));
  }
}), A_ = /* @__PURE__ */ Yt(p$, [["__scopeId", "data-v-fed6336d"]]), m$ = { class: "graph-editor" }, g$ = { class: "graph-header" }, v$ = { class: "mode-toggle" }, y$ = { class: "preset-buttons" }, _$ = ["onClick", "title"], x$ = { class: "toolbar" }, b$ = { class: "graph-content" }, w$ = { class: "property-list" }, S$ = { class: "property-list-header" }, M$ = ["title"], C$ = ["onClick"], T$ = ["onClick"], E$ = { class: "property-name" }, A$ = {
  key: 0,
  class: "keyframe-count"
}, P$ = {
  key: 0,
  class: "dimension-toggles"
}, D$ = ["onClick"], k$ = {
  key: 0,
  class: "no-properties"
}, R$ = { class: "graph-main" }, L$ = ["viewBox"], I$ = ["onMousedown"], O$ = ["x", "y", "fill", "transform"], F$ = {
  key: 1,
  class: "bezier-handles"
}, U$ = {
  key: 0,
  class: "handle out-handle"
}, z$ = ["x1", "y1", "x2", "y2"], B$ = ["cx", "cy", "onMousedown"], N$ = {
  key: 1,
  class: "handle in-handle"
}, V$ = ["x1", "y1", "x2", "y2"], G$ = ["cx", "cy", "onMousedown"], H$ = ["x1", "x2", "y2"], W$ = {
  key: 0,
  class: "keyframe-info-panel"
}, j$ = { class: "info-row" }, $$ = ["value"], X$ = { class: "info-row" }, Y$ = ["value"], q$ = { class: "info-row" }, Z$ = ["value"], K$ = ["disabled"], J$ = ["disabled"], Q$ = ["disabled"], eX = /* @__PURE__ */ jt({
  __name: "GraphEditor",
  emits: ["close"],
  setup(r, { emit: e }) {
    const n = e, i = _n(), s = Ce(null), o = Ce(null), a = Ce(null), l = Ce(null), c = Ce(null), u = Ce(null), h = Ce(400), d = Ce(200), p = Ce("value"), f = yl({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), m = Ce([]), _ = Ce([]), g = Ce({}), v = Ce([]), S = Ce(null), b = Ce(null), x = Ce(null), M = Ce(null), C = Ce(null), E = Ce(!1), T = Ce(!0), w = { top: 10, right: 10, bottom: 10, left: 10 }, A = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, O = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], U = Xe(() => {
      const me = i.selectedLayer;
      if (!me) return [];
      const Se = [];
      return Se.push(me.transform.position), Se.push(me.transform.scale), Se.push(me.transform.rotation), Se.push(me.opacity), Se.push(...me.properties), Se;
    }), D = Xe(() => U.value.filter(
      (me) => _.value.includes(me.id) && me.animated
    )), L = Xe(() => U.value.every((me) => _.value.includes(me.id))), P = Xe(() => V(i.currentFrame));
    function V(me) {
      const Se = h.value - w.left - w.right, Oe = (me - f.frameStart) / (f.frameEnd - f.frameStart);
      return w.left + Oe * Se;
    }
    function ce(me) {
      const Se = h.value - w.left - w.right, Oe = (me - w.left) / Se;
      return f.frameStart + Oe * (f.frameEnd - f.frameStart);
    }
    function q(me) {
      const Se = d.value - w.top - w.bottom, Oe = (me - f.valueMin) / (f.valueMax - f.valueMin);
      return d.value - w.bottom - Oe * Se;
    }
    function oe(me) {
      const Se = d.value - w.top - w.bottom, Oe = (d.value - w.bottom - me) / Se;
      return f.valueMin + Oe * (f.valueMax - f.valueMin);
    }
    function ne(me) {
      return V(me.frame);
    }
    function $(me, Se) {
      const Oe = typeof Se.value == "number" ? Se.value : typeof Se.value == "object" ? Se.value.x ?? Se.value : 0;
      return q(Oe);
    }
    function J(me) {
      if (!me) return 0;
      const Se = me.keyframe.value;
      return typeof Se == "number" ? Se : typeof Se == "object" ? Se.x ?? 0 : 0;
    }
    function se(me, Se) {
      const Oe = me.keyframes[Se];
      if (!Oe || !Oe.outHandle.enabled) return V(Oe.frame);
      const $e = Oe.frame + Oe.outHandle.frame;
      return V($e);
    }
    function le(me, Se) {
      const Oe = me.keyframes[Se];
      if (!Oe || !Oe.outHandle.enabled) return q(H(Oe.value));
      const $e = H(Oe.value) + Oe.outHandle.value;
      return q($e);
    }
    function re(me, Se) {
      const Oe = me.keyframes[Se];
      if (!Oe || !Oe.inHandle.enabled) return V(Oe.frame);
      const $e = Oe.frame + Oe.inHandle.frame;
      return V($e);
    }
    function ye(me, Se) {
      const Oe = me.keyframes[Se];
      if (!Oe || !Oe.inHandle.enabled) return q(H(Oe.value));
      const $e = H(Oe.value) + Oe.inHandle.value;
      return q($e);
    }
    function H(me) {
      return typeof me == "number" ? me : typeof me == "object" ? me.x ?? me.y ?? me.z ?? 0 : 0;
    }
    function K(me) {
      const Se = U.value.find((Oe) => Oe.id === me);
      return Se ? A[Se.name] ?? A.default : A.default;
    }
    function G(me) {
      return me.frame >= f.frameStart && me.frame <= f.frameEnd;
    }
    function R(me, Se) {
      return v.value.some((Oe) => Oe.propId === me && Oe.index === Se);
    }
    function z(me, Se) {
      if (!me.animated || me.keyframes.length === 0) return !1;
      const Oe = me.keyframes[0].value;
      return typeof Oe == "object" && Se in Oe;
    }
    function I(me) {
      const Se = m.value.indexOf(me);
      Se === -1 ? m.value.push(me) : m.value.splice(Se, 1);
    }
    function Q(me) {
      const Se = _.value.indexOf(me);
      Se === -1 ? _.value.push(me) : _.value.splice(Se, 1), Z();
    }
    function X() {
      L.value ? _.value = [] : _.value = U.value.map((me) => me.id), Z();
    }
    function k(me, Se) {
      g.value[me] || (g.value[me] = []);
      const Oe = g.value[me], $e = Oe.indexOf(Se);
      $e === -1 ? Oe.push(Se) : Oe.splice($e, 1);
    }
    function ee() {
      const me = D.value;
      if (me.length === 0) return;
      let Se = 1 / 0, Oe = -1 / 0, $e = 1 / 0, W = -1 / 0;
      for (const Le of me)
        for (const Me of Le.keyframes) {
          Se = Math.min(Se, Me.frame), Oe = Math.max(Oe, Me.frame);
          const We = H(Me.value);
          $e = Math.min($e, We), W = Math.max(W, We);
        }
      const ve = (Oe - Se) * 0.1 || 10, we = (W - $e) * 0.1 || 10;
      f.frameStart = Se - ve, f.frameEnd = Oe + ve, f.valueMin = $e - we, f.valueMax = W + we;
    }
    function Z() {
      ee();
    }
    function N() {
      T.value = !T.value;
    }
    function j(me) {
      return v.value.length === 0 || !wd[me] ? !1 : me === "linear" ? v.value.every((Oe) => Oe.keyframe.interpolation === "linear") : v.value.every((Oe) => Oe.keyframe.interpolation === "bezier");
    }
    function te(me) {
      const Se = wd[me];
      if (!Se) return;
      const Oe = i.selectedLayer;
      if (Oe) {
        for (const $e of v.value) {
          const W = U.value.find((st) => st.id === $e.propId);
          if (!W) continue;
          const ve = de(W), we = $e.index, Le = we > 0 ? W.keyframes[we - 1] : null, Me = we < W.keyframes.length - 1 ? W.keyframes[we + 1] : null, We = Le ? $e.keyframe.frame - Le.frame : 10, Be = Me ? Me.frame - $e.keyframe.frame : 10;
          if (me === "linear")
            i.setKeyframeInterpolation(Oe.id, ve, $e.keyframe.id, "linear"), $e.keyframe.interpolation = "linear", $e.keyframe.outHandle = { frame: Be * 0.33, value: 0, enabled: !1 }, $e.keyframe.inHandle = { frame: -We * 0.33, value: 0, enabled: !1 };
          else {
            const st = {
              frame: Se.outHandle.x * Be,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            }, lt = {
              frame: -Se.inHandle.x * We,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            };
            i.setKeyframeInterpolation(Oe.id, ve, $e.keyframe.id, "bezier"), i.setKeyframeHandle(Oe.id, ve, $e.keyframe.id, "out", st), i.setKeyframeHandle(Oe.id, ve, $e.keyframe.id, "in", lt), $e.keyframe.interpolation = "bezier", $e.keyframe.outHandle = st, $e.keyframe.inHandle = lt;
          }
        }
        ot();
      }
    }
    function F(me) {
      var W;
      const Se = (W = s.value) == null ? void 0 : W.getBoundingClientRect();
      if (!Se) return;
      const Oe = me.clientX - Se.left, $e = me.clientY - Se.top;
      me.button === 1 || me.button === 0 && me.altKey ? b.value = { type: "pan", startX: Oe, startY: $e } : me.button === 0 && (me.shiftKey || (v.value = []), x.value = { x: Oe, y: $e, width: 0, height: 0 }, b.value = { type: "select", startX: Oe, startY: $e });
    }
    function B(me) {
      var W;
      const Se = (W = s.value) == null ? void 0 : W.getBoundingClientRect();
      if (!Se) return;
      const Oe = me.clientX - Se.left, $e = me.clientY - Se.top;
      if (ge(Oe, $e), !!b.value)
        if (b.value.type === "pan") {
          const ve = Oe - (b.value.startX ?? 0), we = $e - (b.value.startY ?? 0), Le = h.value - w.left - w.right, Me = d.value - w.top - w.bottom, We = -ve / Le * (f.frameEnd - f.frameStart), Be = we / Me * (f.valueMax - f.valueMin);
          f.frameStart += We, f.frameEnd += We, f.valueMin += Be, f.valueMax += Be, b.value.startX = Oe, b.value.startY = $e, ot();
        } else if (b.value.type === "select" && x.value) {
          const ve = b.value.startX ?? 0, we = b.value.startY ?? 0;
          x.value = {
            x: Math.min(Oe, ve),
            y: Math.min($e, we),
            width: Math.abs(Oe - ve),
            height: Math.abs($e - we)
          };
        } else b.value.type === "keyframe" ? ae(Oe, $e) : (b.value.type === "outHandle" || b.value.type === "inHandle") && ke(Oe, $e);
    }
    function Y() {
      var me;
      ((me = b.value) == null ? void 0 : me.type) === "select" && x.value && De(), b.value = null, x.value = null;
    }
    function fe(me) {
      var Le;
      me.preventDefault();
      const Se = (Le = s.value) == null ? void 0 : Le.getBoundingClientRect();
      if (!Se) return;
      const Oe = me.clientX - Se.left, $e = me.deltaY > 0 ? 1.1 : 0.9, W = ce(Oe), ve = W - (W - f.frameStart) * $e, we = W + (f.frameEnd - W) * $e;
      if (me.shiftKey)
        f.frameStart = ve, f.frameEnd = we;
      else {
        f.frameStart = ve, f.frameEnd = we;
        const Me = me.clientY - Se.top, We = oe(Me);
        f.valueMin = We - (We - f.valueMin) * $e, f.valueMax = We + (f.valueMax - We) * $e;
      }
      ot();
    }
    function ge(me, Se) {
      S.value = null;
      for (const Oe of D.value)
        for (let $e = 0; $e < Oe.keyframes.length; $e++) {
          const W = Oe.keyframes[$e], ve = ne(W), we = $(Oe, W);
          if (Math.sqrt((me - ve) ** 2 + (Se - we) ** 2) < 10) {
            S.value = { propId: Oe.id, index: $e };
            return;
          }
        }
    }
    function xe(me, Se, Oe) {
      const $e = U.value.find((ve) => ve.id === me);
      if (!$e) return;
      const W = $e.keyframes[Se];
      Oe.shiftKey || (v.value = []), R(me, Se) || v.value.push({ propId: me, index: Se, keyframe: W }), b.value = { type: "keyframe", propId: me, index: Se };
    }
    function De() {
      if (!x.value) return;
      const me = x.value;
      for (const Se of D.value)
        for (let Oe = 0; Oe < Se.keyframes.length; Oe++) {
          const $e = Se.keyframes[Oe], W = ne($e), ve = $(Se, $e);
          W >= me.x && W <= me.x + me.width && ve >= me.y && ve <= me.y + me.height && (R(Se.id, Oe) || v.value.push({ propId: Se.id, index: Oe, keyframe: $e }));
        }
    }
    function ae(me, Se) {
      const Oe = Math.round(ce(me)), $e = oe(Se), W = i.selectedLayer;
      if (W) {
        if (v.value.length > 0) {
          const ve = v.value[0], we = U.value.find((We) => We.id === ve.propId);
          if (!we) return;
          const Le = E.value ? Math.round(Oe / 5) * 5 : Oe;
          typeof ve.keyframe.value == "number" || ve.keyframe.value;
          const Me = de(we);
          i.updateKeyframe(W.id, Me, ve.keyframe.id, {
            frame: Le,
            value: typeof ve.keyframe.value == "number" ? $e : void 0
          }), ve.keyframe.frame = Le, typeof ve.keyframe.value == "number" && (ve.keyframe.value = $e);
        }
        ot();
      }
    }
    function de(me) {
      const Se = me.name.toLowerCase();
      return Se === "position" ? "transform.position" : Se === "scale" ? "transform.scale" : Se === "rotation" ? "transform.rotation" : Se === "opacity" ? "opacity" : Se === "anchor point" ? "transform.anchorPoint" : me.id;
    }
    function Ee(me, Se, Oe, $e) {
      b.value = { type: me, propId: Se, index: Oe }, document.addEventListener("mousemove", be), document.addEventListener("mouseup", Te);
    }
    function be(me) {
      var W;
      const Se = (W = s.value) == null ? void 0 : W.getBoundingClientRect();
      if (!Se || !b.value) return;
      const Oe = me.clientX - Se.left, $e = me.clientY - Se.top;
      ke(Oe, $e);
    }
    function ke(me, Se) {
      if (!b.value || !b.value.propId) return;
      const Oe = i.selectedLayer;
      if (!Oe) return;
      const $e = U.value.find((We) => We.id === b.value.propId);
      if (!$e) return;
      const W = b.value.index, ve = $e.keyframes[W];
      if (!ve) return;
      const we = ce(me), Le = oe(Se), Me = de($e);
      if (b.value.type === "outHandle") {
        const We = $e.keyframes[W + 1];
        let Be = we - ve.frame;
        We ? Be = Math.max(0, Math.min(We.frame - ve.frame, Be)) : Be = Math.max(0, Be);
        const st = Le - H(ve.value), lt = {
          frame: Be,
          value: st,
          enabled: !0
        };
        i.setKeyframeHandle(Oe.id, Me, ve.id, "out", lt), ve.outHandle = lt, ve.interpolation = "bezier", ze(ve, "out", Me);
      } else if (b.value.type === "inHandle") {
        const We = $e.keyframes[W - 1];
        let Be = we - ve.frame;
        We ? Be = Math.min(0, Math.max(We.frame - ve.frame, Be)) : Be = Math.min(0, Be);
        const st = Le - H(ve.value), lt = {
          frame: Be,
          value: st,
          enabled: !0
        };
        i.setKeyframeHandle(Oe.id, Me, ve.id, "in", lt), ve.inHandle = lt, ze(ve, "in", Me);
      }
      ot();
    }
    function ze(me, Se, Oe) {
      if (!me.controlMode || me.controlMode === "corner")
        return;
      const $e = i.selectedLayer;
      if ($e && (me.controlMode === "symmetric" && (Se === "in" ? (me.outHandle.frame = -me.inHandle.frame, me.outHandle.value = -me.inHandle.value, me.outHandle.enabled = me.inHandle.enabled, i.setKeyframeHandle($e.id, Oe, me.id, "out", { ...me.outHandle })) : (me.inHandle.frame = -me.outHandle.frame, me.inHandle.value = -me.outHandle.value, me.inHandle.enabled = me.outHandle.enabled, i.setKeyframeHandle($e.id, Oe, me.id, "in", { ...me.inHandle }))), me.controlMode === "smooth")) {
        const W = Se === "in" ? me.inHandle : me.outHandle, ve = Se === "in" ? me.outHandle : me.inHandle, we = Se === "in" ? "out" : "in";
        if (W.frame !== 0 || W.value !== 0) {
          const Me = Math.atan2(W.value, W.frame) + Math.PI, We = Math.hypot(ve.frame, ve.value);
          ve.frame = Math.cos(Me) * We, ve.value = Math.sin(Me) * We, i.setKeyframeHandle($e.id, Oe, me.id, we, { ...ve });
        }
      }
    }
    function Te() {
      b.value = null, document.removeEventListener("mousemove", be), document.removeEventListener("mouseup", Te);
    }
    function Pe(me) {
      M.value = { x: me.offsetX, y: me.offsetY };
    }
    function Ge() {
      if (!M.value) return;
      const me = i.selectedLayer;
      if (!me) return;
      const Se = Math.round(ce(M.value.x)), Oe = oe(M.value.y);
      if (D.value.length > 0) {
        const $e = D.value[0], W = de($e), ve = typeof $e.value == "number" ? Oe : { x: Oe, y: Oe };
        i.addKeyframe(me.id, W, ve, Se), ot();
      }
      M.value = null;
    }
    function Ve() {
      const me = i.selectedLayer;
      if (me) {
        for (const Se of v.value) {
          const Oe = U.value.find(($e) => $e.id === Se.propId);
          if (Oe) {
            const $e = de(Oe);
            i.removeKeyframe(me.id, $e, Se.keyframe.id);
          }
        }
        v.value = [], ot();
      }
    }
    function Qe() {
      C.value = v.value.map((me) => ({ ...me.keyframe }));
    }
    function _e() {
      var W, ve;
      if (!C.value || D.value.length === 0) return;
      const me = i.selectedLayer;
      if (!me) return;
      const Se = D.value[0], Oe = de(Se), $e = i.currentFrame - C.value[0].frame;
      for (const we of C.value) {
        const Le = we.frame + $e, Me = i.addKeyframe(me.id, Oe, we.value, Le);
        Me && (we.interpolation !== "linear" && i.setKeyframeInterpolation(me.id, Oe, Me.id, we.interpolation), (W = we.inHandle) != null && W.enabled && i.setKeyframeHandle(me.id, Oe, Me.id, "in", we.inHandle), (ve = we.outHandle) != null && ve.enabled && i.setKeyframeHandle(me.id, Oe, Me.id, "out", we.outHandle));
      }
      ot();
    }
    function Ue() {
      v.value = [];
      for (const me of D.value)
        for (let Se = 0; Se < me.keyframes.length; Se++)
          v.value.push({ propId: me.id, index: Se, keyframe: me.keyframes[Se] });
    }
    function Fe() {
      const me = [];
      for (const Se of D.value)
        for (let Oe = 0; Oe < Se.keyframes.length; Oe++)
          R(Se.id, Oe) || me.push({ propId: Se.id, index: Oe, keyframe: Se.keyframes[Oe] });
      v.value = me;
    }
    function je(me) {
      const Se = parseInt(me.target.value);
      v.value.length > 0 && !isNaN(Se) && (v.value[0].keyframe.frame = Se, ot());
    }
    function Ke(me) {
      const Se = parseFloat(me.target.value);
      if (v.value.length > 0 && !isNaN(Se)) {
        const Oe = v.value[0].keyframe;
        typeof Oe.value == "number" ? Oe.value = Se : typeof Oe.value == "object" && (Oe.value.x = Se), ot();
      }
    }
    function qe(me) {
      const Se = me.target.value;
      v.value.length > 0 && (v.value[0].keyframe.interpolation = Se, ot());
    }
    function ut(me) {
      var W;
      const Se = (W = l.value) == null ? void 0 : W.getBoundingClientRect();
      if (!Se) return;
      const Oe = me.clientX - Se.left, $e = Math.round(ce(Oe));
      i.setFrame($e);
    }
    function ot() {
      dt(), on(), Rn();
    }
    function dt() {
      const me = s.value;
      if (!me) return;
      const Se = me.getContext("2d");
      if (Se) {
        me.width = h.value, me.height = d.value, Se.fillStyle = "#1a1a1a", Se.fillRect(0, 0, h.value, d.value), mt(Se);
        for (const Oe of D.value)
          $t(Se, Oe);
      }
    }
    function mt(me) {
      const Se = h.value - w.left - w.right, Oe = d.value - w.top - w.bottom;
      me.strokeStyle = "#2a2a2a", me.lineWidth = 1;
      const $e = f.frameEnd - f.frameStart, W = Bt($e, Se, 50), ve = f.valueMax - f.valueMin, we = Bt(ve, Oe, 30), Le = Math.ceil(f.frameStart / W) * W;
      for (let We = Le; We <= f.frameEnd; We += W) {
        const Be = V(We);
        me.beginPath(), me.moveTo(Be, w.top), me.lineTo(Be, d.value - w.bottom), me.stroke();
      }
      const Me = Math.ceil(f.valueMin / we) * we;
      for (let We = Me; We <= f.valueMax; We += we) {
        const Be = q(We);
        me.beginPath(), me.moveTo(w.left, Be), me.lineTo(h.value - w.right, Be), me.stroke();
      }
      if (me.strokeStyle = "#3a3a3a", me.lineWidth = 1, f.frameStart <= 0 && f.frameEnd >= 0) {
        const We = V(0);
        me.beginPath(), me.moveTo(We, w.top), me.lineTo(We, d.value - w.bottom), me.stroke();
      }
      if (f.valueMin <= 0 && f.valueMax >= 0) {
        const We = q(0);
        me.beginPath(), me.moveTo(w.left, We), me.lineTo(h.value - w.right, We), me.stroke();
      }
    }
    function Bt(me, Se, Oe) {
      const $e = me * Oe / Se, W = Math.pow(10, Math.floor(Math.log10($e))), ve = $e / W;
      return ve <= 1 ? W : ve <= 2 ? 2 * W : ve <= 5 ? 5 * W : 10 * W;
    }
    function $t(me, Se) {
      if (Se.keyframes.length < 2) return;
      const Oe = K(Se.id);
      for (let $e = 0; $e < 2; $e++) {
        $e === 0 ? (me.strokeStyle = "#000", me.lineWidth = 4) : (me.strokeStyle = Oe, me.lineWidth = 2), me.beginPath();
        let W = !1;
        for (let ve = 0; ve < Se.keyframes.length - 1; ve++) {
          const we = Se.keyframes[ve], Le = Se.keyframes[ve + 1];
          if (Le.frame < f.frameStart || we.frame > f.frameEnd) continue;
          const Me = ne(we), We = $(Se, we), Be = ne(Le), st = $(Se, Le);
          if (W || (me.moveTo(Me, We), W = !0), we.interpolation === "hold")
            me.lineTo(Be, We), me.lineTo(Be, st);
          else if (we.interpolation === "linear" || !we.outHandle.enabled && !Le.inHandle.enabled)
            me.lineTo(Be, st);
          else {
            const lt = V(we.frame + we.outHandle.frame), yt = q(H(we.value) + we.outHandle.value), bt = V(Le.frame + Le.inHandle.frame), ft = q(H(Le.value) + Le.inHandle.value);
            me.bezierCurveTo(lt, yt, bt, ft, Be, st);
          }
        }
        me.stroke();
      }
    }
    function on() {
      var Le;
      const me = l.value;
      if (!me) return;
      const Se = (Le = a.value) == null ? void 0 : Le.getBoundingClientRect();
      if (!Se) return;
      me.width = Se.width, me.height = 24;
      const Oe = me.getContext("2d");
      if (!Oe) return;
      Oe.fillStyle = "#252525", Oe.fillRect(0, 0, me.width, me.height);
      const $e = f.frameEnd - f.frameStart, W = Bt($e, me.width, 60);
      Oe.fillStyle = "#888", Oe.font = "10px system-ui", Oe.textAlign = "center";
      const ve = Math.ceil(f.frameStart / W) * W;
      for (let Me = ve; Me <= f.frameEnd; Me += W) {
        const We = V(Me);
        Oe.fillText(Me.toString(), We, 16), Oe.strokeStyle = "#444", Oe.beginPath(), Oe.moveTo(We, 20), Oe.lineTo(We, 24), Oe.stroke();
      }
      const we = V(i.currentFrame);
      Oe.fillStyle = "#ff4444", Oe.beginPath(), Oe.moveTo(we - 5, 0), Oe.lineTo(we + 5, 0), Oe.lineTo(we, 8), Oe.closePath(), Oe.fill();
    }
    function Rn() {
      var we;
      const me = u.value;
      if (!me) return;
      const Se = (we = c.value) == null ? void 0 : we.getBoundingClientRect();
      if (!Se) return;
      me.width = 40, me.height = Se.height;
      const Oe = me.getContext("2d");
      if (!Oe) return;
      Oe.fillStyle = "#252525", Oe.fillRect(0, 0, me.width, me.height);
      const $e = f.valueMax - f.valueMin, W = Bt($e, me.height, 30);
      Oe.fillStyle = "#888", Oe.font = "10px system-ui", Oe.textAlign = "right";
      const ve = Math.ceil(f.valueMin / W) * W;
      for (let Le = ve; Le <= f.valueMax; Le += W) {
        const Me = q(Le);
        Oe.fillText(Le.toFixed(0), 36, Me + 4);
      }
    }
    function dn(me = "both") {
      for (const Se of v.value) {
        const Oe = U.value.find((Be) => Be.id === Se.propId);
        if (!Oe) continue;
        const $e = Se.keyframe, W = Se.index, ve = W > 0 ? Oe.keyframes[W - 1] : null, we = W < Oe.keyframes.length - 1 ? Oe.keyframes[W + 1] : null, Le = ve ? $e.frame - ve.frame : 10, Me = we ? we.frame - $e.frame : 10, We = 0.3333;
        (me === "both" || me === "in") && ($e.inHandle = {
          frame: -Le * We,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (me === "both" || me === "out") && ($e.outHandle = {
          frame: Me * We,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), $e.interpolation = "bezier", $e.controlMode = "smooth";
      }
      ot();
    }
    function Un() {
      const me = i.currentFrame, Se = [];
      for (const $e of D.value)
        for (const W of $e.keyframes)
          Se.includes(W.frame) || Se.push(W.frame);
      Se.sort(($e, W) => $e - W);
      const Oe = [...Se].reverse().find(($e) => $e < me);
      Oe !== void 0 && i.setFrame(Oe);
    }
    function qn() {
      const me = i.currentFrame, Se = [];
      for (const $e of D.value)
        for (const W of $e.keyframes)
          Se.includes(W.frame) || Se.push(W.frame);
      Se.sort(($e, W) => $e - W);
      const Oe = Se.find(($e) => $e > me);
      Oe !== void 0 && i.setFrame(Oe);
    }
    function Ln(me) {
      if (me.key === "F9") {
        me.preventDefault(), me.ctrlKey && me.shiftKey ? dn("out") : me.shiftKey ? dn("in") : dn("both");
        return;
      }
      if (me.key.toLowerCase() === "j") {
        me.preventDefault(), Un();
        return;
      }
      if (me.key.toLowerCase() === "k") {
        me.preventDefault(), qn();
        return;
      }
      if (me.key === "Delete" || me.key === "Backspace") {
        me.preventDefault(), Ve();
        return;
      }
      if (me.key.toLowerCase() === "f" && !me.ctrlKey) {
        me.preventDefault(), me.shiftKey ? ee() : v.value.length > 0 ? wn() : ee();
        return;
      }
      if (me.key === "=" || me.key === "+") {
        me.preventDefault(), Sn();
        return;
      }
      if (me.key === "-" || me.key === "_") {
        me.preventDefault(), Mi();
        return;
      }
    }
    function wn() {
      if (v.value.length === 0) {
        ee();
        return;
      }
      let me = 1 / 0, Se = -1 / 0, Oe = 1 / 0, $e = -1 / 0;
      for (const we of v.value) {
        me = Math.min(me, we.keyframe.frame), Se = Math.max(Se, we.keyframe.frame);
        const Le = H(we.keyframe.value);
        Oe = Math.min(Oe, Le), $e = Math.max($e, Le);
      }
      const W = (Se - me) * 0.1 || 10, ve = ($e - Oe) * 0.1 || 10;
      f.frameStart = me - W, f.frameEnd = Se + W, f.valueMin = Oe - ve, f.valueMax = $e + ve, ot();
    }
    function Sn() {
      const me = (f.frameStart + f.frameEnd) / 2, Se = f.frameEnd - f.frameStart;
      f.frameStart = me - Se * 0.4, f.frameEnd = me + Se * 0.4, ot();
    }
    function Mi() {
      const me = (f.frameStart + f.frameEnd) / 2, Se = f.frameEnd - f.frameStart;
      f.frameStart = me - Se * 0.6, f.frameEnd = me + Se * 0.6, ot();
    }
    let os = null;
    return Xn(() => {
      o.value && (os = new ResizeObserver((me) => {
        for (const Se of me)
          h.value = Se.contentRect.width, d.value = Se.contentRect.height, ot();
      }), os.observe(o.value)), _.value = U.value.filter((me) => me.animated).map((me) => me.id), window.addEventListener("keydown", Ln), ee(), ot();
    }), Ni(() => {
      os == null || os.disconnect(), window.removeEventListener("keydown", Ln);
    }), At([() => i.currentFrame, _, p], () => {
      ot();
    }), At(U, () => {
      ee(), ot();
    }, { deep: !0 }), (me, Se) => {
      var Oe, $e;
      return ie(), ue("div", m$, [
        y("div", g$, [
          Se[9] || (Se[9] = y("span", { class: "graph-title" }, "Graph Editor", -1)),
          y("div", v$, [
            y("button", {
              class: Ye({ active: p.value === "value" }),
              onClick: Se[0] || (Se[0] = (W) => p.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            y("button", {
              class: Ye({ active: p.value === "speed" }),
              onClick: Se[1] || (Se[1] = (W) => p.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          y("div", y$, [
            (ie(), ue(nt, null, pt(O, (W) => y("button", {
              key: W.key,
              class: Ye(["preset-btn", { active: j(W.key) }]),
              onClick: (ve) => te(W.key),
              title: W.label
            }, Ae(W.shortLabel), 11, _$)), 64))
          ]),
          y("div", x$, [
            y("button", {
              onClick: ee,
              title: "Fit to View"
            }, [...Se[5] || (Se[5] = [
              y("span", { class: "icon" }, "[ ]", -1)
            ])]),
            y("button", {
              onClick: N,
              class: Ye({ active: T.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...Se[6] || (Se[6] = [
              y("span", { class: "icon" }, "A", -1)
            ])], 2),
            y("button", {
              onClick: Se[2] || (Se[2] = (W) => E.value = !E.value),
              class: Ye({ active: E.value }),
              title: "Snap to Grid"
            }, [...Se[7] || (Se[7] = [
              y("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          y("button", {
            class: "close-btn",
            onClick: Se[3] || (Se[3] = (W) => n("close"))
          }, [...Se[8] || (Se[8] = [
            y("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        y("div", b$, [
          y("div", w$, [
            y("div", S$, [
              Se[10] || (Se[10] = xt(" Properties ", -1)),
              y("button", {
                class: "toggle-all-btn",
                onClick: X,
                title: L.value ? "Hide All" : "Show All"
              }, Ae(L.value ? "Hide" : "Show"), 9, M$)
            ]),
            (ie(!0), ue(nt, null, pt(U.value, (W) => (ie(), ue("div", {
              key: W.id,
              class: Ye(["property-item", {
                selected: m.value.includes(W.id),
                animated: W.animated
              }])
            }, [
              y("div", {
                class: "property-row",
                onClick: (ve) => I(W.id)
              }, [
                y("span", {
                  class: Ye(["visibility-toggle", { visible: _.value.includes(W.id) }]),
                  onClick: Rt((ve) => Q(W.id), ["stop"])
                }, null, 10, T$),
                y("span", {
                  class: "property-color",
                  style: Ct({ background: K(W.id) })
                }, null, 4),
                y("span", E$, Ae(W.name), 1),
                W.animated ? (ie(), ue("span", A$, Ae(W.keyframes.length), 1)) : Ne("", !0)
              ], 8, C$),
              W.name === "Position" || W.name === "Scale" ? (ie(), ue("div", P$, [
                (ie(), ue(nt, null, pt(["x", "y", "z"], (ve) => {
                  var we;
                  return y("button", {
                    key: ve,
                    class: Ye({
                      active: (we = g.value[W.id]) == null ? void 0 : we.includes(ve),
                      hasValue: z(W, ve)
                    }),
                    onClick: (Le) => k(W.id, ve)
                  }, Ae(ve.toUpperCase()), 11, D$);
                }), 64))
              ])) : Ne("", !0)
            ], 2))), 128)),
            U.value.length === 0 ? (ie(), ue("div", k$, " No animated properties ")) : Ne("", !0)
          ]),
          y("div", R$, [
            y("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              y("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: ut
              }, null, 512)
            ], 512),
            y("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              y("canvas", {
                ref_key: "canvasRef",
                ref: s,
                onMousedown: F,
                onMousemove: B,
                onMouseup: Y,
                onMouseleave: Y,
                onWheel: fe,
                onContextmenu: Rt(Pe, ["prevent"])
              }, null, 544),
              x.value ? (ie(), ue("div", {
                key: 0,
                class: "selection-box",
                style: Ct({
                  left: x.value.x + "px",
                  top: x.value.y + "px",
                  width: x.value.width + "px",
                  height: x.value.height + "px"
                })
              }, null, 4)) : Ne("", !0),
              (ie(), ue("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${h.value} ${d.value}`
              }, [
                (ie(!0), ue(nt, null, pt(D.value, (W) => (ie(), ue("g", {
                  key: W.id,
                  class: "property-handles"
                }, [
                  (ie(!0), ue(nt, null, pt(W.keyframes, (ve, we) => {
                    var Le, Me, We, Be, st, lt, yt, bt;
                    return ie(), ue(nt, { key: we }, [
                      G(ve) ? (ie(), ue("g", {
                        key: 0,
                        class: Ye(["keyframe-marker", {
                          selected: R(W.id, we),
                          hovered: ((Le = S.value) == null ? void 0 : Le.propId) === W.id && ((Me = S.value) == null ? void 0 : Me.index) === we
                        }]),
                        onMousedown: Rt((ft) => xe(W.id, we, ft), ["stop"])
                      }, [
                        y("rect", {
                          x: ne(ve) - 5,
                          y: $(W, ve) - 5,
                          width: "10",
                          height: "10",
                          fill: K(W.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${ne(ve)}, ${$(W, ve)})`
                        }, null, 8, O$)
                      ], 42, I$)) : Ne("", !0),
                      R(W.id, we) && ve.interpolation !== "hold" ? (ie(), ue("g", F$, [
                        W.keyframes[we + 1] && (ve.outHandle.enabled || ve.interpolation === "bezier") ? (ie(), ue("g", U$, [
                          y("line", {
                            x1: ne(ve),
                            y1: $(W, ve),
                            x2: se(W, we),
                            y2: le(W, we),
                            class: "handle-line"
                          }, null, 8, z$),
                          y("circle", {
                            cx: se(W, we),
                            cy: le(W, we),
                            r: "5",
                            class: Ye(["handle-point", { dragging: ((We = b.value) == null ? void 0 : We.type) === "outHandle" && ((Be = b.value) == null ? void 0 : Be.propId) === W.id && ((st = b.value) == null ? void 0 : st.index) === we }]),
                            onMousedown: Rt((ft) => Ee("outHandle", W.id, we), ["stop"])
                          }, null, 42, B$)
                        ])) : Ne("", !0),
                        we > 0 && (ve.inHandle.enabled || ve.interpolation === "bezier") ? (ie(), ue("g", N$, [
                          y("line", {
                            x1: ne(ve),
                            y1: $(W, ve),
                            x2: re(W, we),
                            y2: ye(W, we),
                            class: "handle-line"
                          }, null, 8, V$),
                          y("circle", {
                            cx: re(W, we),
                            cy: ye(W, we),
                            r: "5",
                            class: Ye(["handle-point", { dragging: ((lt = b.value) == null ? void 0 : lt.type) === "inHandle" && ((yt = b.value) == null ? void 0 : yt.propId) === W.id && ((bt = b.value) == null ? void 0 : bt.index) === we }]),
                            onMousedown: Rt((ft) => Ee("inHandle", W.id, we), ["stop"])
                          }, null, 42, G$)
                        ])) : Ne("", !0)
                      ])) : Ne("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                y("line", {
                  x1: P.value,
                  y1: 0,
                  x2: P.value,
                  y2: d.value,
                  class: "current-time-line"
                }, null, 8, H$)
              ], 8, L$))
            ], 512),
            y("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              y("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        v.value.length > 0 ? (ie(), ue("div", W$, [
          y("div", j$, [
            Se[11] || (Se[11] = y("span", { class: "info-label" }, "Frame:", -1)),
            y("input", {
              type: "number",
              value: (Oe = v.value[0]) == null ? void 0 : Oe.keyframe.frame,
              onChange: je,
              class: "info-input"
            }, null, 40, $$)
          ]),
          y("div", X$, [
            Se[12] || (Se[12] = y("span", { class: "info-label" }, "Value:", -1)),
            y("input", {
              type: "number",
              value: J(v.value[0]),
              onChange: Ke,
              class: "info-input",
              step: "0.1"
            }, null, 40, Y$)
          ]),
          y("div", q$, [
            Se[14] || (Se[14] = y("span", { class: "info-label" }, "Interpolation:", -1)),
            y("select", {
              value: ($e = v.value[0]) == null ? void 0 : $e.keyframe.interpolation,
              onChange: qe,
              class: "info-select"
            }, [...Se[13] || (Se[13] = [
              y("option", { value: "linear" }, "Linear", -1),
              y("option", { value: "bezier" }, "Bezier", -1),
              y("option", { value: "hold" }, "Hold", -1)
            ])], 40, Z$)
          ])
        ])) : Ne("", !0),
        M.value ? (ie(), ue("div", {
          key: 1,
          class: "context-menu",
          style: Ct({ left: M.value.x + "px", top: M.value.y + "px" }),
          onClick: Se[4] || (Se[4] = (W) => M.value = null)
        }, [
          y("button", { onClick: Ge }, "Add Keyframe"),
          y("button", {
            onClick: Ve,
            disabled: v.value.length === 0
          }, "Delete Keyframe(s)", 8, K$),
          Se[15] || (Se[15] = y("hr", null, null, -1)),
          y("button", {
            onClick: Qe,
            disabled: v.value.length === 0
          }, "Copy", 8, J$),
          y("button", {
            onClick: _e,
            disabled: !C.value
          }, "Paste", 8, Q$),
          Se[16] || (Se[16] = y("hr", null, null, -1)),
          y("button", { onClick: Ue }, "Select All"),
          y("button", { onClick: Fe }, "Invert Selection")
        ], 4)) : Ne("", !0)
      ]);
    };
  }
}), tX = /* @__PURE__ */ Yt(eX, [["__scopeId", "data-v-70deec8d"]]), { abs: tc, cos: sr, sin: Ra, acos: nX, atan2: nc, sqrt: Yr, pow: Qi } = Math;
function ic(r) {
  return r < 0 ? -Qi(-r, 1 / 3) : Qi(r, 1 / 3);
}
const vS = Math.PI, Fh = 2 * vS, qr = vS / 2, iX = 1e-6, Zp = Number.MAX_SAFE_INTEGER || 9007199254740991, Kp = Number.MIN_SAFE_INTEGER || -9007199254740991, sX = { x: 0, y: 0, z: 0 }, it = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const n = e(r);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), Yr(i);
  },
  compute: function(r, e, n) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (r === 1)
      return e[i].t = 1, e[i];
    const s = 1 - r;
    let o = e;
    if (i === 0)
      return e[0].t = r, e[0];
    if (i === 1) {
      const l = {
        x: s * o[0].x + r * o[1].x,
        y: s * o[0].y + r * o[1].y,
        t: r
      };
      return n && (l.z = s * o[0].z + r * o[1].z), l;
    }
    if (i < 4) {
      let l = s * s, c = r * r, u, h, d, p = 0;
      i === 2 ? (o = [o[0], o[1], o[2], sX], u = l, h = s * r * 2, d = c) : i === 3 && (u = l * s, h = l * r * 3, d = s * c * 3, p = r * c);
      const f = {
        x: u * o[0].x + h * o[1].x + d * o[2].x + p * o[3].x,
        y: u * o[0].y + h * o[1].y + d * o[2].y + p * o[3].y,
        t: r
      };
      return n && (f.z = u * o[0].z + h * o[1].z + d * o[2].z + p * o[3].z), f;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * r,
          y: a[l].y + (a[l + 1].y - a[l].y) * r
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * r);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = r, a[0];
  },
  computeWithRatios: function(r, e, n, i) {
    const s = 1 - r, o = n, a = e;
    let l = o[0], c = o[1], u = o[2], h = o[3], d;
    if (l *= s, c *= r, a.length === 2)
      return d = l + c, {
        x: (l * a[0].x + c * a[1].x) / d,
        y: (l * a[0].y + c * a[1].y) / d,
        z: i ? (l * a[0].z + c * a[1].z) / d : !1,
        t: r
      };
    if (l *= s, c *= 2 * s, u *= r * r, a.length === 3)
      return d = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / d,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / d,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z) / d : !1,
        t: r
      };
    if (l *= s, c *= 1.5 * s, u *= 3 * s, h *= r * r * r, a.length === 4)
      return d = l + c + u + h, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + h * a[3].x) / d,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + h * a[3].y) / d,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z + h * a[3].z) / d : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const n = [];
    for (let i = r, s = i.length, o = s - 1; s > 1; s--, o--) {
      const a = [];
      for (let l = 0, c; l < o; l++)
        c = {
          x: o * (i[l + 1].x - i[l].x),
          y: o * (i[l + 1].y - i[l].y)
        }, e && (c.z = o * (i[l + 1].z - i[l].z)), a.push(c);
      n.push(a), i = a;
    }
    return n;
  },
  between: function(r, e, n) {
    return e <= r && r <= n || it.approximately(r, e) || it.approximately(r, n);
  },
  approximately: function(r, e, n) {
    return tc(r - e) <= (n || iX);
  },
  length: function(r) {
    const n = it.Tvalues.length;
    let i = 0;
    for (let s = 0, o; s < n; s++)
      o = 0.5 * it.Tvalues[s] + 0.5, i += it.Cvalues[s] * it.arcfn(o, r);
    return 0.5 * i;
  },
  map: function(r, e, n, i, s) {
    const o = n - e, a = s - i, l = r - e, c = l / o;
    return i + a * c;
  },
  lerp: function(r, e, n) {
    const i = {
      x: e.x + r * (n.x - e.x),
      y: e.y + r * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + r * (n.z - e.z)), i;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(it.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, n) {
    const i = e.x - r.x, s = e.y - r.y, o = n.x - r.x, a = n.y - r.y, l = i * a - s * o, c = i * o + s * a;
    return nc(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const n = "" + r, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(r, e) {
    const n = r.x - e.x, i = r.y - e.y;
    return Yr(n * n + i * i);
  },
  closest: function(r, e) {
    let n = Qi(2, 63), i, s;
    return r.forEach(function(o, a) {
      s = it.dist(e, o), s < n && (n = s, i = a);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = Qi(r, e) + Qi(1 - r, e), i = n - 1;
    return tc(i / n);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = Qi(1 - r, e), i = Qi(r, e) + n;
    return n / i;
  },
  lli8: function(r, e, n, i, s, o, a, l) {
    const c = (r * i - e * n) * (s - a) - (r - n) * (s * l - o * a), u = (r * i - e * n) * (o - l) - (e - i) * (s * l - o * a), h = (r - n) * (o - l) - (e - i) * (s - a);
    return h == 0 ? !1 : { x: c / h, y: u / h };
  },
  lli4: function(r, e, n, i) {
    const s = r.x, o = r.y, a = e.x, l = e.y, c = n.x, u = n.y, h = i.x, d = i.y;
    return it.lli8(s, o, a, l, c, u, h, d);
  },
  lli: function(r, e) {
    return it.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new yS(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = Zp, n = Zp, i = Kp, s = Kp;
    return r.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), i < a.x.max && (i = a.x.max), s < a.y.max && (s = a.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + s) / 2, max: s, size: s - n }
    };
  },
  shapeintersections: function(r, e, n, i, s) {
    if (!it.bboxoverlap(e, i)) return [];
    const o = [], a = [r.startcap, r.forward, r.back, r.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const h = c.intersects(u, s);
        h.length > 0 && (h.c1 = c, h.c2 = u, h.s1 = r, h.s2 = n, o.push(h));
      });
    }), o;
  },
  makeshape: function(r, e, n) {
    const i = e.points.length, s = r.points.length, o = it.makeline(e.points[i - 1], r.points[0]), a = it.makeline(r.points[s - 1], e.points[0]), l = {
      startcap: o,
      forward: r,
      back: e,
      endcap: a,
      bbox: it.findbbox([o, r, e, a])
    };
    return l.intersections = function(c) {
      return it.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(r, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = Zp, s = Kp, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      o = n[l], a = r.get(o), a[e] < i && (i = a[e]), a[e] > s && (s = a[e]);
    return { min: i, mid: (i + s) / 2, max: s, size: s - i };
  },
  align: function(r, e) {
    const n = e.p1.x, i = e.p1.y, s = -nc(e.p2.y - i, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * sr(s) - (a.y - i) * Ra(s),
        y: (a.x - n) * Ra(s) + (a.y - i) * sr(s)
      };
    };
    return r.map(o);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = r.length - 1, i = it.align(r, e), s = function(E) {
      return 0 <= E && E <= 1;
    };
    if (n === 2) {
      const E = i[0].y, T = i[1].y, w = i[2].y, A = E - 2 * T + w;
      if (A !== 0) {
        const O = -Yr(T * T - E * w), U = -E + T, D = -(O + U) / A, L = -(-O + U) / A;
        return [D, L].filter(s);
      } else if (T !== w && A === 0)
        return [(2 * T - w) / (2 * T - 2 * w)].filter(s);
      return [];
    }
    const o = i[0].y, a = i[1].y, l = i[2].y, c = i[3].y;
    let u = -o + 3 * a - 3 * l + c, h = 3 * o - 6 * a + 3 * l, d = -3 * o + 3 * a, p = o;
    if (it.approximately(u, 0)) {
      if (it.approximately(h, 0))
        return it.approximately(d, 0) ? [] : [-p / d].filter(s);
      const E = Yr(d * d - 4 * h * p), T = 2 * h;
      return [(E - d) / T, (-d - E) / T].filter(s);
    }
    h /= u, d /= u, p /= u;
    const f = (3 * d - h * h) / 3, m = f / 3, _ = (2 * h * h * h - 9 * h * d + 27 * p) / 27, g = _ / 2, v = g * g + m * m * m;
    let S, b, x, M, C;
    if (v < 0) {
      const E = -f / 3, T = E * E * E, w = Yr(T), A = -_ / (2 * w), O = A < -1 ? -1 : A > 1 ? 1 : A, U = nX(O), D = ic(w), L = 2 * D;
      return x = L * sr(U / 3) - h / 3, M = L * sr((U + Fh) / 3) - h / 3, C = L * sr((U + 2 * Fh) / 3) - h / 3, [x, M, C].filter(s);
    } else {
      if (v === 0)
        return S = g < 0 ? ic(-g) : -ic(g), x = 2 * S - h / 3, M = -S - h / 3, [x, M].filter(s);
      {
        const E = Yr(v);
        return S = ic(-g + E), b = ic(g + E), [S - b - h / 3].filter(s);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], n = r[1], i = r[2], s = e - 2 * n + i;
      if (s !== 0) {
        const o = -Yr(n * n - e * i), a = -e + n, l = -(o + a) / s, c = -(-o + a) / s;
        return [l, c];
      } else if (n !== i && s === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], n = r[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(r, e, n, i, s) {
    let o, a, l, c, u = 0, h = 0;
    const d = it.compute(r, e), p = it.compute(r, n), f = d.x * d.x + d.y * d.y;
    if (i ? (o = Yr(
      Qi(d.y * p.z - p.y * d.z, 2) + Qi(d.z * p.x - p.z * d.x, 2) + Qi(d.x * p.y - p.x * d.y, 2)
    ), a = Qi(f + d.z * d.z, 3 / 2)) : (o = d.x * p.y - d.y * p.x, a = Qi(f, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = o / a, h = a / o, !s) {
      const m = it.curvature(r - 1e-3, e, n, i, !0).k, _ = it.curvature(r + 1e-3, e, n, i, !0).k;
      c = (_ - u + (u - m)) / 2, l = (tc(_ - u) + tc(u - m)) / 2;
    }
    return { k: u, r: h, dk: c, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = it.align(r, { p1: r[0], p2: r.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, s = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * i + 3 * s - o), l = 18 * (3 * n - i - 3 * s), c = 18 * (s - n);
    if (it.approximately(a, 0)) {
      if (!it.approximately(l, 0)) {
        let p = -c / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const u = 2 * a;
    if (it.approximately(u, 0)) return [];
    const h = l * l - 4 * a * c;
    if (h < 0) return [];
    const d = Math.sqrt(h);
    return [(d - l) / u, -(l + d) / u].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const n = ["x", "y"], i = n.length;
    for (let s = 0, o, a, l, c; s < i; s++)
      if (o = n[s], a = r[o].mid, l = e[o].mid, c = (r[o].size + e[o].size) / 2, tc(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, n) {
    const i = r.bbox(), s = e.bbox(), o = 1e5, a = n || 0.5;
    if (i.x.size + i.y.size < a && s.x.size + s.y.size < a)
      return [
        (o * (r._t1 + r._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = r.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(d) {
      return it.bboxoverlap(d.left.bbox(), d.right.bbox());
    });
    let h = [];
    return u.length === 0 || (u.forEach(function(d) {
      h = h.concat(
        it.pairiteration(d.left, d.right, a)
      );
    }), h = h.filter(function(d, p) {
      return h.indexOf(d) === p;
    })), h;
  },
  getccenter: function(r, e, n) {
    const i = e.x - r.x, s = e.y - r.y, o = n.x - e.x, a = n.y - e.y, l = i * sr(qr) - s * Ra(qr), c = i * Ra(qr) + s * sr(qr), u = o * sr(qr) - a * Ra(qr), h = o * Ra(qr) + a * sr(qr), d = (r.x + e.x) / 2, p = (r.y + e.y) / 2, f = (e.x + n.x) / 2, m = (e.y + n.y) / 2, _ = d + l, g = p + c, v = f + u, S = m + h, b = it.lli8(d, p, _, g, f, m, v, S), x = it.dist(b, r);
    let M = nc(r.y - b.y, r.x - b.x), C = nc(e.y - b.y, e.x - b.x), E = nc(n.y - b.y, n.x - b.x), T;
    return M < E ? ((M > C || C > E) && (M += Fh), M > E && (T = E, E = M, M = T)) : E < C && C < M ? (T = E, E = M, M = T) : E += Fh, b.s = M, b.e = E, b.r = x, b;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class Ic {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return it.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      it.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new Ic(n);
  }
}
const { abs: sc, min: P_, max: D_, cos: rX, sin: oX, acos: aX, sqrt: rc } = Math, lX = Math.PI;
let yS = class Mn {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const f = [];
      n.forEach(function(m) {
        ["x", "y", "z"].forEach(function(_) {
          typeof m[_] < "u" && f.push(m[_]);
        });
      }), n = f;
    }
    let s = !1;
    const o = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        s = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !s && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = a ? 3 : 2; f < o; f += m) {
      var c = {
        x: n[f],
        y: n[f + 1]
      };
      a && (c.z = n[f + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, h = this.dims = ["x", "y"];
    a && h.push("z"), this.dimlen = h.length;
    const d = it.align(l, { p1: l[0], p2: l[u] }), p = it.dist(l[0], l[u]);
    this._linear = d.reduce((f, m) => f + sc(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, i, s) {
    if (typeof s > "u" && (s = 0.5), s === 0)
      return new Mn(n, n, i);
    if (s === 1)
      return new Mn(e, n, n);
    const o = Mn.getABC(2, e, n, i, s);
    return new Mn(e, o.A, i);
  }
  static cubicFromPoints(e, n, i, s, o) {
    typeof s > "u" && (s = 0.5);
    const a = Mn.getABC(3, e, n, i, s);
    typeof o > "u" && (o = it.dist(n, a.C));
    const l = o * (1 - s) / s, c = it.dist(e, i), u = (i.x - e.x) / c, h = (i.y - e.y) / c, d = o * u, p = o * h, f = l * u, m = l * h, _ = { x: n.x - d, y: n.y - p }, g = { x: n.x + f, y: n.y + m }, v = a.A, S = { x: v.x + (_.x - v.x) / (1 - s), y: v.y + (_.y - v.y) / (1 - s) }, b = { x: v.x + (g.x - v.x) / s, y: v.y + (g.y - v.y) / s }, x = { x: e.x + (S.x - e.x) / s, y: e.y + (S.y - e.y) / s }, M = {
      x: i.x + (b.x - i.x) / (1 - s),
      y: i.y + (b.y - i.y) / (1 - s)
    };
    return new Mn(e, x, M, i);
  }
  static getUtils() {
    return it;
  }
  getUtils() {
    return Mn.getUtils();
  }
  static get PolyBezier() {
    return Ic;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return it.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, s = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      s.push(e[o].x), s.push(e[o].y);
    return s.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = it.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = it.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return it.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, s, o = 0.5) {
    const a = it.projectionratio(o, e), l = 1 - a, c = {
      x: a * n.x + l * s.x,
      y: a * n.y + l * s.y
    }, u = it.abcratio(o, e);
    return { A: {
      x: i.x + (i.x - c.x) / u,
      y: i.y + (i.y - c.y) / u
    }, B: i, C: c, S: n, E: s };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], s = this.points[this.order];
    return Mn.getABC(this.order, i, n, s, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, s; n < e; n++)
      s = n / (e - 1), i = this.compute(s), i.t = s, this._lut.push(i);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), s = [];
    for (let o = 0, a, l = 0; o < i.length; o++)
      a = i[o], it.dist(a, e) < n && (s.push(a), l += o / i.length);
    return s.length ? t /= s.length : !1;
  }
  project(e) {
    const n = this.getLUT(), i = n.length - 1, s = it.closest(n, e), o = s.mpos, a = (o - 1) / i, l = (o + 1) / i, c = 0.1 / i;
    let u = s.mdist, h = a, d = h, p;
    u += 1;
    for (let f; h < l + c; h += c)
      p = this.compute(h), f = it.dist(e, p), f < u && (u = f, d = h);
    return d = d < 0 ? 0 : d > 1 ? 1 : d, p = this.compute(d), p.t = d, p.d = u, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? it.computeWithRatios(e, this.points, this.ratios, this._3d) : it.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let s = 1, o, a; s < i; s++)
      o = e[s], a = e[s - 1], n[s] = {
        x: (i - s) / i * o.x + s / i * a.x,
        y: (i - s) / i * o.y + s / i * a.y
      };
    return n[i] = e[i - 1], new Mn(n);
  }
  derivative(e) {
    return it.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return it.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new Mn(it.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return it.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return it.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = rc(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), s = rc(n.x * n.x + n.y * n.y + n.z * n.z), o = rc(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= s, n.y /= s, n.z /= s, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, l = rc(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, i = [], s = [], o = 0;
    for (s[o++] = n[0], s[o++] = n[1], s[o++] = n[2], this.order === 3 && (s[o++] = n[3]); n.length > 1; ) {
      i = [];
      for (let a = 0, l, c = n.length - 1; a < c; a++)
        l = it.lerp(e, n[a], n[a + 1]), s[o++] = l, i.push(l);
      n = i;
    }
    return s;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), s = {
      left: this.order === 2 ? new Mn([i[0], i[3], i[5]]) : new Mn([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new Mn([i[5], i[4], i[2]]) : new Mn([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return s.left._t1 = it.map(0, 0, 1, this._t1, this._t2), s.left._t2 = it.map(e, 0, 1, this._t1, this._t2), s.right._t1 = it.map(e, 0, 1, this._t1, this._t2), s.right._t2 = it.map(1, 0, 1, this._t1, this._t2), n ? (n = it.map(n, e, 1, 0, 1), s.right.split(n).left) : s;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let s = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(s);
        e[i] = it.droots(o), this.order === 3 && (o = this.dpoints[1].map(s), e[i] = e[i].concat(it.droots(o))), e[i] = e[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[i].sort(it.numberSort));
      }).bind(this)
    ), e.values = n.sort(it.numberSort).filter(function(i, s) {
      return n.indexOf(i) === s;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = it.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return it.bboxoverlap(n, i);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), s = this.normal(e), o = {
        c: i,
        n: s,
        x: i.x + s.x * n,
        y: i.y + s.y * n
      };
      return this._3d && (o.z = i.z + s.z * n), o;
    }
    if (this._linear) {
      const i = this.normal(0), s = this.points.map(function(o) {
        const a = {
          x: o.x + e * i.x,
          y: o.y + e * i.y
        };
        return o.z && i.z && (a.z = o.z + e * i.z), a;
      });
      return [new Mn(s)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const s = it.angle(this.points[0], this.points[3], this.points[1]), o = it.angle(this.points[0], this.points[3], this.points[2]);
      if (s > 0 && o < 0 || s < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), sc(aX(i)) < lX / 3;
  }
  reduce() {
    let e, n = 0, i = 0, s = 0.01, o, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], o = this.split(n, i), o._t1 = n, o._t2 = i, a.push(o), n = i;
    return a.forEach(function(u) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + s; i <= 1 + s; i += s)
          if (o = u.split(n, i), !o.simple()) {
            if (i -= s, sc(n - i) < s)
              return [];
            o = u.split(n, i), o._t1 = it.map(n, 0, 1, u._t1, u._t2), o._t2 = it.map(i, 0, 1, u._t1, u._t2), l.push(o), n = i;
            break;
          }
      n < 1 && (o = u.split(n, 1), o._t1 = it.map(n, 0, 1, u._t1, u._t2), o._t2 = u._t2, l.push(o));
    }), l;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const s = this.order;
    let o = this.points.map((a, l) => (1 - l / s) * n + l / s * i);
    return new Mn(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const s = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const a = i ? i(0) : e, l = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], h = it.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(d) {
      const p = u[d * n] = it.copy(o[d * n]);
      p.x += (d ? l : a) * c[d].n.x, p.y += (d ? l : a) * c[d].n.y;
    }), i ? ([0, 1].forEach(function(d) {
      if (!(n === 2 && d)) {
        var p = o[d + 1], f = {
          x: p.x - h.x,
          y: p.y - h.y
        }, m = i ? i((d + 1) / n) : e;
        i && !s && (m = -m);
        var _ = rc(f.x * f.x + f.y * f.y);
        f.x /= _, f.y /= _, u[d + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new Mn(u)) : ([0, 1].forEach((d) => {
      if (n === 2 && d) return;
      const p = u[d * n], f = this.derivative(d), m = { x: p.x + f.x, y: p.y + f.y };
      u[d + 1] = it.lli4(p, m, h, o[d + 1]);
    }), new Mn(u));
  }
  outline(e, n, i, s) {
    if (n = n === void 0 ? e : n, this._linear) {
      const M = this.normal(0), C = this.points[0], E = this.points[this.points.length - 1];
      let T, w, A;
      i === void 0 && (i = e, s = n), T = { x: C.x + M.x * e, y: C.y + M.y * e }, A = { x: E.x + M.x * i, y: E.y + M.y * i }, w = { x: (T.x + A.x) / 2, y: (T.y + A.y) / 2 };
      const O = [T, w, A];
      T = { x: C.x - M.x * n, y: C.y - M.y * n }, A = { x: E.x - M.x * s, y: E.y - M.y * s }, w = { x: (T.x + A.x) / 2, y: (T.y + A.y) / 2 };
      const U = [A, w, T], D = it.makeline(U[2], O[0]), L = it.makeline(O[2], U[0]), P = [D, new Mn(O), L, new Mn(U)];
      return new Ic(P);
    }
    const o = this.reduce(), a = o.length, l = [];
    let c = [], u, h = 0, d = this.length();
    const p = typeof i < "u" && typeof s < "u";
    function f(M, C, E, T, w) {
      return function(A) {
        const O = T / E, U = (T + w) / E, D = C - M;
        return it.map(A, 0, 1, M + O * D, M + U * D);
      };
    }
    o.forEach(function(M) {
      const C = M.length();
      p ? (l.push(
        M.scale(f(e, i, d, h, C))
      ), c.push(
        M.scale(f(-n, -s, d, h, C))
      )) : (l.push(M.scale(e)), c.push(M.scale(-n))), h += C;
    }), c = c.map(function(M) {
      return u = M.points, u[3] ? M.points = [u[3], u[2], u[1], u[0]] : M.points = [u[2], u[1], u[0]], M;
    }).reverse();
    const m = l[0].points[0], _ = l[a - 1].points[l[a - 1].points.length - 1], g = c[a - 1].points[c[a - 1].points.length - 1], v = c[0].points[0], S = it.makeline(g, m), b = it.makeline(_, v), x = [S].concat(l).concat([b]).concat(c);
    return new Ic(x);
  }
  outlineshapes(e, n, i) {
    n = n || e;
    const s = this.outline(e, n).curves, o = [];
    for (let a = 1, l = s.length; a < l / 2; a++) {
      const c = it.makeshape(
        s[a],
        s[l - a],
        i
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, o.push(c);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof Mn && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = P_(e.p1.x, e.p2.x), i = P_(e.p1.y, e.p2.y), s = D_(e.p1.x, e.p2.x), o = D_(e.p1.y, e.p2.y);
    return it.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return it.between(l.x, n, s) && it.between(l.y, i, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, s = [];
    for (let o = 0, a, l, c; o < i; o++)
      l = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(l, c, e), s.push(...a);
    return s;
  }
  curveintersects(e, n, i) {
    const s = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && s.push({ left: a, right: l });
      });
    });
    let o = [];
    return s.forEach(function(a) {
      const l = it.pairiteration(
        a.left,
        a.right,
        i
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, s) {
    const o = (s - i) / 4, a = this.get(i + o), l = this.get(s - o), c = it.dist(e, n), u = it.dist(e, a), h = it.dist(e, l);
    return sc(u - c) + sc(h - c);
  }
  _iterate(e, n) {
    let i = 0, s = 1, o;
    do {
      o = 0, s = 1;
      let a = this.get(i), l, c, u, h, d = !1, p = !1, f, m = s, _ = 1;
      do
        if (p = d, h = u, m = (i + s) / 2, l = this.get(m), c = this.get(s), u = it.getccenter(a, l, c), u.interval = {
          start: i,
          end: s
        }, d = this._error(u, a, i, s) <= e, f = p && !d, f || (_ = s), d) {
          if (s >= 1) {
            if (u.interval.end = _ = 1, h = u, s > 1) {
              let v = {
                x: u.x + u.r * rX(u.e),
                y: u.y + u.r * oX(u.e)
              };
              u.e += it.angle({ x: u.x, y: u.y }, v, this.get(1));
            }
            break;
          }
          s = s + (s - i) / 2;
        } else
          s = m;
      while (!f && o++ < 100);
      if (o >= 100)
        break;
      h = h || u, n.push(h), i = _;
    } while (s < 1);
    return n;
  }
};
const cX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: yS
}, Symbol.toStringTag, { value: "Module" })), k_ = cX;
class uX {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    pe(this, "curve");
    pe(this, "lut");
    pe(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, i = this.curve.get(0);
    for (let s = 0; s <= e; s++) {
      const o = s / e, a = this.curve.get(o);
      if (s > 0) {
        const l = a.x - i.x, c = a.y - i.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: o,
        length: n
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.lut.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.lut[l].length < e ? n = l + 1 : i = l;
    }
    const s = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (s.length === o.length)
      return s.t;
    const a = (e - o.length) / (s.length - o.length);
    return o.t + a * (s.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], i = this.totalLength / (e - 1);
    for (let s = 0; s < e; s++) {
      const o = s * i;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function hX(r) {
  if (!r || r.length < 2)
    return null;
  let e = null;
  for (const n of r) {
    const [i, ...s] = n;
    if (i === "M")
      e = { x: s[0], y: s[1] };
    else {
      if (i === "C" && e)
        return new k_(
          e.x,
          e.y,
          s[0],
          s[1],
          // control point 1
          s[2],
          s[3],
          // control point 2
          s[4],
          s[5]
          // end point
        );
      if (i === "Q" && e)
        return new k_(
          e.x,
          e.y,
          s[0],
          s[1],
          // control point
          s[2],
          s[3]
          // end point
        );
    }
  }
  return null;
}
class dX {
  constructor() {
    pe(this, "offscreenCanvas", null);
    pe(this, "ctx", null);
    pe(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const i = Math.round(e / 8) * 8, s = Math.round(n / 8) * 8, o = Math.max(256, i), a = Math.max(256, s), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, i) {
    const { frameCount: s } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < s; c++) {
      i && i({
        frame: c,
        total: s,
        percent: Math.round(c / s * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), i && i({
      frame: s,
      total: s,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, i) {
    const s = this.ctx, { width: o, height: a } = i;
    if (s.fillStyle = "#FFFFFF", s.fillRect(0, 0, o, a), i.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    s.fillStyle = "#000000";
    const l = o / e.composition.width, c = a / e.composition.height, u = e.layers.filter(
      (d) => d.type === "text" && d.visible && n >= d.inPoint && n <= d.outPoint
    );
    for (const d of u)
      await this.renderTextLayerToMatte(s, d, e, n, l, c);
    const h = e.layers.filter(
      (d) => d.type === "particles" && d.visible && n >= d.inPoint && n <= d.outPoint
    );
    for (const d of h)
      this.renderParticleLayerToMatte(s, d, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, i) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== i.width || this.offscreenCanvas.height !== i.height) && (this.offscreenCanvas = new OffscreenCanvas(i.width, i.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const s = await this.generateFrame(e, n, i);
    return URL.createObjectURL(s);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, i, s, o, a) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((d) => d.name === "fontSize"), h = (c ? fn(c, s) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${h}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, i, s, h, o, a) : this.renderTextBlockToMatte(e, n, l, s, h, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, i, s, o, a, l, c) {
    const u = s.layers.find((b) => b.id === i.pathLayerId);
    if (!u || u.type !== "spline") return;
    const h = u.data;
    if (!(h != null && h.controlPoints) || h.controlPoints.length < 2) return;
    const d = this.buildPathCommands(h);
    if (!d || d.length < 2) return;
    const p = hX(d);
    if (!p) return;
    const f = new uX(p), m = n.properties.find((b) => b.name === "pathOffset"), _ = m ? fn(m, o) : i.pathOffset, g = f.totalLength;
    let v = _ * g;
    const S = 4 * Math.min(l, c);
    for (const b of i.text) {
      if (b === " ") {
        const O = e.measureText(" ").width;
        v += O + i.letterSpacing;
        continue;
      }
      const x = e.measureText(b).width, M = Math.max(0, Math.min(v, g)), { point: C, tangent: E } = f.getPointAtDistance(M), T = Math.atan2(E.y, E.x), w = C.x * l, A = C.y * c;
      e.save(), e.translate(w, A), e.rotate(T), e.fillRect(
        -S,
        -a - S,
        x + S * 2,
        a + S * 2
      ), e.restore(), v += x + i.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const i = [];
    i.push(["M", n[0].x, n[0].y]);
    for (let s = 0; s < n.length - 1; s++) {
      const o = n[s], a = n[s + 1], l = o.handleOut || { x: o.x, y: o.y }, c = a.handleIn || { x: a.x, y: a.y };
      i.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        a.x,
        a.y
      ]);
    }
    return i;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, i, s, o, a, l) {
    const c = n.transform.position, u = fn(c, s), h = n.transform.rotation, d = fn(h, s), p = n.transform.scale, f = fn(p, s);
    e.save(), e.translate(u.x * a, u.y * l), e.rotate(d * Math.PI / 180), e.scale(f.x, f.y);
    const _ = e.measureText(i.text).width, g = o, v = 4;
    e.fillRect(
      -v,
      -g - v,
      _ + v * 2,
      g + v * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", i) {
    const s = (await Promise.resolve().then(() => uZ)).default, o = new s();
    e.forEach((u, h) => {
      const d = `${n}_${String(h).padStart(4, "0")}.png`;
      o.file(d, u);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (u) => {
        i && i(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(a), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (i) => i.type === "particles"
    );
    for (const i of n) {
      const s = i.data;
      if (!s) continue;
      const o = new Sf(s.systemConfig);
      for (const l of s.emitters)
        o.addEmitter(l);
      for (const l of s.gravityWells)
        o.addGravityWell(l);
      for (const l of s.vortices)
        o.addVortex(l);
      for (const l of s.modulations)
        o.addModulation(l);
      const a = s.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(i.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const i of e.layers) {
        if (i.type !== "particles") continue;
        const s = this.particleSystems.get(i.id);
        s && i.visible && n >= i.inPoint && n <= i.outPoint && s.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, i, s) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(i, s), l = new OffscreenCanvas(i, s);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Do = new dX(), fX = { class: "export-dialog" }, pX = { class: "dialog-header" }, mX = { class: "dialog-content" }, gX = { class: "form-group" }, vX = { class: "resolution-presets" }, yX = ["onClick"], _X = { class: "custom-resolution" }, xX = { class: "dimension-input" }, bX = { class: "dimension-input" }, wX = {
  key: 0,
  class: "dimension-warning"
}, SX = { class: "form-group" }, MX = { class: "matte-mode-options" }, CX = { class: "form-group" }, TX = { class: "preview-container" }, EX = ["src"], AX = {
  key: 1,
  class: "preview-placeholder"
}, PX = {
  key: 0,
  class: "progress-section"
}, DX = { class: "progress-bar" }, kX = { class: "progress-text" }, RX = { class: "dialog-footer" }, LX = { class: "export-info" }, IX = ["disabled"], OX = ["disabled"], FX = /* @__PURE__ */ jt({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(r, { emit: e }) {
    const n = e, i = _n(), s = Do.getResolutionPresets(), o = Ce("720p (1280x720)"), a = Ce(1280), l = Ce(720), c = Ce(), u = Ce("exclude_text"), h = Ce(null), d = Ce(!1), p = Ce(0), f = Ce(""), m = Xe(() => a.value), _ = Xe(() => l.value);
    function g(x) {
      o.value = x.label, a.value = x.width, l.value = x.height, c.value = void 0;
    }
    function v() {
      const x = Do.validateDimensions(a.value, l.value);
      if (!x.valid)
        a.value = x.correctedWidth, l.value = x.correctedHeight, c.value = x.message, o.value = "";
      else {
        c.value = void 0;
        const M = s.find(
          (C) => C.width === a.value && C.height === l.value
        );
        o.value = (M == null ? void 0 : M.label) || "";
      }
    }
    async function S() {
      if (!i.hasProject) return;
      h.value && (URL.revokeObjectURL(h.value), h.value = null);
      const x = {
        width: m.value,
        height: _.value,
        matteMode: u.value
      };
      h.value = await Do.generatePreviewFrame(
        i.project,
        0,
        x
      );
    }
    async function b() {
      if (d.value || !i.hasProject) return;
      d.value = !0, p.value = 0, f.value = "Generating frames...";
      const x = {
        width: m.value,
        height: _.value,
        matteMode: u.value
      };
      try {
        const M = await Do.generateMatteSequence(
          i.project,
          x,
          (C) => {
            p.value = C.percent, f.value = `Generating frame ${C.frame + 1} of ${C.total}...`;
          }
        );
        f.value = "Creating ZIP archive...", await Do.downloadAsZip(
          M,
          `matte_${Date.now()}`,
          (C) => {
            f.value = `Compressing... ${C}%`;
          }
        ), f.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (M) {
        console.error("[ExportDialog] Export failed:", M), f.value = `Export failed: ${M instanceof Error ? M.message : "Unknown error"}`;
      } finally {
        d.value = !1;
      }
    }
    return At(
      [m, _, u],
      () => {
        S();
      },
      { immediate: !1 }
    ), Xn(() => {
      if (i.hasProject) {
        const x = Do.validateDimensions(i.width, i.height);
        a.value = x.correctedWidth, l.value = x.correctedHeight;
        const M = s.find(
          (C) => C.width === a.value && C.height === l.value
        );
        o.value = (M == null ? void 0 : M.label) || "", x.valid || (c.value = x.message);
      }
      S();
    }), Ni(() => {
      h.value && URL.revokeObjectURL(h.value), Do.dispose();
    }), (x, M) => (ie(), ue("div", {
      class: "export-dialog-overlay",
      onClick: M[6] || (M[6] = Rt((C) => n("close"), ["self"]))
    }, [
      y("div", fX, [
        y("div", pX, [
          M[8] || (M[8] = y("h3", null, "Export Matte Sequence", -1)),
          y("button", {
            class: "close-btn",
            onClick: M[0] || (M[0] = (C) => n("close"))
          }, [...M[7] || (M[7] = [
            y("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        y("div", mX, [
          y("div", gX, [
            M[13] || (M[13] = y("label", null, "Resolution", -1)),
            y("div", vX, [
              (ie(!0), ue(nt, null, pt(Je(s), (C) => (ie(), ue("button", {
                key: C.label,
                class: Ye(["preset-btn", { active: o.value === C.label }]),
                onClick: (E) => g(C)
              }, Ae(C.label), 11, yX))), 128))
            ]),
            y("div", _X, [
              y("div", xX, [
                M[9] || (M[9] = y("label", null, "Width", -1)),
                wt(y("input", {
                  "onUpdate:modelValue": M[1] || (M[1] = (C) => a.value = C),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: v
                }, null, 544), [
                  [
                    Tn,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              M[11] || (M[11] = y("span", { class: "dimension-x" }, "", -1)),
              y("div", bX, [
                M[10] || (M[10] = y("label", null, "Height", -1)),
                wt(y("input", {
                  "onUpdate:modelValue": M[2] || (M[2] = (C) => l.value = C),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: v
                }, null, 544), [
                  [
                    Tn,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (ie(), ue("p", wX, [
              M[12] || (M[12] = y("i", { class: "pi pi-info-circle" }, null, -1)),
              xt(" " + Ae(c.value), 1)
            ])) : Ne("", !0)
          ]),
          y("div", SX, [
            M[16] || (M[16] = y("label", null, "Matte Mode", -1)),
            y("div", MX, [
              y("button", {
                class: Ye(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: M[3] || (M[3] = (C) => u.value = "exclude_text")
              }, [...M[14] || (M[14] = [
                y("i", { class: "pi pi-ban" }, null, -1),
                y("span", null, "Exclude Text", -1),
                y("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              y("button", {
                class: Ye(["mode-btn", { active: u.value === "include_all" }]),
                onClick: M[4] || (M[4] = (C) => u.value = "include_all")
              }, [...M[15] || (M[15] = [
                y("i", { class: "pi pi-check-circle" }, null, -1),
                y("span", null, "Include All", -1),
                y("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          y("div", CX, [
            M[18] || (M[18] = y("label", null, "Preview (Frame 0)", -1)),
            y("div", TX, [
              h.value ? (ie(), ue("img", {
                key: 0,
                src: h.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, EX)) : (ie(), ue("div", AX, [...M[17] || (M[17] = [
                y("i", { class: "pi pi-image" }, null, -1),
                y("span", null, "Generating preview...", -1)
              ])]))
            ]),
            M[19] || (M[19] = y("p", { class: "preview-info" }, [
              xt(" White = Keep original / generate content"),
              y("br"),
              xt(" Black = Exclude from generation ")
            ], -1))
          ]),
          d.value ? (ie(), ue("div", PX, [
            y("div", DX, [
              y("div", {
                class: "progress-fill",
                style: Ct({ width: `${p.value}%` })
              }, null, 4)
            ]),
            y("p", kX, Ae(f.value), 1)
          ])) : Ne("", !0)
        ]),
        y("div", RX, [
          y("div", LX, [
            y("span", null, Ae(Je(i).frameCount) + " frames @ " + Ae(m.value) + "" + Ae(_.value), 1)
          ]),
          y("button", {
            class: "cancel-btn",
            onClick: M[5] || (M[5] = (C) => n("close")),
            disabled: d.value
          }, " Cancel ", 8, IX),
          y("button", {
            class: "export-btn",
            onClick: b,
            disabled: d.value || !Je(i).hasProject
          }, [
            M[20] || (M[20] = y("i", { class: "pi pi-download" }, null, -1)),
            xt(" " + Ae(d.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, OX)
        ])
      ])
    ]));
  }
}), UX = /* @__PURE__ */ Yt(FX, [["__scopeId", "data-v-34eee532"]]), zX = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !1,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  motionctrl: {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 3
  },
  cogvideox: {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ati: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ttm: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  }
}, BX = {
  midas: {
    format: "midas",
    bitDepth: 8,
    invert: !0,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  zoe: {
    format: "zoe",
    bitDepth: 16,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: !1,
    normalize: !1,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  normalized: {
    format: "normalized",
    bitDepth: 8,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
}, NX = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
], VX = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
], R_ = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  motionctrl: {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  cogvideox: {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  ati: {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  ttm: {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};
function GX(r) {
  const { width: e, height: n, nearClip: i, farClip: s, camera: o, layers: a, frame: l } = r, c = new Float32Array(e * n);
  c.fill(s);
  let u = s, h = i;
  const d = [...a].filter((p) => p.visible).sort((p, f) => {
    const m = Jp(p, l), _ = Jp(f, l);
    return m - _;
  });
  for (const p of d) {
    const f = Jp(p, l), m = HX(p, l);
    if (m < 0.01) continue;
    const _ = WX(p, l, o, e, n);
    if (!_) continue;
    const g = o.position.z, v = Math.abs(f - g), S = Math.max(i, Math.min(s, v));
    u = Math.min(u, S), h = Math.max(h, S), p.type === "depthflow" && jX(p) ? $X(c, p, _, e, n, i, s) : XX(c, _, S, m, e, n);
  }
  return {
    depthBuffer: c,
    width: e,
    height: n,
    minDepth: u,
    maxDepth: h
  };
}
function Jp(r, e) {
  var i;
  const n = (i = r.transform) == null ? void 0 : i.position;
  if (!n) return 0;
  if (n.keyframes && n.keyframes.length > 0)
    return _S(n.keyframes, e, 2) || 0;
  if (n.value) {
    const s = n.value;
    if (typeof s == "object" && "z" in s)
      return s.z ?? 0;
  }
  return 0;
}
function HX(r, e) {
  var n;
  return r.opacity && "keyframes" in r.opacity && ((n = r.opacity.keyframes) == null ? void 0 : n.length) > 0 ? (_S(r.opacity.keyframes, e) || 100) / 100 : r.opacity && "value" in r.opacity ? (r.opacity.value || 100) / 100 : 1;
}
function WX(r, e, n, i, s) {
  var T, w, A;
  let o = 0, a = 0;
  const l = (T = r.transform) == null ? void 0 : T.position;
  if (l && "value" in l) {
    const O = l.value;
    Array.isArray(O) && (o = O[0] || 0, a = O[1] || 0);
  }
  const c = r.width || i, u = r.height || s;
  let h = 1, d = 1;
  const p = (w = r.transform) == null ? void 0 : w.scale;
  if (p && "value" in p) {
    const O = p.value;
    Array.isArray(O) && (h = (O[0] || 100) / 100, d = (O[1] || 100) / 100);
  }
  const f = c * h, m = u * d;
  let _ = 0.5, g = 0.5;
  const v = (A = r.transform) == null ? void 0 : A.anchorPoint;
  if (v && "value" in v) {
    const O = v.value;
    Array.isArray(O) && (_ = (O[0] || 0) / c + 0.5, g = (O[1] || 0) / u + 0.5);
  }
  const S = o - f * _ + i / 2, b = a - m * g + s / 2, x = Math.max(0, Math.min(i, S)), M = Math.max(0, Math.min(s, b)), C = Math.max(0, Math.min(i - x, f - (x - S))), E = Math.max(0, Math.min(s - M, m - (M - b)));
  return C <= 0 || E <= 0 ? null : {
    x,
    y: M,
    width: C,
    height: E
  };
}
function jX(r) {
  return r.type === "depthflow" && !!r.depthMapData;
}
function $X(r, e, n, i, s, o, a) {
  const l = e.depthMapData, c = e.depthWidth || n.width, u = e.depthHeight || n.height;
  for (let h = 0; h < n.height; h++)
    for (let d = 0; d < n.width; d++) {
      const p = Math.floor(n.x + d), f = Math.floor(n.y + h);
      if (p < 0 || p >= i || f < 0 || f >= s) continue;
      const m = Math.floor(d / n.width * c), g = Math.floor(h / n.height * u) * c + m;
      let v;
      l instanceof Float32Array ? v = l[g] : v = l[g] / 255;
      const S = o + v * (a - o), b = f * i + p;
      S < r[b] && (r[b] = S);
    }
}
function XX(r, e, n, i, s, o) {
  const a = Math.floor(e.x), l = Math.floor(e.y), c = Math.min(s, Math.ceil(e.x + e.width)), u = Math.min(o, Math.ceil(e.y + e.height));
  for (let h = l; h < u; h++)
    for (let d = a; d < c; d++) {
      const p = h * s + d;
      i > 0.5 && n < r[p] && (r[p] = n);
    }
}
function _S(r, e, n) {
  if (!r || r.length === 0) return null;
  let i = r[0], s = r[r.length - 1];
  for (let c = 0; c < r.length; c++)
    if (r[c].frame <= e && (i = r[c]), r[c].frame >= e && c < r.length) {
      s = r[c];
      break;
    }
  if (i.frame === s.frame) {
    const c = i.value;
    return n !== void 0 && Array.isArray(c) ? c[n] : c;
  }
  const o = (e - i.frame) / (s.frame - i.frame), a = n !== void 0 && Array.isArray(i.value) ? i.value[n] : i.value, l = n !== void 0 && Array.isArray(s.value) ? s.value[n] : s.value;
  return a + (l - a) * o;
}
function YX(r, e) {
  const n = BX[e], { depthBuffer: i, width: s, height: o, minDepth: a, maxDepth: l } = r, c = s * o;
  if (n.bitDepth === 16) {
    const u = new Uint16Array(c);
    for (let h = 0; h < c; h++) {
      let d;
      n.normalize ? d = (i[h] - a) / (l - a) : d = i[h] / n.farClip, n.invert && (d = 1 - d), u[h] = Math.max(0, Math.min(65535, Math.round(d * 65535)));
    }
    return u;
  } else {
    const u = new Uint8Array(c);
    for (let h = 0; h < c; h++) {
      let d = (i[h] - a) / (l - a);
      n.invert && (d = 1 - d), u[h] = Math.max(0, Math.min(255, Math.round(d * 255)));
    }
    return u;
  }
}
function qX(r, e, n) {
  const i = new ImageData(e, n), s = r instanceof Uint16Array;
  for (let o = 0; o < e * n; o++) {
    const a = s ? Math.floor(r[o] / 256) : r[o], l = o * 4;
    i.data[l] = a, i.data[l + 1] = a, i.data[l + 2] = a, i.data[l + 3] = 255;
  }
  return i;
}
class ZX {
  constructor(e) {
    pe(this, "serverAddress");
    pe(this, "clientId");
    pe(this, "ws", null);
    pe(this, "messageHandlers", /* @__PURE__ */ new Map());
    this.serverAddress = e.serverAddress.replace(/\/$/, ""), this.clientId = e.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      return (await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      })).ok;
    } catch {
      return !1;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const e = await fetch(`http://${this.serverAddress}/system_stats`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const e = await fetch(`http://${this.serverAddress}/prompt`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(e, n, i = "input", s, o = !0) {
    const a = new FormData();
    a.append("image", e, n), a.append("type", i), a.append("overwrite", o.toString()), s && a.append("subfolder", s);
    const l = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: a
    });
    if (!l.ok) {
      const c = await l.text();
      throw new Error(`Failed to upload image: ${c}`);
    }
    return l.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(e, n, i) {
    const s = new FormData();
    s.append("image", e, n), s.append("original_ref", JSON.stringify(i)), s.append("type", "input");
    const o = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: s
    });
    if (!o.ok)
      throw new Error(`Failed to upload mask: ${await o.text()}`);
    return o.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(e, n) {
    const i = {
      prompt: e,
      client_id: this.clientId,
      extra_data: n
    }, s = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(i)
    });
    if (!s.ok) {
      const o = await s.text();
      throw new Error(`Failed to queue prompt: ${o}`);
    }
    return s.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(e) {
    const n = e ? `http://${this.serverAddress}/history/${e}` : `http://${this.serverAddress}/history`, i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to get history: ${await i.text()}`);
    return i.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(e, n = "", i = "output") {
    const s = new URLSearchParams({
      filename: e,
      subfolder: n,
      type: i
    }), o = await fetch(`http://${this.serverAddress}/view?${s}`);
    if (!o.ok)
      throw new Error(`Failed to get output: ${await o.text()}`);
    return o.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(e, n = "", i = "output") {
    const s = await this.getOutput(e, n, i);
    return new Promise((o, a) => {
      const l = new FileReader();
      l.onloadend = () => o(l.result), l.onerror = a, l.readAsDataURL(s);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const e = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!e.ok)
      throw new Error(`Failed to interrupt: ${await e.text()}`);
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const e = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: !0 })
    });
    if (!e.ok)
      throw new Error(`Failed to clear queue: ${await e.text()}`);
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(e, n) {
    const i = await fetch(`http://${this.serverAddress}/${e}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: n })
    });
    if (!i.ok)
      throw new Error(`Failed to delete from ${e}: ${await i.text()}`);
  }
  /**
   * Get available models
   */
  async getModels(e) {
    const n = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    }, i = await fetch(
      `http://${this.serverAddress}/models/${n[e]}`
    );
    return i.ok ? i.json() : [];
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((e, n) => {
      const i = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(i), this.ws.onopen = () => {
        console.log("[ComfyUI] WebSocket connected"), e();
      }, this.ws.onerror = (s) => {
        console.error("[ComfyUI] WebSocket error:", s), n(new Error("WebSocket connection failed"));
      }, this.ws.onclose = () => {
        console.log("[ComfyUI] WebSocket disconnected"), this.ws = null;
      }, this.ws.onmessage = (s) => {
        try {
          const o = JSON.parse(s.data);
          this.handleWebSocketMessage(o);
        } catch (o) {
          console.error("[ComfyUI] Failed to parse WebSocket message:", o);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(e, n) {
    this.messageHandlers.set(e, n);
  }
  /**
   * Remove a message handler
   */
  offMessage(e) {
    this.messageHandlers.delete(e);
  }
  handleWebSocketMessage(e) {
    const { type: n } = e, i = this.messageHandlers.get(n);
    i && i(e);
    const s = this.messageHandlers.get("all");
    s && s(e);
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(e, n, i) {
    const s = new OffscreenCanvas(e.width, e.height);
    s.getContext("2d").putImageData(e, 0, 0);
    const a = await s.convertToBlob({ type: "image/png" });
    return this.uploadImage(a, n, "input", i);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(e, n, i) {
    let s;
    return e instanceof OffscreenCanvas ? s = await e.convertToBlob({ type: "image/png" }) : s = await new Promise((o, a) => {
      e.toBlob((l) => {
        l ? o(l) : a(new Error("Failed to convert canvas to blob"));
      }, "image/png");
    }), this.uploadImage(s, n, "input", i);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(e, n, i = 3e5) {
    const s = Date.now();
    return this.isWebSocketConnected() || await this.connectWebSocket(), new Promise((o, a) => {
      let l = !1;
      const c = () => {
        this.offMessage("progress"), this.offMessage("executing"), this.offMessage("executed"), this.offMessage("execution_error");
      }, u = () => {
        Date.now() - s > i && (c(), a(new Error("Prompt execution timed out")));
      };
      this.onMessage("progress", (h) => {
        u(), n == null || n({
          status: "executing",
          currentStep: h.data.value,
          totalSteps: h.data.max,
          percentage: h.data.value / h.data.max * 100
        });
      }), this.onMessage("executing", (h) => {
        u(), h.data.prompt_id === e && (n == null || n({
          status: "executing",
          currentNode: h.data.node,
          percentage: 10
          // Approximate
        }));
      }), this.onMessage("executed", async (h) => {
        if (h.data.prompt_id === e && !l) {
          l = !0, c(), n == null || n({
            status: "completed",
            percentage: 100
          });
          const d = await this.getHistory(e);
          o(d[e]);
        }
      }), this.onMessage("execution_error", (h) => {
        h.data.prompt_id === e && (c(), n == null || n({
          status: "error",
          percentage: 0
        }), a(new Error(h.data.exception_message || "Execution failed")));
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(e, n) {
    const { prompt_id: i } = await this.queuePrompt(e);
    n == null || n({
      status: "queued",
      percentage: 0
    });
    const s = await this.waitForPrompt(i, n), o = [];
    for (const a of Object.values(s.outputs))
      a.images && o.push(...a.images), a.gifs && o.push(...a.gifs);
    return {
      promptId: i,
      history: s,
      outputs: o
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let Uh = null;
function Ua(r) {
  return (!Uh || r && r !== Uh.server) && (Uh = new ZX({
    serverAddress: r || "127.0.0.1:8188"
  })), Uh;
}
let xS = 1;
function Ir() {
  xS = 1;
}
function _t() {
  return String(xS++);
}
function vt(r, e, n) {
  const i = {
    class_type: r,
    inputs: e
  };
  return n && (i._meta = { title: n }), i;
}
function et(r, e = 0) {
  return [r, e];
}
function Ov(r, e) {
  const n = _t();
  return r[n] = vt("CheckpointLoaderSimple", {
    ckpt_name: e
  }, "Load Checkpoint"), n;
}
function gl(r, e, n, i) {
  const s = _t();
  return r[s] = vt("CLIPTextEncode", {
    clip: e,
    text: n
  }, i), s;
}
function uo(r, e, n) {
  const i = _t();
  return r[i] = vt("LoadImage", {
    image: e
  }, n || "Load Image"), i;
}
function ho(r, e, n, i) {
  const s = _t();
  return r[s] = vt("ImageResize", {
    image: e,
    width: n,
    height: i,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image"), s;
}
function KX(r, e, n) {
  const i = _t();
  return r[i] = vt("VAEEncode", {
    pixels: e,
    vae: n
  }, "VAE Encode"), i;
}
function gu(r, e, n) {
  const i = _t();
  return r[i] = vt("VAEDecode", {
    samples: e,
    vae: n
  }, "VAE Decode"), i;
}
function vu(r, e, n, i, s, o) {
  const a = _t();
  return r[a] = vt("KSampler", {
    model: e,
    positive: n,
    negative: i,
    latent_image: s,
    seed: o.seed ?? Math.floor(Math.random() * 2147483647),
    steps: o.steps ?? 20,
    cfg: o.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: o.denoise ?? 1
  }, "KSampler"), a;
}
function Or(r, e, n) {
  const i = _t();
  return r[i] = vt("VHS_VideoCombine", {
    images: e,
    frame_rate: n.fps,
    loop_count: 0,
    filename_prefix: n.filename || "weyl_output",
    format: n.format || "video/h264-mp4",
    pingpong: !1,
    save_output: !0,
    audio: null,
    meta_batch: null
  }, "Video Output"), i;
}
function L_(r) {
  Ir();
  const e = {}, n = r.width > 640 || r.height > 640, i = r.wanModel || (n ? "i2v_720p" : "i2v_480p"), s = _t();
  e[s] = vt("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${i}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const o = _t();
  e[o] = vt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const a = _t();
  e[a] = vt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const l = uo(e, r.referenceImage || "input.png", "Reference Image"), c = ho(e, et(l), r.width, r.height), u = _t();
  e[u] = vt("WanTextEncode", {
    text_encoder: et(a),
    prompt: r.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const h = _t();
  e[h] = vt("WanImageToVideo", {
    wan_model: et(s),
    positive: et(u),
    image: et(c),
    vae: et(o),
    width: r.width,
    height: r.height,
    length: r.frameCount,
    steps: r.steps || 30,
    cfg: r.cfgScale || 5,
    seed: r.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: r.denoise || 1
  }, "I2V Generation");
  const d = _t();
  return e[d] = vt("WanVAEDecode", {
    vae: et(o),
    samples: et(h),
    enable_vae_tiling: !0,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode"), Or(e, et(d), {
    fps: r.fps,
    filename: r.outputFilename || "wan22_i2v"
  }), e;
}
function JX(r) {
  Ir();
  const e = {}, n = _t();
  e[n] = vt("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const i = _t();
  e[i] = vt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const s = _t();
  e[s] = vt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = uo(e, r.referenceImage || "input.png", "Reference Image"), a = ho(e, et(o), r.width, r.height), l = _t();
  e[l] = vt("WanTextEncode", {
    text_encoder: et(s),
    prompt: r.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const c = _t();
  e[c] = vt("WanFunCameraMotion", {
    motion_type: r.cameraMotion || "Static",
    length: r.frameCount
  }, "Camera Motion");
  const u = _t();
  e[u] = vt("WanFunCameraI2V", {
    wan_model: et(n),
    positive: et(l),
    image: et(a),
    camera_motion: et(c),
    vae: et(i),
    width: r.width,
    height: r.height,
    length: r.frameCount,
    steps: r.steps || 30,
    cfg: r.cfgScale || 5,
    seed: r.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const h = _t();
  return e[h] = vt("WanVAEDecode", {
    vae: et(i),
    samples: et(u),
    enable_vae_tiling: !0
  }, "VAE Decode"), Or(e, et(h), {
    fps: r.fps,
    filename: r.outputFilename || "wan22_fun_camera"
  }), e;
}
function QX(r) {
  Ir();
  const e = {}, n = _t();
  e[n] = vt("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const i = _t();
  e[i] = vt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const s = _t();
  e[s] = vt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = uo(e, r.referenceImage || "first.png", "First Frame"), a = uo(e, r.lastFrameImage || "last.png", "Last Frame"), l = ho(e, et(o), r.width, r.height), c = ho(e, et(a), r.width, r.height), u = _t();
  e[u] = vt("WanTextEncode", {
    text_encoder: et(s),
    prompt: r.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const h = _t();
  e[h] = vt("WanFirstLastFrameToVideo", {
    wan_model: et(n),
    positive: et(u),
    first_frame: et(l),
    last_frame: et(c),
    vae: et(i),
    width: r.width,
    height: r.height,
    length: r.frameCount,
    steps: r.steps || 30,
    cfg: r.cfgScale || 5,
    seed: r.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const d = _t();
  return e[d] = vt("WanVAEDecode", {
    vae: et(i),
    samples: et(h),
    enable_vae_tiling: !0
  }, "VAE Decode"), Or(e, et(d), {
    fps: r.fps,
    filename: r.outputFilename || "wan22_flf"
  }), e;
}
function eY(r) {
  var d;
  Ir();
  const e = {}, n = _t();
  e[n] = vt("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const i = _t();
  e[i] = vt("ImageOnlyCheckpointLoader", {
    ckpt_name: r.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const s = uo(e, r.referenceImage || "input.png", "Reference Image"), o = ho(e, et(s), r.width, r.height), a = _t();
  r.trajType === "custom" && ((d = r.cameraData) != null && d.trajectory) ? e[a] = vt("Uni3CCustomTrajectory", {
    trajectory_data: JSON.stringify(r.cameraData.trajectory),
    length: r.frameCount
  }, "Custom Trajectory") : e[a] = vt("Uni3CPresetTrajectory", {
    traj_type: r.trajType || "orbit",
    length: r.frameCount
  }, "Preset Trajectory");
  const l = _t();
  e[l] = vt("ApplyUni3CCameraControl", {
    model: et(i),
    uni3c: et(n),
    trajectory: et(a),
    image: et(o),
    control_strength: 1
  }, "Apply Camera Control");
  const c = _t();
  e[c] = vt("SVDEncode", {
    model: et(l),
    image: et(o),
    vae: et(i, 2),
    width: r.width,
    height: r.height,
    video_frames: r.frameCount,
    motion_bucket_id: 127,
    fps: r.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = vu(
    e,
    et(l),
    et(c, 1),
    et(c, 2),
    et(c),
    { seed: r.seed, steps: r.steps || 25, cfg: r.cfgScale || 2.5, denoise: 1 }
  ), h = gu(e, et(u), et(i, 2));
  return Or(e, et(h), {
    fps: r.fps,
    filename: r.outputFilename || "uni3c_output"
  }), e;
}
function tY(r) {
  Ir();
  const e = {}, n = _t();
  e[n] = vt("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const i = _t();
  e[i] = vt("ImageOnlyCheckpointLoader", {
    ckpt_name: r.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const s = uo(e, r.referenceImage || "input.png", "Reference Image"), o = ho(e, et(s), r.width, r.height), a = _t();
  r.cameraPoses ? e[a] = vt("MotionCtrlCameraPoses", {
    poses: JSON.stringify(r.cameraPoses)
  }, "Camera Poses") : e[a] = vt("MotionCtrlPresetPoses", {
    preset: r.motionPreset || "static",
    length: r.frameCount
  }, "Preset Poses");
  const l = _t();
  e[l] = vt("ApplyMotionCtrl", {
    model: et(i),
    motion_ctrl: et(n),
    camera_poses: et(a),
    control_strength: 1
  }, "Apply MotionCtrl");
  const c = _t();
  e[c] = vt("SVDEncode", {
    model: et(l),
    image: et(o),
    vae: et(i, 2),
    width: r.width,
    height: r.height,
    video_frames: r.frameCount,
    motion_bucket_id: 127,
    fps: r.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = vu(
    e,
    et(l),
    et(c, 1),
    et(c, 2),
    et(c),
    { seed: r.seed, steps: r.steps || 25, cfg: r.cfgScale || 2.5 }
  ), h = gu(e, et(u), et(i, 2));
  return Or(e, et(h), {
    fps: r.fps,
    filename: r.outputFilename || "motionctrl_output"
  }), e;
}
function nY(r) {
  Ir();
  const e = {}, n = Ov(e, r.checkpoint || "sd_xl_base_1.0.safetensors"), i = _t();
  e[i] = vt("ControlNetLoader", {
    control_net_name: r.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const s = _t();
  e[s] = vt("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: r.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const o = uo(e, r.referenceImage || "reference.png", "Reference Image"), a = ho(e, et(o), r.width, r.height), l = gl(e, et(n, 1), r.prompt, "Positive"), c = gl(e, et(n, 1), r.negativePrompt, "Negative"), u = _t();
  e[u] = vt("ControlNetApply", {
    conditioning: et(l),
    control_net: et(i),
    image: et(s),
    strength: 1
  }, "Apply ControlNet");
  const h = KX(e, et(a), et(n, 2)), d = vu(
    e,
    et(n),
    et(u),
    et(c),
    et(h),
    { seed: r.seed, steps: r.steps || 20, cfg: r.cfgScale || 7, denoise: r.denoise || 0.75 }
  ), p = gu(e, et(d), et(n, 2));
  return Or(e, et(p), {
    fps: r.fps,
    filename: r.outputFilename || "controlnet_depth"
  }), e;
}
function iY(r) {
  Ir();
  const e = {}, n = Ov(e, r.checkpoint || "dreamshaper_8.safetensors"), i = _t();
  e[i] = vt("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const s = _t();
  e[s] = vt("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const o = _t();
  r.cameraPoses ? e[o] = vt("ADE_CameraCtrlPoses", {
    poses: JSON.stringify(r.cameraPoses)
  }, "Camera Poses") : e[o] = vt("ADE_CameraCtrlPreset", {
    motion_type: r.cameraMotion || "Static",
    speed: 1,
    frame_length: r.frameCount
  }, "Camera Preset");
  const a = _t();
  e[a] = vt("ADE_ApplyAnimateDiffModel", {
    model: et(n),
    motion_model: et(i)
  }, "Apply AnimateDiff");
  const l = _t();
  e[l] = vt("ADE_ApplyCameraCtrl", {
    model: et(a),
    cameractrl: et(s),
    poses: et(o)
  }, "Apply CameraCtrl");
  const c = gl(e, et(n, 1), r.prompt, "Positive"), u = gl(e, et(n, 1), r.negativePrompt, "Negative"), h = _t();
  e[h] = vt("EmptyLatentImage", {
    width: r.width,
    height: r.height,
    batch_size: r.frameCount
  }, "Empty Latent");
  const d = vu(
    e,
    et(l),
    et(c),
    et(u),
    et(h),
    { seed: r.seed, steps: r.steps || 20, cfg: r.cfgScale || 7 }
  ), p = gu(e, et(d), et(n, 2));
  return Or(e, et(p), {
    fps: r.fps,
    filename: r.outputFilename || "animatediff_cameractrl"
  }), e;
}
function sY(r) {
  Ir();
  const e = {}, n = _t();
  e[n] = vt("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const i = _t();
  e[i] = vt("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const s = _t();
  e[s] = vt("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const o = uo(e, r.referenceImage || "input.png", "Reference Image"), a = ho(e, et(o), r.width, r.height), l = _t();
  e[l] = vt("CogVideoTextEncode", {
    text_encoder: et(i),
    prompt: r.prompt,
    force_offload: !0
  }, "Encode Prompt");
  const c = _t();
  e[c] = vt("CogVideoImageToVideo", {
    model: et(n),
    positive: et(l),
    image: et(a),
    vae: et(s),
    width: r.width,
    height: r.height,
    num_frames: r.frameCount,
    steps: r.steps || 50,
    cfg: r.cfgScale || 6,
    seed: r.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const u = _t();
  return e[u] = vt("CogVideoDecode", {
    vae: et(s),
    samples: et(c),
    enable_vae_tiling: !0
  }, "Decode Video"), Or(e, et(u), {
    fps: r.fps,
    filename: r.outputFilename || "cogvideox_output"
  }), e;
}
function I_(r, e) {
  Ir();
  const n = {}, i = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  }, s = Ov(n, r.checkpoint || "v1-5-pruned-emaonly.safetensors"), o = _t();
  n[o] = vt("ControlNetLoader", {
    control_net_name: r.controlnetModel || i[e]
  }, `Load ControlNet ${e}`);
  const a = _t();
  n[a] = vt("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: r.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const l = gl(n, et(s, 1), r.prompt, "Positive"), c = gl(n, et(s, 1), r.negativePrompt, "Negative"), u = _t();
  n[u] = vt("ControlNetApply", {
    conditioning: et(l),
    control_net: et(o),
    image: et(a),
    strength: 1
  }, "Apply ControlNet");
  const h = _t();
  n[h] = vt("EmptyLatentImage", {
    width: r.width,
    height: r.height,
    batch_size: r.frameCount
  }, "Empty Latent");
  const d = vu(
    n,
    et(s),
    et(u),
    et(c),
    et(h),
    { seed: r.seed, steps: r.steps || 20, cfg: r.cfgScale || 7 }
  ), p = gu(n, et(d), et(s, 2));
  return Or(n, et(p), {
    fps: r.fps,
    filename: r.outputFilename || `controlnet_${e}`
  }), n;
}
function rY(r, e) {
  switch (r) {
    case "wan22-i2v":
      return L_(e);
    case "wan22-t2v":
      return L_({ ...e, referenceImage: void 0 });
    case "wan22-fun-camera":
      return JX(e);
    case "wan22-first-last":
      return QX(e);
    case "uni3c-camera":
    case "uni3c-motion":
      return eY(e);
    case "motionctrl":
    case "motionctrl-svd":
      return tY(e);
    case "cogvideox":
      return sY(e);
    case "controlnet-depth":
      return nY(e);
    case "controlnet-canny":
      return I_(e, "canny");
    case "controlnet-lineart":
      return I_(e, "lineart");
    case "animatediff-cameractrl":
      return iY(e);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${r}`);
  }
}
function oY(r) {
  const e = [], n = [], i = Object.keys(r);
  for (const [o, a] of Object.entries(r)) {
    a.class_type || e.push(`Node ${o}: missing class_type`);
    for (const [l, c] of Object.entries(a.inputs))
      if (Array.isArray(c) && c.length === 2) {
        const [u] = c;
        typeof u == "string" && !i.includes(u) && e.push(`Node ${o}.${l}: references non-existent node ${u}`);
      }
  }
  return Object.values(r).some(
    (o) => o.class_type.includes("Save") || o.class_type.includes("Output") || o.class_type.includes("Preview")
  ) || n.push("Workflow has no output/save nodes"), {
    valid: e.length === 0,
    errors: e,
    warnings: n
  };
}
class aY {
  constructor(e) {
    pe(this, "layers");
    pe(this, "cameraKeyframes");
    pe(this, "config");
    pe(this, "onProgress");
    pe(this, "abortSignal");
    pe(this, "aborted", !1);
    this.layers = e.layers, this.cameraKeyframes = e.cameraKeyframes, this.config = e.config, this.onProgress = e.onProgress || (() => {
    }), this.abortSignal = e.abortSignal, this.abortSignal && this.abortSignal.addEventListener("abort", () => {
      this.aborted = !0;
    });
  }
  checkAborted() {
    if (this.aborted)
      throw new Error("Export aborted");
  }
  updateProgress(e) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...e
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const e = Date.now(), n = {
      success: !1,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const i = this.validateConfig();
      if (i.length > 0)
        return n.errors = i, n;
      this.config.exportReferenceFrame && (this.checkAborted(), await this.renderReferenceFrame(n)), this.config.exportLastFrame && (this.checkAborted(), await this.renderLastFrame(n)), this.config.exportDepthMap && (this.checkAborted(), await this.renderDepthSequence(n)), this.config.exportControlImages && (this.checkAborted(), await this.renderControlSequence(n)), this.config.exportCameraData && (this.checkAborted(), await this.exportCameraData(n)), this.checkAborted(), await this.generateWorkflow(n), this.config.autoQueueWorkflow && this.config.comfyuiServer && (this.checkAborted(), await this.queueWorkflow(n)), n.success = n.errors.length === 0;
    } catch (i) {
      i instanceof Error && i.message === "Export aborted" ? n.errors.push("Export was cancelled") : n.errors.push(i instanceof Error ? i.message : "Unknown error");
    }
    return n.duration = Date.now() - e, n;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const e = [];
    return (this.config.width < 64 || this.config.width > 4096) && e.push("Width must be between 64 and 4096"), (this.config.height < 64 || this.config.height > 4096) && e.push("Height must be between 64 and 4096"), (this.config.frameCount < 1 || this.config.frameCount > 1e3) && e.push("Frame count must be between 1 and 1000"), (this.config.fps < 1 || this.config.fps > 120) && e.push("FPS must be between 1 and 120"), (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) && e.push("Invalid start frame"), (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) && e.push("Invalid end frame"), !this.config.prompt && this.needsPrompt() && e.push("Prompt is required for this export target"), e;
  }
  needsPrompt() {
    return !["controlnet-depth", "controlnet-canny", "controlnet-lineart"].includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.startFrame);
    const s = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const l = await Ua(this.config.comfyuiServer).uploadImage(s, o);
      e.outputFiles.referenceImage = l.name;
    } else
      e.outputFiles.referenceImage = await this.saveBlobLocally(s, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.endFrame - 1);
    const s = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const l = await Ua(this.config.comfyuiServer).uploadImage(s, o);
      e.outputFiles.lastImage = l.name;
    } else
      e.outputFiles.lastImage = await this.saveBlobLocally(s, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(e, n) {
    e.clearRect(0, 0, e.canvas.width, e.canvas.height);
    const i = [...this.layers].filter((s) => s.visible).sort((s, o) => {
      var c, u, h, d, p, f;
      const a = ((h = (u = (c = s.transform) == null ? void 0 : c.position) == null ? void 0 : u.value) == null ? void 0 : h.z) ?? 0, l = ((f = (p = (d = o.transform) == null ? void 0 : d.position) == null ? void 0 : p.value) == null ? void 0 : f.z) ?? 0;
      return a - l;
    });
    for (const s of i)
      await this.renderLayerToCanvas(e, s, n);
  }
  async renderLayerToCanvas(e, n, i) {
    var u, h, d, p, f, m, _;
    const s = ((h = (u = n.transform) == null ? void 0 : u.position) == null ? void 0 : h.value) ?? { x: 0, y: 0 }, o = ((p = (d = n.transform) == null ? void 0 : d.scale) == null ? void 0 : p.value) ?? { x: 100, y: 100 }, a = ((m = (f = n.transform) == null ? void 0 : f.rotation) == null ? void 0 : m.value) ?? 0, l = typeof ((_ = n.opacity) == null ? void 0 : _.value) == "number" ? n.opacity.value : 100;
    e.save(), e.globalAlpha = l / 100, e.translate(s.x, s.y), e.rotate(a * Math.PI / 180), e.scale(o.x / 100, o.y / 100);
    const c = n.data;
    if (n.type === "image" && (c != null && c.src)) {
      const g = await this.loadImage(c.src);
      e.drawImage(g, -g.width / 2, -g.height / 2);
    } else if (n.type === "solid" && (c != null && c.color)) {
      e.fillStyle = c.color || "#000000";
      const g = c.width ?? 100, v = c.height ?? 100;
      e.fillRect(-g / 2, -v / 2, g, v);
    }
    e.restore();
  }
  loadImage(e) {
    return new Promise((n, i) => {
      const s = new Image();
      s.onload = () => n(s), s.onerror = i, s.src = e;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let s = 0; s < n; s++) {
      this.checkAborted();
      const o = this.config.startFrame + s, a = s / n * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: a,
        overallProgress: 15 + a * 0.25,
        currentFrame: s + 1,
        totalFrames: n,
        message: `Rendering depth frame ${s + 1}/${n}`
      });
      const l = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: !1,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      }, c = GX({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: l,
        layers: this.layers,
        frame: o
      }), u = YX(
        c,
        this.config.depthFormat
      ), h = qX(
        u,
        this.config.width,
        this.config.height
      ), d = new OffscreenCanvas(this.config.width, this.config.height);
      d.getContext("2d").putImageData(h, 0, 0);
      const f = await d.convertToBlob({ type: "image/png" }), m = `${this.config.filenamePrefix}_depth_${String(s).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const g = await Ua(this.config.comfyuiServer).uploadImage(f, m, "input", "depth_sequence");
        i.push(g.name);
      } else
        i.push(await this.saveBlobLocally(f, m));
    }
    e.outputFiles.depthSequence = i, this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let s = 0; s < n; s++) {
      this.checkAborted();
      const o = this.config.startFrame + s, a = s / n * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: a,
        overallProgress: 40 + a * 0.2,
        currentFrame: s + 1,
        totalFrames: n,
        message: `Rendering control frame ${s + 1}/${n}`
      });
      const l = new OffscreenCanvas(this.config.width, this.config.height), c = l.getContext("2d");
      await this.renderFrameToCanvas(c, o);
      const h = await (await this.applyControlPreprocessing(l, this.config.controlType || "depth")).convertToBlob({ type: "image/png" }), d = `${this.config.filenamePrefix}_control_${String(s).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const f = await Ua(this.config.comfyuiServer).uploadImage(h, d, "input", "control_sequence");
        i.push(f.name);
      } else
        i.push(await this.saveBlobLocally(h, d));
    }
    e.outputFiles.controlSequence = i, this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(e, n) {
    const i = new OffscreenCanvas(e.width, e.height), s = i.getContext("2d"), a = e.getContext("2d").getImageData(0, 0, e.width, e.height), l = a.data;
    switch (n) {
      case "canny":
        this.applyEdgeDetection(l, e.width, e.height);
        break;
      case "lineart":
        this.applyLineart(l);
        break;
      case "softedge":
        this.applySoftEdge(l, e.width, e.height);
        break;
    }
    return s.putImageData(a, 0, 0), i;
  }
  applyEdgeDetection(e, n, i) {
    const s = new Float32Array(n * i);
    for (let a = 0; a < n * i; a++) {
      const l = a * 4;
      s[a] = (e[l] * 0.299 + e[l + 1] * 0.587 + e[l + 2] * 0.114) / 255;
    }
    const o = new Float32Array(n * i);
    for (let a = 1; a < i - 1; a++)
      for (let l = 1; l < n - 1; l++) {
        const c = a * n + l, u = -s[c - n - 1] + s[c - n + 1] + -2 * s[c - 1] + 2 * s[c + 1] + -s[c + n - 1] + s[c + n + 1], h = -s[c - n - 1] - 2 * s[c - n] - s[c - n + 1] + s[c + n - 1] + 2 * s[c + n] + s[c + n + 1];
        o[c] = Math.min(1, Math.sqrt(u * u + h * h) * 2);
      }
    for (let a = 0; a < n * i; a++) {
      const l = a * 4, c = Math.floor(o[a] * 255);
      e[l] = c, e[l + 1] = c, e[l + 2] = c;
    }
  }
  applyLineart(e) {
    for (let n = 0; n < e.length; n += 4) {
      const s = e[n] * 0.299 + e[n + 1] * 0.587 + e[n + 2] * 0.114 > 128 ? 255 : 0;
      e[n] = s, e[n + 1] = s, e[n + 2] = s;
    }
  }
  applySoftEdge(e, n, i) {
    this.applyEdgeDetection(e, n, i);
    const s = new Uint8ClampedArray(e), o = 2;
    for (let a = o; a < i - o; a++)
      for (let l = o; l < n - o; l++) {
        let c = 0, u = 0;
        for (let p = -o; p <= o; p++)
          for (let f = -o; f <= o; f++) {
            const m = ((a + p) * n + (l + f)) * 4;
            c += s[m], u++;
          }
        const h = (a * n + l) * 4, d = Math.floor(c / u);
        e[h] = d, e[h + 1] = d, e[h + 2] = d;
      }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(e) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const n = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: !1,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: !1
      }
    }, i = Dk(
      this.config.target,
      n,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    ), s = `${this.config.filenamePrefix}_camera.json`, o = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    this.config.comfyuiServer ? e.outputFiles.cameraData = s : e.outputFiles.cameraData = await this.saveBlobLocally(o, s), this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(e) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const n = {
      referenceImage: e.outputFiles.referenceImage,
      lastFrameImage: e.outputFiles.lastImage,
      depthSequence: e.outputFiles.depthSequence,
      controlImages: e.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    e.outputFiles.cameraData && (n.cameraData = e.outputFiles.cameraData);
    const i = rY(this.config.target, n), s = oY(i);
    s.valid || e.errors.push(...s.errors), e.warnings.push(...s.warnings);
    const o = `${this.config.filenamePrefix}_workflow.json`, a = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    e.outputFiles.workflowJson = await this.saveBlobLocally(a, o), this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(e) {
    if (!this.config.comfyuiServer || !e.outputFiles.workflowJson)
      return;
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const n = Ua(this.config.comfyuiServer);
    if (!await n.checkConnection()) {
      e.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const o = await (await fetch(e.outputFiles.workflowJson)).json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const a = await n.queuePrompt(o);
    if (e.outputFiles.promptId = a.prompt_id, a.node_errors && Object.keys(a.node_errors).length > 0) {
      e.errors.push("Workflow has node errors: " + JSON.stringify(a.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await n.waitForPrompt(a.prompt_id, (l) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: l.percentage,
          overallProgress: 80 + l.percentage * 0.15,
          message: `Generating: ${l.percentage.toFixed(0)}%`,
          preview: l.preview
        });
      }), this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (l) {
      e.errors.push(l instanceof Error ? l.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(e, n) {
    const i = URL.createObjectURL(e), s = document.createElement("a");
    return s.href = i, s.download = n, document.body.appendChild(s), s.click(), document.body.removeChild(s), i;
  }
}
async function lY(r, e, n, i) {
  return new aY({
    layers: r,
    cameraKeyframes: e,
    config: n,
    onProgress: i
  }).execute();
}
const cY = { class: "export-dialog" }, uY = { class: "dialog-tabs" }, hY = { class: "dialog-content" }, dY = {
  key: 0,
  class: "tab-content"
}, fY = { class: "target-grid" }, pY = { class: "target-buttons" }, mY = ["onClick"], gY = {
  key: 0,
  class: "target-info"
}, vY = { class: "info-row" }, yY = { class: "info-row" }, _Y = { class: "info-row" }, xY = {
  key: 1,
  class: "tab-content"
}, bY = { class: "settings-section" }, wY = { class: "preset-buttons" }, SY = ["onClick"], MY = { class: "input-row" }, CY = { class: "settings-section" }, TY = { class: "preset-buttons" }, EY = ["onClick"], AY = { class: "input-row" }, PY = { class: "input-row" }, DY = { class: "settings-section" }, kY = { class: "checkbox-grid" }, RY = {
  key: 0,
  class: "settings-section"
}, LY = ["value"], IY = {
  key: 1,
  class: "settings-section"
}, OY = ["value"], FY = {
  key: 2,
  class: "tab-content"
}, UY = { class: "settings-section" }, zY = { class: "settings-section" }, BY = { class: "settings-section" }, NY = { class: "input-row" }, VY = { class: "input-row seed-row" }, GY = {
  key: 3,
  class: "tab-content"
}, HY = { class: "settings-section" }, WY = { class: "server-row" }, jY = { key: 0 }, $Y = { key: 1 }, XY = { key: 2 }, YY = { key: 3 }, qY = { class: "settings-section" }, ZY = { class: "checkbox-large" }, KY = {
  key: 0,
  class: "export-progress"
}, JY = { class: "progress-header" }, QY = { class: "progress-bar" }, eq = {
  key: 0,
  class: "progress-details"
}, tq = {
  key: 1,
  class: "export-error"
}, nq = { class: "dialog-footer" }, iq = ["disabled"], sq = /* @__PURE__ */ jt({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(r, { emit: e }) {
    const n = r, i = e, s = Ce("target"), o = Ce("wan22-i2v"), a = Ce(832), l = Ce(480), c = Ce(81), u = Ce(24), h = Ce(0), d = Ce(81), p = Ce(!0), f = Ce(!1), m = Ce(!0), _ = Ce(!0), g = Ce(!1), v = Ce("midas"), S = Ce("depth"), b = Ce(""), x = Ce("blurry, low quality, distorted"), M = Ce(void 0), C = Ce(30), E = Ce(5), T = Ce("127.0.0.1:8188"), w = Ce(!1), A = Ce("disconnected"), O = Ce(!1), U = Ce(null), D = Ce(null), L = Ce(null), P = Xe(() => R_[o.value]), V = Xe(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      Uni3C: ["uni3c-camera", "uni3c-motion"],
      MotionCtrl: ["motionctrl", "motionctrl-svd"],
      Camera: ["animatediff-cameractrl", "camera-comfyui", "ati"],
      Advanced: ["light-x", "ttm", "cogvideox"],
      ControlNet: ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      Custom: ["custom-workflow"]
    })), ce = Xe(() => ({
      "wan22-i2v": "Image to Video",
      "wan22-t2v": "Text to Video",
      "wan22-fun-camera": "Fun Camera",
      "wan22-first-last": "First + Last Frame",
      "wan-move": "Point Trajectories",
      "uni3c-camera": "Camera Control",
      "uni3c-motion": "Motion + Camera",
      motionctrl: "MotionCtrl",
      "motionctrl-svd": "MotionCtrl SVD",
      cogvideox: "CogVideoX I2V",
      "animatediff-cameractrl": "CameraCtrl",
      "camera-comfyui": "4x4 Matrices",
      ati: "Any Trajectory",
      "light-x": "Relighting",
      ttm: "Cut & Drag",
      "controlnet-depth": "Depth",
      "controlnet-canny": "Canny Edge",
      "controlnet-lineart": "Line Art",
      "custom-workflow": "Custom Workflow"
    })), q = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ], oe = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function ne(K) {
      o.value = K;
      const G = zX[K];
      G && (a.value = G.width ?? 832, l.value = G.height ?? 480, c.value = G.frameCount ?? 81, u.value = G.fps ?? 24, d.value = c.value);
      const R = R_[K];
      R && (p.value = R.requiredInputs.includes("depth_sequence") || R.requiredInputs.includes("depth_map"), m.value = R.requiredInputs.includes("camera_data") || R.requiredInputs.includes("camera_trajectory") || R.requiredInputs.includes("camera_poses"), _.value = R.requiredInputs.includes("reference_image") || R.requiredInputs.includes("first_frame"), g.value = R.requiredInputs.includes("last_frame"), f.value = K.startsWith("controlnet-"));
    }
    async function $() {
      A.value = "connecting";
      try {
        const G = await Ua(T.value).checkConnection();
        A.value = G ? "connected" : "error";
      } catch {
        A.value = "error";
      }
    }
    function J(K) {
      a.value = K.width, l.value = K.height;
    }
    function se(K) {
      c.value = K, d.value = Math.min(d.value, K);
    }
    function le() {
      M.value = Math.floor(Math.random() * 2147483647);
    }
    async function re() {
      O.value = !0, D.value = null, L.value = new AbortController();
      const K = {
        target: o.value,
        width: a.value,
        height: l.value,
        frameCount: c.value,
        fps: u.value,
        startFrame: h.value,
        endFrame: d.value,
        outputDir: "",
        filenamePrefix: `weyl_${o.value}_${Date.now()}`,
        exportDepthMap: p.value,
        exportControlImages: f.value,
        exportCameraData: m.value,
        exportReferenceFrame: _.value,
        exportLastFrame: g.value,
        depthFormat: v.value,
        controlType: S.value,
        prompt: b.value,
        negativePrompt: x.value,
        seed: M.value,
        steps: C.value,
        cfgScale: E.value,
        comfyuiServer: T.value,
        autoQueueWorkflow: w.value
      };
      try {
        const G = await lY(
          n.layers,
          n.cameraKeyframes,
          K,
          (R) => {
            U.value = R;
          }
        );
        G.success ? i("exported", G) : D.value = G.errors.join(`
`);
      } catch (G) {
        D.value = G instanceof Error ? G.message : "Export failed";
      } finally {
        O.value = !1, L.value = null;
      }
    }
    function ye() {
      L.value && L.value.abort();
    }
    function H() {
      O.value && ye(), i("close");
    }
    return Xn(() => {
      d.value = Math.min(c.value, n.totalFrames), $();
    }), At(o, () => {
      ne(o.value);
    }), (K, G) => {
      var R, z, I;
      return ie(), ue("div", {
        class: "export-dialog-overlay",
        onClick: Rt(H, ["self"])
      }, [
        y("div", cY, [
          y("header", { class: "dialog-header" }, [
            G[24] || (G[24] = y("h2", null, "Export to ComfyUI", -1)),
            y("button", {
              class: "close-btn",
              onClick: H
            }, "")
          ]),
          y("nav", uY, [
            y("button", {
              class: Ye({ active: s.value === "target" }),
              onClick: G[0] || (G[0] = (Q) => s.value = "target")
            }, " Target ", 2),
            y("button", {
              class: Ye({ active: s.value === "output" }),
              onClick: G[1] || (G[1] = (Q) => s.value = "output")
            }, " Output ", 2),
            y("button", {
              class: Ye({ active: s.value === "generation" }),
              onClick: G[2] || (G[2] = (Q) => s.value = "generation")
            }, " Generation ", 2),
            y("button", {
              class: Ye({ active: s.value === "comfyui" }),
              onClick: G[3] || (G[3] = (Q) => s.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          y("div", hY, [
            s.value === "target" ? (ie(), ue("div", dY, [
              y("div", fY, [
                (ie(!0), ue(nt, null, pt(V.value, (Q, X) => (ie(), ue("div", {
                  key: X,
                  class: "target-category"
                }, [
                  y("h3", null, Ae(X), 1),
                  y("div", pY, [
                    (ie(!0), ue(nt, null, pt(Q, (k) => (ie(), ue("button", {
                      key: k,
                      class: Ye({ selected: o.value === k }),
                      onClick: (ee) => ne(k)
                    }, Ae(ce.value[k]), 11, mY))), 128))
                  ])
                ]))), 128))
              ]),
              P.value ? (ie(), ue("div", gY, [
                y("h4", null, Ae(ce.value[o.value]), 1),
                y("div", vY, [
                  G[25] || (G[25] = y("span", { class: "label" }, "Required:", -1)),
                  y("span", null, Ae(P.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                y("div", yY, [
                  G[26] || (G[26] = y("span", { class: "label" }, "Optional:", -1)),
                  y("span", null, Ae(P.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                y("div", _Y, [
                  G[27] || (G[27] = y("span", { class: "label" }, "Outputs:", -1)),
                  y("span", null, Ae(P.value.outputTypes.join(", ")), 1)
                ])
              ])) : Ne("", !0)
            ])) : Ne("", !0),
            s.value === "output" ? (ie(), ue("div", xY, [
              y("div", bY, [
                G[28] || (G[28] = y("h3", null, "Resolution", -1)),
                y("div", wY, [
                  (ie(!0), ue(nt, null, pt(Je(NX), (Q) => (ie(), ue("button", {
                    key: Q.name,
                    onClick: (X) => J(Q)
                  }, Ae(Q.name), 9, SY))), 128))
                ]),
                y("div", MY, [
                  Ze(rt, {
                    modelValue: a.value,
                    "onUpdate:modelValue": G[4] || (G[4] = (Q) => a.value = Q),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  Ze(rt, {
                    modelValue: l.value,
                    "onUpdate:modelValue": G[5] || (G[5] = (Q) => l.value = Q),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              y("div", CY, [
                G[29] || (G[29] = y("h3", null, "Frames", -1)),
                y("div", TY, [
                  (ie(!0), ue(nt, null, pt(Je(VX), (Q) => (ie(), ue("button", {
                    key: Q.name,
                    onClick: (X) => se(Q.frameCount)
                  }, Ae(Q.name), 9, EY))), 128))
                ]),
                y("div", AY, [
                  Ze(rt, {
                    modelValue: c.value,
                    "onUpdate:modelValue": G[6] || (G[6] = (Q) => c.value = Q),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  Ze(rt, {
                    modelValue: u.value,
                    "onUpdate:modelValue": G[7] || (G[7] = (Q) => u.value = Q),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                y("div", PY, [
                  Ze(rt, {
                    modelValue: h.value,
                    "onUpdate:modelValue": G[8] || (G[8] = (Q) => h.value = Q),
                    label: "Start",
                    min: 0,
                    max: d.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  Ze(rt, {
                    modelValue: d.value,
                    "onUpdate:modelValue": G[9] || (G[9] = (Q) => d.value = Q),
                    label: "End",
                    min: h.value + 1,
                    max: c.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              y("div", DY, [
                G[35] || (G[35] = y("h3", null, "Export Options", -1)),
                y("div", kY, [
                  y("label", null, [
                    wt(y("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": G[10] || (G[10] = (Q) => _.value = Q)
                    }, null, 512), [
                      [Us, _.value]
                    ]),
                    G[30] || (G[30] = xt(" Reference Frame ", -1))
                  ]),
                  y("label", null, [
                    wt(y("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": G[11] || (G[11] = (Q) => g.value = Q)
                    }, null, 512), [
                      [Us, g.value]
                    ]),
                    G[31] || (G[31] = xt(" Last Frame ", -1))
                  ]),
                  y("label", null, [
                    wt(y("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": G[12] || (G[12] = (Q) => p.value = Q)
                    }, null, 512), [
                      [Us, p.value]
                    ]),
                    G[32] || (G[32] = xt(" Depth Maps ", -1))
                  ]),
                  y("label", null, [
                    wt(y("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": G[13] || (G[13] = (Q) => f.value = Q)
                    }, null, 512), [
                      [Us, f.value]
                    ]),
                    G[33] || (G[33] = xt(" Control Images ", -1))
                  ]),
                  y("label", null, [
                    wt(y("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": G[14] || (G[14] = (Q) => m.value = Q)
                    }, null, 512), [
                      [Us, m.value]
                    ]),
                    G[34] || (G[34] = xt(" Camera Data ", -1))
                  ])
                ])
              ]),
              p.value ? (ie(), ue("div", RY, [
                G[36] || (G[36] = y("h3", null, "Depth Format", -1)),
                wt(y("select", {
                  "onUpdate:modelValue": G[15] || (G[15] = (Q) => v.value = Q)
                }, [
                  (ie(), ue(nt, null, pt(q, (Q) => y("option", {
                    key: Q.value,
                    value: Q.value
                  }, Ae(Q.label), 9, LY)), 64))
                ], 512), [
                  [ns, v.value]
                ])
              ])) : Ne("", !0),
              f.value ? (ie(), ue("div", IY, [
                G[37] || (G[37] = y("h3", null, "Control Type", -1)),
                wt(y("select", {
                  "onUpdate:modelValue": G[16] || (G[16] = (Q) => S.value = Q)
                }, [
                  (ie(), ue(nt, null, pt(oe, (Q) => y("option", {
                    key: Q.value,
                    value: Q.value
                  }, Ae(Q.label), 9, OY)), 64))
                ], 512), [
                  [ns, S.value]
                ])
              ])) : Ne("", !0)
            ])) : Ne("", !0),
            s.value === "generation" ? (ie(), ue("div", FY, [
              y("div", UY, [
                G[38] || (G[38] = y("h3", null, "Prompt", -1)),
                wt(y("textarea", {
                  "onUpdate:modelValue": G[17] || (G[17] = (Q) => b.value = Q),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [Tn, b.value]
                ])
              ]),
              y("div", zY, [
                G[39] || (G[39] = y("h3", null, "Negative Prompt", -1)),
                wt(y("textarea", {
                  "onUpdate:modelValue": G[18] || (G[18] = (Q) => x.value = Q),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [Tn, x.value]
                ])
              ]),
              y("div", BY, [
                G[40] || (G[40] = y("h3", null, "Parameters", -1)),
                y("div", NY, [
                  Ze(rt, {
                    modelValue: C.value,
                    "onUpdate:modelValue": G[19] || (G[19] = (Q) => C.value = Q),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  Ze(rt, {
                    modelValue: E.value,
                    "onUpdate:modelValue": G[20] || (G[20] = (Q) => E.value = Q),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                y("div", VY, [
                  Ze(rt, {
                    modelValue: M.value ?? 0,
                    "onUpdate:modelValue": G[21] || (G[21] = (Q) => M.value = Q),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  y("button", {
                    class: "randomize-btn",
                    onClick: le
                  }, "Random")
                ])
              ])
            ])) : Ne("", !0),
            s.value === "comfyui" ? (ie(), ue("div", GY, [
              y("div", HY, [
                G[41] || (G[41] = y("h3", null, "Server", -1)),
                y("div", WY, [
                  wt(y("input", {
                    type: "text",
                    "onUpdate:modelValue": G[22] || (G[22] = (Q) => T.value = Q),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [Tn, T.value]
                  ]),
                  y("button", { onClick: $ }, Ae(A.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                y("div", {
                  class: Ye(["connection-status", A.value])
                }, [
                  A.value === "connected" ? (ie(), ue("span", jY, "Connected")) : A.value === "error" ? (ie(), ue("span", $Y, "Connection failed")) : A.value === "connecting" ? (ie(), ue("span", XY, "Connecting...")) : (ie(), ue("span", YY, "Not connected"))
                ], 2)
              ]),
              y("div", qY, [
                G[43] || (G[43] = y("h3", null, "Workflow", -1)),
                y("label", ZY, [
                  wt(y("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": G[23] || (G[23] = (Q) => w.value = Q)
                  }, null, 512), [
                    [Us, w.value]
                  ]),
                  G[42] || (G[42] = y("span", null, [
                    y("strong", null, "Auto-queue workflow"),
                    y("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : Ne("", !0)
          ]),
          O.value ? (ie(), ue("div", KY, [
            y("div", JY, [
              y("span", null, Ae(((R = U.value) == null ? void 0 : R.message) || "Exporting..."), 1),
              y("button", { onClick: ye }, "Cancel")
            ]),
            y("div", QY, [
              y("div", {
                class: "progress-fill",
                style: Ct({ width: `${((z = U.value) == null ? void 0 : z.overallProgress) || 0}%` })
              }, null, 4)
            ]),
            (I = U.value) != null && I.currentFrame ? (ie(), ue("div", eq, " Frame " + Ae(U.value.currentFrame) + " / " + Ae(U.value.totalFrames), 1)) : Ne("", !0)
          ])) : Ne("", !0),
          D.value ? (ie(), ue("div", tq, Ae(D.value), 1)) : Ne("", !0),
          y("footer", nq, [
            y("button", {
              class: "secondary",
              onClick: H
            }, "Cancel"),
            y("button", {
              class: "primary",
              disabled: O.value,
              onClick: re
            }, Ae(O.value ? "Exporting..." : "Export"), 9, iq)
          ])
        ])
      ]);
    };
  }
}), rq = /* @__PURE__ */ Yt(sq, [["__scopeId", "data-v-784836ff"]]), oq = { class: "workspace-layout" }, aq = { class: "toolbar" }, lq = { class: "tool-group" }, cq = { class: "tool-group" }, uq = ["title"], hq = { class: "icon" }, dq = { class: "timecode-display" }, fq = { class: "tool-group" }, pq = { class: "tool-group" }, mq = ["disabled"], gq = ["disabled"], vq = { class: "workspace-content" }, yq = { class: "panel left-panel" }, _q = { class: "panel-tabs" }, xq = { class: "panel-content" }, bq = { class: "panel viewport-panel" }, wq = { class: "viewport-header" }, Sq = { class: "viewport-tabs" }, Mq = { class: "viewport-controls" }, Cq = ["title"], Tq = { class: "icon" }, Eq = { class: "viewport-content" }, Aq = { class: "panel timeline-panel" }, Pq = { class: "panel graph-editor-panel" }, Dq = {
  key: 1,
  class: "panel timeline-panel"
}, kq = { class: "panel right-panel" }, Rq = { class: "panel-tabs" }, Lq = { class: "panel-content" }, Iq = { class: "status-bar" }, Oq = { class: "status-left" }, Fq = { class: "status-item" }, Uq = { class: "status-item" }, zq = { class: "status-center" }, Bq = {
  key: 0,
  class: "render-progress"
}, Nq = { class: "status-right" }, Vq = { class: "status-item" }, Gq = { class: "status-item" }, Hq = /* @__PURE__ */ jt({
  __name: "WorkspaceLayout",
  setup(r) {
    const e = _n(), n = Xe({
      get: () => e.currentTool,
      set: (R) => e.setTool(R)
    }), i = Ce("standard"), s = Ce("project"), o = Ce("properties"), a = Ce("composition"), l = Ce("fit"), c = Ce(!1), u = Ce(!0), h = Ce(!1), d = Ce(!1), p = Ce(!1), f = Ce(!0), m = Ce(!1), _ = Ce("cpu"), g = Ce(null), v = Ce(null), S = Xe(() => {
      const R = e.getActiveCameraAtFrame();
      return R || Yb("default", M.value, C.value);
    }), b = Ce(qb()), x = Ce({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), M = Xe(() => {
      var R, z;
      return ((z = (R = e.project) == null ? void 0 : R.composition) == null ? void 0 : z.width) || 1920;
    }), C = Xe(() => {
      var R, z;
      return ((z = (R = e.project) == null ? void 0 : R.composition) == null ? void 0 : z.height) || 1080;
    }), E = Ce(60), T = Ce("0 MB"), w = Ce(0), A = Xe(() => {
      var ee, Z;
      const R = e.currentFrame, z = ((Z = (ee = e.project) == null ? void 0 : ee.composition) == null ? void 0 : Z.fps) || 30, I = R / z, Q = Math.floor(I / 60), X = Math.floor(I % 60), k = R % z;
      return `${String(Q).padStart(2, "0")}:${String(X).padStart(2, "0")}:${String(k).padStart(2, "0")}`;
    }), O = Xe(() => {
      var R, z;
      return ((z = (R = e.project) == null ? void 0 : R.meta) == null ? void 0 : z.name) || "Untitled Project";
    }), U = Xe(() => {
      var z;
      const R = (z = e.project) == null ? void 0 : z.composition;
      return R ? `${R.width}${R.height} @ ${R.fps}fps` : "No Composition";
    }), D = Xe(() => e.canUndo), L = Xe(() => e.canRedo);
    function P() {
      m.value = !m.value, m.value ? e.play() : e.pause();
    }
    function V() {
      e.goToStart();
    }
    function ce() {
      e.goToEnd();
    }
    function q() {
      e.setFrame(e.currentFrame + 1);
    }
    function oe() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function ne() {
      e.undo();
    }
    function $() {
      e.redo();
    }
    function J(R) {
      e.activeCameraId && e.updateCamera(R.id, R);
    }
    function se() {
      console.log("[Weyl] Matte export completed");
    }
    function le(R) {
      console.log("[Weyl] ComfyUI export completed", R), p.value = !1;
    }
    const re = Xe(() => {
      const R = e.getActiveCameraAtFrame();
      return R ? e.getCameraKeyframes(R.id) : [];
    });
    At(u, (R) => {
      g.value && (g.value.showGrid = R);
    }), At(c, (R) => {
      g.value && (g.value.showGuides = R);
    });
    function ye() {
      const R = g.value;
      if (R)
        if (l.value === "fit")
          R.fitToView();
        else {
          const z = parseInt(l.value) / 100;
          R.fabricCanvas && (R.fabricCanvas.setZoom(z), R.zoom = z, R.fabricCanvas.requestRenderAll());
        }
    }
    function H(R) {
      var z, I;
      if (!(((z = document.activeElement) == null ? void 0 : z.tagName) === "INPUT" || ((I = document.activeElement) == null ? void 0 : I.tagName) === "TEXTAREA"))
        switch (R.key.toLowerCase()) {
          case " ":
            R.preventDefault(), P();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            R.ctrlKey || R.metaKey ? (R.preventDefault(), R.shiftKey ? $() : ne()) : n.value = "zoom";
            break;
          case "home":
            R.preventDefault(), V();
            break;
          case "end":
            R.preventDefault(), ce();
            break;
          case "arrowleft":
            R.preventDefault(), oe();
            break;
          case "arrowright":
            R.preventDefault(), q();
            break;
          case "g":
            R.shiftKey && (h.value = !h.value);
            break;
        }
    }
    let K;
    function G() {
      if ("memory" in performance) {
        const R = performance.memory, z = Math.round(R.usedJSHeapSize / 1024 / 1024);
        T.value = `${z} MB`;
      }
    }
    return Xn(async () => {
      const R = await eR();
      _.value = R.tier, window.addEventListener("keydown", H), K = window.setInterval(G, 1e3);
    }), Ni(() => {
      window.removeEventListener("keydown", H), clearInterval(K);
    }), (R, z) => (ie(), ue("div", oq, [
      y("div", aq, [
        y("div", lq, [
          y("button", {
            class: Ye({ active: n.value === "select" }),
            onClick: z[0] || (z[0] = (I) => n.value = "select"),
            title: "Select (V)"
          }, [...z[24] || (z[24] = [
            y("span", { class: "icon" }, "", -1)
          ])], 2),
          y("button", {
            class: Ye({ active: n.value === "pen" }),
            onClick: z[1] || (z[1] = (I) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...z[25] || (z[25] = [
            y("span", { class: "icon" }, "", -1)
          ])], 2),
          y("button", {
            class: Ye({ active: n.value === "text" }),
            onClick: z[2] || (z[2] = (I) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...z[26] || (z[26] = [
            y("span", { class: "icon" }, "T", -1)
          ])], 2),
          y("button", {
            class: Ye({ active: n.value === "hand" }),
            onClick: z[3] || (z[3] = (I) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...z[27] || (z[27] = [
            y("span", { class: "icon" }, "", -1)
          ])], 2),
          y("button", {
            class: Ye({ active: n.value === "zoom" }),
            onClick: z[4] || (z[4] = (I) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...z[28] || (z[28] = [
            y("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        z[38] || (z[38] = y("div", { class: "divider" }, null, -1)),
        y("div", cq, [
          y("button", {
            onClick: V,
            title: "Go to Start (Home)"
          }, [...z[29] || (z[29] = [
            y("span", { class: "icon" }, "", -1)
          ])]),
          y("button", {
            onClick: oe,
            title: "Step Backward"
          }, [...z[30] || (z[30] = [
            y("span", { class: "icon" }, "", -1)
          ])]),
          y("button", {
            onClick: P,
            title: m.value ? "Pause (Space)" : "Play (Space)"
          }, [
            y("span", hq, Ae(m.value ? "" : ""), 1)
          ], 8, uq),
          y("button", {
            onClick: q,
            title: "Step Forward"
          }, [...z[31] || (z[31] = [
            y("span", { class: "icon" }, "", -1)
          ])]),
          y("button", {
            onClick: ce,
            title: "Go to End (End)"
          }, [...z[32] || (z[32] = [
            y("span", { class: "icon" }, "", -1)
          ])])
        ]),
        y("div", dq, Ae(A.value), 1),
        z[39] || (z[39] = y("div", { class: "divider" }, null, -1)),
        y("div", fq, [
          wt(y("select", {
            "onUpdate:modelValue": z[5] || (z[5] = (I) => i.value = I),
            class: "workspace-selector"
          }, [...z[33] || (z[33] = [
            y("option", { value: "standard" }, "Standard", -1),
            y("option", { value: "animation" }, "Animation", -1),
            y("option", { value: "effects" }, "Effects", -1),
            y("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [ns, i.value]
          ])
        ]),
        z[40] || (z[40] = y("div", { class: "spacer" }, null, -1)),
        y("div", pq, [
          y("span", {
            class: Ye(["gpu-badge", _.value])
          }, Ae(_.value.toUpperCase()), 3),
          y("button", {
            onClick: ne,
            disabled: !D.value,
            title: "Undo (Ctrl+Z)"
          }, [...z[34] || (z[34] = [
            y("span", { class: "icon" }, "", -1)
          ])], 8, mq),
          y("button", {
            onClick: $,
            disabled: !L.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...z[35] || (z[35] = [
            y("span", { class: "icon" }, "", -1)
          ])], 8, gq),
          y("button", {
            onClick: z[6] || (z[6] = (I) => d.value = !0),
            title: "Export Matte"
          }, [...z[36] || (z[36] = [
            y("span", { class: "icon" }, "", -1),
            xt(" Matte ", -1)
          ])]),
          y("button", {
            onClick: z[7] || (z[7] = (I) => p.value = !0),
            title: "Export to ComfyUI"
          }, [...z[37] || (z[37] = [
            y("span", { class: "icon" }, "", -1),
            xt(" ComfyUI ", -1)
          ])])
        ])
      ]),
      y("div", vq, [
        Ze(Je(jf), { class: "default-theme horizontal-split" }, {
          default: fs(() => [
            Ze(Je(xo), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: fs(() => [
                y("div", yq, [
                  y("div", _q, [
                    y("button", {
                      class: Ye({ active: s.value === "project" }),
                      onClick: z[8] || (z[8] = (I) => s.value = "project")
                    }, " Project ", 2),
                    y("button", {
                      class: Ye({ active: s.value === "effects" }),
                      onClick: z[9] || (z[9] = (I) => s.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  y("div", xq, [
                    s.value === "project" ? (ie(), Et(TR, { key: 0 })) : s.value === "effects" ? (ie(), Et(rL, { key: 1 })) : Ne("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Ze(Je(xo), {
              size: 70,
              "min-size": 40
            }, {
              default: fs(() => [
                Ze(Je(jf), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: fs(() => [
                    Ze(Je(xo), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: fs(() => [
                        y("div", bq, [
                          y("div", wq, [
                            y("div", Sq, [
                              y("button", {
                                class: Ye({ active: a.value === "composition" }),
                                onClick: z[10] || (z[10] = (I) => a.value = "composition")
                              }, " Composition ", 2),
                              y("button", {
                                class: Ye({ active: a.value === "layer" }),
                                onClick: z[11] || (z[11] = (I) => a.value = "layer")
                              }, " Layer ", 2),
                              y("button", {
                                class: Ye({ active: a.value === "footage" }),
                                onClick: z[12] || (z[12] = (I) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            y("div", Mq, [
                              wt(y("select", {
                                "onUpdate:modelValue": z[13] || (z[13] = (I) => l.value = I),
                                onChange: ye,
                                class: "zoom-select"
                              }, [...z[41] || (z[41] = [
                                y("option", { value: "fit" }, "Fit", -1),
                                y("option", { value: "25" }, "25%", -1),
                                y("option", { value: "50" }, "50%", -1),
                                y("option", { value: "75" }, "75%", -1),
                                y("option", { value: "100" }, "100%", -1),
                                y("option", { value: "150" }, "150%", -1),
                                y("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [ns, l.value]
                              ]),
                              y("button", {
                                class: Ye({ active: c.value }),
                                onClick: z[14] || (z[14] = (I) => c.value = !c.value),
                                title: "Toggle Guides"
                              }, [...z[42] || (z[42] = [
                                y("span", { class: "icon" }, "", -1)
                              ])], 2),
                              y("button", {
                                class: Ye({ active: u.value }),
                                onClick: z[15] || (z[15] = (I) => u.value = !u.value),
                                title: "Toggle Grid"
                              }, [...z[43] || (z[43] = [
                                y("span", { class: "icon" }, "", -1)
                              ])], 2),
                              y("button", {
                                class: Ye({ active: f.value }),
                                onClick: z[16] || (z[16] = (I) => f.value = !f.value),
                                title: f.value ? "Using Three.js (click for Fabric.js)" : "Using Fabric.js (click for Three.js)"
                              }, [
                                y("span", Tq, Ae(f.value ? "3D" : "2D"), 1)
                              ], 10, Cq)
                            ])
                          ]),
                          y("div", Eq, [
                            a.value === "composition" && f.value ? (ie(), Et(wj, {
                              key: 0,
                              ref_key: "threeCanvasRef",
                              ref: v
                            }, null, 512)) : a.value === "composition" ? (ie(), Et(k9, {
                              key: 1,
                              ref_key: "canvasRef",
                              ref: g
                            }, null, 512)) : (ie(), Et(_G, {
                              key: 2,
                              camera: S.value,
                              viewportState: b.value,
                              viewOptions: x.value,
                              compWidth: M.value,
                              compHeight: C.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Ze(Je(xo), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: fs(() => [
                        h.value ? (ie(), Et(Je(jf), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: fs(() => [
                            Ze(Je(xo), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: fs(() => [
                                y("div", Aq, [
                                  Ze(A_)
                                ])
                              ]),
                              _: 1
                            }),
                            Ze(Je(xo), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: fs(() => [
                                y("div", Pq, [
                                  Ze(tX, {
                                    onClose: z[17] || (z[17] = (I) => h.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (ie(), ue("div", Dq, [
                          Ze(A_)
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Ze(Je(xo), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: fs(() => [
                y("div", kq, [
                  y("div", Rq, [
                    y("button", {
                      class: Ye({ active: o.value === "effects" }),
                      onClick: z[18] || (z[18] = (I) => o.value = "effects")
                    }, " Effects ", 2),
                    y("button", {
                      class: Ye({ active: o.value === "properties" }),
                      onClick: z[19] || (z[19] = (I) => o.value = "properties")
                    }, " Props ", 2),
                    y("button", {
                      class: Ye({ active: o.value === "camera" }),
                      onClick: z[20] || (z[20] = (I) => o.value = "camera")
                    }, " Cam ", 2),
                    y("button", {
                      class: Ye({ active: o.value === "audio" }),
                      onClick: z[21] || (z[21] = (I) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  y("div", Lq, [
                    o.value === "effects" ? (ie(), Et(AI, { key: 0 })) : o.value === "properties" ? (ie(), Et(A6, { key: 1 })) : o.value === "camera" ? (ie(), Et(NV, {
                      key: 2,
                      camera: S.value,
                      "onUpdate:camera": J
                    }, null, 8, ["camera"])) : o.value === "audio" ? (ie(), Et(K8, { key: 3 })) : Ne("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      y("div", Iq, [
        y("div", Oq, [
          y("span", Fq, Ae(O.value), 1),
          z[44] || (z[44] = y("span", { class: "status-divider" }, "|", -1)),
          y("span", Uq, Ae(U.value), 1)
        ]),
        y("div", zq, [
          w.value > 0 ? (ie(), ue("span", Bq, " Rendering: " + Ae(Math.round(w.value * 100)) + "% ", 1)) : Ne("", !0)
        ]),
        y("div", Nq, [
          y("span", Vq, Ae(T.value), 1),
          z[45] || (z[45] = y("span", { class: "status-divider" }, "|", -1)),
          y("span", Gq, Ae(E.value) + " fps", 1)
        ])
      ]),
      d.value ? (ie(), Et(UX, {
        key: 0,
        onClose: z[22] || (z[22] = (I) => d.value = !1),
        onExported: se
      })) : Ne("", !0),
      p.value ? (ie(), Et(rq, {
        key: 1,
        layers: Je(e).layers,
        "camera-keyframes": re.value,
        "current-frame": Je(e).currentFrame,
        "total-frames": Je(e).frameCount,
        onClose: z[23] || (z[23] = (I) => p.value = !1),
        onExported: le
      }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : Ne("", !0)
    ]));
  }
}), Wq = /* @__PURE__ */ Yt(Hq, [["__scopeId", "data-v-871fdea4"]]), jq = /* @__PURE__ */ jt({
  __name: "App",
  setup(r) {
    return (e, n) => (ie(), Et(Wq));
  }
}), bS = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], wS = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function SS(r) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let i = 1; i < r; i++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function $q(r, e, n) {
  const i = r.data, s = r.width, o = r.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && Xq(i, s, o, e), n > 0 && Yq(i, s, o, n));
}
function Xq(r, e, n, i) {
  const s = i + i + 1, o = e - 1, a = bS[i], l = wS[i], c = SS(s);
  for (let u = 0; u < n; u++) {
    let h = 0, d = 0, p = 0, f = 0, m = 0, _ = 0, g = 0, v = 0, S = 0, b = 0, x = 0, M = 0;
    const C = u * e;
    let E = c, T = c;
    const w = r[C * 4], A = r[C * 4 + 1], O = r[C * 4 + 2], U = r[C * 4 + 3];
    for (let L = 0; L <= i; L++) {
      E.r = w, E.g = A, E.b = O, E.a = U;
      const P = i + 1 - L;
      S += w * P, b += A * P, x += O * P, M += U * P, L > 0 ? (h += w, d += A, p += O, f += U) : (m += w, _ += A, g += O, v += U), E = E.next;
    }
    for (let L = 1; L <= i; L++) {
      const P = Math.min(L, o), V = (C + P) * 4, ce = r[V], q = r[V + 1], oe = r[V + 2], ne = r[V + 3];
      E.r = ce, E.g = q, E.b = oe, E.a = ne;
      const $ = i + 1 - L;
      S += ce * $, b += q * $, x += oe * $, M += ne * $, h += ce, d += q, p += oe, f += ne, E = E.next;
    }
    let D = c;
    for (let L = 0; L < i; L++)
      D = D.next;
    T = D.next;
    for (let L = 0; L < e; L++) {
      const P = (C + L) * 4;
      r[P] = S * a >>> l, r[P + 1] = b * a >>> l, r[P + 2] = x * a >>> l, r[P + 3] = M * a >>> l, S -= m, b -= _, x -= g, M -= v, m -= D.r, _ -= D.g, g -= D.b, v -= D.a;
      const V = Math.min(L + i + 1, o), ce = (C + V) * 4;
      D.r = r[ce], D.g = r[ce + 1], D.b = r[ce + 2], D.a = r[ce + 3], h += D.r, d += D.g, p += D.b, f += D.a, S += h, b += d, x += p, M += f, D = D.next, m += T.r, _ += T.g, g += T.b, v += T.a, h -= T.r, d -= T.g, p -= T.b, f -= T.a, T = T.next;
    }
  }
}
function Yq(r, e, n, i) {
  const s = i + i + 1, o = n - 1, a = bS[i], l = wS[i], c = SS(s);
  for (let u = 0; u < e; u++) {
    let h = 0, d = 0, p = 0, f = 0, m = 0, _ = 0, g = 0, v = 0, S = 0, b = 0, x = 0, M = 0, C = c, E = c;
    const T = r[u * 4], w = r[u * 4 + 1], A = r[u * 4 + 2], O = r[u * 4 + 3];
    for (let D = 0; D <= i; D++) {
      C.r = T, C.g = w, C.b = A, C.a = O;
      const L = i + 1 - D;
      S += T * L, b += w * L, x += A * L, M += O * L, D > 0 ? (h += T, d += w, p += A, f += O) : (m += T, _ += w, g += A, v += O), C = C.next;
    }
    for (let D = 1; D <= i; D++) {
      const P = (Math.min(D, o) * e + u) * 4, V = r[P], ce = r[P + 1], q = r[P + 2], oe = r[P + 3];
      C.r = V, C.g = ce, C.b = q, C.a = oe;
      const ne = i + 1 - D;
      S += V * ne, b += ce * ne, x += q * ne, M += oe * ne, h += V, d += ce, p += q, f += oe, C = C.next;
    }
    let U = c;
    for (let D = 0; D < i; D++)
      U = U.next;
    E = U.next;
    for (let D = 0; D < n; D++) {
      const L = (D * e + u) * 4;
      r[L] = S * a >>> l, r[L + 1] = b * a >>> l, r[L + 2] = x * a >>> l, r[L + 3] = M * a >>> l, S -= m, b -= _, x -= g, M -= v, m -= U.r, _ -= U.g, g -= U.b, v -= U.a;
      const V = (Math.min(D + i + 1, o) * e + u) * 4;
      U.r = r[V], U.g = r[V + 1], U.b = r[V + 2], U.a = r[V + 3], h += U.r, d += U.g, p += U.b, f += U.a, S += h, b += d, x += p, M += f, U = U.next, m += E.r, _ += E.g, g += E.b, v += E.a, h -= E.r, d -= E.g, p -= E.b, f -= E.a, E = E.next;
    }
  }
}
function qq(r, e) {
  const n = e.blurriness ?? 10, i = e.blur_dimensions ?? "both";
  if (n <= 0)
    return r;
  const s = bl(r.canvas), o = r.ctx.getImageData(0, 0, r.canvas.width, r.canvas.height);
  let a = 0, l = 0;
  switch (i) {
    case "horizontal":
      a = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      a = n, l = n;
      break;
  }
  return $q(o, a, l), s.ctx.putImageData(o, 0, 0), s;
}
function Zq() {
  Oa("gaussian-blur", qq);
}
function Kq(r, e) {
  const n = (e.brightness ?? 0) / 100, i = (e.contrast ?? 0) / 100, s = e.use_legacy ?? !1;
  if (n === 0 && i === 0)
    return r;
  const o = bl(r.canvas), a = r.ctx.getImageData(0, 0, r.canvas.width, r.canvas.height), l = a.data, c = s ? 1 + i : 259 * (i * 255 + 255) / (255 * (259 - i * 255));
  for (let u = 0; u < l.length; u += 4) {
    let h = l[u], d = l[u + 1], p = l[u + 2];
    h += n * 255, d += n * 255, p += n * 255, h = c * (h - 128) + 128, d = c * (d - 128) + 128, p = c * (p - 128) + 128, l[u] = Math.max(0, Math.min(255, h)), l[u + 1] = Math.max(0, Math.min(255, d)), l[u + 2] = Math.max(0, Math.min(255, p));
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function Jq(r, e, n) {
  r /= 255, e /= 255, n /= 255;
  const i = Math.max(r, e, n), s = Math.min(r, e, n), o = (i + s) / 2;
  let a = 0, l = 0;
  if (i !== s) {
    const c = i - s;
    switch (l = o > 0.5 ? c / (2 - i - s) : c / (i + s), i) {
      case r:
        a = ((e - n) / c + (e < n ? 6 : 0)) / 6;
        break;
      case e:
        a = ((n - r) / c + 2) / 6;
        break;
      case n:
        a = ((r - e) / c + 4) / 6;
        break;
    }
  }
  return [a, l, o];
}
function Qq(r, e, n) {
  let i, s, o;
  if (e === 0)
    i = s = o = n;
  else {
    const a = (u, h, d) => (d < 0 && (d += 1), d > 1 && (d -= 1), d < 0.16666666666666666 ? u + (h - u) * 6 * d : d < 0.5 ? h : d < 0.6666666666666666 ? u + (h - u) * (0.6666666666666666 - d) * 6 : u), l = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - l;
    i = a(c, l, r + 1 / 3), s = a(c, l, r), o = a(c, l, r - 1 / 3);
  }
  return [Math.round(i * 255), Math.round(s * 255), Math.round(o * 255)];
}
function eZ(r, e) {
  const n = (e.master_hue ?? 0) / 360, i = (e.master_saturation ?? 0) / 100, s = (e.master_lightness ?? 0) / 100, o = e.colorize ?? !1;
  if (n === 0 && i === 0 && s === 0 && !o)
    return r;
  const a = bl(r.canvas), l = r.ctx.getImageData(0, 0, r.canvas.width, r.canvas.height), c = l.data;
  for (let u = 0; u < c.length; u += 4) {
    const h = c[u], d = c[u + 1], p = c[u + 2];
    let [f, m, _] = Jq(h, d, p);
    o ? (f = n, m = Math.abs(i) + 0.25) : (f = (f + n) % 1, f < 0 && (f += 1), m = m + m * i), _ = _ + _ * s, m = Math.max(0, Math.min(1, m)), _ = Math.max(0, Math.min(1, _));
    const [g, v, S] = Qq(f, m, _);
    c[u] = g, c[u + 1] = v, c[u + 2] = S;
  }
  return a.ctx.putImageData(l, 0, 0), a;
}
function tZ(r, e) {
  const n = e.input_black ?? 0, i = e.input_white ?? 255, s = e.gamma ?? 1, o = e.output_black ?? 0, a = e.output_white ?? 255;
  if (n === 0 && i === 255 && s === 1 && o === 0 && a === 255)
    return r;
  const l = bl(r.canvas), c = r.ctx.getImageData(0, 0, r.canvas.width, r.canvas.height), u = c.data, h = new Uint8Array(256), d = i - n, p = a - o;
  for (let f = 0; f < 256; f++) {
    let m = (f - n) / d;
    m = Math.max(0, Math.min(1, m)), m = Math.pow(m, 1 / s), m = o + m * p, m = Math.max(0, Math.min(255, m)), h[f] = Math.round(m);
  }
  for (let f = 0; f < u.length; f += 4)
    u[f] = h[u[f]], u[f + 1] = h[u[f + 1]], u[f + 2] = h[u[f + 2]];
  return l.ctx.putImageData(c, 0, 0), l;
}
function nZ(r, e) {
  const n = e.map_black_to ?? { r: 0, g: 0, b: 0 }, i = e.map_white_to ?? { r: 255, g: 255, b: 255 }, s = (e.amount_to_tint ?? 100) / 100;
  if (s === 0)
    return r;
  const o = bl(r.canvas), a = r.ctx.getImageData(0, 0, r.canvas.width, r.canvas.height), l = a.data;
  for (let c = 0; c < l.length; c += 4) {
    const u = l[c], h = l[c + 1], d = l[c + 2], p = (u * 0.299 + h * 0.587 + d * 0.114) / 255, f = n.r + (i.r - n.r) * p, m = n.g + (i.g - n.g) * p, _ = n.b + (i.b - n.b) * p;
    l[c] = Math.round(u + (f - u) * s), l[c + 1] = Math.round(h + (m - h) * s), l[c + 2] = Math.round(d + (_ - d) * s);
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function iZ(r, e) {
  const n = e.shadow_color ?? { r: 0, g: 0, b: 0 }, i = (e.opacity ?? 50) / 100, s = (e.direction ?? 135) * Math.PI / 180, o = e.distance ?? 5, a = e.softness ?? 5, l = e.shadow_only ?? !1, c = bl(r.canvas), { width: u, height: h } = r.canvas, d = Math.cos(s) * o, p = Math.sin(s) * o;
  return c.ctx.shadowColor = `rgba(${n.r}, ${n.g}, ${n.b}, ${i})`, c.ctx.shadowBlur = a, c.ctx.shadowOffsetX = d, c.ctx.shadowOffsetY = p, c.ctx.drawImage(r.canvas, 0, 0), c.ctx.shadowColor = "transparent", c.ctx.shadowBlur = 0, c.ctx.shadowOffsetX = 0, c.ctx.shadowOffsetY = 0, l || c.ctx.drawImage(r.canvas, 0, 0), c;
}
function sZ() {
  Oa("brightness-contrast", Kq), Oa("hue-saturation", eZ), Oa("levels", tZ), Oa("tint", nZ), Oa("drop-shadow", iZ);
}
function rZ() {
  Zq(), sZ();
}
let MS = null;
function O_(r) {
  let e = null;
  if (typeof r == "string" ? e = document.getElementById(r) || document.querySelector(r) : r instanceof HTMLElement ? e = r : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  rZ();
  const n = QC(jq);
  return n.use(nT()), n.mount(e), MS = n, oZ(), n;
}
function oZ() {
  window.addEventListener("weyl:inputs-ready", (r) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: r.detail }));
  });
}
async function dZ(r, e) {
  var n, i;
  return ((i = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : i.call(n, r, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => O_()) : setTimeout(() => {
  MS || O_();
}, 0);
var zh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function aZ(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Bh(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var CS = { exports: {} };
(function(r, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(i) {
    r.exports = i();
  })(function() {
    return function i(s, o, a) {
      function l(h, d) {
        if (!o[h]) {
          if (!s[h]) {
            var p = typeof Bh == "function" && Bh;
            if (!d && p) return p(h, !0);
            if (c) return c(h, !0);
            var f = new Error("Cannot find module '" + h + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var m = o[h] = { exports: {} };
          s[h][0].call(m.exports, function(_) {
            var g = s[h][1][_];
            return l(g || _);
          }, m, m.exports, i, s, o, a);
        }
        return o[h].exports;
      }
      for (var c = typeof Bh == "function" && Bh, u = 0; u < a.length; u++) l(a[u]);
      return l;
    }({ 1: [function(i, s, o) {
      var a = i("./utils"), l = i("./support"), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o.encode = function(u) {
        for (var h, d, p, f, m, _, g, v = [], S = 0, b = u.length, x = b, M = a.getTypeOf(u) !== "string"; S < u.length; ) x = b - S, p = M ? (h = u[S++], d = S < b ? u[S++] : 0, S < b ? u[S++] : 0) : (h = u.charCodeAt(S++), d = S < b ? u.charCodeAt(S++) : 0, S < b ? u.charCodeAt(S++) : 0), f = h >> 2, m = (3 & h) << 4 | d >> 4, _ = 1 < x ? (15 & d) << 2 | p >> 6 : 64, g = 2 < x ? 63 & p : 64, v.push(c.charAt(f) + c.charAt(m) + c.charAt(_) + c.charAt(g));
        return v.join("");
      }, o.decode = function(u) {
        var h, d, p, f, m, _, g = 0, v = 0, S = "data:";
        if (u.substr(0, S.length) === S) throw new Error("Invalid base64 input, it looks like a data url.");
        var b, x = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === c.charAt(64) && x--, u.charAt(u.length - 2) === c.charAt(64) && x--, x % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (b = l.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); g < u.length; ) h = c.indexOf(u.charAt(g++)) << 2 | (f = c.indexOf(u.charAt(g++))) >> 4, d = (15 & f) << 4 | (m = c.indexOf(u.charAt(g++))) >> 2, p = (3 & m) << 6 | (_ = c.indexOf(u.charAt(g++))), b[v++] = h, m !== 64 && (b[v++] = d), _ !== 64 && (b[v++] = p);
        return b;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(i, s, o) {
      var a = i("./external"), l = i("./stream/DataWorker"), c = i("./stream/Crc32Probe"), u = i("./stream/DataLengthProbe");
      function h(d, p, f, m, _) {
        this.compressedSize = d, this.uncompressedSize = p, this.crc32 = f, this.compression = m, this.compressedContent = _;
      }
      h.prototype = { getContentWorker: function() {
        var d = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), p = this;
        return d.on("end", function() {
          if (this.streamInfo.data_length !== p.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), d;
      }, getCompressedWorker: function() {
        return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, h.createWorkerFrom = function(d, p, f) {
        return d.pipe(new c()).pipe(new u("uncompressedSize")).pipe(p.compressWorker(f)).pipe(new u("compressedSize")).withStreamInfo("compression", p);
      }, s.exports = h;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, s, o) {
      var a = i("./stream/GenericWorker");
      o.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, o.DEFLATE = i("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, s, o) {
      var a = i("./utils"), l = function() {
        for (var c, u = [], h = 0; h < 256; h++) {
          c = h;
          for (var d = 0; d < 8; d++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
          u[h] = c;
        }
        return u;
      }();
      s.exports = function(c, u) {
        return c !== void 0 && c.length ? a.getTypeOf(c) !== "string" ? function(h, d, p, f) {
          var m = l, _ = f + p;
          h ^= -1;
          for (var g = f; g < _; g++) h = h >>> 8 ^ m[255 & (h ^ d[g])];
          return -1 ^ h;
        }(0 | u, c, c.length, 0) : function(h, d, p, f) {
          var m = l, _ = f + p;
          h ^= -1;
          for (var g = f; g < _; g++) h = h >>> 8 ^ m[255 & (h ^ d.charCodeAt(g))];
          return -1 ^ h;
        }(0 | u, c, c.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(i, s, o) {
      o.base64 = !1, o.binary = !1, o.dir = !1, o.createFolders = !0, o.date = null, o.compression = null, o.compressionOptions = null, o.comment = null, o.unixPermissions = null, o.dosPermissions = null;
    }, {}], 6: [function(i, s, o) {
      var a = null;
      a = typeof Promise < "u" ? Promise : i("lie"), s.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(i, s, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = i("pako"), c = i("./utils"), u = i("./stream/GenericWorker"), h = a ? "uint8array" : "array";
      function d(p, f) {
        u.call(this, "FlateWorker/" + p), this._pako = null, this._pakoAction = p, this._pakoOptions = f, this.meta = {};
      }
      o.magic = "\b\0", c.inherits(d, u), d.prototype.processChunk = function(p) {
        this.meta = p.meta, this._pako === null && this._createPako(), this._pako.push(c.transformTo(h, p.data), !1);
      }, d.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, d.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, d.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var p = this;
        this._pako.onData = function(f) {
          p.push({ data: f, meta: p.meta });
        };
      }, o.compressWorker = function(p) {
        return new d("Deflate", p);
      }, o.uncompressWorker = function() {
        return new d("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, s, o) {
      function a(m, _) {
        var g, v = "";
        for (g = 0; g < _; g++) v += String.fromCharCode(255 & m), m >>>= 8;
        return v;
      }
      function l(m, _, g, v, S, b) {
        var x, M, C = m.file, E = m.compression, T = b !== h.utf8encode, w = c.transformTo("string", b(C.name)), A = c.transformTo("string", h.utf8encode(C.name)), O = C.comment, U = c.transformTo("string", b(O)), D = c.transformTo("string", h.utf8encode(O)), L = A.length !== C.name.length, P = D.length !== O.length, V = "", ce = "", q = "", oe = C.dir, ne = C.date, $ = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        _ && !g || ($.crc32 = m.crc32, $.compressedSize = m.compressedSize, $.uncompressedSize = m.uncompressedSize);
        var J = 0;
        _ && (J |= 8), T || !L && !P || (J |= 2048);
        var se = 0, le = 0;
        oe && (se |= 16), S === "UNIX" ? (le = 798, se |= function(ye, H) {
          var K = ye;
          return ye || (K = H ? 16893 : 33204), (65535 & K) << 16;
        }(C.unixPermissions, oe)) : (le = 20, se |= function(ye) {
          return 63 & (ye || 0);
        }(C.dosPermissions)), x = ne.getUTCHours(), x <<= 6, x |= ne.getUTCMinutes(), x <<= 5, x |= ne.getUTCSeconds() / 2, M = ne.getUTCFullYear() - 1980, M <<= 4, M |= ne.getUTCMonth() + 1, M <<= 5, M |= ne.getUTCDate(), L && (ce = a(1, 1) + a(d(w), 4) + A, V += "up" + a(ce.length, 2) + ce), P && (q = a(1, 1) + a(d(U), 4) + D, V += "uc" + a(q.length, 2) + q);
        var re = "";
        return re += `
\0`, re += a(J, 2), re += E.magic, re += a(x, 2), re += a(M, 2), re += a($.crc32, 4), re += a($.compressedSize, 4), re += a($.uncompressedSize, 4), re += a(w.length, 2), re += a(V.length, 2), { fileRecord: p.LOCAL_FILE_HEADER + re + w + V, dirRecord: p.CENTRAL_FILE_HEADER + a(le, 2) + re + a(U.length, 2) + "\0\0\0\0" + a(se, 4) + a(v, 4) + w + V + U };
      }
      var c = i("../utils"), u = i("../stream/GenericWorker"), h = i("../utf8"), d = i("../crc32"), p = i("../signature");
      function f(m, _, g, v) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = _, this.zipPlatform = g, this.encodeFileName = v, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      c.inherits(f, u), f.prototype.push = function(m) {
        var _ = m.meta.percent || 0, g = this.entriesCount, v = this._sources.length;
        this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, u.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: g ? (_ + 100 * (g - v - 1)) / g : 100 } }));
      }, f.prototype.openedSource = function(m) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
        var _ = this.streamFiles && !m.file.dir;
        if (_) {
          var g = l(m, _, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, f.prototype.closedSource = function(m) {
        this.accumulate = !1;
        var _ = this.streamFiles && !m.file.dir, g = l(m, _, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), _) this.push({ data: function(v) {
          return p.DATA_DESCRIPTOR + a(v.crc32, 4) + a(v.compressedSize, 4) + a(v.uncompressedSize, 4);
        }(m), meta: { percent: 100 } });
        else for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, f.prototype.flush = function() {
        for (var m = this.bytesWritten, _ = 0; _ < this.dirRecords.length; _++) this.push({ data: this.dirRecords[_], meta: { percent: 100 } });
        var g = this.bytesWritten - m, v = function(S, b, x, M, C) {
          var E = c.transformTo("string", C(M));
          return p.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(S, 2) + a(S, 2) + a(b, 4) + a(x, 4) + a(E.length, 2) + E;
        }(this.dirRecords.length, g, m, this.zipComment, this.encodeFileName);
        this.push({ data: v, meta: { percent: 100 } });
      }, f.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, f.prototype.registerPrevious = function(m) {
        this._sources.push(m);
        var _ = this;
        return m.on("data", function(g) {
          _.processChunk(g);
        }), m.on("end", function() {
          _.closedSource(_.previous.streamInfo), _._sources.length ? _.prepareNextSource() : _.end();
        }), m.on("error", function(g) {
          _.error(g);
        }), this;
      }, f.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, f.prototype.error = function(m) {
        var _ = this._sources;
        if (!u.prototype.error.call(this, m)) return !1;
        for (var g = 0; g < _.length; g++) try {
          _[g].error(m);
        } catch {
        }
        return !0;
      }, f.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var m = this._sources, _ = 0; _ < m.length; _++) m[_].lock();
      }, s.exports = f;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, s, o) {
      var a = i("../compressions"), l = i("./ZipFileWorker");
      o.generateWorker = function(c, u, h) {
        var d = new l(u.streamFiles, h, u.platform, u.encodeFileName), p = 0;
        try {
          c.forEach(function(f, m) {
            p++;
            var _ = function(b, x) {
              var M = b || x, C = a[M];
              if (!C) throw new Error(M + " is not a valid compression method !");
              return C;
            }(m.options.compression, u.compression), g = m.options.compressionOptions || u.compressionOptions || {}, v = m.dir, S = m.date;
            m._compressWorker(_, g).withStreamInfo("file", { name: f, dir: v, date: S, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(d);
          }), d.entriesCount = p;
        } catch (f) {
          d.error(f);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, s, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new a();
          for (var c in this) typeof this[c] != "function" && (l[c] = this[c]);
          return l;
        };
      }
      (a.prototype = i("./object")).loadAsync = i("./load"), a.support = i("./support"), a.defaults = i("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, c) {
        return new a().loadAsync(l, c);
      }, a.external = i("./external"), s.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, s, o) {
      var a = i("./utils"), l = i("./external"), c = i("./utf8"), u = i("./zipEntries"), h = i("./stream/Crc32Probe"), d = i("./nodejsUtils");
      function p(f) {
        return new l.Promise(function(m, _) {
          var g = f.decompressed.getContentWorker().pipe(new h());
          g.on("error", function(v) {
            _(v);
          }).on("end", function() {
            g.streamInfo.crc32 !== f.decompressed.crc32 ? _(new Error("Corrupted zip : CRC32 mismatch")) : m();
          }).resume();
        });
      }
      s.exports = function(f, m) {
        var _ = this;
        return m = a.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: c.utf8decode }), d.isNode && d.isStream(f) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", f, !0, m.optimizedBinaryString, m.base64).then(function(g) {
          var v = new u(m);
          return v.load(g), v;
        }).then(function(g) {
          var v = [l.Promise.resolve(g)], S = g.files;
          if (m.checkCRC32) for (var b = 0; b < S.length; b++) v.push(p(S[b]));
          return l.Promise.all(v);
        }).then(function(g) {
          for (var v = g.shift(), S = v.files, b = 0; b < S.length; b++) {
            var x = S[b], M = x.fileNameStr, C = a.resolve(x.fileNameStr);
            _.file(C, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: m.createFolders }), x.dir || (_.file(C).unsafeOriginalName = M);
          }
          return v.zipComment.length && (_.comment = v.zipComment), _;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, s, o) {
      var a = i("../utils"), l = i("../stream/GenericWorker");
      function c(u, h) {
        l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(h);
      }
      a.inherits(c, l), c.prototype._bindStream = function(u) {
        var h = this;
        (this._stream = u).pause(), u.on("data", function(d) {
          h.push({ data: d, meta: { percent: 0 } });
        }).on("error", function(d) {
          h.isPaused ? this.generatedError = d : h.error(d);
        }).on("end", function() {
          h.isPaused ? h._upstreamEnded = !0 : h.end();
        });
      }, c.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, s.exports = c;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, s, o) {
      var a = i("readable-stream").Readable;
      function l(c, u, h) {
        a.call(this, u), this._helper = c;
        var d = this;
        c.on("data", function(p, f) {
          d.push(p) || d._helper.pause(), h && h(f);
        }).on("error", function(p) {
          d.emit("error", p);
        }).on("end", function() {
          d.push(null);
        });
      }
      i("../utils").inherits(l, a), l.prototype._read = function() {
        this._helper.resume();
      }, s.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, s, o) {
      s.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
        if (typeof a == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(a, l);
      }, allocBuffer: function(a) {
        if (Buffer.alloc) return Buffer.alloc(a);
        var l = new Buffer(a);
        return l.fill(0), l;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(i, s, o) {
      function a(C, E, T) {
        var w, A = c.getTypeOf(E), O = c.extend(T || {}, d);
        O.date = O.date || /* @__PURE__ */ new Date(), O.compression !== null && (O.compression = O.compression.toUpperCase()), typeof O.unixPermissions == "string" && (O.unixPermissions = parseInt(O.unixPermissions, 8)), O.unixPermissions && 16384 & O.unixPermissions && (O.dir = !0), O.dosPermissions && 16 & O.dosPermissions && (O.dir = !0), O.dir && (C = S(C)), O.createFolders && (w = v(C)) && b.call(this, w, !0);
        var U = A === "string" && O.binary === !1 && O.base64 === !1;
        T && T.binary !== void 0 || (O.binary = !U), (E instanceof p && E.uncompressedSize === 0 || O.dir || !E || E.length === 0) && (O.base64 = !1, O.binary = !0, E = "", O.compression = "STORE", A = "string");
        var D = null;
        D = E instanceof p || E instanceof u ? E : _.isNode && _.isStream(E) ? new g(C, E) : c.prepareContent(C, E, O.binary, O.optimizedBinaryString, O.base64);
        var L = new f(C, D, O);
        this.files[C] = L;
      }
      var l = i("./utf8"), c = i("./utils"), u = i("./stream/GenericWorker"), h = i("./stream/StreamHelper"), d = i("./defaults"), p = i("./compressedObject"), f = i("./zipObject"), m = i("./generate"), _ = i("./nodejsUtils"), g = i("./nodejs/NodejsStreamInputAdapter"), v = function(C) {
        C.slice(-1) === "/" && (C = C.substring(0, C.length - 1));
        var E = C.lastIndexOf("/");
        return 0 < E ? C.substring(0, E) : "";
      }, S = function(C) {
        return C.slice(-1) !== "/" && (C += "/"), C;
      }, b = function(C, E) {
        return E = E !== void 0 ? E : d.createFolders, C = S(C), this.files[C] || a.call(this, C, null, { dir: !0, createFolders: E }), this.files[C];
      };
      function x(C) {
        return Object.prototype.toString.call(C) === "[object RegExp]";
      }
      var M = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(C) {
        var E, T, w;
        for (E in this.files) w = this.files[E], (T = E.slice(this.root.length, E.length)) && E.slice(0, this.root.length) === this.root && C(T, w);
      }, filter: function(C) {
        var E = [];
        return this.forEach(function(T, w) {
          C(T, w) && E.push(w);
        }), E;
      }, file: function(C, E, T) {
        if (arguments.length !== 1) return C = this.root + C, a.call(this, C, E, T), this;
        if (x(C)) {
          var w = C;
          return this.filter(function(O, U) {
            return !U.dir && w.test(O);
          });
        }
        var A = this.files[this.root + C];
        return A && !A.dir ? A : null;
      }, folder: function(C) {
        if (!C) return this;
        if (x(C)) return this.filter(function(A, O) {
          return O.dir && C.test(A);
        });
        var E = this.root + C, T = b.call(this, E), w = this.clone();
        return w.root = T.name, w;
      }, remove: function(C) {
        C = this.root + C;
        var E = this.files[C];
        if (E || (C.slice(-1) !== "/" && (C += "/"), E = this.files[C]), E && !E.dir) delete this.files[C];
        else for (var T = this.filter(function(A, O) {
          return O.name.slice(0, C.length) === C;
        }), w = 0; w < T.length; w++) delete this.files[T[w].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(C) {
        var E, T = {};
        try {
          if ((T = c.extend(C || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = T.type.toLowerCase(), T.compression = T.compression.toUpperCase(), T.type === "binarystring" && (T.type = "string"), !T.type) throw new Error("No output type specified.");
          c.checkSupport(T.type), T.platform !== "darwin" && T.platform !== "freebsd" && T.platform !== "linux" && T.platform !== "sunos" || (T.platform = "UNIX"), T.platform === "win32" && (T.platform = "DOS");
          var w = T.comment || this.comment || "";
          E = m.generateWorker(this, T, w);
        } catch (A) {
          (E = new u("error")).error(A);
        }
        return new h(E, T.type || "string", T.mimeType);
      }, generateAsync: function(C, E) {
        return this.generateInternalStream(C).accumulate(E);
      }, generateNodeStream: function(C, E) {
        return (C = C || {}).type || (C.type = "nodebuffer"), this.generateInternalStream(C).toNodejsStream(E);
      } };
      s.exports = M;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, s, o) {
      s.exports = i("stream");
    }, { stream: void 0 }], 17: [function(i, s, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
        for (var u = 0; u < this.data.length; u++) c[u] = 255 & c[u];
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data[this.zero + c];
      }, l.prototype.lastIndexOfSignature = function(c) {
        for (var u = c.charCodeAt(0), h = c.charCodeAt(1), d = c.charCodeAt(2), p = c.charCodeAt(3), f = this.length - 4; 0 <= f; --f) if (this.data[f] === u && this.data[f + 1] === h && this.data[f + 2] === d && this.data[f + 3] === p) return f - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(c) {
        var u = c.charCodeAt(0), h = c.charCodeAt(1), d = c.charCodeAt(2), p = c.charCodeAt(3), f = this.readData(4);
        return u === f[0] && h === f[1] && d === f[2] && p === f[3];
      }, l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, s.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, s, o) {
      var a = i("../utils");
      function l(c) {
        this.data = c, this.length = c.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(c) {
        this.checkIndex(this.index + c);
      }, checkIndex: function(c) {
        if (this.length < this.zero + c || c < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + c + "). Corrupted zip ?");
      }, setIndex: function(c) {
        this.checkIndex(c), this.index = c;
      }, skip: function(c) {
        this.setIndex(this.index + c);
      }, byteAt: function() {
      }, readInt: function(c) {
        var u, h = 0;
        for (this.checkOffset(c), u = this.index + c - 1; u >= this.index; u--) h = (h << 8) + this.byteAt(u);
        return this.index += c, h;
      }, readString: function(c) {
        return a.transformTo("string", this.readData(c));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var c = this.readInt(4);
        return new Date(Date.UTC(1980 + (c >> 25 & 127), (c >> 21 & 15) - 1, c >> 16 & 31, c >> 11 & 31, c >> 5 & 63, (31 & c) << 1));
      } }, s.exports = l;
    }, { "../utils": 32 }], 19: [function(i, s, o) {
      var a = i("./Uint8ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, s.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, s, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data.charCodeAt(this.zero + c);
      }, l.prototype.lastIndexOfSignature = function(c) {
        return this.data.lastIndexOf(c) - this.zero;
      }, l.prototype.readAndCheckSignature = function(c) {
        return c === this.readData(4);
      }, l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, s.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, s, o) {
      var a = i("./ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, s.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, s, o) {
      var a = i("../utils"), l = i("../support"), c = i("./ArrayReader"), u = i("./StringReader"), h = i("./NodeBufferReader"), d = i("./Uint8ArrayReader");
      s.exports = function(p) {
        var f = a.getTypeOf(p);
        return a.checkSupport(f), f !== "string" || l.uint8array ? f === "nodebuffer" ? new h(p) : l.uint8array ? new d(a.transformTo("uint8array", p)) : new c(a.transformTo("array", p)) : new u(p);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, s, o) {
      o.LOCAL_FILE_HEADER = "PK", o.CENTRAL_FILE_HEADER = "PK", o.CENTRAL_DIRECTORY_END = "PK", o.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", o.ZIP64_CENTRAL_DIRECTORY_END = "PK", o.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(i, s, o) {
      var a = i("./GenericWorker"), l = i("../utils");
      function c(u) {
        a.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      l.inherits(c, a), c.prototype.processChunk = function(u) {
        this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
      }, s.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, s, o) {
      var a = i("./GenericWorker"), l = i("../crc32");
      function c() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      i("../utils").inherits(c, a), c.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, s.exports = c;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, s, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      a.inherits(c, l), c.prototype.processChunk = function(u) {
        if (u) {
          var h = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = h + u.data.length;
        }
        l.prototype.processChunk.call(this, u);
      }, s.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, s, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataWorker");
        var h = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(d) {
          h.dataIsReady = !0, h.data = d, h.max = d && d.length || 0, h.type = a.getTypeOf(d), h.isPaused || h._tickAndRepeat();
        }, function(d) {
          h.error(d);
        });
      }
      a.inherits(c, l), c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, c.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, c.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var u = null, h = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, h);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, h);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, h);
        }
        return this.index = h, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, s.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, s, o) {
      function a(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, c) {
        return this._listeners[l].push(c), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, c) {
        if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, c);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var c = this;
        return l.on("data", function(u) {
          c.processChunk(u);
        }), l.on("end", function() {
          c.end();
        }), l.on("error", function(u) {
          c.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, c) {
        return this.extraStreamInfo[l] = c, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, s.exports = a;
    }, {}], 29: [function(i, s, o) {
      var a = i("../utils"), l = i("./ConvertWorker"), c = i("./GenericWorker"), u = i("../base64"), h = i("../support"), d = i("../external"), p = null;
      if (h.nodestream) try {
        p = i("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function f(_, g) {
        return new d.Promise(function(v, S) {
          var b = [], x = _._internalType, M = _._outputType, C = _._mimeType;
          _.on("data", function(E, T) {
            b.push(E), g && g(T);
          }).on("error", function(E) {
            b = [], S(E);
          }).on("end", function() {
            try {
              var E = function(T, w, A) {
                switch (T) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", w), A);
                  case "base64":
                    return u.encode(w);
                  default:
                    return a.transformTo(T, w);
                }
              }(M, function(T, w) {
                var A, O = 0, U = null, D = 0;
                for (A = 0; A < w.length; A++) D += w[A].length;
                switch (T) {
                  case "string":
                    return w.join("");
                  case "array":
                    return Array.prototype.concat.apply([], w);
                  case "uint8array":
                    for (U = new Uint8Array(D), A = 0; A < w.length; A++) U.set(w[A], O), O += w[A].length;
                    return U;
                  case "nodebuffer":
                    return Buffer.concat(w);
                  default:
                    throw new Error("concat : unsupported type '" + T + "'");
                }
              }(x, b), C);
              v(E);
            } catch (T) {
              S(T);
            }
            b = [];
          }).resume();
        });
      }
      function m(_, g, v) {
        var S = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            S = "uint8array";
            break;
          case "base64":
            S = "string";
        }
        try {
          this._internalType = S, this._outputType = g, this._mimeType = v, a.checkSupport(S), this._worker = _.pipe(new l(S)), _.lock();
        } catch (b) {
          this._worker = new c("error"), this._worker.error(b);
        }
      }
      m.prototype = { accumulate: function(_) {
        return f(this, _);
      }, on: function(_, g) {
        var v = this;
        return _ === "data" ? this._worker.on(_, function(S) {
          g.call(v, S.data, S.meta);
        }) : this._worker.on(_, function() {
          a.delay(g, arguments, v);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(_) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new p(this, { objectMode: this._outputType !== "nodebuffer" }, _);
      } }, s.exports = m;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, s, o) {
      if (o.base64 = !0, o.array = !0, o.string = !0, o.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o.nodebuffer = typeof Buffer < "u", o.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") o.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          o.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(a), o.blob = l.getBlob("application/zip").size === 0;
          } catch {
            o.blob = !1;
          }
        }
      }
      try {
        o.nodestream = !!i("readable-stream").Readable;
      } catch {
        o.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(i, s, o) {
      for (var a = i("./utils"), l = i("./support"), c = i("./nodejsUtils"), u = i("./stream/GenericWorker"), h = new Array(256), d = 0; d < 256; d++) h[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      h[254] = h[254] = 1;
      function p() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        u.call(this, "utf-8 encode");
      }
      o.utf8encode = function(m) {
        return l.nodebuffer ? c.newBufferFrom(m, "utf-8") : function(_) {
          var g, v, S, b, x, M = _.length, C = 0;
          for (b = 0; b < M; b++) (64512 & (v = _.charCodeAt(b))) == 55296 && b + 1 < M && (64512 & (S = _.charCodeAt(b + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (S - 56320), b++), C += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
          for (g = l.uint8array ? new Uint8Array(C) : new Array(C), b = x = 0; x < C; b++) (64512 & (v = _.charCodeAt(b))) == 55296 && b + 1 < M && (64512 & (S = _.charCodeAt(b + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (S - 56320), b++), v < 128 ? g[x++] = v : (v < 2048 ? g[x++] = 192 | v >>> 6 : (v < 65536 ? g[x++] = 224 | v >>> 12 : (g[x++] = 240 | v >>> 18, g[x++] = 128 | v >>> 12 & 63), g[x++] = 128 | v >>> 6 & 63), g[x++] = 128 | 63 & v);
          return g;
        }(m);
      }, o.utf8decode = function(m) {
        return l.nodebuffer ? a.transformTo("nodebuffer", m).toString("utf-8") : function(_) {
          var g, v, S, b, x = _.length, M = new Array(2 * x);
          for (g = v = 0; g < x; ) if ((S = _[g++]) < 128) M[v++] = S;
          else if (4 < (b = h[S])) M[v++] = 65533, g += b - 1;
          else {
            for (S &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && g < x; ) S = S << 6 | 63 & _[g++], b--;
            1 < b ? M[v++] = 65533 : S < 65536 ? M[v++] = S : (S -= 65536, M[v++] = 55296 | S >> 10 & 1023, M[v++] = 56320 | 1023 & S);
          }
          return M.length !== v && (M.subarray ? M = M.subarray(0, v) : M.length = v), a.applyFromCharCode(M);
        }(m = a.transformTo(l.uint8array ? "uint8array" : "array", m));
      }, a.inherits(p, u), p.prototype.processChunk = function(m) {
        var _ = a.transformTo(l.uint8array ? "uint8array" : "array", m.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var g = _;
            (_ = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), _.set(g, this.leftOver.length);
          } else _ = this.leftOver.concat(_);
          this.leftOver = null;
        }
        var v = function(b, x) {
          var M;
          for ((x = x || b.length) > b.length && (x = b.length), M = x - 1; 0 <= M && (192 & b[M]) == 128; ) M--;
          return M < 0 || M === 0 ? x : M + h[b[M]] > x ? M : x;
        }(_), S = _;
        v !== _.length && (l.uint8array ? (S = _.subarray(0, v), this.leftOver = _.subarray(v, _.length)) : (S = _.slice(0, v), this.leftOver = _.slice(v, _.length))), this.push({ data: o.utf8decode(S), meta: m.meta });
      }, p.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: o.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, o.Utf8DecodeWorker = p, a.inherits(f, u), f.prototype.processChunk = function(m) {
        this.push({ data: o.utf8encode(m.data), meta: m.meta });
      }, o.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, s, o) {
      var a = i("./support"), l = i("./base64"), c = i("./nodejsUtils"), u = i("./external");
      function h(g) {
        return g;
      }
      function d(g, v) {
        for (var S = 0; S < g.length; ++S) v[S] = 255 & g.charCodeAt(S);
        return v;
      }
      i("setimmediate"), o.newBlob = function(g, v) {
        o.checkSupport("blob");
        try {
          return new Blob([g], { type: v });
        } catch {
          try {
            var S = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return S.append(g), S.getBlob(v);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var p = { stringifyByChunk: function(g, v, S) {
        var b = [], x = 0, M = g.length;
        if (M <= S) return String.fromCharCode.apply(null, g);
        for (; x < M; ) v === "array" || v === "nodebuffer" ? b.push(String.fromCharCode.apply(null, g.slice(x, Math.min(x + S, M)))) : b.push(String.fromCharCode.apply(null, g.subarray(x, Math.min(x + S, M)))), x += S;
        return b.join("");
      }, stringifyByChar: function(g) {
        for (var v = "", S = 0; S < g.length; S++) v += String.fromCharCode(g[S]);
        return v;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, c.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function f(g) {
        var v = 65536, S = o.getTypeOf(g), b = !0;
        if (S === "uint8array" ? b = p.applyCanBeUsed.uint8array : S === "nodebuffer" && (b = p.applyCanBeUsed.nodebuffer), b) for (; 1 < v; ) try {
          return p.stringifyByChunk(g, S, v);
        } catch {
          v = Math.floor(v / 2);
        }
        return p.stringifyByChar(g);
      }
      function m(g, v) {
        for (var S = 0; S < g.length; S++) v[S] = g[S];
        return v;
      }
      o.applyFromCharCode = f;
      var _ = {};
      _.string = { string: h, array: function(g) {
        return d(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return _.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return d(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return d(g, c.allocBuffer(g.length));
      } }, _.array = { string: f, array: h, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, _.arraybuffer = { string: function(g) {
        return f(new Uint8Array(g));
      }, array: function(g) {
        return m(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: h, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(new Uint8Array(g));
      } }, _.uint8array = { string: f, array: function(g) {
        return m(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: h, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, _.nodebuffer = { string: f, array: function(g) {
        return m(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return _.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return m(g, new Uint8Array(g.length));
      }, nodebuffer: h }, o.transformTo = function(g, v) {
        if (v = v || "", !g) return v;
        o.checkSupport(g);
        var S = o.getTypeOf(v);
        return _[S][g](v);
      }, o.resolve = function(g) {
        for (var v = g.split("/"), S = [], b = 0; b < v.length; b++) {
          var x = v[b];
          x === "." || x === "" && b !== 0 && b !== v.length - 1 || (x === ".." ? S.pop() : S.push(x));
        }
        return S.join("/");
      }, o.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : a.nodebuffer && c.isBuffer(g) ? "nodebuffer" : a.uint8array && g instanceof Uint8Array ? "uint8array" : a.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, o.checkSupport = function(g) {
        if (!a[g.toLowerCase()]) throw new Error(g + " is not supported by this platform");
      }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(g) {
        var v, S, b = "";
        for (S = 0; S < (g || "").length; S++) b += "\\x" + ((v = g.charCodeAt(S)) < 16 ? "0" : "") + v.toString(16).toUpperCase();
        return b;
      }, o.delay = function(g, v, S) {
        setImmediate(function() {
          g.apply(S || null, v || []);
        });
      }, o.inherits = function(g, v) {
        function S() {
        }
        S.prototype = v.prototype, g.prototype = new S();
      }, o.extend = function() {
        var g, v, S = {};
        for (g = 0; g < arguments.length; g++) for (v in arguments[g]) Object.prototype.hasOwnProperty.call(arguments[g], v) && S[v] === void 0 && (S[v] = arguments[g][v]);
        return S;
      }, o.prepareContent = function(g, v, S, b, x) {
        return u.Promise.resolve(v).then(function(M) {
          return a.blob && (M instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(M)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(C, E) {
            var T = new FileReader();
            T.onload = function(w) {
              C(w.target.result);
            }, T.onerror = function(w) {
              E(w.target.error);
            }, T.readAsArrayBuffer(M);
          }) : M;
        }).then(function(M) {
          var C = o.getTypeOf(M);
          return C ? (C === "arraybuffer" ? M = o.transformTo("uint8array", M) : C === "string" && (x ? M = l.decode(M) : S && b !== !0 && (M = function(E) {
            return d(E, a.uint8array ? new Uint8Array(E.length) : new Array(E.length));
          }(M))), M) : u.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, s, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./signature"), u = i("./zipEntry"), h = i("./support");
      function d(p) {
        this.files = [], this.loadOptions = p;
      }
      d.prototype = { checkSignature: function(p) {
        if (!this.reader.readAndCheckSignature(p)) {
          this.reader.index -= 4;
          var f = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(f) + ", expected " + l.pretty(p) + ")");
        }
      }, isSignature: function(p, f) {
        var m = this.reader.index;
        this.reader.setIndex(p);
        var _ = this.reader.readString(4) === f;
        return this.reader.setIndex(m), _;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var p = this.reader.readData(this.zipCommentLength), f = h.uint8array ? "uint8array" : "array", m = l.transformTo(f, p);
        this.zipComment = this.loadOptions.decodeFileName(m);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var p, f, m, _ = this.zip64EndOfCentralSize - 44; 0 < _; ) p = this.reader.readInt(2), f = this.reader.readInt(4), m = this.reader.readData(f), this.zip64ExtensibleData[p] = { id: p, length: f, value: m };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var p, f;
        for (p = 0; p < this.files.length; p++) f = this.files[p], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(c.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
      }, readCentralDir: function() {
        var p;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(c.CENTRAL_FILE_HEADER); ) (p = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(p);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var p = this.reader.lastIndexOfSignature(c.CENTRAL_DIRECTORY_END);
        if (p < 0) throw this.isSignature(0, c.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(p);
        var f = p;
        if (this.checkSignature(c.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (p = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(p), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, c.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var m = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
        var _ = f - m;
        if (0 < _) this.isSignature(f, c.CENTRAL_FILE_HEADER) || (this.reader.zero = _);
        else if (_ < 0) throw new Error("Corrupted zip: missing " + Math.abs(_) + " bytes.");
      }, prepareReader: function(p) {
        this.reader = a(p);
      }, load: function(p) {
        this.prepareReader(p), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, s.exports = d;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, s, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./compressedObject"), u = i("./crc32"), h = i("./utf8"), d = i("./compressions"), p = i("./support");
      function f(m, _) {
        this.options = m, this.loadOptions = _;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(m) {
        var _, g;
        if (m.skip(22), this.fileNameLength = m.readInt(2), g = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((_ = function(v) {
          for (var S in d) if (Object.prototype.hasOwnProperty.call(d, S) && d[S].magic === v) return d[S];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new c(this.compressedSize, this.uncompressedSize, this.crc32, _, m.readData(this.compressedSize));
      }, readCentralPart: function(m) {
        this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
        var _ = m.readInt(2);
        if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        m.skip(_), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var m = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var m = a(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = m.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = m.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = m.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = m.readInt(4));
        }
      }, readExtraFields: function(m) {
        var _, g, v, S = m.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); m.index + 4 < S; ) _ = m.readInt(2), g = m.readInt(2), v = m.readData(g), this.extraFields[_] = { id: _, length: g, value: v };
        m.setIndex(S);
      }, handleUTF8: function() {
        var m = p.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = h.utf8decode(this.fileName), this.fileCommentStr = h.utf8decode(this.fileComment);
        else {
          var _ = this.findExtraFieldUnicodePath();
          if (_ !== null) this.fileNameStr = _;
          else {
            var g = l.transformTo(m, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var v = this.findExtraFieldUnicodeComment();
          if (v !== null) this.fileCommentStr = v;
          else {
            var S = l.transformTo(m, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(S);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var m = this.extraFields[28789];
        if (m) {
          var _ = a(m.value);
          return _.readInt(1) !== 1 || u(this.fileName) !== _.readInt(4) ? null : h.utf8decode(_.readData(m.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var m = this.extraFields[25461];
        if (m) {
          var _ = a(m.value);
          return _.readInt(1) !== 1 || u(this.fileComment) !== _.readInt(4) ? null : h.utf8decode(_.readData(m.length - 5));
        }
        return null;
      } }, s.exports = f;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, s, o) {
      function a(_, g, v) {
        this.name = _, this.dir = v.dir, this.date = v.date, this.comment = v.comment, this.unixPermissions = v.unixPermissions, this.dosPermissions = v.dosPermissions, this._data = g, this._dataBinary = v.binary, this.options = { compression: v.compression, compressionOptions: v.compressionOptions };
      }
      var l = i("./stream/StreamHelper"), c = i("./stream/DataWorker"), u = i("./utf8"), h = i("./compressedObject"), d = i("./stream/GenericWorker");
      a.prototype = { internalStream: function(_) {
        var g = null, v = "string";
        try {
          if (!_) throw new Error("No output type specified.");
          var S = (v = _.toLowerCase()) === "string" || v === "text";
          v !== "binarystring" && v !== "text" || (v = "string"), g = this._decompressWorker();
          var b = !this._dataBinary;
          b && !S && (g = g.pipe(new u.Utf8EncodeWorker())), !b && S && (g = g.pipe(new u.Utf8DecodeWorker()));
        } catch (x) {
          (g = new d("error")).error(x);
        }
        return new l(g, v, "");
      }, async: function(_, g) {
        return this.internalStream(_).accumulate(g);
      }, nodeStream: function(_, g) {
        return this.internalStream(_ || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(_, g) {
        if (this._data instanceof h && this._data.compression.magic === _.magic) return this._data.getCompressedWorker();
        var v = this._decompressWorker();
        return this._dataBinary || (v = v.pipe(new u.Utf8EncodeWorker())), h.createWorkerFrom(v, _, g);
      }, _decompressWorker: function() {
        return this._data instanceof h ? this._data.getContentWorker() : this._data instanceof d ? this._data : new c(this._data);
      } };
      for (var p = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, m = 0; m < p.length; m++) a.prototype[p[m]] = f;
      s.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, s, o) {
      (function(a) {
        var l, c, u = a.MutationObserver || a.WebKitMutationObserver;
        if (u) {
          var h = 0, d = new u(_), p = a.document.createTextNode("");
          d.observe(p, { characterData: !0 }), l = function() {
            p.data = h = ++h % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
          var g = a.document.createElement("script");
          g.onreadystatechange = function() {
            _(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
          }, a.document.documentElement.appendChild(g);
        } : function() {
          setTimeout(_, 0);
        };
        else {
          var f = new a.MessageChannel();
          f.port1.onmessage = _, l = function() {
            f.port2.postMessage(0);
          };
        }
        var m = [];
        function _() {
          var g, v;
          c = !0;
          for (var S = m.length; S; ) {
            for (v = m, m = [], g = -1; ++g < S; ) v[g]();
            S = m.length;
          }
          c = !1;
        }
        s.exports = function(g) {
          m.push(g) !== 1 || c || l();
        };
      }).call(this, typeof zh < "u" ? zh : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(i, s, o) {
      var a = i("immediate");
      function l() {
      }
      var c = {}, u = ["REJECTED"], h = ["FULFILLED"], d = ["PENDING"];
      function p(S) {
        if (typeof S != "function") throw new TypeError("resolver must be a function");
        this.state = d, this.queue = [], this.outcome = void 0, S !== l && g(this, S);
      }
      function f(S, b, x) {
        this.promise = S, typeof b == "function" && (this.onFulfilled = b, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function m(S, b, x) {
        a(function() {
          var M;
          try {
            M = b(x);
          } catch (C) {
            return c.reject(S, C);
          }
          M === S ? c.reject(S, new TypeError("Cannot resolve promise with itself")) : c.resolve(S, M);
        });
      }
      function _(S) {
        var b = S && S.then;
        if (S && (typeof S == "object" || typeof S == "function") && typeof b == "function") return function() {
          b.apply(S, arguments);
        };
      }
      function g(S, b) {
        var x = !1;
        function M(T) {
          x || (x = !0, c.reject(S, T));
        }
        function C(T) {
          x || (x = !0, c.resolve(S, T));
        }
        var E = v(function() {
          b(C, M);
        });
        E.status === "error" && M(E.value);
      }
      function v(S, b) {
        var x = {};
        try {
          x.value = S(b), x.status = "success";
        } catch (M) {
          x.status = "error", x.value = M;
        }
        return x;
      }
      (s.exports = p).prototype.finally = function(S) {
        if (typeof S != "function") return this;
        var b = this.constructor;
        return this.then(function(x) {
          return b.resolve(S()).then(function() {
            return x;
          });
        }, function(x) {
          return b.resolve(S()).then(function() {
            throw x;
          });
        });
      }, p.prototype.catch = function(S) {
        return this.then(null, S);
      }, p.prototype.then = function(S, b) {
        if (typeof S != "function" && this.state === h || typeof b != "function" && this.state === u) return this;
        var x = new this.constructor(l);
        return this.state !== d ? m(x, this.state === h ? S : b, this.outcome) : this.queue.push(new f(x, S, b)), x;
      }, f.prototype.callFulfilled = function(S) {
        c.resolve(this.promise, S);
      }, f.prototype.otherCallFulfilled = function(S) {
        m(this.promise, this.onFulfilled, S);
      }, f.prototype.callRejected = function(S) {
        c.reject(this.promise, S);
      }, f.prototype.otherCallRejected = function(S) {
        m(this.promise, this.onRejected, S);
      }, c.resolve = function(S, b) {
        var x = v(_, b);
        if (x.status === "error") return c.reject(S, x.value);
        var M = x.value;
        if (M) g(S, M);
        else {
          S.state = h, S.outcome = b;
          for (var C = -1, E = S.queue.length; ++C < E; ) S.queue[C].callFulfilled(b);
        }
        return S;
      }, c.reject = function(S, b) {
        S.state = u, S.outcome = b;
        for (var x = -1, M = S.queue.length; ++x < M; ) S.queue[x].callRejected(b);
        return S;
      }, p.resolve = function(S) {
        return S instanceof this ? S : c.resolve(new this(l), S);
      }, p.reject = function(S) {
        var b = new this(l);
        return c.reject(b, S);
      }, p.all = function(S) {
        var b = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = S.length, M = !1;
        if (!x) return this.resolve([]);
        for (var C = new Array(x), E = 0, T = -1, w = new this(l); ++T < x; ) A(S[T], T);
        return w;
        function A(O, U) {
          b.resolve(O).then(function(D) {
            C[U] = D, ++E !== x || M || (M = !0, c.resolve(w, C));
          }, function(D) {
            M || (M = !0, c.reject(w, D));
          });
        }
      }, p.race = function(S) {
        var b = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = S.length, M = !1;
        if (!x) return this.resolve([]);
        for (var C = -1, E = new this(l); ++C < x; ) T = S[C], b.resolve(T).then(function(w) {
          M || (M = !0, c.resolve(E, w));
        }, function(w) {
          M || (M = !0, c.reject(E, w));
        });
        var T;
        return E;
      };
    }, { immediate: 36 }], 38: [function(i, s, o) {
      var a = {};
      (0, i("./lib/utils/common").assign)(a, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), s.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, s, o) {
      var a = i("./zlib/deflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/messages"), h = i("./zlib/zstream"), d = Object.prototype.toString, p = 0, f = -1, m = 0, _ = 8;
      function g(S) {
        if (!(this instanceof g)) return new g(S);
        this.options = l.assign({ level: f, method: _, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, S || {});
        var b = this.options;
        b.raw && 0 < b.windowBits ? b.windowBits = -b.windowBits : b.gzip && 0 < b.windowBits && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var x = a.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
        if (x !== p) throw new Error(u[x]);
        if (b.header && a.deflateSetHeader(this.strm, b.header), b.dictionary) {
          var M;
          if (M = typeof b.dictionary == "string" ? c.string2buf(b.dictionary) : d.call(b.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(b.dictionary) : b.dictionary, (x = a.deflateSetDictionary(this.strm, M)) !== p) throw new Error(u[x]);
          this._dict_set = !0;
        }
      }
      function v(S, b) {
        var x = new g(b);
        if (x.push(S, !0), x.err) throw x.msg || u[x.err];
        return x.result;
      }
      g.prototype.push = function(S, b) {
        var x, M, C = this.strm, E = this.options.chunkSize;
        if (this.ended) return !1;
        M = b === ~~b ? b : b === !0 ? 4 : 0, typeof S == "string" ? C.input = c.string2buf(S) : d.call(S) === "[object ArrayBuffer]" ? C.input = new Uint8Array(S) : C.input = S, C.next_in = 0, C.avail_in = C.input.length;
        do {
          if (C.avail_out === 0 && (C.output = new l.Buf8(E), C.next_out = 0, C.avail_out = E), (x = a.deflate(C, M)) !== 1 && x !== p) return this.onEnd(x), !(this.ended = !0);
          C.avail_out !== 0 && (C.avail_in !== 0 || M !== 4 && M !== 2) || (this.options.to === "string" ? this.onData(c.buf2binstring(l.shrinkBuf(C.output, C.next_out))) : this.onData(l.shrinkBuf(C.output, C.next_out)));
        } while ((0 < C.avail_in || C.avail_out === 0) && x !== 1);
        return M === 4 ? (x = a.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === p) : M !== 2 || (this.onEnd(p), !(C.avail_out = 0));
      }, g.prototype.onData = function(S) {
        this.chunks.push(S);
      }, g.prototype.onEnd = function(S) {
        S === p && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = S, this.msg = this.strm.msg;
      }, o.Deflate = g, o.deflate = v, o.deflateRaw = function(S, b) {
        return (b = b || {}).raw = !0, v(S, b);
      }, o.gzip = function(S, b) {
        return (b = b || {}).gzip = !0, v(S, b);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, s, o) {
      var a = i("./zlib/inflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/constants"), h = i("./zlib/messages"), d = i("./zlib/zstream"), p = i("./zlib/gzheader"), f = Object.prototype.toString;
      function m(g) {
        if (!(this instanceof m)) return new m(g);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var v = this.options;
        v.raw && 0 <= v.windowBits && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(0 <= v.windowBits && v.windowBits < 16) || g && g.windowBits || (v.windowBits += 32), 15 < v.windowBits && v.windowBits < 48 && !(15 & v.windowBits) && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var S = a.inflateInit2(this.strm, v.windowBits);
        if (S !== u.Z_OK) throw new Error(h[S]);
        this.header = new p(), a.inflateGetHeader(this.strm, this.header);
      }
      function _(g, v) {
        var S = new m(v);
        if (S.push(g, !0), S.err) throw S.msg || h[S.err];
        return S.result;
      }
      m.prototype.push = function(g, v) {
        var S, b, x, M, C, E, T = this.strm, w = this.options.chunkSize, A = this.options.dictionary, O = !1;
        if (this.ended) return !1;
        b = v === ~~v ? v : v === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof g == "string" ? T.input = c.binstring2buf(g) : f.call(g) === "[object ArrayBuffer]" ? T.input = new Uint8Array(g) : T.input = g, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new l.Buf8(w), T.next_out = 0, T.avail_out = w), (S = a.inflate(T, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && A && (E = typeof A == "string" ? c.string2buf(A) : f.call(A) === "[object ArrayBuffer]" ? new Uint8Array(A) : A, S = a.inflateSetDictionary(this.strm, E)), S === u.Z_BUF_ERROR && O === !0 && (S = u.Z_OK, O = !1), S !== u.Z_STREAM_END && S !== u.Z_OK) return this.onEnd(S), !(this.ended = !0);
          T.next_out && (T.avail_out !== 0 && S !== u.Z_STREAM_END && (T.avail_in !== 0 || b !== u.Z_FINISH && b !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = c.utf8border(T.output, T.next_out), M = T.next_out - x, C = c.buf2string(T.output, x), T.next_out = M, T.avail_out = w - M, M && l.arraySet(T.output, T.output, x, M, 0), this.onData(C)) : this.onData(l.shrinkBuf(T.output, T.next_out)))), T.avail_in === 0 && T.avail_out === 0 && (O = !0);
        } while ((0 < T.avail_in || T.avail_out === 0) && S !== u.Z_STREAM_END);
        return S === u.Z_STREAM_END && (b = u.Z_FINISH), b === u.Z_FINISH ? (S = a.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === u.Z_OK) : b !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(T.avail_out = 0));
      }, m.prototype.onData = function(g) {
        this.chunks.push(g);
      }, m.prototype.onEnd = function(g) {
        g === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, o.Inflate = m, o.inflate = _, o.inflateRaw = function(g, v) {
        return (v = v || {}).raw = !0, _(g, v);
      }, o.ungzip = _;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, s, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      o.assign = function(u) {
        for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
          var d = h.shift();
          if (d) {
            if (typeof d != "object") throw new TypeError(d + "must be non-object");
            for (var p in d) d.hasOwnProperty(p) && (u[p] = d[p]);
          }
        }
        return u;
      }, o.shrinkBuf = function(u, h) {
        return u.length === h ? u : u.subarray ? u.subarray(0, h) : (u.length = h, u);
      };
      var l = { arraySet: function(u, h, d, p, f) {
        if (h.subarray && u.subarray) u.set(h.subarray(d, d + p), f);
        else for (var m = 0; m < p; m++) u[f + m] = h[d + m];
      }, flattenChunks: function(u) {
        var h, d, p, f, m, _;
        for (h = p = 0, d = u.length; h < d; h++) p += u[h].length;
        for (_ = new Uint8Array(p), h = f = 0, d = u.length; h < d; h++) m = u[h], _.set(m, f), f += m.length;
        return _;
      } }, c = { arraySet: function(u, h, d, p, f) {
        for (var m = 0; m < p; m++) u[f + m] = h[d + m];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      o.setTyped = function(u) {
        u ? (o.Buf8 = Uint8Array, o.Buf16 = Uint16Array, o.Buf32 = Int32Array, o.assign(o, l)) : (o.Buf8 = Array, o.Buf16 = Array, o.Buf32 = Array, o.assign(o, c));
      }, o.setTyped(a);
    }, {}], 42: [function(i, s, o) {
      var a = i("./common"), l = !0, c = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        c = !1;
      }
      for (var u = new a.Buf8(256), h = 0; h < 256; h++) u[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      function d(p, f) {
        if (f < 65537 && (p.subarray && c || !p.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(p, f));
        for (var m = "", _ = 0; _ < f; _++) m += String.fromCharCode(p[_]);
        return m;
      }
      u[254] = u[254] = 1, o.string2buf = function(p) {
        var f, m, _, g, v, S = p.length, b = 0;
        for (g = 0; g < S; g++) (64512 & (m = p.charCodeAt(g))) == 55296 && g + 1 < S && (64512 & (_ = p.charCodeAt(g + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (_ - 56320), g++), b += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (f = new a.Buf8(b), g = v = 0; v < b; g++) (64512 & (m = p.charCodeAt(g))) == 55296 && g + 1 < S && (64512 & (_ = p.charCodeAt(g + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (_ - 56320), g++), m < 128 ? f[v++] = m : (m < 2048 ? f[v++] = 192 | m >>> 6 : (m < 65536 ? f[v++] = 224 | m >>> 12 : (f[v++] = 240 | m >>> 18, f[v++] = 128 | m >>> 12 & 63), f[v++] = 128 | m >>> 6 & 63), f[v++] = 128 | 63 & m);
        return f;
      }, o.buf2binstring = function(p) {
        return d(p, p.length);
      }, o.binstring2buf = function(p) {
        for (var f = new a.Buf8(p.length), m = 0, _ = f.length; m < _; m++) f[m] = p.charCodeAt(m);
        return f;
      }, o.buf2string = function(p, f) {
        var m, _, g, v, S = f || p.length, b = new Array(2 * S);
        for (m = _ = 0; m < S; ) if ((g = p[m++]) < 128) b[_++] = g;
        else if (4 < (v = u[g])) b[_++] = 65533, m += v - 1;
        else {
          for (g &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && m < S; ) g = g << 6 | 63 & p[m++], v--;
          1 < v ? b[_++] = 65533 : g < 65536 ? b[_++] = g : (g -= 65536, b[_++] = 55296 | g >> 10 & 1023, b[_++] = 56320 | 1023 & g);
        }
        return d(b, _);
      }, o.utf8border = function(p, f) {
        var m;
        for ((f = f || p.length) > p.length && (f = p.length), m = f - 1; 0 <= m && (192 & p[m]) == 128; ) m--;
        return m < 0 || m === 0 ? f : m + u[p[m]] > f ? m : f;
      };
    }, { "./common": 41 }], 43: [function(i, s, o) {
      s.exports = function(a, l, c, u) {
        for (var h = 65535 & a | 0, d = a >>> 16 & 65535 | 0, p = 0; c !== 0; ) {
          for (c -= p = 2e3 < c ? 2e3 : c; d = d + (h = h + l[u++] | 0) | 0, --p; ) ;
          h %= 65521, d %= 65521;
        }
        return h | d << 16 | 0;
      };
    }, {}], 44: [function(i, s, o) {
      s.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(i, s, o) {
      var a = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var h = 0; h < 8; h++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      s.exports = function(l, c, u, h) {
        var d = a, p = h + u;
        l ^= -1;
        for (var f = h; f < p; f++) l = l >>> 8 ^ d[255 & (l ^ c[f])];
        return -1 ^ l;
      };
    }, {}], 46: [function(i, s, o) {
      var a, l = i("../utils/common"), c = i("./trees"), u = i("./adler32"), h = i("./crc32"), d = i("./messages"), p = 0, f = 4, m = 0, _ = -2, g = -1, v = 4, S = 2, b = 8, x = 9, M = 286, C = 30, E = 19, T = 2 * M + 1, w = 15, A = 3, O = 258, U = O + A + 1, D = 42, L = 113, P = 1, V = 2, ce = 3, q = 4;
      function oe(k, ee) {
        return k.msg = d[ee], ee;
      }
      function ne(k) {
        return (k << 1) - (4 < k ? 9 : 0);
      }
      function $(k) {
        for (var ee = k.length; 0 <= --ee; ) k[ee] = 0;
      }
      function J(k) {
        var ee = k.state, Z = ee.pending;
        Z > k.avail_out && (Z = k.avail_out), Z !== 0 && (l.arraySet(k.output, ee.pending_buf, ee.pending_out, Z, k.next_out), k.next_out += Z, ee.pending_out += Z, k.total_out += Z, k.avail_out -= Z, ee.pending -= Z, ee.pending === 0 && (ee.pending_out = 0));
      }
      function se(k, ee) {
        c._tr_flush_block(k, 0 <= k.block_start ? k.block_start : -1, k.strstart - k.block_start, ee), k.block_start = k.strstart, J(k.strm);
      }
      function le(k, ee) {
        k.pending_buf[k.pending++] = ee;
      }
      function re(k, ee) {
        k.pending_buf[k.pending++] = ee >>> 8 & 255, k.pending_buf[k.pending++] = 255 & ee;
      }
      function ye(k, ee) {
        var Z, N, j = k.max_chain_length, te = k.strstart, F = k.prev_length, B = k.nice_match, Y = k.strstart > k.w_size - U ? k.strstart - (k.w_size - U) : 0, fe = k.window, ge = k.w_mask, xe = k.prev, De = k.strstart + O, ae = fe[te + F - 1], de = fe[te + F];
        k.prev_length >= k.good_match && (j >>= 2), B > k.lookahead && (B = k.lookahead);
        do
          if (fe[(Z = ee) + F] === de && fe[Z + F - 1] === ae && fe[Z] === fe[te] && fe[++Z] === fe[te + 1]) {
            te += 2, Z++;
            do
              ;
            while (fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && fe[++te] === fe[++Z] && te < De);
            if (N = O - (De - te), te = De - O, F < N) {
              if (k.match_start = ee, B <= (F = N)) break;
              ae = fe[te + F - 1], de = fe[te + F];
            }
          }
        while ((ee = xe[ee & ge]) > Y && --j != 0);
        return F <= k.lookahead ? F : k.lookahead;
      }
      function H(k) {
        var ee, Z, N, j, te, F, B, Y, fe, ge, xe = k.w_size;
        do {
          if (j = k.window_size - k.lookahead - k.strstart, k.strstart >= xe + (xe - U)) {
            for (l.arraySet(k.window, k.window, xe, xe, 0), k.match_start -= xe, k.strstart -= xe, k.block_start -= xe, ee = Z = k.hash_size; N = k.head[--ee], k.head[ee] = xe <= N ? N - xe : 0, --Z; ) ;
            for (ee = Z = xe; N = k.prev[--ee], k.prev[ee] = xe <= N ? N - xe : 0, --Z; ) ;
            j += xe;
          }
          if (k.strm.avail_in === 0) break;
          if (F = k.strm, B = k.window, Y = k.strstart + k.lookahead, fe = j, ge = void 0, ge = F.avail_in, fe < ge && (ge = fe), Z = ge === 0 ? 0 : (F.avail_in -= ge, l.arraySet(B, F.input, F.next_in, ge, Y), F.state.wrap === 1 ? F.adler = u(F.adler, B, ge, Y) : F.state.wrap === 2 && (F.adler = h(F.adler, B, ge, Y)), F.next_in += ge, F.total_in += ge, ge), k.lookahead += Z, k.lookahead + k.insert >= A) for (te = k.strstart - k.insert, k.ins_h = k.window[te], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[te + 1]) & k.hash_mask; k.insert && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[te + A - 1]) & k.hash_mask, k.prev[te & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = te, te++, k.insert--, !(k.lookahead + k.insert < A)); ) ;
        } while (k.lookahead < U && k.strm.avail_in !== 0);
      }
      function K(k, ee) {
        for (var Z, N; ; ) {
          if (k.lookahead < U) {
            if (H(k), k.lookahead < U && ee === p) return P;
            if (k.lookahead === 0) break;
          }
          if (Z = 0, k.lookahead >= A && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + A - 1]) & k.hash_mask, Z = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), Z !== 0 && k.strstart - Z <= k.w_size - U && (k.match_length = ye(k, Z)), k.match_length >= A) if (N = c._tr_tally(k, k.strstart - k.match_start, k.match_length - A), k.lookahead -= k.match_length, k.match_length <= k.max_lazy_match && k.lookahead >= A) {
            for (k.match_length--; k.strstart++, k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + A - 1]) & k.hash_mask, Z = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart, --k.match_length != 0; ) ;
            k.strstart++;
          } else k.strstart += k.match_length, k.match_length = 0, k.ins_h = k.window[k.strstart], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + 1]) & k.hash_mask;
          else N = c._tr_tally(k, 0, k.window[k.strstart]), k.lookahead--, k.strstart++;
          if (N && (se(k, !1), k.strm.avail_out === 0)) return P;
        }
        return k.insert = k.strstart < A - 1 ? k.strstart : A - 1, ee === f ? (se(k, !0), k.strm.avail_out === 0 ? ce : q) : k.last_lit && (se(k, !1), k.strm.avail_out === 0) ? P : V;
      }
      function G(k, ee) {
        for (var Z, N, j; ; ) {
          if (k.lookahead < U) {
            if (H(k), k.lookahead < U && ee === p) return P;
            if (k.lookahead === 0) break;
          }
          if (Z = 0, k.lookahead >= A && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + A - 1]) & k.hash_mask, Z = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), k.prev_length = k.match_length, k.prev_match = k.match_start, k.match_length = A - 1, Z !== 0 && k.prev_length < k.max_lazy_match && k.strstart - Z <= k.w_size - U && (k.match_length = ye(k, Z), k.match_length <= 5 && (k.strategy === 1 || k.match_length === A && 4096 < k.strstart - k.match_start) && (k.match_length = A - 1)), k.prev_length >= A && k.match_length <= k.prev_length) {
            for (j = k.strstart + k.lookahead - A, N = c._tr_tally(k, k.strstart - 1 - k.prev_match, k.prev_length - A), k.lookahead -= k.prev_length - 1, k.prev_length -= 2; ++k.strstart <= j && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + A - 1]) & k.hash_mask, Z = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), --k.prev_length != 0; ) ;
            if (k.match_available = 0, k.match_length = A - 1, k.strstart++, N && (se(k, !1), k.strm.avail_out === 0)) return P;
          } else if (k.match_available) {
            if ((N = c._tr_tally(k, 0, k.window[k.strstart - 1])) && se(k, !1), k.strstart++, k.lookahead--, k.strm.avail_out === 0) return P;
          } else k.match_available = 1, k.strstart++, k.lookahead--;
        }
        return k.match_available && (N = c._tr_tally(k, 0, k.window[k.strstart - 1]), k.match_available = 0), k.insert = k.strstart < A - 1 ? k.strstart : A - 1, ee === f ? (se(k, !0), k.strm.avail_out === 0 ? ce : q) : k.last_lit && (se(k, !1), k.strm.avail_out === 0) ? P : V;
      }
      function R(k, ee, Z, N, j) {
        this.good_length = k, this.max_lazy = ee, this.nice_length = Z, this.max_chain = N, this.func = j;
      }
      function z() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = b, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * T), this.dyn_dtree = new l.Buf16(2 * (2 * C + 1)), this.bl_tree = new l.Buf16(2 * (2 * E + 1)), $(this.dyn_ltree), $(this.dyn_dtree), $(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(w + 1), this.heap = new l.Buf16(2 * M + 1), $(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * M + 1), $(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function I(k) {
        var ee;
        return k && k.state ? (k.total_in = k.total_out = 0, k.data_type = S, (ee = k.state).pending = 0, ee.pending_out = 0, ee.wrap < 0 && (ee.wrap = -ee.wrap), ee.status = ee.wrap ? D : L, k.adler = ee.wrap === 2 ? 0 : 1, ee.last_flush = p, c._tr_init(ee), m) : oe(k, _);
      }
      function Q(k) {
        var ee = I(k);
        return ee === m && function(Z) {
          Z.window_size = 2 * Z.w_size, $(Z.head), Z.max_lazy_match = a[Z.level].max_lazy, Z.good_match = a[Z.level].good_length, Z.nice_match = a[Z.level].nice_length, Z.max_chain_length = a[Z.level].max_chain, Z.strstart = 0, Z.block_start = 0, Z.lookahead = 0, Z.insert = 0, Z.match_length = Z.prev_length = A - 1, Z.match_available = 0, Z.ins_h = 0;
        }(k.state), ee;
      }
      function X(k, ee, Z, N, j, te) {
        if (!k) return _;
        var F = 1;
        if (ee === g && (ee = 6), N < 0 ? (F = 0, N = -N) : 15 < N && (F = 2, N -= 16), j < 1 || x < j || Z !== b || N < 8 || 15 < N || ee < 0 || 9 < ee || te < 0 || v < te) return oe(k, _);
        N === 8 && (N = 9);
        var B = new z();
        return (k.state = B).strm = k, B.wrap = F, B.gzhead = null, B.w_bits = N, B.w_size = 1 << B.w_bits, B.w_mask = B.w_size - 1, B.hash_bits = j + 7, B.hash_size = 1 << B.hash_bits, B.hash_mask = B.hash_size - 1, B.hash_shift = ~~((B.hash_bits + A - 1) / A), B.window = new l.Buf8(2 * B.w_size), B.head = new l.Buf16(B.hash_size), B.prev = new l.Buf16(B.w_size), B.lit_bufsize = 1 << j + 6, B.pending_buf_size = 4 * B.lit_bufsize, B.pending_buf = new l.Buf8(B.pending_buf_size), B.d_buf = 1 * B.lit_bufsize, B.l_buf = 3 * B.lit_bufsize, B.level = ee, B.strategy = te, B.method = Z, Q(k);
      }
      a = [new R(0, 0, 0, 0, function(k, ee) {
        var Z = 65535;
        for (Z > k.pending_buf_size - 5 && (Z = k.pending_buf_size - 5); ; ) {
          if (k.lookahead <= 1) {
            if (H(k), k.lookahead === 0 && ee === p) return P;
            if (k.lookahead === 0) break;
          }
          k.strstart += k.lookahead, k.lookahead = 0;
          var N = k.block_start + Z;
          if ((k.strstart === 0 || k.strstart >= N) && (k.lookahead = k.strstart - N, k.strstart = N, se(k, !1), k.strm.avail_out === 0) || k.strstart - k.block_start >= k.w_size - U && (se(k, !1), k.strm.avail_out === 0)) return P;
        }
        return k.insert = 0, ee === f ? (se(k, !0), k.strm.avail_out === 0 ? ce : q) : (k.strstart > k.block_start && (se(k, !1), k.strm.avail_out), P);
      }), new R(4, 4, 8, 4, K), new R(4, 5, 16, 8, K), new R(4, 6, 32, 32, K), new R(4, 4, 16, 16, G), new R(8, 16, 32, 32, G), new R(8, 16, 128, 128, G), new R(8, 32, 128, 256, G), new R(32, 128, 258, 1024, G), new R(32, 258, 258, 4096, G)], o.deflateInit = function(k, ee) {
        return X(k, ee, b, 15, 8, 0);
      }, o.deflateInit2 = X, o.deflateReset = Q, o.deflateResetKeep = I, o.deflateSetHeader = function(k, ee) {
        return k && k.state ? k.state.wrap !== 2 ? _ : (k.state.gzhead = ee, m) : _;
      }, o.deflate = function(k, ee) {
        var Z, N, j, te;
        if (!k || !k.state || 5 < ee || ee < 0) return k ? oe(k, _) : _;
        if (N = k.state, !k.output || !k.input && k.avail_in !== 0 || N.status === 666 && ee !== f) return oe(k, k.avail_out === 0 ? -5 : _);
        if (N.strm = k, Z = N.last_flush, N.last_flush = ee, N.status === D) if (N.wrap === 2) k.adler = 0, le(N, 31), le(N, 139), le(N, 8), N.gzhead ? (le(N, (N.gzhead.text ? 1 : 0) + (N.gzhead.hcrc ? 2 : 0) + (N.gzhead.extra ? 4 : 0) + (N.gzhead.name ? 8 : 0) + (N.gzhead.comment ? 16 : 0)), le(N, 255 & N.gzhead.time), le(N, N.gzhead.time >> 8 & 255), le(N, N.gzhead.time >> 16 & 255), le(N, N.gzhead.time >> 24 & 255), le(N, N.level === 9 ? 2 : 2 <= N.strategy || N.level < 2 ? 4 : 0), le(N, 255 & N.gzhead.os), N.gzhead.extra && N.gzhead.extra.length && (le(N, 255 & N.gzhead.extra.length), le(N, N.gzhead.extra.length >> 8 & 255)), N.gzhead.hcrc && (k.adler = h(k.adler, N.pending_buf, N.pending, 0)), N.gzindex = 0, N.status = 69) : (le(N, 0), le(N, 0), le(N, 0), le(N, 0), le(N, 0), le(N, N.level === 9 ? 2 : 2 <= N.strategy || N.level < 2 ? 4 : 0), le(N, 3), N.status = L);
        else {
          var F = b + (N.w_bits - 8 << 4) << 8;
          F |= (2 <= N.strategy || N.level < 2 ? 0 : N.level < 6 ? 1 : N.level === 6 ? 2 : 3) << 6, N.strstart !== 0 && (F |= 32), F += 31 - F % 31, N.status = L, re(N, F), N.strstart !== 0 && (re(N, k.adler >>> 16), re(N, 65535 & k.adler)), k.adler = 1;
        }
        if (N.status === 69) if (N.gzhead.extra) {
          for (j = N.pending; N.gzindex < (65535 & N.gzhead.extra.length) && (N.pending !== N.pending_buf_size || (N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), J(k), j = N.pending, N.pending !== N.pending_buf_size)); ) le(N, 255 & N.gzhead.extra[N.gzindex]), N.gzindex++;
          N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), N.gzindex === N.gzhead.extra.length && (N.gzindex = 0, N.status = 73);
        } else N.status = 73;
        if (N.status === 73) if (N.gzhead.name) {
          j = N.pending;
          do {
            if (N.pending === N.pending_buf_size && (N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), J(k), j = N.pending, N.pending === N.pending_buf_size)) {
              te = 1;
              break;
            }
            te = N.gzindex < N.gzhead.name.length ? 255 & N.gzhead.name.charCodeAt(N.gzindex++) : 0, le(N, te);
          } while (te !== 0);
          N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), te === 0 && (N.gzindex = 0, N.status = 91);
        } else N.status = 91;
        if (N.status === 91) if (N.gzhead.comment) {
          j = N.pending;
          do {
            if (N.pending === N.pending_buf_size && (N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), J(k), j = N.pending, N.pending === N.pending_buf_size)) {
              te = 1;
              break;
            }
            te = N.gzindex < N.gzhead.comment.length ? 255 & N.gzhead.comment.charCodeAt(N.gzindex++) : 0, le(N, te);
          } while (te !== 0);
          N.gzhead.hcrc && N.pending > j && (k.adler = h(k.adler, N.pending_buf, N.pending - j, j)), te === 0 && (N.status = 103);
        } else N.status = 103;
        if (N.status === 103 && (N.gzhead.hcrc ? (N.pending + 2 > N.pending_buf_size && J(k), N.pending + 2 <= N.pending_buf_size && (le(N, 255 & k.adler), le(N, k.adler >> 8 & 255), k.adler = 0, N.status = L)) : N.status = L), N.pending !== 0) {
          if (J(k), k.avail_out === 0) return N.last_flush = -1, m;
        } else if (k.avail_in === 0 && ne(ee) <= ne(Z) && ee !== f) return oe(k, -5);
        if (N.status === 666 && k.avail_in !== 0) return oe(k, -5);
        if (k.avail_in !== 0 || N.lookahead !== 0 || ee !== p && N.status !== 666) {
          var B = N.strategy === 2 ? function(Y, fe) {
            for (var ge; ; ) {
              if (Y.lookahead === 0 && (H(Y), Y.lookahead === 0)) {
                if (fe === p) return P;
                break;
              }
              if (Y.match_length = 0, ge = c._tr_tally(Y, 0, Y.window[Y.strstart]), Y.lookahead--, Y.strstart++, ge && (se(Y, !1), Y.strm.avail_out === 0)) return P;
            }
            return Y.insert = 0, fe === f ? (se(Y, !0), Y.strm.avail_out === 0 ? ce : q) : Y.last_lit && (se(Y, !1), Y.strm.avail_out === 0) ? P : V;
          }(N, ee) : N.strategy === 3 ? function(Y, fe) {
            for (var ge, xe, De, ae, de = Y.window; ; ) {
              if (Y.lookahead <= O) {
                if (H(Y), Y.lookahead <= O && fe === p) return P;
                if (Y.lookahead === 0) break;
              }
              if (Y.match_length = 0, Y.lookahead >= A && 0 < Y.strstart && (xe = de[De = Y.strstart - 1]) === de[++De] && xe === de[++De] && xe === de[++De]) {
                ae = Y.strstart + O;
                do
                  ;
                while (xe === de[++De] && xe === de[++De] && xe === de[++De] && xe === de[++De] && xe === de[++De] && xe === de[++De] && xe === de[++De] && xe === de[++De] && De < ae);
                Y.match_length = O - (ae - De), Y.match_length > Y.lookahead && (Y.match_length = Y.lookahead);
              }
              if (Y.match_length >= A ? (ge = c._tr_tally(Y, 1, Y.match_length - A), Y.lookahead -= Y.match_length, Y.strstart += Y.match_length, Y.match_length = 0) : (ge = c._tr_tally(Y, 0, Y.window[Y.strstart]), Y.lookahead--, Y.strstart++), ge && (se(Y, !1), Y.strm.avail_out === 0)) return P;
            }
            return Y.insert = 0, fe === f ? (se(Y, !0), Y.strm.avail_out === 0 ? ce : q) : Y.last_lit && (se(Y, !1), Y.strm.avail_out === 0) ? P : V;
          }(N, ee) : a[N.level].func(N, ee);
          if (B !== ce && B !== q || (N.status = 666), B === P || B === ce) return k.avail_out === 0 && (N.last_flush = -1), m;
          if (B === V && (ee === 1 ? c._tr_align(N) : ee !== 5 && (c._tr_stored_block(N, 0, 0, !1), ee === 3 && ($(N.head), N.lookahead === 0 && (N.strstart = 0, N.block_start = 0, N.insert = 0))), J(k), k.avail_out === 0)) return N.last_flush = -1, m;
        }
        return ee !== f ? m : N.wrap <= 0 ? 1 : (N.wrap === 2 ? (le(N, 255 & k.adler), le(N, k.adler >> 8 & 255), le(N, k.adler >> 16 & 255), le(N, k.adler >> 24 & 255), le(N, 255 & k.total_in), le(N, k.total_in >> 8 & 255), le(N, k.total_in >> 16 & 255), le(N, k.total_in >> 24 & 255)) : (re(N, k.adler >>> 16), re(N, 65535 & k.adler)), J(k), 0 < N.wrap && (N.wrap = -N.wrap), N.pending !== 0 ? m : 1);
      }, o.deflateEnd = function(k) {
        var ee;
        return k && k.state ? (ee = k.state.status) !== D && ee !== 69 && ee !== 73 && ee !== 91 && ee !== 103 && ee !== L && ee !== 666 ? oe(k, _) : (k.state = null, ee === L ? oe(k, -3) : m) : _;
      }, o.deflateSetDictionary = function(k, ee) {
        var Z, N, j, te, F, B, Y, fe, ge = ee.length;
        if (!k || !k.state || (te = (Z = k.state).wrap) === 2 || te === 1 && Z.status !== D || Z.lookahead) return _;
        for (te === 1 && (k.adler = u(k.adler, ee, ge, 0)), Z.wrap = 0, ge >= Z.w_size && (te === 0 && ($(Z.head), Z.strstart = 0, Z.block_start = 0, Z.insert = 0), fe = new l.Buf8(Z.w_size), l.arraySet(fe, ee, ge - Z.w_size, Z.w_size, 0), ee = fe, ge = Z.w_size), F = k.avail_in, B = k.next_in, Y = k.input, k.avail_in = ge, k.next_in = 0, k.input = ee, H(Z); Z.lookahead >= A; ) {
          for (N = Z.strstart, j = Z.lookahead - (A - 1); Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[N + A - 1]) & Z.hash_mask, Z.prev[N & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = N, N++, --j; ) ;
          Z.strstart = N, Z.lookahead = A - 1, H(Z);
        }
        return Z.strstart += Z.lookahead, Z.block_start = Z.strstart, Z.insert = Z.lookahead, Z.lookahead = 0, Z.match_length = Z.prev_length = A - 1, Z.match_available = 0, k.next_in = B, k.input = Y, k.avail_in = F, Z.wrap = te, m;
      }, o.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, s, o) {
      s.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(i, s, o) {
      s.exports = function(a, l) {
        var c, u, h, d, p, f, m, _, g, v, S, b, x, M, C, E, T, w, A, O, U, D, L, P, V;
        c = a.state, u = a.next_in, P = a.input, h = u + (a.avail_in - 5), d = a.next_out, V = a.output, p = d - (l - a.avail_out), f = d + (a.avail_out - 257), m = c.dmax, _ = c.wsize, g = c.whave, v = c.wnext, S = c.window, b = c.hold, x = c.bits, M = c.lencode, C = c.distcode, E = (1 << c.lenbits) - 1, T = (1 << c.distbits) - 1;
        e: do {
          x < 15 && (b += P[u++] << x, x += 8, b += P[u++] << x, x += 8), w = M[b & E];
          t: for (; ; ) {
            if (b >>>= A = w >>> 24, x -= A, (A = w >>> 16 & 255) === 0) V[d++] = 65535 & w;
            else {
              if (!(16 & A)) {
                if (!(64 & A)) {
                  w = M[(65535 & w) + (b & (1 << A) - 1)];
                  continue t;
                }
                if (32 & A) {
                  c.mode = 12;
                  break e;
                }
                a.msg = "invalid literal/length code", c.mode = 30;
                break e;
              }
              O = 65535 & w, (A &= 15) && (x < A && (b += P[u++] << x, x += 8), O += b & (1 << A) - 1, b >>>= A, x -= A), x < 15 && (b += P[u++] << x, x += 8, b += P[u++] << x, x += 8), w = C[b & T];
              n: for (; ; ) {
                if (b >>>= A = w >>> 24, x -= A, !(16 & (A = w >>> 16 & 255))) {
                  if (!(64 & A)) {
                    w = C[(65535 & w) + (b & (1 << A) - 1)];
                    continue n;
                  }
                  a.msg = "invalid distance code", c.mode = 30;
                  break e;
                }
                if (U = 65535 & w, x < (A &= 15) && (b += P[u++] << x, (x += 8) < A && (b += P[u++] << x, x += 8)), m < (U += b & (1 << A) - 1)) {
                  a.msg = "invalid distance too far back", c.mode = 30;
                  break e;
                }
                if (b >>>= A, x -= A, (A = d - p) < U) {
                  if (g < (A = U - A) && c.sane) {
                    a.msg = "invalid distance too far back", c.mode = 30;
                    break e;
                  }
                  if (L = S, (D = 0) === v) {
                    if (D += _ - A, A < O) {
                      for (O -= A; V[d++] = S[D++], --A; ) ;
                      D = d - U, L = V;
                    }
                  } else if (v < A) {
                    if (D += _ + v - A, (A -= v) < O) {
                      for (O -= A; V[d++] = S[D++], --A; ) ;
                      if (D = 0, v < O) {
                        for (O -= A = v; V[d++] = S[D++], --A; ) ;
                        D = d - U, L = V;
                      }
                    }
                  } else if (D += v - A, A < O) {
                    for (O -= A; V[d++] = S[D++], --A; ) ;
                    D = d - U, L = V;
                  }
                  for (; 2 < O; ) V[d++] = L[D++], V[d++] = L[D++], V[d++] = L[D++], O -= 3;
                  O && (V[d++] = L[D++], 1 < O && (V[d++] = L[D++]));
                } else {
                  for (D = d - U; V[d++] = V[D++], V[d++] = V[D++], V[d++] = V[D++], 2 < (O -= 3); ) ;
                  O && (V[d++] = V[D++], 1 < O && (V[d++] = V[D++]));
                }
                break;
              }
            }
            break;
          }
        } while (u < h && d < f);
        u -= O = x >> 3, b &= (1 << (x -= O << 3)) - 1, a.next_in = u, a.next_out = d, a.avail_in = u < h ? h - u + 5 : 5 - (u - h), a.avail_out = d < f ? f - d + 257 : 257 - (d - f), c.hold = b, c.bits = x;
      };
    }, {}], 49: [function(i, s, o) {
      var a = i("../utils/common"), l = i("./adler32"), c = i("./crc32"), u = i("./inffast"), h = i("./inftrees"), d = 1, p = 2, f = 0, m = -2, _ = 1, g = 852, v = 592;
      function S(D) {
        return (D >>> 24 & 255) + (D >>> 8 & 65280) + ((65280 & D) << 8) + ((255 & D) << 24);
      }
      function b() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(D) {
        var L;
        return D && D.state ? (L = D.state, D.total_in = D.total_out = L.total = 0, D.msg = "", L.wrap && (D.adler = 1 & L.wrap), L.mode = _, L.last = 0, L.havedict = 0, L.dmax = 32768, L.head = null, L.hold = 0, L.bits = 0, L.lencode = L.lendyn = new a.Buf32(g), L.distcode = L.distdyn = new a.Buf32(v), L.sane = 1, L.back = -1, f) : m;
      }
      function M(D) {
        var L;
        return D && D.state ? ((L = D.state).wsize = 0, L.whave = 0, L.wnext = 0, x(D)) : m;
      }
      function C(D, L) {
        var P, V;
        return D && D.state ? (V = D.state, L < 0 ? (P = 0, L = -L) : (P = 1 + (L >> 4), L < 48 && (L &= 15)), L && (L < 8 || 15 < L) ? m : (V.window !== null && V.wbits !== L && (V.window = null), V.wrap = P, V.wbits = L, M(D))) : m;
      }
      function E(D, L) {
        var P, V;
        return D ? (V = new b(), (D.state = V).window = null, (P = C(D, L)) !== f && (D.state = null), P) : m;
      }
      var T, w, A = !0;
      function O(D) {
        if (A) {
          var L;
          for (T = new a.Buf32(512), w = new a.Buf32(32), L = 0; L < 144; ) D.lens[L++] = 8;
          for (; L < 256; ) D.lens[L++] = 9;
          for (; L < 280; ) D.lens[L++] = 7;
          for (; L < 288; ) D.lens[L++] = 8;
          for (h(d, D.lens, 0, 288, T, 0, D.work, { bits: 9 }), L = 0; L < 32; ) D.lens[L++] = 5;
          h(p, D.lens, 0, 32, w, 0, D.work, { bits: 5 }), A = !1;
        }
        D.lencode = T, D.lenbits = 9, D.distcode = w, D.distbits = 5;
      }
      function U(D, L, P, V) {
        var ce, q = D.state;
        return q.window === null && (q.wsize = 1 << q.wbits, q.wnext = 0, q.whave = 0, q.window = new a.Buf8(q.wsize)), V >= q.wsize ? (a.arraySet(q.window, L, P - q.wsize, q.wsize, 0), q.wnext = 0, q.whave = q.wsize) : (V < (ce = q.wsize - q.wnext) && (ce = V), a.arraySet(q.window, L, P - V, ce, q.wnext), (V -= ce) ? (a.arraySet(q.window, L, P - V, V, 0), q.wnext = V, q.whave = q.wsize) : (q.wnext += ce, q.wnext === q.wsize && (q.wnext = 0), q.whave < q.wsize && (q.whave += ce))), 0;
      }
      o.inflateReset = M, o.inflateReset2 = C, o.inflateResetKeep = x, o.inflateInit = function(D) {
        return E(D, 15);
      }, o.inflateInit2 = E, o.inflate = function(D, L) {
        var P, V, ce, q, oe, ne, $, J, se, le, re, ye, H, K, G, R, z, I, Q, X, k, ee, Z, N, j = 0, te = new a.Buf8(4), F = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!D || !D.state || !D.output || !D.input && D.avail_in !== 0) return m;
        (P = D.state).mode === 12 && (P.mode = 13), oe = D.next_out, ce = D.output, $ = D.avail_out, q = D.next_in, V = D.input, ne = D.avail_in, J = P.hold, se = P.bits, le = ne, re = $, ee = f;
        e: for (; ; ) switch (P.mode) {
          case _:
            if (P.wrap === 0) {
              P.mode = 13;
              break;
            }
            for (; se < 16; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if (2 & P.wrap && J === 35615) {
              te[P.check = 0] = 255 & J, te[1] = J >>> 8 & 255, P.check = c(P.check, te, 2, 0), se = J = 0, P.mode = 2;
              break;
            }
            if (P.flags = 0, P.head && (P.head.done = !1), !(1 & P.wrap) || (((255 & J) << 8) + (J >> 8)) % 31) {
              D.msg = "incorrect header check", P.mode = 30;
              break;
            }
            if ((15 & J) != 8) {
              D.msg = "unknown compression method", P.mode = 30;
              break;
            }
            if (se -= 4, k = 8 + (15 & (J >>>= 4)), P.wbits === 0) P.wbits = k;
            else if (k > P.wbits) {
              D.msg = "invalid window size", P.mode = 30;
              break;
            }
            P.dmax = 1 << k, D.adler = P.check = 1, P.mode = 512 & J ? 10 : 12, se = J = 0;
            break;
          case 2:
            for (; se < 16; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if (P.flags = J, (255 & P.flags) != 8) {
              D.msg = "unknown compression method", P.mode = 30;
              break;
            }
            if (57344 & P.flags) {
              D.msg = "unknown header flags set", P.mode = 30;
              break;
            }
            P.head && (P.head.text = J >> 8 & 1), 512 & P.flags && (te[0] = 255 & J, te[1] = J >>> 8 & 255, P.check = c(P.check, te, 2, 0)), se = J = 0, P.mode = 3;
          case 3:
            for (; se < 32; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            P.head && (P.head.time = J), 512 & P.flags && (te[0] = 255 & J, te[1] = J >>> 8 & 255, te[2] = J >>> 16 & 255, te[3] = J >>> 24 & 255, P.check = c(P.check, te, 4, 0)), se = J = 0, P.mode = 4;
          case 4:
            for (; se < 16; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            P.head && (P.head.xflags = 255 & J, P.head.os = J >> 8), 512 & P.flags && (te[0] = 255 & J, te[1] = J >>> 8 & 255, P.check = c(P.check, te, 2, 0)), se = J = 0, P.mode = 5;
          case 5:
            if (1024 & P.flags) {
              for (; se < 16; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              P.length = J, P.head && (P.head.extra_len = J), 512 & P.flags && (te[0] = 255 & J, te[1] = J >>> 8 & 255, P.check = c(P.check, te, 2, 0)), se = J = 0;
            } else P.head && (P.head.extra = null);
            P.mode = 6;
          case 6:
            if (1024 & P.flags && (ne < (ye = P.length) && (ye = ne), ye && (P.head && (k = P.head.extra_len - P.length, P.head.extra || (P.head.extra = new Array(P.head.extra_len)), a.arraySet(P.head.extra, V, q, ye, k)), 512 & P.flags && (P.check = c(P.check, V, ye, q)), ne -= ye, q += ye, P.length -= ye), P.length)) break e;
            P.length = 0, P.mode = 7;
          case 7:
            if (2048 & P.flags) {
              if (ne === 0) break e;
              for (ye = 0; k = V[q + ye++], P.head && k && P.length < 65536 && (P.head.name += String.fromCharCode(k)), k && ye < ne; ) ;
              if (512 & P.flags && (P.check = c(P.check, V, ye, q)), ne -= ye, q += ye, k) break e;
            } else P.head && (P.head.name = null);
            P.length = 0, P.mode = 8;
          case 8:
            if (4096 & P.flags) {
              if (ne === 0) break e;
              for (ye = 0; k = V[q + ye++], P.head && k && P.length < 65536 && (P.head.comment += String.fromCharCode(k)), k && ye < ne; ) ;
              if (512 & P.flags && (P.check = c(P.check, V, ye, q)), ne -= ye, q += ye, k) break e;
            } else P.head && (P.head.comment = null);
            P.mode = 9;
          case 9:
            if (512 & P.flags) {
              for (; se < 16; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              if (J !== (65535 & P.check)) {
                D.msg = "header crc mismatch", P.mode = 30;
                break;
              }
              se = J = 0;
            }
            P.head && (P.head.hcrc = P.flags >> 9 & 1, P.head.done = !0), D.adler = P.check = 0, P.mode = 12;
            break;
          case 10:
            for (; se < 32; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            D.adler = P.check = S(J), se = J = 0, P.mode = 11;
          case 11:
            if (P.havedict === 0) return D.next_out = oe, D.avail_out = $, D.next_in = q, D.avail_in = ne, P.hold = J, P.bits = se, 2;
            D.adler = P.check = 1, P.mode = 12;
          case 12:
            if (L === 5 || L === 6) break e;
          case 13:
            if (P.last) {
              J >>>= 7 & se, se -= 7 & se, P.mode = 27;
              break;
            }
            for (; se < 3; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            switch (P.last = 1 & J, se -= 1, 3 & (J >>>= 1)) {
              case 0:
                P.mode = 14;
                break;
              case 1:
                if (O(P), P.mode = 20, L !== 6) break;
                J >>>= 2, se -= 2;
                break e;
              case 2:
                P.mode = 17;
                break;
              case 3:
                D.msg = "invalid block type", P.mode = 30;
            }
            J >>>= 2, se -= 2;
            break;
          case 14:
            for (J >>>= 7 & se, se -= 7 & se; se < 32; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if ((65535 & J) != (J >>> 16 ^ 65535)) {
              D.msg = "invalid stored block lengths", P.mode = 30;
              break;
            }
            if (P.length = 65535 & J, se = J = 0, P.mode = 15, L === 6) break e;
          case 15:
            P.mode = 16;
          case 16:
            if (ye = P.length) {
              if (ne < ye && (ye = ne), $ < ye && (ye = $), ye === 0) break e;
              a.arraySet(ce, V, q, ye, oe), ne -= ye, q += ye, $ -= ye, oe += ye, P.length -= ye;
              break;
            }
            P.mode = 12;
            break;
          case 17:
            for (; se < 14; ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if (P.nlen = 257 + (31 & J), J >>>= 5, se -= 5, P.ndist = 1 + (31 & J), J >>>= 5, se -= 5, P.ncode = 4 + (15 & J), J >>>= 4, se -= 4, 286 < P.nlen || 30 < P.ndist) {
              D.msg = "too many length or distance symbols", P.mode = 30;
              break;
            }
            P.have = 0, P.mode = 18;
          case 18:
            for (; P.have < P.ncode; ) {
              for (; se < 3; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              P.lens[F[P.have++]] = 7 & J, J >>>= 3, se -= 3;
            }
            for (; P.have < 19; ) P.lens[F[P.have++]] = 0;
            if (P.lencode = P.lendyn, P.lenbits = 7, Z = { bits: P.lenbits }, ee = h(0, P.lens, 0, 19, P.lencode, 0, P.work, Z), P.lenbits = Z.bits, ee) {
              D.msg = "invalid code lengths set", P.mode = 30;
              break;
            }
            P.have = 0, P.mode = 19;
          case 19:
            for (; P.have < P.nlen + P.ndist; ) {
              for (; R = (j = P.lencode[J & (1 << P.lenbits) - 1]) >>> 16 & 255, z = 65535 & j, !((G = j >>> 24) <= se); ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              if (z < 16) J >>>= G, se -= G, P.lens[P.have++] = z;
              else {
                if (z === 16) {
                  for (N = G + 2; se < N; ) {
                    if (ne === 0) break e;
                    ne--, J += V[q++] << se, se += 8;
                  }
                  if (J >>>= G, se -= G, P.have === 0) {
                    D.msg = "invalid bit length repeat", P.mode = 30;
                    break;
                  }
                  k = P.lens[P.have - 1], ye = 3 + (3 & J), J >>>= 2, se -= 2;
                } else if (z === 17) {
                  for (N = G + 3; se < N; ) {
                    if (ne === 0) break e;
                    ne--, J += V[q++] << se, se += 8;
                  }
                  se -= G, k = 0, ye = 3 + (7 & (J >>>= G)), J >>>= 3, se -= 3;
                } else {
                  for (N = G + 7; se < N; ) {
                    if (ne === 0) break e;
                    ne--, J += V[q++] << se, se += 8;
                  }
                  se -= G, k = 0, ye = 11 + (127 & (J >>>= G)), J >>>= 7, se -= 7;
                }
                if (P.have + ye > P.nlen + P.ndist) {
                  D.msg = "invalid bit length repeat", P.mode = 30;
                  break;
                }
                for (; ye--; ) P.lens[P.have++] = k;
              }
            }
            if (P.mode === 30) break;
            if (P.lens[256] === 0) {
              D.msg = "invalid code -- missing end-of-block", P.mode = 30;
              break;
            }
            if (P.lenbits = 9, Z = { bits: P.lenbits }, ee = h(d, P.lens, 0, P.nlen, P.lencode, 0, P.work, Z), P.lenbits = Z.bits, ee) {
              D.msg = "invalid literal/lengths set", P.mode = 30;
              break;
            }
            if (P.distbits = 6, P.distcode = P.distdyn, Z = { bits: P.distbits }, ee = h(p, P.lens, P.nlen, P.ndist, P.distcode, 0, P.work, Z), P.distbits = Z.bits, ee) {
              D.msg = "invalid distances set", P.mode = 30;
              break;
            }
            if (P.mode = 20, L === 6) break e;
          case 20:
            P.mode = 21;
          case 21:
            if (6 <= ne && 258 <= $) {
              D.next_out = oe, D.avail_out = $, D.next_in = q, D.avail_in = ne, P.hold = J, P.bits = se, u(D, re), oe = D.next_out, ce = D.output, $ = D.avail_out, q = D.next_in, V = D.input, ne = D.avail_in, J = P.hold, se = P.bits, P.mode === 12 && (P.back = -1);
              break;
            }
            for (P.back = 0; R = (j = P.lencode[J & (1 << P.lenbits) - 1]) >>> 16 & 255, z = 65535 & j, !((G = j >>> 24) <= se); ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if (R && !(240 & R)) {
              for (I = G, Q = R, X = z; R = (j = P.lencode[X + ((J & (1 << I + Q) - 1) >> I)]) >>> 16 & 255, z = 65535 & j, !(I + (G = j >>> 24) <= se); ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              J >>>= I, se -= I, P.back += I;
            }
            if (J >>>= G, se -= G, P.back += G, P.length = z, R === 0) {
              P.mode = 26;
              break;
            }
            if (32 & R) {
              P.back = -1, P.mode = 12;
              break;
            }
            if (64 & R) {
              D.msg = "invalid literal/length code", P.mode = 30;
              break;
            }
            P.extra = 15 & R, P.mode = 22;
          case 22:
            if (P.extra) {
              for (N = P.extra; se < N; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              P.length += J & (1 << P.extra) - 1, J >>>= P.extra, se -= P.extra, P.back += P.extra;
            }
            P.was = P.length, P.mode = 23;
          case 23:
            for (; R = (j = P.distcode[J & (1 << P.distbits) - 1]) >>> 16 & 255, z = 65535 & j, !((G = j >>> 24) <= se); ) {
              if (ne === 0) break e;
              ne--, J += V[q++] << se, se += 8;
            }
            if (!(240 & R)) {
              for (I = G, Q = R, X = z; R = (j = P.distcode[X + ((J & (1 << I + Q) - 1) >> I)]) >>> 16 & 255, z = 65535 & j, !(I + (G = j >>> 24) <= se); ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              J >>>= I, se -= I, P.back += I;
            }
            if (J >>>= G, se -= G, P.back += G, 64 & R) {
              D.msg = "invalid distance code", P.mode = 30;
              break;
            }
            P.offset = z, P.extra = 15 & R, P.mode = 24;
          case 24:
            if (P.extra) {
              for (N = P.extra; se < N; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              P.offset += J & (1 << P.extra) - 1, J >>>= P.extra, se -= P.extra, P.back += P.extra;
            }
            if (P.offset > P.dmax) {
              D.msg = "invalid distance too far back", P.mode = 30;
              break;
            }
            P.mode = 25;
          case 25:
            if ($ === 0) break e;
            if (ye = re - $, P.offset > ye) {
              if ((ye = P.offset - ye) > P.whave && P.sane) {
                D.msg = "invalid distance too far back", P.mode = 30;
                break;
              }
              H = ye > P.wnext ? (ye -= P.wnext, P.wsize - ye) : P.wnext - ye, ye > P.length && (ye = P.length), K = P.window;
            } else K = ce, H = oe - P.offset, ye = P.length;
            for ($ < ye && (ye = $), $ -= ye, P.length -= ye; ce[oe++] = K[H++], --ye; ) ;
            P.length === 0 && (P.mode = 21);
            break;
          case 26:
            if ($ === 0) break e;
            ce[oe++] = P.length, $--, P.mode = 21;
            break;
          case 27:
            if (P.wrap) {
              for (; se < 32; ) {
                if (ne === 0) break e;
                ne--, J |= V[q++] << se, se += 8;
              }
              if (re -= $, D.total_out += re, P.total += re, re && (D.adler = P.check = P.flags ? c(P.check, ce, re, oe - re) : l(P.check, ce, re, oe - re)), re = $, (P.flags ? J : S(J)) !== P.check) {
                D.msg = "incorrect data check", P.mode = 30;
                break;
              }
              se = J = 0;
            }
            P.mode = 28;
          case 28:
            if (P.wrap && P.flags) {
              for (; se < 32; ) {
                if (ne === 0) break e;
                ne--, J += V[q++] << se, se += 8;
              }
              if (J !== (4294967295 & P.total)) {
                D.msg = "incorrect length check", P.mode = 30;
                break;
              }
              se = J = 0;
            }
            P.mode = 29;
          case 29:
            ee = 1;
            break e;
          case 30:
            ee = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return m;
        }
        return D.next_out = oe, D.avail_out = $, D.next_in = q, D.avail_in = ne, P.hold = J, P.bits = se, (P.wsize || re !== D.avail_out && P.mode < 30 && (P.mode < 27 || L !== 4)) && U(D, D.output, D.next_out, re - D.avail_out) ? (P.mode = 31, -4) : (le -= D.avail_in, re -= D.avail_out, D.total_in += le, D.total_out += re, P.total += re, P.wrap && re && (D.adler = P.check = P.flags ? c(P.check, ce, re, D.next_out - re) : l(P.check, ce, re, D.next_out - re)), D.data_type = P.bits + (P.last ? 64 : 0) + (P.mode === 12 ? 128 : 0) + (P.mode === 20 || P.mode === 15 ? 256 : 0), (le == 0 && re === 0 || L === 4) && ee === f && (ee = -5), ee);
      }, o.inflateEnd = function(D) {
        if (!D || !D.state) return m;
        var L = D.state;
        return L.window && (L.window = null), D.state = null, f;
      }, o.inflateGetHeader = function(D, L) {
        var P;
        return D && D.state && 2 & (P = D.state).wrap ? ((P.head = L).done = !1, f) : m;
      }, o.inflateSetDictionary = function(D, L) {
        var P, V = L.length;
        return D && D.state ? (P = D.state).wrap !== 0 && P.mode !== 11 ? m : P.mode === 11 && l(1, L, V, 0) !== P.check ? -3 : U(D, L, V, V) ? (P.mode = 31, -4) : (P.havedict = 1, f) : m;
      }, o.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, s, o) {
      var a = i("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      s.exports = function(d, p, f, m, _, g, v, S) {
        var b, x, M, C, E, T, w, A, O, U = S.bits, D = 0, L = 0, P = 0, V = 0, ce = 0, q = 0, oe = 0, ne = 0, $ = 0, J = 0, se = null, le = 0, re = new a.Buf16(16), ye = new a.Buf16(16), H = null, K = 0;
        for (D = 0; D <= 15; D++) re[D] = 0;
        for (L = 0; L < m; L++) re[p[f + L]]++;
        for (ce = U, V = 15; 1 <= V && re[V] === 0; V--) ;
        if (V < ce && (ce = V), V === 0) return _[g++] = 20971520, _[g++] = 20971520, S.bits = 1, 0;
        for (P = 1; P < V && re[P] === 0; P++) ;
        for (ce < P && (ce = P), D = ne = 1; D <= 15; D++) if (ne <<= 1, (ne -= re[D]) < 0) return -1;
        if (0 < ne && (d === 0 || V !== 1)) return -1;
        for (ye[1] = 0, D = 1; D < 15; D++) ye[D + 1] = ye[D] + re[D];
        for (L = 0; L < m; L++) p[f + L] !== 0 && (v[ye[p[f + L]]++] = L);
        if (T = d === 0 ? (se = H = v, 19) : d === 1 ? (se = l, le -= 257, H = c, K -= 257, 256) : (se = u, H = h, -1), D = P, E = g, oe = L = J = 0, M = -1, C = ($ = 1 << (q = ce)) - 1, d === 1 && 852 < $ || d === 2 && 592 < $) return 1;
        for (; ; ) {
          for (w = D - oe, O = v[L] < T ? (A = 0, v[L]) : v[L] > T ? (A = H[K + v[L]], se[le + v[L]]) : (A = 96, 0), b = 1 << D - oe, P = x = 1 << q; _[E + (J >> oe) + (x -= b)] = w << 24 | A << 16 | O | 0, x !== 0; ) ;
          for (b = 1 << D - 1; J & b; ) b >>= 1;
          if (b !== 0 ? (J &= b - 1, J += b) : J = 0, L++, --re[D] == 0) {
            if (D === V) break;
            D = p[f + v[L]];
          }
          if (ce < D && (J & C) !== M) {
            for (oe === 0 && (oe = ce), E += P, ne = 1 << (q = D - oe); q + oe < V && !((ne -= re[q + oe]) <= 0); ) q++, ne <<= 1;
            if ($ += 1 << q, d === 1 && 852 < $ || d === 2 && 592 < $) return 1;
            _[M = J & C] = ce << 24 | q << 16 | E - g | 0;
          }
        }
        return J !== 0 && (_[E + J] = D - oe << 24 | 64 << 16 | 0), S.bits = ce, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(i, s, o) {
      s.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(i, s, o) {
      var a = i("../utils/common"), l = 0, c = 1;
      function u(j) {
        for (var te = j.length; 0 <= --te; ) j[te] = 0;
      }
      var h = 0, d = 29, p = 256, f = p + 1 + d, m = 30, _ = 19, g = 2 * f + 1, v = 15, S = 16, b = 7, x = 256, M = 16, C = 17, E = 18, T = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], w = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], A = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], O = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (f + 2));
      u(U);
      var D = new Array(2 * m);
      u(D);
      var L = new Array(512);
      u(L);
      var P = new Array(256);
      u(P);
      var V = new Array(d);
      u(V);
      var ce, q, oe, ne = new Array(m);
      function $(j, te, F, B, Y) {
        this.static_tree = j, this.extra_bits = te, this.extra_base = F, this.elems = B, this.max_length = Y, this.has_stree = j && j.length;
      }
      function J(j, te) {
        this.dyn_tree = j, this.max_code = 0, this.stat_desc = te;
      }
      function se(j) {
        return j < 256 ? L[j] : L[256 + (j >>> 7)];
      }
      function le(j, te) {
        j.pending_buf[j.pending++] = 255 & te, j.pending_buf[j.pending++] = te >>> 8 & 255;
      }
      function re(j, te, F) {
        j.bi_valid > S - F ? (j.bi_buf |= te << j.bi_valid & 65535, le(j, j.bi_buf), j.bi_buf = te >> S - j.bi_valid, j.bi_valid += F - S) : (j.bi_buf |= te << j.bi_valid & 65535, j.bi_valid += F);
      }
      function ye(j, te, F) {
        re(j, F[2 * te], F[2 * te + 1]);
      }
      function H(j, te) {
        for (var F = 0; F |= 1 & j, j >>>= 1, F <<= 1, 0 < --te; ) ;
        return F >>> 1;
      }
      function K(j, te, F) {
        var B, Y, fe = new Array(v + 1), ge = 0;
        for (B = 1; B <= v; B++) fe[B] = ge = ge + F[B - 1] << 1;
        for (Y = 0; Y <= te; Y++) {
          var xe = j[2 * Y + 1];
          xe !== 0 && (j[2 * Y] = H(fe[xe]++, xe));
        }
      }
      function G(j) {
        var te;
        for (te = 0; te < f; te++) j.dyn_ltree[2 * te] = 0;
        for (te = 0; te < m; te++) j.dyn_dtree[2 * te] = 0;
        for (te = 0; te < _; te++) j.bl_tree[2 * te] = 0;
        j.dyn_ltree[2 * x] = 1, j.opt_len = j.static_len = 0, j.last_lit = j.matches = 0;
      }
      function R(j) {
        8 < j.bi_valid ? le(j, j.bi_buf) : 0 < j.bi_valid && (j.pending_buf[j.pending++] = j.bi_buf), j.bi_buf = 0, j.bi_valid = 0;
      }
      function z(j, te, F, B) {
        var Y = 2 * te, fe = 2 * F;
        return j[Y] < j[fe] || j[Y] === j[fe] && B[te] <= B[F];
      }
      function I(j, te, F) {
        for (var B = j.heap[F], Y = F << 1; Y <= j.heap_len && (Y < j.heap_len && z(te, j.heap[Y + 1], j.heap[Y], j.depth) && Y++, !z(te, B, j.heap[Y], j.depth)); ) j.heap[F] = j.heap[Y], F = Y, Y <<= 1;
        j.heap[F] = B;
      }
      function Q(j, te, F) {
        var B, Y, fe, ge, xe = 0;
        if (j.last_lit !== 0) for (; B = j.pending_buf[j.d_buf + 2 * xe] << 8 | j.pending_buf[j.d_buf + 2 * xe + 1], Y = j.pending_buf[j.l_buf + xe], xe++, B === 0 ? ye(j, Y, te) : (ye(j, (fe = P[Y]) + p + 1, te), (ge = T[fe]) !== 0 && re(j, Y -= V[fe], ge), ye(j, fe = se(--B), F), (ge = w[fe]) !== 0 && re(j, B -= ne[fe], ge)), xe < j.last_lit; ) ;
        ye(j, x, te);
      }
      function X(j, te) {
        var F, B, Y, fe = te.dyn_tree, ge = te.stat_desc.static_tree, xe = te.stat_desc.has_stree, De = te.stat_desc.elems, ae = -1;
        for (j.heap_len = 0, j.heap_max = g, F = 0; F < De; F++) fe[2 * F] !== 0 ? (j.heap[++j.heap_len] = ae = F, j.depth[F] = 0) : fe[2 * F + 1] = 0;
        for (; j.heap_len < 2; ) fe[2 * (Y = j.heap[++j.heap_len] = ae < 2 ? ++ae : 0)] = 1, j.depth[Y] = 0, j.opt_len--, xe && (j.static_len -= ge[2 * Y + 1]);
        for (te.max_code = ae, F = j.heap_len >> 1; 1 <= F; F--) I(j, fe, F);
        for (Y = De; F = j.heap[1], j.heap[1] = j.heap[j.heap_len--], I(j, fe, 1), B = j.heap[1], j.heap[--j.heap_max] = F, j.heap[--j.heap_max] = B, fe[2 * Y] = fe[2 * F] + fe[2 * B], j.depth[Y] = (j.depth[F] >= j.depth[B] ? j.depth[F] : j.depth[B]) + 1, fe[2 * F + 1] = fe[2 * B + 1] = Y, j.heap[1] = Y++, I(j, fe, 1), 2 <= j.heap_len; ) ;
        j.heap[--j.heap_max] = j.heap[1], function(de, Ee) {
          var be, ke, ze, Te, Pe, Ge, Ve = Ee.dyn_tree, Qe = Ee.max_code, _e = Ee.stat_desc.static_tree, Ue = Ee.stat_desc.has_stree, Fe = Ee.stat_desc.extra_bits, je = Ee.stat_desc.extra_base, Ke = Ee.stat_desc.max_length, qe = 0;
          for (Te = 0; Te <= v; Te++) de.bl_count[Te] = 0;
          for (Ve[2 * de.heap[de.heap_max] + 1] = 0, be = de.heap_max + 1; be < g; be++) Ke < (Te = Ve[2 * Ve[2 * (ke = de.heap[be]) + 1] + 1] + 1) && (Te = Ke, qe++), Ve[2 * ke + 1] = Te, Qe < ke || (de.bl_count[Te]++, Pe = 0, je <= ke && (Pe = Fe[ke - je]), Ge = Ve[2 * ke], de.opt_len += Ge * (Te + Pe), Ue && (de.static_len += Ge * (_e[2 * ke + 1] + Pe)));
          if (qe !== 0) {
            do {
              for (Te = Ke - 1; de.bl_count[Te] === 0; ) Te--;
              de.bl_count[Te]--, de.bl_count[Te + 1] += 2, de.bl_count[Ke]--, qe -= 2;
            } while (0 < qe);
            for (Te = Ke; Te !== 0; Te--) for (ke = de.bl_count[Te]; ke !== 0; ) Qe < (ze = de.heap[--be]) || (Ve[2 * ze + 1] !== Te && (de.opt_len += (Te - Ve[2 * ze + 1]) * Ve[2 * ze], Ve[2 * ze + 1] = Te), ke--);
          }
        }(j, te), K(fe, ae, j.bl_count);
      }
      function k(j, te, F) {
        var B, Y, fe = -1, ge = te[1], xe = 0, De = 7, ae = 4;
        for (ge === 0 && (De = 138, ae = 3), te[2 * (F + 1) + 1] = 65535, B = 0; B <= F; B++) Y = ge, ge = te[2 * (B + 1) + 1], ++xe < De && Y === ge || (xe < ae ? j.bl_tree[2 * Y] += xe : Y !== 0 ? (Y !== fe && j.bl_tree[2 * Y]++, j.bl_tree[2 * M]++) : xe <= 10 ? j.bl_tree[2 * C]++ : j.bl_tree[2 * E]++, fe = Y, ae = (xe = 0) === ge ? (De = 138, 3) : Y === ge ? (De = 6, 3) : (De = 7, 4));
      }
      function ee(j, te, F) {
        var B, Y, fe = -1, ge = te[1], xe = 0, De = 7, ae = 4;
        for (ge === 0 && (De = 138, ae = 3), B = 0; B <= F; B++) if (Y = ge, ge = te[2 * (B + 1) + 1], !(++xe < De && Y === ge)) {
          if (xe < ae) for (; ye(j, Y, j.bl_tree), --xe != 0; ) ;
          else Y !== 0 ? (Y !== fe && (ye(j, Y, j.bl_tree), xe--), ye(j, M, j.bl_tree), re(j, xe - 3, 2)) : xe <= 10 ? (ye(j, C, j.bl_tree), re(j, xe - 3, 3)) : (ye(j, E, j.bl_tree), re(j, xe - 11, 7));
          fe = Y, ae = (xe = 0) === ge ? (De = 138, 3) : Y === ge ? (De = 6, 3) : (De = 7, 4);
        }
      }
      u(ne);
      var Z = !1;
      function N(j, te, F, B) {
        re(j, (h << 1) + (B ? 1 : 0), 3), function(Y, fe, ge, xe) {
          R(Y), le(Y, ge), le(Y, ~ge), a.arraySet(Y.pending_buf, Y.window, fe, ge, Y.pending), Y.pending += ge;
        }(j, te, F);
      }
      o._tr_init = function(j) {
        Z || (function() {
          var te, F, B, Y, fe, ge = new Array(v + 1);
          for (Y = B = 0; Y < d - 1; Y++) for (V[Y] = B, te = 0; te < 1 << T[Y]; te++) P[B++] = Y;
          for (P[B - 1] = Y, Y = fe = 0; Y < 16; Y++) for (ne[Y] = fe, te = 0; te < 1 << w[Y]; te++) L[fe++] = Y;
          for (fe >>= 7; Y < m; Y++) for (ne[Y] = fe << 7, te = 0; te < 1 << w[Y] - 7; te++) L[256 + fe++] = Y;
          for (F = 0; F <= v; F++) ge[F] = 0;
          for (te = 0; te <= 143; ) U[2 * te + 1] = 8, te++, ge[8]++;
          for (; te <= 255; ) U[2 * te + 1] = 9, te++, ge[9]++;
          for (; te <= 279; ) U[2 * te + 1] = 7, te++, ge[7]++;
          for (; te <= 287; ) U[2 * te + 1] = 8, te++, ge[8]++;
          for (K(U, f + 1, ge), te = 0; te < m; te++) D[2 * te + 1] = 5, D[2 * te] = H(te, 5);
          ce = new $(U, T, p + 1, f, v), q = new $(D, w, 0, m, v), oe = new $(new Array(0), A, 0, _, b);
        }(), Z = !0), j.l_desc = new J(j.dyn_ltree, ce), j.d_desc = new J(j.dyn_dtree, q), j.bl_desc = new J(j.bl_tree, oe), j.bi_buf = 0, j.bi_valid = 0, G(j);
      }, o._tr_stored_block = N, o._tr_flush_block = function(j, te, F, B) {
        var Y, fe, ge = 0;
        0 < j.level ? (j.strm.data_type === 2 && (j.strm.data_type = function(xe) {
          var De, ae = 4093624447;
          for (De = 0; De <= 31; De++, ae >>>= 1) if (1 & ae && xe.dyn_ltree[2 * De] !== 0) return l;
          if (xe.dyn_ltree[18] !== 0 || xe.dyn_ltree[20] !== 0 || xe.dyn_ltree[26] !== 0) return c;
          for (De = 32; De < p; De++) if (xe.dyn_ltree[2 * De] !== 0) return c;
          return l;
        }(j)), X(j, j.l_desc), X(j, j.d_desc), ge = function(xe) {
          var De;
          for (k(xe, xe.dyn_ltree, xe.l_desc.max_code), k(xe, xe.dyn_dtree, xe.d_desc.max_code), X(xe, xe.bl_desc), De = _ - 1; 3 <= De && xe.bl_tree[2 * O[De] + 1] === 0; De--) ;
          return xe.opt_len += 3 * (De + 1) + 5 + 5 + 4, De;
        }(j), Y = j.opt_len + 3 + 7 >>> 3, (fe = j.static_len + 3 + 7 >>> 3) <= Y && (Y = fe)) : Y = fe = F + 5, F + 4 <= Y && te !== -1 ? N(j, te, F, B) : j.strategy === 4 || fe === Y ? (re(j, 2 + (B ? 1 : 0), 3), Q(j, U, D)) : (re(j, 4 + (B ? 1 : 0), 3), function(xe, De, ae, de) {
          var Ee;
          for (re(xe, De - 257, 5), re(xe, ae - 1, 5), re(xe, de - 4, 4), Ee = 0; Ee < de; Ee++) re(xe, xe.bl_tree[2 * O[Ee] + 1], 3);
          ee(xe, xe.dyn_ltree, De - 1), ee(xe, xe.dyn_dtree, ae - 1);
        }(j, j.l_desc.max_code + 1, j.d_desc.max_code + 1, ge + 1), Q(j, j.dyn_ltree, j.dyn_dtree)), G(j), B && R(j);
      }, o._tr_tally = function(j, te, F) {
        return j.pending_buf[j.d_buf + 2 * j.last_lit] = te >>> 8 & 255, j.pending_buf[j.d_buf + 2 * j.last_lit + 1] = 255 & te, j.pending_buf[j.l_buf + j.last_lit] = 255 & F, j.last_lit++, te === 0 ? j.dyn_ltree[2 * F]++ : (j.matches++, te--, j.dyn_ltree[2 * (P[F] + p + 1)]++, j.dyn_dtree[2 * se(te)]++), j.last_lit === j.lit_bufsize - 1;
      }, o._tr_align = function(j) {
        re(j, 2, 3), ye(j, x, U), function(te) {
          te.bi_valid === 16 ? (le(te, te.bi_buf), te.bi_buf = 0, te.bi_valid = 0) : 8 <= te.bi_valid && (te.pending_buf[te.pending++] = 255 & te.bi_buf, te.bi_buf >>= 8, te.bi_valid -= 8);
        }(j);
      };
    }, { "../utils/common": 41 }], 53: [function(i, s, o) {
      s.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(i, s, o) {
      (function(a) {
        (function(l, c) {
          if (!l.setImmediate) {
            var u, h, d, p, f = 1, m = {}, _ = !1, g = l.document, v = Object.getPrototypeOf && Object.getPrototypeOf(l);
            v = v && v.setTimeout ? v : l, u = {}.toString.call(l.process) === "[object process]" ? function(M) {
              n.nextTick(function() {
                b(M);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var M = !0, C = l.onmessage;
                return l.onmessage = function() {
                  M = !1;
                }, l.postMessage("", "*"), l.onmessage = C, M;
              }
            }() ? (p = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", x, !1) : l.attachEvent("onmessage", x), function(M) {
              l.postMessage(p + M, "*");
            }) : l.MessageChannel ? ((d = new MessageChannel()).port1.onmessage = function(M) {
              b(M.data);
            }, function(M) {
              d.port2.postMessage(M);
            }) : g && "onreadystatechange" in g.createElement("script") ? (h = g.documentElement, function(M) {
              var C = g.createElement("script");
              C.onreadystatechange = function() {
                b(M), C.onreadystatechange = null, h.removeChild(C), C = null;
              }, h.appendChild(C);
            }) : function(M) {
              setTimeout(b, 0, M);
            }, v.setImmediate = function(M) {
              typeof M != "function" && (M = new Function("" + M));
              for (var C = new Array(arguments.length - 1), E = 0; E < C.length; E++) C[E] = arguments[E + 1];
              var T = { callback: M, args: C };
              return m[f] = T, u(f), f++;
            }, v.clearImmediate = S;
          }
          function S(M) {
            delete m[M];
          }
          function b(M) {
            if (_) setTimeout(b, 0, M);
            else {
              var C = m[M];
              if (C) {
                _ = !0;
                try {
                  (function(E) {
                    var T = E.callback, w = E.args;
                    switch (w.length) {
                      case 0:
                        T();
                        break;
                      case 1:
                        T(w[0]);
                        break;
                      case 2:
                        T(w[0], w[1]);
                        break;
                      case 3:
                        T(w[0], w[1], w[2]);
                        break;
                      default:
                        T.apply(c, w);
                    }
                  })(C);
                } finally {
                  S(M), _ = !1;
                }
              }
            }
          }
          function x(M) {
            M.source === l && typeof M.data == "string" && M.data.indexOf(p) === 0 && b(+M.data.slice(p.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof zh < "u" ? zh : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(CS);
var lZ = CS.exports;
const cZ = /* @__PURE__ */ aZ(lZ), uZ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: cZ
}, Symbol.toStringTag, { value: "Module" }));
export {
  O_ as mountApp,
  dZ as sendToComfyUI
};
