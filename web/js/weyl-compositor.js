import { H as defineStore, I as toRaw, c as computed, r as ref, J as reactive, K as defineComponent, w as watch, o as onMounted, a as createElementBlock, d as openBlock, L as withModifiers, t as createBaseVNode, C as createCommentVNode, D as normalizeClass, x as toDisplayString, A as withDirectives, F as Fragment, M as renderList, v as createTextVNode, N as vModelSelect, O as vModelText, P as vModelCheckbox, g as createBlock, u as unref, B as withCtx, n as normalizeStyle, Q as vModelRadio, E as createVNode, R as onUnmounted, S as withKeys, T as Teleport, U as createStaticVNode, V as markRaw, h as resolveDynamicComponent, W as vShow, X as storeToRefs, k as nextTick, Y as shallowRef, Z as createApp, _ as createPinia } from './weyl-vue-vendor.js';
import { s as script, g as ge, P as Pe } from './weyl-ui-vendor.js';
import { G as Group, M as MathUtils, a as Mesh, N as NormalBlending, A as AddEquation, S as SrcAlphaFactor, O as OneMinusSrcAlphaFactor, b as OneFactor, C as CustomBlending, c as MaxEquation, d as MinEquation, e as OneMinusDstColorFactor, f as OneMinusSrcColorFactor, g as SubtractEquation, h as SubtractiveBlending, i as AdditiveBlending, j as MultiplyBlending, V as Vector3, k as CatmullRomCurve3, B as BufferGeometry, L as LineBasicMaterial, l as Line, m as OctahedronGeometry, n as MeshBasicMaterial, o as SphereGeometry, p as Box3, P as PlaneGeometry, D as DoubleSide, q as VideoTexture, r as LinearFilter, R as RGBAFormat, s as SRGBColorSpace, t as SVGLoader, u as Color, v as Matrix4, E as ExtrudeGeometry, w as ShapeGeometry, x as BufferAttribute, y as MeshStandardMaterial, z as MeshPhysicalMaterial, F as BackSide, H as FrontSide, I as Float32BufferAttribute, T as TubeGeometry, J as TextureLoader, K as BoxGeometry, Q as IcosahedronGeometry, U as TetrahedronGeometry, W as TorusGeometry, X as CylinderGeometry, Y as ConeGeometry, Z as InstancedMesh, _ as DynamicDrawUsage, $ as Euler, a0 as Quaternion, a1 as Scene, a2 as PerspectiveCamera, a3 as AmbientLight, a4 as DirectionalLight, a5 as WebGLRenderer, a6 as NearestFilter, a7 as SpriteMaterial, a8 as RGBELoader, a9 as EXRLoader, aa as PMREMGenerator, ab as RepeatWrapping, ac as LinearMipmapLinearFilter, ad as LinearSRGBColorSpace, ae as Vector2, af as AxesHelper, ag as GridHelper, ah as EquirectangularReflectionMapping, ai as LineLoop, aj as Shape, ak as Path, al as ACESFilmicToneMapping, am as PCFSoftShadowMap, an as EffectComposer, ao as MeshNormalMaterial, ap as WebGLRenderTarget, aq as HalfFloatType, ar as DepthTexture, as as DepthFormat, at as UnsignedIntType, au as FloatType, av as ShaderMaterial, aw as RenderPass, ax as OutputPass, ay as BokehPass, az as SSAOPass, aA as UnrealBloomPass, aB as ShaderPass, aC as UnsignedByteType, aD as CircleGeometry, aE as CurvePath, aF as CubicBezierCurve3, aG as Text, aH as LineGeometry, aI as LineMaterial, aJ as Line2, aK as DataTexture, aL as RedFormat, aM as InstancedBufferGeometry, aN as InstancedBufferAttribute, aO as RingGeometry, aP as PointLight, aQ as RectAreaLight, aR as SpotLight, aS as RectAreaLightHelper, aT as DirectionalLightHelper, aU as SpotLightHelper, aV as PointLightHelper, aW as RectAreaLightUniformsLib, aX as CanvasTexture, aY as GLTFLoader, aZ as DRACOLoader, a_ as MeshoptDecoder, a$ as OBJLoader, b0 as FBXLoader, b1 as ColladaLoader, b2 as AnimationMixer, b3 as LoopRepeat, b4 as LoopOnce, b5 as MeshDepthMaterial, b6 as RGBADepthPacking, b7 as BoxHelper, b8 as SkeletonHelper, b9 as SkinnedMesh, ba as PLYLoader, bb as PCDLoader, bc as Points, bd as Raycaster, be as Clock, bf as OrthographicCamera, bg as THREE$1, bh as Texture, bi as TransformControls } from './weyl-three-vendor.js';
import { M as Muxer, A as ArrayBufferTarget, a as Muxer$1, b as ArrayBufferTarget$1 } from './weyl-export-vendor.js';

const PI = Math.PI;
const c1$1 = 1.70158;
const c2$1 = c1$1 * 1.525;
const c3$1 = c1$1 + 1;
const c4$1 = 2 * PI / 3;
const c5$1 = 2 * PI / 4.5;
const easings = {
  // Linear - no easing
  linear: (t) => t,
  // Sine easing
  easeInSine: (t) => 1 - Math.cos(t * PI / 2),
  easeOutSine: (t) => Math.sin(t * PI / 2),
  easeInOutSine: (t) => -(Math.cos(PI * t) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
    return (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // Circ (circular)
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (t) => c3$1 * t * t * t - c1$1 * t * t,
  easeOutBack: (t) => 1 + c3$1 * Math.pow(t - 1, 3) + c1$1 * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2$1 + 1) * 2 * t - c2$1) / 2 : (Math.pow(2 * t - 2, 2) * ((c2$1 + 1) * (t * 2 - 2) + c2$1) + 2) / 2,
  // Elastic
  easeInElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4$1);
  },
  easeOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4$1) + 1;
  },
  easeInOutElastic: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    if (t < 0.5) {
      return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5$1)) / 2;
    }
    return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5$1) / 2 + 1;
  },
  // Bounce
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInBounce: (t) => 1 - easings.easeOutBounce(1 - t),
  easeInOutBounce: (t) => t < 0.5 ? (1 - easings.easeOutBounce(1 - 2 * t)) / 2 : (1 + easings.easeOutBounce(2 * t - 1)) / 2
};
function getEasing(name) {
  if (name in easings) {
    return easings[name];
  }
  return easings.linear;
}

const LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
const config = {
  level: "warn",
  prefix: "[Weyl]"};
function shouldLog(level) {
  return LOG_LEVELS[level] >= LOG_LEVELS[config.level];
}
function formatMessage(level, context, message) {
  const parts = [];
  {
    parts.push(config.prefix);
  }
  if (context) {
    parts.push(`[${context}]`);
  }
  parts.push(message);
  return parts.join(" ");
}
function createLogger(context) {
  return {
    debug(message, ...args) {
      if (shouldLog("debug")) {
        console.log(formatMessage("DEBUG", context, message), ...args);
      }
    },
    info(message, ...args) {
      if (shouldLog("info")) {
        console.info(formatMessage("INFO", context, message), ...args);
      }
    },
    warn(message, ...args) {
      if (shouldLog("warn")) {
        console.warn(formatMessage("WARN", context, message), ...args);
      }
    },
    error(message, ...args) {
      if (shouldLog("error")) {
        console.error(formatMessage("ERROR", context, message), ...args);
      }
    },
    /**
     * Log with a specific level
     */
    log(level, message, ...args) {
      switch (level) {
        case "debug":
          this.debug(message, ...args);
          break;
        case "info":
          this.info(message, ...args);
          break;
        case "warn":
          this.warn(message, ...args);
          break;
        case "error":
          this.error(message, ...args);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(label) {
      if (shouldLog("debug")) {
        console.group(formatMessage("", context, label));
      }
    },
    groupEnd() {
      if (shouldLog("debug")) {
        console.groupEnd();
      }
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(data) {
      if (shouldLog("debug")) {
        console.log(formatMessage("", context, "Table:"));
        console.table(data);
      }
    },
    /**
     * Measure time for an operation
     */
    time(label) {
      if (shouldLog("debug")) {
        console.time(`${config.prefix} [${context}] ${label}`);
      }
    },
    timeEnd(label) {
      if (shouldLog("debug")) {
        console.timeEnd(`${config.prefix} [${context}] ${label}`);
      }
    }
  };
}
const storeLogger = createLogger("Store");
const engineLogger = createLogger("Engine");
const layerLogger = createLogger("Layer");
const renderLogger = createLogger("Render");
const exportLogger = createLogger("Export");

const easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
const easeOutSine = (t) => Math.sin(t * Math.PI / 2);
const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
const easeInQuad = (t) => t * t;
const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
const easeInCubic = (t) => t * t * t;
const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
const easeInQuart = (t) => t * t * t * t;
const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
const easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
const easeInQuint = (t) => t * t * t * t * t;
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
const easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
const easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
const easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
const easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
const easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
const easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
const easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
const c1 = 1.70158;
const c2 = c1 * 1.525;
const c3 = c1 + 1;
const easeInBack = (t) => c3 * t * t * t - c1 * t * t;
const easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
const easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
const c4 = 2 * Math.PI / 3;
const c5 = 2 * Math.PI / 4.5;
const easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
const easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
const easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
const easeOutBounce = (t) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
const easeInBounce = (t) => 1 - easeOutBounce(1 - t);
const easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
const linear = (t) => t;
const stepStart = (t) => t === 0 ? 0 : 1;
const stepEnd = (t) => t === 1 ? 1 : 0;
const EASING_FUNCTIONS = {
  // Linear
  linear,
  // Sine
  easeInSine,
  easeOutSine,
  easeInOutSine,
  // Quad
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  // Cubic
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  // Quart
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  // Quint
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  // Expo
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  // Circ
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  // Back
  easeInBack,
  easeOutBack,
  easeInOutBack,
  // Elastic
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  // Bounce
  easeInBounce,
  easeOutBounce,
  easeInOutBounce,
  // Step
  stepStart,
  stepEnd
};
function inertia(ctx, amplitude = 0.1, frequency = 2, decay = 2) {
  const { time: time2, keyframes, value, velocity } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let nearestKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      nearestKey = keyframes[i];
      break;
    }
  }
  if (!nearestKey) return value;
  const keyTime = nearestKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const vel = typeof velocity === "number" ? velocity : velocity[0];
  const val = typeof value === "number" ? value : value[0];
  const oscillation = vel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  if (typeof value === "number") {
    return val + oscillation;
  }
  return value.map((v, i) => {
    const componentVel = velocity[i] || 0;
    return v + componentVel * amplitude * Math.sin(frequency * t * 2 * Math.PI) / Math.exp(decay * t);
  });
}
function bounce(ctx, elasticity = 0.7, gravity = 4e3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  let bounceTime = t;
  let bounceHeight = 1;
  let totalBounces = 0;
  const maxBounces = 10;
  while (bounceTime > 0 && totalBounces < maxBounces) {
    const bounceDuration2 = Math.sqrt(2 * bounceHeight / gravity);
    if (bounceTime < bounceDuration2 * 2) {
      break;
    }
    bounceTime -= bounceDuration2 * 2;
    bounceHeight *= elasticity * elasticity;
    totalBounces++;
  }
  const bounceDuration = Math.sqrt(2 * bounceHeight / gravity);
  const bounceT = bounceTime / (bounceDuration * 2);
  const bounceOffset = bounceHeight * 4 * bounceT * (1 - bounceT);
  if (typeof value === "number") {
    return value - bounceOffset * (1 - elasticity);
  }
  return value.map((v) => v - bounceOffset * (1 - elasticity));
}
function elastic(ctx, amplitude = 1, period = 0.3) {
  const { time: time2, keyframes, value } = ctx;
  if (keyframes.length === 0) return value;
  const fps = ctx.fps || 30;
  const currentFrame = time2 * fps;
  let lastKey = null;
  for (let i = keyframes.length - 1; i >= 0; i--) {
    if (keyframes[i].frame <= currentFrame) {
      lastKey = keyframes[i];
      break;
    }
  }
  if (!lastKey) return value;
  const keyTime = lastKey.frame / fps;
  const t = time2 - keyTime;
  if (t <= 0) return value;
  const s = period / 4;
  const decay = Math.pow(2, -10 * t);
  const oscillation = decay * Math.sin((t - s) * (2 * Math.PI) / period);
  if (typeof value === "number") {
    return value + amplitude * oscillation;
  }
  return value.map((v) => v + amplitude * oscillation);
}
function repeatAfter(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const startIdx = numKeyframes > 0 ? Math.max(0, keyframes.length - numKeyframes) : 0;
  const startKey = keyframes[startIdx];
  const endKey = keyframes[keyframes.length - 1];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 <= endTime) return ctx.value;
  const elapsed = time2 - endTime;
  switch (type) {
    case "cycle": {
      const cycleTime = startTime + elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? 1 - cycleProgress : cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = startTime + elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(endKey.value, startKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value + velocity * elapsed;
      }
      return ctx.value.map((v, i) => v + velocity[i] * elapsed);
    }
  }
}
function repeatBefore(ctx, type = "cycle", numKeyframes = 0) {
  const { time: time2, keyframes, fps } = ctx;
  if (keyframes.length < 2) return ctx.value;
  const endIdx = numKeyframes > 0 ? Math.min(keyframes.length - 1, numKeyframes - 1) : keyframes.length - 1;
  const startKey = keyframes[0];
  const endKey = keyframes[endIdx];
  const startTime = startKey.frame / fps;
  const endTime = endKey.frame / fps;
  const duration = endTime - startTime;
  if (duration <= 0 || time2 >= startTime) return ctx.value;
  const elapsed = startTime - time2;
  switch (type) {
    case "cycle": {
      const cycleTime = endTime - elapsed % duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "pingpong": {
      const cycles = Math.floor(elapsed / duration);
      const cycleProgress = elapsed % duration / duration;
      const isReverse = cycles % 2 === 1;
      const t = isReverse ? cycleProgress : 1 - cycleProgress;
      const cycleTime = startTime + t * duration;
      return interpolateAtTime(keyframes, cycleTime, fps);
    }
    case "offset": {
      const cycles = Math.floor(elapsed / duration);
      const cycleTime = endTime - elapsed % duration;
      const baseValue = interpolateAtTime(keyframes, cycleTime, fps);
      const delta = subtractValues(startKey.value, endKey.value);
      return addValues(baseValue, scaleValue(delta, cycles + 1));
    }
    case "continue": {
      const velocity = ctx.velocity;
      if (typeof velocity === "number") {
        return ctx.value - velocity * elapsed;
      }
      return ctx.value.map((v, i) => v - velocity[i] * elapsed);
    }
  }
}
function jitter(ctx, frequency = 5, amplitude = 50, octaves = 1, amplitudeMultiplier = 0.5, time2) {
  const t = time2 ?? ctx.time;
  const { value } = ctx;
  const noise = (seed, t2) => {
    let result = 0;
    let amp = 1;
    let freq = 1;
    for (let i = 0; i < octaves; i++) {
      result += amp * Math.sin(t2 * frequency * freq * Math.PI * 2 + seed * 1e3);
      result += amp * 0.5 * Math.sin(t2 * frequency * freq * Math.PI * 2 * 1.5 + seed * 500);
      amp *= amplitudeMultiplier;
      freq *= 2;
    }
    return result / (1 + (octaves - 1) * amplitudeMultiplier);
  };
  if (typeof value === "number") {
    return value + noise(0, t) * amplitude;
  }
  return value.map((v, i) => v + noise(i, t) * amplitude);
}
const timeExpressions = {
  /**
   * Linear time ramp
   */
  timeRamp(startTime, endTime, startValue, endValue, time2) {
    if (time2 <= startTime) return startValue;
    if (time2 >= endTime) return endValue;
    const t = (time2 - startTime) / (endTime - startTime);
    return startValue + (endValue - startValue) * t;
  },
  /**
   * Periodic function (loops every period seconds)
   */
  periodic(time2, period) {
    return time2 % period / period;
  },
  /**
   * Sawtooth wave
   */
  sawtooth(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * 2 * (t - Math.floor(t + 0.5));
  },
  /**
   * Triangle wave
   */
  triangle(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (2 * Math.abs(2 * (t - Math.floor(t + 0.5))) - 1);
  },
  /**
   * Square wave
   */
  square(time2, frequency, amplitude = 1) {
    const t = time2 * frequency;
    return amplitude * (t - Math.floor(t) < 0.5 ? 1 : -1);
  },
  /**
   * Sine wave
   */
  sine(time2, frequency, amplitude = 1, phase = 0) {
    return amplitude * Math.sin(2 * Math.PI * frequency * time2 + phase);
  },
  /**
   * Pulse (duty cycle controlled square)
   */
  pulse(time2, frequency, dutyCycle = 0.5, amplitude = 1) {
    const t = time2 * frequency % 1;
    return amplitude * (t < dutyCycle ? 1 : 0);
  }
};
const mathExpressions = {
  /**
   * Linear interpolation
   */
  lerp(a, b, t) {
    return a + (b - a) * t;
  },
  /**
   * Clamp value between min and max
   */
  clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
  },
  /**
   * Map value from one range to another
   */
  map(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
  },
  /**
   * Normalized value (0-1) based on range
   */
  normalize(value, min, max) {
    return (value - min) / (max - min);
  },
  /**
   * Smooth step (Hermite interpolation)
   */
  smoothstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
  },
  /**
   * Smoother step (Ken Perlin's improved version)
   */
  smootherstep(edge0, edge1, x) {
    const t = mathExpressions.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * t * (t * (t * 6 - 15) + 10);
  },
  /**
   * Modulo with support for negative numbers
   */
  mod(a, b) {
    return (a % b + b) % b;
  },
  /**
   * Distance between two 2D points
   */
  distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  },
  /**
   * Angle between two 2D points (in radians)
   */
  angleBetween(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  },
  /**
   * Convert degrees to radians
   */
  degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  },
  /**
   * Convert radians to degrees
   */
  radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
  },
  /**
   * Random number with seed (deterministic)
   */
  seedRandom(seed, min = 0, max = 1) {
    const x = Math.sin(seed * 12.9898) * 43758.5453;
    const rand = x - Math.floor(x);
    return min + rand * (max - min);
  },
  /**
   * Gaussian random (normal distribution)
   */
  gaussRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + z0 * stdDev;
  }
};
function interpolateAtTime(keyframes, time2, fps) {
  const frame = time2 * fps;
  let before = null;
  let after = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      before = kf;
    } else if (!after) {
      after = kf;
      break;
    }
  }
  if (!before) return keyframes[0].value;
  if (!after) return before.value;
  const t = (frame - before.frame) / (after.frame - before.frame);
  const easedT = applyEasing$2(t, before.interpolation);
  return lerpValues(before.value, after.value, easedT);
}
function applyEasing$2(t, interpolation) {
  const fn = EASING_FUNCTIONS[interpolation];
  return fn ? fn(t) : t;
}
function lerpValues(a, b, t) {
  if (typeof a === "number" && typeof b === "number") {
    return a + (b - a) * t;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + (b[i] - v) * t);
  }
  return a;
}
function subtractValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v - b[i]);
  }
  return 0;
}
function addValues(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.map((v, i) => v + b[i]);
  }
  return a;
}
function scaleValue(v, s) {
  if (typeof v === "number") {
    return v * s;
  }
  if (Array.isArray(v)) {
    return v.map((x) => x * s);
  }
  return 0;
}
function evaluateExpression(expression, ctx) {
  if (!expression.enabled) return ctx.value;
  switch (expression.type) {
    case "preset":
      return evaluatePreset(expression.name, ctx, expression.params);
    case "function":
      return evaluateFunction(expression.name, ctx, expression.params);
    default:
      return ctx.value;
  }
}
function evaluatePreset(name, ctx, params) {
  switch (name) {
    case "inertia":
      return inertia(ctx, params.amplitude, params.frequency, params.decay);
    case "bounce":
      return bounce(ctx, params.elasticity, params.gravity);
    case "elastic":
      return elastic(ctx, params.amplitude, params.period);
    case "jitter":
      return jitter(ctx, params.frequency, params.amplitude, params.octaves);
    case "repeatAfter":
      return repeatAfter(ctx, params.type, params.numKeyframes);
    case "repeatBefore":
      return repeatBefore(ctx, params.type, params.numKeyframes);
    default:
      return ctx.value;
  }
}
function evaluateFunction(name, ctx, params) {
  if (name in timeExpressions) {
    const fn = timeExpressions[name];
    return fn(ctx.time, ...Object.values(params));
  }
  if (name in mathExpressions) {
    const fn = mathExpressions[name];
    const val = typeof ctx.value === "number" ? ctx.value : ctx.value[0];
    return fn(val, ...Object.values(params));
  }
  return ctx.value;
}

const logger$8 = createLogger("PathMorphing");
const DEFAULT_MORPH_CONFIG = {
  pointMatchingStrategy: "subdivide-shorter",
  correspondenceMethod: "nearest-rotation"
};
function clonePoint$1(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex$1(v) {
  return {
    point: clonePoint$1(v.point),
    inHandle: clonePoint$1(v.inHandle),
    outHandle: clonePoint$1(v.outHandle)
  };
}
function clonePath$1(path) {
  return {
    vertices: path.vertices.map(cloneVertex$1),
    closed: path.closed
  };
}
function distance$2(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerp$1(a, b, t) {
  return a + (b - a) * t;
}
function lerpPoint$1(a, b, t) {
  return {
    x: lerp$1(a.x, b.x, t),
    y: lerp$1(a.y, b.y, t)
  };
}
function addPoints$1(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints$1(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint$2(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function cubicBezierPoint$1(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function splitCubicBezier$1(p0, p1, p2, p3, t) {
  const q0 = lerpPoint$1(p0, p1, t);
  const q1 = lerpPoint$1(p1, p2, t);
  const q2 = lerpPoint$1(p2, p3, t);
  const r0 = lerpPoint$1(q0, q1, t);
  const r1 = lerpPoint$1(q1, q2, t);
  const s = lerpPoint$1(r0, r1, t);
  return [
    [p0, q0, r0, s],
    // Left segment
    [s, r1, q2, p3]
    // Right segment
  ];
}
function estimateSegmentLength(p0, p1, p2, p3, samples = 10) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= samples; i++) {
    const t = i / samples;
    const curr = cubicBezierPoint$1(p0, p1, p2, p3, t);
    length += distance$2(prev, curr);
    prev = curr;
  }
  return length;
}
function getSegmentControlPoints(path, segmentIndex) {
  const v0 = path.vertices[segmentIndex];
  const v1 = path.vertices[(segmentIndex + 1) % path.vertices.length];
  return {
    p0: v0.point,
    p1: addPoints$1(v0.point, v0.outHandle),
    p2: addPoints$1(v1.point, v1.inHandle),
    p3: v1.point
  };
}
function getSegmentLengths(path, samplesPerSegment = 10) {
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  const lengths = [];
  for (let i = 0; i < numSegments; i++) {
    const { p0, p1, p2, p3 } = getSegmentControlPoints(path, i);
    lengths.push(estimateSegmentLength(p0, p1, p2, p3, samplesPerSegment));
  }
  return lengths;
}
function getPointAtArcLength(path, targetLength, segmentLengths) {
  let accumulated = 0;
  for (let i = 0; i < segmentLengths.length; i++) {
    const segmentLength = segmentLengths[i];
    if (accumulated + segmentLength >= targetLength || i === segmentLengths.length - 1) {
      const localT = segmentLength > 0 ? (targetLength - accumulated) / segmentLength : 0;
      const { p0, p1, p2, p3 } = getSegmentControlPoints(path, i);
      const point = cubicBezierPoint$1(p0, p1, p2, p3, Math.max(0, Math.min(1, localT)));
      return { point, segmentIndex: i, t: localT };
    }
    accumulated += segmentLength;
  }
  const lastVertex = path.vertices[path.vertices.length - 1];
  return {
    point: clonePoint$1(lastVertex.point),
    segmentIndex: segmentLengths.length - 1,
    t: 1
  };
}
function subdivideSegmentAt(path, segmentIndex, t) {
  const result = clonePath$1(path);
  const v0 = result.vertices[segmentIndex];
  const nextIdx = (segmentIndex + 1) % result.vertices.length;
  const v1 = result.vertices[nextIdx];
  const p0 = v0.point;
  const p1 = addPoints$1(v0.point, v0.outHandle);
  const p2 = addPoints$1(v1.point, v1.inHandle);
  const p3 = v1.point;
  const [left, right] = splitCubicBezier$1(p0, p1, p2, p3, t);
  v0.outHandle = subtractPoints$1(left[1], left[0]);
  const newVertex = {
    point: clonePoint$1(left[3]),
    inHandle: subtractPoints$1(left[2], left[3]),
    outHandle: subtractPoints$1(right[1], right[0])
  };
  v1.inHandle = subtractPoints$1(right[2], right[3]);
  result.vertices.splice(segmentIndex + 1, 0, newVertex);
  return result;
}
function subdivideToVertexCount(path, targetCount) {
  if (path.vertices.length >= targetCount) {
    return clonePath$1(path);
  }
  let current = clonePath$1(path);
  const segmentLengths = getSegmentLengths(current);
  segmentLengths.reduce((sum, l) => sum + l, 0);
  while (current.vertices.length < targetCount) {
    const currentLengths = getSegmentLengths(current);
    let maxLength = 0;
    let maxIndex = 0;
    for (let i = 0; i < currentLengths.length; i++) {
      if (currentLengths[i] > maxLength) {
        maxLength = currentLengths[i];
        maxIndex = i;
      }
    }
    current = subdivideSegmentAt(current, maxIndex, 0.5);
  }
  return current;
}
function resamplePath(path, vertexCount) {
  if (vertexCount < 2) {
    return clonePath$1(path);
  }
  const segmentLengths = getSegmentLengths(path);
  const totalLength = segmentLengths.reduce((sum, l) => sum + l, 0);
  if (totalLength === 0) {
    const vertices2 = [];
    for (let i = 0; i < vertexCount; i++) {
      const srcIdx = Math.floor(i * path.vertices.length / vertexCount);
      vertices2.push(cloneVertex$1(path.vertices[srcIdx]));
    }
    return { vertices: vertices2, closed: path.closed };
  }
  const spacing = totalLength / (path.closed ? vertexCount : vertexCount - 1);
  const vertices = [];
  for (let i = 0; i < vertexCount; i++) {
    const targetLength = i * spacing;
    const { point } = getPointAtArcLength(path, targetLength, segmentLengths);
    const prevLength = Math.max(0, targetLength - spacing * 0.33);
    const nextLength = Math.min(totalLength, targetLength + spacing * 0.33);
    const prevPoint = getPointAtArcLength(path, prevLength, segmentLengths).point;
    const nextPoint = getPointAtArcLength(path, nextLength, segmentLengths).point;
    const tangent = {
      x: (nextPoint.x - prevPoint.x) * 0.5,
      y: (nextPoint.y - prevPoint.y) * 0.5
    };
    const handleScale = 0.33;
    vertices.push({
      point: clonePoint$1(point),
      inHandle: scalePoint$2(tangent, -handleScale),
      outHandle: scalePoint$2(tangent, handleScale)
    });
  }
  return { vertices, closed: path.closed };
}
function calculateTravelDistance(source, target, rotationOffset = 0, reversed = false) {
  const n = source.vertices.length;
  let total = 0;
  for (let i = 0; i < n; i++) {
    const srcIdx = i;
    let tgtIdx = (i + rotationOffset + n) % n;
    if (reversed) {
      tgtIdx = (n - 1 - i + rotationOffset + n) % n;
    }
    total += distance$2(source.vertices[srcIdx].point, target.vertices[tgtIdx].point);
  }
  return total;
}
function findOptimalRotation(source, target) {
  const n = source.vertices.length;
  let bestOffset = 0;
  let bestReversed = false;
  let bestDistance = Infinity;
  for (let offset = 0; offset < n; offset++) {
    const dist = calculateTravelDistance(source, target, offset, false);
    if (dist < bestDistance) {
      bestDistance = dist;
      bestOffset = offset;
      bestReversed = false;
    }
    if (source.closed && target.closed) {
      const distRev = calculateTravelDistance(source, target, offset, true);
      if (distRev < bestDistance) {
        bestDistance = distRev;
        bestOffset = offset;
        bestReversed = true;
      }
    }
  }
  return { offset: bestOffset, reversed: bestReversed };
}
function rotateVertices(path, offset, reverse = false) {
  const n = path.vertices.length;
  const vertices = [];
  for (let i = 0; i < n; i++) {
    let srcIdx = (i + offset + n) % n;
    if (reverse) {
      srcIdx = (n - 1 - i + offset + n) % n;
    }
    const srcVertex = path.vertices[srcIdx];
    if (reverse) {
      vertices.push({
        point: clonePoint$1(srcVertex.point),
        inHandle: clonePoint$1(srcVertex.outHandle),
        outHandle: clonePoint$1(srcVertex.inHandle)
      });
    } else {
      vertices.push(cloneVertex$1(srcVertex));
    }
  }
  return { vertices, closed: path.closed };
}
function prepareMorphPaths(source, target, config = {}) {
  const cfg = { ...DEFAULT_MORPH_CONFIG, ...config };
  if (source.vertices.length === 0 || target.vertices.length === 0) {
    logger$8.warn("Cannot morph empty paths");
    return {
      source: clonePath$1(source),
      target: clonePath$1(target),
      rotationOffset: 0,
      reversed: false
    };
  }
  let preparedSource = clonePath$1(source);
  let preparedTarget = clonePath$1(target);
  const sourceCount = preparedSource.vertices.length;
  const targetCount = preparedTarget.vertices.length;
  if (sourceCount !== targetCount) {
    switch (cfg.pointMatchingStrategy) {
      case "subdivide-shorter":
        if (sourceCount < targetCount) {
          preparedSource = subdivideToVertexCount(preparedSource, targetCount);
        } else {
          preparedTarget = subdivideToVertexCount(preparedTarget, sourceCount);
        }
        break;
      case "subdivide-both": {
        const maxCount = Math.max(sourceCount, targetCount);
        preparedSource = subdivideToVertexCount(preparedSource, maxCount);
        preparedTarget = subdivideToVertexCount(preparedTarget, maxCount);
        break;
      }
      case "resample": {
        const count = cfg.resampleCount ?? Math.max(sourceCount, targetCount);
        preparedSource = resamplePath(preparedSource, count);
        preparedTarget = resamplePath(preparedTarget, count);
        break;
      }
    }
  }
  let rotationOffset = 0;
  let reversed = false;
  if (preparedSource.closed && preparedTarget.closed) {
    switch (cfg.correspondenceMethod) {
      case "nearest-rotation":
      case "nearest-distance": {
        const result = findOptimalRotation(preparedSource, preparedTarget);
        rotationOffset = result.offset;
        reversed = result.reversed;
        break;
      }
    }
  }
  if (rotationOffset !== 0 || reversed) {
    preparedTarget = rotateVertices(preparedTarget, rotationOffset, reversed);
  }
  return {
    source: preparedSource,
    target: preparedTarget,
    rotationOffset,
    reversed
  };
}
function morphPaths(source, target, t) {
  t = Math.max(0, Math.min(1, t));
  if (t === 0) return clonePath$1(source);
  if (t === 1) return clonePath$1(target);
  if (source.vertices.length !== target.vertices.length) {
    logger$8.warn("Paths have different vertex counts - use prepareMorphPaths() first");
    const count = Math.min(source.vertices.length, target.vertices.length);
    source = { vertices: source.vertices.slice(0, count), closed: source.closed };
    target = { vertices: target.vertices.slice(0, count), closed: target.closed };
  }
  const vertices = [];
  for (let i = 0; i < source.vertices.length; i++) {
    const srcV = source.vertices[i];
    const tgtV = target.vertices[i];
    vertices.push({
      point: lerpPoint$1(srcV.point, tgtV.point, t),
      inHandle: lerpPoint$1(srcV.inHandle, tgtV.inHandle, t),
      outHandle: lerpPoint$1(srcV.outHandle, tgtV.outHandle, t)
    });
  }
  return { vertices, closed: source.closed };
}
function isBezierPath(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const obj = value;
  if (!Array.isArray(obj.vertices) || typeof obj.closed !== "boolean") {
    return false;
  }
  if (obj.vertices.length > 0) {
    const v = obj.vertices[0];
    if (typeof v !== "object" || v === null) return false;
    if (typeof v.point?.x !== "number") return false;
    if (typeof v.point?.y !== "number") return false;
  }
  return true;
}

class BezierCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 500;
  /**
   * Generate cache key from bezier parameters
   * Uses fixed precision to avoid floating point key variations
   */
  makeKey(outHandle, inHandle, frameDuration, valueDelta) {
    const round = (n) => Math.round(n * 1e4);
    return `${round(outHandle.frame)},${round(outHandle.value)},${round(inHandle.frame)},${round(inHandle.value)},${round(frameDuration)},${round(valueDelta)}`;
  }
  /**
   * Get cached normalized bezier or compute and cache it
   */
  get(outHandle, inHandle, frameDuration, valueDelta) {
    const key = this.makeKey(outHandle, inHandle, frameDuration, valueDelta);
    const cached = this.cache.get(key);
    if (cached) {
      this.cache.delete(key);
      this.cache.set(key, cached);
      return cached;
    }
    const x1 = frameDuration > 0 ? Math.abs(outHandle.frame) / frameDuration : 0.33;
    const y1 = valueDelta !== 0 ? outHandle.value / valueDelta : 0.33;
    const x2 = frameDuration > 0 ? 1 - Math.abs(inHandle.frame) / frameDuration : 0.67;
    const y2 = valueDelta !== 0 ? 1 - inHandle.value / valueDelta : 0.67;
    const normalized = { x1, y1, x2, y2 };
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, normalized);
    return normalized;
  }
  /**
   * Clear the cache (call on project load)
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const bezierCache = new BezierCache();
function findKeyframeIndex(keyframes, frame) {
  let low = 0;
  let high = keyframes.length - 2;
  while (low <= high) {
    const mid = low + high >>> 1;
    const midFrame = keyframes[mid].frame;
    const nextFrame = keyframes[mid + 1].frame;
    if (frame >= midFrame && frame <= nextFrame) {
      return mid;
    } else if (frame < midFrame) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return Math.max(0, Math.min(low, keyframes.length - 2));
}
function getValueDelta(v1, v2) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v2 - v1;
  }
  if (typeof v1 === "object" && v1 !== null && "x" in v1 && "y" in v1 && typeof v2 === "object" && v2 !== null && "x" in v2 && "y" in v2) {
    const dx = v2.x - v1.x;
    const dy = v2.y - v1.y;
    return Math.sqrt(dx * dx + dy * dy) || 1;
  }
  return 1;
}
function interpolateProperty(property, frame, fps = 30, layerId = "") {
  let value;
  if (!property.animated || property.keyframes.length === 0) {
    value = property.value;
  } else {
    const keyframes = property.keyframes;
    if (frame <= keyframes[0].frame) {
      value = keyframes[0].value;
    } else if (frame >= keyframes[keyframes.length - 1].frame) {
      value = keyframes[keyframes.length - 1].value;
    } else {
      const idx = findKeyframeIndex(keyframes, frame);
      const k1 = keyframes[idx];
      const k2 = keyframes[idx + 1];
      const duration = k2.frame - k1.frame;
      const elapsed = frame - k1.frame;
      let t = duration > 0 ? elapsed / duration : 0;
      const interpolation = k1.interpolation || "linear";
      if (interpolation === "hold") {
        value = k1.value;
      } else {
        if (interpolation === "bezier") {
          const valueDelta = getValueDelta(k1.value, k2.value);
          t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
        } else if (interpolation !== "linear" && interpolation in easings) {
          const easingFn = getEasing(interpolation);
          t = easingFn(t);
        } else if (interpolation !== "linear") {
          renderLogger.warn(`Unknown interpolation type: ${interpolation}, using linear`);
        }
        value = interpolateValue$1(k1.value, k2.value, t);
      }
    }
  }
  if (property.expression?.enabled) {
    value = applyPropertyExpression(property, value, frame, fps);
  }
  return value;
}
function applyPropertyExpression(property, value, frame, fps, layerId) {
  const expr = property.expression;
  if (!expr || !expr.enabled) return value;
  const time = frame / fps;
  const velocity = calculateVelocity(property, frame, fps);
  const ctx = {
    time,
    fps,
    value,
    velocity,
    keyframes: property.keyframes
  };
  const expression = {
    type: expr.type,
    name: expr.name,
    params: expr.params,
    enabled: expr.enabled
  };
  const result = evaluateExpression(expression, ctx);
  return result;
}
function calculateVelocity(property, frame, fps) {
  const delta = 0.5;
  const valueBefore = interpolatePropertyBase(property, frame - delta);
  const valueAfter = interpolatePropertyBase(property, frame + delta);
  if (typeof valueBefore === "number" && typeof valueAfter === "number") {
    return (valueAfter - valueBefore) * fps;
  }
  if (typeof valueBefore === "object" && typeof valueAfter === "object") {
    const vb = valueBefore;
    const va = valueAfter;
    if ("x" in vb && "y" in vb) {
      const result = [(va.x - vb.x) * fps, (va.y - vb.y) * fps];
      if ("z" in vb && "z" in va) {
        result.push((va.z - vb.z) * fps);
      }
      return result;
    }
  }
  return 0;
}
function interpolatePropertyBase(property, frame) {
  if (!property.animated || property.keyframes.length === 0) {
    return property.value;
  }
  const keyframes = property.keyframes;
  if (frame <= keyframes[0].frame) {
    return keyframes[0].value;
  }
  if (frame >= keyframes[keyframes.length - 1].frame) {
    return keyframes[keyframes.length - 1].value;
  }
  const idx = findKeyframeIndex(keyframes, frame);
  const k1 = keyframes[idx];
  const k2 = keyframes[idx + 1];
  const duration = k2.frame - k1.frame;
  const elapsed = frame - k1.frame;
  let t = duration > 0 ? elapsed / duration : 0;
  const interpolation = k1.interpolation || "linear";
  if (interpolation === "hold") {
    return k1.value;
  } else if (interpolation === "bezier") {
    const valueDelta = getValueDelta(k1.value, k2.value);
    t = cubicBezierEasing(t, k1.outHandle, k2.inHandle, duration, valueDelta);
  } else if (interpolation !== "linear" && interpolation in easings) {
    const easingFn = getEasing(interpolation);
    t = easingFn(t);
  }
  return interpolateValue$1(k1.value, k2.value, t);
}
function cubicBezierEasing(t, outHandle, inHandle, frameDuration = 1, valueDelta = 1) {
  if (!outHandle.enabled && !inHandle.enabled) {
    return t;
  }
  const { x1, y1, x2, y2 } = bezierCache.get(outHandle, inHandle, frameDuration, valueDelta);
  let guessT = t;
  const EPSILON = 1e-6;
  const MAX_ITERATIONS = 8;
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    const currentX = bezierPoint(guessT, 0, x1, x2, 1);
    const error = currentX - t;
    if (Math.abs(error) < EPSILON) break;
    const currentSlope = bezierDerivative(guessT, 0, x1, x2, 1);
    if (Math.abs(currentSlope) < EPSILON) break;
    guessT -= error / currentSlope;
    guessT = Math.max(0, Math.min(1, guessT));
  }
  return bezierPoint(guessT, 0, y1, y2, 1);
}
function bezierPoint(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
}
function bezierDerivative(t, p0, p1, p2, p3) {
  const mt = 1 - t;
  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
}
function interpolateValue$1(v1, v2, t) {
  if (typeof v1 === "number" && typeof v2 === "number") {
    return v1 + (v2 - v1) * t;
  }
  if (typeof v1 === "object" && v1 !== null && typeof v2 === "object" && v2 !== null && "x" in v1 && "y" in v1 && "x" in v2 && "y" in v2) {
    const val1 = v1;
    const val2 = v2;
    const result = {
      x: val1.x + (val2.x - val1.x) * t,
      y: val1.y + (val2.y - val1.y) * t
    };
    if ("z" in val1 && "z" in val2) {
      result.z = val1.z + (val2.z - val1.z) * t;
    } else if ("z" in val1) {
      result.z = val1.z * (1 - t);
    } else if ("z" in val2) {
      result.z = val2.z * t;
    }
    return result;
  }
  if (typeof v1 === "string" && typeof v2 === "string" && v1.startsWith("#") && v2.startsWith("#")) {
    return interpolateColor(v1, v2, t);
  }
  if (isBezierPath(v1) && isBezierPath(v2)) {
    return interpolatePath(v1, v2, t);
  }
  return t < 0.5 ? v1 : v2;
}
function interpolateColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1, 3), 16);
  const g1 = parseInt(c1.slice(3, 5), 16);
  const b1 = parseInt(c1.slice(5, 7), 16);
  const r2 = parseInt(c2.slice(1, 3), 16);
  const g2 = parseInt(c2.slice(3, 5), 16);
  const b2 = parseInt(c2.slice(5, 7), 16);
  const r = Math.round(r1 + (r2 - r1) * t);
  const g = Math.round(g1 + (g2 - g1) * t);
  const b = Math.round(b1 + (b2 - b1) * t);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}
const pathMorphCache = /* @__PURE__ */ new Map();
const PATH_MORPH_CACHE_MAX = 100;
function hashBezierPath(path) {
  const v = path.vertices;
  if (v.length === 0) return "empty";
  const first = v[0];
  const last = v[v.length - 1];
  return `${v.length}_${first.point.x.toFixed(1)}_${first.point.y.toFixed(1)}_${last.point.x.toFixed(1)}_${last.point.y.toFixed(1)}_${path.closed ? "c" : "o"}`;
}
function interpolatePath(p1, p2, t) {
  if (t <= 0) return p1;
  if (t >= 1) return p2;
  const key = `${hashBezierPath(p1)}|${hashBezierPath(p2)}`;
  let prepared = pathMorphCache.get(key);
  if (!prepared) {
    prepared = prepareMorphPaths(p1, p2);
    if (pathMorphCache.size >= PATH_MORPH_CACHE_MAX) {
      const firstKey = pathMorphCache.keys().next().value;
      if (firstKey) pathMorphCache.delete(firstKey);
    }
    pathMorphCache.set(key, prepared);
  }
  return morphPaths(prepared.source, prepared.target, t);
}
const EASING_PRESETS_NORMALIZED = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
const EASING_PRESETS = EASING_PRESETS_NORMALIZED;
function getBezierCurvePointNormalized(t, outHandle, inHandle) {
  const x1 = outHandle.x;
  const y1 = outHandle.y;
  const x2 = 1 - inHandle.x;
  const y2 = 1 - inHandle.y;
  return {
    x: bezierPoint(t, 0, x1, x2, 1),
    y: bezierPoint(t, 0, y1, y2, 1)
  };
}
function applyEasing$1(ratio, preset) {
  const t = Math.max(0, Math.min(1, ratio));
  const point = getBezierCurvePointNormalized(t, preset.outHandle, preset.inHandle);
  return point.y;
}

function getFeatureAtFrame(analysis, feature, frame) {
  const clampedFrame = Math.max(0, Math.min(frame, analysis.frameCount - 1));
  switch (feature) {
    case "amplitude":
      return analysis.amplitudeEnvelope[clampedFrame] ?? 0;
    case "rms":
      return analysis.rmsEnergy[clampedFrame] ?? 0;
    case "spectralCentroid":
      return analysis.spectralCentroid[clampedFrame] ?? 0;
    case "sub":
      return analysis.frequencyBands.sub[clampedFrame] ?? 0;
    case "bass":
      return analysis.frequencyBands.bass[clampedFrame] ?? 0;
    case "lowMid":
      return analysis.frequencyBands.lowMid[clampedFrame] ?? 0;
    case "mid":
      return analysis.frequencyBands.mid[clampedFrame] ?? 0;
    case "highMid":
      return analysis.frequencyBands.highMid[clampedFrame] ?? 0;
    case "high":
      return analysis.frequencyBands.high[clampedFrame] ?? 0;
    case "onsets":
      return analysis.onsets.includes(clampedFrame) ? 1 : 0;
    case "spectralFlux":
      return analysis.spectralFlux?.[clampedFrame] ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return analysis.zeroCrossingRate?.[clampedFrame] ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return analysis.spectralRolloff?.[clampedFrame] ?? 0;
    case "spectralFlatness":
    case "flatness":
      return analysis.spectralFlatness?.[clampedFrame] ?? 0;
    case "chromaEnergy":
      return analysis.chromaFeatures?.chromaEnergy[clampedFrame] ?? 0;
    case "chromaC":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[0] ?? 0;
    case "chromaCs":
    case "chromaDb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[1] ?? 0;
    case "chromaD":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[2] ?? 0;
    case "chromaDs":
    case "chromaEb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[3] ?? 0;
    case "chromaE":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[4] ?? 0;
    case "chromaF":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[5] ?? 0;
    case "chromaFs":
    case "chromaGb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[6] ?? 0;
    case "chromaG":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[7] ?? 0;
    case "chromaGs":
    case "chromaAb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[8] ?? 0;
    case "chromaA":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[9] ?? 0;
    case "chromaAs":
    case "chromaBb":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[10] ?? 0;
    case "chromaB":
      return analysis.chromaFeatures?.chroma[clampedFrame]?.[11] ?? 0;
    default:
      return 0;
  }
}
function detectPeaks(weights, config) {
  const { threshold, minPeaksDistance, multiply } = config;
  const amplified = weights.map((w) => Math.min(1, w * multiply));
  const rawPeaks = [];
  for (let i = 1; i < amplified.length - 1; i++) {
    const prev = amplified[i - 1];
    const curr = amplified[i];
    const next = amplified[i + 1];
    if (curr > prev && curr > next && curr >= threshold) {
      rawPeaks.push({ index: i, value: curr });
    }
  }
  const filteredPeaks = [];
  for (const peak of rawPeaks) {
    const recentPeakIndex = filteredPeaks.findIndex(
      (p) => Math.abs(p.index - peak.index) < minPeaksDistance
    );
    if (recentPeakIndex === -1) {
      filteredPeaks.push(peak);
    } else {
      if (peak.value > filteredPeaks[recentPeakIndex].value) {
        filteredPeaks[recentPeakIndex] = peak;
      }
    }
  }
  filteredPeaks.sort((a, b) => a.index - b.index);
  const alternating = new Array(weights.length).fill(0);
  let currentState = 0;
  for (let i = 0; i < weights.length; i++) {
    const isPeak = filteredPeaks.some((p) => p.index === i);
    if (isPeak) {
      currentState = 1 - currentState;
    }
    alternating[i] = currentState;
  }
  return {
    indices: filteredPeaks.map((p) => p.index),
    values: filteredPeaks.map((p) => p.value),
    count: filteredPeaks.length,
    alternating
  };
}
function isBeatAtFrame(analysis, frame) {
  return analysis.onsets.includes(frame);
}
function isPeakAtFrame(peaks, frame) {
  return peaks.indices.includes(frame);
}

/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.

 Copyright (c) 2024 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
// these __PURE__ comments help uglifyjs with dead code removal
//
const SQRT3 = /*#__PURE__*/ Math.sqrt(3.0);
const F2 = 0.5 * (SQRT3 - 1.0);
const G2 = (3.0 - SQRT3) / 6.0;
const F3 = 1.0 / 3.0;
const G3 = 1.0 / 6.0;
// I'm really not sure why this | 0 (basically a coercion to int)
// is making this faster but I get ~5 million ops/sec more on the
// benchmarks across the board or a ~10% speedup.
const fastFloor = (x) => Math.floor(x) | 0;
const grad2 = /*#__PURE__*/ new Float64Array([1, 1,
    -1, 1,
    1, -1,
    -1, -1,
    1, 0,
    -1, 0,
    1, 0,
    -1, 0,
    0, 1,
    0, -1,
    0, 1,
    0, -1]);
// double seems to be faster than single or int's
// probably because most operations are in double precision
const grad3 = /*#__PURE__*/ new Float64Array([1, 1, 0,
    -1, 1, 0,
    1, -1, 0,
    -1, -1, 0,
    1, 0, 1,
    -1, 0, 1,
    1, 0, -1,
    -1, 0, -1,
    0, 1, 1,
    0, -1, 1,
    0, 1, -1,
    0, -1, -1]);
/**
 * Creates a 2D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction2D}
 */
function createNoise2D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating this yields a little ~3% performance improvement.
    const permGrad2x = new Float64Array(perm).map(v => grad2[(v % 12) * 2]);
    const permGrad2y = new Float64Array(perm).map(v => grad2[(v % 12) * 2 + 1]);
    return function noise2D(x, y) {
        // if(!isFinite(x) || !isFinite(y)) return 0;
        let n0 = 0; // Noise contributions from the three corners
        let n1 = 0;
        let n2 = 0;
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y) * F2; // Hairy factor for 2D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const t = (i + j) * G2;
        const X0 = i - t; // Unskew the cell origin back to (x,y) space
        const Y0 = j - t;
        const x0 = x - X0; // The x,y distances from the cell origin
        const y0 = y - Y0;
        // For the 2D case, the simplex shape is an equilateral triangle.
        // Determine which simplex we are in.
        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
        else {
            i1 = 0;
            j1 = 1;
        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
        // c = (3-sqrt(3))/6
        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
        const y2 = y0 - 1.0 + 2.0 * G2;
        // Work out the hashed gradient indices of the three simplex corners
        const ii = i & 255;
        const jj = j & 255;
        // Calculate the contribution from the three corners
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 >= 0) {
            const gi0 = ii + perm[jj];
            const g0x = permGrad2x[gi0];
            const g0y = permGrad2y[gi0];
            t0 *= t0;
            // n0 = t0 * t0 * (grad2[gi0] * x0 + grad2[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            n0 = t0 * t0 * (g0x * x0 + g0y * y0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 >= 0) {
            const gi1 = ii + i1 + perm[jj + j1];
            const g1x = permGrad2x[gi1];
            const g1y = permGrad2y[gi1];
            t1 *= t1;
            // n1 = t1 * t1 * (grad2[gi1] * x1 + grad2[gi1 + 1] * y1);
            n1 = t1 * t1 * (g1x * x1 + g1y * y1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 >= 0) {
            const gi2 = ii + 1 + perm[jj + 1];
            const g2x = permGrad2x[gi2];
            const g2y = permGrad2y[gi2];
            t2 *= t2;
            // n2 = t2 * t2 * (grad2[gi2] * x2 + grad2[gi2 + 1] * y2);
            n2 = t2 * t2 * (g2x * x2 + g2y * y2);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to return values in the interval [-1,1].
        return 70.0 * (n0 + n1 + n2);
    };
}
/**
 * Creates a 3D noise function
 * @param random the random function that will be used to build the permutation table
 * @returns {NoiseFunction3D}
 */
function createNoise3D(random = Math.random) {
    const perm = buildPermutationTable(random);
    // precalculating these seems to yield a speedup of over 15%
    const permGrad3x = new Float64Array(perm).map(v => grad3[(v % 12) * 3]);
    const permGrad3y = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 1]);
    const permGrad3z = new Float64Array(perm).map(v => grad3[(v % 12) * 3 + 2]);
    return function noise3D(x, y, z) {
        let n0, n1, n2, n3; // Noise contributions from the four corners
        // Skew the input space to determine which simplex cell we're in
        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
        const i = fastFloor(x + s);
        const j = fastFloor(y + s);
        const k = fastFloor(z + s);
        const t = (i + j + k) * G3;
        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
        const Y0 = j - t;
        const Z0 = k - t;
        const x0 = x - X0; // The x,y,z distances from the cell origin
        const y0 = y - Y0;
        const z0 = z - Z0;
        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
        // Determine which simplex we are in.
        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
                i1 = 1;
                j1 = 0;
                k1 = 0;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // X Z Y order
            else {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 1;
                j2 = 0;
                k2 = 1;
            } // Z X Y order
        }
        else { // x0<y0
            if (y0 < z0) {
                i1 = 0;
                j1 = 0;
                k1 = 1;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 0;
                j2 = 1;
                k2 = 1;
            } // Y Z X order
            else {
                i1 = 0;
                j1 = 1;
                k1 = 0;
                i2 = 1;
                j2 = 1;
                k2 = 0;
            } // Y X Z order
        }
        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
        // c = 1/6.
        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;
        // Work out the hashed gradient indices of the four simplex corners
        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        // Calculate the contribution from the four corners
        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 < 0)
            n0 = 0.0;
        else {
            const gi0 = ii + perm[jj + perm[kk]];
            t0 *= t0;
            n0 = t0 * t0 * (permGrad3x[gi0] * x0 + permGrad3y[gi0] * y0 + permGrad3z[gi0] * z0);
        }
        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 < 0)
            n1 = 0.0;
        else {
            const gi1 = ii + i1 + perm[jj + j1 + perm[kk + k1]];
            t1 *= t1;
            n1 = t1 * t1 * (permGrad3x[gi1] * x1 + permGrad3y[gi1] * y1 + permGrad3z[gi1] * z1);
        }
        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 < 0)
            n2 = 0.0;
        else {
            const gi2 = ii + i2 + perm[jj + j2 + perm[kk + k2]];
            t2 *= t2;
            n2 = t2 * t2 * (permGrad3x[gi2] * x2 + permGrad3y[gi2] * y2 + permGrad3z[gi2] * z2);
        }
        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 < 0)
            n3 = 0.0;
        else {
            const gi3 = ii + 1 + perm[jj + 1 + perm[kk + 1]];
            t3 *= t3;
            n3 = t3 * t3 * (permGrad3x[gi3] * x3 + permGrad3y[gi3] * y3 + permGrad3z[gi3] * z3);
        }
        // Add contributions from each corner to get the final noise value.
        // The result is scaled to stay just inside [-1,1]
        return 32.0 * (n0 + n1 + n2 + n3);
    };
}
/**
 * Builds a random permutation table.
 * This is exported only for (internal) testing purposes.
 * Do not rely on this export.
 * @private
 */
function buildPermutationTable(random) {
    const tableSize = 512;
    const p = new Uint8Array(tableSize);
    for (let i = 0; i < tableSize / 2; i++) {
        p[i] = i;
    }
    for (let i = 0; i < tableSize / 2 - 1; i++) {
        const r = i + ~~(random() * (256 - i));
        const aux = p[i];
        p[i] = p[r];
        p[r] = aux;
    }
    for (let i = 256; i < tableSize; i++) {
        p[i] = p[i - 256];
    }
    return p;
}

class SeededRandom {
  state;
  initialSeed;
  constructor(seed = 12345) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Reset to initial seed */
  reset() {
    this.state = this.initialSeed;
  }
  /** Reset to a new seed */
  setSeed(seed) {
    this.initialSeed = seed;
    this.state = seed;
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
  /** Get initial seed */
  getSeed() {
    return this.initialSeed;
  }
  /**
   * Get next random number in [0, 1)
   * Uses mulberry32 algorithm
   */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get random integer in range [min, max] inclusive */
  int(min, max) {
    return Math.floor(this.range(min, max + 1));
  }
  /** Get random value with variance: base + random(-variance, +variance) */
  variance(base, variance) {
    return base + (this.next() - 0.5) * 2 * variance;
  }
  /** Get random boolean with given probability of true */
  bool(probability = 0.5) {
    return this.next() < probability;
  }
  /** Get random angle in radians [0, 2) */
  angle() {
    return this.next() * Math.PI * 2;
  }
  /** Get random point in unit circle */
  inCircle() {
    const angle = this.angle();
    const r = Math.sqrt(this.next());
    return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
  }
  /** Get random point on unit sphere */
  onSphere() {
    const theta = this.angle();
    const phi = Math.acos(2 * this.next() - 1);
    return {
      x: Math.sin(phi) * Math.cos(theta),
      y: Math.sin(phi) * Math.sin(theta),
      z: Math.cos(phi)
    };
  }
}
function createDefaultCollisionConfig() {
  return {
    enabled: false,
    particleCollision: false,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: false,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: false,
    floorY: 1,
    ceilingEnabled: false,
    ceilingY: 0,
    wallsEnabled: false,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function createDefaultConnectionConfig() {
  return {
    enabled: false,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: true
  };
}
function createDefaultSystemConfig() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: false,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: createDefaultCollisionConfig()
  };
}
function createDefaultRenderOptions() {
  return {
    blendMode: "additive",
    renderTrails: false,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: false,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: false,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: createDefaultConnectionConfig(),
    spriteSmoothing: true,
    spriteOpacityByAge: true,
    emissiveEnabled: false,
    emissiveIntensity: 2,
    emissiveColor: null
  };
}
class ParticleSystem {
  particles = [];
  emitters = /* @__PURE__ */ new Map();
  gravityWells = /* @__PURE__ */ new Map();
  vortices = /* @__PURE__ */ new Map();
  modulations = [];
  config;
  boundaryMask = null;
  frameCount = 0;
  emissionAccumulators = /* @__PURE__ */ new Map();
  nextParticleId = 0;
  trailHistory = /* @__PURE__ */ new Map();
  // ============================================================================
  // PARTICLE POOL - Recycles dead particles to reduce GC pressure
  // Memory management: Pool limited to maxParticles to prevent unbounded growth
  // ============================================================================
  particlePool = [];
  poolMaxSize = 1e4;
  // Cap pool size
  // Audio reactivity state
  featureOverrides = /* @__PURE__ */ new Map();
  // Turbulence noise generator (seeded for determinism)
  noise2D;
  noiseTime = 0;
  // Render options cache for spatial grid
  renderOptions = createDefaultRenderOptions();
  // Sprite image cache - maps emitter ID to loaded image
  spriteCache = /* @__PURE__ */ new Map();
  // Collision spatial hash grid
  collisionGrid = /* @__PURE__ */ new Map();
  collisionGridCellSize = 50;
  // SEEDED RNG - For deterministic simulation
  // Same seed + same config + same frame = identical particle state
  rng;
  // Spline path provider for emitters with shape='spline'
  // Set by the engine integration (e.g., WeylEngine) to resolve spline paths
  splineProvider = null;
  // Current frame for spline queries
  currentFrame = 0;
  // Sequential emit state per emitter (for 'sequential' emit mode)
  sequentialEmitT = /* @__PURE__ */ new Map();
  constructor(config = {}, seed = 12345) {
    this.config = { ...createDefaultSystemConfig(), ...config };
    this.rng = new SeededRandom(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
    if (this.config.collision) {
      this.collisionGridCellSize = this.config.collision.spatialHashCellSize;
    }
  }
  /**
   * Get the RNG instance (for external access/checkpointing)
   */
  getRng() {
    return this.rng;
  }
  /**
   * Set new seed and reset RNG
   */
  setSeed(seed) {
    this.rng.setSeed(seed);
    this.noise2D = createNoise2D(() => this.rng.next());
  }
  /**
   * Set the spline path provider callback
   * This allows emitters with shape='spline' to query spline positions
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get the current spline provider
   */
  getSplineProvider() {
    return this.splineProvider;
  }
  /**
   * Set the current frame for spline queries
   * Called by the engine before stepping the simulation
   */
  setCurrentFrame(frame) {
    this.currentFrame = frame;
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(emitterId, imageUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.spriteCache.set(emitterId, img);
        const emitter = this.emitters.get(emitterId);
        if (emitter && emitter.sprite) {
          emitter.sprite.imageData = img;
        }
        resolve();
      };
      img.onerror = reject;
      img.src = imageUrl;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(emitterId, image) {
    this.spriteCache.set(emitterId, image);
    const emitter = this.emitters.get(emitterId);
    if (emitter && emitter.sprite) {
      emitter.sprite.imageData = image;
    }
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(emitterId) {
    return this.spriteCache.get(emitterId) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, { ...config });
    this.emissionAccumulators.set(config.id, 0);
    if (config.initialBurst > 0 && config.enabled) {
      const burstCount = Math.floor(config.emissionRate * config.initialBurst * 10);
      for (let i = 0; i < burstCount; i++) {
        this.spawnParticle(config);
      }
    }
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.emissionAccumulators.delete(id);
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(config) {
    this.gravityWells.set(config.id, { ...config });
  }
  updateGravityWell(id, updates) {
    const well = this.gravityWells.get(id);
    if (well) {
      Object.assign(well, updates);
    }
  }
  removeGravityWell(id) {
    this.gravityWells.delete(id);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(config) {
    this.vortices.set(config.id, { ...config });
  }
  updateVortex(id, updates) {
    const vortex = this.vortices.get(id);
    if (vortex) {
      Object.assign(vortex, updates);
    }
  }
  removeVortex(id) {
    this.vortices.delete(id);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(mod) {
    this.modulations.push({ ...mod });
  }
  removeModulation(id) {
    const index = this.modulations.findIndex((m) => m.id === id);
    if (index >= 0) {
      this.modulations.splice(index, 1);
    }
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(mask) {
    this.boundaryMask = mask;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(param, value, emitterId) {
    const key = emitterId ? `${emitterId}:${param}` : `*:${param}`;
    this.featureOverrides.set(key, value);
  }
  getFeatureValue(param, emitterId) {
    return this.featureOverrides.get(`${emitterId}:${param}`) ?? this.featureOverrides.get(`*:${param}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(deltaTime = 1) {
    this.emitters.forEach((emitter, id) => {
      if (!emitter.enabled) return;
      const baseRate = this.getFeatureValue("emissionRate", id) ?? emitter.emissionRate;
      const particlesToEmit = baseRate * deltaTime;
      let accumulated = (this.emissionAccumulators.get(id) || 0) + particlesToEmit;
      while (accumulated >= 1 && this.particles.length < this.config.maxParticles) {
        this.spawnParticle(emitter);
        accumulated -= 1;
      }
      this.emissionAccumulators.set(id, accumulated);
    });
    const windRadians = this.config.windDirection * Math.PI / 180;
    const windX = Math.cos(windRadians) * this.config.windStrength * 1e-3;
    const windY = Math.sin(windRadians) * this.config.windStrength * 1e-3;
    const gravity = this.getFeatureValue("gravity", "*") ?? this.config.gravity;
    const windStrength = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength;
    const actualWindX = windX * (windStrength / Math.max(1, this.config.windStrength));
    const actualWindY = windY * (windStrength / Math.max(1, this.config.windStrength));
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.prevX = p.x;
      p.prevY = p.y;
      if (this.trailHistory.has(p.id)) {
        const trail = this.trailHistory.get(p.id);
        trail.unshift({ x: p.x, y: p.y });
        if (trail.length > 20) trail.pop();
      }
      p.vy += gravity * 1e-3 * deltaTime;
      p.vx += actualWindX * deltaTime;
      p.vy += actualWindY * deltaTime;
      this.gravityWells.forEach((well) => {
        if (!well.enabled) return;
        const dx = well.x - p.x;
        const dy = well.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < well.radius && dist > 1e-3) {
          let force = well.strength * 1e-4;
          switch (well.falloff) {
            case "linear":
              force *= 1 - dist / well.radius;
              break;
            case "quadratic":
              force *= Math.pow(1 - dist / well.radius, 2);
              break;
          }
          const nx = dx / dist;
          const ny = dy / dist;
          p.vx += nx * force * deltaTime;
          p.vy += ny * force * deltaTime;
        }
      });
      this.vortices.forEach((vortex) => {
        if (!vortex.enabled) return;
        const dx = vortex.x - p.x;
        const dy = vortex.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < vortex.radius && dist > 1e-3) {
          const influence = 1 - dist / vortex.radius;
          const strength = vortex.strength * 1e-4 * influence;
          const nx = dx / dist;
          const ny = dy / dist;
          const perpX = -ny;
          const perpY = nx;
          p.vx += perpX * strength * deltaTime;
          p.vy += perpY * strength * deltaTime;
          const inward = vortex.inwardPull * 1e-4 * influence;
          p.vx += nx * inward * deltaTime;
          p.vy += ny * inward * deltaTime;
        }
      });
      this.applyTurbulence(p, deltaTime);
      const frictionFactor = 1 - this.config.friction;
      p.vx *= frictionFactor;
      p.vy *= frictionFactor;
      if (p.angularVelocity !== 0) {
        p.rotation += p.angularVelocity * deltaTime;
      }
      const emitter = this.emitters.get(p.emitterId);
      if (emitter?.sprite?.alignToVelocity && (p.vx !== 0 || p.vy !== 0)) {
        p.rotation = Math.atan2(p.vy, p.vx);
      }
      if (emitter?.sprite?.isSheet && emitter.sprite.totalFrames > 1) {
        this.updateSpriteFrame(p, emitter.sprite, deltaTime);
      }
      p.x += p.vx * deltaTime;
      p.y += p.vy * deltaTime;
      if (this.boundaryMask && this.config.respectMaskBoundary) {
        this.handleBoundaryCollision(p);
      }
      this.handleCanvasBoundary(p);
      this.applyModulations(p);
      p.age += deltaTime;
      if (p.age > p.lifetime) {
        if (!p.isSubParticle) {
          this.triggerSubEmitters(p);
        }
        if (this.particlePool.length < this.poolMaxSize) {
          this.particlePool.push(p);
        }
        this.particles.splice(i, 1);
        this.trailHistory.delete(p.id);
      }
    }
    if (this.config.collision?.enabled && this.config.collision.particleCollision) {
      this.handleParticleCollisions();
    }
    if (this.config.collision?.enabled) {
      this.handleEnvironmentCollisions();
    }
    this.noiseTime += deltaTime;
    this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(p, sprite, _deltaTime) {
    const totalFrames = sprite.totalFrames;
    switch (sprite.playMode) {
      case "loop": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = framesElapsed % totalFrames;
        break;
      }
      case "once": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        p.spriteIndex = Math.min(framesElapsed, totalFrames - 1);
        break;
      }
      case "pingpong": {
        const framesElapsed = Math.floor(p.age * sprite.frameRate / 60);
        const cycle = Math.floor(framesElapsed / (totalFrames - 1));
        const frameInCycle = framesElapsed % (totalFrames - 1);
        p.spriteIndex = cycle % 2 === 0 ? frameInCycle : totalFrames - 1 - frameInCycle;
        break;
      }
      case "random": {
        if (this.rng.bool(0.1)) {
          p.spriteIndex = this.rng.int(0, totalFrames - 1);
        }
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const collision = this.config.collision;
    if (!collision || !collision.particleCollision) return;
    this.collisionGrid.clear();
    const cellSize = this.collisionGridCellSize / 1e3;
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      const key = `${cellX},${cellY}`;
      if (!this.collisionGrid.has(key)) {
        this.collisionGrid.set(key, []);
      }
      this.collisionGrid.get(key).push(p);
    }
    const checked = /* @__PURE__ */ new Set();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x / cellSize);
      const cellY = Math.floor(p.y / cellSize);
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          const cell = this.collisionGrid.get(key);
          if (!cell) continue;
          for (const other of cell) {
            if (other.id <= p.id) continue;
            const pairKey = `${Math.min(p.id, other.id)}-${Math.max(p.id, other.id)}`;
            if (checked.has(pairKey)) continue;
            checked.add(pairKey);
            const radiusP = p.size / 1e3 * collision.particleCollisionRadius;
            const radiusO = other.size / 1e3 * collision.particleCollisionRadius;
            const minDist = radiusP + radiusO;
            const dx2 = other.x - p.x;
            const dy2 = other.y - p.y;
            const distSq = dx2 * dx2 + dy2 * dy2;
            if (distSq < minDist * minDist && distSq > 1e-6) {
              const dist = Math.sqrt(distSq);
              const nx = dx2 / dist;
              const ny = dy2 / dist;
              switch (collision.particleCollisionResponse) {
                case "bounce": {
                  const dvx = p.vx - other.vx;
                  const dvy = p.vy - other.vy;
                  const dvDotN = dvx * nx + dvy * ny;
                  if (dvDotN > 0) {
                    const damping = collision.particleCollisionDamping;
                    p.vx -= dvDotN * nx * damping;
                    p.vy -= dvDotN * ny * damping;
                    other.vx += dvDotN * nx * damping;
                    other.vy += dvDotN * ny * damping;
                    const overlap = minDist - dist;
                    p.x -= nx * overlap * 0.5;
                    p.y -= ny * overlap * 0.5;
                    other.x += nx * overlap * 0.5;
                    other.y += ny * overlap * 0.5;
                  }
                  break;
                }
                case "absorb": {
                  if (p.size > other.size) {
                    p.size += other.size * 0.1;
                    other.age = other.lifetime + 1;
                  } else {
                    other.size += p.size * 0.1;
                    p.age = p.lifetime + 1;
                  }
                  break;
                }
                case "explode": {
                  p.age = p.lifetime + 1;
                  other.age = other.lifetime + 1;
                  break;
                }
              }
              p.collisionCount++;
              other.collisionCount++;
            }
          }
        }
      }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const collision = this.config.collision;
    if (!collision?.enabled) return;
    const bounciness = collision.bounciness;
    const friction = collision.friction;
    for (const p of this.particles) {
      if (collision.floorEnabled && p.y > collision.floorY) {
        p.y = collision.floorY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.ceilingEnabled && p.y < collision.ceilingY) {
        p.y = collision.ceilingY;
        p.vy = -p.vy * bounciness;
        p.vx *= 1 - friction;
        p.collisionCount++;
      }
      if (collision.wallsEnabled) {
        if (p.x < 0) {
          p.x = 0;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx = -p.vx * bounciness;
          p.vy *= 1 - friction;
          p.collisionCount++;
        }
      }
    }
  }
  spawnParticle(emitter) {
    if (this.particles.length >= this.config.maxParticles) return;
    const spawnPos = this.getEmitterSpawnPosition(emitter);
    const baseDirection = spawnPos.direction !== void 0 ? spawnPos.direction : emitter.direction;
    const spreadRad = emitter.spread * Math.PI / 180;
    const baseRad = baseDirection * Math.PI / 180;
    const angle = baseRad + (this.rng.next() - 0.5) * spreadRad;
    const speed = this.rng.variance(emitter.speed, emitter.speedVariance);
    const speedNormalized = speed * 1e-3;
    const size = Math.max(1, this.rng.variance(emitter.size, emitter.sizeVariance));
    const lifetime = Math.max(1, this.rng.variance(emitter.particleLifetime, emitter.lifetimeVariance));
    let rotation = 0;
    let angularVelocity = 0;
    const sprite = emitter.sprite;
    if (sprite && sprite.rotationEnabled) {
      rotation = this.rng.angle();
      const rotSpeed = sprite.rotationSpeed * (Math.PI / 180);
      const rotVariance = sprite.rotationSpeedVariance * (Math.PI / 180);
      angularVelocity = this.rng.variance(rotSpeed, rotVariance);
    }
    if (sprite && sprite.alignToVelocity) {
      rotation = angle;
    }
    let spriteIndex = 0;
    if (sprite && sprite.isSheet && sprite.playMode === "random") {
      spriteIndex = this.rng.int(0, sprite.totalFrames - 1);
    }
    let particle;
    if (this.particlePool.length > 0) {
      particle = this.particlePool.pop();
      particle.id = this.nextParticleId++;
      particle.x = spawnPos.x;
      particle.y = spawnPos.y;
      particle.prevX = spawnPos.x;
      particle.prevY = spawnPos.y;
      particle.vx = Math.cos(angle) * speedNormalized;
      particle.vy = Math.sin(angle) * speedNormalized;
      particle.age = 0;
      particle.lifetime = lifetime;
      particle.size = size;
      particle.baseSize = size;
      particle.color[0] = emitter.color[0];
      particle.color[1] = emitter.color[1];
      particle.color[2] = emitter.color[2];
      particle.color[3] = 255;
      particle.baseColor[0] = emitter.color[0];
      particle.baseColor[1] = emitter.color[1];
      particle.baseColor[2] = emitter.color[2];
      particle.baseColor[3] = 255;
      particle.emitterId = emitter.id;
      particle.isSubParticle = false;
      particle.rotation = rotation;
      particle.angularVelocity = angularVelocity;
      particle.spriteIndex = spriteIndex;
      particle.collisionCount = 0;
    } else {
      particle = {
        id: this.nextParticleId++,
        x: spawnPos.x,
        y: spawnPos.y,
        prevX: spawnPos.x,
        prevY: spawnPos.y,
        vx: Math.cos(angle) * speedNormalized,
        vy: Math.sin(angle) * speedNormalized,
        age: 0,
        lifetime,
        size,
        baseSize: size,
        color: [...emitter.color, 255],
        baseColor: [...emitter.color, 255],
        emitterId: emitter.id,
        isSubParticle: false,
        rotation,
        angularVelocity,
        spriteIndex,
        collisionCount: 0
      };
    }
    this.particles.push(particle);
    this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   * Returns position and optionally a direction override for spline emission
   */
  getEmitterSpawnPosition(emitter) {
    const shape = emitter.shape || "point";
    switch (shape) {
      case "point":
        return { x: emitter.x, y: emitter.y };
      case "line": {
        const t = this.rng.next();
        const halfWidth = emitter.shapeWidth / 2;
        const dirRad = emitter.direction * Math.PI / 180;
        const perpX = -Math.sin(dirRad);
        const perpY = Math.cos(dirRad);
        return {
          x: emitter.x + perpX * (t - 0.5) * halfWidth * 2,
          y: emitter.y + perpY * (t - 0.5) * halfWidth * 2
        };
      }
      case "circle": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const angle = this.rng.angle();
          return {
            x: emitter.x + Math.cos(angle) * radius,
            y: emitter.y + Math.sin(angle) * radius
          };
        } else {
          const angle = this.rng.angle();
          const r = radius * Math.sqrt(this.rng.next());
          return {
            x: emitter.x + Math.cos(angle) * r,
            y: emitter.y + Math.sin(angle) * r
          };
        }
      }
      case "ring": {
        const innerR = emitter.shapeInnerRadius;
        const outerR = emitter.shapeRadius;
        const angle = this.rng.angle();
        const r = Math.sqrt(this.rng.next() * (outerR * outerR - innerR * innerR) + innerR * innerR);
        return {
          x: emitter.x + Math.cos(angle) * r,
          y: emitter.y + Math.sin(angle) * r
        };
      }
      case "box": {
        const halfW = emitter.shapeWidth / 2;
        const halfH = emitter.shapeHeight / 2;
        if (emitter.emitFromEdge) {
          const perimeter = 2 * (emitter.shapeWidth + emitter.shapeHeight);
          const t = this.rng.next() * perimeter;
          if (t < emitter.shapeWidth) {
            return { x: emitter.x - halfW + t, y: emitter.y - halfH };
          } else if (t < emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW, y: emitter.y - halfH + (t - emitter.shapeWidth) };
          } else if (t < 2 * emitter.shapeWidth + emitter.shapeHeight) {
            return { x: emitter.x + halfW - (t - emitter.shapeWidth - emitter.shapeHeight), y: emitter.y + halfH };
          } else {
            return { x: emitter.x - halfW, y: emitter.y + halfH - (t - 2 * emitter.shapeWidth - emitter.shapeHeight) };
          }
        } else {
          return {
            x: emitter.x + (this.rng.next() - 0.5) * emitter.shapeWidth,
            y: emitter.y + (this.rng.next() - 0.5) * emitter.shapeHeight
          };
        }
      }
      case "sphere": {
        const radius = emitter.shapeRadius;
        if (emitter.emitFromEdge) {
          const theta = this.rng.angle();
          const phi = Math.acos(2 * this.rng.next() - 1);
          return {
            x: emitter.x + Math.sin(phi) * Math.cos(theta) * radius,
            y: emitter.y + Math.sin(phi) * Math.sin(theta) * radius
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let x, y, z;
          do {
            x = (this.rng.next() - 0.5) * 2;
            y = (this.rng.next() - 0.5) * 2;
            z = (this.rng.next() - 0.5) * 2;
          } while (x * x + y * y + z * z > 1);
          return {
            x: emitter.x + x * radius,
            y: emitter.y + y * radius
          };
        }
      }
      case "spline": {
        return this.getSplineEmitPosition(emitter);
      }
      case "depth-map": {
        return this.getDepthMapEmitPosition(emitter);
      }
      case "mask": {
        return this.getMaskEmitPosition(emitter);
      }
      default:
        return { x: emitter.x, y: emitter.y };
    }
  }
  /**
   * Get emission position along a spline path
   * Returns position and optionally modifies emission direction
   * DETERMINISM: Uses seeded RNG (this.rng) for random positions
   */
  getSplineEmitPosition(emitter) {
    const splinePath = emitter.splinePath;
    if (!splinePath || !this.splineProvider) {
      return { x: emitter.x, y: emitter.y };
    }
    let t;
    switch (splinePath.emitMode) {
      case "start":
        t = splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "end":
        t = 1 - splinePath.parameter * this.rng.next() * 0.1;
        break;
      case "random":
        t = this.rng.next();
        break;
      case "uniform":
        const interval = Math.max(0.01, splinePath.parameter);
        const numSlots = Math.ceil(1 / interval);
        const slot = this.rng.int(0, numSlots - 1);
        t = slot * interval;
        break;
      case "sequential":
        const currentT = this.sequentialEmitT.get(emitter.id) ?? 0;
        t = currentT;
        const speed = Math.max(1e-3, splinePath.parameter);
        let nextT = currentT + speed;
        if (nextT > 1) nextT = nextT - 1;
        this.sequentialEmitT.set(emitter.id, nextT);
        break;
      default:
        t = this.rng.next();
    }
    t = Math.max(0, Math.min(1, t));
    const result = this.splineProvider(splinePath.layerId, t, this.currentFrame);
    if (!result) {
      return { x: emitter.x, y: emitter.y };
    }
    let x = result.point.x;
    let y = result.point.y;
    if (splinePath.offset !== 0) {
      const tangentLength = Math.sqrt(result.tangent.x ** 2 + result.tangent.y ** 2);
      if (tangentLength > 1e-4) {
        const perpX = -result.tangent.y / tangentLength;
        const perpY = result.tangent.x / tangentLength;
        x += perpX * splinePath.offset;
        y += perpY * splinePath.offset;
      }
    }
    let direction;
    if (splinePath.alignToPath) {
      const tangentAngle = Math.atan2(result.tangent.y, result.tangent.x) * (180 / Math.PI);
      if (splinePath.bidirectional && this.rng.bool(0.5)) {
        direction = tangentAngle + 180;
      } else {
        direction = tangentAngle;
      }
      direction += 90;
    }
    return { x, y, direction };
  }
  /**
   * Get emission position from depth map
   * Emits particles from positions where depth values fall within the configured range
   * Uses cached emission points for performance
   */
  getDepthMapEmitPosition(emitter) {
    const config = emitter.depthMapEmission;
    if (!config) {
      return { x: emitter.x, y: emitter.y };
    }
    const cacheKey = `depth_${config.sourceLayerId}`;
    let emissionPoints = this.imageEmissionCache.get(cacheKey);
    if (!emissionPoints) {
      emissionPoints = this.sampleDepthMapEmissionPoints(config);
      this.imageEmissionCache.set(cacheKey, emissionPoints);
    }
    if (emissionPoints.length === 0) {
      return { x: emitter.x, y: emitter.y };
    }
    const idx = this.rng.int(0, emissionPoints.length - 1);
    const point = emissionPoints[idx];
    return { x: point.x + emitter.x, y: point.y + emitter.y };
  }
  /**
   * Sample valid emission points from a depth map
   */
  sampleDepthMapEmissionPoints(config) {
    const points = [];
    if (!this.depthMapProvider) {
      const gridSize = 20;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const depth = (x + y) / (gridSize * 2);
          if (depth >= config.depthMin && depth <= config.depthMax) {
            points.push({
              x: (x / gridSize - 0.5) * 500,
              y: (y / gridSize - 0.5) * 500,
              depth
            });
          }
        }
      }
      return points;
    }
    const depthData = this.depthMapProvider(config.sourceLayerId, this.currentFrame);
    if (!depthData) {
      return points;
    }
    const sampleRate = Math.max(1, Math.floor(1 / config.density));
    for (let y = 0; y < depthData.height; y += sampleRate) {
      for (let x = 0; x < depthData.width; x += sampleRate) {
        const idx = (y * depthData.width + x) * 4;
        let depthValue = depthData.data[idx] / 255;
        if (config.depthMode === "near-black") {
          depthValue = 1 - depthValue;
        }
        if (depthValue >= config.depthMin && depthValue <= config.depthMax) {
          points.push({
            x: x - depthData.width / 2,
            y: y - depthData.height / 2,
            depth: depthValue
          });
        }
      }
    }
    return points;
  }
  /**
   * Get emission position from mask/matte
   * Emits particles from bright areas of the mask
   */
  getMaskEmitPosition(emitter) {
    const config = emitter.maskEmission;
    if (!config) {
      return { x: emitter.x, y: emitter.y };
    }
    const cacheKey = `mask_${config.sourceLayerId}_${config.channel}_${config.threshold}`;
    let emissionPoints = this.imageEmissionCache.get(cacheKey);
    if (!emissionPoints) {
      emissionPoints = this.sampleMaskEmissionPoints(config);
      this.imageEmissionCache.set(cacheKey, emissionPoints);
    }
    if (emissionPoints.length === 0) {
      return { x: emitter.x, y: emitter.y };
    }
    const idx = this.rng.int(0, emissionPoints.length - 1);
    const point = emissionPoints[idx];
    return { x: point.x + emitter.x, y: point.y + emitter.y };
  }
  /**
   * Sample valid emission points from a mask
   */
  sampleMaskEmissionPoints(config) {
    const points = [];
    if (!this.maskProvider) {
      return points;
    }
    const maskData = this.maskProvider(config.sourceLayerId, this.currentFrame);
    if (!maskData) {
      return points;
    }
    const channelIdx = config.channel === "alpha" ? 3 : config.channel === "red" ? 0 : config.channel === "green" ? 1 : config.channel === "blue" ? 2 : -1;
    const sampleRate = Math.max(1, config.sampleRate || 1);
    for (let y = 0; y < maskData.height; y += sampleRate) {
      for (let x = 0; x < maskData.width; x += sampleRate) {
        const idx = (y * maskData.width + x) * 4;
        let value;
        if (channelIdx === -1) {
          value = (maskData.data[idx] * 0.299 + maskData.data[idx + 1] * 0.587 + maskData.data[idx + 2] * 0.114) / 255;
        } else {
          value = maskData.data[idx + channelIdx] / 255;
        }
        if (config.invert) {
          value = 1 - value;
        }
        if (value >= config.threshold) {
          if (this.rng.next() < config.density) {
            points.push({
              x: x - maskData.width / 2,
              y: y - maskData.height / 2
            });
          }
        }
      }
    }
    return points;
  }
  // Cache for image-based emission points
  imageEmissionCache = /* @__PURE__ */ new Map();
  // Provider functions for image data (set by the engine)
  depthMapProvider;
  maskProvider;
  /**
   * Set the depth map provider function
   */
  setDepthMapProvider(provider) {
    this.depthMapProvider = provider;
  }
  /**
   * Set the mask provider function
   */
  setMaskProvider(provider) {
    this.maskProvider = provider;
  }
  /**
   * Clear the image emission cache (call when source layers change)
   */
  clearEmissionCache() {
    this.imageEmissionCache.clear();
  }
  handleBoundaryCollision(p) {
    if (!this.boundaryMask) return;
    const px = Math.floor(p.x * this.boundaryMask.width);
    const py = Math.floor(p.y * this.boundaryMask.height);
    if (px < 0 || px >= this.boundaryMask.width || py < 0 || py >= this.boundaryMask.height) {
      return;
    }
    const idx = (py * this.boundaryMask.width + px) * 4;
    const maskValue = this.boundaryMask.data[idx];
    if (maskValue < 128) {
      switch (this.config.boundaryBehavior) {
        case "bounce":
          p.vx *= -0.8;
          p.vy *= -0.8;
          p.x = p.prevX;
          p.y = p.prevY;
          break;
        case "kill":
          p.age = p.lifetime + 1;
          break;
        case "wrap":
          p.x = this.rng.next();
          p.y = this.rng.next();
          break;
      }
    }
  }
  handleCanvasBoundary(p) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        if (p.x < 0) {
          p.x = 0;
          p.vx *= -0.8;
        }
        if (p.x > 1) {
          p.x = 1;
          p.vx *= -0.8;
        }
        if (p.y < 0) {
          p.y = 0;
          p.vy *= -0.8;
        }
        if (p.y > 1) {
          p.y = 1;
          p.vy *= -0.8;
        }
        break;
      case "kill":
        if (p.x < -0.1 || p.x > 1.1 || p.y < -0.1 || p.y > 1.1) {
          p.age = p.lifetime + 1;
        }
        break;
      case "wrap":
        if (p.x < 0) p.x += 1;
        if (p.x > 1) p.x -= 1;
        if (p.y < 0) p.y += 1;
        if (p.y > 1) p.y -= 1;
        break;
    }
  }
  applyModulations(p) {
    const lifeRatio = p.age / p.lifetime;
    for (const mod of this.modulations) {
      if (mod.emitterId !== "*" && mod.emitterId !== p.emitterId) continue;
      const easingKey = mod.easing;
      const easing = EASING_PRESETS[easingKey] || EASING_PRESETS.linear;
      const easedRatio = applyEasing$1(lifeRatio, easing);
      const value = mod.startValue + (mod.endValue - mod.startValue) * easedRatio;
      switch (mod.property) {
        case "size":
          p.size = p.baseSize * value;
          break;
        case "speed":
          const currentSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
          if (currentSpeed > 1e-4) {
            const scale = value / Math.max(1e-4, currentSpeed * 1e3);
            p.vx *= scale;
            p.vy *= scale;
          }
          break;
        case "opacity":
          p.color[3] = Math.max(0, Math.min(255, p.baseColor[3] * value));
          break;
        case "colorR":
          p.color[0] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorG":
          p.color[1] = Math.max(0, Math.min(255, value * 255));
          break;
        case "colorB":
          p.color[2] = Math.max(0, Math.min(255, value * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(p, deltaTime) {
    const turbFields = this.config.turbulenceFields || [];
    for (const turb of turbFields) {
      if (!turb.enabled) continue;
      const nx = p.x * turb.scale * 1e3;
      const ny = p.y * turb.scale * 1e3;
      const nt = this.noiseTime * turb.evolutionSpeed;
      const angle = this.noise2D(nx + nt, ny + nt) * Math.PI * 2;
      const force = turb.strength * 1e-5;
      p.vx += Math.cos(angle) * force * deltaTime;
      p.vy += Math.sin(angle) * force * deltaTime;
    }
  }
  addTurbulence(config) {
    if (!this.config.turbulenceFields) this.config.turbulenceFields = [];
    this.config.turbulenceFields.push(config);
  }
  updateTurbulence(id, updates) {
    const turb = this.config.turbulenceFields?.find((t) => t.id === id);
    if (turb) Object.assign(turb, updates);
  }
  removeTurbulence(id) {
    if (this.config.turbulenceFields) {
      this.config.turbulenceFields = this.config.turbulenceFields.filter((t) => t.id !== id);
    }
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  /**
   * Trigger sub-emitters when a particle dies
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   */
  triggerSubEmitters(deadParticle) {
    const subEmitters = this.config.subEmitters || [];
    for (const sub of subEmitters) {
      if (!sub.enabled) continue;
      if (sub.parentEmitterId !== "*" && sub.parentEmitterId !== deadParticle.emitterId) continue;
      for (let i = 0; i < sub.spawnCount; i++) {
        const angle = (this.rng.next() - 0.5) * sub.spread * Math.PI / 180;
        const baseAngle = Math.atan2(deadParticle.vy, deadParticle.vx);
        const emitAngle = baseAngle + angle;
        const inheritedSpeed = Math.sqrt(deadParticle.vx ** 2 + deadParticle.vy ** 2) * sub.inheritVelocity;
        const totalSpeed = sub.speed * 1e-3 + inheritedSpeed;
        const particle = {
          id: this.nextParticleId++,
          x: deadParticle.x,
          y: deadParticle.y,
          prevX: deadParticle.x,
          prevY: deadParticle.y,
          vx: Math.cos(emitAngle) * totalSpeed + deadParticle.vx * sub.inheritVelocity,
          vy: Math.sin(emitAngle) * totalSpeed + deadParticle.vy * sub.inheritVelocity,
          age: 0,
          lifetime: sub.lifetime * (1 + (this.rng.next() - 0.5) * 0.2),
          size: sub.size * (1 + (this.rng.next() - 0.5) * sub.sizeVariance / sub.size),
          baseSize: sub.size,
          color: [...sub.color, 255],
          baseColor: [...sub.color, 255],
          emitterId: sub.id,
          isSubParticle: true,
          rotation: deadParticle.rotation,
          // Inherit parent rotation
          angularVelocity: 0,
          spriteIndex: 0,
          collisionCount: 0
        };
        this.particles.push(particle);
        this.trailHistory.set(particle.id, [{ x: particle.x, y: particle.y }]);
      }
    }
  }
  addSubEmitter(config) {
    if (!this.config.subEmitters) this.config.subEmitters = [];
    this.config.subEmitters.push(config);
  }
  updateSubEmitter(id, updates) {
    const sub = this.config.subEmitters?.find((s) => s.id === id);
    if (sub) Object.assign(sub, updates);
  }
  removeSubEmitter(id) {
    if (this.config.subEmitters) {
      this.config.subEmitters = this.config.subEmitters.filter((s) => s.id !== id);
    }
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(emitterId, count) {
    const emitter = this.emitters.get(emitterId);
    if (!emitter || !emitter.enabled) return;
    const burstCount = count ?? emitter.burstCount ?? 20;
    for (let i = 0; i < burstCount; i++) {
      this.spawnParticle(emitter);
    }
  }
  triggerAllBursts() {
    for (const emitter of this.emitters.values()) {
      if (emitter.burstOnBeat && emitter.enabled) {
        this.triggerBurst(emitter.id);
      }
    }
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    const cellSize = this.renderOptions.connections?.maxDistance || 100;
    const cells = /* @__PURE__ */ new Map();
    for (const p of this.particles) {
      const cellX = Math.floor(p.x * 1e3 / cellSize);
      const cellY = Math.floor(p.y * 1e3 / cellSize);
      const key = `${cellX},${cellY}`;
      if (!cells.has(key)) cells.set(key, []);
      cells.get(key).push(p);
    }
    return { cellSize, cells };
  }
  getNeighborParticles(p, grid) {
    const cellX = Math.floor(p.x * 1e3 / grid.cellSize);
    const cellY = Math.floor(p.y * 1e3 / grid.cellSize);
    const neighbors = [];
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const key = `${cellX + dx},${cellY + dy}`;
        const cell = grid.cells.get(key);
        if (cell) neighbors.push(...cell);
      }
    }
    return neighbors;
  }
  renderConnections(ctx, width, height) {
    const config = this.renderOptions.connections;
    if (!config?.enabled || this.particles.length < 2) return;
    const grid = this.buildSpatialGrid();
    const maxDist = config.maxDistance / 1e3;
    const maxDistSq = maxDist * maxDist;
    ctx.lineWidth = config.lineWidth;
    for (const p of this.particles) {
      const neighbors = this.getNeighborParticles(p, grid);
      let connectionCount = 0;
      for (const other of neighbors) {
        if (other.id <= p.id) continue;
        if (connectionCount >= config.maxConnections) break;
        const dx = other.x - p.x;
        const dy = other.y - p.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < maxDistSq) {
          const dist = Math.sqrt(distSq);
          let opacity = config.lineOpacity;
          if (config.fadeByDistance) {
            opacity *= 1 - dist / maxDist;
          }
          const r = Math.round((p.color[0] + other.color[0]) / 2);
          const g = Math.round((p.color[1] + other.color[1]) / 2);
          const b = Math.round((p.color[2] + other.color[2]) / 2);
          ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
          ctx.beginPath();
          ctx.moveTo(p.x * width, p.y * height);
          ctx.lineTo(other.x * width, other.y * height);
          ctx.stroke();
          connectionCount++;
        }
      }
    }
  }
  reset() {
    this.particles = [];
    this.particlePool = [];
    this.frameCount = 0;
    this.trailHistory.clear();
    this.emissionAccumulators.forEach((_, key) => {
      this.emissionAccumulators.set(key, 0);
    });
    this.nextParticleId = 0;
    this.sequentialEmitT.clear();
    this.currentFrame = 0;
  }
  /**
   * Get particle pool statistics for debugging
   */
  getPoolStats() {
    return {
      poolSize: this.particlePool.length,
      maxPoolSize: this.poolMaxSize,
      activeParticles: this.particles.length
    };
  }
  /**
   * Clear the particle pool to free memory
   * Call this when memory pressure is high
   */
  clearPool() {
    this.particlePool = [];
  }
  /**
   * Restore particles from serialized state (for checkpoint restoration)
   * DETERMINISM: Restores exact particle positions for scrub-safe simulation
   *
   * @param particleStates - Array of serialized particle states from a checkpoint
   * @param frameCount - The frame number being restored to
   */
  restoreParticles(particleStates, frameCount) {
    this.particles = [];
    this.trailHistory.clear();
    let maxId = 0;
    for (const state of particleStates) {
      const particle = {
        id: state.id,
        x: state.x,
        y: state.y,
        prevX: state.x,
        // Previous position set to current (no trail initially)
        prevY: state.y,
        vx: state.vx,
        vy: state.vy,
        age: state.age,
        lifetime: state.lifetime,
        size: state.size,
        baseSize: state.size,
        // Base size set to current
        color: [...state.color],
        baseColor: [...state.color],
        emitterId: state.emitterId,
        isSubParticle: false,
        rotation: state.rotation,
        angularVelocity: 0,
        // Default angular velocity
        spriteIndex: 0,
        collisionCount: 0
        // Reset collision count on restore
      };
      this.particles.push(particle);
      maxId = Math.max(maxId, state.id);
    }
    this.nextParticleId = maxId + 1;
    this.frameCount = frameCount;
  }
  warmup() {
    for (let i = 0; i < this.config.warmupPeriod; i++) {
      this.step(1);
    }
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(ctx, width, height, options = createDefaultRenderOptions()) {
    this.renderOptions = options;
    ctx.save();
    switch (options.blendMode) {
      case "additive":
        ctx.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        ctx.globalCompositeOperation = "multiply";
        break;
      case "screen":
        ctx.globalCompositeOperation = "screen";
        break;
      default:
        ctx.globalCompositeOperation = "source-over";
    }
    this.renderConnections(ctx, width, height);
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size;
      if (options.renderTrails) {
        const trail = this.trailHistory.get(p.id);
        if (trail && trail.length > 1) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          const trailLen = Math.min(trail.length, options.trailLength);
          for (let i = 0; i < trailLen; i++) {
            const tp = trail[i];
            const opacity = p.color[3] * Math.pow(options.trailOpacityFalloff, i + 1);
            ctx.strokeStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${opacity / 255})`;
            ctx.lineWidth = size * Math.pow(options.trailOpacityFalloff, i);
            ctx.lineTo(tp.x * width, tp.y * height);
          }
          ctx.stroke();
        }
      }
      if (options.glowEnabled) {
        ctx.shadowBlur = options.glowRadius;
        ctx.shadowColor = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${options.glowIntensity})`;
      } else {
        ctx.shadowBlur = 0;
      }
      if (options.motionBlur && (p.vx !== 0 || p.vy !== 0)) {
        this.renderParticleWithMotionBlur(ctx, p, x, y, size, width, height, options);
      } else {
        this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
      }
    }
    ctx.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(ctx, p, x, y, size, _width, _height, options) {
    const velocityMag = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
    if (velocityMag < 1e-4) {
      this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape);
      return;
    }
    const stretchFactor = options.motionBlurStrength * velocityMag * 500;
    const samples = Math.min(options.motionBlurSamples, 16);
    const dirX = p.vx / velocityMag;
    const dirY = p.vy / velocityMag;
    const stretchDistance = Math.min(stretchFactor * size, size * 10);
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1);
      const sampleOpacity = (1 - t * 0.8) / samples;
      const sampleX = x - dirX * stretchDistance * t;
      const sampleY = y - dirY * stretchDistance * t;
      const sampleSize = size * (1 - t * 0.3);
      const alpha = p.color[3] / 255 * sampleOpacity * samples;
      ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${Math.min(1, alpha)})`;
      this.renderParticleShape(ctx, sampleX, sampleY, sampleSize, null, options.particleShape, p, options);
    }
    ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.color[3] / 255})`;
    this.renderParticleShape(ctx, x, y, size, p.color, options.particleShape, p, options);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(ctx, x, y, size, color, shape, particle, options) {
    if (color) {
      ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
    }
    if (shape === "sprite" && particle) {
      this.renderSprite(ctx, x, y, size, particle, options);
      return;
    }
    const hasRotation = particle && particle.rotation !== 0;
    if (hasRotation && particle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(particle.rotation);
      this.drawShapeAtOrigin(ctx, size, shape);
      ctx.restore();
    } else {
      switch (shape) {
        case "circle":
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case "square":
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
          break;
        case "triangle":
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          break;
        case "star":
          this.drawStar(ctx, x, y, 5, size / 2, size / 4);
          ctx.fill();
          break;
      }
    }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(ctx, size, shape) {
    switch (shape) {
      case "circle":
        ctx.beginPath();
        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
        ctx.fill();
        break;
      case "square":
        ctx.fillRect(-size / 2, -size / 2, size, size);
        break;
      case "triangle":
        ctx.beginPath();
        ctx.moveTo(0, -size / 2);
        ctx.lineTo(-size / 2, size / 2);
        ctx.lineTo(size / 2, size / 2);
        ctx.closePath();
        ctx.fill();
        break;
      case "star":
        this.drawStar(ctx, 0, 0, 5, size / 2, size / 4);
        ctx.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(ctx, x, y, size, particle, options) {
    const emitter = this.emitters.get(particle.emitterId);
    if (!emitter?.sprite?.enabled) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    const sprite = emitter.sprite;
    const image = sprite.imageData || this.spriteCache.get(particle.emitterId);
    if (!image) {
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return;
    }
    ctx.save();
    ctx.imageSmoothingEnabled = options?.spriteSmoothing ?? true;
    let alpha = particle.color[3] / 255;
    if (options?.spriteOpacityByAge) {
      const lifeRatio = particle.age / particle.lifetime;
      if (lifeRatio > 0.8) {
        alpha *= 1 - (lifeRatio - 0.8) / 0.2;
      }
    }
    ctx.globalAlpha = alpha;
    let sx = 0;
    let sy = 0;
    let sw = image.width;
    let sh = image.height;
    if (sprite.isSheet && sprite.columns > 1 || sprite.rows > 1) {
      const frameWidth = image.width / sprite.columns;
      const frameHeight = image.height / sprite.rows;
      const col = particle.spriteIndex % sprite.columns;
      const row = Math.floor(particle.spriteIndex / sprite.columns) % sprite.rows;
      sx = col * frameWidth;
      sy = row * frameHeight;
      sw = frameWidth;
      sh = frameHeight;
    }
    ctx.translate(x, y);
    if (particle.rotation !== 0) {
      ctx.rotate(particle.rotation);
    }
    const halfSize = size / 2;
    ctx.drawImage(
      image,
      sx,
      sy,
      sw,
      sh,
      // Source rectangle
      -halfSize,
      -halfSize,
      size,
      size
      // Destination rectangle
    );
    ctx.restore();
  }
  drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    ctx.beginPath();
    let rotation = -Math.PI / 2;
    for (let i = 0; i < spikes; i++) {
      const outerX = cx + Math.cos(rotation) * outerRadius;
      const outerY = cy + Math.sin(rotation) * outerRadius;
      if (i === 0) {
        ctx.moveTo(outerX, outerY);
      } else {
        ctx.lineTo(outerX, outerY);
      }
      rotation += Math.PI / spikes;
      const innerX = cx + Math.cos(rotation) * innerRadius;
      const innerY = cy + Math.sin(rotation) * innerRadius;
      ctx.lineTo(innerX, innerY);
      rotation += Math.PI / spikes;
    }
    ctx.closePath();
  }
  renderToMask(width, height) {
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    const connConfig = this.renderOptions.connections;
    if (connConfig?.enabled && this.particles.length >= 2) {
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = connConfig.lineWidth * 2;
      this.renderConnections(ctx, width, height);
    }
    ctx.fillStyle = "#000000";
    for (const p of this.particles) {
      const x = p.x * width;
      const y = p.y * height;
      const size = p.size * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
    return ctx.getImageData(0, 0, width, height);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(data) {
    const system = new ParticleSystem(data.config);
    if (data.emitters) {
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
    }
    if (data.modulations) {
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
    }
    return system;
  }
}

class SeededRNG {
  state;
  constructor(seed) {
    this.state = seed;
  }
  /** Reset to initial seed */
  reset(seed) {
    this.state = seed;
  }
  /** Get next random number in [0, 1) */
  next() {
    let t = this.state += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(min, max) {
    return min + this.next() * (max - min);
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(state) {
    this.state = state;
  }
}
class ParticleSimulationController {
  /** The underlying particle system (used for simulation) */
  system;
  /** Configuration (immutable after construction) */
  config;
  /** Master seed for deterministic simulation */
  seed;
  /** Seeded RNG instance */
  rng;
  /** Checkpoint interval (frames between cached states) */
  checkpointInterval;
  /** Cached checkpoints: frame  checkpoint */
  checkpoints;
  /** Last evaluated frame (for optimization) */
  lastEvaluatedFrame = -1;
  /** Last snapshot (cached for repeated access) */
  lastSnapshot = null;
  constructor(config, seed = 12345, checkpointInterval = 30) {
    this.config = { ...config };
    this.seed = seed;
    this.rng = new SeededRNG(seed);
    this.checkpointInterval = checkpointInterval;
    this.checkpoints = /* @__PURE__ */ new Map();
    this.system = new ParticleSystem(config, seed);
    this.createCheckpoint(0);
  }
  /**
   * Evaluate particle state at a specific frame
   *
   * PURE (relative to frame number): Same frame always produces same result.
   *
   * @param frame - Target frame number
   * @returns Immutable ParticleSnapshot
   */
  evaluateAtFrame(frame) {
    if (frame === this.lastEvaluatedFrame && this.lastSnapshot) {
      return this.lastSnapshot;
    }
    const checkpointFrame = this.findNearestCheckpoint(frame);
    this.restoreCheckpoint(checkpointFrame);
    const framesToSimulate = frame - checkpointFrame;
    for (let i = 0; i < framesToSimulate; i++) {
      this.deterministicStep();
      const currentFrame = checkpointFrame + i + 1;
      if (currentFrame % this.checkpointInterval === 0 && !this.checkpoints.has(currentFrame)) {
        this.createCheckpoint(currentFrame);
      }
    }
    const snapshot = this.createSnapshot(frame);
    this.lastEvaluatedFrame = frame;
    this.lastSnapshot = snapshot;
    return snapshot;
  }
  /**
   * Get the underlying particles for rendering
   * NOTE: This is a convenience method; prefer evaluateAtFrame() for determinism
   */
  getParticles() {
    return this.system.getParticles();
  }
  /**
   * Reset controller and clear all checkpoints
   */
  reset() {
    this.system.reset();
    this.rng.reset(this.seed);
    this.checkpoints.clear();
    this.lastEvaluatedFrame = -1;
    this.lastSnapshot = null;
    this.createCheckpoint(0);
  }
  /**
   * Update configuration (clears all checkpoints)
   */
  updateConfig(updates) {
    Object.assign(this.config, updates);
    this.system.setConfig(updates);
    this.reset();
  }
  /**
   * Get current seed
   */
  getSeed() {
    return this.seed;
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  /**
   * Find the frame number of the nearest checkpoint at or before target
   */
  findNearestCheckpoint(targetFrame) {
    let nearest = 0;
    for (const frame of this.checkpoints.keys()) {
      if (frame <= targetFrame && frame > nearest) {
        nearest = frame;
      }
    }
    return nearest;
  }
  /**
   * Create a checkpoint at the current state
   * DETERMINISM: Captures RNG state for exact restoration
   */
  createCheckpoint(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    const checkpoint = {
      frame,
      particles,
      emissionAccumulators: /* @__PURE__ */ new Map(),
      // Would need access to system internals
      nextParticleId: particles.length > 0 ? Math.max(...particles.map((p) => p.id)) + 1 : 0,
      noiseTime: 0,
      // Would need access to system internals
      frameCount: frame,
      // Capture RNG state from the particle system for deterministic restoration
      rngState: this.system.getRng().getState()
    };
    this.checkpoints.set(frame, checkpoint);
  }
  /**
   * Restore state from a checkpoint
   * DETERMINISM: Restores exact RNG state for reproducible continuation
   */
  restoreCheckpoint(frame) {
    const checkpoint = this.checkpoints.get(frame);
    if (!checkpoint) {
      throw new Error(`No checkpoint at frame ${frame}`);
    }
    this.system.getRng().setState(checkpoint.rngState);
    this.rng.setState(checkpoint.rngState);
    this.system.restoreParticles(checkpoint.particles, checkpoint.frame);
  }
  /**
   * Perform one deterministic simulation step
   * DETERMINISM: ParticleSystem now uses seeded RNG (mulberry32) for all randomness
   */
  deterministicStep() {
    this.system.step(1);
  }
  /**
   * Serialize a particle to immutable state
   */
  serializeParticle(p) {
    return Object.freeze({
      id: p.id,
      x: p.x,
      y: p.y,
      vx: p.vx,
      vy: p.vy,
      age: p.age,
      lifetime: p.lifetime,
      size: p.size,
      color: Object.freeze([...p.color]),
      rotation: p.rotation,
      emitterId: p.emitterId
    });
  }
  /**
   * Create an immutable snapshot of current state
   * DETERMINISM: No timestamps - only deterministic values
   */
  createSnapshot(frame) {
    const particles = this.system.getParticles().map((p) => this.serializeParticle(p));
    return Object.freeze({
      frame,
      particles: Object.freeze(particles),
      count: particles.length,
      seed: this.seed,
      rngState: this.system.getRng().getState()
    });
  }
}
class ParticleSimulationRegistry {
  controllers = /* @__PURE__ */ new Map();
  /**
   * Get or create a controller for a layer
   */
  getController(layerId, config, seed) {
    let controller = this.controllers.get(layerId);
    if (!controller) {
      controller = new ParticleSimulationController(config, seed ?? this.generateSeed(layerId));
      this.controllers.set(layerId, controller);
    }
    return controller;
  }
  /**
   * Evaluate particles for a layer at a frame
   */
  evaluateLayer(layerId, frame, config, seed) {
    const controller = this.getController(layerId, config, seed);
    return controller.evaluateAtFrame(frame);
  }
  /**
   * Reset a specific layer's controller
   */
  resetLayer(layerId) {
    const controller = this.controllers.get(layerId);
    if (controller) {
      controller.reset();
    }
  }
  /**
   * Clear all controllers
   */
  clear() {
    this.controllers.clear();
  }
  /**
   * Generate deterministic seed from layer ID
   */
  generateSeed(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
}
const particleSimulationRegistry = new ParticleSimulationRegistry();

class FrameStateCache {
  cache = /* @__PURE__ */ new Map();
  maxSize;
  maxAgeMs;
  constructor(maxSize = 120, maxAgeMs = 3e4) {
    this.maxSize = maxSize;
    this.maxAgeMs = maxAgeMs;
  }
  /**
   * Generate cache key from frame + composition ID
   */
  makeKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Compute a lightweight hash of project state that affects rendering
   * Changes to layers, keyframes, or effects invalidate the cache
   */
  computeProjectHash(project) {
    const comp = project.compositions[project.mainCompositionId];
    if (!comp) return "";
    let hash = 0;
    const str = JSON.stringify({
      layerCount: comp.layers.length,
      layerIds: comp.layers.map((l) => l.id),
      modified: project.meta?.modified || "",
      // Include layer visibility and animation state in hash
      layerStates: comp.layers.map((l) => ({
        id: l.id,
        visible: l.visible,
        inPoint: l.inPoint,
        outPoint: l.outPoint,
        kfCount: l.properties.reduce((sum, p) => sum + (p.keyframes?.length || 0), 0)
      }))
    });
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  /**
   * Get cached frame state if valid
   */
  get(frame, compositionId, projectHash) {
    const key = this.makeKey(frame, compositionId);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (entry.projectHash !== projectHash || now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.frameState;
  }
  /**
   * Store frame state in cache
   */
  set(frame, compositionId, projectHash, frameState) {
    const key = this.makeKey(frame, compositionId);
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    this.cache.set(key, {
      frameState,
      projectHash,
      timestamp: Date.now()
    });
  }
  /**
   * Invalidate all cached entries
   * Call when project structure changes (layer add/remove, etc.)
   */
  invalidate() {
    this.cache.clear();
  }
  /**
   * Invalidate entries for a specific composition
   */
  invalidateComposition(compositionId) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${compositionId}:`)) {
        this.cache.delete(key);
      }
    }
  }
  /**
   * Get cache statistics for debugging
   */
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: 0
      // Would need hit/miss tracking
    };
  }
}
class MotionEngine {
  /**
   * Frame state cache for memoization
   * Dramatically improves scrubbing performance (90%+ for repeated frames)
   */
  frameCache = new FrameStateCache();
  lastProjectHash = "";
  /**
   * Invalidate the frame cache
   * Call this when project structure changes
   */
  invalidateCache() {
    this.frameCache.invalidate();
    this.lastProjectHash = "";
  }
  /**
   * Get cache statistics for debugging
   */
  getCacheStats() {
    return this.frameCache.getStats();
  }
  /**
   * Evaluate complete frame state
   *
   * PURE FUNCTION: Same inputs always produce same outputs
   * NO SIDE EFFECTS: Does not mutate project, layers, or any external state
   *
   * @param frame - Absolute frame number (0-indexed)
   * @param project - The project data (read-only)
   * @param audioAnalysis - Pre-computed audio analysis (optional)
   * @param activeCameraId - ID of active camera layer (optional)
   * @param useCache - Whether to use memoization cache (default: true)
   * @returns Immutable FrameState snapshot
   */
  evaluate(frame, project, audioAnalysis, activeCameraId, useCache = true) {
    const composition = project.compositions[project.mainCompositionId];
    if (!composition) {
      return this.createEmptyFrameState(frame, project.composition);
    }
    const projectHash = useCache ? this.frameCache.computeProjectHash(project) : "";
    if (useCache) {
      const cached = this.frameCache.get(frame, project.mainCompositionId, projectHash);
      if (cached) {
        return cached;
      }
    }
    const evaluatedLayers = this.evaluateLayers(frame, composition.layers);
    const evaluatedCamera = this.evaluateCamera(
      frame,
      composition.layers,
      activeCameraId ?? null,
      composition.settings
    );
    const evaluatedAudio = this.evaluateAudio(frame, audioAnalysis ?? null);
    const particleSnapshots = this.evaluateParticleLayers(frame, composition.layers);
    const frameState = Object.freeze({
      frame,
      composition: composition.settings,
      layers: Object.freeze(evaluatedLayers),
      camera: evaluatedCamera,
      audio: evaluatedAudio,
      particleSnapshots: Object.freeze(particleSnapshots)
    });
    if (useCache) {
      this.frameCache.set(frame, project.mainCompositionId, projectHash, frameState);
    }
    return frameState;
  }
  /**
   * Evaluate a single property at a given frame
   * Utility method for UI components that need individual values
   */
  evaluateProperty(property, frame) {
    return interpolateProperty(property, frame);
  }
  /**
   * Check if a layer is visible at a given frame
   */
  isLayerVisibleAtFrame(layer, frame) {
    return layer.visible && frame >= layer.inPoint && frame <= layer.outPoint;
  }
  // ============================================================================
  // PRIVATE EVALUATION METHODS
  // ============================================================================
  evaluateLayers(frame, layers) {
    const evaluated = [];
    for (const layer of layers) {
      const inRange = frame >= layer.inPoint && frame <= layer.outPoint;
      const visible = layer.visible && inRange;
      const transform = this.evaluateTransform(frame, layer.transform, layer.threeD);
      const opacity = interpolateProperty(layer.opacity, frame);
      const effects = this.evaluateEffects(frame, layer.effects);
      const properties = this.evaluateLayerProperties(frame, layer);
      evaluated.push(Object.freeze({
        id: layer.id,
        type: layer.type,
        name: layer.name,
        frame,
        // Include frame number for layers that need simulation (particles)
        visible,
        inRange,
        opacity,
        transform: Object.freeze(transform),
        effects: Object.freeze(effects),
        properties: Object.freeze(properties),
        parentId: layer.parentId,
        blendMode: layer.blendMode,
        threeD: layer.threeD,
        layerRef: layer
        // Reference for static data only - NOT for evaluation
      }));
    }
    return evaluated;
  }
  evaluateTransform(frame, transform, is3D) {
    const position = interpolateProperty(transform.position, frame);
    const anchorPoint = interpolateProperty(transform.anchorPoint, frame);
    const scale = interpolateProperty(transform.scale, frame);
    const rotation = interpolateProperty(transform.rotation, frame);
    const result = {
      position: { ...position },
      anchorPoint: { ...anchorPoint },
      scale: { ...scale },
      rotation
    };
    if (is3D) {
      return {
        ...result,
        rotationX: transform.rotationX ? interpolateProperty(transform.rotationX, frame) : 0,
        rotationY: transform.rotationY ? interpolateProperty(transform.rotationY, frame) : 0,
        rotationZ: transform.rotationZ ? interpolateProperty(transform.rotationZ, frame) : rotation
      };
    }
    return result;
  }
  evaluateEffects(frame, effects) {
    return effects.map((effect) => {
      const evaluatedParams = {};
      for (const [key, param] of Object.entries(effect.parameters)) {
        if (this.isAnimatableProperty(param)) {
          evaluatedParams[key] = interpolateProperty(param, frame);
        } else {
          evaluatedParams[key] = param;
        }
      }
      return Object.freeze({
        id: effect.id,
        type: effect.effectKey,
        // Use effectKey as the effect type identifier
        enabled: effect.enabled,
        parameters: Object.freeze(evaluatedParams)
      });
    });
  }
  evaluateLayerProperties(frame, layer) {
    const evaluated = {};
    for (const prop of layer.properties) {
      evaluated[prop.name] = interpolateProperty(prop, frame);
    }
    switch (layer.type) {
      case "text":
        break;
      case "solid":
        break;
      case "depthflow":
        if (layer.data && "animatedZoom" in layer.data) {
          const data = layer.data;
          if (data.animatedZoom) {
            evaluated["zoom"] = interpolateProperty(data.animatedZoom, frame);
          }
          if (data.animatedOffsetX) {
            evaluated["offsetX"] = interpolateProperty(data.animatedOffsetX, frame);
          }
          if (data.animatedOffsetY) {
            evaluated["offsetY"] = interpolateProperty(data.animatedOffsetY, frame);
          }
          if (data.animatedRotation) {
            evaluated["rotation"] = interpolateProperty(data.animatedRotation, frame);
          }
        }
        break;
      case "particles":
        evaluated["_requiresSimulation"] = true;
        break;
    }
    return evaluated;
  }
  evaluateCamera(frame, layers, activeCameraId, compositionSettings) {
    let cameraLayer;
    if (activeCameraId) {
      cameraLayer = layers.find(
        (l) => l.id === activeCameraId && l.type === "camera"
      );
    }
    if (!cameraLayer) {
      cameraLayer = layers.find(
        (l) => l.type === "camera" && l.visible && frame >= l.inPoint && frame <= l.outPoint
      );
    }
    if (!cameraLayer || !cameraLayer.data) {
      return null;
    }
    const cameraData = cameraLayer.data;
    const transform = this.evaluateTransform(frame, cameraLayer.transform, true);
    const compWidth = compositionSettings?.width ?? 1024;
    const compHeight = compositionSettings?.height ?? 1024;
    const centerX = compWidth / 2;
    const centerY = compHeight / 2;
    let position = { x: transform.position.x, y: transform.position.y, z: 0 };
    let target = { x: centerX, y: centerY, z: 0 };
    let fov = 50;
    let focalLength = 50;
    if (cameraData.animatedPosition) {
      const pos = interpolateProperty(cameraData.animatedPosition, frame);
      position = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    }
    if (cameraData.animatedTarget) {
      const tgt = interpolateProperty(cameraData.animatedTarget, frame);
      target = { x: tgt.x, y: tgt.y, z: tgt.z ?? 0 };
    }
    if (cameraData.animatedFov) {
      fov = interpolateProperty(cameraData.animatedFov, frame);
    }
    if (cameraData.animatedFocalLength) {
      focalLength = interpolateProperty(cameraData.animatedFocalLength, frame);
    }
    let focusDistance = cameraData.depthOfField?.focusDistance ?? 1e3;
    let aperture = cameraData.depthOfField?.aperture ?? 2.8;
    let blurLevel = cameraData.depthOfField?.blurLevel ?? 50;
    if (cameraData.animatedFocusDistance) {
      focusDistance = interpolateProperty(cameraData.animatedFocusDistance, frame);
    }
    if (cameraData.animatedAperture) {
      aperture = interpolateProperty(cameraData.animatedAperture, frame);
    }
    if (cameraData.animatedBlurLevel) {
      blurLevel = interpolateProperty(cameraData.animatedBlurLevel, frame);
    }
    return Object.freeze({
      id: cameraLayer.id,
      name: cameraLayer.name,
      position: Object.freeze(position),
      target: Object.freeze(target),
      fov,
      focalLength,
      depthOfField: Object.freeze({
        enabled: cameraData.depthOfField?.enabled ?? false,
        focusDistance,
        aperture,
        blurLevel
      })
    });
  }
  evaluateAudio(frame, analysis) {
    if (!analysis) {
      return Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      });
    }
    return Object.freeze({
      hasAudio: true,
      amplitude: getFeatureAtFrame(analysis, "amplitude", frame),
      rms: getFeatureAtFrame(analysis, "rms", frame),
      bass: getFeatureAtFrame(analysis, "bass", frame),
      mid: getFeatureAtFrame(analysis, "mid", frame),
      high: getFeatureAtFrame(analysis, "high", frame),
      spectralCentroid: getFeatureAtFrame(analysis, "spectralCentroid", frame),
      isBeat: getFeatureAtFrame(analysis, "onsets", frame) > 0.5,
      isOnset: getFeatureAtFrame(analysis, "onsets", frame) > 0,
      bpm: analysis.bpm
    });
  }
  /**
   * Evaluate particle layers through deterministic simulation
   * DETERMINISM: Uses ParticleSimulationRegistry which guarantees same frame = same result
   */
  evaluateParticleLayers(frame, layers) {
    const snapshots = {};
    for (const layer of layers) {
      if (layer.type !== "particles" || !layer.visible) continue;
      if (frame < layer.inPoint || frame > layer.outPoint) continue;
      const data = layer.data;
      if (!data?.systemConfig) continue;
      const config = this.convertToParticleSystemConfig(data);
      const relativeFrame = frame - layer.inPoint;
      const snapshot = particleSimulationRegistry.evaluateLayer(
        layer.id,
        relativeFrame,
        config
      );
      snapshots[layer.id] = snapshot;
    }
    return snapshots;
  }
  /**
   * Convert ParticleLayerData to ParticleSystemConfig
   * Maps the project-level configuration to the simulation config
   */
  convertToParticleSystemConfig(data) {
    const sys = data.systemConfig;
    return {
      maxParticles: sys.maxParticles,
      gravity: sys.gravity,
      windStrength: sys.windStrength,
      windDirection: sys.windDirection,
      warmupPeriod: sys.warmupPeriod,
      respectMaskBoundary: sys.respectMaskBoundary,
      boundaryBehavior: sys.boundaryBehavior,
      friction: sys.friction,
      turbulenceFields: sys.turbulenceFields ?? [],
      subEmitters: sys.subEmitters ?? [],
      collision: {
        enabled: false,
        particleCollision: false,
        particleCollisionRadius: 1,
        particleCollisionResponse: "bounce",
        particleCollisionDamping: 0.5,
        layerCollision: false,
        layerCollisionLayerId: null,
        layerCollisionThreshold: 0.5,
        floorEnabled: false,
        floorY: 1,
        ceilingEnabled: false,
        ceilingY: 0,
        wallsEnabled: false,
        bounciness: 0.8,
        friction: 0.1,
        spatialHashCellSize: 32
      }
    };
  }
  /**
   * Create empty frame state for missing compositions
   * DETERMINISM: No timestamps or non-deterministic values
   */
  createEmptyFrameState(frame, settings) {
    return Object.freeze({
      frame,
      composition: settings,
      layers: Object.freeze([]),
      camera: null,
      audio: Object.freeze({
        hasAudio: false,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: false,
        isOnset: false,
        bpm: 0
      }),
      particleSnapshots: Object.freeze({})
    });
  }
  /**
   * Type guard to check if a value is an AnimatableProperty
   */
  isAnimatableProperty(value) {
    return typeof value === "object" && value !== null && "value" in value && "keyframes" in value && Array.isArray(value.keyframes);
  }
}
const motionEngine = new MotionEngine();

const easingFunctions = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (t) => t,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => {
    if (t === 0) return 0;
    if (t === 1) return 1;
    return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  },
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return c3 * t * t * t - c1 * t * t;
  },
  easeOutBack: (t) => {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  },
  easeInOutBack: (t) => {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;
    return t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
  },
  easeOutElastic: (t) => {
    const c4 = 2 * Math.PI / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  },
  easeInOutElastic: (t) => {
    const c5 = 2 * Math.PI / 4.5;
    return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (t) => 1 - easingFunctions.easeOutBounce(1 - t),
  easeOutBounce: (t) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
      return n1 * t * t;
    } else if (t < 2 / d1) {
      return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
      return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
      return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
  },
  easeInOutBounce: (t) => t < 0.5 ? (1 - easingFunctions.easeOutBounce(1 - 2 * t)) / 2 : (1 + easingFunctions.easeOutBounce(2 * t - 1)) / 2
};

class KeyframeEvaluator {
  // Cache for recent evaluations (cleared per frame batch)
  cache = /* @__PURE__ */ new Map();
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(property, frame) {
    const cacheKey = property.id;
    const cached = this.cache.get(cacheKey);
    if (cached && cached.frame === frame) {
      return cached.value;
    }
    let value;
    if (!property.animated || !property.keyframes || property.keyframes.length === 0) {
      value = property.value;
    } else {
      value = this.evaluateKeyframes(property.keyframes, frame, property.value);
    }
    this.cache.set(cacheKey, { frame, value });
    return value;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(keyframes, frame, defaultValue) {
    const sorted = [...keyframes].sort((a, b) => a.frame - b.frame);
    if (frame <= sorted[0].frame) {
      return sorted[0].value;
    }
    if (frame >= sorted[sorted.length - 1].frame) {
      return sorted[sorted.length - 1].value;
    }
    let prevKeyframe = sorted[0];
    let nextKeyframe = sorted[sorted.length - 1];
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i].frame <= frame && sorted[i + 1].frame > frame) {
        prevKeyframe = sorted[i];
        nextKeyframe = sorted[i + 1];
        break;
      }
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const rawT = frameDiff > 0 ? (frame - prevKeyframe.frame) / frameDiff : 0;
    const easedT = this.applyEasing(rawT, prevKeyframe.interpolation, prevKeyframe, nextKeyframe);
    return this.interpolateValue(prevKeyframe.value, nextKeyframe.value, easedT, defaultValue);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(t, interpolation, prevKeyframe, nextKeyframe) {
    switch (interpolation) {
      case "hold":
        return 0;
      case "linear":
        return t;
      case "bezier":
        return this.evaluateBezier(t, prevKeyframe, nextKeyframe);
      default:
        const easingFn = easingFunctions[interpolation];
        if (easingFn) {
          return easingFn(t);
        }
        return t;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(t, prevKeyframe, nextKeyframe) {
    const outHandle = prevKeyframe.outHandle;
    const inHandle = nextKeyframe.inHandle;
    if (!outHandle?.enabled && !inHandle?.enabled) {
      return t;
    }
    const frameDiff = nextKeyframe.frame - prevKeyframe.frame;
    const p0 = { x: 0, y: 0 };
    const p1 = {
      x: outHandle?.enabled ? Math.min(1, Math.max(0, outHandle.frame / frameDiff)) : 0.33,
      y: outHandle?.enabled ? outHandle.value : 0
    };
    const p2 = {
      x: inHandle?.enabled ? Math.min(1, Math.max(0, 1 + inHandle.frame / frameDiff)) : 0.67,
      y: inHandle?.enabled ? 1 + inHandle.value : 1
    };
    const p3 = { x: 1, y: 1 };
    return this.solveCubicBezier(t, p0.x, p1.x, p2.x, p3.x, p0.y, p1.y, p2.y, p3.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(x, x0, x1, x2, x3, y0, y1, y2, y3) {
    let t = x;
    const epsilon = 1e-4;
    for (let i = 0; i < 10; i++) {
      const currentX = this.cubicBezier(t, x0, x1, x2, x3);
      const diff = currentX - x;
      if (Math.abs(diff) < epsilon) {
        break;
      }
      const derivative = this.cubicBezierDerivative(t, x0, x1, x2, x3);
      if (Math.abs(derivative) < epsilon) {
        break;
      }
      t -= diff / derivative;
      t = Math.max(0, Math.min(1, t));
    }
    return this.cubicBezier(t, y0, y1, y2, y3);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return mt * mt * mt * p0 + 3 * mt * mt * t * p1 + 3 * mt * t * t * p2 + t * t * t * p3;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(t, p0, p1, p2, p3) {
    const mt = 1 - t;
    return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(from, to, t, defaultValue) {
    if (typeof from === "number" && typeof to === "number") {
      return from + (to - from) * t;
    }
    if (this.isPositionLike(from) && this.isPositionLike(to)) {
      return this.interpolatePosition(from, to, t);
    }
    if (typeof from === "string" && typeof to === "string") {
      if (from.startsWith("#") && to.startsWith("#")) {
        return this.interpolateColor(from, to, t);
      }
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return this.interpolateArray(from, to, t);
    }
    return t < 0.5 ? from : to;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(value) {
    return value !== null && typeof value === "object" && "x" in value && "y" in value;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(from, to, t) {
    const result = {
      x: from.x + (to.x - from.x) * t,
      y: from.y + (to.y - from.y) * t
    };
    if ("z" in from || "z" in to) {
      result.z = (from.z ?? 0) + ((to.z ?? 0) - (from.z ?? 0)) * t;
    }
    return result;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(from, to, t) {
    const fromRGB = this.hexToRGB(from);
    const toRGB = this.hexToRGB(to);
    const r = Math.round(fromRGB.r + (toRGB.r - fromRGB.r) * t);
    const g = Math.round(fromRGB.g + (toRGB.g - fromRGB.g) * t);
    const b = Math.round(fromRGB.b + (toRGB.b - fromRGB.b) * t);
    return this.rgbToHex(r, g, b);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(from, to, t) {
    const length = Math.max(from.length, to.length);
    const result = [];
    for (let i = 0; i < length; i++) {
      const fromVal = from[i] ?? 0;
      const toVal = to[i] ?? 0;
      result.push(fromVal + (toVal - fromVal) * t);
    }
    return result;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(r, g, b) {
    return "#" + [r, g, b].map((x) => Math.max(0, Math.min(255, x)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}

class CanvasPool {
  pool = [];
  maxSize = 20;
  // Max pooled canvases
  maxAge = 6e4;
  // 60 second TTL for unused canvases
  /**
   * Acquire a canvas of the specified dimensions
   */
  acquire(width, height) {
    const now = Date.now();
    for (const item of this.pool) {
      if (!item.inUse && item.width === width && item.height === height) {
        item.inUse = true;
        item.lastUsed = now;
        item.ctx.clearRect(0, 0, width, height);
        return { canvas: item.canvas, ctx: item.ctx };
      }
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (this.pool.length < this.maxSize) {
      this.pool.push({
        canvas,
        ctx,
        width,
        height,
        inUse: true,
        lastUsed: now
      });
    }
    return { canvas, ctx };
  }
  /**
   * Release a canvas back to the pool
   * Call this when done with an effect result
   */
  release(canvas) {
    const item = this.pool.find((p) => p.canvas === canvas);
    if (item) {
      item.inUse = false;
      item.lastUsed = Date.now();
    }
  }
  /**
   * Clean up old unused canvases to free memory
   */
  cleanup() {
    const now = Date.now();
    this.pool = this.pool.filter((item) => {
      if (!item.inUse && now - item.lastUsed > this.maxAge) {
        return false;
      }
      return true;
    });
  }
  /**
   * Clear all pooled canvases
   */
  clear() {
    this.pool = [];
  }
  /**
   * Get pool statistics
   */
  getStats() {
    const inUse = this.pool.filter((p) => p.inUse).length;
    return {
      total: this.pool.length,
      inUse,
      available: this.pool.length - inUse
    };
  }
}
const canvasPool = new CanvasPool();
const effectRenderers = /* @__PURE__ */ new Map();
function registerEffectRenderer(effectKey, renderer) {
  effectRenderers.set(effectKey, renderer);
}
function evaluateEffectParameters(effect, frame) {
  const evaluated = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    const animatableProp = param;
    evaluated[key] = interpolateProperty(animatableProp, frame);
  }
  return evaluated;
}
function processEffectStack(effects, inputCanvas, frame, quality = "high") {
  const workCanvas = document.createElement("canvas");
  workCanvas.width = inputCanvas.width;
  workCanvas.height = inputCanvas.height;
  const workCtx = workCanvas.getContext("2d");
  workCtx.drawImage(inputCanvas, 0, 0);
  let current = {
    canvas: workCanvas,
    ctx: workCtx
  };
  for (const effect of effects) {
    if (!effect.enabled) {
      continue;
    }
    const renderer = effectRenderers.get(effect.effectKey);
    if (!renderer) {
      renderLogger.warn(`No renderer registered for effect: ${effect.effectKey}`);
      continue;
    }
    const params = evaluateEffectParameters(effect, frame);
    try {
      current = renderer(current, params);
    } catch (error) {
      renderLogger.error(`Error applying effect ${effect.name}:`, error);
    }
  }
  return current;
}
function createMatchingCanvas(source) {
  return canvasPool.acquire(source.width, source.height);
}
function hasEnabledEffects(effects) {
  return effects.some((e) => e.enabled);
}

function renderMaskPath(ctx, path) {
  if (path.vertices.length < 2) return;
  ctx.beginPath();
  const vertices = path.vertices;
  const n = vertices.length;
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 0; i < n; i++) {
    const current = vertices[i];
    const next = vertices[(i + 1) % n];
    if (!path.closed && i === n - 1) break;
    const cp1x = current.x + current.outTangentX;
    const cp1y = current.y + current.outTangentY;
    const cp2x = next.x + next.inTangentX;
    const cp2y = next.y + next.inTangentY;
    if (cp1x === current.x && cp1y === current.y && cp2x === next.x && cp2y === next.y) {
      ctx.lineTo(next.x, next.y);
    } else {
      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
    }
  }
  if (path.closed) {
    ctx.closePath();
  }
}
function calculateVertexNormal(prev, curr, next) {
  let inDx, inDy;
  if (curr.inTangentX || curr.inTangentY) {
    inDx = -curr.inTangentX;
    inDy = -curr.inTangentY;
  } else {
    inDx = curr.x - prev.x;
    inDy = curr.y - prev.y;
  }
  let outDx, outDy;
  if (curr.outTangentX || curr.outTangentY) {
    outDx = curr.outTangentX;
    outDy = curr.outTangentY;
  } else {
    outDx = next.x - curr.x;
    outDy = next.y - curr.y;
  }
  const inLen = Math.sqrt(inDx * inDx + inDy * inDy);
  if (inLen > 0) {
    inDx /= inLen;
    inDy /= inLen;
  }
  const outLen = Math.sqrt(outDx * outDx + outDy * outDy);
  if (outLen > 0) {
    outDx /= outLen;
    outDy /= outLen;
  }
  const inNx = -inDy;
  const inNy = inDx;
  const outNx = -outDy;
  const outNy = outDx;
  let nx = (inNx + outNx) / 2;
  let ny = (inNy + outNy) / 2;
  const nLen = Math.sqrt(nx * nx + ny * ny);
  if (nLen > 0) {
    nx /= nLen;
    ny /= nLen;
  } else {
    nx = inNx;
    ny = inNy;
  }
  const dot = inNx * outNx + inNy * outNy;
  const miterFactor = 1 / Math.max(0.5, (1 + dot) / 2);
  return {
    nx: nx * Math.min(miterFactor, 2),
    ny: ny * Math.min(miterFactor, 2)
  };
}
function expandMaskPath(path, expansion) {
  if (expansion === 0) return path;
  const vertices = path.vertices;
  if (vertices.length < 2) return path;
  const expandedVertices = [];
  for (let i = 0; i < vertices.length; i++) {
    const prev = vertices[(i - 1 + vertices.length) % vertices.length];
    const curr = vertices[i];
    const next = vertices[(i + 1) % vertices.length];
    const effectivePrev = !path.closed && i === 0 ? curr : prev;
    const effectiveNext = !path.closed && i === vertices.length - 1 ? curr : next;
    const { nx, ny } = calculateVertexNormal(effectivePrev, curr, effectiveNext);
    const offsetX = nx * expansion;
    const offsetY = ny * expansion;
    const handleScale = 1 + expansion / 100;
    expandedVertices.push({
      x: curr.x + offsetX,
      y: curr.y + offsetY,
      // Scale handles to maintain curve shape
      inTangentX: curr.inTangentX * handleScale,
      inTangentY: curr.inTangentY * handleScale,
      outTangentX: curr.outTangentX * handleScale,
      outTangentY: curr.outTangentY * handleScale
    });
  }
  return { ...path, vertices: expandedVertices };
}
function calculateMaskMotion(currentPath, previousPath) {
  if (!previousPath || currentPath.vertices.length !== previousPath.vertices.length) {
    return currentPath.vertices.map(() => ({
      dx: 0,
      dy: 0,
      magnitude: 0,
      angle: 0
    }));
  }
  return currentPath.vertices.map((curr, i) => {
    const prev = previousPath.vertices[i];
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const magnitude = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    return { dx, dy, magnitude, angle };
  });
}
function applyMotionAwareFeather(canvas, baseFeather, motionVectors, motionScale = 1) {
  const width = canvas.width;
  const height = canvas.height;
  let avgDx = 0;
  let avgDy = 0;
  let avgMagnitude = 0;
  for (const motion of motionVectors) {
    avgDx += motion.dx;
    avgDy += motion.dy;
    avgMagnitude += motion.magnitude;
  }
  const count = motionVectors.length || 1;
  avgDx /= count;
  avgDy /= count;
  avgMagnitude /= count;
  if (avgMagnitude < 0.5) {
    if (baseFeather > 0) {
      const ctx2 = canvas.getContext("2d");
      const blurCanvas = document.createElement("canvas");
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext("2d");
      blurCtx.filter = `blur(${baseFeather}px)`;
      blurCtx.drawImage(canvas, 0, 0);
      ctx2.clearRect(0, 0, width, height);
      ctx2.drawImage(blurCanvas, 0, 0);
    }
    return canvas;
  }
  const motionFeather = avgMagnitude * motionScale;
  const len = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
  const normDx = len > 0 ? avgDx / len : 0;
  const normDy = len > 0 ? avgDy / len : 0;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const baseCanvas = document.createElement("canvas");
  baseCanvas.width = width;
  baseCanvas.height = height;
  const baseCtx = baseCanvas.getContext("2d");
  if (baseFeather > 0) {
    baseCtx.filter = `blur(${baseFeather}px)`;
  }
  baseCtx.drawImage(canvas, 0, 0);
  const steps = Math.max(3, Math.min(15, Math.ceil(motionFeather / 2)));
  resultCtx.globalAlpha = 1 / steps;
  for (let i = 0; i < steps; i++) {
    const t = i / (steps - 1) - 0.5;
    const offsetX = normDx * motionFeather * t;
    const offsetY = normDy * motionFeather * t;
    resultCtx.drawImage(baseCanvas, offsetX, offsetY);
  }
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, width, height);
  ctx.globalAlpha = 1;
  ctx.drawImage(resultCanvas, 0, 0);
  return canvas;
}
const previousPathCache = /* @__PURE__ */ new Map();
function getPreviousPath(maskId, currentFrame) {
  const cached = previousPathCache.get(maskId);
  if (cached && cached.frame === currentFrame - 1) {
    return cached.path;
  }
  return null;
}
function cachePath(maskId, frame, path) {
  previousPathCache.set(maskId, { frame, path });
}
function renderMask(mask, width, height, frame) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);
  if (!mask.enabled) return canvas;
  const path = interpolateProperty(mask.path, frame);
  const expansion = interpolateProperty(mask.expansion, frame);
  const opacity = interpolateProperty(mask.opacity, frame);
  const feather = interpolateProperty(mask.feather, frame);
  const expandedPath = expandMaskPath(path, expansion);
  ctx.fillStyle = "white";
  renderMaskPath(ctx, expandedPath);
  ctx.fill();
  if (opacity < 100) {
    const opacityFactor = opacity / 100;
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = Math.round(imageData.data[i] * opacityFactor);
    }
    ctx.putImageData(imageData, 0, 0);
  }
  const previousPath = getPreviousPath(mask.id, frame);
  const motionVectors = calculateMaskMotion(path, previousPath);
  cachePath(mask.id, frame, path);
  const avgMotion = motionVectors.reduce((sum, v) => sum + v.magnitude, 0) / motionVectors.length;
  if (feather > 0 || avgMotion > 1) {
    applyMotionAwareFeather(canvas, feather, motionVectors, 0.5);
  }
  if (mask.inverted) {
    const imageData = ctx.getImageData(0, 0, width, height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] = 255 - imageData.data[i];
      imageData.data[i + 1] = 255 - imageData.data[i + 1];
      imageData.data[i + 2] = 255 - imageData.data[i + 2];
    }
    ctx.putImageData(imageData, 0, 0);
  }
  return canvas;
}
function combineMasks(masks, width, height, frame) {
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const enabledMasks = masks.filter((m) => m.enabled && m.mode !== "none");
  if (enabledMasks.length === 0) {
    resultCtx.fillStyle = "white";
    resultCtx.fillRect(0, 0, width, height);
    return resultCanvas;
  }
  resultCtx.fillStyle = "black";
  resultCtx.fillRect(0, 0, width, height);
  const resultData = resultCtx.getImageData(0, 0, width, height);
  const result = resultData.data;
  for (const mask of enabledMasks) {
    const maskCanvas = renderMask(mask, width, height, frame);
    const maskCtx = maskCanvas.getContext("2d");
    const maskData = maskCtx.getImageData(0, 0, width, height);
    const maskPixels = maskData.data;
    for (let i = 0; i < result.length; i += 4) {
      const maskValue = maskPixels[i];
      switch (mask.mode) {
        case "add":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "subtract":
          result[i] = Math.max(0, result[i] - maskValue);
          result[i + 1] = Math.max(0, result[i + 1] - maskValue);
          result[i + 2] = Math.max(0, result[i + 2] - maskValue);
          break;
        case "intersect":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "lighten":
          result[i] = Math.max(result[i], maskValue);
          result[i + 1] = Math.max(result[i + 1], maskValue);
          result[i + 2] = Math.max(result[i + 2], maskValue);
          break;
        case "darken":
          result[i] = Math.min(result[i], maskValue);
          result[i + 1] = Math.min(result[i + 1], maskValue);
          result[i + 2] = Math.min(result[i + 2], maskValue);
          break;
        case "difference":
          result[i] = Math.abs(result[i] - maskValue);
          result[i + 1] = Math.abs(result[i + 1] - maskValue);
          result[i + 2] = Math.abs(result[i + 2] - maskValue);
          break;
      }
    }
  }
  resultCtx.putImageData(resultData, 0, 0);
  return resultCanvas;
}
function applyTrackMatte(layerCanvas, matteCanvas, matteType) {
  if (matteType === "none") return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const matteScaled = document.createElement("canvas");
  matteScaled.width = width;
  matteScaled.height = height;
  const matteScaledCtx = matteScaled.getContext("2d");
  matteScaledCtx.drawImage(matteCanvas, 0, 0, width, height);
  const matteData = matteScaledCtx.getImageData(0, 0, width, height);
  const matte = matteData.data;
  for (let i = 0; i < layer.length; i += 4) {
    let matteValue;
    switch (matteType) {
      case "alpha":
        matteValue = matte[i + 3] / 255;
        break;
      case "alpha_inverted":
        matteValue = 1 - matte[i + 3] / 255;
        break;
      case "luma":
        matteValue = (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      case "luma_inverted":
        matteValue = 1 - (matte[i] * 0.299 + matte[i + 1] * 0.587 + matte[i + 2] * 0.114) / 255;
        break;
      default:
        matteValue = 1;
    }
    layer[i + 3] = Math.round(layer[i + 3] * matteValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}
function applyMasksToLayer(layerCanvas, masks, frame) {
  if (!masks || masks.length === 0) return layerCanvas;
  const width = layerCanvas.width;
  const height = layerCanvas.height;
  const combinedMask = combineMasks(masks, width, height, frame);
  const resultCanvas = document.createElement("canvas");
  resultCanvas.width = width;
  resultCanvas.height = height;
  const resultCtx = resultCanvas.getContext("2d");
  const layerCtx = layerCanvas.getContext("2d");
  const layerData = layerCtx.getImageData(0, 0, width, height);
  const layer = layerData.data;
  const maskCtx = combinedMask.getContext("2d");
  const maskData = maskCtx.getImageData(0, 0, width, height);
  const mask = maskData.data;
  for (let i = 0; i < layer.length; i += 4) {
    const maskValue = mask[i] / 255;
    layer[i + 3] = Math.round(layer[i + 3] * maskValue);
  }
  resultCtx.putImageData(layerData, 0, 0);
  return resultCanvas;
}

function createDefaultMotionBlurSettings() {
  return {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16,
    pixelBlurLength: 50,
    vectorDetail: 50,
    direction: 0,
    blurLength: 10,
    radialMode: "zoom",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    adaptiveThreshold: 2,
    motionBlurQuality: "normal",
    useGPU: true
  };
}
class MotionBlurProcessor {
  settings;
  frameBuffer = [];
  maxBufferSize = 5;
  // Cached canvases for compositing
  workCanvas;
  workCtx;
  outputCanvas;
  outputCtx;
  constructor(width, height, settings) {
    this.settings = { ...createDefaultMotionBlurSettings(), ...settings };
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
  }
  // ============================================================================
  // SETTINGS
  // ============================================================================
  setSettings(settings) {
    this.settings = { ...this.settings, ...settings };
  }
  getSettings() {
    return { ...this.settings };
  }
  resize(width, height) {
    this.workCanvas = new OffscreenCanvas(width, height);
    this.workCtx = this.workCanvas.getContext("2d");
    this.outputCanvas = new OffscreenCanvas(width, height);
    this.outputCtx = this.outputCanvas.getContext("2d");
    this.frameBuffer = [];
  }
  // ============================================================================
  // VELOCITY CALCULATION
  // ============================================================================
  /**
   * Calculate velocity from transform changes between frames
   */
  calculateVelocity(prevTransform, currTransform, deltaTime = 1) {
    return {
      x: (currTransform.x - prevTransform.x) / deltaTime,
      y: (currTransform.y - prevTransform.y) / deltaTime,
      rotation: (currTransform.rotation - prevTransform.rotation) / deltaTime,
      scale: (currTransform.scaleX - prevTransform.scaleX + (currTransform.scaleY - prevTransform.scaleY)) / 2 / deltaTime
    };
  }
  /**
   * Get velocity magnitude
   */
  getVelocityMagnitude(velocity) {
    return Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
  }
  // ============================================================================
  // BLUR APPLICATION
  // ============================================================================
  /**
   * Apply motion blur to a canvas based on current settings
   */
  applyMotionBlur(sourceCanvas, velocity, frame) {
    if (!this.settings.enabled || this.settings.type === "none") {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    this.addFrameToBuffer(sourceCanvas, velocity, frame);
    switch (this.settings.type) {
      case "standard":
        return this.applyStandardBlur(sourceCanvas, velocity);
      case "pixel":
        return this.applyPixelMotionBlur(sourceCanvas);
      case "directional":
        return this.applyDirectionalBlur(sourceCanvas);
      case "radial":
        return this.applyRadialBlur(sourceCanvas);
      case "vector":
        return this.applyVectorBlur(sourceCanvas, velocity);
      case "adaptive":
        return this.applyAdaptiveBlur(sourceCanvas, velocity);
      default:
        this.outputCtx.drawImage(sourceCanvas, 0, 0);
        return this.outputCanvas;
    }
  }
  /**
   * Add frame to circular buffer
   */
  addFrameToBuffer(canvas, velocity, frame) {
    const cloned = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = cloned.getContext("2d");
    ctx.drawImage(canvas, 0, 0);
    this.frameBuffer.push({
      canvas: cloned,
      velocity,
      timestamp: frame
    });
    while (this.frameBuffer.length > this.maxBufferSize) {
      this.frameBuffer.shift();
    }
  }
  // ============================================================================
  // STANDARD MOTION BLUR (Shutter-based)
  // ============================================================================
  /**
   * Standard shutter-angle motion blur
   * Simulates camera shutter open during frame exposure
   */
  applyStandardBlur(sourceCanvas, velocity) {
    const { shutterAngle, shutterPhase} = this.settings;
    const exposureRatio = shutterAngle / 360;
    const phaseOffset = shutterPhase / 360;
    const blurDistX = velocity.x * exposureRatio;
    const blurDistY = velocity.y * exposureRatio;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5 + phaseOffset;
      const offsetX = blurDistX * t;
      const offsetY = blurDistY * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // PIXEL MOTION BLUR
  // ============================================================================
  /**
   * Pixel Motion Blur - analyzes motion between frames
   * Creates blur based on pixel movement vectors
   */
  applyPixelMotionBlur(sourceCanvas) {
    if (this.frameBuffer.length < 2) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    const { pixelBlurLength, vectorDetail } = this.settings;
    const blurStrength = pixelBlurLength / 100;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const frameCount = Math.min(this.frameBuffer.length, Math.ceil(vectorDetail / 20) + 2);
    const alpha = 1 / frameCount;
    this.outputCtx.globalAlpha = alpha;
    for (let i = this.frameBuffer.length - frameCount; i < this.frameBuffer.length; i++) {
      if (i >= 0) {
        const frame = this.frameBuffer[i];
        const timeOffset = (this.frameBuffer.length - 1 - i) * blurStrength;
        this.outputCtx.save();
        this.outputCtx.translate(
          -frame.velocity.x * timeOffset * 0.5,
          -frame.velocity.y * timeOffset * 0.5
        );
        this.outputCtx.drawImage(frame.canvas, 0, 0);
        this.outputCtx.restore();
      }
    }
    this.outputCtx.globalAlpha = 0.5;
    this.outputCtx.drawImage(sourceCanvas, 0, 0);
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // DIRECTIONAL BLUR
  // ============================================================================
  /**
   * Directional blur - blur in a specific direction
   * Independent of actual motion
   */
  applyDirectionalBlur(sourceCanvas) {
    const { direction, blurLength } = this.settings;
    const angleRad = direction * Math.PI / 180;
    const dx = Math.cos(angleRad) * blurLength;
    const dy = Math.sin(angleRad) * blurLength;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      const offsetX = dx * t;
      const offsetY = dy * t;
      this.outputCtx.drawImage(sourceCanvas, offsetX, offsetY);
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // RADIAL BLUR
  // ============================================================================
  /**
   * Radial blur - zoom or spin blur from center point
   */
  applyRadialBlur(sourceCanvas) {
    const { radialMode, radialAmount, radialCenterX, radialCenterY } = this.settings;
    const centerX = this.outputCanvas.width * radialCenterX;
    const centerY = this.outputCanvas.height * radialCenterY;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = this.getSampleCount();
    const alpha = 1 / samples;
    const amount = radialAmount / 100;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      if (radialMode === "spin") {
        const angle = t * amount * 0.2;
        this.outputCtx.rotate(angle);
      } else {
        const scale = 1 + t * amount * 0.1;
        this.outputCtx.scale(scale, scale);
      }
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // VECTOR MOTION BLUR
  // ============================================================================
  /**
   * Vector-based motion blur using velocity data
   * More accurate than pixel-based for known motion
   */
  applyVectorBlur(sourceCanvas, velocity) {
    const { shutterAngle, vectorDetail } = this.settings;
    const exposureRatio = shutterAngle / 360;
    const blurX = velocity.x * exposureRatio;
    const blurY = velocity.y * exposureRatio;
    const blurRotation = velocity.rotation * exposureRatio * 0.01;
    const blurScale = velocity.scale * exposureRatio * 1e-3;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const samples = Math.ceil(vectorDetail / 100 * this.getSampleCount());
    const alpha = 1 / samples;
    const centerX = this.outputCanvas.width / 2;
    const centerY = this.outputCanvas.height / 2;
    this.outputCtx.globalAlpha = alpha;
    for (let i = 0; i < samples; i++) {
      const t = i / (samples - 1) - 0.5;
      this.outputCtx.save();
      this.outputCtx.translate(centerX, centerY);
      this.outputCtx.translate(blurX * t, blurY * t);
      this.outputCtx.rotate(blurRotation * t);
      this.outputCtx.scale(1 + blurScale * t, 1 + blurScale * t);
      this.outputCtx.translate(-centerX, -centerY);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      this.outputCtx.restore();
    }
    this.outputCtx.globalAlpha = 1;
    return this.outputCanvas;
  }
  // ============================================================================
  // ADAPTIVE BLUR
  // ============================================================================
  /**
   * Adaptive blur - automatically selects blur type based on motion
   */
  applyAdaptiveBlur(sourceCanvas, velocity) {
    const magnitude = this.getVelocityMagnitude(velocity);
    if (magnitude < this.settings.adaptiveThreshold) {
      this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
      this.outputCtx.drawImage(sourceCanvas, 0, 0);
      return this.outputCanvas;
    }
    if (Math.abs(velocity.rotation) > magnitude * 0.5) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "spin";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.rotation) * 2);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    if (Math.abs(velocity.scale) > 0.1) {
      const origMode = this.settings.radialMode;
      this.settings.radialMode = "zoom";
      this.settings.radialAmount = Math.min(100, Math.abs(velocity.scale) * 500);
      const result = this.applyRadialBlur(sourceCanvas);
      this.settings.radialMode = origMode;
      return result;
    }
    return this.applyVectorBlur(sourceCanvas, velocity);
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  /**
   * Get sample count based on quality setting
   */
  getSampleCount() {
    const base = this.settings.samplesPerFrame;
    switch (this.settings.motionBlurQuality) {
      case "draft":
        return Math.max(4, Math.floor(base / 2));
      case "high":
        return Math.min(64, base * 2);
      default:
        return base;
    }
  }
  /**
   * Clear frame buffer (call when seeking or starting new playback)
   */
  clearBuffer() {
    this.frameBuffer = [];
  }
  /**
   * Get motion blur intensity suggestion based on frame rate
   */
  static suggestSettings(fps) {
    const baseAngle = 180;
    const fpsRatio = 24 / fps;
    return {
      shutterAngle: Math.min(360, baseAngle * fpsRatio),
      samplesPerFrame: fps >= 60 ? 8 : fps >= 30 ? 12 : 16
    };
  }
}
const MOTION_BLUR_PRESETS = {
  // Film Standards
  "film_24fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_cinematic": {
    type: "standard",
    shutterAngle: 172.8,
    // 1/48s at 24fps
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  "film_smooth": {
    type: "standard",
    shutterAngle: 270,
    shutterPhase: -90,
    samplesPerFrame: 24
  },
  // Video Standards
  "video_30fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 12
  },
  "video_60fps": {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 8
  },
  // Stylized
  "action_crisp": {
    type: "standard",
    shutterAngle: 90,
    shutterPhase: -45,
    samplesPerFrame: 8
  },
  "dreamy": {
    type: "standard",
    shutterAngle: 360,
    shutterPhase: -180,
    samplesPerFrame: 32
  },
  "staccato": {
    type: "standard",
    shutterAngle: 45,
    shutterPhase: -22.5,
    samplesPerFrame: 4
  },
  // Directional Effects
  "speed_horizontal": {
    type: "directional",
    direction: 0,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "speed_vertical": {
    type: "directional",
    direction: 90,
    blurLength: 20,
    samplesPerFrame: 16
  },
  "diagonal_streak": {
    type: "directional",
    direction: 45,
    blurLength: 30,
    samplesPerFrame: 24
  },
  // Radial Effects
  "zoom_impact": {
    type: "radial",
    radialMode: "zoom",
    radialAmount: 75,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  "spin_vortex": {
    type: "radial",
    radialMode: "spin",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  // Advanced
  "pixel_smooth": {
    type: "pixel",
    pixelBlurLength: 60,
    vectorDetail: 70,
    samplesPerFrame: 16
  },
  "vector_accurate": {
    type: "vector",
    shutterAngle: 180,
    vectorDetail: 90,
    samplesPerFrame: 24
  },
  "adaptive_auto": {
    type: "adaptive",
    shutterAngle: 180,
    adaptiveThreshold: 3,
    samplesPerFrame: 16
  }
};

class BaseLayer {
  /** Unique layer identifier */
  id;
  /** Layer type */
  type;
  /** The Three.js group containing this layer's content */
  group;
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /** Keyframe evaluator for animated properties */
  evaluator;
  /** Layer visibility */
  visible;
  /** Layer locked state */
  locked;
  /** In point (start frame) */
  inPoint;
  /** Out point (end frame) */
  outPoint;
  /** Layer opacity (0-100) */
  opacity;
  /** Layer transform */
  transform;
  /** 3D layer flag */
  threeD;
  /** Blend mode */
  blendMode;
  /** Parent layer ID (for parenting hierarchy) */
  parentId;
  /** Reference to parent layer (set by LayerManager) */
  parentLayer = null;
  /** Driven values override (from property drivers/expressions) */
  drivenValues = /* @__PURE__ */ new Map();
  /** Audio reactive values (from audio analysis mapping) */
  audioReactiveValues = /* @__PURE__ */ new Map();
  /** Effects stack for this layer */
  effects = [];
  /** Layer-level effects enable/disable (fx switch in AE) */
  effectsEnabled = true;
  /** Layer quality mode (draft = faster, best = full quality) */
  quality = "best";
  /** Source canvas for effect processing (lazy initialized) */
  effectSourceCanvas = null;
  /** Flag to track if effects need processing */
  effectsDirty = false;
  // ============================================================================
  // MASK & MATTE SYSTEM
  // ============================================================================
  /** Masks applied to this layer (vector cutouts) */
  masks = [];
  /** Matte source type (uses another layer as alpha/luma source) */
  matteType = "none";
  /** ID of the layer used as matte source */
  matteLayerId = null;
  /** ID of composition containing matte layer (for cross-comp mattes) */
  matteCompositionId = null;
  /** Canvas of matte source layer (set externally by LayerManager) */
  matteCanvas = null;
  /** Preserve transparency - only paint on existing pixels */
  preserveTransparency = false;
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /** Motion path line visualization */
  motionPath = null;
  /** Motion path points (frame positions) */
  motionPathPoints = [];
  /** Whether motion path is visible */
  showMotionPath = false;
  /** Motion path keyframe markers */
  motionPathMarkers = null;
  /** 3D axis gizmo at anchor point */
  axisGizmo = null;
  /** Whether 3D axis gizmo is visible */
  showAxisGizmo = false;
  // ============================================================================
  // MOTION BLUR
  // ============================================================================
  /** Motion blur enabled (layer switch) */
  motionBlur = false;
  /** Motion blur settings */
  motionBlurSettings = null;
  /** Motion blur processor instance */
  motionBlurProcessor = null;
  /** Previous frame transform values for velocity calculation */
  prevTransform = null;
  /** Last frame that motion blur was evaluated */
  motionBlurLastFrame = -1;
  /** Reference to layer data for property access */
  layerData;
  constructor(layerData) {
    this.id = layerData.id;
    this.type = layerData.type;
    this.group = new Group();
    this.group.name = `layer_${this.id}`;
    this.group.userData.layerId = this.id;
    this.group.userData.layerType = this.type;
    this.evaluator = new KeyframeEvaluator();
    this.visible = layerData.visible;
    this.locked = layerData.locked;
    this.inPoint = layerData.inPoint;
    this.outPoint = layerData.outPoint;
    this.opacity = layerData.opacity;
    this.transform = layerData.transform;
    this.threeD = layerData.threeD ?? false;
    this.blendMode = layerData.blendMode ?? "normal";
    this.parentId = layerData.parentId ?? null;
    this.effects = layerData.effects ?? [];
    this.effectsEnabled = layerData.effectsEnabled !== false;
    this.quality = layerData.quality ?? "best";
    this.motionBlur = layerData.motionBlur ?? false;
    this.motionBlurSettings = layerData.motionBlurSettings ?? null;
    this.layerData = layerData;
    this.masks = layerData.masks ?? [];
    this.matteType = layerData.matteType ?? layerData.trackMatteType ?? "none";
    this.matteLayerId = layerData.matteLayerId ?? layerData.trackMatteLayerId ?? null;
    this.matteCompositionId = layerData.matteCompositionId ?? layerData.trackMatteCompositionId ?? null;
    this.preserveTransparency = layerData.preserveTransparency ?? false;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    if (this.blendMode !== "normal") {
      this.applyBlendMode(this.blendMode);
    }
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(frame) {
    const inRange = frame >= this.inPoint && frame <= this.outPoint;
    this.group.visible = this.visible && inRange;
    if (!this.group.visible) {
      return;
    }
    let baseOpacity = this.evaluator.evaluate(this.opacity, frame);
    baseOpacity = this.getDrivenOrBase("opacity", baseOpacity);
    const opacityValue = this.applyAudioModulation(baseOpacity, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(opacityValue);
    this.evaluateTransform(frame);
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(frame) {
    const basePosition = this.evaluator.evaluate(this.transform.position, frame);
    let posX = this.getDrivenOrBase("transform.position.x", basePosition.x);
    let posY = this.getDrivenOrBase("transform.position.y", basePosition.y);
    const posZ = this.getDrivenOrBase("transform.position.z", basePosition.z ?? 0);
    posX = this.applyAudioModulation(posX, "layer.x", "add");
    posY = this.applyAudioModulation(posY, "layer.y", "add");
    const position = { x: posX, y: posY, z: posZ };
    const baseScale = this.evaluator.evaluate(this.transform.scale, frame);
    let scaleX = this.getDrivenOrBase("transform.scale.x", baseScale.x ?? 100);
    let scaleY = this.getDrivenOrBase("transform.scale.y", baseScale.y ?? 100);
    const scaleZ = this.getDrivenOrBase("transform.scale.z", baseScale.z ?? 100);
    const audioScaleMod = this.getAudioReactiveValue("layer.scale");
    if (audioScaleMod !== 0) {
      const scaleFactor = 0.5 + audioScaleMod;
      scaleX *= scaleFactor;
      scaleY *= scaleFactor;
    }
    const scale = { x: scaleX, y: scaleY, z: scaleZ };
    const baseAnchor = this.evaluator.evaluate(this.transform.anchorPoint, frame);
    const anchorPoint = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", baseAnchor.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", baseAnchor.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", baseAnchor.z ?? 0)
    };
    let rotation = 0;
    let rotationX = 0;
    let rotationY = 0;
    if (this.threeD) {
      const baseRotX = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, frame) : 0;
      rotationX = this.getDrivenOrBase("transform.rotationX", baseRotX);
      const baseRotY = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, frame) : 0;
      rotationY = this.getDrivenOrBase("transform.rotationY", baseRotY);
      const baseRotZ = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, frame) : 0;
      rotation = this.getDrivenOrBase("transform.rotationZ", baseRotZ);
    } else {
      const baseRotation = this.evaluator.evaluate(this.transform.rotation, frame);
      rotation = this.getDrivenOrBase("transform.rotation", baseRotation);
    }
    const audioRotMod = this.getAudioReactiveValue("layer.rotation");
    if (audioRotMod !== 0) {
      rotation += audioRotMod * 360;
    }
    this.applyTransform({
      position: {
        x: position.x,
        y: position.y,
        z: position.z
      },
      rotation: {
        x: rotationX,
        y: rotationY,
        z: rotation
      },
      scale: {
        x: scale.x / 100,
        y: scale.y / 100,
        z: scale.z / 100
      },
      anchorPoint: {
        x: anchorPoint.x,
        y: anchorPoint.y,
        z: anchorPoint.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(transform) {
    const { position, rotation, scale, anchorPoint } = transform;
    this.group.position.set(
      position.x - anchorPoint.x,
      -(position.y - anchorPoint.y),
      // Negate for screen coords
      position.z - anchorPoint.z
    );
    this.group.rotation.set(
      MathUtils.degToRad(rotation.x),
      MathUtils.degToRad(rotation.y),
      MathUtils.degToRad(-rotation.z)
    );
    this.group.scale.set(scale.x, scale.y, scale.z);
    this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        if ("opacity" in material) {
          material.opacity = normalizedOpacity;
          material.transparent = normalizedOpacity < 1;
          material.needsUpdate = true;
        }
      }
    });
  }
  // ============================================================================
  // EVALUATED STATE APPLICATION (NEW - SINGLE SOURCE OF TRUTH)
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer visual state.
   * All values are already computed - layers only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * @param state - Pre-evaluated layer state from MotionEngine
   */
  applyEvaluatedState(state) {
    this.group.visible = state.visible;
    if (!state.visible) {
      return;
    }
    const opacity = this.getDrivenOrBase("opacity", state.opacity);
    this.applyOpacity(opacity);
    const transform = state.transform;
    this.applyTransform({
      position: {
        x: this.getDrivenOrBase("transform.position.x", transform.position.x),
        y: this.getDrivenOrBase("transform.position.y", transform.position.y),
        z: this.getDrivenOrBase("transform.position.z", transform.position.z ?? 0)
      },
      rotation: {
        x: this.getDrivenOrBase("transform.rotationX", transform.rotationX ?? 0),
        y: this.getDrivenOrBase("transform.rotationY", transform.rotationY ?? 0),
        z: this.getDrivenOrBase("transform.rotation", transform.rotation)
      },
      scale: {
        x: this.getDrivenOrBase("transform.scale.x", transform.scale.x ?? 100) / 100,
        y: this.getDrivenOrBase("transform.scale.y", transform.scale.y ?? 100) / 100,
        z: this.getDrivenOrBase("transform.scale.z", transform.scale.z ?? 100) / 100
      },
      anchorPoint: {
        x: this.getDrivenOrBase("transform.anchorPoint.x", transform.anchorPoint.x),
        y: this.getDrivenOrBase("transform.anchorPoint.y", transform.anchorPoint.y),
        z: this.getDrivenOrBase("transform.anchorPoint.z", transform.anchorPoint.z ?? 0)
      }
    });
    this.onApplyEvaluatedState(state);
  }
  /**
   * Override in subclasses for type-specific state application
   * Default implementation calls legacy onEvaluateFrame for compatibility
   */
  onApplyEvaluatedState(state) {
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(properties) {
    if (properties.visible !== void 0) {
      this.visible = properties.visible;
      this.group.visible = this.visible;
    }
    if (properties.locked !== void 0) {
      this.locked = properties.locked;
    }
    if (properties.inPoint !== void 0) {
      this.inPoint = properties.inPoint;
    }
    if (properties.outPoint !== void 0) {
      this.outPoint = properties.outPoint;
    }
    if (properties.opacity !== void 0) {
      this.opacity = properties.opacity;
    }
    if (properties.transform !== void 0) {
      this.transform = properties.transform;
    }
    if (properties.threeD !== void 0) {
      this.threeD = properties.threeD;
    }
    if (properties.blendMode !== void 0) {
      this.blendMode = properties.blendMode;
      this.applyBlendMode(this.blendMode);
    }
    if (properties.effects !== void 0) {
      this.setEffects(properties.effects);
    }
    if (properties.masks !== void 0) {
      this.masks = properties.masks;
    }
    const newMatteType = properties.matteType ?? properties.trackMatteType;
    if (newMatteType !== void 0) {
      this.matteType = newMatteType;
    }
    const newMatteLayerId = properties.matteLayerId ?? properties.trackMatteLayerId;
    if (newMatteLayerId !== void 0) {
      this.matteLayerId = newMatteLayerId;
      this.matteCanvas = null;
    }
    const newMatteCompId = properties.matteCompositionId ?? properties.trackMatteCompositionId;
    if (newMatteCompId !== void 0) {
      this.matteCompositionId = newMatteCompId;
      this.matteCanvas = null;
    }
    if (properties.preserveTransparency !== void 0) {
      this.preserveTransparency = properties.preserveTransparency;
    }
    this.onUpdate(properties);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(visible) {
    this.visible = visible;
    this.group.visible = visible;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  /**
   * Get the underlying layer data
   * Used for accessing transform, anchor point, and other layer properties
   */
  getLayerData() {
    return this.layerData;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(values) {
    this.drivenValues = values;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(propertyPath, baseValue) {
    return this.drivenValues.get(propertyPath) ?? baseValue;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(values) {
    this.audioReactiveValues = values;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(target) {
    return this.audioReactiveValues.get(target) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(baseValue, target, mode = "add", range = {}) {
    const audioValue = this.getAudioReactiveValue(target);
    if (audioValue === 0) return baseValue;
    let result;
    switch (mode) {
      case "multiply":
        result = baseValue * (0.5 + audioValue);
        break;
      case "replace":
        result = audioValue;
        break;
      case "add":
      default:
        result = baseValue + audioValue * 100;
        break;
    }
    if (range.min !== void 0) result = Math.max(range.min, result);
    if (range.max !== void 0) result = Math.min(range.max, result);
    return result;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(effects) {
    this.effects = effects;
    this.effectsDirty = true;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   * Also respects the layer-level effectsEnabled flag (fx switch)
   */
  hasEnabledEffects() {
    if (!this.effectsEnabled) {
      return false;
    }
    return hasEnabledEffects(this.effects);
  }
  /**
   * Set layer-level effects enabled state (fx switch)
   */
  setEffectsEnabled(enabled) {
    this.effectsEnabled = enabled;
  }
  /**
   * Get layer-level effects enabled state
   */
  getEffectsEnabled() {
    return this.effectsEnabled;
  }
  /**
   * Set layer quality mode (draft = faster preview, best = full quality)
   */
  setQuality(quality) {
    this.quality = quality;
  }
  /**
   * Get layer quality mode
   */
  getQuality() {
    return this.quality;
  }
  /**
   * Check if layer is in draft quality mode
   */
  isDraftQuality() {
    return this.quality === "draft";
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(frame) {
    if (!this.hasEnabledEffects()) {
      return null;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    try {
      const qualityHint = this.isDraftQuality() ? "draft" : "high";
      const result = processEffectStack(this.effects, sourceCanvas, frame, qualityHint);
      let processedCanvas = result.canvas;
      if (this.motionBlur) {
        const currentTransform = this.getCurrentTransformValues();
        processedCanvas = this.applyMotionBlur(processedCanvas, frame, currentTransform);
      }
      return processedCanvas;
    } catch (error) {
      layerLogger.error(`Error processing effects for layer ${this.id}:`, error);
      return null;
    }
  }
  /**
   * Get current transform values for motion blur calculation
   * Uses evaluated values from the current frame
   */
  getCurrentTransformValues() {
    return {
      position: {
        x: this.group.position.x,
        y: -this.group.position.y,
        // Negate to convert back to screen coords
        z: this.group.position.z
      },
      rotation: MathUtils.radToDeg(-this.group.rotation.z),
      // Convert back
      scale: {
        x: this.group.scale.x * 100,
        y: this.group.scale.y * 100
      }
    };
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(_processedCanvas) {
  }
  // ============================================================================
  // MOTION BLUR PROCESSING
  // ============================================================================
  /**
   * Check if motion blur should be applied
   */
  shouldApplyMotionBlur() {
    return this.motionBlur && this.getSourceCanvas() !== null;
  }
  /**
   * Initialize motion blur processor with layer dimensions
   */
  initializeMotionBlurProcessor(width, height) {
    if (!this.motionBlurProcessor) {
      const settings = this.motionBlurSettings ? {
        enabled: true,
        type: this.motionBlurSettings.type,
        shutterAngle: this.motionBlurSettings.shutterAngle,
        shutterPhase: this.motionBlurSettings.shutterPhase,
        samplesPerFrame: this.motionBlurSettings.samplesPerFrame,
        direction: this.motionBlurSettings.direction,
        blurLength: this.motionBlurSettings.blurLength
      } : { ...createDefaultMotionBlurSettings(), enabled: true };
      this.motionBlurProcessor = new MotionBlurProcessor(width, height, settings);
    } else if (this.motionBlurProcessor.getSettings().shutterAngle !== (this.motionBlurSettings?.shutterAngle ?? 180)) {
      this.motionBlurProcessor.setSettings({
        shutterAngle: this.motionBlurSettings?.shutterAngle ?? 180,
        shutterPhase: this.motionBlurSettings?.shutterPhase ?? -90,
        samplesPerFrame: this.motionBlurSettings?.samplesPerFrame ?? 16
      });
    }
  }
  /**
   * Calculate velocity from current and previous transforms
   */
  calculateTransformVelocity(currentTransform) {
    if (!this.prevTransform) {
      return { x: 0, y: 0, rotation: 0, scale: 0 };
    }
    return {
      x: currentTransform.position.x - this.prevTransform.position.x,
      y: currentTransform.position.y - this.prevTransform.position.y,
      rotation: currentTransform.rotation - this.prevTransform.rotation,
      scale: (currentTransform.scale.x - this.prevTransform.scale.x + (currentTransform.scale.y - this.prevTransform.scale.y)) / 2
    };
  }
  /**
   * Apply motion blur to a canvas based on transform velocity
   * @param sourceCanvas - Canvas to apply motion blur to
   * @param frame - Current frame number
   * @param currentTransform - Current transform values
   * @returns Canvas with motion blur applied, or source if no blur needed
   */
  applyMotionBlur(sourceCanvas, frame, currentTransform) {
    if (!this.motionBlur) {
      return sourceCanvas;
    }
    this.initializeMotionBlurProcessor(sourceCanvas.width, sourceCanvas.height);
    if (!this.motionBlurProcessor) {
      return sourceCanvas;
    }
    const velocity = this.calculateTransformVelocity(currentTransform);
    this.prevTransform = {
      position: { ...currentTransform.position },
      rotation: currentTransform.rotation,
      scale: { ...currentTransform.scale }
    };
    const velocityMagnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
    if (velocityMagnitude < 0.5 && Math.abs(velocity.rotation) < 0.5 && Math.abs(velocity.scale) < 0.01) {
      return sourceCanvas;
    }
    try {
      const offscreen = new OffscreenCanvas(sourceCanvas.width, sourceCanvas.height);
      const ctx = offscreen.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        const blurredOffscreen = this.motionBlurProcessor.applyMotionBlur(offscreen, velocity, frame);
        const resultCanvas = document.createElement("canvas");
        resultCanvas.width = sourceCanvas.width;
        resultCanvas.height = sourceCanvas.height;
        const resultCtx = resultCanvas.getContext("2d");
        if (resultCtx) {
          resultCtx.drawImage(blurredOffscreen, 0, 0);
          return resultCanvas;
        }
      }
    } catch (error) {
      layerLogger.error(`Error applying motion blur to layer ${this.id}:`, error);
    }
    return sourceCanvas;
  }
  /**
   * Set motion blur enabled state
   */
  setMotionBlur(enabled) {
    this.motionBlur = enabled;
    this.layerData.motionBlur = enabled;
    if (!enabled) {
      this.motionBlurProcessor?.clearBuffer();
      this.prevTransform = null;
    }
  }
  /**
   * Update motion blur settings
   */
  setMotionBlurSettings(settings) {
    if (!this.motionBlurSettings) {
      this.motionBlurSettings = {
        type: "standard",
        shutterAngle: 180,
        shutterPhase: -90,
        samplesPerFrame: 16,
        ...settings
      };
    } else {
      Object.assign(this.motionBlurSettings, settings);
    }
    if (this.motionBlurProcessor) {
      this.motionBlurProcessor.setSettings({
        type: this.motionBlurSettings.type,
        shutterAngle: this.motionBlurSettings.shutterAngle,
        shutterPhase: this.motionBlurSettings.shutterPhase,
        samplesPerFrame: this.motionBlurSettings.samplesPerFrame
      });
    }
  }
  // ============================================================================
  // MASK PROCESSING
  // ============================================================================
  /**
   * Check if this layer has any enabled masks
   */
  hasMasks() {
    return this.masks.length > 0 && this.masks.some((m) => m.enabled);
  }
  /**
   * Check if this layer has a matte source assigned
   */
  hasMatte() {
    return this.matteType !== "none" && this.matteCanvas !== null;
  }
  /** @deprecated Use hasMatte() instead */
  hasTrackMatte() {
    return this.hasMatte();
  }
  /**
   * Set the matte canvas (called by LayerManager when compositing)
   * @param canvas - The rendered canvas of the matte layer
   */
  setMatteCanvas(canvas) {
    this.matteCanvas = canvas;
  }
  /** @deprecated Use setMatteCanvas() instead */
  setTrackMatteCanvas(canvas) {
    this.setMatteCanvas(canvas);
  }
  /**
   * Get the matte layer ID
   */
  getMatteLayerId() {
    return this.matteLayerId;
  }
  /** @deprecated Use getMatteLayerId() instead */
  getTrackMatteLayerId() {
    return this.getMatteLayerId();
  }
  /**
   * Get the matte composition ID (for cross-comp mattes)
   * Returns null if matte is in the same composition
   */
  getMatteCompositionId() {
    return this.matteCompositionId;
  }
  /** @deprecated Use getMatteCompositionId() instead */
  getTrackMatteCompositionId() {
    return this.getMatteCompositionId();
  }
  /**
   * Check if this layer uses a cross-composition matte
   */
  hasCrossCompMatte() {
    return this.matteCompositionId !== null && this.matteLayerId !== null;
  }
  /**
   * Get the matte type
   */
  getMatteType() {
    return this.matteType;
  }
  /** @deprecated Use getMatteType() instead */
  getTrackMatteType() {
    return this.getMatteType();
  }
  /**
   * Update masks
   */
  setMasks(masks) {
    this.masks = masks;
  }
  /**
   * Process masks and matte source on a canvas
   * @param canvas - Source canvas to apply masks to
   * @param frame - Current frame for animated masks
   * @returns Processed canvas with masks applied
   */
  processMasksAndMattes(canvas, frame) {
    let result = canvas;
    if (this.hasMasks()) {
      result = applyMasksToLayer(result, this.masks, frame);
    }
    if (this.hasMatte() && this.matteCanvas) {
      result = applyTrackMatte(result, this.matteCanvas, this.matteType);
    }
    return result;
  }
  /**
   * Called after frame evaluation to apply effects AND masks
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(frame) {
    const hasEffects = this.hasEnabledEffects();
    const hasMasks = this.hasMasks();
    const hasTrackMatte = this.hasTrackMatte();
    if (!hasEffects && !hasMasks && !hasTrackMatte) {
      return;
    }
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return;
    }
    let processedCanvas = sourceCanvas;
    if (hasEffects) {
      const effectResult = this.processEffects(frame);
      if (effectResult) {
        processedCanvas = effectResult;
      }
    }
    if (hasMasks || hasTrackMatte) {
      processedCanvas = this.processMasksAndMattes(processedCanvas, frame);
    }
    if (processedCanvas !== sourceCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Apply pre-evaluated effects from MotionEngine
   * Uses the evaluated effect parameters rather than re-evaluating
   */
  applyEvaluatedEffects(evaluatedEffects) {
    if (evaluatedEffects.length === 0 || !this.hasEnabledEffects()) {
      return;
    }
    const processedCanvas = this.processEffectsWithEvaluated(evaluatedEffects);
    if (processedCanvas) {
      this.applyProcessedEffects(processedCanvas);
    }
  }
  /**
   * Process effects using pre-evaluated parameters
   */
  processEffectsWithEvaluated(evaluatedEffects) {
    const sourceCanvas = this.getSourceCanvas();
    if (!sourceCanvas) {
      return null;
    }
    let currentCanvas = sourceCanvas;
    for (const evalEffect of evaluatedEffects) {
      if (!evalEffect.enabled) continue;
      const effect = this.effects.find((e) => e.id === evalEffect.id);
      if (!effect) continue;
      const result = this.processEffectWithParams(effect, currentCanvas, evalEffect.parameters);
      if (result) {
        currentCanvas = result;
      }
    }
    return currentCanvas !== sourceCanvas ? currentCanvas : null;
  }
  /**
   * Process a single effect with pre-evaluated parameters
   */
  processEffectWithParams(effect, sourceCanvas, params) {
    return null;
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(parent) {
    if (this.parentLayer) {
      this.parentLayer.getObject().remove(this.group);
    }
    this.parentLayer = parent;
    if (parent) {
      parent.getObject().add(this.group);
    }
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(mode) {
    this.group.traverse((child) => {
      if (child instanceof Mesh && child.material) {
        const material = child.material;
        this.setMaterialBlendMode(material, mode);
        material.needsUpdate = true;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(material, mode) {
    material.blending = NormalBlending;
    material.blendEquation = AddEquation;
    material.blendSrc = SrcAlphaFactor;
    material.blendDst = OneMinusSrcAlphaFactor;
    material.blendEquationAlpha = AddEquation;
    material.blendSrcAlpha = OneFactor;
    material.blendDstAlpha = OneMinusSrcAlphaFactor;
    switch (mode) {
      case "normal":
        material.blending = NormalBlending;
        break;
      case "add":
        material.blending = AdditiveBlending;
        break;
      case "multiply":
        material.blending = MultiplyBlending;
        break;
      case "screen":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "overlay":
        material.blending = MultiplyBlending;
        break;
      case "soft-light":
        material.blending = NormalBlending;
        break;
      case "hard-light":
        material.blending = MultiplyBlending;
        break;
      case "color-dodge":
        material.blending = AdditiveBlending;
        break;
      case "color-burn":
        material.blending = SubtractiveBlending;
        break;
      case "difference":
        material.blending = CustomBlending;
        material.blendEquation = SubtractEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "exclusion":
        material.blending = CustomBlending;
        material.blendEquation = AddEquation;
        material.blendSrc = OneMinusDstColorFactor;
        material.blendDst = OneMinusSrcColorFactor;
        break;
      case "darken":
        material.blending = CustomBlending;
        material.blendEquation = MinEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      case "lighten":
        material.blending = CustomBlending;
        material.blendEquation = MaxEquation;
        material.blendSrc = OneFactor;
        material.blendDst = OneFactor;
        break;
      default:
        material.blending = NormalBlending;
        break;
    }
  }
  // ============================================================================
  // MOTION PATH VISUALIZATION
  // ============================================================================
  /**
   * Compute motion path from position keyframes
   * Samples position at each frame from inPoint to outPoint
   */
  computeMotionPath(startFrame, endFrame) {
    const start = startFrame ?? this.inPoint;
    const end = endFrame ?? this.outPoint;
    this.motionPathPoints = [];
    for (let frame = start; frame <= end; frame++) {
      const pos = this.evaluator.evaluate(this.transform.position, frame);
      this.motionPathPoints.push(new Vector3(pos.x, -pos.y, pos.z ?? 0));
    }
    this.rebuildMotionPath();
  }
  /**
   * Rebuild the motion path line from computed points
   */
  rebuildMotionPath() {
    if (this.motionPath) {
      this.group.remove(this.motionPath);
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.group.remove(this.motionPathMarkers);
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.motionPathPoints.length < 2) return;
    const curve = new CatmullRomCurve3(this.motionPathPoints);
    const curvePoints = curve.getPoints(this.motionPathPoints.length * 10);
    const geometry = new BufferGeometry().setFromPoints(curvePoints);
    const material = new LineBasicMaterial({
      color: 4886745,
      // Blue motion path
      linewidth: 2,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    this.motionPath = new Line(geometry, material);
    this.motionPath.name = `motion_path_${this.id}`;
    this.motionPath.renderOrder = 998;
    this.motionPath.visible = this.showMotionPath;
    this.motionPath.matrixAutoUpdate = false;
    this.motionPath.matrix.identity();
    this.group.add(this.motionPath);
    this.createMotionPathMarkers();
  }
  /**
   * Create markers at keyframe positions on the motion path
   */
  createMotionPathMarkers() {
    this.motionPathMarkers = new Group();
    this.motionPathMarkers.name = `motion_path_markers_${this.id}`;
    this.motionPathMarkers.renderOrder = 999;
    const positionKeyframes = this.transform.position.keyframes;
    if (!positionKeyframes || positionKeyframes.length === 0) return;
    const markerGeometry = new OctahedronGeometry(5, 0);
    const markerMaterial = new MeshBasicMaterial({
      color: 16763904,
      // Yellow keyframe markers
      transparent: true,
      opacity: 0.9,
      depthTest: false
    });
    for (const kf of positionKeyframes) {
      const pos = kf.value;
      const marker = new Mesh(markerGeometry.clone(), markerMaterial.clone());
      marker.position.set(pos.x, -pos.y, pos.z ?? 0);
      marker.userData.frame = kf.frame;
      this.motionPathMarkers.add(marker);
    }
    this.motionPathMarkers.visible = this.showMotionPath;
    this.group.add(this.motionPathMarkers);
  }
  /**
   * Set motion path visibility
   */
  setMotionPathVisible(visible) {
    this.showMotionPath = visible;
    if (visible && this.motionPathPoints.length === 0) {
      this.computeMotionPath();
    }
    if (this.motionPath) {
      this.motionPath.visible = visible;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.visible = visible;
    }
  }
  /**
   * Check if motion path is visible
   */
  isMotionPathVisible() {
    return this.showMotionPath;
  }
  /**
   * Check if layer has position animation
   */
  hasPositionAnimation() {
    return (this.transform.position.keyframes?.length ?? 0) > 0;
  }
  // ============================================================================
  // 3D AXIS GIZMO
  // ============================================================================
  /**
   * Create 3D axis gizmo at anchor point
   */
  createAxisGizmo(size = 50) {
    if (this.axisGizmo) {
      this.group.remove(this.axisGizmo);
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.axisGizmo = new Group();
    this.axisGizmo.name = `axis_gizmo_${this.id}`;
    this.axisGizmo.renderOrder = 1e3;
    const xGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(size, 0, 0)
    ]);
    const xMat = new LineBasicMaterial({
      color: 16711680,
      linewidth: 2,
      depthTest: false
    });
    const xLine = new Line(xGeom, xMat);
    this.axisGizmo.add(xLine);
    const yGeom = new BufferGeometry().setFromPoints([
      new Vector3(0, 0, 0),
      new Vector3(0, size, 0)
    ]);
    const yMat = new LineBasicMaterial({
      color: 65280,
      linewidth: 2,
      depthTest: false
    });
    const yLine = new Line(yGeom, yMat);
    this.axisGizmo.add(yLine);
    if (this.threeD) {
      const zGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(0, 0, size)
      ]);
      const zMat = new LineBasicMaterial({
        color: 35071,
        linewidth: 2,
        depthTest: false
      });
      const zLine = new Line(zGeom, zMat);
      this.axisGizmo.add(zLine);
    }
    this.addAxisLabels(size);
    const anchor = this.transform.anchorPoint.value;
    this.axisGizmo.position.set(-anchor.x, anchor.y, -(anchor.z ?? 0));
    this.axisGizmo.visible = this.showAxisGizmo;
    this.group.add(this.axisGizmo);
  }
  /**
   * Add axis labels (X, Y, Z)
   */
  addAxisLabels(size) {
    if (!this.axisGizmo) return;
    const sphereGeom = new SphereGeometry(3, 8, 8);
    const xSphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 16711680, depthTest: false })
    );
    xSphere.position.set(size + 5, 0, 0);
    this.axisGizmo.add(xSphere);
    const ySphere = new Mesh(
      sphereGeom.clone(),
      new MeshBasicMaterial({ color: 65280, depthTest: false })
    );
    ySphere.position.set(0, size + 5, 0);
    this.axisGizmo.add(ySphere);
    if (this.threeD) {
      const zSphere = new Mesh(
        sphereGeom.clone(),
        new MeshBasicMaterial({ color: 35071, depthTest: false })
      );
      zSphere.position.set(0, 0, size + 5);
      this.axisGizmo.add(zSphere);
    }
  }
  /**
   * Set axis gizmo visibility
   */
  setAxisGizmoVisible(visible) {
    this.showAxisGizmo = visible;
    if (visible && !this.axisGizmo) {
      this.createAxisGizmo();
    }
    if (this.axisGizmo) {
      this.axisGizmo.visible = visible;
    }
  }
  /**
   * Check if axis gizmo is visible
   */
  isAxisGizmoVisible() {
    return this.showAxisGizmo;
  }
  /**
   * Update axis gizmo position to match anchor point
   */
  updateAxisGizmoPosition() {
    if (!this.axisGizmo) return;
    const anchor = this.transform.anchorPoint.value;
    this.axisGizmo.position.set(-anchor.x, anchor.y, -(anchor.z ?? 0));
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const box = new Box3();
    box.setFromObject(this.group);
    return box;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const box = this.getBoundingBox();
    const center = new Vector3();
    box.getCenter(center);
    return center;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    if (this.motionPath) {
      this.motionPath.geometry.dispose();
      this.motionPath.material.dispose();
      this.motionPath = null;
    }
    if (this.motionPathMarkers) {
      this.motionPathMarkers.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.motionPathMarkers = null;
    }
    if (this.axisGizmo) {
      this.axisGizmo.traverse((child) => {
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      this.axisGizmo = null;
    }
    this.group.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry?.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else if (child.material) {
          child.material.dispose();
        }
      }
    });
    this.group.clear();
    this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}

class VideoLayer extends BaseLayer {
  resources;
  // Video elements
  videoElement = null;
  videoTexture = null;
  mesh = null;
  material = null;
  // Video data
  videoData;
  assetRef = null;
  // Metadata (populated after video loads)
  metadata = null;
  // Animation evaluator
  videoEvaluator;
  // Playback state
  lastEvaluatedFrame = -1;
  isPlaying = false;
  // Callbacks for composition auto-resize
  onMetadataLoaded;
  // Composition FPS for time calculation
  compositionFPS = 30;
  // Canvas for effect processing
  effectCanvas = null;
  effectCanvasCtx = null;
  // Frame blending support
  prevFrameCanvas = null;
  prevFrameCtx = null;
  blendCanvas = null;
  blendCtx = null;
  lastVideoTime = -1;
  prevFrameTime = -1;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.videoEvaluator = new KeyframeEvaluator();
    this.videoData = this.extractVideoData(layerData);
    this.createPlaceholderMesh();
    if (this.videoData.assetId) {
      this.loadVideo(this.videoData.assetId);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(layerData) {
    const data = layerData.data;
    return {
      assetId: data?.assetId ?? null,
      loop: data?.loop ?? false,
      pingPong: data?.pingPong ?? false,
      startTime: data?.startTime ?? 0,
      endTime: data?.endTime,
      speed: data?.speed ?? 1,
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      frameBlending: data?.frameBlending ?? "none",
      audioEnabled: data?.audioEnabled ?? true,
      audioLevel: data?.audioLevel ?? 100,
      posterFrame: data?.posterFrame ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 3355443,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `video_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(assetId) {
    const asset = this.resources.getAsset(assetId);
    if (!asset || asset.type !== "video") {
      layerLogger.warn(`VideoLayer: Asset ${assetId} not found or not a video`);
      return;
    }
    this.assetRef = asset;
    this.videoData.assetId = assetId;
    this.videoElement = document.createElement("video");
    this.videoElement.crossOrigin = "anonymous";
    this.videoElement.playsInline = true;
    this.videoElement.muted = !this.videoData.audioEnabled;
    this.videoElement.loop = false;
    this.videoElement.preload = "auto";
    if (asset.data) {
      this.videoElement.src = asset.data;
    }
    await this.waitForMetadata();
    this.createVideoTexture();
    this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((resolve, reject) => {
      if (!this.videoElement) {
        reject(new Error("No video element"));
        return;
      }
      const onLoadedMetadata = () => {
        this.extractMetadata();
        cleanup();
        resolve();
      };
      const onError = (e) => {
        cleanup();
        reject(new Error(`Video load error: ${e}`));
      };
      const cleanup = () => {
        this.videoElement?.removeEventListener("loadedmetadata", onLoadedMetadata);
        this.videoElement?.removeEventListener("error", onError);
      };
      this.videoElement.addEventListener("loadedmetadata", onLoadedMetadata);
      this.videoElement.addEventListener("error", onError);
      this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    if (!this.videoElement) return;
    const duration = this.videoElement.duration;
    const width = this.videoElement.videoWidth;
    const height = this.videoElement.videoHeight;
    const fps = this.assetRef?.fps ?? 30;
    const frameCount = Math.ceil(duration * fps);
    this.metadata = {
      duration,
      frameCount,
      fps,
      width,
      height,
      hasAudio: this.hasAudioTrack()
    };
    if (this.assetRef) {
      this.assetRef.duration = duration;
      this.assetRef.frameCount = frameCount;
      this.assetRef.fps = fps;
      this.assetRef.hasAudio = this.metadata.hasAudio;
    }
    this.onMetadataLoaded?.(this.metadata);
    layerLogger.debug(`VideoLayer: Loaded: ${width}x${height}, ${frameCount} frames @ ${fps}fps, ${duration.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return false;
    const audioTracks = this.videoElement.audioTracks;
    if (audioTracks) {
      return audioTracks.length > 0;
    }
    return true;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    if (!this.videoElement || !this.metadata) return;
    this.videoTexture = new VideoTexture(this.videoElement);
    this.videoTexture.minFilter = LinearFilter;
    this.videoTexture.magFilter = LinearFilter;
    this.videoTexture.format = RGBAFormat;
    this.videoTexture.colorSpace = SRGBColorSpace;
    if (this.material) {
      this.material.map = this.videoTexture;
      this.material.color.setHex(16777215);
      this.material.needsUpdate = true;
    }
    this.resizeMesh(this.metadata.width, this.metadata.height);
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(compositionFrame) {
    if (!this.videoElement || !this.metadata) return;
    const videoTime = this.calculateVideoTime(compositionFrame);
    const clampedTime = Math.max(0, Math.min(videoTime, this.videoElement.duration));
    this.videoElement.currentTime = clampedTime;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(compositionFrame) {
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && this.videoData.timeRemap?.animated) {
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, compositionFrame);
    }
    const compFps = this.compositionFPS;
    const compTime = compositionFrame / compFps;
    let videoTime = compTime * this.videoData.speed;
    videoTime += this.videoData.startTime;
    const effectiveDuration = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && effectiveDuration > 0) {
      if (this.videoData.pingPong) {
        const cycles = Math.floor(videoTime / effectiveDuration);
        const phase = videoTime % effectiveDuration;
        videoTime = cycles % 2 === 0 ? phase : effectiveDuration - phase;
      } else {
        videoTime = videoTime % effectiveDuration;
      }
      videoTime += this.videoData.startTime;
    }
    return videoTime;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(level) {
    this.videoData.audioLevel = level;
    if (this.videoElement) {
      this.videoElement.volume = Math.max(0, Math.min(1, level / 100));
    }
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(enabled) {
    this.videoData.audioEnabled = enabled;
    if (this.videoElement) {
      this.videoElement.muted = !enabled;
    }
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.compositionFPS = fps;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(callback) {
    this.onMetadataLoaded = callback;
    if (this.metadata) {
      callback(this.metadata);
    }
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(loop) {
    this.videoData.loop = loop;
  }
  setPingPong(pingPong) {
    this.videoData.pingPong = pingPong;
  }
  setSpeed(speed) {
    this.videoData.speed = speed;
    if (this.videoElement) {
      this.videoElement.playbackRate = speed;
    }
  }
  setStartTime(time) {
    this.videoData.startTime = time;
  }
  setEndTime(time) {
    this.videoData.endTime = time;
  }
  setFrameBlending(mode) {
    this.videoData.frameBlending = mode;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   * Supports frame blending for smooth slow-motion
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata) {
      return null;
    }
    const width = this.metadata.width;
    const height = this.metadata.height;
    this.ensureCanvases(width, height);
    if (!this.effectCanvasCtx) {
      return null;
    }
    const shouldBlend = this.layerData.frameBlending === true && this.videoData.frameBlending !== "none";
    if (shouldBlend && this.prevFrameCtx && this.blendCtx && this.blendCanvas) {
      return this.getBlendedFrame(width, height);
    }
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    return this.effectCanvas;
  }
  /**
   * Ensure all canvases are created and sized correctly
   */
  ensureCanvases(width, height) {
    if (!this.effectCanvas || this.effectCanvas.width !== width || this.effectCanvas.height !== height) {
      this.effectCanvas = document.createElement("canvas");
      this.effectCanvas.width = width;
      this.effectCanvas.height = height;
      this.effectCanvasCtx = this.effectCanvas.getContext("2d");
    }
    if (!this.prevFrameCanvas || this.prevFrameCanvas.width !== width || this.prevFrameCanvas.height !== height) {
      this.prevFrameCanvas = document.createElement("canvas");
      this.prevFrameCanvas.width = width;
      this.prevFrameCanvas.height = height;
      this.prevFrameCtx = this.prevFrameCanvas.getContext("2d");
    }
    if (!this.blendCanvas || this.blendCanvas.width !== width || this.blendCanvas.height !== height) {
      this.blendCanvas = document.createElement("canvas");
      this.blendCanvas.width = width;
      this.blendCanvas.height = height;
      this.blendCtx = this.blendCanvas.getContext("2d");
    }
  }
  /**
   * Get blended frame between previous and current video frame
   * Used for smooth slow-motion playback
   */
  getBlendedFrame(width, height) {
    if (!this.videoElement || !this.metadata || !this.blendCtx || !this.blendCanvas || !this.prevFrameCtx || !this.prevFrameCanvas) {
      return null;
    }
    const currentVideoTime = this.videoElement.currentTime;
    const videoFps = this.metadata.fps || 30;
    const currentVideoFrame = currentVideoTime * videoFps;
    const blendFactor = currentVideoFrame - Math.floor(currentVideoFrame);
    const currentIntFrame = Math.floor(currentVideoFrame);
    const prevIntFrame = Math.floor(this.lastVideoTime * videoFps);
    if (this.lastVideoTime < 0 || currentIntFrame !== prevIntFrame) {
      if (this.effectCanvasCtx && this.effectCanvas) {
        this.effectCanvasCtx.clearRect(0, 0, width, height);
        this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
        this.prevFrameCtx.clearRect(0, 0, width, height);
        this.prevFrameCtx.drawImage(this.effectCanvas, 0, 0);
        this.prevFrameTime = this.lastVideoTime;
      }
    }
    this.lastVideoTime = currentVideoTime;
    this.effectCanvasCtx.clearRect(0, 0, width, height);
    this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, width, height);
    if (blendFactor < 0.01 || blendFactor > 0.99) {
      return this.effectCanvas;
    }
    this.blendCtx.clearRect(0, 0, width, height);
    this.blendCtx.globalAlpha = 1;
    this.blendCtx.drawImage(this.prevFrameCanvas, 0, 0);
    this.blendCtx.globalAlpha = blendFactor;
    this.blendCtx.drawImage(this.effectCanvas, 0, 0);
    this.blendCtx.globalAlpha = 1;
    return this.blendCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    if (!this.material || !this.metadata) return;
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (frame === this.lastEvaluatedFrame) return;
    this.lastEvaluatedFrame = frame;
    this.seekToFrame(frame);
    if (this.videoTexture) {
      this.videoTexture.needsUpdate = true;
    }
    if (this.hasEnabledEffects()) {
      this.evaluateEffects(frame);
    } else if (this.material && this.videoTexture) {
      this.material.map = this.videoTexture;
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.videoElement) {
      const targetTime = props["timeRemap"];
      const clampedTime = Math.max(0, Math.min(targetTime, this.videoElement.duration || targetTime));
      this.videoElement.currentTime = clampedTime;
    }
    if (props["speed"] !== void 0) {
      this.videoData.speed = props["speed"];
    }
    if (props["audioLevel"] !== void 0) {
      this.setAudioLevel(props["audioLevel"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.videoData.assetId) {
        if (data.assetId) {
          this.loadVideo(data.assetId);
        } else {
          this.clearVideo();
        }
      }
      if (data.loop !== void 0) this.setLoop(data.loop);
      if (data.pingPong !== void 0) this.setPingPong(data.pingPong);
      if (data.speed !== void 0) this.setSpeed(data.speed);
      if (data.startTime !== void 0) this.setStartTime(data.startTime);
      if (data.endTime !== void 0) this.setEndTime(data.endTime);
      if (data.frameBlending !== void 0) this.setFrameBlending(data.frameBlending);
      if (data.audioEnabled !== void 0) this.setAudioEnabled(data.audioEnabled);
      if (data.audioLevel !== void 0) this.setAudioLevel(data.audioLevel);
    }
  }
  /**
   * Clear current video
   */
  clearVideo() {
    if (this.videoElement) {
      this.videoElement.pause();
      this.videoElement.src = "";
      this.videoElement = null;
    }
    if (this.videoTexture) {
      this.videoTexture.dispose();
      this.videoTexture = null;
    }
    if (this.material) {
      this.material.map = null;
      this.material.color.setHex(3355443);
    }
    this.metadata = null;
    this.videoData.assetId = null;
    this.lastVideoTime = -1;
    this.prevFrameTime = -1;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo();
    this.prevFrameCanvas = null;
    this.prevFrameCtx = null;
    this.blendCanvas = null;
    this.blendCtx = null;
    this.effectCanvas = null;
    this.effectCanvasCtx = null;
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
  }
}
async function extractVideoMetadata(source) {
  return new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.preload = "metadata";
    const cleanup = () => {
      video.removeEventListener("loadedmetadata", onLoad);
      video.removeEventListener("error", onError);
      URL.revokeObjectURL(video.src);
    };
    const onLoad = () => {
      const metadata = {
        duration: video.duration,
        frameCount: Math.ceil(video.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: video.videoWidth,
        height: video.videoHeight,
        hasAudio: true
        // Assume true
      };
      cleanup();
      resolve(metadata);
    };
    const onError = () => {
      cleanup();
      reject(new Error("Failed to load video metadata"));
    };
    video.addEventListener("loadedmetadata", onLoad);
    video.addEventListener("error", onError);
    if (typeof source === "string") {
      video.src = source;
    } else {
      video.src = URL.createObjectURL(source);
    }
  });
}
function calculateCompositionFromVideo(metadata, targetFps = 16) {
  const width = Math.round(metadata.width / 8) * 8;
  const height = Math.round(metadata.height / 8) * 8;
  const frameCount = Math.ceil(metadata.duration * targetFps);
  return { width, height, frameCount };
}

const CAMERA_PRESETS = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function createDefaultCamera(id, compWidth, compHeight) {
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  return {
    id,
    name: "Camera 1",
    type: "two-node",
    position: { x: centerX, y: centerY, z: -1500 },
    pointOfInterest: { x: centerX, y: centerY, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: false,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: false
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function createDefaultViewportState() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function createDefaultViewOptions() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: true,
    showLayerHandles: true,
    showSafeZones: false,
    showGrid: false,
    showRulers: true,
    show3DReferenceAxes: true,
    showCompositionBounds: true,
    showFocalPlane: false
  };
}

function controlPointToAnimatable(cp) {
  return {
    id: cp.id,
    x: createAnimatableProperty("x", cp.x, "number"),
    y: createAnimatableProperty("y", cp.y, "number"),
    depth: cp.depth !== void 0 ? createAnimatableProperty("depth", cp.depth, "number") : void 0,
    handleIn: cp.handleIn ? {
      x: createAnimatableProperty("handleIn.x", cp.handleIn.x, "number"),
      y: createAnimatableProperty("handleIn.y", cp.handleIn.y, "number")
    } : null,
    handleOut: cp.handleOut ? {
      x: createAnimatableProperty("handleOut.x", cp.handleOut.x, "number"),
      y: createAnimatableProperty("handleOut.y", cp.handleOut.y, "number")
    } : null,
    type: cp.type,
    group: cp.group
  };
}
function animatableToControlPoint(acp) {
  return {
    id: acp.id,
    x: acp.x.value,
    y: acp.y.value,
    depth: acp.depth?.value,
    handleIn: acp.handleIn ? {
      x: acp.handleIn.x.value,
      y: acp.handleIn.y.value
    } : null,
    handleOut: acp.handleOut ? {
      x: acp.handleOut.x.value,
      y: acp.handleOut.y.value
    } : null,
    type: acp.type,
    group: acp.group
  };
}
function createAnimatableProperty(name, value, type = "number", group) {
  return {
    id: `prop_${name}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name,
    type,
    value,
    animated: false,
    keyframes: [],
    group
  };
}
function createDefaultTransform() {
  return {
    position: createAnimatableProperty("position", { x: 0, y: 0, z: 0 }, "vector3"),
    anchorPoint: createAnimatableProperty("anchorPoint", { x: 0, y: 0, z: 0 }, "vector3"),
    scale: createAnimatableProperty("scale", { x: 100, y: 100, z: 100 }, "vector3"),
    rotation: createAnimatableProperty("rotation", 0, "number"),
    // 3D rotation properties (always present for consistent structure)
    orientation: createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3"),
    rotationX: createAnimatableProperty("rotationX", 0, "number"),
    rotationY: createAnimatableProperty("rotationY", 0, "number"),
    rotationZ: createAnimatableProperty("rotationZ", 0, "number")
  };
}
function createEmptyProject(width, height) {
  const mainCompId = "main";
  const compositionSettings = {
    width,
    height,
    frameCount: 81,
    fps: 16,
    duration: 81 / 16,
    backgroundColor: "#000000",
    autoResizeToContent: true
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [mainCompId]: {
        id: mainCompId,
        name: "Main Comp",
        settings: compositionSettings,
        layers: [],
        currentFrame: 0,
        isNestedComp: false
      }
    },
    mainCompositionId: mainCompId,
    // Legacy alias
    composition: compositionSettings,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}

function isSplineControlPointPath(path) {
  return path.startsWith("spline.controlPoint.");
}
function createSplineControlPointPath(index, property) {
  return `spline.controlPoint.${index}.${property}`;
}
class PropertyDriverSystem {
  drivers = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  audioAnalysis = null;
  propertyGetter = null;
  constructor() {
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(analysis) {
    this.audioAnalysis = analysis;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(getter) {
    this.propertyGetter = getter;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(driver) {
    if (driver.sourceType === "property" && driver.sourceLayerId && driver.sourceProperty) {
      if (this.wouldCreateCycle(driver)) {
        storeLogger.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency");
        return false;
      }
    }
    this.drivers.set(driver.id, driver);
    this.smoothedValues.set(driver.id, 0);
    return true;
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(newDriver) {
    if (newDriver.sourceType !== "property") return false;
    if (!newDriver.sourceLayerId || !newDriver.sourceProperty) return false;
    const visited = /* @__PURE__ */ new Set();
    const targetKey = `${newDriver.targetLayerId}:${newDriver.targetProperty}`;
    const hasCycle = (layerId, property) => {
      const key = `${layerId}:${property}`;
      if (key === targetKey) return true;
      if (visited.has(key)) return false;
      visited.add(key);
      for (const driver of this.drivers.values()) {
        if (driver.sourceType !== "property") continue;
        if (driver.targetLayerId !== layerId || driver.targetProperty !== property) continue;
        if (!driver.sourceLayerId || !driver.sourceProperty) continue;
        if (hasCycle(driver.sourceLayerId, driver.sourceProperty)) {
          return true;
        }
      }
      return false;
    };
    return hasCycle(newDriver.sourceLayerId, newDriver.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(id) {
    this.drivers.delete(id);
    this.smoothedValues.delete(id);
  }
  /**
   * Update a driver
   */
  updateDriver(id, updates) {
    const driver = this.drivers.get(id);
    if (driver) {
      Object.assign(driver, updates);
    }
  }
  /**
   * Get a driver by ID
   */
  getDriver(id) {
    return this.drivers.get(id);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(layerId) {
    return Array.from(this.drivers.values()).filter((d) => d.targetLayerId === layerId);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(layerId, property) {
    return Array.from(this.drivers.values()).filter(
      (d) => d.targetLayerId === layerId && d.targetProperty === property && d.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(driver, frame, baseValue) {
    if (!driver.enabled) return baseValue;
    let value = this.getSourceValue(driver, frame);
    if (value === null) return baseValue;
    value = this.applyTransforms(driver, value);
    return this.blendValue(baseValue, value, driver.blendMode, driver.blendAmount);
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(driver, frame) {
    switch (driver.sourceType) {
      case "property":
        return this.getPropertySourceValue(driver, frame);
      case "audio":
        return this.getAudioSourceValue(driver, frame);
      case "time":
        return frame;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(driver, frame) {
    if (!this.propertyGetter || !driver.sourceLayerId || !driver.sourceProperty) {
      return null;
    }
    return this.propertyGetter(driver.sourceLayerId, driver.sourceProperty, frame);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(driver, frame) {
    if (!this.audioAnalysis || !driver.audioFeature) {
      return null;
    }
    let value = getFeatureAtFrame(this.audioAnalysis, driver.audioFeature, frame);
    if (driver.audioThreshold !== void 0) {
      if (driver.audioAboveThreshold) {
        value = value > driver.audioThreshold ? value : 0;
      } else {
        value = value >= driver.audioThreshold ? value : 0;
      }
    }
    return value;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(driver, value) {
    for (const transform of driver.transforms) {
      value = this.applyTransform(driver.id, transform, value);
    }
    return value;
  }
  /**
   * Apply a single transform
   */
  applyTransform(driverId, transform, value) {
    switch (transform.type) {
      case "scale":
        return value * (transform.factor ?? 1);
      case "offset":
        return value + (transform.amount ?? 0);
      case "clamp":
        return Math.max(transform.min ?? -Infinity, Math.min(transform.max ?? Infinity, value));
      case "smooth": {
        const prevValue = this.smoothedValues.get(driverId) ?? value;
        const smoothing = transform.smoothing ?? 0.5;
        const smoothed = prevValue * smoothing + value * (1 - smoothing);
        this.smoothedValues.set(driverId, smoothed);
        return smoothed;
      }
      case "invert":
        return 1 - value;
      case "remap": {
        const inMin = transform.inMin ?? 0;
        const inMax = transform.inMax ?? 1;
        const outMin = transform.outMin ?? 0;
        const outMax = transform.outMax ?? 1;
        const normalized = (value - inMin) / (inMax - inMin);
        return outMin + normalized * (outMax - outMin);
      }
      case "threshold":
        return value > (transform.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const freq = transform.frequency ?? 1;
        const amp = transform.amplitude ?? 1;
        const phase = transform.phase ?? 0;
        return Math.sin((value * freq + phase) * Math.PI * 2) * amp;
      }
      default:
        return value;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(base, driven, mode, amount) {
    let result;
    switch (mode) {
      case "replace":
        result = driven;
        break;
      case "add":
        result = base + driven;
        break;
      case "multiply":
        result = base * driven;
        break;
      default:
        result = driven;
    }
    return base * (1 - amount) + result * amount;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(layerId, frame, baseValues) {
    const result = /* @__PURE__ */ new Map();
    const drivers = this.getDriversForLayer(layerId);
    for (const driver of drivers) {
      if (!driver.enabled) continue;
      const baseValue = baseValues.get(driver.targetProperty) ?? 0;
      const drivenValue = this.evaluateDriver(driver, frame, baseValue);
      const existing = result.get(driver.targetProperty);
      if (existing !== void 0) {
        result.set(driver.targetProperty, existing + drivenValue - baseValue);
      } else {
        result.set(driver.targetProperty, drivenValue);
      }
    }
    return result;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear();
    this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(drivers) {
    this.clear();
    for (const driver of drivers) {
      this.addDriver(driver);
    }
  }
}
function createPropertyDriver(targetLayerId, targetProperty, sourceType = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: true,
    targetLayerId,
    targetProperty,
    sourceType,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function createAudioDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "audio");
  driver.audioFeature = audioFeature;
  driver.audioThreshold = options.threshold ?? 0;
  driver.audioAboveThreshold = options.threshold !== void 0;
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  if (options.smoothing !== void 0 && options.smoothing > 0) {
    driver.transforms.push({ type: "smooth", smoothing: options.smoothing });
  }
  return driver;
}
function createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyDriver(targetLayerId, targetProperty, "property");
  driver.sourceLayerId = sourceLayerId;
  driver.sourceProperty = sourceProperty;
  driver.blendMode = options.blendMode ?? "add";
  if (options.scale !== void 0 && options.scale !== 1) {
    driver.transforms.push({ type: "scale", factor: options.scale });
  }
  if (options.offset !== void 0 && options.offset !== 0) {
    driver.transforms.push({ type: "offset", amount: options.offset });
  }
  return driver;
}

const DEFAULT_SNAP_CONFIG = {
  enabled: true,
  snapToGrid: true,
  snapToKeyframes: true,
  snapToBeats: true,
  snapToPeaks: true,
  snapToLayerBounds: true,
  snapToPlayhead: true,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function findNearestSnap(frame, config, pixelsPerFrame, context) {
  if (!config.enabled) {
    return null;
  }
  const snapTargets = [];
  const thresholdFrames = config.threshold / pixelsPerFrame;
  if (config.snapToGrid) {
    const nearestGridFrame = Math.round(frame / config.gridInterval) * config.gridInterval;
    const gridDistance = Math.abs(frame - nearestGridFrame);
    if (gridDistance <= thresholdFrames) {
      snapTargets.push({
        frame: nearestGridFrame,
        type: "frame",
        distance: gridDistance * pixelsPerFrame
      });
    }
  }
  if (config.snapToKeyframes && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, snapTargets);
    }
  }
  if (config.snapToBeats && context.audioAnalysis?.onsets) {
    for (const onset of context.audioAnalysis.onsets) {
      const distance = Math.abs(frame - onset);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: onset,
          type: "beat",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPeaks && context.peakData?.indices) {
    for (const peakFrame of context.peakData.indices) {
      const distance = Math.abs(frame - peakFrame);
      if (distance <= thresholdFrames) {
        snapTargets.push({
          frame: peakFrame,
          type: "peak",
          distance: distance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToLayerBounds && context.layers) {
    for (const layer of context.layers) {
      if (layer.id === context.selectedLayerId) continue;
      const inDistance = Math.abs(frame - layer.inPoint);
      const outDistance = Math.abs(frame - layer.outPoint);
      if (inDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.inPoint,
          type: "layer-in",
          distance: inDistance * pixelsPerFrame
        });
      }
      if (outDistance <= thresholdFrames) {
        snapTargets.push({
          frame: layer.outPoint,
          type: "layer-out",
          distance: outDistance * pixelsPerFrame
        });
      }
    }
  }
  if (config.snapToPlayhead && context.currentFrame !== void 0) {
    const distance = Math.abs(frame - context.currentFrame);
    if (distance <= thresholdFrames && distance > 0) {
      snapTargets.push({
        frame: context.currentFrame,
        type: "playhead",
        distance: distance * pixelsPerFrame
      });
    }
  }
  if (snapTargets.length === 0) {
    return null;
  }
  const priority = {
    "playhead": 5,
    "beat": 4,
    "peak": 4,
    "keyframe": 3,
    "layer-in": 2,
    "layer-out": 2,
    "frame": 1
  };
  snapTargets.sort((a, b) => {
    const distDiff = a.distance - b.distance;
    if (Math.abs(distDiff) < 0.5) {
      return priority[b.type] - priority[a.type];
    }
    return distDiff;
  });
  return snapTargets[0];
}
function collectKeyframeSnapTargets(layer, frame, thresholdFrames, pixelsPerFrame, targets) {
  const properties = [
    layer.transform.position,
    layer.transform.scale,
    layer.transform.rotation,
    layer.opacity,
    ...layer.properties
  ];
  for (const prop of properties) {
    if (!prop.animated || !prop.keyframes) continue;
    for (const kf of prop.keyframes) {
      const distance = Math.abs(frame - kf.frame);
      if (distance <= thresholdFrames) {
        if (!targets.some((t) => t.frame === kf.frame && t.type === "keyframe")) {
          targets.push({
            frame: kf.frame,
            type: "keyframe",
            distance: distance * pixelsPerFrame
          });
        }
      }
    }
  }
}
function getBeatFrames(audioAnalysis) {
  return audioAnalysis?.onsets ?? [];
}
function getPeakFrames(peakData) {
  return peakData?.indices ?? [];
}

const useSelectionStore = defineStore("selection", {
  state: () => ({
    selectedLayerIds: [],
    lastSelectedLayerId: null,
    selectedKeyframeIds: [],
    selectedControlPoints: [],
    selectedPropertyPath: null,
    currentTool: "select"
  }),
  getters: {
    hasSelection: (state) => state.selectedLayerIds.length > 0,
    hasMultipleSelected: (state) => state.selectedLayerIds.length > 1,
    hasKeyframeSelection: (state) => state.selectedKeyframeIds.length > 0,
    hasControlPointSelection: (state) => state.selectedControlPoints.length > 0,
    singleSelectedLayerId: (state) => state.selectedLayerIds.length === 1 ? state.selectedLayerIds[0] : null,
    selectedControlPointCount: (state) => state.selectedControlPoints.length
  },
  actions: {
    // ============================================================
    // LAYER SELECTION
    // ============================================================
    /**
     * Select a single layer (replaces current selection)
     */
    selectLayer(layerId) {
      this.selectedLayerIds = [layerId];
      this.lastSelectedLayerId = layerId;
      storeLogger.debug("Selected layer:", layerId);
    },
    /**
     * Select multiple layers (replaces current selection)
     */
    selectLayers(layerIds) {
      this.selectedLayerIds = [...layerIds];
      if (layerIds.length > 0) {
        this.lastSelectedLayerId = layerIds[layerIds.length - 1];
      }
      storeLogger.debug("Selected layers:", layerIds.length);
    },
    /**
     * Add layer to selection (multi-select)
     */
    addToSelection(layerId) {
      if (!this.selectedLayerIds.includes(layerId)) {
        this.selectedLayerIds.push(layerId);
        this.lastSelectedLayerId = layerId;
      }
    },
    /**
     * Remove layer from selection
     */
    removeFromSelection(layerId) {
      const index = this.selectedLayerIds.indexOf(layerId);
      if (index >= 0) {
        this.selectedLayerIds.splice(index, 1);
      }
    },
    /**
     * Toggle layer selection
     */
    toggleLayerSelection(layerId) {
      if (this.selectedLayerIds.includes(layerId)) {
        this.removeFromSelection(layerId);
      } else {
        this.addToSelection(layerId);
      }
    },
    /**
     * Select layer with keyboard modifiers (Ctrl/Shift+Click behavior)
     *
     * @param layerId The layer to select
     * @param modifiers Modifier keys state
     * @param orderedLayerIds All layer IDs in order (for shift+click range selection)
     */
    selectLayerWithModifiers(layerId, modifiers, orderedLayerIds) {
      if (modifiers.shift && this.lastSelectedLayerId && orderedLayerIds) {
        this.selectRange(this.lastSelectedLayerId, layerId, orderedLayerIds);
      } else if (modifiers.ctrl) {
        this.toggleLayerSelection(layerId);
        this.lastSelectedLayerId = layerId;
      } else {
        this.selectLayer(layerId);
      }
    },
    /**
     * Select a range of layers between two layer IDs
     *
     * @param startLayerId First layer in range
     * @param endLayerId Last layer in range
     * @param orderedLayerIds All layer IDs in display order
     */
    selectRange(startLayerId, endLayerId, orderedLayerIds) {
      const startIndex = orderedLayerIds.indexOf(startLayerId);
      const endIndex = orderedLayerIds.indexOf(endLayerId);
      if (startIndex === -1 || endIndex === -1) {
        this.selectLayer(endLayerId);
        return;
      }
      const minIndex = Math.min(startIndex, endIndex);
      const maxIndex = Math.max(startIndex, endIndex);
      this.selectedLayerIds = orderedLayerIds.slice(minIndex, maxIndex + 1);
      this.lastSelectedLayerId = endLayerId;
      storeLogger.debug("Range selected layers:", this.selectedLayerIds.length);
    },
    /**
     * Clear layer selection
     */
    clearLayerSelection() {
      this.selectedLayerIds = [];
      this.lastSelectedLayerId = null;
    },
    /**
     * Check if layer is selected
     */
    isLayerSelected(layerId) {
      return this.selectedLayerIds.includes(layerId);
    },
    // ============================================================
    // KEYFRAME SELECTION
    // ============================================================
    /**
     * Select a single keyframe
     */
    selectKeyframe(keyframeId) {
      this.selectedKeyframeIds = [keyframeId];
    },
    /**
     * Select multiple keyframes
     */
    selectKeyframes(keyframeIds) {
      this.selectedKeyframeIds = [...keyframeIds];
    },
    /**
     * Add keyframe to selection
     */
    addKeyframeToSelection(keyframeId) {
      if (!this.selectedKeyframeIds.includes(keyframeId)) {
        this.selectedKeyframeIds.push(keyframeId);
      }
    },
    /**
     * Remove keyframe from selection
     */
    removeKeyframeFromSelection(keyframeId) {
      const index = this.selectedKeyframeIds.indexOf(keyframeId);
      if (index >= 0) {
        this.selectedKeyframeIds.splice(index, 1);
      }
    },
    /**
     * Toggle keyframe selection
     */
    toggleKeyframeSelection(keyframeId) {
      if (this.selectedKeyframeIds.includes(keyframeId)) {
        this.removeKeyframeFromSelection(keyframeId);
      } else {
        this.addKeyframeToSelection(keyframeId);
      }
    },
    /**
     * Clear keyframe selection
     */
    clearKeyframeSelection() {
      this.selectedKeyframeIds = [];
    },
    /**
     * Check if keyframe is selected
     */
    isKeyframeSelected(keyframeId) {
      return this.selectedKeyframeIds.includes(keyframeId);
    },
    // ============================================================
    // CONTROL POINT SELECTION
    // ============================================================
    /**
     * Select a single control point
     */
    selectControlPoint(layerId, pointIndex, groupId) {
      this.selectedControlPoints = [{ layerId, pointIndex, groupId }];
    },
    /**
     * Select multiple control points
     */
    selectControlPoints(points) {
      this.selectedControlPoints = [...points];
    },
    /**
     * Add control point to selection
     */
    addControlPointToSelection(layerId, pointIndex, groupId) {
      const exists = this.selectedControlPoints.some(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
      if (!exists) {
        this.selectedControlPoints.push({ layerId, pointIndex, groupId });
      }
    },
    /**
     * Remove control point from selection
     */
    removeControlPointFromSelection(layerId, pointIndex) {
      this.selectedControlPoints = this.selectedControlPoints.filter(
        (p) => !(p.layerId === layerId && p.pointIndex === pointIndex)
      );
    },
    /**
     * Toggle control point selection
     */
    toggleControlPointSelection(layerId, pointIndex, groupId) {
      const index = this.selectedControlPoints.findIndex(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
      if (index >= 0) {
        this.selectedControlPoints.splice(index, 1);
      } else {
        this.selectedControlPoints.push({ layerId, pointIndex, groupId });
      }
    },
    /**
     * Select control point with keyboard modifiers
     */
    selectControlPointWithModifiers(layerId, pointIndex, modifiers, groupId) {
      if (modifiers.ctrl) {
        this.toggleControlPointSelection(layerId, pointIndex, groupId);
      } else {
        this.selectControlPoint(layerId, pointIndex, groupId);
      }
    },
    /**
     * Select all control points in a group
     * @param groupId The group ID to select
     * @param layerId The layer containing the group
     * @param pointIndicesInGroup All point indices that belong to this group
     */
    selectControlPointGroup(groupId, layerId, pointIndicesInGroup) {
      this.selectedControlPoints = pointIndicesInGroup.map((pointIndex) => ({
        layerId,
        pointIndex,
        groupId
      }));
      storeLogger.debug("Selected control point group:", groupId, "points:", pointIndicesInGroup.length);
    },
    /**
     * Add all control points in a group to selection
     */
    addControlPointGroupToSelection(groupId, layerId, pointIndicesInGroup) {
      for (const pointIndex of pointIndicesInGroup) {
        const exists = this.selectedControlPoints.some(
          (p) => p.layerId === layerId && p.pointIndex === pointIndex
        );
        if (!exists) {
          this.selectedControlPoints.push({ layerId, pointIndex, groupId });
        }
      }
    },
    /**
     * Clear control point selection
     */
    clearControlPointSelection() {
      this.selectedControlPoints = [];
    },
    /**
     * Check if control point is selected
     */
    isControlPointSelected(layerId, pointIndex) {
      return this.selectedControlPoints.some(
        (p) => p.layerId === layerId && p.pointIndex === pointIndex
      );
    },
    /**
     * Get selected control points for a specific layer
     */
    getSelectedControlPointsForLayer(layerId) {
      return this.selectedControlPoints.filter((p) => p.layerId === layerId);
    },
    // ============================================================
    // PROPERTY SELECTION
    // ============================================================
    /**
     * Set selected property path (for graph editor focus)
     */
    setSelectedPropertyPath(path) {
      this.selectedPropertyPath = path;
    },
    // ============================================================
    // TOOL STATE
    // ============================================================
    /**
     * Set current tool
     */
    setTool(tool) {
      this.currentTool = tool;
    },
    // ============================================================
    // CLEAR ALL
    // ============================================================
    /**
     * Clear all selections
     */
    clearAll() {
      this.selectedLayerIds = [];
      this.lastSelectedLayerId = null;
      this.selectedKeyframeIds = [];
      this.selectedControlPoints = [];
      this.selectedPropertyPath = null;
    }
  }
});

const layerVersions = /* @__PURE__ */ new Map();
function markLayerDirty(layerId) {
  const current = layerVersions.get(layerId) ?? 0;
  layerVersions.set(layerId, current + 1);
}
const evaluationCache = /* @__PURE__ */ new Map();
function clearLayerCache(layerId) {
  const keysToDelete = [];
  for (const key of evaluationCache.keys()) {
    if (key.startsWith(`${layerId}:`)) {
      keysToDelete.push(key);
    }
  }
  keysToDelete.forEach((key) => evaluationCache.delete(key));
}

function createLayer(store, type, name) {
  const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  let layerData = null;
  switch (type) {
    case "text":
      layerData = {
        text: "Text",
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        tracking: 0,
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left"
      };
      break;
    case "solid":
      layerData = {
        color: "#808080",
        width: store.project.composition.width,
        height: store.project.composition.height
      };
      break;
    case "null":
      layerData = {
        size: 40
      };
      break;
    case "spline":
      layerData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        // Stroke options (shown in More Options group)
        lineCap: "round",
        // butt, round, square
        lineJoin: "round",
        // miter, round, bevel
        dashArray: "",
        // e.g., "10, 5" for dashed lines
        dashOffset: 0
      };
      break;
    case "particles":
      layerData = {
        systemConfig: {
          maxParticles: 1e3,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: "emitter_1",
          name: "Emitter 1",
          x: store.project.composition.width / 2,
          y: store.project.composition.height / 2,
          direction: -90,
          spread: 30,
          speed: 5,
          speedVariance: 0.2,
          size: 10,
          sizeVariance: 0.3,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 0.2,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 10,
          trailOpacityFalloff: 0.9,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 5,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 4,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        }
      };
      break;
    case "depthflow":
      layerData = {
        sourceLayerId: null,
        depthLayerId: null,
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0,
          orbitSpeed: 1,
          swingAmplitude: 0,
          swingFrequency: 1,
          edgeDilation: 0,
          inpaintEdges: false
        }
      };
      break;
    case "light":
      layerData = {
        lightType: "point",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0
      };
      break;
    case "camera":
      layerData = {
        cameraId: null,
        isActiveCamera: false
      };
      break;
    case "image":
      layerData = {
        assetId: null,
        fit: "contain"
      };
      break;
    case "video":
      layerData = {
        assetId: null,
        loop: false,
        startTime: 0,
        speed: 1
      };
      break;
    case "shape":
      layerData = {
        shapes: [],
        fill: "#ffffff",
        stroke: "#000000",
        strokeWidth: 2
      };
      break;
    case "nestedComp":
      layerData = {
        compositionId: null,
        timeRemap: null
      };
      break;
    case "matte":
      layerData = {
        matteType: "luminance",
        invert: false,
        threshold: 0.5
      };
      break;
  }
  let audioProps = void 0;
  if (type === "video" || type === "audio") {
    audioProps = {
      level: createAnimatableProperty("Audio Levels", 0, "number")
      // 0dB default
    };
  }
  const comp = store.getActiveComp();
  const layers = store.getActiveCompLayers();
  const compWidth = comp?.settings.width || store.project.composition.width || 1920;
  const compHeight = comp?.settings.height || store.project.composition.height || 1080;
  const centeredTransform = createDefaultTransform();
  centeredTransform.position.value = { x: compWidth / 2, y: compHeight / 2 };
  const layer = {
    id,
    name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
    type,
    visible: true,
    locked: false,
    isolate: false,
    threeD: false,
    motionBlur: false,
    inPoint: 0,
    outPoint: (comp?.settings.frameCount || 81) - 1,
    parentId: null,
    blendMode: "normal",
    opacity: createAnimatableProperty("opacity", 100, "number"),
    transform: centeredTransform,
    audio: audioProps,
    properties: [],
    effects: [],
    data: layerData
  };
  if (type === "camera") {
    storeLogger.warn("Use createCameraLayer() for camera layers");
  }
  layers.unshift(layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return layer;
}
function deleteLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const index = layers.findIndex((l) => l.id === layerId);
  if (index === -1) return;
  layers.splice(index, 1);
  useSelectionStore().removeFromSelection(layerId);
  clearLayerCache(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function duplicateLayer(store, layerId) {
  const layers = store.getActiveCompLayers();
  const original = layers.find((l) => l.id === layerId);
  if (!original) return null;
  const duplicate = structuredClone(original);
  duplicate.id = crypto.randomUUID();
  duplicate.name = original.name + " Copy";
  regenerateKeyframeIds(duplicate);
  const index = layers.findIndex((l) => l.id === layerId);
  layers.splice(index, 0, duplicate);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return duplicate;
}
function copySelectedLayers(store) {
  const layers = store.getActiveCompLayers();
  const selection = useSelectionStore();
  const selectedLayers = layers.filter((l) => selection.selectedLayerIds.includes(l.id));
  if (selectedLayers.length === 0) return;
  store.clipboard.layers = selectedLayers.map((layer) => structuredClone(layer));
  storeLogger.debug(`Copied ${store.clipboard.layers.length} layer(s) to clipboard`);
}
function pasteLayers(store) {
  if (store.clipboard.layers.length === 0) return [];
  const layers = store.getActiveCompLayers();
  const pastedLayers = [];
  for (const clipboardLayer of store.clipboard.layers) {
    const newLayer = structuredClone(clipboardLayer);
    newLayer.id = crypto.randomUUID();
    newLayer.name = clipboardLayer.name + " Copy";
    regenerateKeyframeIds(newLayer);
    newLayer.parentId = null;
    layers.unshift(newLayer);
    pastedLayers.push(newLayer);
  }
  useSelectionStore().selectLayers(pastedLayers.map((l) => l.id));
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  storeLogger.debug(`Pasted ${pastedLayers.length} layer(s)`);
  return pastedLayers;
}
function cutSelectedLayers(store) {
  copySelectedLayers(store);
  const layerIds = [...useSelectionStore().selectedLayerIds];
  for (const id of layerIds) {
    deleteLayer(store, id);
  }
}
function updateLayer(store, layerId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  Object.assign(layer, updates);
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateLayerData(store, layerId, dataUpdates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.data) return;
  Object.assign(layer.data, dataUpdates);
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveLayer(store, layerId, newIndex) {
  const layers = store.getActiveCompLayers();
  const currentIndex = layers.findIndex((l) => l.id === layerId);
  if (currentIndex === -1) return;
  const [layer] = layers.splice(currentIndex, 1);
  layers.splice(newIndex, 0, layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleLayer3D(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  layer.threeD = !layer.threeD;
  if (layer.threeD) {
    const t = layer.transform;
    const pos = t.position.value;
    t.position.value = { x: pos.x, y: pos.y, z: pos.z ?? 0 };
    t.position.type = "vector3";
    const anch = t.anchorPoint.value;
    t.anchorPoint.value = { x: anch.x, y: anch.y, z: anch.z ?? 0 };
    t.anchorPoint.type = "vector3";
    const scl = t.scale.value;
    t.scale.value = { x: scl.x, y: scl.y, z: scl.z ?? 100 };
    t.scale.type = "vector3";
    if (!t.orientation) {
      t.orientation = createAnimatableProperty("orientation", { x: 0, y: 0, z: 0 }, "vector3");
    }
    if (!t.rotationX) {
      t.rotationX = createAnimatableProperty("rotationX", 0, "number");
    }
    if (!t.rotationY) {
      t.rotationY = createAnimatableProperty("rotationY", 0, "number");
    }
    if (!t.rotationZ) {
      t.rotationZ = createAnimatableProperty("rotationZ", 0, "number");
      t.rotationZ.value = t.rotation.value;
    }
  } else {
    if (layer.transform.rotationZ) {
      layer.transform.rotation.value = layer.transform.rotationZ.value;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setLayerParent(store, layerId, parentId) {
  const layers = store.getActiveCompLayers();
  const layer = layers.find((l) => l.id === layerId);
  if (!layer) return;
  if (parentId === layerId) return;
  if (parentId) {
    const getDescendants = (id) => {
      const descendants2 = /* @__PURE__ */ new Set();
      const children = layers.filter((l) => l.parentId === id);
      for (const child of children) {
        descendants2.add(child.id);
        const childDescendants = getDescendants(child.id);
        childDescendants.forEach((d) => descendants2.add(d));
      }
      return descendants2;
    };
    const descendants = getDescendants(layerId);
    if (descendants.has(parentId)) {
      storeLogger.warn("Cannot set parent: would create circular reference");
      return;
    }
  }
  layer.parentId = parentId;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function addSplineControlPoint(store, layerId, point) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  splineData.controlPoints.push(point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function insertSplineControlPoint(store, layerId, point, index) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) {
    splineData.controlPoints = [];
  }
  const insertIndex = Math.max(0, Math.min(index, splineData.controlPoints.length));
  splineData.controlPoints.splice(insertIndex, 0, point);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateSplineControlPoint(store, layerId, pointId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const point = splineData.controlPoints?.find((p) => p.id === pointId);
  if (!point) return;
  Object.assign(point, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteSplineControlPoint(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.controlPoints) return;
  const index = splineData.controlPoints.findIndex((p) => p.id === pointId);
  if (index >= 0) {
    splineData.controlPoints.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function enableSplineAnimation(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (splineData.animated && splineData.animatedControlPoints) {
    storeLogger.debug("Spline already in animated mode");
    return;
  }
  const staticPoints = splineData.controlPoints || [];
  const animatedPoints = staticPoints.map(
    (cp) => controlPointToAnimatable(cp)
  );
  splineData.animatedControlPoints = animatedPoints;
  splineData.animated = true;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug("Enabled spline animation with", animatedPoints.length, "control points");
}
function addSplinePointKeyframe(store, layerId, pointId, property, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) {
    enableSplineAnimation(store, layerId);
  }
  const point = splineData.animatedControlPoints?.find((p) => p.id === pointId);
  if (!point) {
    storeLogger.warn("Control point not found:", pointId);
    return;
  }
  let animatableProp;
  switch (property) {
    case "x":
      animatableProp = point.x;
      break;
    case "y":
      animatableProp = point.y;
      break;
    case "depth":
      animatableProp = point.depth;
      break;
    case "handleIn.x":
      animatableProp = point.handleIn?.x;
      break;
    case "handleIn.y":
      animatableProp = point.handleIn?.y;
      break;
    case "handleOut.x":
      animatableProp = point.handleOut?.x;
      break;
    case "handleOut.y":
      animatableProp = point.handleOut?.y;
      break;
  }
  if (!animatableProp) {
    storeLogger.warn("Property not found on control point:", property);
    return;
  }
  const existingIdx = animatableProp.keyframes.findIndex((k) => k.frame === frame);
  if (existingIdx >= 0) {
    animatableProp.keyframes[existingIdx].value = animatableProp.value;
  } else {
    animatableProp.keyframes.push({
      id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      frame,
      value: animatableProp.value,
      interpolation: "bezier",
      controlMode: "smooth",
      inHandle: { frame: -5, value: 0, enabled: true },
      outHandle: { frame: 5, value: 0, enabled: true }
    });
    animatableProp.keyframes.sort((a, b) => a.frame - b.frame);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug("Added keyframe to control point", pointId, "property", property, "at frame", frame);
}
function addSplinePointPositionKeyframe(store, layerId, pointId, frame) {
  addSplinePointKeyframe(store, layerId, pointId, "x", frame);
  addSplinePointKeyframe(store, layerId, pointId, "y", frame);
}
function updateSplinePointWithKeyframe(store, layerId, pointId, x, y, frame, addKeyframe = false) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  if (splineData.animated && splineData.animatedControlPoints) {
    const point = splineData.animatedControlPoints.find((p) => p.id === pointId);
    if (!point) return;
    point.x.value = x;
    point.y.value = y;
    if (addKeyframe) {
      addSplinePointPositionKeyframe(store, layerId, pointId, frame);
    }
    const staticPoint = splineData.controlPoints?.find((p) => p.id === pointId);
    if (staticPoint) {
      staticPoint.x = x;
      staticPoint.y = y;
    }
  } else {
    const point = splineData.controlPoints?.find((p) => p.id === pointId);
    if (!point) return;
    point.x = x;
    point.y = y;
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
}
function getEvaluatedSplinePoints(store, layerId, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return [];
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) {
    return (splineData.controlPoints || []).map((cp) => ({
      id: cp.id,
      x: cp.x,
      y: cp.y,
      depth: cp.depth ?? 0,
      handleIn: cp.handleIn ? { ...cp.handleIn } : null,
      handleOut: cp.handleOut ? { ...cp.handleOut } : null,
      type: cp.type
    }));
  }
  return splineData.animatedControlPoints.map((acp) => {
    const x = interpolateProperty(acp.x, frame);
    const y = interpolateProperty(acp.y, frame);
    const depth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    let handleIn = null;
    let handleOut = null;
    if (acp.handleIn) {
      handleIn = {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      };
    }
    if (acp.handleOut) {
      handleOut = {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      };
    }
    return {
      id: acp.id,
      x,
      y,
      depth,
      handleIn,
      handleOut,
      type: animatableToControlPoint(acp).type
    };
  });
}
function isSplineAnimated(store, layerId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return false;
  const splineData = layer.data;
  return !!splineData.animated;
}
function hasSplinePointKeyframes(store, layerId, pointId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return false;
  const splineData = layer.data;
  if (!splineData.animated || !splineData.animatedControlPoints) return false;
  const point = splineData.animatedControlPoints.find((p) => p.id === pointId);
  if (!point) return false;
  if (point.x.keyframes.length > 0) return true;
  if (point.y.keyframes.length > 0) return true;
  if (point.depth?.keyframes.length) return true;
  if (point.handleIn?.x.keyframes.length) return true;
  if (point.handleIn?.y.keyframes.length) return true;
  if (point.handleOut?.x.keyframes.length) return true;
  if (point.handleOut?.y.keyframes.length) return true;
  return false;
}
function simplifySpline(store, layerId, tolerance) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const controlPoints = splineData.controlPoints;
  if (!controlPoints || controlPoints.length <= 2) return;
  const points = controlPoints.map((cp) => ({ x: cp.x, y: cp.y }));
  const simplified = douglasPeuckerSimplify(points, tolerance);
  const newControlPoints = [];
  let simplifiedIdx = 0;
  for (const cp of controlPoints) {
    if (simplifiedIdx < simplified.length) {
      const sp = simplified[simplifiedIdx];
      if (Math.abs(cp.x - sp.x) < 0.01 && Math.abs(cp.y - sp.y) < 0.01) {
        newControlPoints.push(cp);
        simplifiedIdx++;
      }
    }
  }
  splineData.controlPoints = newControlPoints;
  if (splineData.animated && splineData.animatedControlPoints) {
    const newAnimatedPoints = splineData.animatedControlPoints.filter(
      (acp) => newControlPoints.some((cp) => cp.id === acp.id)
    );
    splineData.animatedControlPoints = newAnimatedPoints;
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug(`Simplified spline from ${controlPoints.length} to ${newControlPoints.length} points`);
}
function douglasPeuckerSimplify(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDist(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeuckerSimplify(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeuckerSimplify(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function perpendicularDist(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (length < 1e-4) {
    return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);
  }
  const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
  const closest = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return Math.sqrt((point.x - closest.x) ** 2 + (point.y - closest.y) ** 2);
}
function smoothSplineHandles(store, layerId, amount) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline" || !layer.data) return;
  const splineData = layer.data;
  const controlPoints = splineData.controlPoints;
  if (!controlPoints || controlPoints.length < 2) return;
  const factor = Math.max(0, Math.min(100, amount)) / 100;
  for (let i = 0; i < controlPoints.length; i++) {
    const cp = controlPoints[i];
    const prev = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
    const next = controlPoints[(i + 1) % controlPoints.length];
    if (!splineData.closed && (i === 0 || i === controlPoints.length - 1)) {
      continue;
    }
    const toPrev = { x: prev.x - cp.x, y: prev.y - cp.y };
    const toNext = { x: next.x - cp.x, y: next.y - cp.y };
    const avgDir = { x: toNext.x - toPrev.x, y: toNext.y - toPrev.y };
    const avgLength = Math.sqrt(avgDir.x * avgDir.x + avgDir.y * avgDir.y);
    if (avgLength < 0.01) continue;
    const normalized = { x: avgDir.x / avgLength, y: avgDir.y / avgLength };
    const distPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
    const distNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);
    const handleLength = (distPrev + distNext) / 6;
    const idealIn = { x: cp.x - normalized.x * handleLength, y: cp.y - normalized.y * handleLength };
    const idealOut = { x: cp.x + normalized.x * handleLength, y: cp.y + normalized.y * handleLength };
    if (cp.handleIn) {
      cp.handleIn = {
        x: cp.handleIn.x + (idealIn.x - cp.handleIn.x) * factor,
        y: cp.handleIn.y + (idealIn.y - cp.handleIn.y) * factor
      };
    } else {
      cp.handleIn = { x: idealIn.x * factor + cp.x * (1 - factor), y: idealIn.y * factor + cp.y * (1 - factor) };
    }
    if (cp.handleOut) {
      cp.handleOut = {
        x: cp.handleOut.x + (idealOut.x - cp.handleOut.x) * factor,
        y: cp.handleOut.y + (idealOut.y - cp.handleOut.y) * factor
      };
    } else {
      cp.handleOut = { x: idealOut.x * factor + cp.x * (1 - factor), y: idealOut.y * factor + cp.y * (1 - factor) };
    }
    cp.type = "smooth";
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  markLayerDirty(layerId);
  storeLogger.debug(`Smoothed spline handles with amount ${amount}%`);
}
function selectLayer(_store, layerId, addToSelection = false) {
  const selection = useSelectionStore();
  if (addToSelection) {
    selection.addToSelection(layerId);
  } else {
    selection.selectLayer(layerId);
  }
}
function deselectLayer(_store, layerId) {
  useSelectionStore().removeFromSelection(layerId);
}
function regenerateKeyframeIds(layer) {
  if (layer.transform) {
    for (const key of Object.keys(layer.transform)) {
      const prop = layer.transform[key];
      if (prop?.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
  if (layer.properties) {
    for (const prop of layer.properties) {
      if (prop.keyframes) {
        prop.keyframes = prop.keyframes.map((kf) => ({
          ...kf,
          id: crypto.randomUUID()
        }));
      }
    }
  }
}

function findPropertyByPath(layer, propertyPath) {
  const normalizedPath = propertyPath.replace(/^transform\./, "");
  if (normalizedPath === "position") {
    return layer.transform.position;
  }
  if (normalizedPath === "scale") {
    return layer.transform.scale;
  }
  if (normalizedPath === "rotation") {
    return layer.transform.rotation;
  }
  if (normalizedPath === "anchorPoint") {
    return layer.transform.anchorPoint;
  }
  if (propertyPath === "opacity") {
    return layer.opacity;
  }
  if (normalizedPath === "rotationX" && layer.transform.rotationX) {
    return layer.transform.rotationX;
  }
  if (normalizedPath === "rotationY" && layer.transform.rotationY) {
    return layer.transform.rotationY;
  }
  if (normalizedPath === "rotationZ" && layer.transform.rotationZ) {
    return layer.transform.rotationZ;
  }
  if (normalizedPath === "orientation" && layer.transform.orientation) {
    return layer.transform.orientation;
  }
  return layer.properties.find((p) => p.name === propertyPath || p.id === propertyPath);
}
function addKeyframe(store, layerId, propertyPath, value, atFrame) {
  const comp = store.getActiveComp();
  const frame = atFrame ?? (comp?.currentFrame ?? 0);
  storeLogger.debug("addKeyframe called:", { layerId, propertyPath, value, frame });
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    storeLogger.debug("addKeyframe: layer not found");
    return null;
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    storeLogger.debug("addKeyframe: property not found:", propertyPath);
    return null;
  }
  property.animated = true;
  const keyframe = {
    id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    frame,
    value,
    interpolation: "linear",
    inHandle: { frame: 0, value: 0, enabled: false },
    outHandle: { frame: 0, value: 0, enabled: false },
    controlMode: "smooth"
  };
  const existingIndex = property.keyframes.findIndex((k) => k.frame === frame);
  if (existingIndex >= 0) {
    property.keyframes[existingIndex] = keyframe;
    storeLogger.debug("addKeyframe: replaced existing keyframe at frame", frame);
  } else {
    property.keyframes.push(keyframe);
    property.keyframes.sort((a, b) => a.frame - b.frame);
    storeLogger.debug("addKeyframe: added new keyframe at frame", frame, "total keyframes:", property.keyframes.length);
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  return keyframe;
}
function removeKeyframe(store, layerId, propertyPath, keyframeId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const index = property.keyframes.findIndex((k) => k.id === keyframeId);
  if (index >= 0) {
    property.keyframes.splice(index, 1);
    if (property.keyframes.length === 0) {
      property.animated = false;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function moveKeyframe(store, layerId, propertyPath, keyframeId, newFrame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  const existingAtTarget = property.keyframes.find(
    (kf) => kf.frame === newFrame && kf.id !== keyframeId
  );
  if (existingAtTarget) {
    property.keyframes = property.keyframes.filter((kf) => kf.id !== existingAtTarget.id);
  }
  keyframe.frame = newFrame;
  property.keyframes.sort((a, b) => a.frame - b.frame);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeValue(store, layerId, propertyPath, keyframeId, newValue) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (typeof keyframe.value === "object" && keyframe.value !== null && typeof newValue === "number") {
    storeLogger.warn("setKeyframeValue: Cannot directly update vector keyframes with scalar. Use separate dimension curves.");
    return;
  }
  keyframe.value = newValue;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function updateKeyframe(store, layerId, propertyPath, keyframeId, updates) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (updates.frame !== void 0) {
    keyframe.frame = updates.frame;
    property.keyframes.sort((a, b) => a.frame - b.frame);
  }
  if (updates.value !== void 0) {
    keyframe.value = updates.value;
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeInterpolation(store, layerId, propertyPath, keyframeId, interpolation) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  keyframe.interpolation = interpolation;
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setKeyframeHandle(store, layerId, propertyPath, keyframeId, handleType, handle) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  const keyframe = property.keyframes.find((kf) => kf.id === keyframeId);
  if (!keyframe) return;
  if (handleType === "in") {
    keyframe.inHandle = { ...handle };
  } else {
    keyframe.outHandle = { ...handle };
  }
  if (handle.enabled && keyframe.interpolation === "linear") {
    keyframe.interpolation = "bezier";
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyValue(store, layerId, propertyPath, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.value = value;
  if (property.animated && property.keyframes.length > 0) {
    const currentFrame = store.getActiveComp()?.currentFrame ?? 0;
    const existingKf = property.keyframes.find((kf) => kf.frame === currentFrame);
    if (existingKf) {
      existingKf.value = value;
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setPropertyAnimated(store, layerId, propertyPath, animated, addKeyframeCallback) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) return;
  property.animated = animated;
  if (animated && property.keyframes.length === 0) {
    if (addKeyframeCallback) {
      addKeyframeCallback();
    } else {
      const comp = store.getActiveComp();
      const frame = comp?.currentFrame ?? 0;
      const keyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame,
        value: property.value,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false },
        controlMode: "smooth"
      };
      property.keyframes.push(keyframe);
    }
  }
  markLayerDirty(layerId);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}

const BLOCKED_HOSTNAMES = [
  "localhost",
  "127.0.0.1",
  "0.0.0.0",
  "::1"
  // Private IP ranges are checked separately
];
function isPrivateIP(hostname) {
  const privateRanges = [
    /^10\./,
    // 10.0.0.0/8
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
    // 172.16.0.0/12
    /^192\.168\./,
    // 192.168.0.0/16
    /^169\.254\./,
    // Link-local
    /^127\./
    // Loopback
  ];
  return privateRanges.some((range) => range.test(hostname));
}
function isValidExternalURL(url, options = {}) {
  const {
    allowData = true,
    allowBlob = true,
    allowHttp = false
    // Default to HTTPS only for external URLs
  } = options;
  try {
    const parsed = new URL(url);
    const allowedProtocols = ["https:"];
    if (allowHttp) allowedProtocols.push("http:");
    if (allowData) allowedProtocols.push("data:");
    if (allowBlob) allowedProtocols.push("blob:");
    if (!allowedProtocols.includes(parsed.protocol)) {
      console.warn(`[Security] Blocked URL with protocol: ${parsed.protocol}`);
      return false;
    }
    if (parsed.protocol === "data:" || parsed.protocol === "blob:") {
      return true;
    }
    if (BLOCKED_HOSTNAMES.includes(parsed.hostname.toLowerCase())) {
      console.warn(`[Security] Blocked URL with hostname: ${parsed.hostname}`);
      return false;
    }
    if (isPrivateIP(parsed.hostname)) {
      console.warn(`[Security] Blocked URL with private IP: ${parsed.hostname}`);
      return false;
    }
    return true;
  } catch {
    console.warn(`[Security] Invalid URL: ${url}`);
    return false;
  }
}
function validateURL(url, context = "resource loading", options = {}) {
  if (!isValidExternalURL(url, options)) {
    throw new Error(
      `[Security] Invalid or blocked URL for ${context}: ${url.substring(0, 100)}...`
    );
  }
  return url;
}
function secureUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);
  array[6] = array[6] & 15 | 64;
  array[8] = array[8] & 63 | 128;
  const hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join("");
  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
}

const logger$7 = createLogger("ProjectStorage");
const API_BASE = "/weyl/compositor";
function isValidProjectId(projectId) {
  const uuidPattern = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;
  const alphanumericPattern = /^[a-zA-Z0-9_-]{1,128}$/;
  return uuidPattern.test(projectId) || alphanumericPattern.test(projectId);
}
async function saveProject(project, projectId) {
  try {
    logger$7.info(`Saving project${projectId ? ` (${projectId})` : ""}...`);
    const response = await fetch(`${API_BASE}/save_project`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        project,
        project_id: projectId
      })
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project saved: ${result.project_id}`);
    } else {
      logger$7.error(`Failed to save project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error saving project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function loadProject(projectId) {
  if (!isValidProjectId(projectId)) {
    logger$7.error(`Invalid project ID format: ${projectId}`);
    return {
      status: "error",
      message: "Invalid project ID format"
    };
  }
  try {
    logger$7.info(`Loading project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/load_project/${encodeURIComponent(projectId)}`);
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project loaded: ${projectId}`);
    } else {
      logger$7.error(`Failed to load project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error loading project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function listProjects() {
  try {
    logger$7.info("Listing projects...");
    const response = await fetch(`${API_BASE}/list_projects`);
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Found ${result.projects?.length || 0} projects`);
    } else {
      logger$7.error(`Failed to list projects: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error listing projects:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function deleteProject(projectId) {
  try {
    logger$7.info(`Deleting project: ${projectId}...`);
    const response = await fetch(`${API_BASE}/delete_project/${encodeURIComponent(projectId)}`, {
      method: "DELETE"
    });
    const result = await response.json();
    if (result.status === "success") {
      logger$7.info(`Project deleted: ${projectId}`);
    } else {
      logger$7.error(`Failed to delete project: ${result.message}`);
    }
    return result;
  } catch (error) {
    logger$7.error("Error deleting project:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Unknown error"
    };
  }
}

const MAX_HISTORY_SIZE = 50;
function pushHistory(store) {
  if (store.historyIndex < store.historyStack.length - 1) {
    store.historyStack = store.historyStack.slice(0, store.historyIndex + 1);
  }
  const snapshot = structuredClone(toRaw(store.project));
  store.historyStack.push(snapshot);
  store.historyIndex = store.historyStack.length - 1;
  if (store.historyStack.length > MAX_HISTORY_SIZE) {
    store.historyStack = store.historyStack.slice(-MAX_HISTORY_SIZE);
    store.historyIndex = store.historyStack.length - 1;
  }
}
function undo(store) {
  if (store.historyIndex <= 0) return false;
  store.historyIndex--;
  store.project = structuredClone(store.historyStack[store.historyIndex]);
  return true;
}
function redo(store) {
  if (store.historyIndex >= store.historyStack.length - 1) return false;
  store.historyIndex++;
  store.project = structuredClone(store.historyStack[store.historyIndex]);
  return true;
}
function exportProject(store) {
  return JSON.stringify(store.project, null, 2);
}
function importProject(store, json, pushHistoryFn) {
  try {
    const project = JSON.parse(json);
    store.project = project;
    pushHistoryFn();
    return true;
  } catch (err) {
    storeLogger.error("Failed to import project:", err);
    return false;
  }
}
async function saveProjectToServer(store, projectId) {
  try {
    const result = await saveProject(store.project, projectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project saved to server:", result.project_id);
      return result.project_id;
    } else {
      storeLogger.error("Failed to save project:", result.message);
      return null;
    }
  } catch (err) {
    storeLogger.error("Error saving project to server:", err);
    return null;
  }
}
async function loadProjectFromServer(store, projectId, pushHistoryFn) {
  try {
    const result = await loadProject(projectId);
    if (result.status === "success" && result.project) {
      store.project = result.project;
      pushHistoryFn();
      store.lastSaveProjectId = projectId;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Project loaded from server:", projectId);
      return true;
    } else {
      storeLogger.error("Failed to load project:", result.message);
      return false;
    }
  } catch (err) {
    storeLogger.error("Error loading project from server:", err);
    return false;
  }
}
async function listServerProjects() {
  try {
    const result = await listProjects();
    if (result.status === "success" && result.projects) {
      return result.projects;
    }
    return [];
  } catch (err) {
    storeLogger.error("Error listing projects:", err);
    return [];
  }
}
async function deleteServerProject(projectId) {
  try {
    const result = await deleteProject(projectId);
    return result.status === "success";
  } catch (err) {
    storeLogger.error("Error deleting project:", err);
    return false;
  }
}
function startAutosave(store, performAutosaveFn) {
  if (store.autosaveTimerId !== null || !store.autosaveEnabled) {
    return;
  }
  store.autosaveTimerId = window.setInterval(
    performAutosaveFn,
    store.autosaveIntervalMs
  );
  storeLogger.info("Autosave started with interval:", store.autosaveIntervalMs);
}
function stopAutosave(store) {
  if (store.autosaveTimerId !== null && store.autosaveTimerId !== void 0) {
    window.clearInterval(store.autosaveTimerId);
    store.autosaveTimerId = null;
    storeLogger.info("Autosave stopped");
  }
}
function configureAutosave(store, options, performAutosaveFn) {
  if (options.enabled !== void 0) {
    store.autosaveEnabled = options.enabled;
  }
  if (options.intervalMs !== void 0) {
    store.autosaveIntervalMs = options.intervalMs;
  }
  stopAutosave(store);
  if (store.autosaveEnabled) {
    startAutosave(store, performAutosaveFn);
  }
}
async function performAutosave(store) {
  if (!store.hasUnsavedChanges) return;
  try {
    const existingProjectId = store.lastSaveProjectId || void 0;
    const result = await saveProject(store.project, existingProjectId);
    if (result.status === "success" && result.project_id) {
      store.lastSaveProjectId = result.project_id;
      store.lastSaveTime = Date.now();
      store.hasUnsavedChanges = false;
      storeLogger.info("Autosaved project:", result.project_id);
    } else {
      storeLogger.error("Autosave failed:", result.message);
    }
  } catch (error) {
    storeLogger.error("Autosave failed:", error);
  }
}
function markUnsavedChanges(store) {
  store.hasUnsavedChanges = true;
}

let worker = null;
let currentResolve = null;
let currentReject = null;
let currentOnProgress = null;
function ensureWorker() {
  if (!worker) {
    worker = new Worker(
      new URL(/* @vite-ignore */ "/worker-audioWorker.js", import.meta.url),
      { type: "module" }
    );
    worker.onmessage = (event) => {
      const message = event.data;
      switch (message.type) {
        case "progress":
          if (currentOnProgress) {
            currentOnProgress({
              phase: message.payload.phase,
              progress: message.payload.progress,
              message: message.payload.message
            });
          }
          break;
        case "complete":
          if (currentResolve) {
            currentResolve(message.payload);
            cleanup();
          }
          break;
        case "error":
          if (currentReject) {
            currentReject(new Error(message.payload.message));
            cleanup();
          }
          break;
      }
    };
    worker.onerror = (error) => {
      console.error("[AudioWorker] Worker error:", error);
      if (currentReject) {
        currentReject(new Error(`Worker error: ${error.message}`));
        cleanup();
      }
    };
  }
  return worker;
}
function cleanup() {
  currentResolve = null;
  currentReject = null;
  currentOnProgress = null;
}
function cancelAnalysis() {
  if (worker) {
    worker.postMessage({ type: "cancel" });
  }
}
async function analyzeAudioInWorker(audioBuffer, fps, options = {}) {
  const w = ensureWorker();
  if (currentResolve) {
    throw new Error("Analysis already in progress. Cancel it first.");
  }
  const channelData = audioBuffer.getChannelData(0);
  const channelDataCopy = new Float32Array(channelData);
  return new Promise((resolve, reject) => {
    currentResolve = resolve;
    currentReject = reject;
    currentOnProgress = options.onProgress || null;
    w.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: channelDataCopy,
          sampleRate: audioBuffer.sampleRate,
          fps
        }
      },
      [channelDataCopy.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function loadAndAnalyzeAudio(file, fps, options = {}) {
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 0,
      message: "Decoding audio file..."
    });
  }
  const arrayBuffer = await file.arrayBuffer();
  const audioContext = new AudioContext();
  let buffer;
  try {
    buffer = await audioContext.decodeAudioData(arrayBuffer);
  } finally {
    await audioContext.close();
  }
  if (options.onProgress) {
    options.onProgress({
      phase: "decoding",
      progress: 1,
      message: "Audio decoded successfully"
    });
  }
  const analysis = await analyzeAudioInWorker(buffer, fps, options);
  return { buffer, analysis };
}

function createDefaultAudioMapping(id, feature = "amplitude", target = "particle.emissionRate") {
  return {
    id: id || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature,
    target,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: false,
    threshold: 0,
    enabled: true,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class AudioReactiveMapper {
  analysis;
  mappings = /* @__PURE__ */ new Map();
  smoothedValues = /* @__PURE__ */ new Map();
  releaseEnvelopes = /* @__PURE__ */ new Map();
  // ATI-style release tracking
  beatToggleStates = /* @__PURE__ */ new Map();
  // For beat toggle/flip
  peakData = null;
  constructor(analysis) {
    this.analysis = analysis;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(peakData) {
    this.peakData = peakData;
  }
  /**
   * Add a new mapping
   */
  addMapping(mapping) {
    this.mappings.set(mapping.id, mapping);
    this.smoothedValues.set(mapping.id, 0);
    this.releaseEnvelopes.set(mapping.id, 0);
    this.beatToggleStates.set(mapping.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(id) {
    this.mappings.delete(id);
    this.smoothedValues.delete(id);
    this.releaseEnvelopes.delete(id);
    this.beatToggleStates.delete(id);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(id, updates) {
    const mapping = this.mappings.get(id);
    if (mapping) {
      Object.assign(mapping, updates);
    }
  }
  /**
   * Get a specific mapping
   */
  getMapping(id) {
    return this.mappings.get(id);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(layerId) {
    return Array.from(this.mappings.values()).filter(
      (m) => m.targetLayerId === layerId || m.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(target) {
    return Array.from(this.mappings.values()).filter((m) => m.target === target);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(feature, frame) {
    if (feature === "peaks") {
      if (this.peakData) {
        return isPeakAtFrame(this.peakData, frame) ? 1 : 0;
      }
      return 0;
    }
    return getFeatureAtFrame(this.analysis, feature, frame);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(mappingId, frame) {
    const mapping = this.mappings.get(mappingId);
    if (!mapping || !mapping.enabled) return 0;
    let value = this.getFeatureAtFrame(mapping.feature, frame);
    if (value < mapping.threshold) {
      value = 0;
    }
    if (mapping.amplitudeCurve !== 1) {
      value = Math.pow(value, mapping.amplitudeCurve);
    }
    const releaseEnvelope = this.releaseEnvelopes.get(mappingId) || 0;
    if (value > releaseEnvelope) {
      this.releaseEnvelopes.set(mappingId, value);
    } else {
      const decayRate = 1 - mapping.release * 0.98;
      const newEnvelope = releaseEnvelope * decayRate;
      this.releaseEnvelopes.set(mappingId, newEnvelope);
      value = Math.max(value, newEnvelope);
    }
    if (mapping.beatResponse !== "none") {
      const isBeat = this.analysis.onsets.includes(frame) && this.getFeatureAtFrame(mapping.feature, frame) > mapping.beatThreshold;
      if (isBeat) {
        const currentToggle = this.beatToggleStates.get(mappingId) || 0;
        switch (mapping.beatResponse) {
          case "flip":
            this.beatToggleStates.set(mappingId, currentToggle === 0 ? 1 : 0);
            break;
          case "pulse":
            value = 1;
            break;
          case "toggle":
            const newToggle = currentToggle === 0 ? 1 : 0;
            this.beatToggleStates.set(mappingId, newToggle);
            value = newToggle;
            break;
        }
      }
      if (mapping.beatResponse === "flip") {
        const toggle = this.beatToggleStates.get(mappingId) || 0;
        if (toggle === 1) {
          value = 1 - value;
        }
      }
    }
    value = this.applyCurve(value, mapping.curve);
    if (mapping.invert) {
      value = 1 - value;
    }
    value *= mapping.sensitivity;
    value += mapping.offset;
    value = Math.max(mapping.min, Math.min(mapping.max, value));
    const prevSmoothed = this.smoothedValues.get(mappingId) || 0;
    const smoothed = prevSmoothed * mapping.smoothing + value * (1 - mapping.smoothing);
    this.smoothedValues.set(mappingId, smoothed);
    return smoothed;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(layerId, frame) {
    const values = /* @__PURE__ */ new Map();
    for (const mapping of this.mappings.values()) {
      if (!mapping.enabled) continue;
      if (mapping.targetLayerId && mapping.targetLayerId !== layerId) continue;
      const value = this.getValueAtFrame(mapping.id, frame);
      const existing = values.get(mapping.target);
      if (existing !== void 0) {
        values.set(mapping.target, existing + value);
      } else {
        values.set(mapping.target, value);
      }
    }
    return values;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(value, curve) {
    const clamped = Math.max(0, Math.min(1, value));
    switch (curve) {
      case "exponential":
        return clamped * clamped;
      case "logarithmic":
        return Math.sqrt(clamped);
      case "smoothstep":
        return clamped * clamped * (3 - 2 * clamped);
      case "bounce":
        if (clamped < 0.5) {
          return 2 * clamped * clamped;
        } else {
          const t = clamped - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * t, 2));
        }
      case "linear":
      default:
        return clamped;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
    for (const mapping of this.mappings.values()) {
      this.smoothedValues.set(mapping.id, 0);
      this.releaseEnvelopes.set(mapping.id, 0);
      this.beatToggleStates.set(mapping.id, 0);
    }
  }
  /**
   * Update analysis data
   */
  setAnalysis(analysis) {
    this.analysis = analysis;
    this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear();
    this.smoothedValues.clear();
    this.releaseEnvelopes.clear();
    this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(mappings) {
    this.clear();
    for (const mapping of mappings) {
      this.addMapping(mapping);
    }
  }
}
function getFeatureDisplayName(feature) {
  const names = {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  };
  return names[feature] || feature;
}
function getTargetDisplayName(target) {
  const splineMatch = target.match(/^spline\.controlPoint\.(\d+)\.(x|y|depth)$/);
  if (splineMatch) {
    const index = splineMatch[1];
    const prop = splineMatch[2] === "x" ? "X" : splineMatch[2] === "y" ? "Y" : "Depth";
    return `Spline: Control Point ${index} ${prop}`;
  }
  const names = {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  };
  return names[target] || target;
}
function getAllFeatures() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function getFeaturesByCategory() {
  return {
    "Energy": ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    "Spectral": ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    "Events": ["onsets", "peaks"],
    "Harmonic": ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function getTargetsByCategory() {
  return {
    "Particle": [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    "Depthflow": [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    "Path": ["path.position"],
    "Layer": [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
    // Note: 'Spline' targets are generated dynamically based on control point count
    // Use createSplineControlPointTargets() to get targets for a specific spline
  };
}

const DEFAULT_CONFIG$2 = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: true,
  beatThreshold: 0.05,
  motionBlur: false,
  motionBlurStrength: 0.5
};
class AudioPathAnimator {
  config;
  state;
  pathSegments = [];
  totalLength = 0;
  releaseState = 0;
  // For amplitude mode release tracking
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$2, ...config };
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(pathData) {
    this.pathSegments = this.parsePath(pathData);
    this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(pathData) {
    const segments = [];
    const commands = pathData.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let currentX = 0;
    let currentY = 0;
    for (const cmd of commands) {
      const type = cmd[0].toUpperCase();
      const nums = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter((n) => !isNaN(n));
      switch (type) {
        case "M":
          currentX = nums[0] || 0;
          currentY = nums[1] || 0;
          segments.push({
            type: "M",
            points: [currentX, currentY],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          segments.push({
            type: "L",
            points: [currentX, currentY, nums[0], nums[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[0];
          currentY = nums[1];
          break;
        case "C":
          segments.push({
            type: "C",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[4];
          currentY = nums[5];
          break;
        case "Q":
          segments.push({
            type: "Q",
            points: [currentX, currentY, nums[0], nums[1], nums[2], nums[3]],
            length: 0,
            startT: 0,
            endT: 0
          });
          currentX = nums[2];
          currentY = nums[3];
          break;
        case "Z":
          const firstMove = segments.find((s) => s.type === "M");
          if (firstMove) {
            segments.push({
              type: "L",
              points: [currentX, currentY, firstMove.points[0], firstMove.points[1]],
              length: 0,
              startT: 0,
              endT: 0
            });
          }
          break;
      }
    }
    return segments;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let totalLength = 0;
    for (const segment of this.pathSegments) {
      switch (segment.type) {
        case "M":
          segment.length = 0;
          break;
        case "L":
          segment.length = this.lineLength(segment.points);
          break;
        case "C":
          segment.length = this.bezierLength(segment.points, 3);
          break;
        case "Q":
          segment.length = this.bezierLength(segment.points, 2);
          break;
      }
      segment.startT = totalLength;
      totalLength += segment.length;
      segment.endT = totalLength;
    }
    this.totalLength = totalLength;
    if (this.totalLength > 0) {
      for (const segment of this.pathSegments) {
        segment.startT /= this.totalLength;
        segment.endT /= this.totalLength;
      }
    }
  }
  lineLength(points) {
    const dx = points[2] - points[0];
    const dy = points[3] - points[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  bezierLength(points, degree) {
    const steps = 20;
    let length = 0;
    let prevX = points[0];
    let prevY = points[1];
    for (let i = 1; i <= steps; i++) {
      const t = i / steps;
      const { x, y } = this.getBezierPoint(points, t, degree);
      const dx = x - prevX;
      const dy = y - prevY;
      length += Math.sqrt(dx * dx + dy * dy);
      prevX = x;
      prevY = y;
    }
    return length;
  }
  getBezierPoint(points, t, degree) {
    if (degree === 2) {
      const mt = 1 - t;
      return {
        x: mt * mt * points[0] + 2 * mt * t * points[2] + t * t * points[4],
        y: mt * mt * points[1] + 2 * mt * t * points[3] + t * t * points[5]
      };
    } else {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;
      return {
        x: mt2 * mt * points[0] + 3 * mt2 * t * points[2] + 3 * mt * t2 * points[4] + t2 * t * points[6],
        y: mt2 * mt * points[1] + 3 * mt2 * t * points[3] + 3 * mt * t2 * points[5] + t2 * t * points[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(audioValue, isBeat) {
    this.state.previousPosition = this.state.position;
    const smoothedInput = this.state.smoothedValue * this.config.smoothing + audioValue * (1 - this.config.smoothing);
    this.state.smoothedValue = smoothedInput;
    if (this.config.movementMode === "amplitude") {
      this.updateAmplitudeMode(smoothedInput);
    } else {
      this.updateAccumulateMode(smoothedInput, isBeat);
    }
    const pathPoint = this.getPositionOnPath(this.state.position);
    this.state.x = pathPoint.x;
    this.state.y = pathPoint.y;
    this.state.angle = pathPoint.angle;
    return { ...this.state };
  }
  updateAmplitudeMode(audioValue) {
    let processedValue = Math.pow(audioValue, this.config.amplitudeCurve);
    if (processedValue > this.releaseState) {
      this.releaseState = processedValue;
    } else {
      const decayRate = 1 - this.config.release * 0.95;
      this.releaseState *= decayRate;
    }
    const finalValue = Math.max(processedValue, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, finalValue * this.config.sensitivity));
  }
  updateAccumulateMode(audioValue, isBeat) {
    if (this.config.flipOnBeat && isBeat && audioValue > this.config.beatThreshold) {
      this.state.direction *= -1;
    }
    const delta = audioValue * this.config.sensitivity * 0.02 * this.state.direction;
    let newPosition = this.state.position + delta;
    if (newPosition > 1) {
      newPosition = 2 - newPosition;
      this.state.direction = -1;
    } else if (newPosition < 0) {
      newPosition = -newPosition;
      this.state.direction = 1;
    }
    this.state.position = Math.max(0, Math.min(1, newPosition));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(t) {
    t = Math.max(0, Math.min(1, t));
    if (this.pathSegments.length === 0) {
      return { x: 0, y: 0, angle: 0 };
    }
    let segment = this.pathSegments[0];
    for (const seg of this.pathSegments) {
      if (seg.type !== "M" && t >= seg.startT && t <= seg.endT) {
        segment = seg;
        break;
      }
    }
    if (segment.type === "M") {
      return { x: segment.points[0], y: segment.points[1], angle: 0 };
    }
    const segmentT = segment.endT > segment.startT ? (t - segment.startT) / (segment.endT - segment.startT) : 0;
    let x, y;
    let tangentX, tangentY;
    switch (segment.type) {
      case "L":
        x = segment.points[0] + (segment.points[2] - segment.points[0]) * segmentT;
        y = segment.points[1] + (segment.points[3] - segment.points[1]) * segmentT;
        tangentX = segment.points[2] - segment.points[0];
        tangentY = segment.points[3] - segment.points[1];
        break;
      case "Q": {
        const result = this.getBezierPoint(segment.points, segmentT, 2);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        tangentX = 2 * mt * (segment.points[2] - segment.points[0]) + 2 * segmentT * (segment.points[4] - segment.points[2]);
        tangentY = 2 * mt * (segment.points[3] - segment.points[1]) + 2 * segmentT * (segment.points[5] - segment.points[3]);
        break;
      }
      case "C": {
        const result = this.getBezierPoint(segment.points, segmentT, 3);
        x = result.x;
        y = result.y;
        const mt = 1 - segmentT;
        const mt2 = mt * mt;
        const t2 = segmentT * segmentT;
        tangentX = 3 * mt2 * (segment.points[2] - segment.points[0]) + 6 * mt * segmentT * (segment.points[4] - segment.points[2]) + 3 * t2 * (segment.points[6] - segment.points[4]);
        tangentY = 3 * mt2 * (segment.points[3] - segment.points[1]) + 6 * mt * segmentT * (segment.points[5] - segment.points[3]) + 3 * t2 * (segment.points[7] - segment.points[5]);
        break;
      }
      default:
        x = 0;
        y = 0;
        tangentX = 1;
        tangentY = 0;
    }
    const angle = Math.atan2(tangentY, tangentX);
    return { x, y, angle };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(steps = 5) {
    if (!this.config.motionBlur) return [];
    const trail = [];
    const startT = this.state.previousPosition;
    const endT = this.state.position;
    for (let i = 0; i <= steps; i++) {
      const t = startT + (endT - startT) * (i / steps);
      const pos = this.getPositionOnPath(t);
      const opacity = i / steps * this.config.motionBlurStrength;
      trail.push({ x: pos.x, y: pos.y, opacity });
    }
    return trail;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
    this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(updates) {
    Object.assign(this.config, updates);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}

async function loadAudio(store, file) {
  store.audioFile = file;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioLoadingState = "decoding";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "Preparing...";
  store.audioLoadingError = null;
  try {
    const result = await loadAndAnalyzeAudio(
      file,
      store.project.composition.fps,
      {
        onProgress: (progress) => {
          if (progress.phase === "decoding") {
            store.audioLoadingState = "decoding";
          } else {
            store.audioLoadingState = "analyzing";
          }
          store.audioLoadingProgress = progress.progress;
          store.audioLoadingPhase = progress.message;
        }
      }
    );
    store.audioBuffer = result.buffer;
    store.audioAnalysis = result.analysis;
    store.audioLoadingState = "complete";
    store.audioLoadingProgress = 1;
    store.audioLoadingPhase = "Complete";
    initializeAudioReactiveMapper(store);
    if (store.propertyDriverSystem && store.audioAnalysis) {
      store.propertyDriverSystem.setAudioAnalysis(store.audioAnalysis);
    }
    storeLogger.debug("Audio loaded:", {
      duration: store.audioBuffer.duration,
      bpm: store.audioAnalysis.bpm,
      frameCount: store.audioAnalysis.frameCount
    });
  } catch (error) {
    storeLogger.error("Failed to load audio:", error);
    store.audioFile = null;
    store.audioBuffer = null;
    store.audioAnalysis = null;
    store.audioReactiveMapper = null;
    store.audioLoadingState = "error";
    store.audioLoadingError = error.message;
  }
}
function cancelAudioLoad(store) {
  cancelAnalysis();
  store.audioLoadingState = "idle";
  store.audioLoadingProgress = 0;
  store.audioLoadingPhase = "";
  store.audioLoadingError = null;
}
function clearAudio(store) {
  cancelAudioLoad(store);
  store.audioFile = null;
  store.audioBuffer = null;
  store.audioAnalysis = null;
  store.audioMappings.clear();
}
function getAudioFeatureAtFrame(store, feature, frame) {
  if (!store.audioAnalysis) return 0;
  return getFeatureAtFrame(store.audioAnalysis, feature, frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function setPeakData(store, peakData) {
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
}
function detectAudioPeaks(store, config) {
  if (!store.audioAnalysis) return null;
  const weights = store.audioAnalysis.amplitudeEnvelope;
  const peakData = detectPeaks(weights, config);
  store.peakData = peakData;
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.setPeakData(peakData);
  }
  return peakData;
}
function addAudioMapping(store, mapping) {
  store.audioReactiveMappings.push(mapping);
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.addMapping(mapping);
  }
}
function removeAudioMapping(store, mappingId) {
  const index = store.audioReactiveMappings.findIndex((m) => m.id === mappingId);
  if (index >= 0) {
    store.audioReactiveMappings.splice(index, 1);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.removeMapping(mappingId);
  }
}
function updateAudioMapping(store, mappingId, updates) {
  const mapping = store.audioReactiveMappings.find((m) => m.id === mappingId);
  if (mapping) {
    Object.assign(mapping, updates);
  }
  if (store.audioReactiveMapper) {
    store.audioReactiveMapper.updateMapping(mappingId, updates);
  }
}
function getMappedValueAtFrame(store, mappingId, frame) {
  if (!store.audioReactiveMapper) return 0;
  return store.audioReactiveMapper.getValueAtFrame(mappingId, frame);
}
function getAllMappedValuesAtFrame(store, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getAllValuesAtFrame(frame ?? (store.getActiveComp()?.currentFrame ?? 0));
}
function getActiveMappingsForLayer(store, layerId) {
  return store.audioReactiveMappings.filter(
    (m) => m.enabled && (m.targetLayerId === layerId || m.targetLayerId === void 0)
  );
}
function getAudioReactiveValuesForLayer(store, layerId, frame) {
  if (!store.audioReactiveMapper) return /* @__PURE__ */ new Map();
  return store.audioReactiveMapper.getValuesForLayerAtFrame(layerId, frame);
}
function isBeatAtCurrentFrame(store) {
  if (!store.audioAnalysis) return false;
  return isBeatAtFrame(store.audioAnalysis, store.getActiveComp()?.currentFrame ?? 0);
}
function initializeAudioReactiveMapper(store) {
  if (!store.audioAnalysis) return;
  store.audioReactiveMapper = new AudioReactiveMapper(store.audioAnalysis);
  for (const mapping of store.audioReactiveMappings) {
    store.audioReactiveMapper.addMapping(mapping);
  }
  if (store.peakData) {
    store.audioReactiveMapper.setPeakData(store.peakData);
  }
}
function createPathAnimator(store, layerId, config = {}) {
  const animator = new AudioPathAnimator(config);
  store.pathAnimators.set(layerId, animator);
}
function setPathAnimatorPath(store, layerId, pathData) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setPath(pathData);
  }
}
function updatePathAnimatorConfig(store, layerId, config) {
  const animator = store.pathAnimators.get(layerId);
  if (animator) {
    animator.setConfig(config);
  }
}
function removePathAnimator(store, layerId) {
  store.pathAnimators.delete(layerId);
}
function getPathAnimator(store, layerId) {
  return store.pathAnimators.get(layerId);
}
function updatePathAnimators(store) {
  if (!store.audioAnalysis) return;
  const frame = store.getActiveComp()?.currentFrame ?? 0;
  const amplitude = getFeatureAtFrame(store.audioAnalysis, "amplitude", frame);
  const isBeat = isBeatAtFrame(store.audioAnalysis, frame);
  for (const [_layerId, animator] of store.pathAnimators) {
    animator.update(amplitude, isBeat);
  }
}
function resetPathAnimators(store) {
  for (const animator of store.pathAnimators.values()) {
    animator.reset();
  }
}
function applyAudioToParticles(store, layerId, mapping) {
  const existing = store.audioMappings.get(layerId) || [];
  existing.push(mapping);
  store.audioMappings.set(layerId, existing);
}
function removeLegacyAudioMapping(store, layerId, index) {
  const mappings = store.audioMappings.get(layerId);
  if (mappings) {
    mappings.splice(index, 1);
    if (mappings.length === 0) {
      store.audioMappings.delete(layerId);
    }
  }
}
function getAudioMappingsForLayer(store, layerId) {
  return store.audioMappings.get(layerId) || [];
}

function getEvaluatedLayerProperties(store, layerId, frame) {
  if (!store.propertyDriverSystem) {
    return /* @__PURE__ */ new Map();
  }
  const layer = store.getLayer(layerId);
  if (!layer) return /* @__PURE__ */ new Map();
  const baseValues = /* @__PURE__ */ new Map();
  const pos = interpolateProperty(layer.transform.position, frame);
  baseValues.set("transform.position.x", pos.x);
  baseValues.set("transform.position.y", pos.y);
  const scale = interpolateProperty(layer.transform.scale, frame);
  baseValues.set("transform.scale.x", scale.x);
  baseValues.set("transform.scale.y", scale.y);
  baseValues.set("transform.rotation", interpolateProperty(layer.transform.rotation, frame));
  if (layer.transform.rotationX) {
    baseValues.set("transform.rotationX", interpolateProperty(layer.transform.rotationX, frame));
  }
  if (layer.transform.rotationY) {
    baseValues.set("transform.rotationY", interpolateProperty(layer.transform.rotationY, frame));
  }
  if (layer.transform.rotationZ) {
    baseValues.set("transform.rotationZ", interpolateProperty(layer.transform.rotationZ, frame));
  }
  baseValues.set("opacity", interpolateProperty(layer.opacity, frame));
  return store.propertyDriverSystem.evaluateLayerDrivers(layerId, frame, baseValues);
}
function addPropertyDriver(store, driver) {
  if (store.propertyDriverSystem) {
    const added = store.propertyDriverSystem.addDriver(driver);
    if (!added) {
      storeLogger.warn("Cannot add property driver: would create circular dependency");
      return false;
    }
  }
  store.propertyDrivers.push(driver);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  return true;
}
function createAudioPropertyDriver(store, targetLayerId, targetProperty, audioFeature, options = {}) {
  const driver = createAudioDriver(targetLayerId, targetProperty, audioFeature, options);
  addPropertyDriver(store, driver);
  return driver;
}
function createPropertyLinkDriver(store, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
  const driver = createPropertyLink(
    targetLayerId,
    targetProperty,
    sourceLayerId,
    sourceProperty,
    options
  );
  const success = addPropertyDriver(store, driver);
  if (!success) {
    return null;
  }
  return driver;
}
function removePropertyDriver(store, driverId) {
  const index = store.propertyDrivers.findIndex((d) => d.id === driverId);
  if (index >= 0) {
    store.propertyDrivers.splice(index, 1);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.removeDriver(driverId);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function updatePropertyDriver(store, driverId, updates) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    Object.assign(driver, updates);
  }
  if (store.propertyDriverSystem) {
    store.propertyDriverSystem.updateDriver(driverId, updates);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function getDriversForLayer(store, layerId) {
  return store.propertyDrivers.filter((d) => d.targetLayerId === layerId);
}
function togglePropertyDriver(store, driverId) {
  const driver = store.propertyDrivers.find((d) => d.id === driverId);
  if (driver) {
    driver.enabled = !driver.enabled;
    if (store.propertyDriverSystem) {
      store.propertyDriverSystem.updateDriver(driverId, { enabled: driver.enabled });
    }
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}

async function estimateVRAM(adapter) {
  try {
    const device = await adapter.requestDevice();
    const maxBufferSize = device.limits.maxBufferSize;
    device.destroy();
    return Math.round(maxBufferSize * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function detectGPUTier() {
  if ("gpu" in navigator) {
    try {
      const gpu = navigator.gpu;
      const adapter = await gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (adapter) {
        let deviceName = "";
        if ("info" in adapter) {
          const info = adapter.info;
          deviceName = info?.device || info?.description || "";
        }
        if (deviceName.includes("RTX 50") || deviceName.toLowerCase().includes("blackwell") || deviceName.includes("B100") || deviceName.includes("B200")) {
          return {
            tier: "blackwell",
            vram: await estimateVRAM(adapter),
            features: ["fp4_tensor", "webgpu", "cuda_12"]
          };
        }
        return {
          tier: "webgpu",
          vram: await estimateVRAM(adapter),
          features: ["webgpu"]
        };
      }
    } catch (error) {
      engineLogger.warn("WebGPU detection failed:", error);
    }
  }
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl2");
  if (gl) {
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
    engineLogger.debug("WebGL renderer:", renderer);
    return {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}

const TIER_CONFIGS = {
  blackwell: {
    maxFrames: 500,
    maxMemoryBytes: 4 * 1024 * 1024 * 1024,
    // 4GB
    compression: false,
    // Fast GPU, no need for compression
    preCacheWindow: 30
  },
  webgpu: {
    maxFrames: 200,
    maxMemoryBytes: 1 * 1024 * 1024 * 1024,
    // 1GB
    compression: true,
    preCacheWindow: 15
  },
  webgl: {
    maxFrames: 100,
    maxMemoryBytes: 512 * 1024 * 1024,
    // 512MB
    compression: true,
    preCacheWindow: 10
  },
  cpu: {
    maxFrames: 50,
    maxMemoryBytes: 256 * 1024 * 1024,
    // 256MB
    compression: true,
    preCacheWindow: 5
  }
};
const DEFAULT_CONFIG$1 = {
  maxFrames: 100,
  maxMemoryBytes: 512 * 1024 * 1024,
  compression: true,
  compressionQuality: 0.92,
  preCacheWindow: 10,
  predictivePreCache: true
};
class LRUTracker {
  nodeMap = /* @__PURE__ */ new Map();
  head = null;
  // Oldest
  tail = null;
  // Most recent
  add(key) {
    if (this.nodeMap.has(key)) {
      this.moveToEnd(key);
      return;
    }
    const node = { key, prev: null, next: null };
    if (!this.tail) {
      this.head = this.tail = node;
    } else {
      node.prev = this.tail;
      this.tail.next = node;
      this.tail = node;
    }
    this.nodeMap.set(key, node);
  }
  moveToEnd(key) {
    const node = this.nodeMap.get(key);
    if (!node || node === this.tail) return;
    if (node.prev) node.prev.next = node.next;
    if (node.next) node.next.prev = node.prev;
    if (node === this.head) this.head = node.next;
    node.prev = this.tail;
    node.next = null;
    if (this.tail) this.tail.next = node;
    this.tail = node;
  }
  remove(key) {
    const node = this.nodeMap.get(key);
    if (!node) return;
    if (node.prev) node.prev.next = node.next;
    if (node.next) node.next.prev = node.prev;
    if (node === this.head) this.head = node.next;
    if (node === this.tail) this.tail = node.prev;
    this.nodeMap.delete(key);
  }
  getOldest() {
    return this.head?.key ?? null;
  }
  has(key) {
    return this.nodeMap.has(key);
  }
  clear() {
    this.nodeMap.clear();
    this.head = null;
    this.tail = null;
  }
  get size() {
    return this.nodeMap.size;
  }
}
class FrameCache {
  cache = /* @__PURE__ */ new Map();
  lru = new LRUTracker();
  // O(1) LRU tracking
  config;
  currentMemory = 0;
  stats = { hits: 0, misses: 0 };
  // Secondary index: compositionId -> Set of cache keys (for O(1) clearComposition)
  compositionKeyMap = /* @__PURE__ */ new Map();
  // Pre-caching state
  preCacheQueue = [];
  isPreCaching = false;
  preCacheAbort = null;
  // Composition state tracking
  stateHashCache = /* @__PURE__ */ new Map();
  // Frame render callback (set by engine)
  renderFrame = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG$1, ...config };
  }
  /**
   * Initialize cache with GPU-tier-appropriate settings
   */
  async initializeForGPU() {
    const tier = await detectGPUTier();
    const tierConfig = TIER_CONFIGS[tier.tier];
    this.config = { ...this.config, ...tierConfig };
  }
  /**
   * Set the frame render callback
   * This is called to render frames for pre-caching
   */
  setRenderCallback(callback) {
    this.renderFrame = callback;
  }
  /**
   * Generate a cache key for a frame
   */
  getCacheKey(frame, compositionId) {
    return `${compositionId}:${frame}`;
  }
  /**
   * Get a cached frame
   * @returns The cached frame or null if not found/invalid
   */
  get(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.lru.moveToEnd(key);
    this.stats.hits++;
    if (cached.compressed) {
      return null;
    }
    return cached.data;
  }
  /**
   * Get a cached frame (async, supports compression)
   */
  async getAsync(frame, compositionId, currentStateHash) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (!cached) {
      this.stats.misses++;
      return null;
    }
    if (currentStateHash && cached.stateHash !== currentStateHash) {
      this.remove(frame, compositionId);
      this.stats.misses++;
      return null;
    }
    this.lru.moveToEnd(key);
    this.stats.hits++;
    if (cached.compressed) {
      return this.decompressFrame(cached);
    }
    return cached.data;
  }
  /**
   * Cache a frame
   */
  async set(frame, compositionId, imageData, stateHash) {
    const key = this.getCacheKey(frame, compositionId);
    if (this.cache.has(key)) {
      this.remove(frame, compositionId);
    }
    let data = imageData;
    let compressed = false;
    let size = imageData.width * imageData.height * 4;
    if (this.config.compression) {
      const compressedData = await this.compressFrame(imageData);
      if (compressedData.size < size * 0.7) {
        data = compressedData;
        compressed = true;
        size = compressedData.size;
      }
    }
    await this.ensureCapacity(size);
    const cachedFrame = {
      frame,
      compositionId,
      data,
      compressed,
      width: imageData.width,
      height: imageData.height,
      timestamp: Date.now(),
      size,
      stateHash
    };
    this.cache.set(key, cachedFrame);
    this.lru.add(key);
    this.currentMemory += size;
    let keySet = this.compositionKeyMap.get(compositionId);
    if (!keySet) {
      keySet = /* @__PURE__ */ new Set();
      this.compositionKeyMap.set(compositionId, keySet);
    }
    keySet.add(key);
  }
  /**
   * Remove a cached frame - O(1)
   */
  remove(frame, compositionId) {
    const key = this.getCacheKey(frame, compositionId);
    const cached = this.cache.get(key);
    if (cached) {
      this.currentMemory -= cached.size;
      this.cache.delete(key);
      this.lru.remove(key);
      const keySet = this.compositionKeyMap.get(compositionId);
      if (keySet) {
        keySet.delete(key);
        if (keySet.size === 0) {
          this.compositionKeyMap.delete(compositionId);
        }
      }
    }
  }
  /**
   * Check if a frame is cached
   */
  has(frame, compositionId) {
    return this.cache.has(this.getCacheKey(frame, compositionId));
  }
  /**
   * Clear all cached frames for a composition - O(k) where k = frames for this composition
   * Uses secondary index for direct lookup instead of O(n) iteration
   */
  clearComposition(compositionId) {
    const keySet = this.compositionKeyMap.get(compositionId);
    if (!keySet) return;
    for (const key of Array.from(keySet)) {
      const cached = this.cache.get(key);
      if (cached) {
        this.currentMemory -= cached.size;
      }
      this.cache.delete(key);
      this.lru.remove(key);
    }
    this.compositionKeyMap.delete(compositionId);
  }
  /**
   * Clear all cached frames
   */
  clear() {
    this.cache.clear();
    this.lru.clear();
    this.compositionKeyMap.clear();
    this.currentMemory = 0;
    this.stats = { hits: 0, misses: 0 };
    this.abortPreCache();
  }
  /**
   * Invalidate cache for a composition (when state changes)
   */
  invalidate(compositionId, newStateHash) {
    const oldHash = this.stateHashCache.get(compositionId);
    if (oldHash !== newStateHash) {
      this.clearComposition(compositionId);
      this.stateHashCache.set(compositionId, newStateHash);
    }
  }
  /**
   * Start predictive pre-caching around the current frame
   */
  async startPreCache(currentFrame, compositionId, stateHash, direction = "both") {
    if (!this.config.predictivePreCache || !this.renderFrame) {
      return;
    }
    this.abortPreCache();
    this.preCacheAbort = new AbortController();
    const signal = this.preCacheAbort.signal;
    this.preCacheQueue = [];
    const window = this.config.preCacheWindow;
    for (let i = 1; i <= window; i++) {
      if (direction !== "backward") {
        this.preCacheQueue.push({
          frame: currentFrame + i,
          compositionId,
          priority: window - i
          // Closer frames have higher priority
        });
      }
      if (direction !== "forward") {
        this.preCacheQueue.push({
          frame: currentFrame - i,
          compositionId,
          priority: window - i
        });
      }
    }
    this.preCacheQueue.sort((a, b) => b.priority - a.priority);
    this.isPreCaching = true;
    for (const item of this.preCacheQueue) {
      if (signal.aborted) {
        break;
      }
      if (!this.has(item.frame, item.compositionId)) {
        try {
          const imageData = await this.renderFrame(item.frame);
          if (!signal.aborted) {
            await this.set(item.frame, item.compositionId, imageData, stateHash);
          }
        } catch (error) {
          console.warn(`Pre-cache failed for frame ${item.frame}:`, error);
        }
      }
    }
    this.isPreCaching = false;
  }
  /**
   * Abort any ongoing pre-cache operation
   */
  abortPreCache() {
    if (this.preCacheAbort) {
      this.preCacheAbort.abort();
      this.preCacheAbort = null;
    }
    this.preCacheQueue = [];
    this.isPreCaching = false;
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    return {
      cachedFrames: this.cache.size,
      memoryUsed: this.currentMemory,
      hitRatio: total > 0 ? this.stats.hits / total : 0,
      hits: this.stats.hits,
      misses: this.stats.misses
    };
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  async ensureCapacity(requiredSize) {
    while ((this.cache.size >= this.config.maxFrames || this.currentMemory + requiredSize > this.config.maxMemoryBytes) && this.lru.size > 0) {
      const oldestKey = this.lru.getOldest();
      if (!oldestKey) break;
      const cached = this.cache.get(oldestKey);
      if (cached) {
        this.currentMemory -= cached.size;
        this.cache.delete(oldestKey);
        const compositionId = oldestKey.split(":")[0];
        const keySet = this.compositionKeyMap.get(compositionId);
        if (keySet) {
          keySet.delete(oldestKey);
          if (keySet.size === 0) {
            this.compositionKeyMap.delete(compositionId);
          }
        }
      }
      this.lru.remove(oldestKey);
    }
  }
  async compressFrame(imageData) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: "image/webp",
      quality: this.config.compressionQuality
    });
  }
  async decompressFrame(cached) {
    if (!(cached.data instanceof Blob)) {
      return cached.data;
    }
    const bitmap = await createImageBitmap(cached.data);
    const canvas = new OffscreenCanvas(cached.width, cached.height);
    const ctx = canvas.getContext("2d");
    ctx.drawImage(bitmap, 0, 0);
    bitmap.close();
    return ctx.getImageData(0, 0, cached.width, cached.height);
  }
}
let globalFrameCache = null;
function getFrameCache() {
  if (!globalFrameCache) {
    globalFrameCache = new FrameCache();
  }
  return globalFrameCache;
}
async function initializeFrameCache() {
  const cache = getFrameCache();
  await cache.initializeForGPU();
  return cache;
}

async function initializeCache(store) {
  if (store.frameCacheEnabled) {
    await initializeFrameCache();
    storeLogger.info("Frame cache initialized");
  }
}
function setFrameCacheEnabled(store, enabled) {
  store.frameCacheEnabled = enabled;
  if (!enabled) {
    clearFrameCache();
  }
  storeLogger.info("Frame cache", enabled ? "enabled" : "disabled");
}
function getCachedFrame(store, frame) {
  if (!store.frameCacheEnabled) return null;
  const cache = getFrameCache();
  return cache.get(frame, store.activeCompositionId, store.projectStateHash);
}
async function cacheFrame(store, frame, imageData) {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.set(frame, store.activeCompositionId, imageData, store.projectStateHash);
}
function isFrameCached(store, frame) {
  if (!store.frameCacheEnabled) return false;
  const cache = getFrameCache();
  return cache.has(frame, store.activeCompositionId);
}
async function startPreCache(store, currentFrame, direction = "both") {
  if (!store.frameCacheEnabled) return;
  const cache = getFrameCache();
  await cache.startPreCache(currentFrame, store.activeCompositionId, store.projectStateHash, direction);
}
function invalidateFrameCache(store) {
  store.projectStateHash = computeProjectHash(store);
  const cache = getFrameCache();
  cache.invalidate(store.activeCompositionId, store.projectStateHash);
}
function clearFrameCache() {
  const cache = getFrameCache();
  cache.clear();
  storeLogger.info("Frame cache cleared");
}
function getFrameCacheStats() {
  const cache = getFrameCache();
  return cache.getStats();
}
function computeProjectHash(store) {
  const comp = store.project.compositions[store.activeCompositionId];
  if (!comp) return "";
  const fingerprint = {
    layerCount: comp.layers.length,
    layerIds: comp.layers.map((l) => l.id).join(","),
    modified: store.project.meta.modified,
    settings: comp.settings
  };
  const str = JSON.stringify(fingerprint);
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return hash.toString(16);
}

function vec3(x, y, z) {
  return { x, y, z };
}
function addVec3(a, b) {
  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
function subVec3(a, b) {
  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
function scaleVec3(v, s) {
  return { x: v.x * s, y: v.y * s, z: v.z * s };
}
function lengthVec3(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}
function normalizeVec3(v) {
  const len = lengthVec3(v);
  if (len === 0) return { x: 0, y: 0, z: 0 };
  return { x: v.x / len, y: v.y / len, z: v.z / len };
}
function crossVec3(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x
  };
}
function dotVec3(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function perspectiveMat4(fovY, aspect, near, far) {
  const te = new Float32Array(16);
  const f = 1 / Math.tan(fovY / 2);
  const nf = 1 / (near - far);
  te[0] = f / aspect;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = f;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = (far + near) * nf;
  te[11] = -1;
  te[12] = 0;
  te[13] = 0;
  te[14] = 2 * far * near * nf;
  te[15] = 0;
  return { elements: te };
}
function orthographicMat4(left, right, bottom, top, near, far) {
  const te = new Float32Array(16);
  const w = 1 / (right - left);
  const h = 1 / (top - bottom);
  const p = 1 / (far - near);
  te[0] = 2 * w;
  te[1] = 0;
  te[2] = 0;
  te[3] = 0;
  te[4] = 0;
  te[5] = 2 * h;
  te[6] = 0;
  te[7] = 0;
  te[8] = 0;
  te[9] = 0;
  te[10] = -2 * p;
  te[11] = 0;
  te[12] = -(right + left) * w;
  te[13] = -(top + bottom) * h;
  te[14] = -10001 * p;
  te[15] = 1;
  return { elements: te };
}
function lookAtMat4(eye, target, up) {
  const te = new Float32Array(16);
  let zx = eye.x - target.x;
  let zy = eye.y - target.y;
  let zz = eye.z - target.z;
  let len = Math.sqrt(zx * zx + zy * zy + zz * zz);
  if (len === 0) {
    zz = 1;
  } else {
    len = 1 / len;
    zx *= len;
    zy *= len;
    zz *= len;
  }
  let xx = up.y * zz - up.z * zy;
  let xy = up.z * zx - up.x * zz;
  let xz = up.x * zy - up.y * zx;
  len = Math.sqrt(xx * xx + xy * xy + xz * xz);
  if (len === 0) {
    xx = 0;
    xy = 0;
    xz = 0;
  } else {
    len = 1 / len;
    xx *= len;
    xy *= len;
    xz *= len;
  }
  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;
  len = Math.sqrt(yx * yx + yy * yy + yz * yz);
  if (len === 0) {
    yx = 0;
    yy = 0;
    yz = 0;
  } else {
    len = 1 / len;
    yx *= len;
    yy *= len;
    yz *= len;
  }
  te[0] = xx;
  te[4] = xy;
  te[8] = xz;
  te[12] = -dotVec3({ x: xx, y: xy, z: xz }, eye);
  te[1] = yx;
  te[5] = yy;
  te[9] = yz;
  te[13] = -dotVec3({ x: yx, y: yy, z: yz }, eye);
  te[2] = zx;
  te[6] = zy;
  te[10] = zz;
  te[14] = -dotVec3({ x: zx, y: zy, z: zz }, eye);
  te[3] = 0;
  te[7] = 0;
  te[11] = 0;
  te[15] = 1;
  return { elements: te };
}
function transformPoint(m, p) {
  const e = m.elements;
  const w = e[3] * p.x + e[7] * p.y + e[11] * p.z + e[15];
  return {
    x: (e[0] * p.x + e[4] * p.y + e[8] * p.z + e[12]) / w,
    y: (e[1] * p.x + e[5] * p.y + e[9] * p.z + e[13]) / w,
    z: (e[2] * p.x + e[6] * p.y + e[10] * p.z + e[14]) / w
  };
}
function focalLengthToFOV(focalLength, sensorSize) {
  return 2 * Math.atan(sensorSize / (2 * focalLength));
}
function fovToFocalLength(fov, sensorSize) {
  return sensorSize / (2 * Math.tan(fov / 2));
}

function interpolateCameraAtFrame(camera, keyframes, frame) {
  if (!keyframes || keyframes.length === 0) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  let prev = null;
  let next = null;
  for (const kf of keyframes) {
    if (kf.frame <= frame) {
      prev = kf;
    }
    if (kf.frame >= frame && !next) {
      next = kf;
    }
  }
  if (!prev && !next) {
    return {
      position: camera.position,
      rotation: camera.orientation,
      focalLength: camera.focalLength,
      zoom: camera.zoom,
      focusDistance: camera.depthOfField.focusDistance
    };
  }
  if (!prev) prev = next;
  if (!next) next = prev;
  const getPos = (kf) => kf?.position ?? camera.position;
  const getOri = (kf) => kf?.orientation ?? camera.orientation;
  const getFocal = (kf) => kf?.focalLength ?? camera.focalLength;
  const getZoom = (kf) => kf?.zoom ?? camera.zoom;
  const getFocusDist = (kf) => kf?.focusDistance ?? camera.depthOfField.focusDistance;
  if (prev.frame === next.frame) {
    return {
      position: getPos(prev),
      rotation: getOri(prev),
      focalLength: getFocal(prev),
      zoom: getZoom(prev),
      focusDistance: getFocusDist(prev)
    };
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevPos = getPos(prev);
  const nextPos = getPos(next);
  const prevOri = getOri(prev);
  const nextOri = getOri(next);
  return {
    position: {
      x: lerp(prevPos.x, nextPos.x, t),
      y: lerp(prevPos.y, nextPos.y, t),
      z: lerp(prevPos.z, nextPos.z, t)
    },
    rotation: {
      x: lerpAngle(prevOri.x, nextOri.x, t),
      y: lerpAngle(prevOri.y, nextOri.y, t),
      z: lerpAngle(prevOri.z, nextOri.z, t)
    },
    focalLength: lerp(getFocal(prev), getFocal(next), t),
    zoom: lerp(getZoom(prev), getZoom(next), t),
    focusDistance: lerp(getFocusDist(prev), getFocusDist(next), t)
  };
}
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return a + diff * t;
}
function computeViewMatrix(cam) {
  const { position, rotation } = cam;
  const rx = rotation.x * Math.PI / 180;
  const ry = rotation.y * Math.PI / 180;
  const rz = rotation.z * Math.PI / 180;
  const cosX = Math.cos(rx), sinX = Math.sin(rx);
  const cosY = Math.cos(ry), sinY = Math.sin(ry);
  const cosZ = Math.cos(rz), sinZ = Math.sin(rz);
  const r00 = cosY * cosZ + sinY * sinX * sinZ;
  const r01 = -cosY * sinZ + sinY * sinX * cosZ;
  const r02 = sinY * cosX;
  const r10 = cosX * sinZ;
  const r11 = cosX * cosZ;
  const r12 = -sinX;
  const r20 = -sinY * cosZ + cosY * sinX * sinZ;
  const r21 = sinY * sinZ + cosY * sinX * cosZ;
  const r22 = cosY * cosX;
  const tx = -(r00 * position.x + r10 * position.y + r20 * position.z);
  const ty = -(r01 * position.x + r11 * position.y + r21 * position.z);
  const tz = -(r02 * position.x + r12 * position.y + r22 * position.z);
  return [
    [r00, r01, r02, tx],
    [r10, r11, r12, ty],
    [r20, r21, r22, tz],
    [0, 0, 0, 1]
  ];
}
function computeProjectionMatrix(cam, aspectRatio, nearClip = 0.1, farClip = 1e3) {
  const fov = focalLengthToFOV(cam.focalLength, 36);
  const fovRad = fov * Math.PI / 180;
  const tanHalfFov = Math.tan(fovRad / 2);
  const f = 1 / tanHalfFov;
  const nf = 1 / (nearClip - farClip);
  return [
    [f / aspectRatio, 0, 0, 0],
    [0, f, 0, 0],
    [0, 0, (farClip + nearClip) * nf, 2 * farClip * nearClip * nf],
    [0, 0, -1, 0]
  ];
}
function exportToMotionCtrl(camera, keyframes, frameCount) {
  const poses = [];
  for (let frame = 0; frame < frameCount; frame++) {
    const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(interpolated);
    poses.push({
      RT: viewMatrix
    });
  }
  return { camera_poses: poses };
}
function detectMotionCtrlSVDPreset(keyframes) {
  if (!keyframes || keyframes.length < 2) return "static";
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const threshold = 50;
  if (Math.abs(deltaZ) > threshold) {
    return deltaZ < 0 ? "zoom_in" : "zoom_out";
  }
  if (Math.abs(deltaRy) > 15) {
    return deltaRy > 0 ? "rotate_cw" : "rotate_ccw";
  }
  if (Math.abs(deltaX) > threshold) {
    return deltaX > 0 ? "pan_right" : "pan_left";
  }
  if (Math.abs(deltaY) > threshold) {
    return deltaY > 0 ? "pan_down" : "pan_up";
  }
  return "static";
}
function exportToMotionCtrlSVD(camera, keyframes, frameCount) {
  const preset = detectMotionCtrlSVDPreset(keyframes);
  if (preset !== "static" && keyframes.length <= 2) {
    return { motion_camera: preset };
  }
  const motionctrlData = exportToMotionCtrl(camera, keyframes, frameCount);
  return {
    motion_camera: preset,
    camera_poses: JSON.stringify(motionctrlData.camera_poses)
  };
}
function analyzeCameraMotion(keyframes) {
  if (!keyframes || keyframes.length < 2) {
    return {
      hasPan: false,
      panMagnitude: 0,
      hasZoom: false,
      zoomMagnitude: 0,
      hasOrbit: false,
      orbitMagnitude: 0,
      hasRotation: false,
      rotationMagnitude: 0
    };
  }
  const first = keyframes[0];
  const last = keyframes[keyframes.length - 1];
  const firstPos = first.position ?? { x: 0, y: 0, z: 0 };
  const lastPos = last.position ?? { x: 0, y: 0, z: 0 };
  const firstOri = first.orientation ?? { y: 0};
  const lastOri = last.orientation ?? { y: 0};
  const deltaX = lastPos.x - firstPos.x;
  const deltaY = lastPos.y - firstPos.y;
  const deltaZ = lastPos.z - firstPos.z;
  const deltaRy = lastOri.y - firstOri.y;
  const panThreshold = 30;
  const zoomThreshold = 50;
  const orbitThreshold = 20;
  let panDirection;
  const panX = Math.abs(deltaX);
  const panY = Math.abs(deltaY);
  if (panX > panThreshold || panY > panThreshold) {
    if (panX > panY) {
      panDirection = deltaX > 0 ? "right" : "left";
    } else {
      panDirection = deltaY > 0 ? "down" : "up";
    }
  }
  let zoomDirection;
  if (Math.abs(deltaZ) > zoomThreshold) {
    zoomDirection = deltaZ < 0 ? "in" : "out";
  }
  let orbitDirection;
  if (Math.abs(deltaRy) > orbitThreshold && Math.abs(deltaX) > panThreshold) {
    orbitDirection = deltaRy > 0 ? "right" : "left";
  }
  return {
    hasPan: !!panDirection,
    panDirection,
    panMagnitude: Math.max(panX, panY),
    hasZoom: !!zoomDirection,
    zoomDirection,
    zoomMagnitude: Math.abs(deltaZ),
    hasOrbit: !!orbitDirection,
    orbitDirection,
    orbitMagnitude: Math.abs(deltaRy),
    hasRotation: Math.abs(deltaRy) > 5,
    rotationMagnitude: Math.abs(deltaRy)
  };
}
function mapToWan22FunCamera(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  let preset = "Static";
  if (motion.hasOrbit) {
    preset = motion.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  } else if (motion.hasZoom && motion.hasPan) {
    const panDir = capitalize(motion.panDirection || "up");
    const zoomDir = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    preset = `Pan ${panDir} + ${zoomDir}`;
  } else if (motion.hasZoom) {
    preset = motion.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
  } else if (motion.hasPan) {
    preset = `Pan ${capitalize(motion.panDirection || "up")}`;
  }
  return { camera_motion: preset };
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function detectUni3CTrajectoryType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (motion.hasOrbit && motion.orbitMagnitude > 45) {
    return "orbit";
  }
  if (motion.hasPan && motion.hasZoom) {
    return "custom";
  }
  if (!motion.hasPan && !motion.hasZoom && !motion.hasOrbit) {
    return "free1";
  }
  return "custom";
}
function exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight) {
  const detectedType = detectUni3CTrajectoryType(keyframes);
  if (detectedType !== "custom") {
    return { traj_type: detectedType };
  }
  const trajectory = [];
  const baseCamera = interpolateCameraAtFrame(camera, keyframes, 0);
  for (let frame = 0; frame < frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    trajectory.push({
      zoom: cam.zoom / baseCamera.zoom,
      x_offset: (cam.position.x - baseCamera.position.x) / compWidth,
      y_offset: (cam.position.y - baseCamera.position.y) / compHeight,
      z_offset: (cam.position.z - baseCamera.position.z) / 1e3,
      pitch: cam.rotation.x,
      yaw: cam.rotation.y,
      roll: cam.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: trajectory
  };
}
function detectCameraCtrlMotionType(keyframes) {
  const motion = analyzeCameraMotion(keyframes);
  if (!motion.hasPan && !motion.hasZoom && !motion.hasRotation) {
    return "Static";
  }
  if (motion.hasZoom) {
    return motion.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  }
  if (motion.hasPan) {
    switch (motion.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  }
  if (motion.hasRotation) {
    const first = keyframes[0];
    const last = keyframes[keyframes.length - 1];
    const firstOri = first.orientation ?? { x: 0, y: 0, z: 0 };
    const lastOri = last.orientation ?? { x: 0, y: 0, z: 0 };
    const deltaRx = lastOri.x - firstOri.x;
    const deltaRy = lastOri.y - firstOri.y;
    const deltaRz = lastOri.z - firstOri.z;
    if (Math.abs(deltaRy) > Math.abs(deltaRx) && Math.abs(deltaRy) > Math.abs(deltaRz)) {
      return deltaRy > 0 ? "Rotate Right" : "Rotate Left";
    }
    if (Math.abs(deltaRx) > Math.abs(deltaRz)) {
      return deltaRx > 0 ? "Rotate Down" : "Rotate Up";
    }
    return deltaRz > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function exportToCameraCtrl(keyframes, frameCount) {
  const motionType = detectCameraCtrlMotionType(keyframes);
  const motion = analyzeCameraMotion(keyframes);
  let speed = 0;
  if (motion.hasZoom) {
    speed = Math.min(100, motion.zoomMagnitude / 5);
  } else if (motion.hasPan) {
    speed = Math.min(100, motion.panMagnitude / 3);
  } else if (motion.hasRotation) {
    speed = Math.min(100, motion.rotationMagnitude * 2);
  }
  return {
    motion_type: motionType,
    speed: Math.round(speed),
    frame_length: frameCount
  };
}
function exportCameraMatrices(camera, keyframes, options) {
  const frames = [];
  const aspectRatio = options.width / options.height;
  for (let frame = 0; frame < options.frameCount; frame++) {
    const cam = interpolateCameraAtFrame(camera, keyframes, frame);
    const viewMatrix = computeViewMatrix(cam);
    const projMatrix = computeProjectionMatrix(cam, aspectRatio);
    frames.push({
      frame,
      timestamp: frame / options.fps,
      view_matrix: viewMatrix,
      projection_matrix: projMatrix,
      position: [cam.position.x, cam.position.y, cam.position.z],
      rotation: [cam.rotation.x, cam.rotation.y, cam.rotation.z],
      fov: focalLengthToFOV(cam.focalLength, camera.filmSize),
      focal_length: cam.focalLength,
      focus_distance: cam.focusDistance
    });
  }
  return {
    frames,
    metadata: {
      width: options.width,
      height: options.height,
      fps: options.fps,
      total_frames: options.frameCount,
      camera_type: camera.type,
      film_size: camera.filmSize
    }
  };
}
function exportCameraForTarget(target, camera, keyframes, frameCount, compWidth = 1920, compHeight = 1080, fps = 24) {
  switch (target) {
    case "motionctrl":
      return exportToMotionCtrl(camera, keyframes, frameCount);
    case "motionctrl-svd":
      return exportToMotionCtrlSVD(camera, keyframes, frameCount);
    case "wan22-fun-camera":
      return mapToWan22FunCamera(keyframes);
    case "uni3c-camera":
    case "uni3c-motion":
      return exportToUni3C(camera, keyframes, frameCount, compWidth, compHeight);
    case "animatediff-cameractrl":
      return exportToCameraCtrl(keyframes, frameCount);
    default:
      return exportCameraMatrices(camera, keyframes, {
        frameCount,
        width: compWidth,
        height: compHeight,
        fps
      });
  }
}

function createCameraLayer(store, name) {
  const comp = store.getActiveComp();
  const layers = store.getActiveCompLayers();
  const cameraId = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const cameraName = name || `Camera ${store.cameras.size + 1}`;
  const camera = createDefaultCamera(
    cameraId,
    comp?.settings.width || 1024,
    comp?.settings.height || 1024
  );
  camera.name = cameraName;
  store.cameras.set(cameraId, camera);
  if (!store.activeCameraId) {
    store.activeCameraId = cameraId;
  }
  const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const layer = {
    id: layerId,
    name: cameraName,
    type: "camera",
    visible: true,
    locked: false,
    isolate: false,
    threeD: true,
    motionBlur: false,
    inPoint: 0,
    outPoint: (comp?.settings.frameCount || 81) - 1,
    parentId: null,
    blendMode: "normal",
    opacity: createAnimatableProperty("opacity", 100, "number"),
    transform: createDefaultTransform(),
    properties: [],
    effects: [],
    data: {
      cameraId,
      isActiveCamera: !store.activeCameraId || store.activeCameraId === cameraId
    }
  };
  layers.unshift(layer);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
  store.selectLayer(layerId);
  return { camera, layer };
}
function getCamera(store, cameraId) {
  return store.cameras.get(cameraId) || null;
}
function updateCamera(store, cameraId, updates) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return;
  Object.assign(camera, updates);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setActiveCamera(store, cameraId) {
  if (!store.cameras.has(cameraId)) return;
  store.activeCameraId = cameraId;
  const layers = store.getActiveCompLayers();
  for (const layer of layers) {
    if (layer.type === "camera" && layer.data) {
      const cameraData = layer.data;
      cameraData.isActiveCamera = cameraData.cameraId === cameraId;
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function deleteCamera(store, cameraId) {
  const layers = store.getActiveCompLayers();
  const layerIndex = layers.findIndex(
    (l) => l.type === "camera" && l.data?.cameraId === cameraId
  );
  if (layerIndex !== -1) {
    const layerId = layers[layerIndex].id;
    layers.splice(layerIndex, 1);
    useSelectionStore().removeFromSelection(layerId);
  }
  store.cameraKeyframes.delete(cameraId);
  store.cameras.delete(cameraId);
  if (store.activeCameraId === cameraId) {
    const remaining = Array.from(store.cameras.keys());
    store.activeCameraId = remaining.length > 0 ? remaining[0] : null;
    if (store.activeCameraId) {
      setActiveCamera(store, store.activeCameraId);
    }
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getCameraKeyframes(store, cameraId) {
  return store.cameraKeyframes.get(cameraId) || [];
}
function addCameraKeyframe(store, cameraId, keyframe) {
  let keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) {
    keyframes = [];
    store.cameraKeyframes.set(cameraId, keyframes);
  }
  const existingIndex = keyframes.findIndex((k) => k.frame === keyframe.frame);
  if (existingIndex >= 0) {
    keyframes[existingIndex] = keyframe;
  } else {
    keyframes.push(keyframe);
    keyframes.sort((a, b) => a.frame - b.frame);
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function removeCameraKeyframe(store, cameraId, frame) {
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes) return;
  const index = keyframes.findIndex((k) => k.frame === frame);
  if (index >= 0) {
    keyframes.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  }
}
function getCameraAtFrame(store, cameraId, frame) {
  const camera = store.cameras.get(cameraId);
  if (!camera) return null;
  const keyframes = store.cameraKeyframes.get(cameraId);
  if (!keyframes || keyframes.length === 0) {
    return camera;
  }
  const interpolated = interpolateCameraAtFrame(camera, keyframes, frame);
  return {
    ...camera,
    position: interpolated.position,
    orientation: interpolated.rotation,
    focalLength: interpolated.focalLength,
    zoom: interpolated.zoom,
    depthOfField: {
      ...camera.depthOfField,
      focusDistance: interpolated.focusDistance
    }
  };
}
function getActiveCameraAtFrame(store, frame) {
  if (!store.activeCameraId) return null;
  return getCameraAtFrame(store, store.activeCameraId, frame ?? store.currentFrame);
}
function updateViewportState(store, updates) {
  Object.assign(store.viewportState, updates);
}
function updateViewOptions(store, updates) {
  Object.assign(store.viewOptions, updates);
}

function getApiBase() {
  return "";
}
async function segmentImage(request) {
  const response = await fetch(`${getApiBase()}/weyl/segment`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `Segmentation failed: ${response.status}`);
  }
  return response.json();
}
async function segmentByPoint(imageBase64, point, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points: [point],
    labels: [1]
    // Foreground
  });
}
async function segmentByBox(imageBase64, box, model = "sam2") {
  return segmentImage({
    image: imageBase64,
    mode: "box",
    model,
    box
  });
}
async function segmentByMultiplePoints(imageBase64, foregroundPoints, backgroundPoints = [], model = "sam2") {
  const points = [...foregroundPoints, ...backgroundPoints];
  const labels = [
    ...foregroundPoints.map(() => 1),
    // Foreground
    ...backgroundPoints.map(() => 0)
    // Background
  ];
  return segmentImage({
    image: imageBase64,
    mode: "point",
    model,
    points,
    labels
  });
}
async function autoSegment(imageBase64, options = {}) {
  return segmentImage({
    image: imageBase64,
    mode: "auto",
    model: options.model || "sam2",
    minArea: options.minArea || 100,
    maxMasks: options.maxMasks || 20
  });
}
function applyMaskToImage(sourceImageBase64, maskBase64, bounds) {
  return new Promise((resolve, reject) => {
    const sourceImg = new Image();
    const maskImg = new Image();
    let sourceLoaded = false;
    let maskLoaded = false;
    const checkComplete = () => {
      if (!sourceLoaded || !maskLoaded) return;
      try {
        const canvas = document.createElement("canvas");
        canvas.width = bounds.width;
        canvas.height = bounds.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = maskImg.width;
        maskCanvas.height = maskImg.height;
        const maskCtx = maskCanvas.getContext("2d");
        if (!maskCtx) {
          reject(new Error("Failed to get mask canvas context"));
          return;
        }
        maskCtx.drawImage(maskImg, 0, 0);
        const maskData = maskCtx.getImageData(bounds.x, bounds.y, bounds.width, bounds.height);
        ctx.drawImage(
          sourceImg,
          bounds.x,
          bounds.y,
          bounds.width,
          bounds.height,
          0,
          0,
          bounds.width,
          bounds.height
        );
        const imageData = ctx.getImageData(0, 0, bounds.width, bounds.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          imageData.data[i + 3] = maskData.data[i];
        }
        ctx.putImageData(imageData, 0, 0);
        const resultBase64 = canvas.toDataURL("image/png").split(",")[1];
        resolve(resultBase64);
      } catch (err) {
        reject(err);
      }
    };
    sourceImg.onload = () => {
      sourceLoaded = true;
      checkComplete();
    };
    sourceImg.onerror = () => reject(new Error("Failed to load source image"));
    maskImg.onload = () => {
      maskLoaded = true;
      checkComplete();
    };
    maskImg.onerror = () => reject(new Error("Failed to load mask image"));
    sourceImg.src = `data:image/png;base64,${sourceImageBase64}`;
    maskImg.src = `data:image/png;base64,${maskBase64}`;
  });
}

async function createLayerFromMask(store, sourceImageBase64, mask, name, positionAtCenter = false) {
  try {
    const maskedImageBase64 = await applyMaskToImage(
      sourceImageBase64,
      mask.mask,
      mask.bounds
    );
    const assetId = `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const asset = {
      id: assetId,
      type: "image",
      source: "generated",
      width: mask.bounds.width,
      height: mask.bounds.height,
      data: maskedImageBase64
    };
    store.project.assets[assetId] = asset;
    const layer = store.createLayer("image", name || "Segmented");
    const imageData = {
      assetId,
      fit: "none",
      // Don't scale - use original size
      sourceType: "segmented"
    };
    layer.data = imageData;
    if (positionAtCenter) {
      layer.transform.position.value = {
        x: store.project.composition.width / 2,
        y: store.project.composition.height / 2
      };
    } else {
      layer.transform.position.value = {
        x: mask.bounds.x + mask.bounds.width / 2,
        y: mask.bounds.y + mask.bounds.height / 2
      };
    }
    layer.transform.anchorPoint.value = {
      x: mask.bounds.width / 2,
      y: mask.bounds.height / 2
    };
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
    storeLogger.info(`Created segmented layer: ${layer.name} (${mask.bounds.width}x${mask.bounds.height})`);
    return layer;
  } catch (err) {
    storeLogger.error("Failed to create layer from mask:", err);
    return null;
  }
}
async function segmentToLayerByPoint(store, point, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByPoint(sourceImage, point, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByBox(store, box, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByBox(sourceImage, box, options.model || "sam2");
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function segmentToLayerByMultiplePoints(store, foregroundPoints, backgroundPoints = [], options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return null;
  }
  try {
    const result = await segmentByMultiplePoints(
      sourceImage,
      foregroundPoints,
      backgroundPoints,
      options.model || "sam2"
    );
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Segmentation failed:", result.message);
      return null;
    }
    const mask = result.masks[0];
    return createLayerFromMask(store, sourceImage, mask, options.layerName, options.positionAtCenter);
  } catch (err) {
    storeLogger.error("Segmentation error:", err);
    return null;
  }
}
async function autoSegmentToLayers(store, options = {}) {
  const sourceImage = store.sourceImage;
  if (!sourceImage) {
    storeLogger.error("No source image available for segmentation");
    return [];
  }
  try {
    const result = await autoSegment(sourceImage, {
      model: options.model || "sam2",
      minArea: options.minArea || 1e3,
      maxMasks: options.maxMasks || 10
    });
    if (result.status !== "success" || !result.masks || result.masks.length === 0) {
      storeLogger.error("Auto-segmentation failed:", result.message);
      return [];
    }
    const layers = [];
    const prefix = options.namePrefix || "Segment";
    for (let i = 0; i < result.masks.length; i++) {
      const mask = result.masks[i];
      const layer = await createLayerFromMask(
        store,
        sourceImage,
        mask,
        `${prefix} ${i + 1}`,
        false
        // Don't center - preserve original position
      );
      if (layer) {
        layers.push(layer);
      }
    }
    return layers;
  } catch (err) {
    storeLogger.error("Auto-segmentation error:", err);
    return [];
  }
}

function getAnimatableType(paramType) {
  switch (paramType) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const EFFECT_DEFINITIONS = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: true },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: false },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: true },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: true }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: true },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: false },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: false }
    ]
  },
  "sharpen": {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: true }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: true },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: true },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: true },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Use Legacy", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: false },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: true, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  "curves": {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: false }
      // Note: Actual curve control would be a custom component
    ]
  },
  "levels": {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: false },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: true },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: true },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: true }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: true, animatable: false }
    ]
  },
  "tint": {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  // Distort
  "transform": {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: true },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: true },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: true },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: true },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "warp": {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: false },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: true }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: false },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: false },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: true }
    ]
  },
  // Generate
  "fill": {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: true }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: true },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: true },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: true },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: false },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: true }
    ]
  },
  // Stylize
  "glow": {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: true },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: true },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: true },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: false },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: false },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: true },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: true }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: true },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: true },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: true },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: true },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: true },
      { name: "Shadow Only", type: "checkbox", defaultValue: false, animatable: false }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: false },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: false },
      { name: "Invert", type: "checkbox", defaultValue: false, animatable: false },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: true },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: true },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: true },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: true },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: true }
    ]
  }
};
const EFFECT_CATEGORIES = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  "distort": { label: "Distort", icon: "D", description: "Distortion effects" },
  "generate": { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  "keying": { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  "matte": { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  "perspective": { label: "Perspective", icon: "P", description: "3D perspective effects" },
  "stylize": { label: "Stylize", icon: "S", description: "Stylization effects" },
  "time": { label: "Time", icon: "T", description: "Time-based effects" },
  "transition": { label: "Transition", icon: "Tr", description: "Transition effects" },
  "utility": { label: "Utility", icon: "U", description: "Utility effects" }
};
function createEffectInstance(definitionKey) {
  const def = EFFECT_DEFINITIONS[definitionKey];
  if (!def) return null;
  const parameters = {};
  def.parameters.forEach((param, index) => {
    const paramKey = param.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    parameters[paramKey] = {
      id: `${definitionKey}-${paramKey}-${index}`,
      name: param.name,
      type: getAnimatableType(param.type),
      value: param.defaultValue,
      animated: false,
      keyframes: []
    };
  });
  return {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: definitionKey,
    name: def.name,
    category: def.category,
    enabled: true,
    expanded: true,
    parameters
  };
}
const ANIMATION_PRESETS = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];

function addEffectToLayer(store, layerId, effectKey) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) return;
  const effect = createEffectInstance(effectKey);
  if (!effect) return;
  if (!layer.effects) {
    layer.effects = [];
  }
  layer.effects.push(effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function removeEffectFromLayer(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const index = layer.effects.findIndex((e) => e.id === effectId);
  if (index >= 0) {
    layer.effects.splice(index, 1);
    store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    store.pushHistory();
  }
}
function updateEffectParameter(store, layerId, effectId, paramKey, value) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  effect.parameters[paramKey].value = value;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function setEffectParamAnimated(store, layerId, effectId, paramKey, animated) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return;
  const param = effect.parameters[paramKey];
  param.animated = animated;
  if (animated && (!param.keyframes || param.keyframes.length === 0)) {
    param.keyframes = [{
      id: `kf_${Date.now()}`,
      frame: store.currentFrame,
      value: param.value,
      interpolation: "linear",
      inHandle: { frame: -5, value: 0, enabled: false },
      outHandle: { frame: 5, value: 0, enabled: false },
      controlMode: "smooth"
    }];
  }
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function toggleEffect(store, layerId, effectId) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect) return;
  effect.enabled = !effect.enabled;
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
}
function reorderEffects(store, layerId, fromIndex, toIndex) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return;
  if (fromIndex < 0 || fromIndex >= layer.effects.length) return;
  if (toIndex < 0 || toIndex >= layer.effects.length) return;
  const [effect] = layer.effects.splice(fromIndex, 1);
  layer.effects.splice(toIndex, 0, effect);
  store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
  store.pushHistory();
}
function getEffectParameterValue(store, layerId, effectId, paramKey, frame) {
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || !layer.effects) return null;
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect || !effect.parameters[paramKey]) return null;
  const param = effect.parameters[paramKey];
  const targetFrame = frame ?? (store.getActiveComp()?.currentFrame ?? 0);
  if (param.animated && param.keyframes.length > 0) {
    return interpolateProperty(param, targetFrame);
  }
  return param.value;
}

const usePlaybackStore = defineStore("playback", {
  state: () => ({
    isPlaying: false,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    loopPlayback: true
  }),
  getters: {
    playing: (state) => state.isPlaying
  },
  actions: {
    /**
     * Start playback
     * @param fps - Frames per second
     * @param frameCount - Total frame count
     * @param currentFrame - Starting frame
     * @param onFrame - Callback for each frame
     */
    play(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) return;
      this.isPlaying = true;
      this.playbackStartTime = performance.now();
      this.playbackStartFrame = currentFrame;
      const frameDuration = 1e3 / fps;
      let lastFrameTime = this.playbackStartTime;
      const tick = (now) => {
        if (!this.isPlaying) return;
        const elapsed = now - lastFrameTime;
        if (elapsed >= frameDuration) {
          const framesToAdvance = Math.floor(elapsed / frameDuration);
          let newFrame = currentFrame + framesToAdvance;
          if (newFrame >= frameCount) {
            if (this.loopPlayback) {
              newFrame = newFrame % frameCount;
            } else {
              newFrame = frameCount - 1;
              this.stop();
              onFrame(newFrame);
              return;
            }
          }
          currentFrame = newFrame;
          lastFrameTime = now - elapsed % frameDuration;
          onFrame(currentFrame);
        }
        this.playbackRequestId = requestAnimationFrame(tick);
      };
      this.playbackRequestId = requestAnimationFrame(tick);
      storeLogger.debug("Playback started at frame", currentFrame);
    },
    /**
     * Stop playback
     */
    stop() {
      if (this.playbackRequestId !== null) {
        cancelAnimationFrame(this.playbackRequestId);
        this.playbackRequestId = null;
      }
      this.isPlaying = false;
      this.playbackStartTime = null;
      storeLogger.debug("Playback stopped");
    },
    /**
     * Toggle playback
     */
    toggle(fps, frameCount, currentFrame, onFrame) {
      if (this.isPlaying) {
        this.stop();
      } else {
        this.play(fps, frameCount, currentFrame, onFrame);
      }
    },
    /**
     * Set loop playback mode
     */
    setLoopPlayback(loop) {
      this.loopPlayback = loop;
    },
    /**
     * Go to first frame
     */
    goToStart(onFrame) {
      this.stop();
      onFrame(0);
    },
    /**
     * Go to last frame
     */
    goToEnd(frameCount, onFrame) {
      this.stop();
      onFrame(frameCount - 1);
    },
    /**
     * Step forward one frame
     */
    stepForward(currentFrame, frameCount, onFrame) {
      this.stop();
      const newFrame = Math.min(currentFrame + 1, frameCount - 1);
      onFrame(newFrame);
    },
    /**
     * Step backward one frame
     */
    stepBackward(currentFrame, onFrame) {
      this.stop();
      const newFrame = Math.max(currentFrame - 1, 0);
      onFrame(newFrame);
    },
    /**
     * Jump to specific frame
     */
    goToFrame(frame, frameCount, onFrame) {
      const clampedFrame = Math.max(0, Math.min(frame, frameCount - 1));
      onFrame(clampedFrame);
    }
  }
});

const useCompositorStore = defineStore("compositor", {
  state: () => ({
    project: createEmptyProject(832, 480),
    // Wan 2.1 480p default
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    compositionBreadcrumbs: ["main"],
    // Start with main comp in breadcrumb path
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: false,
    segmentToolActive: false,
    segmentMode: "point",
    segmentPendingMask: null,
    segmentBoxStart: null,
    segmentIsLoading: false,
    graphEditorVisible: false,
    hideMinimizedLayers: false,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioVolume: 100,
    audioMuted: false,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: createDefaultViewportState(),
    viewOptions: createDefaultViewOptions(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...DEFAULT_SNAP_CONFIG },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    },
    // Autosave (enabled by default, every 60 seconds)
    autosaveEnabled: true,
    autosaveIntervalMs: 6e4,
    autosaveTimerId: null,
    lastSaveTime: null,
    lastSaveProjectId: null,
    hasUnsavedChanges: false,
    // Frame cache (enabled by default)
    frameCacheEnabled: true,
    projectStateHash: ""
  }),
  getters: {
    // Active composition helper
    activeComposition: (state) => {
      return state.project.compositions[state.activeCompositionId] || null;
    },
    // Project info - now uses active composition
    hasProject: (state) => state.sourceImage !== null,
    width(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.width || 1024;
    },
    height(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.height || 1024;
    },
    frameCount(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.frameCount || 81;
    },
    fps(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.fps || 16;
    },
    duration(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.settings.duration || 5;
    },
    // Current frame - per composition
    currentFrame(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.currentFrame || 0;
    },
    currentTime(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      if (!comp) return 0;
      return comp.currentFrame / comp.settings.fps;
    },
    // Layers - from active composition
    layers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return comp?.layers || [];
    },
    visibleLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.visible);
    },
    // Layers displayed in timeline (respects minimized filter)
    displayedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      const allLayers = comp?.layers || [];
      if (state.hideMinimizedLayers) {
        return allLayers.filter((l) => !l.minimized);
      }
      return allLayers;
    },
    // Selection (delegated to selectionStore)
    selectedLayerIds() {
      return useSelectionStore().selectedLayerIds;
    },
    selectedKeyframeIds() {
      return useSelectionStore().selectedKeyframeIds;
    },
    selectedPropertyPath() {
      return useSelectionStore().selectedPropertyPath;
    },
    currentTool(state) {
      if (state.segmentToolActive) return "segment";
      return useSelectionStore().currentTool;
    },
    selectedLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      const selectionStore = useSelectionStore();
      return (comp?.layers || []).filter((l) => selectionStore.selectedLayerIds.includes(l.id));
    },
    selectedLayer(state) {
      const selectionStore = useSelectionStore();
      if (selectionStore.selectedLayerIds.length !== 1) return null;
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).find((l) => l.id === selectionStore.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (state) => {
      return Object.values(state.project.compositions);
    },
    openCompositions(state) {
      return state.openCompositionIds.map((id) => state.project.compositions[id]).filter(Boolean);
    },
    // Breadcrumb navigation path for nested compositions
    breadcrumbPath(state) {
      return state.compositionBreadcrumbs.map((id) => {
        const comp = state.project.compositions[id];
        return comp ? { id, name: comp.name } : null;
      }).filter(Boolean);
    },
    // Assets
    assets: (state) => state.project.assets,
    // History
    canUndo: (state) => state.historyIndex > 0,
    canRedo: (state) => state.historyIndex < state.historyStack.length - 1,
    // Camera
    activeCamera: (state) => {
      if (!state.activeCameraId) return null;
      return state.cameras.get(state.activeCameraId) || null;
    },
    allCameras: (state) => Array.from(state.cameras.values()),
    cameraLayers(state) {
      const comp = state.project.compositions[state.activeCompositionId];
      return (comp?.layers || []).filter((l) => l.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const comp = this.project.compositions[this.activeCompositionId];
      return comp?.layers || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(name, settings, isNestedComp = false) {
      const id = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const activeComp = this.project.compositions[this.activeCompositionId];
      const defaultSettings = {
        width: settings?.width ?? activeComp?.settings.width ?? 1024,
        height: settings?.height ?? activeComp?.settings.height ?? 1024,
        frameCount: settings?.frameCount ?? activeComp?.settings.frameCount ?? 81,
        fps: settings?.fps ?? activeComp?.settings.fps ?? 16,
        duration: 0,
        backgroundColor: settings?.backgroundColor ?? "#000000",
        autoResizeToContent: settings?.autoResizeToContent ?? true
      };
      defaultSettings.duration = defaultSettings.frameCount / defaultSettings.fps;
      const composition = {
        id,
        name,
        settings: defaultSettings,
        layers: [],
        currentFrame: 0,
        isNestedComp
      };
      this.project.compositions[id] = composition;
      if (!this.openCompositionIds.includes(id)) {
        this.openCompositionIds.push(id);
      }
      this.activeCompositionId = id;
      storeLogger.debug("Created composition:", name, id);
      return composition;
    },
    /**
     * Delete a composition
     */
    deleteComposition(compId) {
      if (compId === this.project.mainCompositionId) {
        storeLogger.warn("Cannot delete main composition");
        return false;
      }
      const comp = this.project.compositions[compId];
      if (!comp) return false;
      delete this.project.compositions[compId];
      const openIdx = this.openCompositionIds.indexOf(compId);
      if (openIdx >= 0) {
        this.openCompositionIds.splice(openIdx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId;
      }
      storeLogger.debug("Deleted composition:", compId);
      return true;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Composition not found:", compId);
        return;
      }
      if (!this.openCompositionIds.includes(compId)) {
        this.openCompositionIds.push(compId);
      }
      const selection = useSelectionStore();
      selection.clearLayerSelection();
      selection.clearKeyframeSelection();
      this.activeCompositionId = compId;
      storeLogger.debug("Switched to composition:", compId);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(compId) {
      if (this.openCompositionIds.length <= 1) {
        storeLogger.warn("Cannot close the last tab");
        return;
      }
      const idx = this.openCompositionIds.indexOf(compId);
      if (idx >= 0) {
        this.openCompositionIds.splice(idx, 1);
      }
      if (this.activeCompositionId === compId) {
        this.activeCompositionId = this.openCompositionIds[Math.max(0, idx - 1)];
      }
    },
    /**
     * Enter a nested comp (e.g., double-click on nested comp layer)
     * Pushes the composition to the breadcrumb trail
     */
    enterNestedComp(compId) {
      if (!this.project.compositions[compId]) {
        storeLogger.warn("Nested comp not found:", compId);
        return;
      }
      this.compositionBreadcrumbs.push(compId);
      this.switchComposition(compId);
      storeLogger.debug("Entered nested comp:", compId, "breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Navigate back one level in the breadcrumb trail
     */
    navigateBack() {
      if (this.compositionBreadcrumbs.length <= 1) {
        storeLogger.warn("Already at root composition");
        return;
      }
      this.compositionBreadcrumbs.pop();
      const prevId = this.compositionBreadcrumbs[this.compositionBreadcrumbs.length - 1];
      if (prevId) {
        this.switchComposition(prevId);
      }
      storeLogger.debug("Navigated back, breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Navigate to a specific breadcrumb index
     * Truncates the breadcrumb trail to that point
     */
    navigateToBreadcrumb(index) {
      if (index < 0 || index >= this.compositionBreadcrumbs.length) {
        return;
      }
      if (index === this.compositionBreadcrumbs.length - 1) {
        return;
      }
      this.compositionBreadcrumbs = this.compositionBreadcrumbs.slice(0, index + 1);
      const targetId = this.compositionBreadcrumbs[index];
      if (targetId) {
        this.switchComposition(targetId);
      }
      storeLogger.debug("Navigated to breadcrumb", index, "breadcrumbs:", this.compositionBreadcrumbs);
    },
    /**
     * Reset breadcrumbs to main composition (e.g., when loading a new project)
     */
    resetBreadcrumbs() {
      this.compositionBreadcrumbs = [this.project.mainCompositionId];
      this.switchComposition(this.project.mainCompositionId);
    },
    /**
     * Rename a composition
     */
    renameComposition(compId, newName) {
      const comp = this.project.compositions[compId];
      if (comp) {
        comp.name = newName;
      }
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(compId, settings) {
      const comp = this.project.compositions[compId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      Object.assign(comp.settings, settings);
      comp.settings.duration = comp.settings.frameCount / comp.settings.fps;
      if (settings.frameCount && settings.frameCount > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = settings.frameCount - 1;
          }
        }
      }
      if (compId === this.project.mainCompositionId) {
        Object.assign(this.project.composition, comp.settings);
      }
    },
    /**
     * Get a composition by ID
     */
    getComposition(compId) {
      return this.project.compositions[compId] || null;
    },
    /**
     * Nest selected layers into a new composition
     */
    nestSelectedLayers(name) {
      if (this.selectedLayerIds.length === 0) {
        storeLogger.warn("No layers selected for nesting");
        return null;
      }
      const activeComp = this.project.compositions[this.activeCompositionId];
      if (!activeComp) return null;
      const nestedComp = this.createComposition(
        name || "Nested Comp",
        activeComp.settings,
        true
      );
      const selectedLayers = activeComp.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      );
      const earliestIn = Math.min(...selectedLayers.map((l) => l.inPoint));
      for (const layer of selectedLayers) {
        layer.inPoint -= earliestIn;
        layer.outPoint -= earliestIn;
        const idx = activeComp.layers.indexOf(layer);
        if (idx >= 0) {
          activeComp.layers.splice(idx, 1);
        }
        nestedComp.layers.push(layer);
      }
      const maxOut = Math.max(...nestedComp.layers.map((l) => l.outPoint));
      nestedComp.settings.frameCount = maxOut + 1;
      nestedComp.settings.duration = nestedComp.settings.frameCount / nestedComp.settings.fps;
      const nestedCompLayer = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: nestedComp.name,
        type: "nestedComp",
        visible: true,
        locked: false,
        isolate: false,
        threeD: false,
        inPoint: earliestIn,
        outPoint: earliestIn + nestedComp.settings.frameCount - 1,
        parentId: null,
        transform: createDefaultTransform(),
        opacity: createAnimatableProperty("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: false,
        data: {
          compositionId: nestedComp.id,
          timeRemapEnabled: false,
          flattenTransform: false
        }
      };
      activeComp.layers.push(nestedCompLayer);
      useSelectionStore().clearLayerSelection();
      this.activeCompositionId = activeComp.id;
      storeLogger.debug("Nested layers into:", nestedComp.name);
      return nestedComp;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(inputs) {
      this.comfyuiNodeId = inputs.node_id;
      this.sourceImage = inputs.source_image;
      this.depthMap = inputs.depth_map;
      const comp = this.project.compositions[this.activeCompositionId];
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = inputs.width;
      comp.settings.height = inputs.height;
      comp.settings.frameCount = inputs.frame_count;
      comp.settings.duration = inputs.frame_count / comp.settings.fps;
      this.project.composition.width = inputs.width;
      this.project.composition.height = inputs.height;
      this.project.composition.frameCount = inputs.frame_count;
      this.project.composition.duration = inputs.frame_count / this.project.composition.fps;
      if (inputs.frame_count > oldFrameCount) {
        for (const layer of comp.layers) {
          if (layer.outPoint === oldFrameCount - 1) {
            layer.outPoint = inputs.frame_count - 1;
          }
        }
      }
      if (inputs.source_image) {
        this.project.assets["source_image"] = {
          id: "source_image",
          type: "image",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.source_image
        };
      }
      if (inputs.depth_map) {
        this.project.assets["depth_map"] = {
          id: "depth_map",
          type: "depth_map",
          source: "comfyui_node",
          nodeId: inputs.node_id,
          width: inputs.width,
          height: inputs.height,
          data: inputs.depth_map
        };
      }
      if (comp) comp.currentFrame = 0;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      storeLogger.debug("Loaded inputs from ComfyUI:", {
        width: inputs.width,
        height: inputs.height,
        frameCount: inputs.frame_count
      });
      this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(type, name) {
      const id = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let layerData = null;
      switch (type) {
        case "text":
          layerData = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: false,
            pathPerpendicularToPath: true,
            pathForceAlignment: false,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid": {
          const activeComp = this.getActiveComp();
          layerData = {
            color: "#808080",
            width: activeComp?.settings.width || this.project.composition.width,
            height: activeComp?.settings.height || this.project.composition.height
          };
          break;
        }
        case "null":
          layerData = {
            size: 40
          };
          break;
        case "spline":
          layerData = {
            pathData: "",
            controlPoints: [],
            closed: false,
            stroke: "#00ff00",
            strokeWidth: 2,
            // Stroke options (shown in More Options group)
            lineCap: "round",
            // butt, round, square
            lineJoin: "round",
            // miter, round, bevel
            dashArray: "",
            // e.g., "10, 5" for dashed lines
            dashOffset: 0
          };
          break;
        case "particles": {
          const activeComp = this.getActiveComp();
          const compWidth2 = activeComp?.settings.width || this.project.composition.width;
          const compHeight2 = activeComp?.settings.height || this.project.composition.height;
          layerData = {
            systemConfig: {
              maxParticles: 1e4,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: false,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              // Use pixel coordinates - center of composition
              x: compWidth2 / 2,
              y: compHeight2 / 2,
              direction: 270,
              // Up direction (degrees, 270 = upward)
              spread: 30,
              speed: 150,
              // Pixels per second
              speedVariance: 30,
              size: 8,
              sizeVariance: 2,
              color: [255, 200, 100],
              // Orange-ish for visibility
              emissionRate: 30,
              // Particles per second
              initialBurst: 0,
              particleLifetime: 90,
              // Frames
              lifetimeVariance: 15,
              enabled: true,
              burstOnBeat: false,
              burstCount: 20,
              // Geometric emitter shape defaults
              shape: "point",
              shapeRadius: 50,
              shapeWidth: 100,
              shapeHeight: 100,
              shapeDepth: 100,
              shapeInnerRadius: 25,
              emitFromEdge: false,
              emitFromVolume: false,
              splinePath: null,
              sprite: {
                enabled: false,
                imageUrl: null,
                imageData: null,
                isSheet: false,
                columns: 1,
                rows: 1,
                totalFrames: 1,
                frameRate: 30,
                playMode: "loop",
                billboard: true,
                rotationEnabled: false,
                rotationSpeed: 0,
                rotationSpeedVariance: 0,
                alignToVelocity: false
              }
            }],
            gravityWells: [],
            vortices: [],
            modulations: [{
              id: "mod_opacity_1",
              emitterId: "*",
              property: "opacity",
              startValue: 1,
              endValue: 0,
              easing: "linear"
            }],
            renderOptions: {
              blendMode: "additive",
              renderTrails: false,
              trailLength: 5,
              trailOpacityFalloff: 0.7,
              particleShape: "circle",
              glowEnabled: true,
              glowRadius: 8,
              glowIntensity: 0.6,
              motionBlur: false,
              motionBlurStrength: 0.5,
              motionBlurSamples: 8,
              connections: {
                enabled: false,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: true
              }
            },
            turbulenceFields: [],
            subEmitters: []
          };
          break;
        }
        case "depthflow":
          layerData = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: false
            }
          };
          break;
        case "light":
          layerData = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: false,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          layerData = {
            cameraId: null,
            isActiveCamera: false
          };
          break;
        case "image":
          layerData = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          layerData = {
            assetId: null,
            loop: false,
            startTime: 0,
            speed: 1
          };
          break;
        case "shape":
          layerData = {
            contents: [],
            blendMode: "normal",
            quality: "normal",
            gpuAccelerated: false
          };
          break;
      }
      let audioProps = void 0;
      if (type === "video" || type === "audio") {
        audioProps = {
          level: createAnimatableProperty("Audio Levels", 0, "number")
          // 0dB default
        };
      }
      const comp = this.getActiveComp();
      const layers = this.getActiveCompLayers();
      const compWidth = comp?.settings.width || this.project.composition.width;
      const compHeight = comp?.settings.height || this.project.composition.height;
      const layerTransform = createDefaultTransform();
      if (type === "solid" && layerData) {
        const layerWidth = layerData.width || compWidth;
        const layerHeight = layerData.height || compHeight;
        layerTransform.anchorPoint.value = { x: layerWidth / 2, y: layerHeight / 2, z: 0 };
        layerTransform.position.value = { x: compWidth / 2, y: compHeight / 2, z: 0 };
      } else {
        layerTransform.position.value = { x: compWidth / 2, y: compHeight / 2, z: 0 };
        layerTransform.anchorPoint.value = { x: compWidth / 2, y: compHeight / 2, z: 0 };
      }
      let layerProperties = [];
      if (type === "spline") {
        layerProperties = [
          createAnimatableProperty("Stroke Width", layerData?.strokeWidth ?? 2, "number", "Stroke"),
          createAnimatableProperty("Stroke Opacity", layerData?.strokeOpacity ?? 100, "number", "Stroke"),
          // Line Cap, Line Join, Dashes are stored in layer.data and shown in More Options
          createAnimatableProperty("Trim Start", 0, "number", "Trim Paths"),
          createAnimatableProperty("Trim End", 100, "number", "Trim Paths"),
          createAnimatableProperty("Trim Offset", 0, "number", "Trim Paths")
          // Note: "Closed" is stored in layer.data.closed as a boolean, not animatable
          // It's displayed in the timeline via the Path Options group in EnhancedLayerTrack
        ];
      }
      const layer = {
        id,
        name: name || `${type.charAt(0).toUpperCase() + type.slice(1)} ${layers.length + 1}`,
        type,
        visible: true,
        locked: false,
        isolate: false,
        threeD: false,
        motionBlur: false,
        inPoint: 0,
        outPoint: (comp?.settings.frameCount || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: createAnimatableProperty("opacity", 100, "number"),
        transform: layerTransform,
        audio: audioProps,
        properties: layerProperties,
        effects: [],
        data: layerData
      };
      if (type === "camera") {
        storeLogger.warn("Use createCameraLayer() for camera layers");
      }
      layers.unshift(layer);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Delete a layer
     */
    deleteLayer(layerId) {
      deleteLayer(this, layerId);
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(layerId) {
      return duplicateLayer(this, layerId);
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      copySelectedLayers(this);
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      return pasteLayers(this);
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      cutSelectedLayers(this);
    },
    /**
     * Select all layers in the active composition
     */
    selectAllLayers() {
      const layers = this.getActiveCompLayers();
      const selection = useSelectionStore();
      selection.selectLayers(layers.map((l) => l.id));
    },
    /**
     * Delete all selected layers
     */
    deleteSelectedLayers() {
      const selection = useSelectionStore();
      const layerIds = [...selection.selectedLayerIds];
      layerIds.forEach((id) => this.deleteLayer(id));
      selection.clearLayerSelection();
    },
    /**
     * Duplicate all selected layers
     */
    duplicateSelectedLayers() {
      const selection = useSelectionStore();
      const newLayerIds = [];
      selection.selectedLayerIds.forEach((id) => {
        const newLayer = duplicateLayer(this, id);
        if (newLayer) {
          newLayerIds.push(newLayer.id);
        }
      });
      if (newLayerIds.length > 0) {
        selection.selectLayers(newLayerIds);
      }
    },
    /**
     * Update layer properties
     */
    updateLayer(layerId, updates) {
      updateLayer(this, layerId, updates);
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(layerId, dataUpdates) {
      updateLayerData(this, layerId, dataUpdates);
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(layerId, point) {
      addSplineControlPoint(this, layerId, point);
    },
    /**
     * Insert a control point at a specific index in a spline layer
     */
    insertSplineControlPoint(layerId, point, index) {
      insertSplineControlPoint(this, layerId, point, index);
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(layerId, pointId, updates) {
      updateSplineControlPoint(this, layerId, pointId, updates);
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(layerId, pointId) {
      deleteSplineControlPoint(this, layerId, pointId);
    },
    /**
     * Enable animation mode on a spline layer (converts to keyframeable control points)
     */
    enableSplineAnimation(layerId) {
      enableSplineAnimation(this, layerId);
    },
    /**
     * Add keyframe to a spline control point property
     */
    addSplinePointKeyframe(layerId, pointId, property, frame) {
      addSplinePointKeyframe(this, layerId, pointId, property, frame);
    },
    /**
     * Add keyframes to all position properties of a control point
     */
    addSplinePointPositionKeyframe(layerId, pointId, frame) {
      addSplinePointPositionKeyframe(this, layerId, pointId, frame);
    },
    /**
     * Update spline control point with optional keyframe
     */
    updateSplinePointWithKeyframe(layerId, pointId, x, y, frame, addKeyframe = false) {
      updateSplinePointWithKeyframe(this, layerId, pointId, x, y, frame, addKeyframe);
    },
    /**
     * Get evaluated control points at a specific frame
     */
    getEvaluatedSplinePoints(layerId, frame) {
      return getEvaluatedSplinePoints(this, layerId, frame);
    },
    /**
     * Check if spline has animation enabled
     */
    isSplineAnimated(layerId) {
      return isSplineAnimated(this, layerId);
    },
    /**
     * Check if a control point has any keyframes
     */
    hasSplinePointKeyframes(layerId, pointId) {
      return hasSplinePointKeyframes(this, layerId, pointId);
    },
    /**
     * Simplify a spline by reducing control points (Douglas-Peucker)
     * @param tolerance - Distance threshold in pixels (higher = more simplification)
     */
    simplifySpline(layerId, tolerance) {
      simplifySpline(this, layerId, tolerance);
    },
    /**
     * Smooth spline handles to create smoother curves
     * @param amount - Smoothing amount 0-100 (100 = fully smooth)
     */
    smoothSplineHandles(layerId, amount) {
      smoothSplineHandles(this, layerId, amount);
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(layerId) {
      toggleLayer3D(this, layerId);
    },
    /**
     * Reorder layers
     */
    moveLayer(layerId, newIndex) {
      moveLayer(this, layerId, newIndex);
    },
    /**
     * Selection
     */
    selectLayer(layerId, addToSelection = false) {
      selectLayer(this, layerId, addToSelection);
    },
    deselectLayer(layerId) {
      deselectLayer(this, layerId);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(layerId, parentId) {
      setLayerParent(this, layerId, parentId);
    },
    clearSelection() {
      const selection = useSelectionStore();
      selection.clearAll();
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(propertyPath) {
      useSelectionStore().setSelectedPropertyPath(propertyPath);
    },
    // ============================================================
    // MOTION ENGINE INTEGRATION
    // ============================================================
    /**
     * Get evaluated FrameState for the current frame
     *
     * This is the CANONICAL way to get evaluated state for rendering.
     * Uses MotionEngine.evaluate() which is PURE and deterministic.
     *
     * @param frame - Optional frame override (defaults to currentFrame)
     * @returns Immutable FrameState snapshot
     */
    getFrameState(frame) {
      const comp = this.getActiveComp();
      const targetFrame = frame ?? (comp?.currentFrame ?? 0);
      return motionEngine.evaluate(
        targetFrame,
        this.project,
        this.audioAnalysis,
        this.activeCameraId
      );
    },
    // ============================================================
    // PLAYBACK CONTROLS
    // ============================================================
    /**
     * Start playback
     * NOTE: This only updates UI state (currentFrame).
     * Actual frame evaluation happens via getFrameState().
     */
    play() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) return;
      const comp = this.getActiveComp();
      if (!comp) return;
      playback.play(
        comp.settings.fps,
        comp.settings.frameCount,
        comp.currentFrame,
        (frame) => {
          comp.currentFrame = frame;
        }
      );
      this.isPlaying = true;
    },
    /**
     * Pause playback
     */
    pause() {
      const playback = usePlaybackStore();
      playback.stop();
      this.isPlaying = false;
    },
    /**
     * Toggle playback state
     */
    togglePlayback() {
      const playback = usePlaybackStore();
      if (playback.isPlaying) {
        this.pause();
      } else {
        this.play();
      }
    },
    /**
     * Set current frame (UI state only)
     * Components watching currentFrame should call getFrameState() to evaluate.
     */
    setFrame(frame) {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = Math.max(0, Math.min(frame, comp.settings.frameCount - 1));
    },
    /**
     * Advance to next frame (UI state only)
     */
    nextFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame < comp.settings.frameCount - 1) {
        comp.currentFrame++;
      }
    },
    /**
     * Go to previous frame (UI state only)
     */
    prevFrame() {
      const comp = this.getActiveComp();
      if (!comp) return;
      if (comp.currentFrame > 0) {
        comp.currentFrame--;
      }
    },
    /**
     * Jump to first frame (UI state only)
     */
    goToStart() {
      const comp = this.getActiveComp();
      if (comp) comp.currentFrame = 0;
    },
    /**
     * Jump to last frame (UI state only)
     */
    goToEnd() {
      const comp = this.getActiveComp();
      if (!comp) return;
      comp.currentFrame = comp.settings.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(tool) {
      if (tool === "segment") {
        this.segmentToolActive = true;
      } else {
        this.segmentToolActive = false;
        useSelectionStore().setTool(tool);
        this.clearSegmentPendingMask();
      }
    },
    /**
     * Set segmentation mode (point or box)
     */
    setSegmentMode(mode) {
      this.segmentMode = mode;
      this.clearSegmentPendingMask();
    },
    /**
     * Clear pending segmentation mask
     */
    clearSegmentPendingMask() {
      this.segmentPendingMask = null;
      this.segmentBoxStart = null;
    },
    /**
     * Set pending segmentation mask (preview before creating layer)
     */
    setSegmentPendingMask(mask) {
      this.segmentPendingMask = mask;
    },
    /**
     * Set box selection start point
     */
    setSegmentBoxStart(point) {
      this.segmentBoxStart = point;
    },
    /**
     * Set segmentation loading state
     */
    setSegmentLoading(loading) {
      this.segmentIsLoading = loading;
    },
    /**
     * Confirm pending mask and create layer from it
     */
    async confirmSegmentMask(layerName) {
      if (!this.segmentPendingMask || !this.sourceImage) {
        return null;
      }
      const layer = await createLayerFromMask(
        this,
        this.sourceImage,
        this.segmentPendingMask,
        layerName,
        false
      );
      this.clearSegmentPendingMask();
      return layer;
    },
    /**
     * History management
     */
    pushHistory() {
      pushHistory(this);
    },
    undo() {
      undo(this);
    },
    redo() {
      redo(this);
    },
    /**
     * Project serialization
     */
    exportProject() {
      return exportProject(this);
    },
    importProject(json) {
      importProject(this, json, () => this.pushHistory());
    },
    /**
     * Save project to server (ComfyUI backend)
     */
    async saveProjectToServer(projectId) {
      return saveProjectToServer(this, projectId);
    },
    /**
     * Load project from server (ComfyUI backend)
     */
    async loadProjectFromServer(projectId) {
      return loadProjectFromServer(this, projectId, () => this.pushHistory());
    },
    /**
     * List all projects saved on server
     */
    async listServerProjects() {
      return listServerProjects();
    },
    /**
     * Delete a project from server
     */
    async deleteServerProject(projectId) {
      return deleteServerProject(projectId);
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Toggle hide minimized layers in timeline
     */
    toggleHideMinimizedLayers() {
      this.hideMinimizedLayers = !this.hideMinimizedLayers;
    },
    /** @deprecated Use toggleHideMinimizedLayers instead */
    toggleHideShyLayers() {
      this.toggleHideMinimizedLayers();
    },
    /**
     * Set hide minimized layers state
     */
    setHideMinimizedLayers(hide) {
      this.hideMinimizedLayers = hide;
    },
    /** @deprecated Use setHideMinimizedLayers instead */
    setHideShyLayers(hide) {
      this.setHideMinimizedLayers(hide);
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(property) {
      return interpolateProperty(property, this.getActiveComp()?.currentFrame ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(layerId, propertyName, value, atFrame) {
      return addKeyframe(this, layerId, propertyName, value, atFrame);
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(layerId, propertyName, keyframeId) {
      removeKeyframe(this, layerId, propertyName, keyframeId);
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(layerId, propertyPath, value) {
      setPropertyValue(this, layerId, propertyPath, value);
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(layerId, propertyPath, animated) {
      setPropertyAnimated(this, layerId, propertyPath, animated, () => {
        this.addKeyframe(layerId, propertyPath, findPropertyByPath(
          this.getActiveCompLayers().find((l) => l.id === layerId),
          propertyPath
        )?.value);
      });
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(layerId, propertyPath, keyframeId, newFrame) {
      moveKeyframe(this, layerId, propertyPath, keyframeId, newFrame);
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(layerId, propertyPath, keyframeId, newValue) {
      setKeyframeValue(this, layerId, propertyPath, keyframeId, newValue);
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(layerId, propertyPath, keyframeId, interpolation) {
      setKeyframeInterpolation(this, layerId, propertyPath, keyframeId, interpolation);
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(layerId, propertyPath, keyframeId, updates) {
      updateKeyframe(this, layerId, propertyPath, keyframeId, updates);
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(layerId, propertyPath, keyframeId, handleType, handle) {
      setKeyframeHandle(this, layerId, propertyPath, keyframeId, handleType, handle);
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(text = "Text") {
      const layer = this.createLayer("text", text.substring(0, 20));
      const textData = {
        text,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: false,
        pathPerpendicularToPath: true,
        pathForceAlignment: false,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: false
      };
      layer.data = textData;
      layer.properties.push(createAnimatableProperty("Font Size", 72, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Fill Color", "#ffffff", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Color", "#000000", "color", "Text"));
      layer.properties.push(createAnimatableProperty("Stroke Width", 0, "number", "Text"));
      layer.properties.push(createAnimatableProperty("Path Offset", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("First Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Last Margin", 0, "number", "Path Options"));
      layer.properties.push(createAnimatableProperty("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options"));
      layer.properties.push(createAnimatableProperty("Tracking", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Line Spacing", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Offset", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Character Value", 0, "number", "Advanced"));
      layer.properties.push(createAnimatableProperty("Blur", { x: 0, y: 0 }, "position", "Advanced"));
      return layer;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const layer = this.createLayer("spline");
      const splineData = {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      layer.data = splineData;
      return layer;
    },
    /**
     * Create a shape layer with proper data structure
     */
    createShapeLayer(name = "Shape Layer") {
      const layer = this.createLayer("shape", name);
      return layer;
    },
    /**
     * Rename a layer by ID
     */
    renameLayer(layerId, newName) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (layer) {
        layer.name = newName;
        this.pushHistory();
      }
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const layer = this.createLayer("particles", "Particle System");
      const activeComp = this.getActiveComp();
      const compWidth = activeComp?.settings.width || this.project.composition.width;
      const compHeight = activeComp?.settings.height || this.project.composition.height;
      const particleData = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          // Use pixel coordinates - center of composition
          x: compWidth / 2,
          y: compHeight / 2,
          direction: 270,
          // Up direction (270 degrees)
          spread: 30,
          speed: 150,
          // Pixels per second
          speedVariance: 30,
          size: 8,
          sizeVariance: 2,
          color: [255, 200, 100],
          emissionRate: 30,
          // Particles per second
          initialBurst: 0,
          particleLifetime: 90,
          lifetimeVariance: 15,
          enabled: true,
          burstOnBeat: false,
          burstCount: 20,
          // Geometric emitter shape defaults (in pixels)
          shape: "point",
          shapeRadius: 50,
          shapeWidth: 100,
          shapeHeight: 100,
          shapeDepth: 100,
          shapeInnerRadius: 25,
          emitFromEdge: false,
          emitFromVolume: false,
          // Spline path emission (null = disabled)
          splinePath: null,
          // Sprite configuration
          sprite: {
            enabled: false,
            imageUrl: null,
            imageData: null,
            isSheet: false,
            columns: 1,
            rows: 1,
            totalFrames: 1,
            frameRate: 30,
            playMode: "loop",
            billboard: true,
            rotationEnabled: false,
            rotationSpeed: 0,
            rotationSpeedVariance: 0,
            alignToVelocity: false
          }
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      layer.data = particleData;
      return layer;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(layerId, config) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters.push(config);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(layerId, emitterId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      const emitter = data.emitters.find((e) => e.id === emitterId);
      if (emitter) {
        Object.assign(emitter, updates);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(layerId, emitterId) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "particles") return;
      const data = layer.data;
      data.emitters = data.emitters.filter((e) => e.id !== emitterId);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(sourceLayerId = "", depthLayerId = "") {
      const layer = this.createLayer("depthflow", "Depthflow");
      const depthflowData = {
        sourceLayerId,
        depthLayerId,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        },
        animatedZoom: createAnimatableProperty("zoom", 1, "number"),
        animatedOffsetX: createAnimatableProperty("offsetX", 0, "number"),
        animatedOffsetY: createAnimatableProperty("offsetY", 0, "number"),
        animatedRotation: createAnimatableProperty("rotation", 0, "number"),
        animatedDepthScale: createAnimatableProperty("depthScale", 1, "number")
      };
      layer.data = depthflowData;
      return layer;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "depthflow") return;
      const data = layer.data;
      Object.assign(data.config, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(file, autoResizeComposition = true) {
      let videoUrl;
      try {
        videoUrl = URL.createObjectURL(file);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let metadata;
      try {
        metadata = await extractVideoMetadata(videoUrl);
      } catch (error) {
        URL.revokeObjectURL(videoUrl);
        throw new Error(`Failed to load video metadata: ${error.message}`);
      }
      const assetId = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const asset = {
        id: assetId,
        type: "video",
        source: "file",
        width: metadata.width,
        height: metadata.height,
        data: videoUrl,
        // Video-specific metadata
        duration: metadata.duration,
        frameCount: metadata.frameCount,
        fps: metadata.fps,
        hasAudio: metadata.hasAudio
      };
      this.project.assets[assetId] = asset;
      if (autoResizeComposition) {
        const compSettings = calculateCompositionFromVideo(metadata, this.project.composition.fps);
        storeLogger.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: compSettings.width,
          newHeight: compSettings.height,
          newFrameCount: compSettings.frameCount,
          videoDuration: metadata.duration
        });
        this.project.composition.width = compSettings.width;
        this.project.composition.height = compSettings.height;
        this.project.composition.frameCount = compSettings.frameCount;
        this.project.composition.duration = compSettings.frameCount / this.project.composition.fps;
      }
      const layer = this.createLayer("video", file.name.replace(/\.[^.]+$/, ""));
      const videoData = {
        assetId,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: metadata.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      layer.data = videoData;
      if (!autoResizeComposition) {
        const videoFrameCount = Math.ceil(metadata.duration * this.project.composition.fps);
        layer.outPoint = Math.min(videoFrameCount - 1, this.project.composition.frameCount - 1);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Created video layer:", {
        layerId: layer.id,
        assetId,
        dimensions: `${metadata.width}x${metadata.height}`,
        duration: `${metadata.duration.toFixed(2)}s`,
        frameCount: metadata.frameCount,
        hasAudio: metadata.hasAudio
      });
      return layer;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(layerId, metadata) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "video") return;
      const videoData = layer.data;
      if (!videoData.assetId) return;
      const asset = this.project.assets[videoData.assetId];
      if (asset) {
        asset.width = metadata.width;
        asset.height = metadata.height;
        asset.duration = metadata.duration;
        asset.frameCount = metadata.frameCount;
        asset.fps = metadata.fps;
        asset.hasAudio = metadata.hasAudio;
      }
      storeLogger.debug("Video metadata loaded:", { layerId, metadata });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(width, height, frameCount) {
      const comp = this.getActiveComp();
      if (!comp) return;
      const oldFrameCount = comp.settings.frameCount;
      comp.settings.width = width;
      comp.settings.height = height;
      this.project.composition.width = width;
      this.project.composition.height = height;
      if (frameCount !== void 0) {
        comp.settings.frameCount = frameCount;
        comp.settings.duration = frameCount / comp.settings.fps;
        this.project.composition.frameCount = frameCount;
        this.project.composition.duration = frameCount / this.project.composition.fps;
        if (frameCount > oldFrameCount) {
          for (const layer of comp.layers) {
            if (layer.outPoint === oldFrameCount - 1) {
              layer.outPoint = frameCount - 1;
            }
          }
        }
      }
      if (comp.currentFrame >= comp.settings.frameCount) {
        comp.currentFrame = comp.settings.frameCount - 1;
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      storeLogger.debug("Composition resized:", {
        width,
        height,
        frameCount: comp.settings.frameCount
      });
    },
    // ============================================================
    // NESTED COMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a nested comp layer referencing another composition
     */
    createNestedCompLayer(compositionId, name) {
      const layer = this.createLayer("nestedComp", name || "Nested Comp");
      const nestedCompData = {
        compositionId,
        timeRemapEnabled: false,
        timeRemap: void 0,
        flattenTransform: false,
        overrideFrameRate: false,
        frameRate: void 0
      };
      layer.data = nestedCompData;
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      this.pushHistory();
      return layer;
    },
    /**
     * Update nested comp layer data
     */
    updateNestedCompLayerData(layerId, updates) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer || layer.type !== "nestedComp") return;
      const data = layer.data;
      Object.assign(data, updates);
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // SEGMENTATION ACTIONS (delegated to segmentationActions)
    // ============================================================
    async segmentToLayerByPoint(point, options = {}) {
      return segmentToLayerByPoint(this, point, options);
    },
    async segmentToLayerByBox(box, options = {}) {
      return segmentToLayerByBox(this, box, options);
    },
    async segmentToLayerByMultiplePoints(foregroundPoints, backgroundPoints = [], options = {}) {
      return segmentToLayerByMultiplePoints(this, foregroundPoints, backgroundPoints, options);
    },
    async autoSegmentToLayers(options = {}) {
      return autoSegmentToLayers(this, options);
    },
    // ============================================================
    // EFFECT ACTIONS (delegated to effectActions)
    // ============================================================
    addEffectToLayer(layerId, effectKey) {
      addEffectToLayer(this, layerId, effectKey);
    },
    removeEffectFromLayer(layerId, effectId) {
      removeEffectFromLayer(this, layerId, effectId);
    },
    updateEffectParameter(layerId, effectId, paramKey, value) {
      updateEffectParameter(this, layerId, effectId, paramKey, value);
    },
    setEffectParamAnimated(layerId, effectId, paramKey, animated) {
      setEffectParamAnimated(this, layerId, effectId, paramKey, animated);
    },
    toggleEffect(layerId, effectId) {
      toggleEffect(this, layerId, effectId);
    },
    reorderEffects(layerId, fromIndex, toIndex) {
      reorderEffects(this, layerId, fromIndex, toIndex);
    },
    getEffectParameterValue(layerId, effectId, paramKey, frame) {
      return getEffectParameterValue(this, layerId, effectId, paramKey, frame);
    },
    // ============================================================
    // CAMERA ACTIONS (delegated to cameraActions module)
    // ============================================================
    createCameraLayer(name) {
      return createCameraLayer(this, name);
    },
    getCamera(cameraId) {
      return getCamera(this, cameraId);
    },
    updateCamera(cameraId, updates) {
      updateCamera(this, cameraId, updates);
    },
    setActiveCamera(cameraId) {
      setActiveCamera(this, cameraId);
    },
    deleteCamera(cameraId) {
      deleteCamera(this, cameraId);
    },
    getCameraKeyframes(cameraId) {
      return getCameraKeyframes(this, cameraId);
    },
    addCameraKeyframe(cameraId, keyframe) {
      addCameraKeyframe(this, cameraId, keyframe);
    },
    removeCameraKeyframe(cameraId, frame) {
      removeCameraKeyframe(this, cameraId, frame);
    },
    getCameraAtFrame(cameraId, frame) {
      return getCameraAtFrame(this, cameraId, frame);
    },
    getActiveCameraAtFrame(frame) {
      return getActiveCameraAtFrame(this, frame);
    },
    updateViewportState(updates) {
      updateViewportState(this, updates);
    },
    updateViewOptions(updates) {
      updateViewOptions(this, updates);
    },
    // ============================================================
    // AUDIO ACTIONS (delegated to audioActions module)
    // ============================================================
    async loadAudio(file) {
      return loadAudio(this, file);
    },
    cancelAudioLoad() {
      cancelAudioLoad(this);
    },
    clearAudio() {
      clearAudio(this);
    },
    setAudioVolume(volume) {
      this.audioVolume = Math.max(0, Math.min(100, volume));
    },
    setAudioMuted(muted) {
      this.audioMuted = muted;
    },
    toggleAudioMute() {
      this.audioMuted = !this.audioMuted;
    },
    getAudioFeatureAtFrame(feature, frame) {
      return getAudioFeatureAtFrame(this, feature, frame);
    },
    applyAudioToParticles(layerId, mapping) {
      applyAudioToParticles(this, layerId, mapping);
    },
    removeLegacyAudioMapping(layerId, index) {
      removeLegacyAudioMapping(this, layerId, index);
    },
    getAudioMappingsForLayer(layerId) {
      return getAudioMappingsForLayer(this, layerId);
    },
    setPeakData(peakData) {
      setPeakData(this, peakData);
    },
    detectAudioPeaks(config) {
      return detectAudioPeaks(this, config);
    },
    addAudioMapping(mapping) {
      addAudioMapping(this, mapping);
    },
    removeAudioMapping(mappingId) {
      removeAudioMapping(this, mappingId);
    },
    updateAudioMapping(mappingId, updates) {
      updateAudioMapping(this, mappingId, updates);
    },
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    getMappedValueAtFrame(mappingId, frame) {
      return getMappedValueAtFrame(this, mappingId, frame);
    },
    getAllMappedValuesAtFrame(frame) {
      return getAllMappedValuesAtFrame(this, frame);
    },
    getActiveMappingsForLayer(layerId) {
      return getActiveMappingsForLayer(this, layerId);
    },
    getAudioReactiveValuesForLayer(layerId, frame) {
      return getAudioReactiveValuesForLayer(this, layerId, frame);
    },
    isBeatAtCurrentFrame() {
      return isBeatAtCurrentFrame(this);
    },
    // Timeline snapping (simple inline - no need for delegation)
    findSnapPoint(frame, pixelsPerFrame, selectedLayerId) {
      return findNearestSnap(frame, this.snapConfig, pixelsPerFrame, {
        layers: this.layers,
        selectedLayerId,
        currentFrame: this.getActiveComp()?.currentFrame ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    getAudioBeatFrames() {
      return getBeatFrames(this.audioAnalysis);
    },
    getAudioPeakFrames() {
      return getPeakFrames(this.peakData);
    },
    setSnapConfig(config) {
      this.snapConfig = { ...this.snapConfig, ...config };
    },
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    toggleSnapType(type) {
      const typeMap = {
        "grid": "snapToGrid",
        "keyframes": "snapToKeyframes",
        "beats": "snapToBeats",
        "peaks": "snapToPeaks",
        "layerBounds": "snapToLayerBounds",
        "playhead": "snapToPlayhead"
      };
      const key = typeMap[type];
      if (key && typeof this.snapConfig[key] === "boolean") {
        this.snapConfig[key] = !this.snapConfig[key];
      }
    },
    // Path animator (delegated to audioActions module)
    createPathAnimator(layerId, config = {}) {
      createPathAnimator(this, layerId, config);
    },
    setPathAnimatorPath(layerId, pathData) {
      setPathAnimatorPath(this, layerId, pathData);
    },
    updatePathAnimatorConfig(layerId, config) {
      updatePathAnimatorConfig(this, layerId, config);
    },
    removePathAnimator(layerId) {
      removePathAnimator(this, layerId);
    },
    getPathAnimator(layerId) {
      return getPathAnimator(this, layerId);
    },
    updatePathAnimators() {
      updatePathAnimators(this);
    },
    resetPathAnimators() {
      resetPathAnimators(this);
    },
    initializeAudioReactiveMapper() {
      initializeAudioReactiveMapper(this);
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (delegated to propertyDriverActions)
    // ============================================================
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new PropertyDriverSystem();
      this.propertyDriverSystem.setPropertyGetter((layerId, propertyPath, frame) => {
        return this.getPropertyValueAtFrame(layerId, propertyPath, frame);
      });
      if (this.audioAnalysis) this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const driver of this.propertyDrivers) this.propertyDriverSystem.addDriver(driver);
    },
    getPropertyValueAtFrame(layerId, propertyPath, frame) {
      const layer = this.getActiveCompLayers().find((l) => l.id === layerId);
      if (!layer) return null;
      const parts = propertyPath.split(".");
      if (parts[0] === "transform") {
        const t = layer.transform;
        if (parts[1] === "position") {
          const p = interpolateProperty(t.position, frame);
          return parts[2] === "x" ? p.x : parts[2] === "y" ? p.y : p.z ?? 0;
        }
        if (parts[1] === "anchorPoint") {
          const a = interpolateProperty(t.anchorPoint, frame);
          return parts[2] === "x" ? a.x : parts[2] === "y" ? a.y : a.z ?? 0;
        }
        if (parts[1] === "scale") {
          const s = interpolateProperty(t.scale, frame);
          return parts[2] === "x" ? s.x : parts[2] === "y" ? s.y : s.z ?? 100;
        }
        if (parts[1] === "rotation") return interpolateProperty(t.rotation, frame);
        if (parts[1] === "rotationX" && t.rotationX) return interpolateProperty(t.rotationX, frame);
        if (parts[1] === "rotationY" && t.rotationY) return interpolateProperty(t.rotationY, frame);
        if (parts[1] === "rotationZ" && t.rotationZ) return interpolateProperty(t.rotationZ, frame);
      }
      return parts[0] === "opacity" ? interpolateProperty(layer.opacity, frame) : null;
    },
    getDrivenValuesForLayer(layerId) {
      return getEvaluatedLayerProperties(this, layerId, this.getActiveComp()?.currentFrame ?? 0);
    },
    addPropertyDriver(driver) {
      return addPropertyDriver(this, driver);
    },
    createAudioPropertyDriver(targetLayerId, targetProperty, audioFeature, options = {}) {
      return createAudioPropertyDriver(this, targetLayerId, targetProperty, audioFeature, options);
    },
    createPropertyLink(targetLayerId, targetProperty, sourceLayerId, sourceProperty, options = {}) {
      return createPropertyLinkDriver(this, targetLayerId, targetProperty, sourceLayerId, sourceProperty, options);
    },
    removePropertyDriver(driverId) {
      removePropertyDriver(this, driverId);
    },
    updatePropertyDriver(driverId, updates) {
      updatePropertyDriver(this, driverId, updates);
    },
    getDriversForLayer(layerId) {
      return getDriversForLayer(this, layerId);
    },
    togglePropertyDriver(driverId) {
      togglePropertyDriver(this, driverId);
    },
    // ============================================================
    // PARTICLE SIMULATION ACTIONS
    // ============================================================
    /**
     * Reset a particle layer's simulation
     * Called when particle configuration changes
     */
    resetParticleSimulation(layerId) {
      particleSimulationRegistry.resetLayer(layerId);
      storeLogger.debug("Reset particle simulation for layer:", layerId);
    },
    /**
     * Clear all particle simulations
     * Called on project load/new
     */
    clearAllParticleSimulations() {
      particleSimulationRegistry.clear();
      storeLogger.debug("Cleared all particle simulations");
    },
    /**
     * Get particle snapshot for a layer at a specific frame
     * Evaluates the frame state to get the deterministic snapshot
     */
    getParticleSnapshot(layerId, frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots[layerId] ?? null;
    },
    /**
     * Get all particle snapshots from current frame
     */
    getAllParticleSnapshots(frame) {
      const frameState = this.getFrameState(frame);
      return frameState.particleSnapshots;
    },
    // ============================================================
    // AUTOSAVE/PROJECT ACTIONS (delegated to projectActions)
    // ============================================================
    enableAutosave(intervalMs) {
      configureAutosave(this, { enabled: true, intervalMs }, () => this.performAutosave());
    },
    disableAutosave() {
      stopAutosave(this);
      this.autosaveEnabled = false;
    },
    startAutosaveTimer() {
      startAutosave(this, () => this.performAutosave());
    },
    stopAutosaveTimer() {
      stopAutosave(this);
    },
    async performAutosave() {
      return performAutosave(this);
    },
    markUnsavedChanges() {
      markUnsavedChanges(this);
      this.invalidateFrameCache();
    },
    async saveProjectToBackend() {
      const result = await saveProjectToServer(this);
      if (!result) throw new Error("Save failed");
      return result;
    },
    async loadProjectFromBackend(projectId) {
      const success = await loadProjectFromServer(this, projectId, () => this.pushHistory());
      if (!success) throw new Error("Load failed");
    },
    async listSavedProjects() {
      return listServerProjects();
    },
    // ============================================================
    // FRAME CACHE ACTIONS (delegated to cacheActions)
    // ============================================================
    async initializeFrameCache() {
      return initializeCache(this);
    },
    setFrameCacheEnabled(enabled) {
      setFrameCacheEnabled(this, enabled);
    },
    getCachedFrame(frame) {
      return getCachedFrame(this, frame);
    },
    async cacheFrame(frame, imageData) {
      return cacheFrame(this, frame, imageData);
    },
    isFrameCached(frame) {
      return isFrameCached(this, frame);
    },
    async startPreCache(currentFrame, direction = "both") {
      return startPreCache(this, currentFrame, direction);
    },
    invalidateFrameCache() {
      invalidateFrameCache(this);
    },
    clearFrameCache() {
      clearFrameCache();
    },
    getFrameCacheStats() {
      return getFrameCacheStats();
    },
    computeProjectHash() {
      return computeProjectHash(this);
    }
  }
});

const comfyLogger = createLogger("ComfyUI");
class ComfyUIClient {
  serverAddress;
  clientId;
  ws = null;
  messageHandlers = /* @__PURE__ */ new Map();
  constructor(config) {
    this.serverAddress = config.serverAddress.replace(/\/$/, "");
    this.clientId = config.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + secureUUID();
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      });
      return response.ok;
    } catch {
      return false;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const response = await fetch(`http://${this.serverAddress}/system_stats`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const response = await fetch(`http://${this.serverAddress}/prompt`);
      if (!response.ok) return null;
      return response.json();
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(imageData, filename, type = "input", subfolder, overwrite = true) {
    const formData = new FormData();
    formData.append("image", imageData, filename);
    formData.append("type", type);
    formData.append("overwrite", overwrite.toString());
    if (subfolder) {
      formData.append("subfolder", subfolder);
    }
    const response = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to upload image: ${error}`);
    }
    return response.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(maskData, filename, originalRef) {
    const formData = new FormData();
    formData.append("image", maskData, filename);
    formData.append("original_ref", JSON.stringify(originalRef));
    formData.append("type", "input");
    const response = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`Failed to upload mask: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(workflow, extraData) {
    const payload = {
      prompt: workflow,
      client_id: this.clientId,
      extra_data: extraData
    };
    const response = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to queue prompt: ${error}`);
    }
    return response.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(promptId) {
    const url = promptId ? `http://${this.serverAddress}/history/${promptId}` : `http://${this.serverAddress}/history`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to get history: ${await response.text()}`);
    }
    return response.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(filename, subfolder = "", type = "output") {
    const params = new URLSearchParams({
      filename,
      subfolder,
      type
    });
    const response = await fetch(`http://${this.serverAddress}/view?${params}`);
    if (!response.ok) {
      throw new Error(`Failed to get output: ${await response.text()}`);
    }
    return response.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(filename, subfolder = "", type = "output") {
    const blob = await this.getOutput(filename, subfolder, type);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const response = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!response.ok) {
      throw new Error(`Failed to interrupt: ${await response.text()}`);
    }
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const response = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: true })
    });
    if (!response.ok) {
      throw new Error(`Failed to clear queue: ${await response.text()}`);
    }
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(deleteType, ids) {
    const response = await fetch(`http://${this.serverAddress}/${deleteType}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: ids })
    });
    if (!response.ok) {
      throw new Error(`Failed to delete from ${deleteType}: ${await response.text()}`);
    }
  }
  /**
   * Get available models
   */
  async getModels(type) {
    const folderMap = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    };
    const response = await fetch(
      `http://${this.serverAddress}/models/${folderMap[type]}`
    );
    if (!response.ok) {
      return [];
    }
    return response.json();
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const wsUrl = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(wsUrl);
      this.ws.onopen = () => {
        comfyLogger.debug("WebSocket connected");
        resolve();
      };
      this.ws.onerror = (event) => {
        comfyLogger.error("WebSocket error:", event);
        reject(new Error("WebSocket connection failed"));
      };
      this.ws.onclose = () => {
        comfyLogger.debug("WebSocket disconnected");
        this.ws = null;
      };
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data);
        } catch (e) {
          comfyLogger.error("Failed to parse WebSocket message:", e);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.messageHandlers.clear();
  }
  /**
   * Clean up all resources (WebSocket, handlers)
   * Call this when the client is no longer needed
   */
  destroy() {
    this.disconnectWebSocket();
    comfyLogger.debug("ComfyUI client destroyed");
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(type, handler) {
    this.messageHandlers.set(type, handler);
  }
  /**
   * Remove a message handler
   */
  offMessage(type) {
    this.messageHandlers.delete(type);
  }
  handleWebSocketMessage(data) {
    const { type } = data;
    const handler = this.messageHandlers.get(type);
    if (handler) {
      handler(data);
    }
    const allHandler = this.messageHandlers.get("all");
    if (allHandler) {
      allHandler(data);
    }
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(imageData, filename, subfolder) {
    const canvas = new OffscreenCanvas(imageData.width, imageData.height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(canvas, filename, subfolder) {
    let blob;
    if (canvas instanceof OffscreenCanvas) {
      blob = await canvas.convertToBlob({ type: "image/png" });
    } else {
      blob = await new Promise((resolve, reject) => {
        canvas.toBlob((b) => {
          if (b) resolve(b);
          else reject(new Error("Failed to convert canvas to blob"));
        }, "image/png");
      });
    }
    return this.uploadImage(blob, filename, "input", subfolder);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(promptId, onProgress, timeoutMs = 3e5) {
    const startTime = Date.now();
    if (!this.isWebSocketConnected()) {
      await this.connectWebSocket();
    }
    return new Promise((resolve, reject) => {
      let completed = false;
      const cleanup = () => {
        this.offMessage("progress");
        this.offMessage("executing");
        this.offMessage("executed");
        this.offMessage("execution_error");
      };
      const checkTimeout = () => {
        if (Date.now() - startTime > timeoutMs) {
          cleanup();
          reject(new Error("Prompt execution timed out"));
        }
      };
      this.onMessage("progress", (data) => {
        checkTimeout();
        onProgress?.({
          status: "executing",
          currentStep: data.data.value,
          totalSteps: data.data.max,
          percentage: data.data.value / data.data.max * 100
        });
      });
      this.onMessage("executing", (data) => {
        checkTimeout();
        if (data.data.prompt_id === promptId) {
          onProgress?.({
            status: "executing",
            currentNode: data.data.node,
            percentage: 10
            // Approximate
          });
        }
      });
      this.onMessage("executed", async (data) => {
        if (data.data.prompt_id === promptId && !completed) {
          completed = true;
          cleanup();
          onProgress?.({
            status: "completed",
            percentage: 100
          });
          const history = await this.getHistory(promptId);
          resolve(history[promptId]);
        }
      });
      this.onMessage("execution_error", (data) => {
        if (data.data.prompt_id === promptId) {
          cleanup();
          onProgress?.({
            status: "error",
            percentage: 0
          });
          reject(new Error(data.data.exception_message || "Execution failed"));
        }
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(workflow, onProgress) {
    const { prompt_id } = await this.queuePrompt(workflow);
    onProgress?.({
      status: "queued",
      percentage: 0
    });
    const history = await this.waitForPrompt(prompt_id, onProgress);
    const outputs = [];
    for (const nodeOutputs of Object.values(history.outputs)) {
      if (nodeOutputs.images) {
        outputs.push(...nodeOutputs.images);
      }
      if (nodeOutputs.gifs) {
        outputs.push(...nodeOutputs.gifs);
      }
    }
    return {
      promptId: prompt_id,
      history,
      outputs
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let defaultClient = null;
function getComfyUIClient(serverAddress) {
  if (!defaultClient || serverAddress && serverAddress !== defaultClient.server) {
    defaultClient = new ComfyUIClient({
      serverAddress: serverAddress || "127.0.0.1:8188"
    });
  }
  return defaultClient;
}

const logger$6 = createLogger("MemoryBudget");
const VRAM_ESTIMATES = {
  // AI Models
  "model:qwen-image-layered": 28800,
  "model:starvector": 4e3};
const THRESHOLDS = {
  info: 0.5,
  // 50% - getting busy
  warning: 0.75,
  // 75% - should consider cleanup
  critical: 0.9
  // 90% - likely to fail soon
};
const allocations = reactive(/* @__PURE__ */ new Map());
const gpuInfo = ref(null);
const isInitialized = ref(false);
const totalUsageMB = computed(() => {
  let total = 0;
  for (const alloc of allocations.values()) {
    total += alloc.estimatedMB;
  }
  return total;
});
const usageByCategory = computed(() => {
  const byCategory = {
    model: 0,
    texture: 0,
    framebuffer: 0,
    particles: 0,
    geometry: 0,
    audio: 0,
    other: 0
  };
  for (const alloc of allocations.values()) {
    byCategory[alloc.category] += alloc.estimatedMB;
  }
  return byCategory;
});
const availableVRAM = computed(() => {
  if (!gpuInfo.value) return 8e3;
  return gpuInfo.value.estimatedVRAM;
});
const usagePercent = computed(() => {
  return totalUsageMB.value / availableVRAM.value;
});
const warningLevel = computed(() => {
  const percent = usagePercent.value;
  if (percent >= THRESHOLDS.critical) return "critical";
  if (percent >= THRESHOLDS.warning) return "warning";
  if (percent >= THRESHOLDS.info) return "info";
  return "none";
});
const allocationList = computed(() => {
  return Array.from(allocations.values()).sort((a, b) => b.estimatedMB - a.estimatedMB);
});
const unloadableItems = computed(() => {
  return allocationList.value.filter((a) => a.canUnload);
});
async function initializeGPUDetection() {
  if (isInitialized.value) return;
  try {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
    if (gl) {
      const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
      const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Unknown";
      const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";
      const estimatedVRAM = estimateVRAMFromRenderer(renderer);
      const tier = determineTier(estimatedVRAM);
      gpuInfo.value = {
        vendor,
        renderer,
        estimatedVRAM,
        tier
      };
      logger$6.info(`GPU detected: ${renderer} (~${estimatedVRAM}MB VRAM, tier: ${tier})`);
    } else {
      gpuInfo.value = {
        vendor: "Unknown",
        renderer: "Software",
        estimatedVRAM: 4e3,
        // Conservative 4GB
        tier: "low"
      };
      logger$6.warn("WebGL not available, using conservative estimates");
    }
    isInitialized.value = true;
  } catch (error) {
    logger$6.error("GPU detection failed:", error);
    gpuInfo.value = {
      vendor: "Unknown",
      renderer: "Unknown",
      estimatedVRAM: 8e3,
      tier: "medium"
    };
    isInitialized.value = true;
  }
}
function registerAllocation(id, name, category, estimatedMB, options) {
  const allocation = {
    id,
    name,
    category,
    estimatedMB,
    timestamp: Date.now(),
    canUnload: options?.canUnload ?? false,
    unloadFn: options?.unloadFn
  };
  allocations.set(id, allocation);
  logger$6.debug(`Registered: ${name} (${estimatedMB}MB) - Total: ${totalUsageMB.value}MB`);
  checkAndLogWarning();
}
function unregisterAllocation(id) {
  const alloc = allocations.get(id);
  if (alloc) {
    allocations.delete(id);
    logger$6.debug(`Unregistered: ${alloc.name} - Total: ${totalUsageMB.value}MB`);
  }
}
function getWarning() {
  const level = warningLevel.value;
  if (level === "none") return null;
  const percent = Math.round(usagePercent.value * 100);
  const suggestions = [];
  const categories = usageByCategory.value;
  if (categories.model > 1e3) {
    suggestions.push("Unload unused AI models to free GPU memory");
  }
  if (categories.texture > 500) {
    suggestions.push("Reduce image layer count or resolution");
  }
  if (categories.framebuffer > 200) {
    suggestions.push("Clear frame cache or reduce composition resolution");
  }
  if (categories.particles > 200) {
    suggestions.push("Reduce particle count or disable unused emitters");
  }
  if (categories.geometry > 500) {
    suggestions.push("Simplify point clouds or 3D models");
  }
  const unloadable = unloadableItems.value.slice(0, 3);
  for (const item of unloadable) {
    if (item.estimatedMB > 100) {
      suggestions.push(`Unload "${item.name}" to free ${formatMB(item.estimatedMB)}`);
    }
  }
  const messages = {
    info: `Memory usage at ${percent}% - consider cleanup for optimal performance`,
    warning: `Memory usage at ${percent}% - performance may degrade, cleanup recommended`,
    critical: `Memory usage at ${percent}% - high risk of crashes, immediate cleanup needed`
  };
  return {
    level,
    message: messages[level],
    suggestions
  };
}
function canAllocate(estimatedMB) {
  const afterUsage = (totalUsageMB.value + estimatedMB) / availableVRAM.value;
  if (afterUsage >= THRESHOLDS.critical) {
    return {
      canProceed: false,
      warning: {
        level: "critical",
        message: `This operation requires ~${formatMB(estimatedMB)} but would exceed safe memory limits`,
        suggestions: [
          "Unload AI models before proceeding",
          "Close other GPU-intensive applications",
          "Reduce project complexity"
        ]
      }
    };
  }
  if (afterUsage >= THRESHOLDS.warning) {
    return {
      canProceed: true,
      warning: {
        level: "warning",
        message: `This operation requires ~${formatMB(estimatedMB)} - consider cleanup first`,
        suggestions: ["Unload unused models", "Clear frame cache"]
      }
    };
  }
  return { canProceed: true, warning: null };
}
async function freeMemory(targetMB) {
  let freed = 0;
  const candidates = unloadableItems.value;
  for (const item of candidates) {
    if (freed >= targetMB) break;
    if (item.unloadFn) {
      try {
        await item.unloadFn();
        freed += item.estimatedMB;
        unregisterAllocation(item.id);
        logger$6.info(`Freed ${formatMB(item.estimatedMB)} by unloading "${item.name}"`);
      } catch (error) {
        logger$6.error(`Failed to unload "${item.name}":`, error);
      }
    }
  }
  return freed;
}
function estimateVRAMFromRenderer(renderer) {
  const r = renderer.toLowerCase();
  if (r.includes("rtx 4090")) return 24e3;
  if (r.includes("rtx 4080")) return 16e3;
  if (r.includes("rtx 4070")) return 12e3;
  if (r.includes("rtx 4060")) return 8e3;
  if (r.includes("rtx 3090")) return 24e3;
  if (r.includes("rtx 3080")) return 1e4;
  if (r.includes("rtx 3070")) return 8e3;
  if (r.includes("rtx 3060")) return 12e3;
  if (r.includes("rtx 2080")) return 8e3;
  if (r.includes("rtx 2070")) return 8e3;
  if (r.includes("rtx 2060")) return 6e3;
  if (r.includes("gtx 1080")) return 8e3;
  if (r.includes("gtx 1070")) return 8e3;
  if (r.includes("gtx 1060")) return 6e3;
  if (r.includes("rx 7900")) return 24e3;
  if (r.includes("rx 7800")) return 16e3;
  if (r.includes("rx 7700")) return 12e3;
  if (r.includes("rx 6900")) return 16e3;
  if (r.includes("rx 6800")) return 16e3;
  if (r.includes("rx 6700")) return 12e3;
  if (r.includes("rx 6600")) return 8e3;
  if (r.includes("apple m3 max")) return 48e3;
  if (r.includes("apple m3 pro")) return 18e3;
  if (r.includes("apple m3")) return 8e3;
  if (r.includes("apple m2 max")) return 32e3;
  if (r.includes("apple m2 pro")) return 16e3;
  if (r.includes("apple m2")) return 8e3;
  if (r.includes("apple m1")) return 8e3;
  if (r.includes("intel") && r.includes("iris")) return 4e3;
  if (r.includes("intel") && r.includes("uhd")) return 2e3;
  return 8e3;
}
function determineTier(vramMB) {
  if (vramMB >= 16e3) return "ultra";
  if (vramMB >= 8e3) return "high";
  if (vramMB >= 4e3) return "medium";
  return "low";
}
function formatMB(mb) {
  if (mb >= 1e3) {
    return `${(mb / 1e3).toFixed(1)}GB`;
  }
  return `${Math.round(mb)}MB`;
}
function checkAndLogWarning() {
  const warning = getWarning();
  if (warning) {
    if (warning.level === "critical") {
      logger$6.error(warning.message);
    } else if (warning.level === "warning") {
      logger$6.warn(warning.message);
    }
  }
}
const memoryState = {
  totalUsageMB,
  availableVRAM,
  usagePercent,
  warningLevel,
  usageByCategory,
  gpuInfo};

const logger$5 = createLogger("LayerDecomposition");
const MODEL_ALLOCATION_ID = "model:qwen-image-layered";
class LayerDecompositionService {
  baseUrl;
  constructor(serverAddress) {
    const client = getComfyUIClient(serverAddress);
    this.baseUrl = `http://${client.server}`;
  }
  /**
   * Get current model status (downloaded, loaded, errors)
   */
  async getStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/status`);
      const result = await response.json();
      if (result.status === "success") {
        return result.data;
      }
      throw new Error(result.message || "Failed to get model status");
    } catch (error) {
      logger$5.error("Failed to get model status:", error);
      throw error;
    }
  }
  /**
   * Download the model (28.8GB, may take a while)
   *
   * @param onProgress - Optional callback for download progress
   */
  async downloadModel(onProgress) {
    try {
      onProgress?.("starting", 0);
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/download`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      onProgress?.("complete", 100);
      logger$5.info("Model download complete");
    } catch (error) {
      logger$5.error("Model download failed:", error);
      throw error;
    }
  }
  /**
   * Load the model into GPU memory
   */
  async loadModel() {
    const memCheck = canAllocate(VRAM_ESTIMATES["model:qwen-image-layered"]);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory");
    }
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/load`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      registerAllocation(
        MODEL_ALLOCATION_ID,
        "Qwen Image Layered Model",
        "model",
        VRAM_ESTIMATES["model:qwen-image-layered"],
        {
          canUnload: true,
          unloadFn: () => this.unloadModel()
        }
      );
      logger$5.info("Model loaded:", result.message);
    } catch (error) {
      logger$5.error("Model load failed:", error);
      throw error;
    }
  }
  /**
   * Unload the model from GPU memory
   */
  async unloadModel() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/unload`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      unregisterAllocation(MODEL_ALLOCATION_ID);
      logger$5.info("Model unloaded");
    } catch (error) {
      logger$5.error("Model unload failed:", error);
      throw error;
    }
  }
  /**
   * Decompose an image into RGBA layers
   *
   * @param imageDataUrl - Image as data URL (data:image/...;base64,...)
   * @param options - Decomposition options
   * @returns Array of decomposed layers
   */
  async decompose(imageDataUrl, options = {}) {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/decomposition/decompose`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          num_layers: options.numLayers ?? 4,
          guidance_scale: options.guidanceScale ?? 3,
          num_inference_steps: options.numInferenceSteps ?? 50,
          seed: options.seed ?? null
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$5.info(`Decomposition complete: ${result.layers.length} layers`);
      return result.layers;
    } catch (error) {
      logger$5.error("Decomposition failed:", error);
      throw error;
    }
  }
  /**
   * One-click decomposition: handles download, load, decompose, and cleanup
   *
   * @param imageDataUrl - Image as data URL
   * @param options - Decomposition options
   * @param onProgress - Progress callback
   */
  async decomposeWithAutoSetup(imageDataUrl, options = {}, onProgress) {
    const autoUnload = options.autoUnload !== false;
    const generateLabels = options.generateSemanticLabels !== false;
    try {
      onProgress?.("checking", "Checking model status...");
      const status = await this.getStatus();
      if (!status.downloaded) {
        onProgress?.("downloading", "Downloading model (28.8GB)...");
        await this.downloadModel();
      }
      if (!status.loaded) {
        onProgress?.("loading", "Loading model into GPU memory...");
        await this.loadModel();
      }
      onProgress?.("decomposing", "Decomposing image into layers...");
      const layers = await this.decompose(imageDataUrl, options);
      if (generateLabels && layers.length > 0) {
        onProgress?.("labeling", "Generating semantic labels...");
        await this.generateSemanticLabels(layers);
      }
      onProgress?.("complete", `Generated ${layers.length} layers`);
      return layers;
    } finally {
      if (autoUnload) {
        onProgress?.("cleanup", "Freeing GPU memory...");
        try {
          await this.unloadModel();
          logger$5.info("Model auto-unloaded to free GPU memory");
        } catch (unloadError) {
          logger$5.warn("Failed to auto-unload model:", unloadError);
        }
      }
    }
  }
  /**
   * Generate semantic labels for decomposed layers using simple heuristics
   * Analyzes alpha channel coverage and position to assign meaningful names
   */
  async generateSemanticLabels(layers) {
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      try {
        const img = await dataUrlToImage(layer.image);
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const analysis = analyzeLayerContent(imageData);
        layer.label = generateLabelFromAnalysis(analysis, i, layers.length);
      } catch (error) {
        logger$5.warn(`Failed to analyze layer ${i}:`, error);
      }
    }
  }
}
let defaultService$1 = null;
function getLayerDecompositionService(serverAddress) {
  if (!defaultService$1) {
    defaultService$1 = new LayerDecompositionService(serverAddress);
  }
  return defaultService$1;
}
function dataUrlToImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}
function analyzeLayerContent(imageData) {
  const { data, width, height } = imageData;
  const totalPixels = width * height;
  let visiblePixels = 0;
  let solidPixels = 0;
  let weightedX = 0;
  let weightedY = 0;
  let totalR = 0, totalG = 0, totalB = 0;
  let colorSamples = 0;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4;
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const a = data[i + 3];
      if (a > 0) {
        visiblePixels++;
        const weight = a / 255;
        weightedX += x * weight;
        weightedY += y * weight;
        if (a > 200) {
          solidPixels++;
          totalR += r;
          totalG += g;
          totalB += b;
          colorSamples++;
        }
      }
    }
  }
  const coverage = visiblePixels / totalPixels;
  const solidCoverage = solidPixels / totalPixels;
  const centerX = visiblePixels > 0 ? weightedX / visiblePixels / width : 0.5;
  const centerY = visiblePixels > 0 ? weightedY / visiblePixels / height : 0.5;
  const avgColor = colorSamples > 0 ? { r: totalR / colorSamples, g: totalG / colorSamples, b: totalB / colorSamples } : { r: 128, g: 128, b: 128 };
  return {
    coverage,
    solidCoverage,
    verticalCenter: centerY,
    horizontalCenter: centerX,
    avgColor,
    isSparse: coverage < 0.1,
    isDense: solidCoverage > 0.8,
    isUpper: centerY < 0.4,
    isLower: centerY > 0.6,
    isEdge: coverage > 0.1 && coverage < 0.4 && solidCoverage < coverage * 0.5
  };
}
function generateLabelFromAnalysis(analysis, index, totalLayers) {
  const position = index / (totalLayers - 1);
  if (index === 0) {
    if (analysis.isDense) {
      return "Background (Solid)";
    }
    if (analysis.isUpper && analysis.coverage > 0.3) {
      return "Background (Sky)";
    }
    return "Background";
  }
  if (index === totalLayers - 1) {
    if (analysis.isSparse) {
      return "Foreground (Details)";
    }
    return "Foreground (Subject)";
  }
  if (analysis.isEdge) {
    return `Edges/Outlines (${index + 1})`;
  }
  if (analysis.isSparse) {
    if (analysis.isUpper) {
      return `Upper Details (${index + 1})`;
    }
    if (analysis.isLower) {
      return `Lower Details (${index + 1})`;
    }
    return `Sparse Elements (${index + 1})`;
  }
  if (analysis.isDense) {
    return `Solid Region (${index + 1})`;
  }
  if (position < 0.33) {
    return `Back Elements (${index + 1})`;
  }
  if (position > 0.66) {
    return `Front Elements (${index + 1})`;
  }
  return `Mid Elements (${index + 1})`;
}

const _hoisted_1$L = { class: "decompose-dialog" };
const _hoisted_2$K = { class: "dialog-header" };
const _hoisted_3$I = ["disabled"];
const _hoisted_4$H = { class: "dialog-content" };
const _hoisted_5$H = { class: "status-section" };
const _hoisted_6$H = {
  key: 0,
  class: "model-info"
};
const _hoisted_7$H = { class: "form-group" };
const _hoisted_8$G = { class: "source-options" };
const _hoisted_9$G = ["disabled"];
const _hoisted_10$G = {
  key: 0,
  class: "layer-select"
};
const _hoisted_11$F = ["disabled"];
const _hoisted_12$D = ["value"];
const _hoisted_13$D = {
  key: 0,
  class: "upload-placeholder"
};
const _hoisted_14$A = ["src"];
const _hoisted_15$z = { class: "form-group" };
const _hoisted_16$y = { class: "slider-row" };
const _hoisted_17$x = ["disabled"];
const _hoisted_18$w = { class: "slider-value" };
const _hoisted_19$w = { class: "form-group options-group" };
const _hoisted_20$w = { class: "checkbox-row" };
const _hoisted_21$v = { class: "checkbox-label" };
const _hoisted_22$u = ["disabled"];
const _hoisted_23$t = { class: "checkbox-row" };
const _hoisted_24$q = { class: "checkbox-label" };
const _hoisted_25$p = ["disabled"];
const _hoisted_26$o = { class: "checkbox-row" };
const _hoisted_27$m = { class: "checkbox-label" };
const _hoisted_28$m = ["disabled"];
const _hoisted_29$m = {
  key: 0,
  class: "form-group collapsed-params"
};
const _hoisted_30$l = { class: "param-row" };
const _hoisted_31$h = ["disabled"];
const _hoisted_32$h = { class: "param-row" };
const _hoisted_33$h = ["disabled"];
const _hoisted_34$g = { class: "param-row" };
const _hoisted_35$f = ["disabled"];
const _hoisted_36$e = {
  key: 1,
  class: "progress-section"
};
const _hoisted_37$e = { class: "progress-bar" };
const _hoisted_38$e = { class: "progress-text" };
const _hoisted_39$e = {
  key: 2,
  class: "error-section"
};
const _hoisted_40$d = { class: "dialog-footer" };
const _hoisted_41$b = ["disabled"];
const _hoisted_42$a = ["disabled"];
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "DecomposeDialog",
  emits: ["close", "decomposed"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const modelStatus = ref(null);
    const sourceType = ref("layer");
    const selectedLayerId = ref("");
    const uploadedImage = ref(null);
    const fileInput = ref(null);
    const numLayers = ref(4);
    const guidanceScale = ref(3);
    const numInferenceSteps = ref(50);
    const seed = ref(void 0);
    const showAdvanced = ref(false);
    const groupIntoComp = ref(true);
    const semanticLabels = ref(true);
    const autoUnload = ref(true);
    const isProcessing = ref(false);
    const progressMessage = ref("");
    const progressIndeterminate = ref(false);
    const errorMessage = ref("");
    const imageLayers = computed(() => {
      const layers = store.getActiveCompLayers();
      return layers.filter((l) => l.type === "image" || l.type === "solid");
    });
    const hasImageLayers = computed(() => imageLayers.value.length > 0);
    const statusClass = computed(() => {
      if (!modelStatus.value) return "checking";
      if (modelStatus.value.error) return "error";
      if (modelStatus.value.loading) return "loading";
      if (modelStatus.value.loaded) return "ready";
      if (modelStatus.value.downloaded) return "downloaded";
      return "not-downloaded";
    });
    const statusIcon = computed(() => {
      switch (statusClass.value) {
        case "ready":
          return "pi pi-check-circle";
        case "downloaded":
          return "pi pi-download";
        case "loading":
          return "pi pi-spin pi-spinner";
        case "checking":
          return "pi pi-spin pi-spinner";
        case "error":
          return "pi pi-exclamation-circle";
        default:
          return "pi pi-cloud-download";
      }
    });
    const statusText = computed(() => {
      if (!modelStatus.value) return "Checking model status...";
      if (modelStatus.value.error) return `Error: ${modelStatus.value.error}`;
      if (modelStatus.value.loading) return "Loading model...";
      if (modelStatus.value.loaded) return "Model ready";
      if (modelStatus.value.downloaded) return "Model downloaded (not loaded)";
      return "Model not downloaded";
    });
    const canDecompose = computed(() => {
      if (!modelStatus.value) return false;
      if (sourceType.value === "layer" && !selectedLayerId.value) return false;
      if (sourceType.value === "upload" && !uploadedImage.value) return false;
      return true;
    });
    const buttonText = computed(() => {
      if (!modelStatus.value) return "Checking...";
      if (isProcessing.value) {
        if (!modelStatus.value.downloaded) return "Downloading...";
        if (!modelStatus.value.loaded) return "Loading...";
        return "Decomposing...";
      }
      if (!modelStatus.value.downloaded) return "Download & Decompose";
      if (!modelStatus.value.loaded) return "Load & Decompose";
      return "Decompose Image";
    });
    function triggerUpload() {
      fileInput.value?.click();
    }
    function handleFileSelect(event) {
      const input = event.target;
      const file = input.files?.[0];
      if (file) {
        loadImageFile(file);
      }
    }
    function handleDrop(event) {
      const file = event.dataTransfer?.files[0];
      if (file && file.type.startsWith("image/")) {
        loadImageFile(file);
      }
    }
    function loadImageFile(file) {
      const reader = new FileReader();
      reader.onload = () => {
        uploadedImage.value = reader.result;
      };
      reader.readAsDataURL(file);
    }
    async function getSourceImage() {
      if (sourceType.value === "upload") {
        return uploadedImage.value;
      }
      const layer = imageLayers.value.find((l) => l.id === selectedLayerId.value);
      if (!layer) return null;
      if (layer.type === "image" && layer.data) {
        const source = layer.data.source || layer.data.url || layer.data.assetId;
        if (source) {
          if (source.startsWith("data:")) {
            return source;
          }
          return await loadImageAsDataUrl(source);
        }
      }
      if (layer.type === "solid" && layer.data) {
        const canvas = document.createElement("canvas");
        canvas.width = layer.data.width || store.width;
        canvas.height = layer.data.height || store.height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = layer.data.color || "#808080";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return canvas.toDataURL("image/png");
      }
      return null;
    }
    async function loadImageAsDataUrl(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          resolve(canvas.toDataURL("image/png"));
        };
        img.onerror = () => reject(new Error("Failed to load image"));
        img.src = url;
      });
    }
    async function createLayersFromDecomposition(decomposedLayers) {
      const comp = store.getActiveComp();
      if (!comp) return;
      if (groupIntoComp.value) {
        const nestedCompName = `Decomposed (${decomposedLayers.length} layers)`;
        const nestedComp = store.createComposition(nestedCompName, {
          width: comp.settings.width,
          height: comp.settings.height,
          frameCount: comp.settings.frameCount,
          fps: comp.settings.fps,
          backgroundColor: "#00000000"
          // Transparent
        });
        const originalCompId = comp.id;
        store.setActiveComposition(nestedComp.id);
        for (let i = decomposedLayers.length - 1; i >= 0; i--) {
          const decomposed = decomposedLayers[i];
          const layer = store.createLayer("image", decomposed.label);
          if (layer.data) {
            layer.data.source = decomposed.image;
          }
        }
        store.setActiveComposition(originalCompId);
        const nestedLayer = store.createLayer("nestedComp", nestedCompName);
        if (nestedLayer.data) {
          nestedLayer.data.compositionId = nestedComp.id;
        }
      } else {
        for (let i = decomposedLayers.length - 1; i >= 0; i--) {
          const decomposed = decomposedLayers[i];
          const layer = store.createLayer("image", decomposed.label);
          if (layer.data) {
            layer.data.source = decomposed.image;
          }
        }
      }
      store.pushHistory();
    }
    async function startDecomposition() {
      if (!canDecompose.value || isProcessing.value) return;
      isProcessing.value = true;
      errorMessage.value = "";
      progressIndeterminate.value = true;
      try {
        const service = getLayerDecompositionService();
        progressMessage.value = "Preparing source image...";
        const sourceImage = await getSourceImage();
        if (!sourceImage) {
          throw new Error("Failed to get source image");
        }
        const layers = await service.decomposeWithAutoSetup(
          sourceImage,
          {
            numLayers: numLayers.value,
            guidanceScale: guidanceScale.value,
            numInferenceSteps: numInferenceSteps.value,
            seed: seed.value,
            autoUnload: autoUnload.value,
            generateSemanticLabels: semanticLabels.value
          },
          (stage, message) => {
            progressMessage.value = message;
            progressIndeterminate.value = stage !== "decomposing";
            if (stage === "downloading" || stage === "loading" || stage === "cleanup") {
              checkModelStatus();
            }
          }
        );
        progressMessage.value = "Creating layers...";
        await createLayersFromDecomposition(layers);
        emit("decomposed", layers);
        emit("close");
      } catch (err) {
        errorMessage.value = err instanceof Error ? err.message : "Decomposition failed";
        console.error("[DecomposeDialog] Error:", err);
      } finally {
        isProcessing.value = false;
        progressIndeterminate.value = false;
      }
    }
    async function checkModelStatus() {
      try {
        const service = getLayerDecompositionService();
        modelStatus.value = await service.getStatus();
      } catch (err) {
        console.error("[DecomposeDialog] Failed to get model status:", err);
        modelStatus.value = {
          downloaded: false,
          loaded: false,
          loading: false,
          error: "Failed to connect to backend",
          model_path: "",
          model_size_gb: 28.8
        };
      }
    }
    watch(hasImageLayers, (has) => {
      if (has && !selectedLayerId.value) {
        selectedLayerId.value = imageLayers.value[0]?.id || "";
      }
    }, { immediate: true });
    onMounted(() => {
      checkModelStatus();
      if (!hasImageLayers.value) {
        sourceType.value = "upload";
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "decompose-dialog-overlay",
        onClick: _cache[14] || (_cache[14] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$L, [
          createBaseVNode("div", _hoisted_2$K, [
            _cache[16] || (_cache[16] = createBaseVNode("h3", null, "AI Layer Decomposition", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close")),
              disabled: isProcessing.value
            }, [..._cache[15] || (_cache[15] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])], 8, _hoisted_3$I)
          ]),
          createBaseVNode("div", _hoisted_4$H, [
            createBaseVNode("div", _hoisted_5$H, [
              createBaseVNode("div", {
                class: normalizeClass(["status-indicator", statusClass.value])
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(statusIcon.value)
                }, null, 2),
                createBaseVNode("span", null, toDisplayString(statusText.value), 1)
              ], 2),
              modelStatus.value && !modelStatus.value.downloaded ? (openBlock(), createElementBlock("div", _hoisted_6$H, [
                createBaseVNode("small", null, "Model size: " + toDisplayString(modelStatus.value.model_size_gb) + "GB", 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_7$H, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Source Image", -1)),
              createBaseVNode("div", _hoisted_8$G, [
                createBaseVNode("button", {
                  class: normalizeClass(["source-btn", { active: sourceType.value === "layer" }]),
                  onClick: _cache[1] || (_cache[1] = ($event) => sourceType.value = "layer"),
                  disabled: !hasImageLayers.value
                }, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-images" }, null, -1),
                  createBaseVNode("span", null, "From Layer", -1)
                ])], 10, _hoisted_9$G),
                createBaseVNode("button", {
                  class: normalizeClass(["source-btn", { active: sourceType.value === "upload" }]),
                  onClick: _cache[2] || (_cache[2] = ($event) => sourceType.value = "upload")
                }, [..._cache[18] || (_cache[18] = [
                  createBaseVNode("i", { class: "pi pi-upload" }, null, -1),
                  createBaseVNode("span", null, "Upload", -1)
                ])], 2)
              ]),
              sourceType.value === "layer" ? (openBlock(), createElementBlock("div", _hoisted_10$G, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedLayerId.value = $event),
                  disabled: isProcessing.value
                }, [
                  _cache[19] || (_cache[19] = createBaseVNode("option", { value: "" }, "Select a layer...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_12$D);
                  }), 128))
                ], 8, _hoisted_11$F), [
                  [vModelSelect, selectedLayerId.value]
                ])
              ])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "upload-area",
                onClick: triggerUpload,
                onDrop: withModifiers(handleDrop, ["prevent"]),
                onDragover: _cache[4] || (_cache[4] = withModifiers(() => {
                }, ["prevent"]))
              }, [
                createBaseVNode("input", {
                  ref_key: "fileInput",
                  ref: fileInput,
                  type: "file",
                  accept: "image/*",
                  onChange: handleFileSelect,
                  style: { "display": "none" }
                }, null, 544),
                !uploadedImage.value ? (openBlock(), createElementBlock("div", _hoisted_13$D, [..._cache[20] || (_cache[20] = [
                  createBaseVNode("i", { class: "pi pi-cloud-upload" }, null, -1),
                  createBaseVNode("span", null, "Click or drop image here", -1)
                ])])) : (openBlock(), createElementBlock("img", {
                  key: 1,
                  src: uploadedImage.value,
                  class: "upload-preview",
                  alt: "Uploaded image"
                }, null, 8, _hoisted_14$A))
              ], 32))
            ]),
            createBaseVNode("div", _hoisted_15$z, [
              _cache[22] || (_cache[22] = createBaseVNode("label", null, "Number of Layers", -1)),
              createBaseVNode("div", _hoisted_16$y, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => numLayers.value = $event),
                  type: "range",
                  min: "3",
                  max: "16",
                  step: "1",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_17$x), [
                  [
                    vModelText,
                    numLayers.value,
                    void 0,
                    { number: true }
                  ]
                ]),
                createBaseVNode("span", _hoisted_18$w, toDisplayString(numLayers.value), 1)
              ]),
              _cache[23] || (_cache[23] = createBaseVNode("small", { class: "param-hint" }, "More layers = finer separation (3-16)", -1))
            ]),
            createBaseVNode("div", _hoisted_19$w, [
              _cache[30] || (_cache[30] = createBaseVNode("label", null, "Organization", -1)),
              createBaseVNode("div", _hoisted_20$w, [
                createBaseVNode("label", _hoisted_21$v, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => groupIntoComp.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_22$u), [
                    [vModelCheckbox, groupIntoComp.value]
                  ]),
                  _cache[24] || (_cache[24] = createBaseVNode("span", null, "Group into nested composition", -1))
                ]),
                _cache[25] || (_cache[25] = createBaseVNode("small", null, "Keeps layers organized, reduces clutter", -1))
              ]),
              createBaseVNode("div", _hoisted_23$t, [
                createBaseVNode("label", _hoisted_24$q, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => semanticLabels.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_25$p), [
                    [vModelCheckbox, semanticLabels.value]
                  ]),
                  _cache[26] || (_cache[26] = createBaseVNode("span", null, "Generate semantic labels", -1))
                ]),
                _cache[27] || (_cache[27] = createBaseVNode("small", null, "AI-friendly names based on content analysis", -1))
              ]),
              createBaseVNode("div", _hoisted_26$o, [
                createBaseVNode("label", _hoisted_27$m, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => autoUnload.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_28$m), [
                    [vModelCheckbox, autoUnload.value]
                  ]),
                  _cache[28] || (_cache[28] = createBaseVNode("span", null, "Free GPU memory after", -1))
                ]),
                _cache[29] || (_cache[29] = createBaseVNode("small", null, "Recommended for complex projects", -1))
              ])
            ]),
            showAdvanced.value ? (openBlock(), createElementBlock("div", _hoisted_29$m, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Advanced Settings", -1)),
              createBaseVNode("div", _hoisted_30$l, [
                _cache[31] || (_cache[31] = createBaseVNode("span", null, "Guidance Scale", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => guidanceScale.value = $event),
                  type: "number",
                  min: "1",
                  max: "10",
                  step: "0.5",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_31$h), [
                  [
                    vModelText,
                    guidanceScale.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_32$h, [
                _cache[32] || (_cache[32] = createBaseVNode("span", null, "Inference Steps", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => numInferenceSteps.value = $event),
                  type: "number",
                  min: "20",
                  max: "100",
                  step: "10",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_33$h), [
                  [
                    vModelText,
                    numInferenceSteps.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ]),
              createBaseVNode("div", _hoisted_34$g, [
                _cache[33] || (_cache[33] = createBaseVNode("span", null, "Seed (optional)", -1)),
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => seed.value = $event),
                  type: "number",
                  min: "0",
                  placeholder: "Random",
                  disabled: isProcessing.value
                }, null, 8, _hoisted_35$f), [
                  [
                    vModelText,
                    seed.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: "advanced-toggle",
              onClick: _cache[12] || (_cache[12] = ($event) => showAdvanced.value = !showAdvanced.value)
            }, [
              createBaseVNode("i", {
                class: normalizeClass(showAdvanced.value ? "pi pi-chevron-up" : "pi pi-chevron-down")
              }, null, 2),
              createTextVNode(" " + toDisplayString(showAdvanced.value ? "Hide" : "Show") + " Advanced Settings ", 1)
            ]),
            isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_36$e, [
              createBaseVNode("div", _hoisted_37$e, [
                createBaseVNode("div", {
                  class: normalizeClass(["progress-fill", { indeterminate: progressIndeterminate.value }])
                }, null, 2)
              ]),
              createBaseVNode("p", _hoisted_38$e, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true),
            errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_39$e, [
              _cache[35] || (_cache[35] = createBaseVNode("i", { class: "pi pi-exclamation-triangle" }, null, -1)),
              createBaseVNode("span", null, toDisplayString(errorMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_40$d, [
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[13] || (_cache[13] = ($event) => emit("close")),
              disabled: isProcessing.value
            }, " Cancel ", 8, _hoisted_41$b),
            createBaseVNode("button", {
              class: "decompose-btn",
              onClick: startDecomposition,
              disabled: !canDecompose.value || isProcessing.value
            }, [
              _cache[36] || (_cache[36] = createBaseVNode("i", { class: "pi pi-sparkles" }, null, -1)),
              createTextVNode(" " + toDisplayString(buttonText.value), 1)
            ], 8, _hoisted_42$a)
          ])
        ])
      ]);
    };
  }
});

const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const DecomposeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__scopeId", "data-v-7dd86d9c"]]);

const logger$4 = createLogger("Vectorize");
const STARVECTOR_ALLOCATION_ID = "model:starvector-1b";
const DEFAULT_VTRACE_OPTIONS = {
  mode: "spline",
  colorMode: "color",
  hierarchical: "stacked",
  filterSpeckle: 4,
  colorPrecision: 6,
  layerDifference: 16,
  cornerThreshold: 60,
  lengthThreshold: 4,
  maxIterations: 10,
  spliceThreshold: 45,
  pathPrecision: 3
};
const DEFAULT_STARVECTOR_OPTIONS = {
  maxLength: 4e3
};
class VectorizeService {
  baseUrl;
  constructor(serverAddress) {
    const client = getComfyUIClient(serverAddress);
    this.baseUrl = `http://${client.server}`;
  }
  /**
   * Get vectorization service status
   */
  async getStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/status`);
      const result = await response.json();
      if (result.status === "success") {
        return result.data;
      }
      throw new Error(result.message || "Failed to get status");
    } catch (error) {
      logger$4.error("Failed to get vectorize status:", error);
      throw error;
    }
  }
  /**
   * Trace an image to vector paths using VTracer (fast, any image type)
   *
   * @param imageDataUrl - Image as data URL (data:image/...;base64,...)
   * @param options - Tracing options
   * @returns Array of vector paths with control points
   */
  async trace(imageDataUrl, options = {}) {
    const opts = { ...DEFAULT_VTRACE_OPTIONS, ...options };
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/trace`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          mode: opts.mode,
          color_mode: opts.colorMode,
          hierarchical: opts.hierarchical,
          filter_speckle: opts.filterSpeckle,
          color_precision: opts.colorPrecision,
          layer_difference: opts.layerDifference,
          corner_threshold: opts.cornerThreshold,
          length_threshold: opts.lengthThreshold,
          max_iterations: opts.maxIterations,
          splice_threshold: opts.spliceThreshold,
          path_precision: opts.pathPrecision
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$4.info(`Traced image: ${result.pathCount} paths`);
      return result;
    } catch (error) {
      logger$4.error("Image tracing failed:", error);
      throw error;
    }
  }
  /**
   * Vectorize an icon/logo using StarVector AI
   * Note: Only works for simple graphics, not photos
   *
   * @param imageDataUrl - Image as data URL
   * @param options - StarVector options
   */
  async vectorizeWithAI(imageDataUrl, options = {}) {
    const opts = { ...DEFAULT_STARVECTOR_OPTIONS, ...options };
    const memCheck = canAllocate(VRAM_ESTIMATES["model:starvector"] || 2500);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory for StarVector");
    }
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/ai`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image: imageDataUrl,
          max_length: opts.maxLength
        })
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      logger$4.info(`AI vectorized: ${result.pathCount} paths`);
      return result;
    } catch (error) {
      logger$4.error("AI vectorization failed:", error);
      throw error;
    }
  }
  /**
   * Download and load StarVector model
   */
  async loadStarVectorModel(onProgress) {
    const memCheck = canAllocate(VRAM_ESTIMATES["model:starvector"] || 2500);
    if (!memCheck.canProceed) {
      throw new Error(memCheck.warning?.message || "Insufficient GPU memory");
    }
    try {
      onProgress?.("downloading", "Downloading StarVector model (~2.5GB)...");
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/download-starvector`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      registerAllocation(
        STARVECTOR_ALLOCATION_ID,
        "StarVector 1B Model",
        "model",
        VRAM_ESTIMATES["model:starvector"] || 2500,
        {
          canUnload: true,
          unloadFn: () => this.unloadStarVectorModel()
        }
      );
      onProgress?.("complete", "StarVector model loaded");
      logger$4.info("StarVector model loaded");
    } catch (error) {
      logger$4.error("Failed to load StarVector:", error);
      throw error;
    }
  }
  /**
   * Unload StarVector model to free GPU memory
   */
  async unloadStarVectorModel() {
    try {
      const response = await fetch(`${this.baseUrl}/weyl/vectorize/unload-starvector`, {
        method: "POST"
      });
      const result = await response.json();
      if (result.status === "error") {
        throw new Error(result.message);
      }
      unregisterAllocation(STARVECTOR_ALLOCATION_ID);
      logger$4.info("StarVector model unloaded");
    } catch (error) {
      logger$4.error("Failed to unload StarVector:", error);
      throw error;
    }
  }
  /**
   * One-click vectorization with automatic mode selection
   *
   * For icons/logos (simple graphics): Uses StarVector AI
   * For photos/complex images: Uses VTracer
   *
   * @param imageDataUrl - Image to vectorize
   * @param options - Options (mode can be 'auto', 'trace', or 'ai')
   * @param onProgress - Progress callback
   */
  async vectorize(imageDataUrl, options = {}, onProgress) {
    const mode = options.mode ?? "trace";
    if (mode === "ai") {
      onProgress?.("checking", "Checking StarVector model...");
      const status = await this.getStatus();
      if (!status.starvector.loaded) {
        if (!status.starvector.downloaded) {
          onProgress?.("downloading", "Downloading StarVector model...");
        }
        await this.loadStarVectorModel(onProgress);
      }
      onProgress?.("vectorizing", "Running AI vectorization...");
      return await this.vectorizeWithAI(imageDataUrl, options.aiOptions);
    }
    onProgress?.("tracing", "Tracing image to vectors...");
    return await this.trace(imageDataUrl, options.traceOptions);
  }
}
let defaultService = null;
function getVectorizeService(serverAddress) {
  if (!defaultService) {
    defaultService = new VectorizeService(serverAddress);
  }
  return defaultService;
}
function normalizeControlPoints(paths, options = {}) {
  const { groupByPath = false, prefix = "vec" } = options;
  return paths.map((path, pathIdx) => {
    const groupId = groupByPath ? `${prefix}_path_${pathIdx}` : void 0;
    return {
      ...path,
      controlPoints: path.controlPoints.map((cp, cpIdx) => ({
        ...cp,
        id: cp.id || `${prefix}_${pathIdx}_${cpIdx}`,
        group: groupId,
        // Ensure handles are in correct format (absolute positions)
        handleIn: cp.handleIn ? { x: cp.handleIn.x, y: cp.handleIn.y } : null,
        handleOut: cp.handleOut ? { x: cp.handleOut.x, y: cp.handleOut.y } : null
      }))
    };
  });
}
function filterSmallPaths(paths, minPoints = 3) {
  return paths.filter((path) => path.controlPoints.length >= minPoints);
}
function autoGroupPoints(controlPoints, options = {}) {
  const { method = "quadrant", gridSize = 100, numGroups = 4 } = options;
  if (controlPoints.length === 0) return [];
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const cp of controlPoints) {
    minX = Math.min(minX, cp.x);
    minY = Math.min(minY, cp.y);
    maxX = Math.max(maxX, cp.x);
    maxY = Math.max(maxY, cp.y);
  }
  const width = maxX - minX || 1;
  const height = maxY - minY || 1;
  return controlPoints.map((cp) => {
    let group;
    switch (method) {
      case "grid": {
        const gridX = Math.floor((cp.x - minX) / gridSize);
        const gridY = Math.floor((cp.y - minY) / gridSize);
        group = `grid_${gridX}_${gridY}`;
        break;
      }
      case "quadrant": {
        const normX = (cp.x - minX) / width;
        const normY = (cp.y - minY) / height;
        if (normX < 0.5 && normY < 0.5) group = "top_left";
        else if (normX >= 0.5 && normY < 0.5) group = "top_right";
        else if (normX < 0.5 && normY >= 0.5) group = "bottom_left";
        else group = "bottom_right";
        break;
      }
      case "proximity":
      default: {
        const normX = (cp.x - minX) / width;
        const groupIdx = Math.floor(normX * numGroups) % numGroups;
        group = `region_${groupIdx}`;
        break;
      }
    }
    return { ...cp, group };
  });
}
if (typeof VRAM_ESTIMATES === "object") {
  VRAM_ESTIMATES["model:starvector"] = 2500;
}

const _hoisted_1$K = { class: "vectorize-dialog" };
const _hoisted_2$J = { class: "section" };
const _hoisted_3$H = { class: "source-options" };
const _hoisted_4$G = { class: "option-group" };
const _hoisted_5$G = ["disabled"];
const _hoisted_6$G = ["disabled"];
const _hoisted_7$G = ["value"];
const _hoisted_8$F = { class: "option-group" };
const _hoisted_9$F = ["disabled"];
const _hoisted_10$F = ["disabled"];
const _hoisted_11$E = {
  key: 0,
  class: "preview-container"
};
const _hoisted_12$C = ["src"];
const _hoisted_13$C = { class: "preview-size" };
const _hoisted_14$z = { class: "section" };
const _hoisted_15$y = { class: "mode-options" };
const _hoisted_16$x = ["disabled"];
const _hoisted_17$w = ["disabled"];
const _hoisted_18$v = { class: "mode-info" };
const _hoisted_19$v = {
  key: 0,
  class: "mode-warning"
};
const _hoisted_20$v = {
  key: 0,
  class: "section options-section"
};
const _hoisted_21$u = { class: "options-grid" };
const _hoisted_22$t = { class: "option-row" };
const _hoisted_23$s = ["disabled"];
const _hoisted_24$p = { class: "option-row" };
const _hoisted_25$o = ["disabled"];
const _hoisted_26$n = { class: "value" };
const _hoisted_27$l = { class: "option-row" };
const _hoisted_28$l = ["disabled"];
const _hoisted_29$l = { class: "value" };
const _hoisted_30$k = { class: "option-row" };
const _hoisted_31$g = ["disabled"];
const _hoisted_32$g = { class: "value" };
const _hoisted_33$g = { class: "option-row" };
const _hoisted_34$f = ["disabled"];
const _hoisted_35$e = { class: "value" };
const _hoisted_36$d = { class: "section" };
const _hoisted_37$d = { class: "output-options" };
const _hoisted_38$d = ["disabled"];
const _hoisted_39$d = ["disabled"];
const _hoisted_40$c = ["disabled"];
const _hoisted_41$a = ["disabled"];
const _hoisted_42$9 = {
  key: 1,
  class: "progress-section"
};
const _hoisted_43$9 = { class: "progress-bar" };
const _hoisted_44$9 = { class: "progress-text" };
const _hoisted_45$9 = {
  key: 2,
  class: "result-section"
};
const _hoisted_46$9 = { class: "result-header" };
const _hoisted_47$9 = { class: "result-count" };
const _hoisted_48$9 = ["innerHTML"];
const _hoisted_49$9 = {
  key: 3,
  class: "error-message"
};
const _hoisted_50$8 = { class: "dialog-footer" };
const _hoisted_51$8 = ["disabled"];
const _hoisted_52$8 = ["disabled"];
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "VectorizeDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "created"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const vectorizeService = getVectorizeService();
    const sourceType = ref("layer");
    const selectedLayerId = ref("");
    const uploadedImage = ref(null);
    const fileInput = ref(null);
    const previewUrl = ref(null);
    const previewWidth = ref(0);
    const previewHeight = ref(0);
    const mode = ref("trace");
    const starVectorAvailable = ref(false);
    const traceOptions = ref({ ...DEFAULT_VTRACE_OPTIONS });
    const createSeparateLayers = ref(true);
    const groupByPath = ref(true);
    const autoGroupByRegion = ref(false);
    const enableAnimation = ref(true);
    const isProcessing = ref(false);
    const progressPercent = ref(0);
    const progressMessage = ref("");
    const result = ref(null);
    const showSvgPreview = ref(false);
    const errorMessage = ref("");
    const availableLayers = computed(() => {
      return store.layers.filter(
        (l) => l.type === "image" || l.type === "video" || l.type === "solid"
      );
    });
    const canVectorize = computed(() => {
      if (sourceType.value === "layer") {
        return !!selectedLayerId.value;
      }
      return !!uploadedImage.value;
    });
    const sanitizedSvg = computed(() => {
      if (!result.value?.svg) return "";
      return result.value.svg.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/on\w+="[^"]*"/gi, "").replace(/on\w+='[^']*'/gi, "");
    });
    watch([sourceType, selectedLayerId], async () => {
      if (sourceType.value === "layer" && selectedLayerId.value) {
        await loadLayerPreview();
      }
    });
    onMounted(async () => {
      try {
        const status = await vectorizeService.getStatus();
        starVectorAvailable.value = status.starvector.available || status.starvector.downloaded;
      } catch {
        starVectorAvailable.value = false;
      }
    });
    async function loadLayerPreview() {
      const layer = store.layers.find((l) => l.id === selectedLayerId.value);
      if (!layer) return;
      try {
        const layerData = layer.data;
        if (layerData?.source) {
          previewUrl.value = layerData.source;
        } else if (layerData?.assetId) {
          const asset = store.project?.assets[layerData.assetId];
          if (asset?.data) {
            previewUrl.value = asset.data;
          }
        }
        if (previewUrl.value) {
          const img = new Image();
          img.onload = () => {
            previewWidth.value = img.naturalWidth;
            previewHeight.value = img.naturalHeight;
          };
          img.src = previewUrl.value;
        }
      } catch (error) {
        console.error("Failed to load layer preview:", error);
      }
    }
    function onFileSelect(event) {
      const input = event.target;
      const file = input.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedImage.value = e.target?.result;
        previewUrl.value = uploadedImage.value;
        const img = new Image();
        img.onload = () => {
          previewWidth.value = img.naturalWidth;
          previewHeight.value = img.naturalHeight;
        };
        img.src = uploadedImage.value;
      };
      reader.readAsDataURL(file);
    }
    async function startVectorize() {
      errorMessage.value = "";
      result.value = null;
      isProcessing.value = true;
      progressPercent.value = 0;
      try {
        let imageDataUrl;
        if (sourceType.value === "layer") {
          const layer = store.layers.find((l) => l.id === selectedLayerId.value);
          if (!layer) throw new Error("Layer not found");
          const layerData = layer.data;
          if (layerData?.source) {
            imageDataUrl = layerData.source;
          } else if (layerData?.assetId) {
            const asset = store.project?.assets[layerData.assetId];
            if (!asset?.data) throw new Error("Asset data not found");
            imageDataUrl = asset.data;
          } else {
            throw new Error("Could not get image data from layer");
          }
        } else {
          if (!uploadedImage.value) throw new Error("No image uploaded");
          imageDataUrl = uploadedImage.value;
        }
        progressMessage.value = "Vectorizing image...";
        progressPercent.value = 30;
        result.value = await vectorizeService.vectorize(
          imageDataUrl,
          {
            mode: mode.value,
            traceOptions: traceOptions.value
          },
          (stage, message) => {
            progressMessage.value = message;
            if (stage === "downloading") progressPercent.value = 20;
            else if (stage === "tracing" || stage === "vectorizing") progressPercent.value = 60;
            else if (stage === "complete") progressPercent.value = 100;
          }
        );
        progressPercent.value = 100;
        progressMessage.value = `Found ${result.value.pathCount} paths`;
      } catch (error) {
        errorMessage.value = error instanceof Error ? error.message : "Vectorization failed";
      } finally {
        isProcessing.value = false;
      }
    }
    function createLayers() {
      if (!result.value) return;
      const createdLayerIds = [];
      let paths = filterSmallPaths(result.value.paths, 2);
      paths = normalizeControlPoints(paths, {
        groupByPath: groupByPath.value,
        prefix: "vec"
      });
      if (createSeparateLayers.value) {
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          let controlPoints = path.controlPoints;
          if (autoGroupByRegion.value) {
            controlPoints = autoGroupPoints(controlPoints, { method: "quadrant" });
          }
          const layer = store.createSplineLayer();
          store.renameLayer(layer.id, `Vector Path ${i + 1}`);
          store.updateLayerData(layer.id, {
            controlPoints,
            closed: path.closed,
            stroke: path.stroke || "#00ff00",
            strokeWidth: 2,
            fill: path.fill || "",
            animated: enableAnimation.value
          });
          createdLayerIds.push(layer.id);
        }
      } else {
        const allPoints = [];
        let pointIdx = 0;
        for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
          const path = paths[pathIdx];
          for (const cp of path.controlPoints) {
            allPoints.push({
              ...cp,
              id: `vec_${pointIdx++}`,
              group: `path_${pathIdx}`
            });
          }
        }
        let controlPoints = allPoints;
        if (autoGroupByRegion.value) {
          controlPoints = autoGroupPoints(allPoints, { method: "quadrant" });
        }
        const layer = store.createSplineLayer();
        store.renameLayer(layer.id, "Vectorized Paths");
        store.updateLayerData(layer.id, {
          controlPoints,
          closed: false,
          stroke: "#00ff00",
          strokeWidth: 2,
          fill: "",
          animated: enableAnimation.value
        });
        createdLayerIds.push(layer.id);
      }
      emit("created", createdLayerIds);
      emit("close");
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script), {
        visible: __props.visible,
        modal: "",
        header: "Vectorize Image",
        style: { width: "700px" },
        closable: !isProcessing.value,
        "onUpdate:visible": _cache[16] || (_cache[16] = ($event) => _ctx.$emit("close"))
      }, {
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_50$8, [
            createBaseVNode("button", {
              class: "btn-secondary",
              onClick: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("close")),
              disabled: isProcessing.value
            }, " Cancel ", 8, _hoisted_51$8),
            createBaseVNode("button", {
              class: "btn-primary",
              onClick: startVectorize,
              disabled: !canVectorize.value || isProcessing.value
            }, toDisplayString(isProcessing.value ? "Processing..." : "Vectorize"), 9, _hoisted_52$8),
            result.value && !isProcessing.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "btn-success",
              onClick: createLayers
            }, " Create Layers (" + toDisplayString(result.value.pathCount) + ") ", 1)) : createCommentVNode("", true)
          ])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$K, [
            createBaseVNode("div", _hoisted_2$J, [
              _cache[20] || (_cache[20] = createBaseVNode("h4", null, "Source", -1)),
              createBaseVNode("div", _hoisted_3$H, [
                createBaseVNode("div", _hoisted_4$G, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "radio",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => sourceType.value = $event),
                      value: "layer",
                      disabled: isProcessing.value || !availableLayers.value.length
                    }, null, 8, _hoisted_5$G), [
                      [vModelRadio, sourceType.value]
                    ]),
                    _cache[17] || (_cache[17] = createTextVNode(" From Layer ", -1))
                  ]),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedLayerId.value = $event),
                    disabled: sourceType.value !== "layer" || isProcessing.value,
                    class: "layer-select"
                  }, [
                    _cache[18] || (_cache[18] = createBaseVNode("option", { value: "" }, "Select a layer...", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(availableLayers.value, (layer) => {
                      return openBlock(), createElementBlock("option", {
                        key: layer.id,
                        value: layer.id
                      }, toDisplayString(layer.name), 9, _hoisted_7$G);
                    }), 128))
                  ], 8, _hoisted_6$G), [
                    [vModelSelect, selectedLayerId.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_8$F, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "radio",
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => sourceType.value = $event),
                      value: "upload",
                      disabled: isProcessing.value
                    }, null, 8, _hoisted_9$F), [
                      [vModelRadio, sourceType.value]
                    ]),
                    _cache[19] || (_cache[19] = createTextVNode(" Upload Image ", -1))
                  ]),
                  createBaseVNode("input", {
                    ref_key: "fileInput",
                    ref: fileInput,
                    type: "file",
                    accept: "image/*",
                    onChange: onFileSelect,
                    disabled: sourceType.value !== "upload" || isProcessing.value,
                    class: "file-input"
                  }, null, 40, _hoisted_10$F)
                ])
              ]),
              previewUrl.value ? (openBlock(), createElementBlock("div", _hoisted_11$E, [
                createBaseVNode("img", {
                  src: previewUrl.value,
                  alt: "Source preview",
                  class: "preview-image"
                }, null, 8, _hoisted_12$C),
                createBaseVNode("span", _hoisted_13$C, toDisplayString(previewWidth.value) + " x " + toDisplayString(previewHeight.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_14$z, [
              _cache[24] || (_cache[24] = createBaseVNode("h4", null, "Vectorization Mode", -1)),
              createBaseVNode("div", _hoisted_15$y, [
                createBaseVNode("label", {
                  class: normalizeClass(["mode-option", { selected: mode.value === "trace" }])
                }, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => mode.value = $event),
                    value: "trace",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_16$x), [
                    [vModelRadio, mode.value]
                  ]),
                  _cache[21] || (_cache[21] = createBaseVNode("div", { class: "mode-info" }, [
                    createBaseVNode("span", { class: "mode-title" }, "VTracer (Fast)"),
                    createBaseVNode("span", { class: "mode-desc" }, "Works with any image. Fast tracing to bezier curves.")
                  ], -1))
                ], 2),
                createBaseVNode("label", {
                  class: normalizeClass(["mode-option", { selected: mode.value === "ai" }])
                }, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => mode.value = $event),
                    value: "ai",
                    disabled: isProcessing.value || !starVectorAvailable.value
                  }, null, 8, _hoisted_17$w), [
                    [vModelRadio, mode.value]
                  ]),
                  createBaseVNode("div", _hoisted_18$v, [
                    _cache[22] || (_cache[22] = createBaseVNode("span", { class: "mode-title" }, "StarVector AI", -1)),
                    _cache[23] || (_cache[23] = createBaseVNode("span", { class: "mode-desc" }, "Best for icons/logos. Requires ~2.5GB VRAM.", -1)),
                    !starVectorAvailable.value ? (openBlock(), createElementBlock("span", _hoisted_19$v, "Model not available")) : createCommentVNode("", true)
                  ])
                ], 2)
              ])
            ]),
            mode.value === "trace" ? (openBlock(), createElementBlock("div", _hoisted_20$v, [
              _cache[31] || (_cache[31] = createBaseVNode("h4", null, "Tracing Options", -1)),
              createBaseVNode("div", _hoisted_21$u, [
                createBaseVNode("div", _hoisted_22$t, [
                  _cache[26] || (_cache[26] = createBaseVNode("label", null, "Color Mode", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => traceOptions.value.colorMode = $event),
                    disabled: isProcessing.value
                  }, [..._cache[25] || (_cache[25] = [
                    createBaseVNode("option", { value: "color" }, "Color", -1),
                    createBaseVNode("option", { value: "binary" }, "Black & White", -1)
                  ])], 8, _hoisted_23$s), [
                    [vModelSelect, traceOptions.value.colorMode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$p, [
                  _cache[27] || (_cache[27] = createBaseVNode("label", null, "Filter Speckle", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => traceOptions.value.filterSpeckle = $event),
                    min: "0",
                    max: "100",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_25$o), [
                    [
                      vModelText,
                      traceOptions.value.filterSpeckle,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_26$n, toDisplayString(traceOptions.value.filterSpeckle), 1)
                ]),
                createBaseVNode("div", _hoisted_27$l, [
                  _cache[28] || (_cache[28] = createBaseVNode("label", null, "Corner Threshold", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => traceOptions.value.cornerThreshold = $event),
                    min: "0",
                    max: "180",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_28$l), [
                    [
                      vModelText,
                      traceOptions.value.cornerThreshold,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_29$l, toDisplayString(traceOptions.value.cornerThreshold) + "", 1)
                ]),
                createBaseVNode("div", _hoisted_30$k, [
                  _cache[29] || (_cache[29] = createBaseVNode("label", null, "Color Precision", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => traceOptions.value.colorPrecision = $event),
                    min: "1",
                    max: "10",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_31$g), [
                    [
                      vModelText,
                      traceOptions.value.colorPrecision,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_32$g, toDisplayString(traceOptions.value.colorPrecision), 1)
                ]),
                createBaseVNode("div", _hoisted_33$g, [
                  _cache[30] || (_cache[30] = createBaseVNode("label", null, "Layer Difference", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "range",
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => traceOptions.value.layerDifference = $event),
                    min: "1",
                    max: "256",
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_34$f), [
                    [
                      vModelText,
                      traceOptions.value.layerDifference,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  createBaseVNode("span", _hoisted_35$e, toDisplayString(traceOptions.value.layerDifference), 1)
                ])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_36$d, [
              _cache[36] || (_cache[36] = createBaseVNode("h4", null, "Output Options", -1)),
              createBaseVNode("div", _hoisted_37$d, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => createSeparateLayers.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_38$d), [
                    [vModelCheckbox, createSeparateLayers.value]
                  ]),
                  _cache[32] || (_cache[32] = createTextVNode(" Create separate layer for each path ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => groupByPath.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_39$d), [
                    [vModelCheckbox, groupByPath.value]
                  ]),
                  _cache[33] || (_cache[33] = createTextVNode(" Assign group IDs to control points (for group animation) ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => autoGroupByRegion.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_40$c), [
                    [vModelCheckbox, autoGroupByRegion.value]
                  ]),
                  _cache[34] || (_cache[34] = createTextVNode(" Auto-group points by region (quadrants) ", -1))
                ]),
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => enableAnimation.value = $event),
                    disabled: isProcessing.value
                  }, null, 8, _hoisted_41$a), [
                    [vModelCheckbox, enableAnimation.value]
                  ]),
                  _cache[35] || (_cache[35] = createTextVNode(" Enable keyframe animation on created layers ", -1))
                ])
              ])
            ]),
            isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_42$9, [
              createBaseVNode("div", _hoisted_43$9, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: progressPercent.value + "%" })
                }, null, 4)
              ]),
              createBaseVNode("span", _hoisted_44$9, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true),
            result.value && !isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_45$9, [
              createBaseVNode("div", _hoisted_46$9, [
                createBaseVNode("span", _hoisted_47$9, toDisplayString(result.value.pathCount) + " paths found", 1),
                createBaseVNode("button", {
                  class: "preview-svg-btn",
                  onClick: _cache[14] || (_cache[14] = ($event) => showSvgPreview.value = !showSvgPreview.value)
                }, toDisplayString(showSvgPreview.value ? "Hide" : "Show") + " SVG Preview ", 1)
              ]),
              showSvgPreview.value && result.value.svg ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "svg-preview",
                innerHTML: sanitizedSvg.value
              }, null, 8, _hoisted_48$9)) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_49$9, toDisplayString(errorMessage.value), 1)) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }, 8, ["visible", "closable"]);
    };
  }
});

const VectorizeDialog = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__scopeId", "data-v-bdfd2d6e"]]);

const DEFAULT_OPTIONS = {
  includeStrokes: true,
  includeFills: true,
  precision: 3,
  viewBox: { x: 0, y: 0, width: 1920, height: 1080 },
  includeTransforms: true,
  includeMetadata: true,
  minify: false
};
class SVGExportService {
  options;
  constructor(options) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }
  exportSplineLayer(layer, options) {
    const opts = { ...this.options, ...options };
    const warnings = [];
    if (layer.type !== "spline" || !layer.data) {
      warnings.push("Layer is not a spline layer");
      return { svg: "", width: 0, height: 0, pathCount: 0, warnings };
    }
    const splineData = layer.data;
    const pathData = this.controlPointsToPathData(
      splineData.controlPoints,
      splineData.closed ?? false,
      opts.precision
    );
    const strokeAttr = opts.includeStrokes ? 'stroke="' + (splineData.strokeColor || "#000") + '" stroke-width="' + (splineData.strokeWidth || 1) + '"' : 'stroke="none"';
    const fillAttr = opts.includeFills ? 'fill="' + (splineData.fillColor || "none") + '"' : 'fill="none"';
    let transformAttr = "";
    if (opts.includeTransforms && layer.transform) {
      transformAttr = this.buildTransformAttribute(layer);
    }
    const bounds = this.calculateBounds(splineData.controlPoints);
    const viewBox = opts.viewBox || {
      x: bounds.minX - 10,
      y: bounds.minY - 10,
      width: bounds.maxX - bounds.minX + 20,
      height: bounds.maxY - bounds.minY + 20
    };
    const nl = opts.minify ? "" : "\n";
    const ind = opts.minify ? "" : "  ";
    let svg = '<?xml version="1.0" encoding="UTF-8"?>' + nl;
    svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
    svg += 'viewBox="' + viewBox.x + " " + viewBox.y + " " + viewBox.width + " " + viewBox.height + '" ';
    svg += 'width="' + viewBox.width + '" height="' + viewBox.height + '">' + nl;
    if (opts.includeMetadata) {
      svg += ind + "<!-- Exported from Weyl Compositor -->" + nl;
    }
    const trAttr = transformAttr ? ' transform="' + transformAttr + '"' : "";
    svg += ind + '<path d="' + pathData + '" ' + strokeAttr + " " + fillAttr + trAttr + "/>" + nl;
    svg += "</svg>";
    return { svg, width: viewBox.width, height: viewBox.height, pathCount: 1, warnings };
  }
  exportComposition(composition, layers, options) {
    const opts = { ...this.options, ...options };
    const warnings = [];
    const width = composition.settings.width;
    const height = composition.settings.height;
    const viewBox = opts.viewBox || { x: 0, y: 0, width, height };
    const nl = opts.minify ? "" : "\n";
    const ind = opts.minify ? "" : "  ";
    let svg = '<?xml version="1.0" encoding="UTF-8"?>' + nl;
    svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
    svg += 'viewBox="' + viewBox.x + " " + viewBox.y + " " + viewBox.width + " " + viewBox.height + '" ';
    svg += 'width="' + width + '" height="' + height + '">' + nl;
    let pathCount = 0;
    for (const layer of layers) {
      if (layer.type !== "spline" || !layer.data) continue;
      const splineData = layer.data;
      const pathData = this.controlPointsToPathData(
        splineData.controlPoints,
        splineData.closed ?? false,
        opts.precision
      );
      const strokeAttr = opts.includeStrokes ? 'stroke="' + (splineData.strokeColor || "#000") + '" stroke-width="' + (splineData.strokeWidth || 1) + '"' : 'stroke="none"';
      const fillAttr = opts.includeFills ? 'fill="' + (splineData.fillColor || "none") + '"' : 'fill="none"';
      let transformAttr = "";
      if (opts.includeTransforms && layer.transform) {
        transformAttr = this.buildTransformAttribute(layer);
      }
      const trAttr = transformAttr ? ' transform="' + transformAttr + '"' : "";
      svg += ind + '<g id="' + this.sanitizeId(layer.id) + '">' + nl;
      svg += ind + ind + '<path d="' + pathData + '" ' + strokeAttr + " " + fillAttr + trAttr + "/>" + nl;
      svg += ind + "</g>" + nl;
      pathCount++;
    }
    svg += "</svg>";
    return { svg, width, height, pathCount, warnings };
  }
  controlPointsToPathData(points, closed, precision = 3) {
    if (points.length === 0) return "";
    const fmt = (n) => n.toFixed(precision).replace(/.?0+$/, "");
    let d = "M" + fmt(points[0].x) + "," + fmt(points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const curr = points[i];
      const next = points[i + 1];
      const cp1 = curr.handleOut || { x: curr.x, y: curr.y };
      const cp2 = next.handleIn || { x: next.x, y: next.y };
      const isLine = Math.abs(cp1.x - curr.x) < 0.01 && Math.abs(cp1.y - curr.y) < 0.01 && Math.abs(cp2.x - next.x) < 0.01 && Math.abs(cp2.y - next.y) < 0.01;
      if (isLine) {
        d += " L" + fmt(next.x) + "," + fmt(next.y);
      } else {
        d += " C" + fmt(cp1.x) + "," + fmt(cp1.y) + " " + fmt(cp2.x) + "," + fmt(cp2.y) + " " + fmt(next.x) + "," + fmt(next.y);
      }
    }
    if (closed && points.length > 1) {
      d += " Z";
    }
    return d;
  }
  buildTransformAttribute(layer) {
    const transforms = [];
    const t = layer.transform;
    if (!t) return "";
    const pos = t.position?.value;
    if (pos && (pos.x || pos.y)) {
      transforms.push("translate(" + (pos.x || 0) + "," + (pos.y || 0) + ")");
    }
    const rot = t.rotation?.value;
    if (rot) {
      transforms.push("rotate(" + rot + ")");
    }
    const scale = t.scale?.value;
    if (scale && (scale.x !== 100 || scale.y !== 100)) {
      transforms.push("scale(" + (scale.x || 100) / 100 + "," + (scale.y || 100) / 100 + ")");
    }
    return transforms.join(" ");
  }
  calculateBounds(points) {
    if (points.length === 0) return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of points) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    return { minX, minY, maxX, maxY };
  }
  sanitizeId(id) {
    return id.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
}
const svgExportService = new SVGExportService();
function exportSplineLayer(layer, options) {
  return svgExportService.exportSplineLayer(layer, options).svg;
}
function exportLayers(layers, options) {
  const composition = {
    settings: {
      width: options?.viewBox?.width ?? 1920,
      height: options?.viewBox?.height ?? 1080
    }
  };
  return svgExportService.exportComposition(composition, layers, options).svg;
}

const _hoisted_1$J = { class: "project-panel" };
const _hoisted_2$I = { class: "panel-header" };
const _hoisted_3$G = { class: "header-actions" };
const _hoisted_4$F = { class: "dropdown-container" };
const _hoisted_5$F = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_6$F = ["disabled"];
const _hoisted_7$F = ["disabled"];
const _hoisted_8$E = { class: "dropdown-container" };
const _hoisted_9$E = {
  key: 0,
  class: "dropdown-menu"
};
const _hoisted_10$E = {
  key: 1,
  class: "search-bar"
};
const _hoisted_11$D = { class: "panel-content" };
const _hoisted_12$B = { class: "folder-tree" };
const _hoisted_13$B = ["onClick", "onDblclick"];
const _hoisted_14$y = ["onClick"];
const _hoisted_15$x = { class: "folder-name" };
const _hoisted_16$w = { class: "item-count" };
const _hoisted_17$v = {
  key: 0,
  class: "folder-contents"
};
const _hoisted_18$u = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_19$u = { class: "item-icon" };
const _hoisted_20$u = { class: "item-name" };
const _hoisted_21$t = { class: "item-info" };
const _hoisted_22$s = ["onClick", "onDblclick", "onDragstart"];
const _hoisted_23$r = { class: "item-icon" };
const _hoisted_24$o = { class: "item-name" };
const _hoisted_25$n = { class: "item-info" };
const _hoisted_26$m = {
  key: 0,
  class: "empty-state"
};
const _hoisted_27$k = {
  key: 2,
  class: "panel-footer"
};
const _hoisted_28$k = { class: "item-details" };
const _hoisted_29$k = { class: "detail-label" };
const _hoisted_30$j = { class: "detail-info" };
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectionStore = useSelectionStore();
    const fileInputRef = ref(null);
    const showSearch = ref(false);
    const showNewMenu = ref(false);
    const showExportMenu = ref(false);
    const showDecomposeDialog = ref(false);
    const showVectorizeDialog = ref(false);
    const searchQuery = ref("");
    const selectedItem = ref(null);
    const expandedFolders = ref(["compositions", "footage"]);
    const hasSelectedSplineLayer = computed(() => {
      const selectedLayerIds = selectionStore.selectedLayerIds;
      if (selectedLayerIds.length === 0) return false;
      const layers = store.getActiveCompLayers();
      const selectedLayer = layers.find((l) => l.id === selectedLayerIds[0]);
      return selectedLayer?.type === "spline";
    });
    const folders = computed(() => {
      const compositions = Object.values(store.project.compositions || {}).map((comp) => ({
        id: comp.id,
        name: comp.name,
        type: "composition",
        width: comp.settings.width,
        height: comp.settings.height,
        fps: comp.settings.fps,
        duration: comp.settings.frameCount
      }));
      return [
        {
          id: "compositions",
          name: "Compositions",
          items: compositions.length > 0 ? compositions : [{
            id: "comp-main",
            name: store.activeComposition?.name || "Main Comp",
            type: "composition",
            width: store.width,
            height: store.height,
            fps: store.fps,
            duration: store.frameCount
          }]
        },
        {
          id: "footage",
          name: "Footage",
          items: []
        },
        {
          id: "solids",
          name: "Solids",
          items: []
        }
      ];
    });
    const items = ref([]);
    const filteredFolders = computed(() => {
      if (!searchQuery.value) return folders.value;
      const query = searchQuery.value.toLowerCase();
      return folders.value.map((folder) => ({
        ...folder,
        items: folder.items.filter(
          (item) => item.name.toLowerCase().includes(query)
        )
      })).filter((folder) => folder.items.length > 0 || folder.name.toLowerCase().includes(query));
    });
    const filteredRootItems = computed(() => {
      if (!searchQuery.value) return items.value;
      const query = searchQuery.value.toLowerCase();
      return items.value.filter(
        (item) => item.name.toLowerCase().includes(query)
      );
    });
    const selectedItemDetails = computed(() => {
      if (!selectedItem.value) return null;
      for (const folder of folders.value) {
        const item2 = folder.items.find((i) => i.id === selectedItem.value);
        if (item2) {
          return {
            name: item2.name,
            info: getItemInfo(item2)
          };
        }
      }
      const item = items.value.find((i) => i.id === selectedItem.value);
      if (item) {
        return {
          name: item.name,
          info: getItemInfo(item)
        };
      }
      return null;
    });
    function toggleFolder(folderId) {
      const index = expandedFolders.value.indexOf(folderId);
      if (index >= 0) {
        expandedFolders.value.splice(index, 1);
      } else {
        expandedFolders.value.push(folderId);
      }
    }
    function selectItem(itemId) {
      selectedItem.value = itemId;
    }
    function openItem(item) {
      if (item.type === "composition") {
        console.log("Opening composition:", item.name);
      }
    }
    function createNewComposition() {
      showNewMenu.value = false;
      emit("openCompositionSettings");
    }
    function createNewSolid() {
      showNewMenu.value = false;
      const layer = store.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", layer.id);
    }
    function createNewText() {
      showNewMenu.value = false;
      const layer = store.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", layer.id);
    }
    function createNewControl() {
      showNewMenu.value = false;
      const layer = store.createLayer("control", "Control");
      console.log("[ProjectPanel] Created control layer:", layer.id);
    }
    function createNewSpline() {
      showNewMenu.value = false;
      const layer = store.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", layer.id);
    }
    function createNewModel() {
      showNewMenu.value = false;
      const layer = store.createLayer("model", "3D Model");
      console.log("[ProjectPanel] Created model layer:", layer.id);
    }
    function createNewPointCloud() {
      showNewMenu.value = false;
      const layer = store.createLayer("pointcloud", "Point Cloud");
      console.log("[ProjectPanel] Created point cloud layer:", layer.id);
    }
    function openDecomposeDialog() {
      showNewMenu.value = false;
      showDecomposeDialog.value = true;
    }
    function openVectorizeDialog() {
      showNewMenu.value = false;
      showVectorizeDialog.value = true;
    }
    function onDecomposed(layers) {
      console.log("[ProjectPanel] Image decomposed into", layers.length, "layers");
    }
    function onVectorized(layerIds) {
      console.log("[ProjectPanel] Created", layerIds.length, "vectorized layers");
    }
    function getSelectedSplineLayer() {
      const selectedLayerIds = selectionStore.selectedLayerIds;
      if (selectedLayerIds.length === 0) return null;
      const layers = store.getActiveCompLayers();
      const layer = layers.find((l) => l.id === selectedLayerIds[0]);
      return layer?.type === "spline" ? layer : null;
    }
    function exportSelectedLayerSVG() {
      showExportMenu.value = false;
      const layer = getSelectedSplineLayer();
      if (!layer) {
        console.warn("[ProjectPanel] No spline layer selected");
        return;
      }
      try {
        const svg = exportSplineLayer(layer);
        navigator.clipboard.writeText(svg).then(() => {
          console.log("[ProjectPanel] SVG copied to clipboard");
        }).catch((err) => {
          console.error("[ProjectPanel] Failed to copy SVG:", err);
        });
      } catch (error) {
        console.error("[ProjectPanel] Failed to export SVG:", error);
      }
    }
    function exportCompositionSVG() {
      showExportMenu.value = false;
      const comp = store.activeComposition;
      if (!comp) {
        console.warn("[ProjectPanel] No active composition");
        return;
      }
      try {
        const svg = exportLayers(comp.layers, {
          viewBox: { x: 0, y: 0, width: comp.settings.width, height: comp.settings.height }
        });
        navigator.clipboard.writeText(svg).then(() => {
          console.log("[ProjectPanel] Composition SVG copied to clipboard");
        }).catch((err) => {
          console.error("[ProjectPanel] Failed to copy SVG:", err);
        });
      } catch (error) {
        console.error("[ProjectPanel] Failed to export composition SVG:", error);
      }
    }
    function downloadSVG(svgContent, filename) {
      const blob = new Blob([svgContent], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    function exportSelectedLayerSVGDownload() {
      showExportMenu.value = false;
      const layer = getSelectedSplineLayer();
      if (!layer) {
        console.warn("[ProjectPanel] No spline layer selected");
        return;
      }
      try {
        const svg = exportSplineLayer(layer);
        const filename = `${layer.name.replace(/[^a-z0-9]/gi, "_")}.svg`;
        downloadSVG(svg, filename);
        console.log("[ProjectPanel] SVG downloaded:", filename);
      } catch (error) {
        console.error("[ProjectPanel] Failed to export SVG:", error);
      }
    }
    function exportCompositionSVGDownload() {
      showExportMenu.value = false;
      const comp = store.activeComposition;
      if (!comp) {
        console.warn("[ProjectPanel] No active composition");
        return;
      }
      try {
        const svg = exportLayers(comp.layers, {
          viewBox: { x: 0, y: 0, width: comp.settings.width, height: comp.settings.height }
        });
        const filename = `${comp.name.replace(/[^a-z0-9]/gi, "_")}.svg`;
        downloadSVG(svg, filename);
        console.log("[ProjectPanel] Composition SVG downloaded:", filename);
      } catch (error) {
        console.error("[ProjectPanel] Failed to export composition SVG:", error);
      }
    }
    function triggerFileImport() {
      fileInputRef.value?.click();
    }
    async function handleFileImport(event) {
      const input = event.target;
      const files = input.files;
      if (!files || files.length === 0) return;
      for (const file of Array.from(files)) {
        const type = getFileType(file);
        const newItem = {
          id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          name: file.name,
          type
        };
        if (type === "audio") {
          store.loadAudio(file);
        } else if (file.type.startsWith("video/")) {
          try {
            const layer = await store.createVideoLayer(file, true);
            newItem.id = layer.id;
            newItem.width = store.width;
            newItem.height = store.height;
            newItem.duration = store.frameCount;
            newItem.fps = store.fps;
            console.log("[ProjectPanel] Video layer created:", layer.id, layer.name);
          } catch (error) {
            console.error("[ProjectPanel] Failed to import video:", error);
            continue;
          }
        } else if (file.type.startsWith("image/")) {
          const imageUrl = URL.createObjectURL(file);
          const assetId = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          store.project.assets[assetId] = {
            id: assetId,
            type: "image",
            source: "file",
            width: 0,
            // Will be updated when image loads
            height: 0,
            data: imageUrl
          };
          const layer = store.createLayer("image", file.name.replace(/\.[^.]+$/, ""));
          layer.data = { assetId };
          newItem.id = layer.id;
        }
        const folder = folders.value.find((f) => f.id === "footage");
        if (folder) {
          folder.items.push(newItem);
        } else {
          items.value.push(newItem);
        }
        console.log("[ProjectPanel] Imported:", file.name, type);
      }
      input.value = "";
    }
    function getFileType(file) {
      const mime = file.type;
      if (mime.startsWith("audio/")) return "audio";
      if (mime.startsWith("video/")) return "footage";
      if (mime.startsWith("image/")) return "footage";
      return "footage";
    }
    function getItemIcon(type) {
      const icons = {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      };
      return icons[type] || "";
    }
    function getItemInfo(item) {
      if (item.type === "composition" || item.type === "footage") {
        const parts = [];
        if (item.width && item.height) {
          parts.push(`${item.width}${item.height}`);
        }
        if (item.fps) {
          parts.push(`${item.fps}fps`);
        }
        if (item.duration) {
          const seconds = item.duration / (item.fps || 30);
          parts.push(`${seconds.toFixed(1)}s`);
        }
        return parts.join("  ");
      }
      return "";
    }
    function onDragStart(item, event) {
      event.dataTransfer?.setData("application/project-item", JSON.stringify(item));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        createBaseVNode("div", _hoisted_2$I, [
          _cache[8] || (_cache[8] = createBaseVNode("span", { class: "panel-title" }, "Project", -1)),
          createBaseVNode("div", _hoisted_3$G, [
            createBaseVNode("button", {
              onClick: triggerFileImport,
              title: "Import File (Ctrl+I)"
            }, ""),
            createBaseVNode("div", _hoisted_4$F, [
              createBaseVNode("button", {
                onClick: _cache[0] || (_cache[0] = ($event) => showExportMenu.value = !showExportMenu.value),
                title: "Export"
              }, ""),
              showExportMenu.value ? (openBlock(), createElementBlock("div", _hoisted_5$F, [
                createBaseVNode("button", {
                  onClick: exportSelectedLayerSVG,
                  disabled: !hasSelectedSplineLayer.value
                }, "  Export Selected Layer as SVG ", 8, _hoisted_6$F),
                createBaseVNode("button", { onClick: exportCompositionSVG }, "  Export Composition as SVG "),
                _cache[6] || (_cache[6] = createBaseVNode("hr", { class: "menu-divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: exportSelectedLayerSVGDownload,
                  disabled: !hasSelectedSplineLayer.value
                }, "  Download Selected as SVG ", 8, _hoisted_7$F),
                createBaseVNode("button", { onClick: exportCompositionSVGDownload }, "  Download Composition as SVG ")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_8$E, [
              createBaseVNode("button", {
                onClick: _cache[1] || (_cache[1] = ($event) => showNewMenu.value = !showNewMenu.value),
                title: "New Item"
              }, "+"),
              showNewMenu.value ? (openBlock(), createElementBlock("div", _hoisted_9$E, [
                createBaseVNode("button", { onClick: createNewComposition }, " New Composition"),
                createBaseVNode("button", { onClick: createNewSolid }, " New Solid"),
                createBaseVNode("button", { onClick: createNewText }, "T New Text"),
                createBaseVNode("button", { onClick: createNewControl }, " New Control"),
                createBaseVNode("button", { onClick: createNewSpline }, " New Spline"),
                createBaseVNode("button", { onClick: createNewModel }, " New 3D Model"),
                createBaseVNode("button", { onClick: createNewPointCloud }, " New Point Cloud"),
                _cache[7] || (_cache[7] = createBaseVNode("hr", { class: "menu-divider" }, null, -1)),
                createBaseVNode("button", { onClick: openDecomposeDialog }, " AI Layer Decompose"),
                createBaseVNode("button", { onClick: openVectorizeDialog }, " Vectorize Image")
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => showSearch.value = !showSearch.value),
              title: "Search"
            }, "")
          ])
        ]),
        showDecomposeDialog.value ? (openBlock(), createBlock(DecomposeDialog, {
          key: 0,
          onClose: _cache[3] || (_cache[3] = ($event) => showDecomposeDialog.value = false),
          onDecomposed
        })) : createCommentVNode("", true),
        createVNode(VectorizeDialog, {
          visible: showVectorizeDialog.value,
          onClose: _cache[4] || (_cache[4] = ($event) => showVectorizeDialog.value = false),
          onCreated: onVectorized
        }, null, 8, ["visible"]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          multiple: "",
          accept: "image/*,video/*,audio/*,.json",
          style: { "display": "none" },
          onChange: handleFileImport
        }, null, 544),
        showSearch.value ? (openBlock(), createElementBlock("div", _hoisted_10$E, [
          withDirectives(createBaseVNode("input", {
            type: "text",
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => searchQuery.value = $event),
            placeholder: "Search project...",
            class: "search-input"
          }, null, 512), [
            [vModelText, searchQuery.value]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_11$D, [
          createBaseVNode("div", _hoisted_12$B, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredFolders.value, (folder) => {
              return openBlock(), createElementBlock("div", {
                key: folder.id,
                class: "folder-item"
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["folder-header", { selected: selectedItem.value === folder.id }]),
                  onClick: ($event) => selectItem(folder.id),
                  onDblclick: ($event) => toggleFolder(folder.id)
                }, [
                  createBaseVNode("span", {
                    class: "expand-icon",
                    onClick: withModifiers(($event) => toggleFolder(folder.id), ["stop"])
                  }, toDisplayString(expandedFolders.value.includes(folder.id) ? "" : ""), 9, _hoisted_14$y),
                  _cache[9] || (_cache[9] = createBaseVNode("span", { class: "folder-icon" }, "", -1)),
                  createBaseVNode("span", _hoisted_15$x, toDisplayString(folder.name), 1),
                  createBaseVNode("span", _hoisted_16$w, toDisplayString(folder.items.length), 1)
                ], 42, _hoisted_13$B),
                expandedFolders.value.includes(folder.id) ? (openBlock(), createElementBlock("div", _hoisted_17$v, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(folder.items, (item) => {
                    return openBlock(), createElementBlock("div", {
                      key: item.id,
                      class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                      onClick: ($event) => selectItem(item.id),
                      onDblclick: ($event) => openItem(item),
                      draggable: "true",
                      onDragstart: ($event) => onDragStart(item, $event)
                    }, [
                      createBaseVNode("span", _hoisted_19$u, toDisplayString(getItemIcon(item.type)), 1),
                      createBaseVNode("span", _hoisted_20$u, toDisplayString(item.name), 1),
                      createBaseVNode("span", _hoisted_21$t, toDisplayString(getItemInfo(item)), 1)
                    ], 42, _hoisted_18$u);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredRootItems.value, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.id,
                class: normalizeClass(["project-item", { selected: selectedItem.value === item.id }]),
                onClick: ($event) => selectItem(item.id),
                onDblclick: ($event) => openItem(item),
                draggable: "true",
                onDragstart: ($event) => onDragStart(item, $event)
              }, [
                createBaseVNode("span", _hoisted_23$r, toDisplayString(getItemIcon(item.type)), 1),
                createBaseVNode("span", _hoisted_24$o, toDisplayString(item.name), 1),
                createBaseVNode("span", _hoisted_25$n, toDisplayString(getItemInfo(item)), 1)
              ], 42, _hoisted_22$s);
            }), 128))
          ]),
          items.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_26$m, [..._cache[10] || (_cache[10] = [
            createBaseVNode("p", null, "No items in project", -1),
            createBaseVNode("p", { class: "hint" }, "Import footage or create compositions", -1)
          ])])) : createCommentVNode("", true)
        ]),
        selectedItemDetails.value ? (openBlock(), createElementBlock("div", _hoisted_27$k, [
          createBaseVNode("div", _hoisted_28$k, [
            createBaseVNode("span", _hoisted_29$k, toDisplayString(selectedItemDetails.value.name), 1),
            createBaseVNode("span", _hoisted_30$j, toDisplayString(selectedItemDetails.value.info), 1)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const ProjectPanel = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__scopeId", "data-v-b1624679"]]);

const _hoisted_1$I = {
  class: "effects-panel",
  role: "region",
  "aria-label": "Effects and Presets"
};
const _hoisted_2$H = { class: "panel-header" };
const _hoisted_3$F = { class: "header-actions" };
const _hoisted_4$E = { class: "panel-content" };
const _hoisted_5$E = {
  class: "tabs",
  role: "tablist",
  "aria-label": "Effects panel tabs"
};
const _hoisted_6$E = ["aria-selected"];
const _hoisted_7$E = ["aria-selected"];
const _hoisted_8$D = ["aria-selected"];
const _hoisted_9$D = {
  key: 0,
  class: "effects-list",
  id: "effects-tab-panel",
  role: "tabpanel",
  "aria-label": "Effects list"
};
const _hoisted_10$D = ["onClick"];
const _hoisted_11$C = { class: "expand-icon" };
const _hoisted_12$A = { class: "category-icon" };
const _hoisted_13$A = { class: "category-name" };
const _hoisted_14$x = { class: "effect-count" };
const _hoisted_15$w = {
  key: 0,
  class: "category-effects"
};
const _hoisted_16$v = ["onDblclick", "onDragstart"];
const _hoisted_17$u = { class: "effect-name" };
const _hoisted_18$t = ["onClick", "title", "aria-label", "aria-pressed"];
const _hoisted_19$t = { "aria-hidden": "true" };
const _hoisted_20$t = {
  key: 1,
  class: "presets-list"
};
const _hoisted_21$s = ["onClick"];
const _hoisted_22$r = { class: "expand-icon" };
const _hoisted_23$q = { class: "category-name" };
const _hoisted_24$n = { class: "preset-count" };
const _hoisted_25$m = {
  key: 0,
  class: "category-presets"
};
const _hoisted_26$l = ["onDblclick", "onDragstart"];
const _hoisted_27$j = { class: "preset-info" };
const _hoisted_28$j = { class: "preset-name" };
const _hoisted_29$j = { class: "preset-description" };
const _hoisted_30$i = {
  key: 2,
  class: "favorites-list"
};
const _hoisted_31$f = {
  key: 0,
  class: "empty-favorites"
};
const _hoisted_32$f = ["onDblclick", "onDragstart"];
const _hoisted_33$f = { class: "category-badge" };
const _hoisted_34$e = { class: "effect-name" };
const _hoisted_35$d = ["onClick"];
const STORAGE_VERSION = 1;
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "EffectsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const activeTab = ref("effects");
    const searchQuery = ref("");
    const expandedCategories = ref(["blur-sharpen", "color-correction"]);
    const expandedPresetCategories = ref(["Fade", "Scale"]);
    const favorites = ref([]);
    const STORAGE_KEY = "effect-favorites-v" + STORAGE_VERSION;
    onMounted(() => {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed) && parsed.every((item) => typeof item === "string")) {
            favorites.value = parsed;
          } else {
            favorites.value = [];
          }
        } catch {
          favorites.value = [];
        }
      }
    });
    function saveFavorites() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(favorites.value));
    }
    const allEffects = computed(() => {
      return Object.entries(EFFECT_DEFINITIONS).map(([key, def]) => ({
        key,
        name: def.name,
        category: def.category,
        description: def.description
      }));
    });
    const filteredCategories = computed(() => {
      const query = searchQuery.value.toLowerCase();
      return Object.entries(EFFECT_CATEGORIES).map(([key, cat]) => {
        const effects = allEffects.value.filter((e) => {
          if (e.category !== key) return false;
          if (query && !e.name.toLowerCase().includes(query)) return false;
          return true;
        });
        return {
          key,
          label: cat.label,
          icon: cat.icon,
          effects
        };
      }).filter((cat) => cat.effects.length > 0);
    });
    const groupedPresets = computed(() => {
      const query = searchQuery.value.toLowerCase();
      const groups = {};
      for (const preset of ANIMATION_PRESETS) {
        if (query && !preset.name.toLowerCase().includes(query)) continue;
        if (!groups[preset.category]) {
          groups[preset.category] = [];
        }
        groups[preset.category].push(preset);
      }
      return Object.entries(groups).map(([category, presets]) => ({
        category,
        presets
      }));
    });
    const favoriteEffects = computed(() => {
      return allEffects.value.filter((e) => favorites.value.includes(e.key));
    });
    function toggleCategory(category) {
      const index = expandedCategories.value.indexOf(category);
      if (index >= 0) {
        expandedCategories.value.splice(index, 1);
      } else {
        expandedCategories.value.push(category);
      }
    }
    function togglePresetCategory(category) {
      const index = expandedPresetCategories.value.indexOf(category);
      if (index >= 0) {
        expandedPresetCategories.value.splice(index, 1);
      } else {
        expandedPresetCategories.value.push(category);
      }
    }
    function toggleFavorite(effectKey) {
      const index = favorites.value.indexOf(effectKey);
      if (index >= 0) {
        favorites.value.splice(index, 1);
      } else {
        favorites.value.push(effectKey);
      }
      saveFavorites();
    }
    function getCategoryIcon(category) {
      return EFFECT_CATEGORIES[category]?.icon || "?";
    }
    function applyEffect(effectKey) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) {
        console.warn("No layer selected to apply effect");
        return;
      }
      store.addEffectToLayer(selectedLayer.id, effectKey);
    }
    function applyPreset(preset) {
      const selectedLayer = store.selectedLayer;
      if (!selectedLayer) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const startFrame = selectedLayer.inPoint;
      const endFrame = selectedLayer.outPoint;
      const duration = endFrame - startFrame;
      for (const propDef of preset.keyframes) {
        for (const kf of propDef.keyframes) {
          const frame = Math.round(startFrame + kf.time * duration);
          store.addKeyframe(selectedLayer.id, propDef.property, kf.value, frame);
        }
      }
    }
    function onDragStart(effectKey, event) {
      event.dataTransfer?.setData("application/effect", effectKey);
    }
    function onDragPreset(preset, event) {
      event.dataTransfer?.setData("application/preset", JSON.stringify(preset));
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$I, [
        createBaseVNode("div", _hoisted_2$H, [
          _cache[4] || (_cache[4] = createBaseVNode("span", {
            class: "panel-title",
            id: "effects-panel-title"
          }, "Effects & Presets", -1)),
          createBaseVNode("div", _hoisted_3$F, [
            withDirectives(createBaseVNode("input", {
              type: "text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
              placeholder: "Search...",
              class: "search-input",
              "aria-label": "Search effects and presets"
            }, null, 512), [
              [vModelText, searchQuery.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$E, [
          createBaseVNode("div", _hoisted_5$E, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "effects" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "effects"),
              role: "tab",
              "aria-selected": activeTab.value === "effects",
              "aria-controls": "effects-tab-panel"
            }, " Effects ", 10, _hoisted_6$E),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "presets" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "presets"),
              role: "tab",
              "aria-selected": activeTab.value === "presets",
              "aria-controls": "presets-tab-panel"
            }, " Presets ", 10, _hoisted_7$E),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "favorites" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "favorites"),
              role: "tab",
              "aria-selected": activeTab.value === "favorites",
              "aria-controls": "favorites-tab-panel"
            }, " Favorites ", 10, _hoisted_8$D)
          ]),
          activeTab.value === "effects" ? (openBlock(), createElementBlock("div", _hoisted_9$D, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filteredCategories.value, (category) => {
              return openBlock(), createElementBlock("div", {
                key: category.key,
                class: "effect-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => toggleCategory(category.key)
                }, [
                  createBaseVNode("span", _hoisted_11$C, toDisplayString(expandedCategories.value.includes(category.key) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_12$A, toDisplayString(category.icon), 1),
                  createBaseVNode("span", _hoisted_13$A, toDisplayString(category.label), 1),
                  createBaseVNode("span", _hoisted_14$x, toDisplayString(category.effects.length), 1)
                ], 8, _hoisted_10$D),
                expandedCategories.value.includes(category.key) ? (openBlock(), createElementBlock("div", _hoisted_15$w, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.effects, (effect) => {
                    return openBlock(), createElementBlock("div", {
                      key: effect.key,
                      class: normalizeClass(["effect-item", { favorite: favorites.value.includes(effect.key) }]),
                      onDblclick: ($event) => applyEffect(effect.key),
                      onDragstart: ($event) => onDragStart(effect.key, $event),
                      draggable: "true"
                    }, [
                      createBaseVNode("span", _hoisted_17$u, toDisplayString(effect.name), 1),
                      createBaseVNode("button", {
                        class: "favorite-btn",
                        onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"]),
                        title: favorites.value.includes(effect.key) ? "Remove from favorites" : "Add to favorites",
                        "aria-label": favorites.value.includes(effect.key) ? `Remove ${effect.name} from favorites` : `Add ${effect.name} to favorites`,
                        "aria-pressed": favorites.value.includes(effect.key)
                      }, [
                        createBaseVNode("span", _hoisted_19$t, toDisplayString(favorites.value.includes(effect.key) ? "" : ""), 1)
                      ], 8, _hoisted_18$t)
                    ], 42, _hoisted_16$v);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "presets" ? (openBlock(), createElementBlock("div", _hoisted_20$t, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedPresets.value, (group) => {
              return openBlock(), createElementBlock("div", {
                key: group.category,
                class: "preset-category"
              }, [
                createBaseVNode("div", {
                  class: "category-header",
                  onClick: ($event) => togglePresetCategory(group.category)
                }, [
                  createBaseVNode("span", _hoisted_22$r, toDisplayString(expandedPresetCategories.value.includes(group.category) ? "" : ""), 1),
                  createBaseVNode("span", _hoisted_23$q, toDisplayString(group.category), 1),
                  createBaseVNode("span", _hoisted_24$n, toDisplayString(group.presets.length), 1)
                ], 8, _hoisted_21$s),
                expandedPresetCategories.value.includes(group.category) ? (openBlock(), createElementBlock("div", _hoisted_25$m, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(group.presets, (preset) => {
                    return openBlock(), createElementBlock("div", {
                      key: preset.id,
                      class: "preset-item",
                      onDblclick: ($event) => applyPreset(preset),
                      onDragstart: ($event) => onDragPreset(preset, $event),
                      draggable: "true"
                    }, [
                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "preset-preview" }, [
                        createBaseVNode("span", { class: "preview-icon" }, "")
                      ], -1)),
                      createBaseVNode("div", _hoisted_27$j, [
                        createBaseVNode("span", _hoisted_28$j, toDisplayString(preset.name), 1),
                        createBaseVNode("span", _hoisted_29$j, toDisplayString(preset.description), 1)
                      ])
                    ], 40, _hoisted_26$l);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : activeTab.value === "favorites" ? (openBlock(), createElementBlock("div", _hoisted_30$i, [
            favoriteEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_31$f, [..._cache[6] || (_cache[6] = [
              createBaseVNode("p", null, "No favorites yet", -1),
              createBaseVNode("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
            ])])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(favoriteEffects.value, (effect) => {
              return openBlock(), createElementBlock("div", {
                key: effect.key,
                class: "effect-item",
                onDblclick: ($event) => applyEffect(effect.key),
                onDragstart: ($event) => onDragStart(effect.key, $event),
                draggable: "true"
              }, [
                createBaseVNode("span", _hoisted_33$f, toDisplayString(getCategoryIcon(effect.category)), 1),
                createBaseVNode("span", _hoisted_34$e, toDisplayString(effect.name), 1),
                createBaseVNode("button", {
                  class: "favorite-btn active",
                  onClick: withModifiers(($event) => toggleFavorite(effect.key), ["stop"])
                }, "  ", 8, _hoisted_35$d)
              ], 40, _hoisted_32$f);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        _cache[7] || (_cache[7] = createBaseVNode("div", { class: "panel-footer" }, [
          createBaseVNode("span", { class: "info-text" }, "Double-click or drag to apply")
        ], -1))
      ]);
    };
  }
});

const EffectsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__scopeId", "data-v-00012ead"]]);

const _hoisted_1$H = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$G = {
  key: 1,
  class: "scrub-unit"
};
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -Infinity },
    max: { default: Infinity },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const isScrubbing = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const defaultValue = computed(() => props.default ?? props.modelValue);
    const showReset = computed(() => props.default !== void 0);
    const displayValue = computed(() => {
      if (Number.isInteger(props.modelValue) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      let multiplier = props.sensitivity;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX * props.step * multiplier * 0.5;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onKeyDown(e) {
      if (props.disabled) return;
      let delta = 0;
      if (e.key === "ArrowUp") delta = props.step;
      else if (e.key === "ArrowDown") delta = -props.step;
      if (delta !== 0) {
        e.preventDefault();
        if (e.shiftKey) delta *= 10;
        if (e.ctrlKey || e.metaKey) delta *= 0.1;
        emit("update:modelValue", round(clamp(props.modelValue + delta)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    function reset() {
      if (props.default !== void 0) {
        emit("update:modelValue", props.default);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["scrubable-number", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["scrub-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("input", {
          type: "number",
          class: "scrub-input",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onKeydown: onKeyDown,
          onBlur
        }, null, 40, _hoisted_1$H),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$G, toDisplayString(__props.unit), 1)) : createCommentVNode("", true),
        showReset.value && __props.modelValue !== defaultValue.value ? (openBlock(), createElementBlock("button", {
          key: 2,
          class: "reset-btn",
          onClick: reset,
          title: "Reset to default"
        }, [..._cache[0] || (_cache[0] = [
          createBaseVNode("i", { class: "pi pi-refresh" }, null, -1)
        ])])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const ScrubableNumber = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__scopeId", "data-v-d5ac8d8c"]]);

const _hoisted_1$G = ["value", "min", "max", "step", "disabled"];
const _hoisted_2$F = {
  key: 2,
  class: "slider-unit"
};
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: true },
    gradient: {},
    disabled: { type: Boolean, default: false },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const trackRef = ref(null);
    const isScrubbing = ref(false);
    const isDragging = ref(false);
    const scrubStartX = ref(0);
    const scrubStartValue = ref(0);
    const fillPercent = computed(() => {
      const range = props.max - props.min;
      if (range === 0) return 0;
      return (props.modelValue - props.min) / range * 100;
    });
    const displayValue = computed(() => {
      if (Number.isInteger(props.step) && props.precision === 0) {
        return props.modelValue;
      }
      return Number(props.modelValue.toFixed(props.precision));
    });
    function clamp(value) {
      return Math.max(props.min, Math.min(props.max, value));
    }
    function round(value) {
      const factor = Math.pow(10, props.precision);
      return Math.round(value * factor) / factor;
    }
    function startScrub(e) {
      if (props.disabled) return;
      isScrubbing.value = true;
      scrubStartX.value = e.clientX;
      scrubStartValue.value = props.modelValue;
      document.addEventListener("mousemove", onScrubMove);
      document.addEventListener("mouseup", stopScrub);
      document.body.style.cursor = "ew-resize";
      document.body.style.userSelect = "none";
    }
    function onScrubMove(e) {
      const deltaX = e.clientX - scrubStartX.value;
      const range = props.max - props.min;
      let multiplier = 1;
      if (e.shiftKey) multiplier *= 10;
      if (e.ctrlKey || e.metaKey) multiplier *= 0.1;
      const deltaValue = deltaX / 200 * range * multiplier;
      const newValue = round(clamp(scrubStartValue.value + deltaValue));
      if (newValue !== props.modelValue) {
        emit("update:modelValue", newValue);
      }
    }
    function stopScrub() {
      isScrubbing.value = false;
      document.removeEventListener("mousemove", onScrubMove);
      document.removeEventListener("mouseup", stopScrub);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onTrackClick(e) {
      if (props.disabled || !trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + percent * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function startThumbDrag(_e) {
      if (props.disabled) return;
      isDragging.value = true;
      document.addEventListener("mousemove", onThumbDrag);
      document.addEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onThumbDrag(e) {
      if (!trackRef.value) return;
      const rect = trackRef.value.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      const value = props.min + Math.max(0, Math.min(1, percent)) * (props.max - props.min);
      emit("update:modelValue", round(clamp(value)));
    }
    function stopThumbDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onThumbDrag);
      document.removeEventListener("mouseup", stopThumbDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", round(clamp(value)));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slider-input", { disabled: __props.disabled }])
      }, [
        __props.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass(["slider-label", { scrubbing: isScrubbing.value }]),
          onMousedown: startScrub
        }, toDisplayString(__props.label), 35)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "slider-track",
          ref_key: "trackRef",
          ref: trackRef,
          onMousedown: onTrackClick
        }, [
          createBaseVNode("div", {
            class: "slider-fill",
            style: normalizeStyle({ width: fillPercent.value + "%", background: __props.gradient || void 0 })
          }, null, 4),
          createBaseVNode("div", {
            class: "slider-thumb",
            style: normalizeStyle({ left: fillPercent.value + "%" }),
            onMousedown: withModifiers(startThumbDrag, ["stop"])
          }, null, 36)
        ], 544),
        __props.showValue ? (openBlock(), createElementBlock("input", {
          key: 1,
          type: "number",
          class: "slider-value",
          value: displayValue.value,
          min: __props.min,
          max: __props.max,
          step: __props.step,
          disabled: __props.disabled,
          onInput,
          onBlur
        }, null, 40, _hoisted_1$G)) : createCommentVNode("", true),
        __props.unit ? (openBlock(), createElementBlock("span", _hoisted_2$F, toDisplayString(__props.unit), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const SliderInput = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__scopeId", "data-v-f02d596e"]]);

const _hoisted_1$F = { class: "dial-marks" };
const _hoisted_2$E = {
  key: 0,
  class: "angle-value"
};
const _hoisted_3$E = ["value", "disabled"];
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const dialRef = ref(null);
    const isDragging = ref(false);
    const displayValue = computed(() => {
      return Math.round(props.modelValue * 10) / 10;
    });
    function normalizeAngle(angle) {
      return (angle % 360 + 360) % 360;
    }
    function startDrag(e) {
      if (props.disabled) return;
      isDragging.value = true;
      updateAngle(e);
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      updateAngle(e);
    }
    function updateAngle(e) {
      if (!dialRef.value) return;
      const rect = dialRef.value.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      let angle = Math.atan2(deltaX, -deltaY) * (180 / Math.PI);
      angle = normalizeAngle(angle);
      if (e.shiftKey) {
        angle = Math.round(angle / 45) * 45;
      }
      emit("update:modelValue", angle);
    }
    function stopDrag() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mouseup", stopDrag);
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    }
    function onInput(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (!isNaN(value)) {
        emit("update:modelValue", normalizeAngle(value));
      }
    }
    function onBlur(e) {
      const input = e.target;
      const value = parseFloat(input.value);
      if (isNaN(value)) {
        input.value = displayValue.value.toString();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["angle-dial", { disabled: __props.disabled }])
      }, [
        createBaseVNode("div", {
          class: "dial",
          ref_key: "dialRef",
          ref: dialRef,
          style: normalizeStyle({ width: __props.size + "px", height: __props.size + "px" }),
          onMousedown: startDrag
        }, [
          _cache[0] || (_cache[0] = createBaseVNode("div", { class: "dial-ring" }, null, -1)),
          _cache[1] || (_cache[1] = createBaseVNode("div", { class: "dial-center" }, null, -1)),
          createBaseVNode("div", {
            class: "dial-indicator",
            style: normalizeStyle({ transform: `rotate(${__props.modelValue}deg)` })
          }, null, 4),
          createBaseVNode("div", _hoisted_1$F, [
            (openBlock(), createElementBlock(Fragment, null, renderList(8, (i) => {
              return createBaseVNode("div", {
                class: "dial-mark",
                key: i,
                style: normalizeStyle({ transform: `rotate(${i * 45}deg)` })
              }, null, 4);
            }), 64))
          ])
        ], 36),
        __props.showValue ? (openBlock(), createElementBlock("div", _hoisted_2$E, [
          createBaseVNode("input", {
            type: "number",
            class: "angle-input",
            value: displayValue.value,
            disabled: __props.disabled,
            onInput,
            onBlur
          }, null, 40, _hoisted_3$E),
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "angle-unit" }, "", -1))
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const AngleDial = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__scopeId", "data-v-0fa5dfd2"]]);

function hsvToRgb(h, s, v) {
  h = (h % 360 + 360) % 360;
  const c = v * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = v - c;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  if (d !== 0) {
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, v];
}
function hslToRgb$1(h, s, l) {
  h = (h % 360 + 360) % 360;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;
  if (h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }
  return [
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  ];
}
function rgbToHsl$1(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      case b:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  return [h, s, l];
}
function hexToRgb(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  if (hex.length === 6 || hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
      return [r, g, b];
    }
  }
  return null;
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "ff";
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  if (hex.length === 8) {
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = parseInt(hex.slice(6, 8), 16) / 255;
    if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
      return [r, g, b, a];
    }
  }
  return null;
}
function rgbToHex(r, g, b) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function rgbaToHex(r, g, b, a) {
  const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}${toHex(a * 255)}`;
}
const STANDARD_SWATCHES = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
];

const _hoisted_1$E = {
  key: 0,
  class: "checkerboard"
};
const _hoisted_2$D = ["value"];
const _hoisted_3$D = { class: "mode-tabs" };
const _hoisted_4$D = ["onClick"];
const _hoisted_5$D = {
  key: 1,
  class: "rgb-sliders"
};
const _hoisted_6$D = { class: "color-slider" };
const _hoisted_7$D = ["value"];
const _hoisted_8$C = { class: "color-slider" };
const _hoisted_9$C = ["value"];
const _hoisted_10$C = { class: "color-slider" };
const _hoisted_11$B = ["value"];
const _hoisted_12$z = {
  key: 2,
  class: "hsl-sliders"
};
const _hoisted_13$z = { class: "color-slider" };
const _hoisted_14$w = ["value"];
const _hoisted_15$v = { class: "color-slider" };
const _hoisted_16$u = ["value"];
const _hoisted_17$t = { class: "color-slider" };
const _hoisted_18$s = ["value"];
const _hoisted_19$s = {
  key: 3,
  class: "alpha-slider"
};
const _hoisted_20$s = ["value"];
const _hoisted_21$r = { class: "swatches-section" };
const _hoisted_22$q = { class: "swatches-grid" };
const _hoisted_23$p = ["onClick"];
const _hoisted_24$m = {
  key: 4,
  class: "recent-section"
};
const _hoisted_25$l = { class: "swatches-grid" };
const _hoisted_26$k = ["onClick"];
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: false },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const modes = ["hsv", "rgb", "hsl"];
    const containerRef = ref(null);
    const panelRef = ref(null);
    const svSquareRef = ref(null);
    const hueSliderRef = ref(null);
    const alphaSliderRef = ref(null);
    const isOpen = ref(false);
    const currentMode = ref("hsv");
    const alphaValue = ref(1);
    const recentColors = ref([]);
    const rgb = ref([255, 255, 255]);
    const hsv = ref([0, 0, 1]);
    const hsl = ref([0, 0, 1]);
    const allSwatches = computed(() => props.swatches || STANDARD_SWATCHES);
    const panelStyle = computed(() => {
      if (!containerRef.value || !props.teleport) return {};
      const rect = containerRef.value.getBoundingClientRect();
      return {
        top: `${rect.bottom + 4}px`,
        left: `${rect.left}px`
      };
    });
    function updateFromHex(hex) {
      const parsed = hexToRgb(hex);
      if (parsed) {
        rgb.value = parsed;
        hsv.value = rgbToHsv(parsed[0], parsed[1], parsed[2]);
        hsl.value = rgbToHsl$1(parsed[0], parsed[1], parsed[2]);
      }
    }
    function emitColor() {
      const hex = rgbToHex(rgb.value[0], rgb.value[1], rgb.value[2]);
      emit("update:modelValue", hex);
    }
    function togglePicker() {
      isOpen.value = !isOpen.value;
    }
    function closePicker() {
      if (isOpen.value) {
        isOpen.value = false;
        addToRecent(props.modelValue);
      }
    }
    function addToRecent(color) {
      const index = recentColors.value.indexOf(color);
      if (index !== -1) {
        recentColors.value.splice(index, 1);
      }
      recentColors.value.unshift(color);
      if (recentColors.value.length > props.recentCount) {
        recentColors.value.pop();
      }
    }
    function selectSwatch(color) {
      emit("update:modelValue", color);
    }
    let isDraggingSV = false;
    function startSVDrag(e) {
      isDraggingSV = true;
      updateSV(e);
      document.addEventListener("mousemove", onSVDrag);
      document.addEventListener("mouseup", stopSVDrag);
    }
    function onSVDrag(e) {
      if (isDraggingSV) updateSV(e);
    }
    function updateSV(e) {
      if (!svSquareRef.value) return;
      const rect = svSquareRef.value.getBoundingClientRect();
      const s = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const v = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
      hsv.value = [hsv.value[0], s, v];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopSVDrag() {
      isDraggingSV = false;
      document.removeEventListener("mousemove", onSVDrag);
      document.removeEventListener("mouseup", stopSVDrag);
    }
    let isDraggingHue = false;
    function startHueDrag(e) {
      isDraggingHue = true;
      updateHue(e);
      document.addEventListener("mousemove", onHueDrag);
      document.addEventListener("mouseup", stopHueDrag);
    }
    function onHueDrag(e) {
      if (isDraggingHue) updateHue(e);
    }
    function updateHue(e) {
      if (!hueSliderRef.value) return;
      const rect = hueSliderRef.value.getBoundingClientRect();
      const h = Math.max(0, Math.min(360, (e.clientX - rect.left) / rect.width * 360));
      hsv.value = [h, hsv.value[1], hsv.value[2]];
      rgb.value = hsvToRgb(hsv.value[0], hsv.value[1], hsv.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function stopHueDrag() {
      isDraggingHue = false;
      document.removeEventListener("mousemove", onHueDrag);
      document.removeEventListener("mouseup", stopHueDrag);
    }
    let draggingSlider = null;
    let sliderRect = null;
    function startSliderDrag(slider, e) {
      draggingSlider = slider;
      const track = e.target.closest(".slider-track");
      if (track) {
        sliderRect = track.getBoundingClientRect();
        updateSlider(e);
        document.addEventListener("mousemove", onSliderDrag);
        document.addEventListener("mouseup", stopSliderDrag);
      }
    }
    function onSliderDrag(e) {
      if (draggingSlider) updateSlider(e);
    }
    function updateSlider(e) {
      if (!sliderRect || !draggingSlider) return;
      const percent = Math.max(0, Math.min(1, (e.clientX - sliderRect.left) / sliderRect.width));
      switch (draggingSlider) {
        case "r":
          rgb.value = [Math.round(percent * 255), rgb.value[1], rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "g":
          rgb.value = [rgb.value[0], Math.round(percent * 255), rgb.value[2]];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "b":
          rgb.value = [rgb.value[0], rgb.value[1], Math.round(percent * 255)];
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "h":
          hsl.value = [percent * 360, hsl.value[1], hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "s":
          hsl.value = [hsl.value[0], percent, hsl.value[2]];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
        case "l":
          hsl.value = [hsl.value[0], hsl.value[1], percent];
          rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
          hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
          break;
      }
      emitColor();
    }
    function stopSliderDrag() {
      draggingSlider = null;
      sliderRect = null;
      document.removeEventListener("mousemove", onSliderDrag);
      document.removeEventListener("mouseup", stopSliderDrag);
    }
    let isDraggingAlpha = false;
    function startAlphaDrag(e) {
      isDraggingAlpha = true;
      updateAlpha(e);
      document.addEventListener("mousemove", onAlphaDrag);
      document.addEventListener("mouseup", stopAlphaDrag);
    }
    function onAlphaDrag(e) {
      if (isDraggingAlpha) updateAlpha(e);
    }
    function updateAlpha(e) {
      if (!alphaSliderRef.value) return;
      const rect = alphaSliderRef.value.getBoundingClientRect();
      alphaValue.value = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    }
    function stopAlphaDrag() {
      isDraggingAlpha = false;
      document.removeEventListener("mousemove", onAlphaDrag);
      document.removeEventListener("mouseup", stopAlphaDrag);
    }
    function onHexInput(e) {
      const input = e.target;
      let value = input.value.trim();
      if (!value.startsWith("#")) {
        value = "#" + value;
      }
      if (/^#[0-9a-f]{6}$/i.test(value)) {
        emit("update:modelValue", value.toLowerCase());
      }
    }
    function onHexBlur(e) {
      const input = e.target;
      input.value = props.modelValue;
    }
    function onRgbInput(index, e) {
      const input = e.target;
      const value = Math.max(0, Math.min(255, parseInt(input.value) || 0));
      const newRgb = [...rgb.value];
      newRgb[index] = value;
      rgb.value = newRgb;
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      hsl.value = rgbToHsl$1(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onHslInput(index, e) {
      const input = e.target;
      let value = parseFloat(input.value) || 0;
      if (index === 0) {
        value = Math.max(0, Math.min(360, value));
        hsl.value = [value, hsl.value[1], hsl.value[2]];
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
        if (index === 1) hsl.value = [hsl.value[0], value, hsl.value[2]];
        else hsl.value = [hsl.value[0], hsl.value[1], value];
      }
      rgb.value = hslToRgb$1(hsl.value[0], hsl.value[1], hsl.value[2]);
      hsv.value = rgbToHsv(rgb.value[0], rgb.value[1], rgb.value[2]);
      emitColor();
    }
    function onAlphaInput(e) {
      const input = e.target;
      alphaValue.value = Math.max(0, Math.min(100, parseInt(input.value) || 0)) / 100;
    }
    function onClickOutside(e) {
      if (containerRef.value && !containerRef.value.contains(e.target) && panelRef.value && !panelRef.value.contains(e.target)) {
        closePicker();
      }
    }
    watch(() => props.modelValue, (newVal) => {
      updateFromHex(newVal);
    }, { immediate: true });
    onMounted(() => {
      document.addEventListener("mousedown", onClickOutside);
    });
    onUnmounted(() => {
      document.removeEventListener("mousedown", onClickOutside);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "color-picker",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("button", {
          class: "color-swatch",
          style: normalizeStyle({ backgroundColor: __props.modelValue }),
          onClick: togglePicker
        }, [
          __props.alpha ? (openBlock(), createElementBlock("span", _hoisted_1$E)) : createCommentVNode("", true)
        ], 4),
        createBaseVNode("input", {
          type: "text",
          class: "hex-input",
          value: __props.modelValue,
          onInput: onHexInput,
          onBlur: onHexBlur,
          onKeydown: _cache[0] || (_cache[0] = withKeys(($event) => $event.target.blur(), ["enter"]))
        }, null, 40, _hoisted_2$D),
        (openBlock(), createBlock(Teleport, {
          to: "body",
          disabled: !__props.teleport
        }, [
          isOpen.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "picker-panel",
            style: normalizeStyle(panelStyle.value),
            ref_key: "panelRef",
            ref: panelRef
          }, [
            createBaseVNode("div", _hoisted_3$D, [
              (openBlock(), createElementBlock(Fragment, null, renderList(modes, (mode) => {
                return createBaseVNode("button", {
                  key: mode,
                  class: normalizeClass({ active: currentMode.value === mode }),
                  onClick: ($event) => currentMode.value = mode
                }, toDisplayString(mode.toUpperCase()), 11, _hoisted_4$D);
              }), 64))
            ]),
            currentMode.value === "hsv" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", {
                class: "sv-square",
                style: normalizeStyle({ backgroundColor: `hsl(${hsv.value[0]}, 100%, 50%)` }),
                onMousedown: startSVDrag,
                ref_key: "svSquareRef",
                ref: svSquareRef
              }, [
                _cache[13] || (_cache[13] = createBaseVNode("div", { class: "sv-white" }, null, -1)),
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "sv-black" }, null, -1)),
                createBaseVNode("div", {
                  class: "sv-cursor",
                  style: normalizeStyle({ left: hsv.value[1] * 100 + "%", top: (1 - hsv.value[2]) * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("div", {
                class: "hue-slider",
                onMousedown: startHueDrag,
                ref_key: "hueSliderRef",
                ref: hueSliderRef
              }, [
                createBaseVNode("div", {
                  class: "hue-cursor",
                  style: normalizeStyle({ left: hsv.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 544)
            ], 64)) : currentMode.value === "rgb" ? (openBlock(), createElementBlock("div", _hoisted_5$D, [
              createBaseVNode("div", _hoisted_6$D, [
                _cache[15] || (_cache[15] = createBaseVNode("label", null, "R", -1)),
                createBaseVNode("div", {
                  class: "slider-track r-track",
                  onMousedown: _cache[1] || (_cache[1] = ($event) => startSliderDrag("r", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[0] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[0],
                  min: "0",
                  max: "255",
                  onInput: _cache[2] || (_cache[2] = ($event) => onRgbInput(0, $event))
                }, null, 40, _hoisted_7$D)
              ]),
              createBaseVNode("div", _hoisted_8$C, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "G", -1)),
                createBaseVNode("div", {
                  class: "slider-track g-track",
                  onMousedown: _cache[3] || (_cache[3] = ($event) => startSliderDrag("g", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[1] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[1],
                  min: "0",
                  max: "255",
                  onInput: _cache[4] || (_cache[4] = ($event) => onRgbInput(1, $event))
                }, null, 40, _hoisted_9$C)
              ]),
              createBaseVNode("div", _hoisted_10$C, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "B", -1)),
                createBaseVNode("div", {
                  class: "slider-track b-track",
                  onMousedown: _cache[5] || (_cache[5] = ($event) => startSliderDrag("b", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: rgb.value[2] / 255 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: rgb.value[2],
                  min: "0",
                  max: "255",
                  onInput: _cache[6] || (_cache[6] = ($event) => onRgbInput(2, $event))
                }, null, 40, _hoisted_11$B)
              ])
            ])) : currentMode.value === "hsl" ? (openBlock(), createElementBlock("div", _hoisted_12$z, [
              createBaseVNode("div", _hoisted_13$z, [
                _cache[18] || (_cache[18] = createBaseVNode("label", null, "H", -1)),
                createBaseVNode("div", {
                  class: "slider-track hue-track",
                  onMousedown: _cache[7] || (_cache[7] = ($event) => startSliderDrag("h", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[0] / 360 * 100 + "%" })
                  }, null, 4)
                ], 32),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[0]),
                  min: "0",
                  max: "360",
                  onInput: _cache[8] || (_cache[8] = ($event) => onHslInput(0, $event))
                }, null, 40, _hoisted_14$w)
              ]),
              createBaseVNode("div", _hoisted_15$v, [
                _cache[19] || (_cache[19] = createBaseVNode("label", null, "S", -1)),
                createBaseVNode("div", {
                  class: "slider-track sat-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[9] || (_cache[9] = ($event) => startSliderDrag("s", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[1] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[1] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[10] || (_cache[10] = ($event) => onHslInput(1, $event))
                }, null, 40, _hoisted_16$u)
              ]),
              createBaseVNode("div", _hoisted_17$t, [
                _cache[20] || (_cache[20] = createBaseVNode("label", null, "L", -1)),
                createBaseVNode("div", {
                  class: "slider-track light-track",
                  style: normalizeStyle({ "--hue": hsl.value[0] }),
                  onMousedown: _cache[11] || (_cache[11] = ($event) => startSliderDrag("l", $event))
                }, [
                  createBaseVNode("div", {
                    class: "slider-cursor",
                    style: normalizeStyle({ left: hsl.value[2] * 100 + "%" })
                  }, null, 4)
                ], 36),
                createBaseVNode("input", {
                  type: "number",
                  value: Math.round(hsl.value[2] * 100),
                  min: "0",
                  max: "100",
                  onInput: _cache[12] || (_cache[12] = ($event) => onHslInput(2, $event))
                }, null, 40, _hoisted_18$s)
              ])
            ])) : createCommentVNode("", true),
            __props.alpha ? (openBlock(), createElementBlock("div", _hoisted_19$s, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "A", -1)),
              createBaseVNode("div", {
                class: "slider-track alpha-track",
                style: normalizeStyle({ "--color": __props.modelValue }),
                onMousedown: startAlphaDrag,
                ref_key: "alphaSliderRef",
                ref: alphaSliderRef
              }, [
                createBaseVNode("div", {
                  class: "slider-cursor",
                  style: normalizeStyle({ left: alphaValue.value * 100 + "%" })
                }, null, 4)
              ], 36),
              createBaseVNode("input", {
                type: "number",
                value: Math.round(alphaValue.value * 100),
                min: "0",
                max: "100",
                onInput: onAlphaInput
              }, null, 40, _hoisted_20$s)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_21$r, [
              _cache[22] || (_cache[22] = createBaseVNode("div", { class: "swatches-label" }, "Swatches", -1)),
              createBaseVNode("div", _hoisted_22$q, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allSwatches.value, (swatch) => {
                  return openBlock(), createElementBlock("button", {
                    key: swatch,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: swatch }),
                    onClick: ($event) => selectSwatch(swatch)
                  }, null, 12, _hoisted_23$p);
                }), 128))
              ])
            ]),
            recentColors.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_24$m, [
              _cache[23] || (_cache[23] = createBaseVNode("div", { class: "swatches-label" }, "Recent", -1)),
              createBaseVNode("div", _hoisted_25$l, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(recentColors.value, (color) => {
                  return openBlock(), createElementBlock("button", {
                    key: color,
                    class: "swatch",
                    style: normalizeStyle({ backgroundColor: color }),
                    onClick: ($event) => selectSwatch(color)
                  }, null, 12, _hoisted_26$k);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ], 8, ["disabled"]))
      ], 512);
    };
  }
});

const ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__scopeId", "data-v-98ed6487"]]);

const _hoisted_1$D = { class: "effect-controls" };
const _hoisted_2$C = { class: "panel-header" };
const _hoisted_3$C = { class: "header-row" };
const _hoisted_4$C = {
  key: 0,
  class: "layer-badge"
};
const _hoisted_5$C = { class: "layer-type-icon" };
const _hoisted_6$C = ["disabled"];
const _hoisted_7$C = {
  key: 0,
  class: "effect-menu"
};
const _hoisted_8$B = { class: "category-label" };
const _hoisted_9$B = { class: "cat-icon" };
const _hoisted_10$B = { class: "category-items" };
const _hoisted_11$A = ["onClick"];
const _hoisted_12$y = { class: "panel-content" };
const _hoisted_13$y = {
  key: 0,
  class: "empty-state"
};
const _hoisted_14$v = {
  key: 1,
  class: "empty-state"
};
const _hoisted_15$u = {
  key: 2,
  class: "effects-list"
};
const _hoisted_16$t = ["onClick"];
const _hoisted_17$s = { class: "header-left" };
const _hoisted_18$r = { class: "arrow" };
const _hoisted_19$r = ["onClick"];
const _hoisted_20$r = { class: "effect-name" };
const _hoisted_21$q = { class: "header-right" };
const _hoisted_22$p = ["onClick"];
const _hoisted_23$o = {
  key: 0,
  class: "effect-params"
};
const _hoisted_24$l = { class: "param-header" };
const _hoisted_25$k = ["title"];
const _hoisted_26$j = ["onClick"];
const _hoisted_27$i = { class: "param-control" };
const _hoisted_28$i = {
  key: 0,
  class: "control-group"
};
const _hoisted_29$i = {
  key: 1,
  class: "control-group"
};
const _hoisted_30$h = {
  key: 2,
  class: "control-group point-group"
};
const _hoisted_31$e = ["checked", "onChange"];
const _hoisted_32$e = ["value", "onChange"];
const _hoisted_33$e = ["value"];
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "EffectControlsPanel",
  setup(__props) {
    const store = useCompositorStore();
    const showAddMenu = ref(false);
    const menuRef = ref(null);
    const layer = computed(() => store.selectedLayer);
    const categories = EFFECT_CATEGORIES;
    function getEffectsByCategory(cat) {
      return Object.entries(EFFECT_DEFINITIONS).filter(([_, def]) => def.category === cat).map(([key, def]) => ({ key, ...def }));
    }
    function getParamDef(effectKey, paramKey) {
      const def = EFFECT_DEFINITIONS[effectKey];
      return def?.parameters.find((p) => formatParamKey(p.name) === paramKey);
    }
    function formatParamKey(name) {
      return name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function hasRange(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def && (def.min !== void 0 || def.max !== void 0);
    }
    function isCheckbox(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "checkbox";
    }
    function isAngleParam(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.type === "angle";
    }
    function getParamOptions(effectKey, paramKey) {
      const def = getParamDef(effectKey, paramKey);
      return def?.options || [];
    }
    function getLayerIcon(type) {
      const icons = {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      };
      return icons[type] || "";
    }
    function addEffect(key) {
      if (layer.value) {
        store.addEffectToLayer(layer.value.id, key);
        showAddMenu.value = false;
      }
    }
    function removeEffect(effect) {
      if (layer.value) store.removeEffectFromLayer(layer.value.id, effect.id);
    }
    function toggleEffect(effect) {
      if (layer.value) store.toggleEffect(layer.value.id, effect.id);
    }
    function toggleExpand(effect) {
      effect.expanded = !effect.expanded;
    }
    function updateParam(effectId, paramKey, value) {
      if (layer.value) store.updateEffectParameter(layer.value.id, effectId, paramKey, value);
    }
    function updatePoint(effectId, paramKey, axis, val) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      if (!effect) return;
      const current = effect.parameters[paramKey].value;
      const newValue = { ...current, [axis]: val };
      store.updateEffectParameter(layer.value.id, effectId, paramKey, newValue);
    }
    function formatColor(val) {
      if (typeof val === "string") return val;
      return rgbaToHex(val.r, val.g, val.b, val.a ?? 1);
    }
    function updateColor(effectId, paramKey, hex) {
      const rgba = hexToRgba(hex);
      if (rgba && layer.value) {
        const val = { r: rgba[0], g: rgba[1], b: rgba[2], a: rgba[3] };
        store.updateEffectParameter(layer.value.id, effectId, paramKey, val);
      }
    }
    function toggleParamAnim(effectId, paramKey) {
      if (!layer.value) return;
      const effect = layer.value.effects.find((e) => e.id === effectId);
      const param = effect?.parameters[paramKey];
      if (param) {
        store.setEffectParamAnimated(layer.value.id, effectId, paramKey, !param.animated);
      }
    }
    function onClickOutside(e) {
      if (menuRef.value && !menuRef.value.contains(e.target)) {
        showAddMenu.value = false;
      }
    }
    onMounted(() => window.addEventListener("mousedown", onClickOutside));
    onUnmounted(() => window.removeEventListener("mousedown", onClickOutside));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        createBaseVNode("div", _hoisted_2$C, [
          createBaseVNode("div", _hoisted_3$C, [
            _cache[1] || (_cache[1] = createBaseVNode("h3", null, "Effect Controls", -1)),
            layer.value ? (openBlock(), createElementBlock("div", _hoisted_4$C, [
              createBaseVNode("span", _hoisted_5$C, toDisplayString(getLayerIcon(layer.value.type)), 1),
              createTextVNode(" " + toDisplayString(layer.value.name), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", {
            class: "add-effect-wrapper",
            ref_key: "menuRef",
            ref: menuRef
          }, [
            createBaseVNode("button", {
              class: "add-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => showAddMenu.value = !showAddMenu.value),
              disabled: !layer.value
            }, [..._cache[2] || (_cache[2] = [
              createBaseVNode("span", { class: "icon" }, "+", -1),
              createTextVNode(" Add Effect ", -1)
            ])], 8, _hoisted_6$C),
            showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_7$C, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(categories), (catInfo, catKey) => {
                return openBlock(), createElementBlock("div", {
                  key: catKey,
                  class: "effect-category"
                }, [
                  createBaseVNode("div", _hoisted_8$B, [
                    createBaseVNode("span", _hoisted_9$B, toDisplayString(catInfo.icon), 1),
                    createTextVNode(" " + toDisplayString(catInfo.label), 1)
                  ]),
                  createBaseVNode("div", _hoisted_10$B, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getEffectsByCategory(catKey), (def) => {
                      return openBlock(), createElementBlock("button", {
                        key: def.key,
                        onClick: ($event) => addEffect(def.key)
                      }, toDisplayString(def.name), 9, _hoisted_11$A);
                    }), 128))
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 512)
        ]),
        createBaseVNode("div", _hoisted_12$y, [
          !layer.value ? (openBlock(), createElementBlock("div", _hoisted_13$y, " Select a layer to edit effects ")) : !layer.value.effects || layer.value.effects.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_14$v, " No effects applied ")) : (openBlock(), createElementBlock("div", _hoisted_15$u, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(layer.value.effects, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: normalizeClass(["effect-item", { collapsed: !effect.expanded }])
              }, [
                createBaseVNode("div", {
                  class: "effect-header",
                  onClick: ($event) => toggleExpand(effect)
                }, [
                  createBaseVNode("div", _hoisted_17$s, [
                    createBaseVNode("span", _hoisted_18$r, toDisplayString(effect.expanded ? "" : ""), 1),
                    createBaseVNode("button", {
                      class: "icon-btn",
                      onClick: withModifiers(($event) => toggleEffect(effect), ["stop"])
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(["fx-icon", { disabled: !effect.enabled }])
                      }, "fx", 2)
                    ], 8, _hoisted_19$r),
                    createBaseVNode("span", _hoisted_20$r, toDisplayString(effect.name), 1)
                  ]),
                  createBaseVNode("div", _hoisted_21$q, [
                    createBaseVNode("button", {
                      class: "icon-btn delete",
                      onClick: withModifiers(($event) => removeEffect(effect), ["stop"]),
                      title: "Remove Effect"
                    }, "", 8, _hoisted_22$p)
                  ])
                ], 8, _hoisted_16$t),
                effect.expanded ? (openBlock(), createElementBlock("div", _hoisted_23$o, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(effect.parameters, (param, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: "param-row"
                    }, [
                      createBaseVNode("div", _hoisted_24$l, [
                        createBaseVNode("span", {
                          class: "param-name",
                          title: String(key)
                        }, toDisplayString(param.name), 9, _hoisted_25$k),
                        createBaseVNode("button", {
                          class: normalizeClass(["keyframe-toggle", { active: param.animated }]),
                          onClick: ($event) => toggleParamAnim(effect.id, String(key)),
                          title: "Toggle Animation"
                        }, "", 10, _hoisted_26$j)
                      ]),
                      createBaseVNode("div", _hoisted_27$i, [
                        param.type === "number" && isAngleParam(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("div", _hoisted_28$i, [
                          createVNode(AngleDial, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            size: 32,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            unit: ""
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "number" ? (openBlock(), createElementBlock("div", _hoisted_29$i, [
                          hasRange(effect.effectKey, String(key)) ? (openBlock(), createBlock(SliderInput, {
                            key: 0,
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            min: getParamDef(effect.effectKey, String(key))?.min ?? 0,
                            max: getParamDef(effect.effectKey, String(key))?.max ?? 100,
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 1,
                            showValue: false
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : createCommentVNode("", true),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value,
                            "onUpdate:modelValue": (v) => updateParam(effect.id, String(key), v),
                            step: getParamDef(effect.effectKey, String(key))?.step ?? 0.1
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                        ])) : param.type === "position" ? (openBlock(), createElementBlock("div", _hoisted_30$h, [
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.x,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "x", v),
                            label: "X"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                          createVNode(ScrubableNumber, {
                            modelValue: param.value.y,
                            "onUpdate:modelValue": (v) => updatePoint(effect.id, String(key), "y", v),
                            label: "Y"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])) : param.type === "color" ? (openBlock(), createBlock(ColorPicker, {
                          key: 3,
                          modelValue: formatColor(param.value),
                          "onUpdate:modelValue": (v) => updateColor(effect.id, String(key), v),
                          alpha: true
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])) : param.type === "enum" && isCheckbox(effect.effectKey, String(key)) ? (openBlock(), createElementBlock("input", {
                          key: 4,
                          type: "checkbox",
                          checked: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.checked)
                        }, null, 40, _hoisted_31$e)) : param.type === "enum" ? (openBlock(), createElementBlock("select", {
                          key: 5,
                          value: param.value,
                          onChange: (e) => updateParam(effect.id, String(key), e.target.value),
                          class: "param-select"
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(getParamOptions(effect.effectKey, String(key)), (opt) => {
                            return openBlock(), createElementBlock("option", {
                              key: opt.value,
                              value: opt.value
                            }, toDisplayString(opt.label), 9, _hoisted_33$e);
                          }), 128))
                        ], 40, _hoisted_32$e)) : createCommentVNode("", true)
                      ])
                    ]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]))
        ])
      ]);
    };
  }
});

const EffectControlsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__scopeId", "data-v-c43eaab6"]]);

const fontLogger = createLogger("Font");
const WEB_SAFE_FONTS = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
];
const GOOGLE_FONTS = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class FontService {
  systemFonts = [];
  loadedGoogleFonts = /* @__PURE__ */ new Set();
  initialized = false;
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    if (this.initialized) return;
    if ("queryLocalFonts" in window) {
      await this.loadSystemFonts();
    }
    this.initialized = true;
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const fonts = await window.queryLocalFonts();
      const familyMap = /* @__PURE__ */ new Map();
      for (const font of fonts) {
        if (!familyMap.has(font.family) || font.style === "Regular") {
          familyMap.set(font.family, {
            family: font.family,
            fullName: font.fullName,
            style: font.style,
            source: "system"
          });
        }
      }
      this.systemFonts = Array.from(familyMap.values()).sort((a, b) => a.family.localeCompare(b.family));
      fontLogger.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (error) {
      if (error.name === "NotAllowedError") {
        fontLogger.info("User denied font access permission");
      } else {
        fontLogger.error("Error loading system fonts:", error);
      }
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const categories = [];
    if (this.systemFonts.length > 0) {
      categories.push({
        name: "System Fonts",
        fonts: this.systemFonts
      });
    }
    categories.push({
      name: "Web Safe",
      fonts: WEB_SAFE_FONTS
    });
    categories.push({
      name: "Google Fonts",
      fonts: GOOGLE_FONTS.map((family) => ({
        family,
        fullName: family,
        style: "normal",
        source: "google"
      }))
    });
    return categories;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const families = /* @__PURE__ */ new Set();
    WEB_SAFE_FONTS.forEach((f) => families.add(f.family));
    GOOGLE_FONTS.forEach((f) => families.add(f));
    this.systemFonts.forEach((f) => families.add(f.family));
    return Array.from(families).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(family, weights = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(family)) return;
    if (!GOOGLE_FONTS.includes(family)) {
      fontLogger.warn(`Attempted to load non-whitelisted font: ${family}`);
      return;
    }
    const weightsStr = weights.join(";");
    const url = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(family)}:wght@${weightsStr}&display=swap`;
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = url;
    document.head.appendChild(link);
    try {
      await document.fonts.load(`400 16px "${family}"`);
      this.loadedGoogleFonts.add(family);
      fontLogger.debug(`Loaded Google Font: ${family}`);
    } catch (error) {
      fontLogger.error(`Failed to load Google Font: ${family}`, error);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(family) {
    if (WEB_SAFE_FONTS.some((f) => f.family === family)) {
      return true;
    }
    if (GOOGLE_FONTS.includes(family)) {
      await this.loadGoogleFont(family);
      return true;
    }
    if (this.systemFonts.some((f) => f.family === family)) {
      return true;
    }
    return this.isFontAvailable(family);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(family) {
    const testString = "mmmmmmmmmmlli";
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    ctx.font = "72px monospace";
    const fallbackWidth = ctx.measureText(testString).width;
    ctx.font = `72px "${family}", monospace`;
    const testWidth = ctx.measureText(testString).width;
    return fallbackWidth !== testWidth;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return WEB_SAFE_FONTS;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return GOOGLE_FONTS;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    if (!("queryLocalFonts" in window)) {
      fontLogger.info("Local Font Access API not available");
      return false;
    }
    await this.loadSystemFonts();
    return this.systemFonts.length > 0;
  }
}
const fontService = new FontService();

function generateId() {
  return `animator_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
}
function createAnimatableProp(value, name) {
  return {
    id: generateId(),
    name,
    type: typeof value === "number" ? "number" : typeof value === "string" ? "string" : "object",
    value,
    animated: false,
    keyframes: []
  };
}
const DEFAULT_RANGE_SELECTOR = {
  mode: "percent",
  start: createAnimatableProp(0, "Start"),
  end: createAnimatableProp(100, "End"),
  offset: createAnimatableProp(0, "Offset"),
  basedOn: "characters",
  shape: "square",
  randomizeOrder: false,
  randomSeed: 12345,
  ease: { high: 100, low: 0 }
};
const DEFAULT_ANIMATOR_PROPERTIES = {};
function createTextAnimator(name) {
  return {
    id: generateId(),
    name: name || "Animator 1",
    enabled: true,
    rangeSelector: { ...DEFAULT_RANGE_SELECTOR },
    properties: { ...DEFAULT_ANIMATOR_PROPERTIES }
  };
}
const TEXT_ANIMATOR_PRESETS = {
  typewriter: {
    type: "typewriter",
    name: "Typewriter",
    description: "Characters appear one by one from left to right",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Typewriter",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        end: createAnimatableProp(100, "End"),
        basedOn: "characters",
        shape: "square"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
        // Characters start invisible
      }
    })
  },
  fade_in_by_character: {
    type: "fade_in_by_character",
    name: "Fade In (Characters)",
    description: "Characters fade in from transparent",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Fade In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  fade_in_by_word: {
    type: "fade_in_by_word",
    name: "Fade In (Words)",
    description: "Words fade in from transparent",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Fade In Words",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "words",
        shape: "ramp_down"
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  bounce_in: {
    type: "bounce_in",
    name: "Bounce In",
    description: "Characters bounce in from above",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Bounce In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: 0, y: -100 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  wave: {
    type: "wave",
    name: "Wave",
    description: "Characters move up and down in a wave pattern",
    duration: 60,
    create: (_duration) => ({
      id: generateId(),
      name: "Wave",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        offset: createAnimatablePropWithKeyframes(0, "Offset", [
          { frame: 0, value: 0 },
          { frame: 30, value: 100 },
          { frame: 60, value: 0 }
        ]),
        basedOn: "characters",
        shape: "triangle"
      },
      properties: {
        position: createAnimatableProp({ x: 0, y: -20 }, "Position")
      }
    })
  },
  scale_in: {
    type: "scale_in",
    name: "Scale In",
    description: "Characters scale up from zero",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Scale In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        scale: createAnimatableProp({ x: 0, y: 0 }, "Scale"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  rotate_in: {
    type: "rotate_in",
    name: "Rotate In",
    description: "Characters rotate into place",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Rotate In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        rotation: createAnimatableProp(-90, "Rotation"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  slide_in_left: {
    type: "slide_in_left",
    name: "Slide In (Left)",
    description: "Characters slide in from the left",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Slide Left",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: -100, y: 0 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  slide_in_right: {
    type: "slide_in_right",
    name: "Slide In (Right)",
    description: "Characters slide in from the right",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Slide Right",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        position: createAnimatableProp({ x: 100, y: 0 }, "Position"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  blur_in: {
    type: "blur_in",
    name: "Blur In",
    description: "Characters unblur as they appear",
    duration: 45,
    create: (duration) => ({
      id: generateId(),
      name: "Blur In",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "ramp_down"
      },
      properties: {
        blur: createAnimatableProp({ x: 20, y: 20 }, "Blur"),
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  },
  random_fade: {
    type: "random_fade",
    name: "Random Fade",
    description: "Characters fade in randomly",
    duration: 60,
    create: (duration) => ({
      id: generateId(),
      name: "Random Fade",
      enabled: true,
      rangeSelector: {
        ...DEFAULT_RANGE_SELECTOR,
        start: createAnimatablePropWithKeyframes(100, "Start", [
          { frame: 0, value: 100 },
          { frame: duration, value: 0 }
        ]),
        basedOn: "characters",
        shape: "square",
        randomizeOrder: true,
        randomSeed: Math.floor(Math.random() * 99999)
      },
      properties: {
        opacity: createAnimatableProp(0, "Opacity")
      }
    })
  }
};
function createAnimatablePropWithKeyframes(value, name, keyframes) {
  return {
    id: generateId(),
    name,
    type: typeof value === "number" ? "number" : typeof value === "string" ? "string" : "object",
    value,
    animated: keyframes.length > 0,
    keyframes: keyframes.map((kf) => ({
      id: generateId(),
      frame: kf.frame,
      value: kf.value,
      easing: "ease-out"
    }))
  };
}
function applyTextAnimatorPreset(presetType, duration = 45) {
  const preset = TEXT_ANIMATOR_PRESETS[presetType];
  if (!preset) {
    return createTextAnimator();
  }
  return preset.create(duration);
}
const TEXT_ANIMATOR_PRESET_LIST = Object.values(TEXT_ANIMATOR_PRESETS);

const _hoisted_1$C = { class: "text-properties" };
const _hoisted_2$B = { class: "prop-section" };
const _hoisted_3$B = ["value"];
const _hoisted_4$B = { class: "prop-section" };
const _hoisted_5$B = { class: "row font-row" };
const _hoisted_6$B = ["value"];
const _hoisted_7$B = ["label"];
const _hoisted_8$A = ["value"];
const _hoisted_9$A = { class: "style-toggles" };
const _hoisted_10$A = {
  key: 0,
  class: "row"
};
const _hoisted_11$z = ["disabled"];
const _hoisted_12$x = { class: "row" };
const _hoisted_13$x = { class: "row color-row" };
const _hoisted_14$u = { class: "color-item" };
const _hoisted_15$t = ["value"];
const _hoisted_16$s = { class: "color-item" };
const _hoisted_17$r = ["value"];
const _hoisted_18$q = { class: "row" };
const _hoisted_19$q = { class: "row" };
const _hoisted_20$q = { class: "align-buttons" };
const _hoisted_21$p = { class: "prop-section" };
const _hoisted_22$o = { class: "row" };
const _hoisted_23$n = { class: "vec2" };
const _hoisted_24$k = { class: "row" };
const _hoisted_25$j = { class: "vec2" };
const _hoisted_26$i = { class: "row" };
const _hoisted_27$h = { class: "vec2" };
const _hoisted_28$h = { class: "row" };
const _hoisted_29$h = { class: "row" };
const _hoisted_30$g = { class: "prop-section" };
const _hoisted_31$d = { class: "row" };
const _hoisted_32$d = ["value"];
const _hoisted_33$d = ["value"];
const _hoisted_34$d = { class: "row" };
const _hoisted_35$c = { class: "row" };
const _hoisted_36$c = { class: "row" };
const _hoisted_37$c = { class: "row checkbox-row" };
const _hoisted_38$c = ["checked"];
const _hoisted_39$c = { class: "row checkbox-row" };
const _hoisted_40$b = ["checked"];
const _hoisted_41$9 = { class: "row checkbox-row" };
const _hoisted_42$8 = ["checked"];
const _hoisted_43$8 = { class: "prop-section" };
const _hoisted_44$8 = { class: "row" };
const _hoisted_45$8 = { class: "row" };
const _hoisted_46$8 = { class: "row" };
const _hoisted_47$8 = { class: "row" };
const _hoisted_48$8 = { class: "row text-formatting-row" };
const _hoisted_49$8 = { class: "format-toggles" };
const _hoisted_50$7 = { class: "row text-formatting-row" };
const _hoisted_51$7 = { class: "format-toggles" };
const _hoisted_52$7 = { class: "prop-section checkbox" };
const _hoisted_53$7 = ["checked"];
const _hoisted_54$7 = { class: "prop-section animators-section" };
const _hoisted_55$7 = { class: "section-header" };
const _hoisted_56$7 = { class: "animator-add-controls" };
const _hoisted_57$6 = ["value"];
const _hoisted_58$6 = {
  key: 0,
  class: "no-animators"
};
const _hoisted_59$6 = ["onClick"];
const _hoisted_60$6 = { class: "expand-icon" };
const _hoisted_61$6 = ["checked", "onClick"];
const _hoisted_62$6 = ["value", "onInput"];
const _hoisted_63$4 = { class: "animator-actions" };
const _hoisted_64$4 = ["onClick"];
const _hoisted_65$4 = ["onClick"];
const _hoisted_66$4 = {
  key: 0,
  class: "animator-content"
};
const _hoisted_67$4 = { class: "subsection" };
const _hoisted_68$4 = { class: "row" };
const _hoisted_69$4 = ["value", "onChange"];
const _hoisted_70$4 = { class: "row" };
const _hoisted_71$4 = { class: "row" };
const _hoisted_72$4 = { class: "row" };
const _hoisted_73$4 = { class: "row" };
const _hoisted_74$4 = ["value", "onChange"];
const _hoisted_75$4 = { class: "row checkbox-row" };
const _hoisted_76$4 = ["checked", "onChange"];
const _hoisted_77$4 = { class: "subsection" };
const _hoisted_78$4 = { class: "property-row" };
const _hoisted_79$4 = { class: "prop-label" };
const _hoisted_80$4 = ["checked", "onChange"];
const _hoisted_81$4 = {
  key: 0,
  class: "vec2"
};
const _hoisted_82$4 = { class: "property-row" };
const _hoisted_83$4 = { class: "prop-label" };
const _hoisted_84$4 = ["checked", "onChange"];
const _hoisted_85$4 = {
  key: 0,
  class: "vec2"
};
const _hoisted_86$4 = { class: "property-row" };
const _hoisted_87$4 = { class: "prop-label" };
const _hoisted_88$4 = ["checked", "onChange"];
const _hoisted_89$4 = { class: "property-row" };
const _hoisted_90$4 = { class: "prop-label" };
const _hoisted_91$3 = ["checked", "onChange"];
const _hoisted_92$3 = { class: "property-row" };
const _hoisted_93$2 = { class: "prop-label" };
const _hoisted_94$2 = ["checked", "onChange"];
const _hoisted_95$1 = {
  key: 0,
  class: "vec2"
};
const _hoisted_96$1 = { class: "property-row" };
const _hoisted_97$1 = { class: "prop-label" };
const _hoisted_98$1 = ["checked", "onChange"];
const _hoisted_99$1 = { class: "property-row" };
const _hoisted_100$1 = { class: "prop-label" };
const _hoisted_101$1 = ["checked", "onChange"];
const _hoisted_102$1 = ["value", "onInput"];
const _hoisted_103$1 = { class: "property-row" };
const _hoisted_104$1 = { class: "prop-label" };
const _hoisted_105$1 = ["checked", "onChange"];
const _hoisted_106$1 = ["value", "onInput"];
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const fontCategories = ref([]);
    const hasSystemFonts = ref(false);
    const loadingFonts = ref(false);
    const expandedAnimators = ref(/* @__PURE__ */ new Set());
    const selectedPreset = ref("");
    const animatorPresets = TEXT_ANIMATOR_PRESET_LIST;
    onMounted(async () => {
      await fontService.initialize();
      fontCategories.value = fontService.getFontCategories();
      hasSystemFonts.value = fontService.hasSystemFonts();
    });
    async function requestFontAccess() {
      loadingFonts.value = true;
      try {
        const success = await fontService.requestSystemFontAccess();
        if (success) {
          fontCategories.value = fontService.getFontCategories();
          hasSystemFonts.value = true;
        }
      } finally {
        loadingFonts.value = false;
      }
    }
    const textData = computed(() => props.layer.data);
    const transform = computed(() => props.layer.transform);
    const splineLayers = computed(() => store.layers.filter((l) => l.type === "spline"));
    const animators = computed(() => textData.value.animators || []);
    function toggleAnimatorExpanded(animatorId) {
      if (expandedAnimators.value.has(animatorId)) {
        expandedAnimators.value.delete(animatorId);
      } else {
        expandedAnimators.value.add(animatorId);
      }
    }
    function addAnimator(presetType) {
      const newAnimator = presetType ? applyTextAnimatorPreset(presetType, 45) : createTextAnimator(`Animator ${animators.value.length + 1}`);
      const currentAnimators = [...animators.value, newAnimator];
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.add(newAnimator.id);
      emit("update");
    }
    function removeAnimator(animatorId) {
      const currentAnimators = animators.value.filter((a) => a.id !== animatorId);
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.delete(animatorId);
      emit("update");
    }
    function duplicateAnimator(animatorId) {
      const source = animators.value.find((a) => a.id === animatorId);
      if (!source) return;
      const duplicated = JSON.parse(JSON.stringify(source));
      duplicated.id = `animator_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
      duplicated.name = `${source.name} (Copy)`;
      const currentAnimators = [...animators.value, duplicated];
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      expandedAnimators.value.add(duplicated.id);
      emit("update");
    }
    function toggleAnimatorEnabled(animatorId) {
      const animator = animators.value.find((a) => a.id === animatorId);
      if (!animator) return;
      const currentAnimators = animators.value.map(
        (a) => a.id === animatorId ? { ...a, enabled: !a.enabled } : a
      );
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateAnimatorName(animatorId, name) {
      const currentAnimators = animators.value.map(
        (a) => a.id === animatorId ? { ...a, name } : a
      );
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateRangeSelector(animatorId, key, value) {
      const currentAnimators = animators.value.map((a) => {
        if (a.id !== animatorId) return a;
        const updated = { ...a };
        if (key === "start" || key === "end" || key === "offset") {
          updated.rangeSelector = {
            ...updated.rangeSelector,
            [key]: {
              ...updated.rangeSelector[key],
              value
            }
          };
        } else {
          updated.rangeSelector = {
            ...updated.rangeSelector,
            [key]: value
          };
        }
        return updated;
      });
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function updateAnimatorProperty(animatorId, propKey, value) {
      const currentAnimators = animators.value.map((a) => {
        if (a.id !== animatorId) return a;
        const updated = { ...a };
        if (value === null || value === void 0) {
          const { [propKey]: removed, ...rest } = updated.properties;
          updated.properties = rest;
        } else {
          updated.properties = {
            ...updated.properties,
            [propKey]: {
              id: `prop_${Date.now()}`,
              name: propKey.charAt(0).toUpperCase() + propKey.slice(1),
              type: typeof value === "number" ? "number" : "object",
              value,
              animated: false,
              keyframes: []
            }
          };
        }
        return updated;
      });
      store.updateLayerData(props.layer.id, { animators: currentAnimators });
      emit("update");
    }
    function getAnimatorPropertyValue(animator, propKey) {
      return animator.properties[propKey]?.value;
    }
    function hasAnimatorProperty(animator, propKey) {
      return propKey in animator.properties;
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const p = getProperty(name);
      return p ? p.value : null;
    }
    function updateText(val) {
      store.setPropertyValue(props.layer.id, "Source Text", val);
      store.updateLayerData(props.layer.id, { text: val });
      emit("update");
    }
    function updateData(key, val) {
      store.updateLayerData(props.layer.id, { [key]: val });
      const map = {
        "fill": "Fill Color",
        "stroke": "Stroke Color",
        "fontSize": "Font Size",
        "strokeWidth": "Stroke Width"
      };
      if (map[key]) {
        store.setPropertyValue(props.layer.id, map[key], val);
      }
      emit("update");
    }
    function updateAnimatable(name, val) {
      store.setPropertyValue(props.layer.id, name, val);
      const keyMap = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        "Tracking": "tracking",
        "Line Spacing": "lineSpacing",
        "Baseline Shift": "baselineShift",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      if (keyMap[name]) {
        store.updateLayerData(props.layer.id, { [keyMap[name]]: val });
      }
      emit("update");
    }
    function isPropertyAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function toggleKeyframe(name) {
      const prop = getProperty(name);
      if (!prop) return;
      const currentFrame = store.currentFrame;
      const existingKf = prop.keyframes?.find((kf) => kf.frame === currentFrame);
      if (existingKf) {
        store.removeKeyframe(props.layer.id, name, existingKf.id);
      } else {
        store.addKeyframe(props.layer.id, name, prop.value, currentFrame);
      }
      emit("update");
    }
    function updateTransform(propName, axis, val) {
      const prop = transform.value[propName];
      let newValue;
      if (axis) {
        newValue = { ...prop.value, [axis]: val };
      } else {
        newValue = val;
      }
      store.setPropertyValue(props.layer.id, `transform.${propName}`, newValue);
      emit("update");
    }
    function updateOpacity(val) {
      store.setPropertyValue(props.layer.id, "opacity", val);
      emit("update");
    }
    function toggleBold() {
      updateData("fontWeight", textData.value.fontWeight === "bold" ? "400" : "bold");
    }
    function toggleItalic() {
      updateData("fontStyle", textData.value.fontStyle === "italic" ? "normal" : "italic");
    }
    function toggleCase(caseType) {
      updateData("textCase", caseType);
    }
    function toggleVerticalAlign(align) {
      updateData("verticalAlign", align);
    }
    async function handleFontChange(family) {
      await fontService.ensureFont(family);
      updateData("fontFamily", family);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$C, [
        createBaseVNode("div", _hoisted_2$B, [
          _cache[39] || (_cache[39] = createBaseVNode("div", { class: "section-title" }, "Source Text", -1)),
          createBaseVNode("textarea", {
            value: textData.value.text,
            onInput: _cache[0] || (_cache[0] = (e) => updateText(e.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, _hoisted_3$B)
        ]),
        createBaseVNode("div", _hoisted_4$B, [
          _cache[45] || (_cache[45] = createBaseVNode("div", { class: "section-title" }, "Character", -1)),
          createBaseVNode("div", _hoisted_5$B, [
            createBaseVNode("select", {
              value: textData.value.fontFamily,
              onChange: _cache[1] || (_cache[1] = (e) => handleFontChange(e.target.value)),
              class: "font-select"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(fontCategories.value, (category) => {
                return openBlock(), createElementBlock("optgroup", {
                  key: category.name,
                  label: category.name
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(category.fonts, (font) => {
                    return openBlock(), createElementBlock("option", {
                      key: font.family,
                      value: font.family
                    }, toDisplayString(font.family), 9, _hoisted_8$A);
                  }), 128))
                ], 8, _hoisted_7$B);
              }), 128))
            ], 40, _hoisted_6$B),
            createBaseVNode("div", _hoisted_9$A, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontWeight === "bold" }),
                onClick: toggleBold
              }, "B", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.fontStyle === "italic" }),
                onClick: toggleItalic
              }, "I", 2)
            ])
          ]),
          !hasSystemFonts.value ? (openBlock(), createElementBlock("div", _hoisted_10$A, [
            createBaseVNode("button", {
              class: "font-access-btn",
              onClick: requestFontAccess,
              disabled: loadingFonts.value
            }, toDisplayString(loadingFonts.value ? "Loading..." : "+ Load System Fonts"), 9, _hoisted_11$z)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_12$x, [
            _cache[40] || (_cache[40] = createBaseVNode("label", null, "Size", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Font Size") || textData.value.fontSize,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("Font Size", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_13$x, [
            createBaseVNode("div", _hoisted_14$u, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.fill,
                onInput: _cache[3] || (_cache[3] = (e) => updateData("fill", e.target.value))
              }, null, 40, _hoisted_15$t),
              _cache[41] || (_cache[41] = createBaseVNode("span", null, "Fill", -1))
            ]),
            createBaseVNode("div", _hoisted_16$s, [
              createBaseVNode("input", {
                type: "color",
                value: textData.value.stroke || "#000000",
                onInput: _cache[4] || (_cache[4] = (e) => updateData("stroke", e.target.value))
              }, null, 40, _hoisted_17$r),
              _cache[42] || (_cache[42] = createBaseVNode("span", null, "Stroke", -1))
            ])
          ]),
          createBaseVNode("div", _hoisted_18$q, [
            _cache[43] || (_cache[43] = createBaseVNode("label", null, "Stroke Width", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Stroke Width") || textData.value.strokeWidth || 0,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_19$q, [
            _cache[44] || (_cache[44] = createBaseVNode("label", null, "Alignment", -1)),
            createBaseVNode("div", _hoisted_20$q, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "left" }),
                onClick: _cache[6] || (_cache[6] = ($event) => updateData("textAlign", "left"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "center" }),
                onClick: _cache[7] || (_cache[7] = ($event) => updateData("textAlign", "center"))
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textAlign === "right" }),
                onClick: _cache[8] || (_cache[8] = ($event) => updateData("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_21$p, [
          _cache[51] || (_cache[51] = createBaseVNode("div", { class: "section-title" }, "Transform", -1)),
          createBaseVNode("div", _hoisted_22$o, [
            _cache[46] || (_cache[46] = createBaseVNode("label", null, "Position", -1)),
            createBaseVNode("div", _hoisted_23$n, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.x,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateTransform("position", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.position.value.y,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateTransform("position", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_24$k, [
            _cache[47] || (_cache[47] = createBaseVNode("label", null, "Anchor Pt", -1)),
            createBaseVNode("div", _hoisted_25$j, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.x,
                "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateTransform("anchorPoint", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.anchorPoint.value.y,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateTransform("anchorPoint", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_26$i, [
            _cache[48] || (_cache[48] = createBaseVNode("label", null, "Scale %", -1)),
            createBaseVNode("div", _hoisted_27$h, [
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.x,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateTransform("scale", "x", v))
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: transform.value.scale.value.y,
                "onUpdate:modelValue": _cache[14] || (_cache[14] = (v) => updateTransform("scale", "y", v))
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_28$h, [
            _cache[49] || (_cache[49] = createBaseVNode("label", null, "Rotation", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: transform.value.rotation.value,
              "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateTransform("rotation", null, v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_29$h, [
            _cache[50] || (_cache[50] = createBaseVNode("label", null, "Opacity", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: __props.layer.opacity?.value ?? 100,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updateOpacity(v)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        createBaseVNode("div", _hoisted_30$g, [
          _cache[60] || (_cache[60] = createBaseVNode("div", { class: "section-title" }, "Path Options", -1)),
          createBaseVNode("div", _hoisted_31$d, [
            _cache[53] || (_cache[53] = createBaseVNode("label", null, "Path", -1)),
            createBaseVNode("select", {
              value: textData.value.pathLayerId || "",
              onChange: _cache[17] || (_cache[17] = (e) => updateData("pathLayerId", e.target.value || null)),
              class: "full-select"
            }, [
              _cache[52] || (_cache[52] = createBaseVNode("option", { value: "" }, "None", -1)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (l) => {
                return openBlock(), createElementBlock("option", {
                  key: l.id,
                  value: l.id
                }, toDisplayString(l.name), 9, _hoisted_33$d);
              }), 128))
            ], 40, _hoisted_32$d)
          ]),
          textData.value.pathLayerId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_34$d, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Path Offset %", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Offset") ?? textData.value.pathOffset ?? 0,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Path Offset", v)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isPropertyAnimated("Path Offset") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_35$c, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "First Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("First Margin") ?? textData.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateAnimatable("First Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_36$c, [
              _cache[56] || (_cache[56] = createBaseVNode("label", null, "Last Margin", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Last Margin") ?? textData.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Last Margin", v)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathReversed,
                  onChange: _cache[22] || (_cache[22] = ($event) => updateData("pathReversed", !textData.value.pathReversed))
                }, null, 40, _hoisted_38$c),
                _cache[57] || (_cache[57] = createTextVNode(" Reverse Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_39$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathPerpendicularToPath ?? true,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateData("pathPerpendicularToPath", !textData.value.pathPerpendicularToPath))
                }, null, 40, _hoisted_40$b),
                _cache[58] || (_cache[58] = createTextVNode(" Perpendicular to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_41$9, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: textData.value.pathForceAlignment,
                  onChange: _cache[24] || (_cache[24] = ($event) => updateData("pathForceAlignment", !textData.value.pathForceAlignment))
                }, null, 40, _hoisted_42$8),
                _cache[59] || (_cache[59] = createTextVNode(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_43$8, [
          _cache[67] || (_cache[67] = createBaseVNode("div", { class: "section-title" }, "Advanced", -1)),
          createBaseVNode("div", _hoisted_44$8, [
            _cache[61] || (_cache[61] = createBaseVNode("label", null, "Tracking", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Tracking") || textData.value.tracking || 0,
              "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Tracking", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_45$8, [
            _cache[62] || (_cache[62] = createBaseVNode("label", null, "Line Spacing", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Line Spacing") || textData.value.lineSpacing || 0,
              "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateAnimatable("Line Spacing", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_46$8, [
            _cache[63] || (_cache[63] = createBaseVNode("label", null, "Baseline", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Baseline Shift") || textData.value.baselineShift || 0,
              "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateAnimatable("Baseline Shift", v))
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_47$8, [
            _cache[64] || (_cache[64] = createBaseVNode("label", null, "Char Offset", -1)),
            createVNode(unref(ScrubableNumber), {
              modelValue: getPropertyValue("Character Offset") || textData.value.characterOffset || 0,
              "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateAnimatable("Character Offset", v)),
              precision: 0
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_48$8, [
            _cache[65] || (_cache[65] = createBaseVNode("label", null, "Case", -1)),
            createBaseVNode("div", _hoisted_49$8, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "uppercase" }),
                onClick: _cache[29] || (_cache[29] = ($event) => toggleCase("uppercase")),
                title: "All Caps"
              }, "AA", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "smallcaps" }),
                onClick: _cache[30] || (_cache[30] = ($event) => toggleCase("smallcaps")),
                title: "Small Caps"
              }, "", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.textCase === "normal" || !textData.value.textCase }),
                onClick: _cache[31] || (_cache[31] = ($event) => toggleCase("normal")),
                title: "Normal"
              }, "Aa", 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_50$7, [
            _cache[66] || (_cache[66] = createBaseVNode("label", null, "Script", -1)),
            createBaseVNode("div", _hoisted_51$7, [
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "super" }),
                onClick: _cache[32] || (_cache[32] = ($event) => toggleVerticalAlign("super")),
                title: "Superscript"
              }, "X", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "sub" }),
                onClick: _cache[33] || (_cache[33] = ($event) => toggleVerticalAlign("sub")),
                title: "Subscript"
              }, "X", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: textData.value.verticalAlign === "baseline" || !textData.value.verticalAlign }),
                onClick: _cache[34] || (_cache[34] = ($event) => toggleVerticalAlign("baseline")),
                title: "Normal"
              }, "X", 2)
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_52$7, [
          createBaseVNode("label", null, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: textData.value.perCharacter3D,
              onChange: _cache[35] || (_cache[35] = ($event) => updateData("perCharacter3D", !textData.value.perCharacter3D))
            }, null, 40, _hoisted_53$7),
            _cache[68] || (_cache[68] = createTextVNode(" Enable Per-Character 3D ", -1))
          ])
        ]),
        createBaseVNode("div", _hoisted_54$7, [
          createBaseVNode("div", _hoisted_55$7, [
            _cache[70] || (_cache[70] = createBaseVNode("div", { class: "section-title" }, "Animators", -1)),
            createBaseVNode("div", _hoisted_56$7, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[36] || (_cache[36] = ($event) => selectedPreset.value = $event),
                class: "preset-select"
              }, [
                _cache[69] || (_cache[69] = createBaseVNode("option", { value: "" }, "Add Preset...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(animatorPresets), (preset) => {
                  return openBlock(), createElementBlock("option", {
                    key: preset.type,
                    value: preset.type
                  }, toDisplayString(preset.name), 9, _hoisted_57$6);
                }), 128))
              ], 512), [
                [vModelSelect, selectedPreset.value]
              ]),
              createBaseVNode("button", {
                class: "add-btn",
                onClick: _cache[37] || (_cache[37] = ($event) => {
                  addAnimator(selectedPreset.value || void 0);
                  selectedPreset.value = "";
                }),
                title: "Add Animator"
              }, "+")
            ])
          ]),
          animators.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_58$6, " No animators. Add one to animate text per-character. ")) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(animators.value, (animator) => {
            return openBlock(), createElementBlock("div", {
              key: animator.id,
              class: "animator-item"
            }, [
              createBaseVNode("div", {
                class: "animator-header",
                onClick: ($event) => toggleAnimatorExpanded(animator.id)
              }, [
                createBaseVNode("span", _hoisted_60$6, toDisplayString(expandedAnimators.value.has(animator.id) ? "" : ""), 1),
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: animator.enabled,
                  onClick: withModifiers(($event) => toggleAnimatorEnabled(animator.id), ["stop"]),
                  class: "animator-enabled"
                }, null, 8, _hoisted_61$6),
                createBaseVNode("input", {
                  type: "text",
                  value: animator.name,
                  onInput: (e) => updateAnimatorName(animator.id, e.target.value),
                  onClick: _cache[38] || (_cache[38] = withModifiers(() => {
                  }, ["stop"])),
                  class: "animator-name"
                }, null, 40, _hoisted_62$6),
                createBaseVNode("div", _hoisted_63$4, [
                  createBaseVNode("button", {
                    onClick: withModifiers(($event) => duplicateAnimator(animator.id), ["stop"]),
                    title: "Duplicate"
                  }, "", 8, _hoisted_64$4),
                  createBaseVNode("button", {
                    onClick: withModifiers(($event) => removeAnimator(animator.id), ["stop"]),
                    title: "Remove"
                  }, "", 8, _hoisted_65$4)
                ])
              ], 8, _hoisted_59$6),
              expandedAnimators.value.has(animator.id) ? (openBlock(), createElementBlock("div", _hoisted_66$4, [
                createBaseVNode("div", _hoisted_67$4, [
                  _cache[79] || (_cache[79] = createBaseVNode("div", { class: "subsection-title" }, "Range Selector", -1)),
                  createBaseVNode("div", _hoisted_68$4, [
                    _cache[72] || (_cache[72] = createBaseVNode("label", null, "Based On", -1)),
                    createBaseVNode("select", {
                      value: animator.rangeSelector.basedOn,
                      onChange: (e) => updateRangeSelector(animator.id, "basedOn", e.target.value),
                      class: "full-select"
                    }, [..._cache[71] || (_cache[71] = [
                      createBaseVNode("option", { value: "characters" }, "Characters", -1),
                      createBaseVNode("option", { value: "words" }, "Words", -1),
                      createBaseVNode("option", { value: "lines" }, "Lines", -1)
                    ])], 40, _hoisted_69$4)
                  ]),
                  createBaseVNode("div", _hoisted_70$4, [
                    _cache[73] || (_cache[73] = createBaseVNode("label", null, "Start %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.start.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "start", v),
                      min: 0,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_71$4, [
                    _cache[74] || (_cache[74] = createBaseVNode("label", null, "End %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.end.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "end", v),
                      min: 0,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_72$4, [
                    _cache[75] || (_cache[75] = createBaseVNode("label", null, "Offset %", -1)),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: animator.rangeSelector.offset.value,
                      "onUpdate:modelValue": (v) => updateRangeSelector(animator.id, "offset", v),
                      min: -100,
                      max: 100,
                      precision: 1
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_73$4, [
                    _cache[77] || (_cache[77] = createBaseVNode("label", null, "Shape", -1)),
                    createBaseVNode("select", {
                      value: animator.rangeSelector.shape,
                      onChange: (e) => updateRangeSelector(animator.id, "shape", e.target.value),
                      class: "full-select"
                    }, [..._cache[76] || (_cache[76] = [
                      createStaticVNode('<option value="square" data-v-7181e2be>Square</option><option value="ramp_up" data-v-7181e2be>Ramp Up</option><option value="ramp_down" data-v-7181e2be>Ramp Down</option><option value="triangle" data-v-7181e2be>Triangle</option><option value="round" data-v-7181e2be>Round</option><option value="smooth" data-v-7181e2be>Smooth</option>', 6)
                    ])], 40, _hoisted_74$4)
                  ]),
                  createBaseVNode("div", _hoisted_75$4, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: animator.rangeSelector.randomizeOrder,
                        onChange: ($event) => updateRangeSelector(animator.id, "randomizeOrder", !animator.rangeSelector.randomizeOrder)
                      }, null, 40, _hoisted_76$4),
                      _cache[78] || (_cache[78] = createTextVNode(" Randomize Order ", -1))
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_77$4, [
                  _cache[88] || (_cache[88] = createBaseVNode("div", { class: "subsection-title" }, "Properties", -1)),
                  createBaseVNode("div", _hoisted_78$4, [
                    createBaseVNode("label", _hoisted_79$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "position"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "position", hasAnimatorProperty(animator, "position") ? null : { x: 0, y: 0 })
                      }, null, 40, _hoisted_80$4),
                      _cache[80] || (_cache[80] = createTextVNode(" Position ", -1))
                    ]),
                    hasAnimatorProperty(animator, "position") ? (openBlock(), createElementBlock("div", _hoisted_81$4, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "position")?.x ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "position", { ...getAnimatorPropertyValue(animator, "position"), x: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "position")?.y ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "position", { ...getAnimatorPropertyValue(animator, "position"), y: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_82$4, [
                    createBaseVNode("label", _hoisted_83$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "scale"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "scale", hasAnimatorProperty(animator, "scale") ? null : { x: 100, y: 100 })
                      }, null, 40, _hoisted_84$4),
                      _cache[81] || (_cache[81] = createTextVNode(" Scale % ", -1))
                    ]),
                    hasAnimatorProperty(animator, "scale") ? (openBlock(), createElementBlock("div", _hoisted_85$4, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "scale")?.x ?? 100,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "scale", { ...getAnimatorPropertyValue(animator, "scale"), x: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "scale")?.y ?? 100,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "scale", { ...getAnimatorPropertyValue(animator, "scale"), y: v })
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_86$4, [
                    createBaseVNode("label", _hoisted_87$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "rotation"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "rotation", hasAnimatorProperty(animator, "rotation") ? null : 0)
                      }, null, 40, _hoisted_88$4),
                      _cache[82] || (_cache[82] = createTextVNode(" Rotation ", -1))
                    ]),
                    hasAnimatorProperty(animator, "rotation") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "rotation") ?? 0,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "rotation", v),
                      min: -360,
                      max: 360
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_89$4, [
                    createBaseVNode("label", _hoisted_90$4, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "opacity"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "opacity", hasAnimatorProperty(animator, "opacity") ? null : 100)
                      }, null, 40, _hoisted_91$3),
                      _cache[83] || (_cache[83] = createTextVNode(" Opacity ", -1))
                    ]),
                    hasAnimatorProperty(animator, "opacity") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "opacity") ?? 100,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "opacity", v),
                      min: 0,
                      max: 100
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_92$3, [
                    createBaseVNode("label", _hoisted_93$2, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "blur"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "blur", hasAnimatorProperty(animator, "blur") ? null : { x: 0, y: 0 })
                      }, null, 40, _hoisted_94$2),
                      _cache[84] || (_cache[84] = createTextVNode(" Blur ", -1))
                    ]),
                    hasAnimatorProperty(animator, "blur") ? (openBlock(), createElementBlock("div", _hoisted_95$1, [
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "blur")?.x ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "blur", { ...getAnimatorPropertyValue(animator, "blur"), x: v }),
                        min: 0,
                        max: 100
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getAnimatorPropertyValue(animator, "blur")?.y ?? 0,
                        "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "blur", { ...getAnimatorPropertyValue(animator, "blur"), y: v }),
                        min: 0,
                        max: 100
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_96$1, [
                    createBaseVNode("label", _hoisted_97$1, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "tracking"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "tracking", hasAnimatorProperty(animator, "tracking") ? null : 0)
                      }, null, 40, _hoisted_98$1),
                      _cache[85] || (_cache[85] = createTextVNode(" Tracking ", -1))
                    ]),
                    hasAnimatorProperty(animator, "tracking") ? (openBlock(), createBlock(unref(ScrubableNumber), {
                      key: 0,
                      modelValue: getAnimatorPropertyValue(animator, "tracking") ?? 0,
                      "onUpdate:modelValue": (v) => updateAnimatorProperty(animator.id, "tracking", v),
                      min: -200,
                      max: 200
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_99$1, [
                    createBaseVNode("label", _hoisted_100$1, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "fillColor"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "fillColor", hasAnimatorProperty(animator, "fillColor") ? null : "#ffffff")
                      }, null, 40, _hoisted_101$1),
                      _cache[86] || (_cache[86] = createTextVNode(" Fill Color ", -1))
                    ]),
                    hasAnimatorProperty(animator, "fillColor") ? (openBlock(), createElementBlock("input", {
                      key: 0,
                      type: "color",
                      value: getAnimatorPropertyValue(animator, "fillColor") || "#ffffff",
                      onInput: (e) => updateAnimatorProperty(animator.id, "fillColor", e.target.value),
                      class: "color-input"
                    }, null, 40, _hoisted_102$1)) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_103$1, [
                    createBaseVNode("label", _hoisted_104$1, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: hasAnimatorProperty(animator, "strokeColor"),
                        onChange: ($event) => updateAnimatorProperty(animator.id, "strokeColor", hasAnimatorProperty(animator, "strokeColor") ? null : "#000000")
                      }, null, 40, _hoisted_105$1),
                      _cache[87] || (_cache[87] = createTextVNode(" Stroke Color ", -1))
                    ]),
                    hasAnimatorProperty(animator, "strokeColor") ? (openBlock(), createElementBlock("input", {
                      key: 0,
                      type: "color",
                      value: getAnimatorPropertyValue(animator, "strokeColor") || "#000000",
                      onInput: (e) => updateAnimatorProperty(animator.id, "strokeColor", e.target.value),
                      class: "color-input"
                    }, null, 40, _hoisted_106$1)) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]);
          }), 128))
        ])
      ]);
    };
  }
});

const TextProperties = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__scopeId", "data-v-7181e2be"]]);

const BUILT_IN_PARTICLE_PRESETS = [
  {
    id: "builtin-particle-fire",
    name: "Fire",
    category: "particle",
    description: "Flickering flame effect",
    tags: ["fire", "flame", "hot"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 500,
      emissionRate: 50,
      lifespan: 1.5,
      startSize: 20,
      endSize: 5,
      startColor: "#ff6600",
      endColor: "#ffff00",
      gravity: { x: 0, y: -50, z: 0 },
      turbulenceStrength: 30,
      velocitySpread: 30
    }
  },
  {
    id: "builtin-particle-snow",
    name: "Snow",
    category: "particle",
    description: "Gentle falling snowflakes",
    tags: ["snow", "winter", "cold"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 300,
      emissionRate: 20,
      lifespan: 5,
      startSize: 8,
      endSize: 6,
      startColor: "#ffffff",
      endColor: "#ccccff",
      gravity: { x: 0, y: 20, z: 0 },
      turbulenceStrength: 10,
      velocitySpread: 20
    }
  },
  {
    id: "builtin-particle-sparks",
    name: "Sparks",
    category: "particle",
    description: "Electric spark burst",
    tags: ["sparks", "electric", "energy"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 200,
      emissionRate: 100,
      lifespan: 0.5,
      startSize: 4,
      endSize: 1,
      startColor: "#ffff00",
      endColor: "#ff8800",
      gravity: { x: 0, y: 100, z: 0 },
      velocitySpread: 180
    }
  },
  {
    id: "builtin-particle-smoke",
    name: "Smoke",
    category: "particle",
    description: "Rising smoke plume",
    tags: ["smoke", "fog", "mist"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 100,
      emissionRate: 10,
      lifespan: 4,
      startSize: 30,
      endSize: 80,
      startColor: "#444444",
      endColor: "#888888",
      gravity: { x: 0, y: -30, z: 0 },
      turbulenceStrength: 20
    }
  },
  {
    id: "builtin-particle-confetti",
    name: "Confetti",
    category: "particle",
    description: "Colorful celebration confetti",
    tags: ["confetti", "celebration", "party"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    config: {
      maxParticles: 500,
      emissionRate: 100,
      lifespan: 3,
      startSize: 10,
      endSize: 8,
      gravity: { x: 0, y: 50, z: 0 },
      velocitySpread: 60,
      turbulenceStrength: 15
    }
  }
];
const BUILT_IN_PATH_EFFECT_PRESETS = [
  {
    id: "builtin-path-sketch",
    name: "Sketchy",
    category: "path-effect",
    description: "Hand-drawn sketch effect",
    tags: ["sketch", "hand-drawn", "rough"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    effects: [
      {
        id: "roughen-1",
        type: "roughen",
        enabled: true,
        order: 0,
        size: { id: "r-size", name: "Size", type: "number", value: 3, animated: false, keyframes: [] },
        detail: { id: "r-detail", name: "Detail", type: "number", value: 4, animated: false, keyframes: [] },
        seed: 12345
      }
    ]
  },
  {
    id: "builtin-path-wavy",
    name: "Wavy",
    category: "path-effect",
    description: "Smooth wave deformation",
    tags: ["wave", "smooth", "organic"],
    isBuiltIn: true,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    effects: [
      {
        id: "wave-1",
        type: "wave",
        enabled: true,
        order: 0,
        amplitude: { id: "w-amp", name: "Amplitude", type: "number", value: 10, animated: false, keyframes: [] },
        frequency: { id: "w-freq", name: "Frequency", type: "number", value: 3, animated: false, keyframes: [] },
        phase: { id: "w-phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
        waveType: "sine"
      }
    ]
  }
];

const STORAGE_KEY = "weyl-presets";
const PRESET_VERSION = 1;
const usePresetStore = defineStore("presets", {
  state: () => ({
    presets: [],
    loaded: false
  }),
  getters: {
    /**
     * Get all presets including built-ins
     */
    allPresets() {
      return [
        ...BUILT_IN_PARTICLE_PRESETS,
        ...BUILT_IN_PATH_EFFECT_PRESETS,
        ...this.presets
      ];
    },
    /**
     * Get presets by category
     */
    byCategory() {
      return (category) => this.allPresets.filter((p) => p.category === category);
    },
    /**
     * Get particle presets
     */
    particlePresets() {
      return this.allPresets.filter((p) => p.category === "particle");
    },
    /**
     * Get path effect presets
     */
    pathEffectPresets() {
      return this.allPresets.filter((p) => p.category === "path-effect");
    },
    /**
     * Get camera shake presets
     */
    cameraShakePresets() {
      return this.allPresets.filter((p) => p.category === "camera-shake");
    },
    /**
     * Get camera trajectory presets
     */
    cameraTrajectoryPresets() {
      return this.allPresets.filter((p) => p.category === "camera-trajectory");
    },
    /**
     * Get text style presets
     */
    textStylePresets() {
      return this.allPresets.filter((p) => p.category === "text-style");
    },
    /**
     * Get animation presets
     */
    animationPresets() {
      return this.allPresets.filter((p) => p.category === "animation");
    },
    /**
     * Search presets by name or tags
     */
    search() {
      return (query, category) => {
        const q = query.toLowerCase();
        let results = this.allPresets;
        if (category) {
          results = results.filter((p) => p.category === category);
        }
        return results.filter(
          (p) => p.name.toLowerCase().includes(q) || p.description?.toLowerCase().includes(q) || p.tags?.some((t) => t.toLowerCase().includes(q))
        );
      };
    },
    /**
     * Get user-created presets (excludes built-ins)
     */
    userPresets() {
      return this.presets.filter((p) => !p.isBuiltIn);
    }
  },
  actions: {
    /**
     * Initialize the preset store from localStorage
     */
    initialize() {
      if (this.loaded) return;
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const data = JSON.parse(stored);
          this.presets = data.presets || [];
        }
      } catch (error) {
        console.warn("Failed to load presets from localStorage:", error);
        this.presets = [];
      }
      this.loaded = true;
    },
    /**
     * Save presets to localStorage
     */
    persist() {
      try {
        const collection = {
          version: PRESET_VERSION,
          presets: this.presets.filter((p) => !p.isBuiltIn),
          exportedAt: Date.now()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(collection));
      } catch (error) {
        console.error("Failed to save presets to localStorage:", error);
      }
    },
    /**
     * Generate a unique preset ID
     */
    generateId() {
      return `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },
    /**
     * Add a new preset
     */
    addPreset(preset) {
      const id = this.generateId();
      const now = Date.now();
      const newPreset = {
        ...preset,
        id,
        createdAt: now,
        updatedAt: now
      };
      this.presets.push(newPreset);
      this.persist();
      return id;
    },
    /**
     * Update an existing preset
     */
    updatePreset(id, updates) {
      const index = this.presets.findIndex((p) => p.id === id);
      if (index === -1) return false;
      if (this.presets[index].isBuiltIn) return false;
      this.presets[index] = {
        ...this.presets[index],
        ...updates,
        updatedAt: Date.now()
      };
      this.persist();
      return true;
    },
    /**
     * Delete a preset
     */
    deletePreset(id) {
      const index = this.presets.findIndex((p) => p.id === id);
      if (index === -1) return false;
      if (this.presets[index].isBuiltIn) return false;
      this.presets.splice(index, 1);
      this.persist();
      return true;
    },
    /**
     * Duplicate a preset
     */
    duplicatePreset(id) {
      const preset = this.allPresets.find((p) => p.id === id);
      if (!preset) return null;
      const duplicated = {
        ...preset,
        name: `${preset.name} (Copy)`,
        isBuiltIn: false
      };
      delete duplicated.id;
      delete duplicated.createdAt;
      delete duplicated.updatedAt;
      return this.addPreset(duplicated);
    },
    /**
     * Get a preset by ID
     */
    getPreset(id) {
      return this.allPresets.find((p) => p.id === id);
    },
    /**
     * Export presets to JSON string
     */
    exportPresets(presetIds) {
      const presetsToExport = presetIds ? this.allPresets.filter((p) => presetIds.includes(p.id)) : this.userPresets;
      const collection = {
        version: PRESET_VERSION,
        presets: presetsToExport,
        exportedAt: Date.now()
      };
      return JSON.stringify(collection, null, 2);
    },
    /**
     * Import presets from JSON string
     */
    importPresets(jsonString) {
      const errors = [];
      let imported = 0;
      try {
        const collection = JSON.parse(jsonString);
        if (!collection.presets || !Array.isArray(collection.presets)) {
          errors.push("Invalid preset collection format");
          return { imported, errors };
        }
        for (const preset of collection.presets) {
          try {
            if (!preset.name || !preset.category) {
              errors.push(`Skipped preset: missing name or category`);
              continue;
            }
            const existing = this.presets.find(
              (p) => p.name === preset.name && p.category === preset.category
            );
            if (existing) {
              this.updatePreset(existing.id, preset);
            } else {
              const { id, createdAt, updatedAt, ...presetData } = preset;
              this.addPreset(presetData);
            }
            imported++;
          } catch (err) {
            errors.push(`Failed to import preset "${preset.name}": ${err}`);
          }
        }
      } catch (err) {
        errors.push(`Failed to parse JSON: ${err}`);
      }
      return { imported, errors };
    },
    /**
     * Save current particle config as a preset
     */
    saveParticlePreset(name, config, options) {
      return this.addPreset({
        name,
        category: "particle",
        config,
        ...options
      });
    },
    /**
     * Save path effects as a preset
     */
    savePathEffectPreset(name, effects, options) {
      return this.addPreset({
        name,
        category: "path-effect",
        effects,
        ...options
      });
    },
    /**
     * Save camera shake config as a preset
     */
    saveCameraShakePreset(name, config, options) {
      return this.addPreset({
        name,
        category: "camera-shake",
        config,
        ...options
      });
    },
    /**
     * Save camera trajectory config as a preset
     */
    saveCameraTrajectoryPreset(name, config, options) {
      return this.addPreset({
        name,
        category: "camera-trajectory",
        config,
        ...options
      });
    },
    /**
     * Save text style as a preset
     */
    saveTextStylePreset(name, style, options) {
      return this.addPreset({
        name,
        category: "text-style",
        style,
        ...options
      });
    },
    /**
     * Clear all user presets
     */
    clearUserPresets() {
      this.presets = this.presets.filter((p) => p.isBuiltIn);
      this.persist();
    }
  }
});

const PARTICLE_UPDATE_SHADER = (
  /* wgsl */
  `
// Uniform buffer for simulation config
struct SimConfig {
  gravity: f32,
  windX: f32,
  windY: f32,
  friction: f32,
  deltaTime: f32,
  particleCount: u32,
  gravityWellCount: u32,
  vortexCount: u32,
}

// Gravity well data
struct GravityWell {
  x: f32,
  y: f32,
  radius: f32,
  strength: f32,
  falloff: f32,
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

// Vortex data
struct Vortex {
  x: f32,
  y: f32,
  radius: f32,
  strength: f32,
  inwardPull: f32,
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

@group(0) @binding(0) var<uniform> config: SimConfig;
@group(0) @binding(1) var<storage, read_write> positions: array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> velocities: array<vec4<f32>>;
@group(0) @binding(3) var<storage, read_write> properties: array<vec4<f32>>;
@group(0) @binding(4) var<storage, read> gravityWells: array<GravityWell>;
@group(0) @binding(5) var<storage, read> vortices: array<Vortex>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let idx = global_id.x;
  if (idx >= config.particleCount) {
    return;
  }

  // Load particle data
  var pos = positions[idx];
  var vel = velocities[idx];
  var props = properties[idx];

  let x = pos.x;
  let y = pos.y;
  var vx = vel.x;
  var vy = vel.y;
  let age = props.x;
  let lifetime = props.y;

  // Skip dead particles
  if (age > lifetime) {
    return;
  }

  // Store previous position
  pos.z = x;
  pos.w = y;

  // Apply gravity
  vy += config.gravity * 0.001 * config.deltaTime;

  // Apply wind
  vx += config.windX * config.deltaTime;
  vy += config.windY * config.deltaTime;

  // Apply gravity wells
  for (var i = 0u; i < config.gravityWellCount; i++) {
    let well = gravityWells[i];
    let dx = well.x - x;
    let dy = well.y - y;
    let dist = sqrt(dx * dx + dy * dy);

    if (dist < well.radius && dist > 0.001) {
      var force = well.strength * 0.0001;

      // Apply falloff
      if (well.falloff == 1.0) {
        // Linear
        force *= 1.0 - (dist / well.radius);
      } else if (well.falloff == 2.0) {
        // Quadratic
        let t = 1.0 - (dist / well.radius);
        force *= t * t;
      }
      // falloff == 0.0 is constant (no modification)

      // Normalize and apply
      let nx = dx / dist;
      let ny = dy / dist;
      vx += nx * force * config.deltaTime;
      vy += ny * force * config.deltaTime;
    }
  }

  // Apply vortices
  for (var i = 0u; i < config.vortexCount; i++) {
    let vortex = vortices[i];
    let dx = vortex.x - x;
    let dy = vortex.y - y;
    let dist = sqrt(dx * dx + dy * dy);

    if (dist < vortex.radius && dist > 0.001) {
      let influence = 1.0 - (dist / vortex.radius);
      let strength = vortex.strength * 0.0001 * influence;

      // Perpendicular (tangential) force
      let nx = dx / dist;
      let ny = dy / dist;
      let perpX = -ny;
      let perpY = nx;

      vx += perpX * strength * config.deltaTime;
      vy += perpY * strength * config.deltaTime;

      // Inward pull
      let inward = vortex.inwardPull * 0.0001 * influence;
      vx += nx * inward * config.deltaTime;
      vy += ny * inward * config.deltaTime;
    }
  }

  // Apply friction
  let frictionFactor = 1.0 - config.friction;
  vx *= frictionFactor;
  vy *= frictionFactor;

  // Update position
  pos.x = x + vx * config.deltaTime;
  pos.y = y + vy * config.deltaTime;

  // Update velocity
  vel.x = vx;
  vel.y = vy;

  // Increment age
  props.x = age + config.deltaTime;

  // Write back
  positions[idx] = pos;
  velocities[idx] = vel;
  properties[idx] = props;
}
`
);
const PARTICLE_SIZE_MODULATION_SHADER = (
  /* wgsl */
  `
struct ModConfig {
  particleCount: u32,
  sizeOverLifeEnabled: u32,
  sizeStart: f32,
  sizeEnd: f32,
  easingType: u32,  // 0=linear, 1=easeIn, 2=easeOut, 3=easeInOut
  _pad1: f32,
  _pad2: f32,
  _pad3: f32,
}

@group(0) @binding(0) var<uniform> config: ModConfig;
@group(0) @binding(1) var<storage, read_write> properties: array<vec4<f32>>;

fn easeInQuad(t: f32) -> f32 {
  return t * t;
}

fn easeOutQuad(t: f32) -> f32 {
  return t * (2.0 - t);
}

fn easeInOutQuad(t: f32) -> f32 {
  if (t < 0.5) {
    return 2.0 * t * t;
  }
  return -1.0 + (4.0 - 2.0 * t) * t;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let idx = global_id.x;
  if (idx >= config.particleCount) {
    return;
  }

  var props = properties[idx];
  let age = props.x;
  let lifetime = props.y;
  let baseSize = props.w;

  if (age > lifetime) {
    return;
  }

  if (config.sizeOverLifeEnabled == 1u) {
    var t = clamp(age / lifetime, 0.0, 1.0);

    // Apply easing
    if (config.easingType == 1u) {
      t = easeInQuad(t);
    } else if (config.easingType == 2u) {
      t = easeOutQuad(t);
    } else if (config.easingType == 3u) {
      t = easeInOutQuad(t);
    }

    let sizeMult = mix(config.sizeStart, config.sizeEnd, t);
    props.z = baseSize * sizeMult;
  }

  properties[idx] = props;
}
`
);
class ParticleGPUCompute {
  device = null;
  adapter = null;
  // Pipelines
  updatePipeline = null;
  modulationPipeline = null;
  // Buffers
  positionBuffer = null;
  velocityBuffer = null;
  propertiesBuffer = null;
  colorBuffer = null;
  configBuffer = null;
  gravityWellBuffer = null;
  vortexBuffer = null;
  modulationConfigBuffer = null;
  // Staging buffers for readback
  stagingPositionBuffer = null;
  stagingVelocityBuffer = null;
  stagingPropertiesBuffer = null;
  stagingColorBuffer = null;
  // Bind groups
  updateBindGroup = null;
  modulationBindGroup = null;
  // Config
  maxParticles = 0;
  initialized = false;
  // Static capability check
  static _capabilities = null;
  // ============================================================================
  // STATIC METHODS
  // ============================================================================
  /**
   * Check WebGPU availability and capabilities
   */
  static async checkCapabilities() {
    if (this._capabilities) {
      return this._capabilities;
    }
    if (!navigator.gpu) {
      this._capabilities = {
        available: false,
        adapter: null,
        device: null,
        maxWorkgroupSize: 0,
        maxBufferSize: 0
      };
      return this._capabilities;
    }
    try {
      const adapter = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (!adapter) {
        this._capabilities = {
          available: false,
          adapter: null,
          device: null,
          maxWorkgroupSize: 0,
          maxBufferSize: 0
        };
        return this._capabilities;
      }
      const device = await adapter.requestDevice({
        requiredLimits: {
          maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
          maxComputeWorkgroupSizeX: 256
        }
      });
      this._capabilities = {
        available: true,
        adapter,
        device,
        maxWorkgroupSize: device.limits.maxComputeWorkgroupSizeX,
        maxBufferSize: device.limits.maxStorageBufferBindingSize
      };
      return this._capabilities;
    } catch (error) {
      console.warn("WebGPU initialization failed:", error);
      this._capabilities = {
        available: false,
        adapter: null,
        device: null,
        maxWorkgroupSize: 0,
        maxBufferSize: 0
      };
      return this._capabilities;
    }
  }
  /**
   * Check if WebGPU compute is available
   */
  static async isAvailable() {
    const caps = await this.checkCapabilities();
    return caps.available;
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Initialize the GPU compute engine
   */
  async initialize(maxParticles) {
    const caps = await ParticleGPUCompute.checkCapabilities();
    if (!caps.available || !caps.device) {
      console.warn("WebGPU not available, using CPU fallback");
      return false;
    }
    this.device = caps.device;
    this.adapter = caps.adapter;
    this.maxParticles = maxParticles;
    try {
      await this.createPipelines();
      this.createBuffers();
      this.initialized = true;
      console.log(`WebGPU Particle Compute initialized for ${maxParticles} particles`);
      return true;
    } catch (error) {
      console.error("Failed to initialize WebGPU compute:", error);
      this.dispose();
      return false;
    }
  }
  /**
   * Create compute shader pipelines
   */
  async createPipelines() {
    if (!this.device) return;
    const updateShaderModule = this.device.createShaderModule({
      label: "Particle Update Shader",
      code: PARTICLE_UPDATE_SHADER
    });
    this.updatePipeline = this.device.createComputePipeline({
      label: "Particle Update Pipeline",
      layout: "auto",
      compute: {
        module: updateShaderModule,
        entryPoint: "main"
      }
    });
    const modulationShaderModule = this.device.createShaderModule({
      label: "Particle Modulation Shader",
      code: PARTICLE_SIZE_MODULATION_SHADER
    });
    this.modulationPipeline = this.device.createComputePipeline({
      label: "Particle Modulation Pipeline",
      layout: "auto",
      compute: {
        module: modulationShaderModule,
        entryPoint: "main"
      }
    });
  }
  /**
   * Create GPU buffers for particle data
   */
  createBuffers() {
    if (!this.device) return;
    const particleCount = this.maxParticles;
    this.positionBuffer = this.device.createBuffer({
      label: "Particle Positions",
      size: particleCount * 4 * 4,
      // 4 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.velocityBuffer = this.device.createBuffer({
      label: "Particle Velocities",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.propertiesBuffer = this.device.createBuffer({
      label: "Particle Properties",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.colorBuffer = this.device.createBuffer({
      label: "Particle Colors",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
    });
    this.configBuffer = this.device.createBuffer({
      label: "Simulation Config",
      size: 32,
      // 8 values * 4 bytes, aligned to 16
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.gravityWellBuffer = this.device.createBuffer({
      label: "Gravity Wells",
      size: 16 * 8 * 4,
      // 16 wells * 8 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.vortexBuffer = this.device.createBuffer({
      label: "Vortices",
      size: 16 * 8 * 4,
      // 16 vortices * 8 floats * 4 bytes
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.modulationConfigBuffer = this.device.createBuffer({
      label: "Modulation Config",
      size: 32,
      // 8 values * 4 bytes
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.stagingPositionBuffer = this.device.createBuffer({
      label: "Staging Positions",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingVelocityBuffer = this.device.createBuffer({
      label: "Staging Velocities",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingPropertiesBuffer = this.device.createBuffer({
      label: "Staging Properties",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    this.stagingColorBuffer = this.device.createBuffer({
      label: "Staging Colors",
      size: particleCount * 4 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
  }
  // ============================================================================
  // DATA UPLOAD
  // ============================================================================
  /**
   * Upload particle data to GPU
   */
  uploadParticles(data) {
    if (!this.device || !this.initialized) return;
    this.device.queue.writeBuffer(this.positionBuffer, 0, data.positions);
    this.device.queue.writeBuffer(this.velocityBuffer, 0, data.velocities);
    this.device.queue.writeBuffer(this.propertiesBuffer, 0, data.properties);
    this.device.queue.writeBuffer(this.colorBuffer, 0, data.colors);
  }
  /**
   * Upload simulation config to GPU
   */
  uploadConfig(config, gravityWells, vortices) {
    if (!this.device || !this.initialized) return;
    const configData = new Float32Array([
      config.gravity,
      config.windX,
      config.windY,
      config.friction,
      config.deltaTime,
      0,
      0,
      0
      // Padding for alignment
    ]);
    const configView = new DataView(configData.buffer);
    configView.setUint32(20, config.maxParticles, true);
    configView.setUint32(24, gravityWells.length, true);
    configView.setUint32(28, vortices.length, true);
    this.device.queue.writeBuffer(this.configBuffer, 0, configData);
    const wellData = new Float32Array(16 * 8);
    gravityWells.forEach((well, i) => {
      if (i >= 16) return;
      const offset = i * 8;
      wellData[offset + 0] = well.x;
      wellData[offset + 1] = well.y;
      wellData[offset + 2] = well.radius;
      wellData[offset + 3] = well.strength;
      wellData[offset + 4] = well.falloff;
    });
    this.device.queue.writeBuffer(this.gravityWellBuffer, 0, wellData);
    const vortexData = new Float32Array(16 * 8);
    vortices.forEach((vortex, i) => {
      if (i >= 16) return;
      const offset = i * 8;
      vortexData[offset + 0] = vortex.x;
      vortexData[offset + 1] = vortex.y;
      vortexData[offset + 2] = vortex.radius;
      vortexData[offset + 3] = vortex.strength;
      vortexData[offset + 4] = vortex.inwardPull;
    });
    this.device.queue.writeBuffer(this.vortexBuffer, 0, vortexData);
  }
  // ============================================================================
  // COMPUTE DISPATCH
  // ============================================================================
  /**
   * Run the particle update compute shader
   */
  dispatchUpdate(particleCount) {
    if (!this.device || !this.initialized || !this.updatePipeline) return;
    if (!this.updateBindGroup) {
      this.updateBindGroup = this.device.createBindGroup({
        label: "Update Bind Group",
        layout: this.updatePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: this.configBuffer } },
          { binding: 1, resource: { buffer: this.positionBuffer } },
          { binding: 2, resource: { buffer: this.velocityBuffer } },
          { binding: 3, resource: { buffer: this.propertiesBuffer } },
          { binding: 4, resource: { buffer: this.gravityWellBuffer } },
          { binding: 5, resource: { buffer: this.vortexBuffer } }
        ]
      });
    }
    const commandEncoder = this.device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.updatePipeline);
    passEncoder.setBindGroup(0, this.updateBindGroup);
    const workgroupCount = Math.ceil(particleCount / 256);
    passEncoder.dispatchWorkgroups(workgroupCount);
    passEncoder.end();
    this.device.queue.submit([commandEncoder.finish()]);
  }
  /**
   * Run the size modulation compute shader
   */
  dispatchModulation(particleCount, sizeOverLifeEnabled, sizeStart, sizeEnd, easingType) {
    if (!this.device || !this.initialized || !this.modulationPipeline) return;
    const modConfig = new Uint32Array([
      particleCount,
      sizeOverLifeEnabled ? 1 : 0,
      0,
      0
      // Will be replaced with floats
    ]);
    const modConfigView = new DataView(modConfig.buffer);
    modConfigView.setFloat32(8, sizeStart, true);
    modConfigView.setFloat32(12, sizeEnd, true);
    modConfigView.setUint32(16, easingType, true);
    this.device.queue.writeBuffer(this.modulationConfigBuffer, 0, modConfig);
    if (!this.modulationBindGroup) {
      this.modulationBindGroup = this.device.createBindGroup({
        label: "Modulation Bind Group",
        layout: this.modulationPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: this.modulationConfigBuffer } },
          { binding: 1, resource: { buffer: this.propertiesBuffer } }
        ]
      });
    }
    const commandEncoder = this.device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(this.modulationPipeline);
    passEncoder.setBindGroup(0, this.modulationBindGroup);
    const workgroupCount = Math.ceil(particleCount / 256);
    passEncoder.dispatchWorkgroups(workgroupCount);
    passEncoder.end();
    this.device.queue.submit([commandEncoder.finish()]);
  }
  // ============================================================================
  // DATA READBACK
  // ============================================================================
  /**
   * Read particle data back from GPU
   * Note: This is async and can be slow - prefer keeping data on GPU when possible
   */
  async readbackParticles(particleCount) {
    if (!this.device || !this.initialized) {
      return {
        positions: new Float32Array(0),
        velocities: new Float32Array(0),
        properties: new Float32Array(0),
        colors: new Float32Array(0),
        count: 0
      };
    }
    const byteSize = particleCount * 4 * 4;
    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(this.positionBuffer, 0, this.stagingPositionBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.velocityBuffer, 0, this.stagingVelocityBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.propertiesBuffer, 0, this.stagingPropertiesBuffer, 0, byteSize);
    commandEncoder.copyBufferToBuffer(this.colorBuffer, 0, this.stagingColorBuffer, 0, byteSize);
    this.device.queue.submit([commandEncoder.finish()]);
    await this.stagingPositionBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingVelocityBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingPropertiesBuffer.mapAsync(GPUMapMode.READ);
    await this.stagingColorBuffer.mapAsync(GPUMapMode.READ);
    const positions = new Float32Array(this.stagingPositionBuffer.getMappedRange().slice(0));
    const velocities = new Float32Array(this.stagingVelocityBuffer.getMappedRange().slice(0));
    const properties = new Float32Array(this.stagingPropertiesBuffer.getMappedRange().slice(0));
    const colors = new Float32Array(this.stagingColorBuffer.getMappedRange().slice(0));
    this.stagingPositionBuffer.unmap();
    this.stagingVelocityBuffer.unmap();
    this.stagingPropertiesBuffer.unmap();
    this.stagingColorBuffer.unmap();
    return {
      positions,
      velocities,
      properties,
      colors,
      count: particleCount
    };
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  /**
   * Dispose GPU resources
   */
  dispose() {
    this.positionBuffer?.destroy();
    this.velocityBuffer?.destroy();
    this.propertiesBuffer?.destroy();
    this.colorBuffer?.destroy();
    this.configBuffer?.destroy();
    this.gravityWellBuffer?.destroy();
    this.vortexBuffer?.destroy();
    this.modulationConfigBuffer?.destroy();
    this.stagingPositionBuffer?.destroy();
    this.stagingVelocityBuffer?.destroy();
    this.stagingPropertiesBuffer?.destroy();
    this.stagingColorBuffer?.destroy();
    this.positionBuffer = null;
    this.velocityBuffer = null;
    this.propertiesBuffer = null;
    this.colorBuffer = null;
    this.configBuffer = null;
    this.gravityWellBuffer = null;
    this.vortexBuffer = null;
    this.modulationConfigBuffer = null;
    this.stagingPositionBuffer = null;
    this.stagingVelocityBuffer = null;
    this.stagingPropertiesBuffer = null;
    this.stagingColorBuffer = null;
    this.updateBindGroup = null;
    this.modulationBindGroup = null;
    this.updatePipeline = null;
    this.modulationPipeline = null;
    this.device = null;
    this.adapter = null;
    this.initialized = false;
  }
  /**
   * Check if engine is initialized
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Get max particles this instance supports
   */
  getMaxParticles() {
    return this.maxParticles;
  }
}

const _hoisted_1$B = { class: "particle-properties" };
const _hoisted_2$A = { class: "property-section presets-section" };
const _hoisted_3$A = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$A = { class: "preset-controls" };
const _hoisted_5$A = { label: "Built-in" };
const _hoisted_6$A = ["value"];
const _hoisted_7$A = {
  key: 0,
  label: "User Presets"
};
const _hoisted_8$z = ["value"];
const _hoisted_9$z = ["disabled"];
const _hoisted_10$z = { class: "preset-actions" };
const _hoisted_11$y = ["disabled"];
const _hoisted_12$w = { class: "preset-dialog" };
const _hoisted_13$w = { class: "dialog-field" };
const _hoisted_14$t = { class: "dialog-field" };
const _hoisted_15$s = { class: "dialog-field" };
const _hoisted_16$r = { class: "dialog-actions" };
const _hoisted_17$q = ["disabled"];
const _hoisted_18$p = { class: "property-section" };
const _hoisted_19$p = {
  key: 0,
  class: "section-content"
};
const _hoisted_20$p = { class: "property-row" };
const _hoisted_21$o = ["value"];
const _hoisted_22$n = { class: "value-display" };
const _hoisted_23$m = { class: "property-row" };
const _hoisted_24$j = ["value"];
const _hoisted_25$i = { class: "value-display" };
const _hoisted_26$h = { class: "property-row" };
const _hoisted_27$g = ["value"];
const _hoisted_28$g = { class: "value-display" };
const _hoisted_29$g = { class: "property-row" };
const _hoisted_30$f = ["value"];
const _hoisted_31$c = { class: "value-display" };
const _hoisted_32$c = { class: "property-row" };
const _hoisted_33$c = ["value"];
const _hoisted_34$c = { class: "value-display" };
const _hoisted_35$b = { class: "property-row" };
const _hoisted_36$b = ["value"];
const _hoisted_37$b = { class: "property-row" };
const _hoisted_38$b = ["value"];
const _hoisted_39$b = { class: "value-display" };
const _hoisted_40$a = { class: "property-row checkbox-row" };
const _hoisted_41$8 = ["checked"];
const _hoisted_42$7 = { class: "property-row checkbox-row gpu-row" };
const _hoisted_43$7 = ["checked", "disabled"];
const _hoisted_44$7 = {
  key: 0,
  class: "gpu-status available"
};
const _hoisted_45$7 = {
  key: 1,
  class: "gpu-status unavailable"
};
const _hoisted_46$7 = { class: "property-section" };
const _hoisted_47$7 = {
  key: 0,
  class: "section-content"
};
const _hoisted_48$7 = ["onClick"];
const _hoisted_49$7 = ["value", "onInput"];
const _hoisted_50$6 = { class: "enabled-toggle" };
const _hoisted_51$6 = ["checked", "onChange"];
const _hoisted_52$6 = ["onClick"];
const _hoisted_53$6 = {
  key: 0,
  class: "emitter-content"
};
const _hoisted_54$6 = { class: "property-row" };
const _hoisted_55$6 = ["value", "onInput"];
const _hoisted_56$6 = { class: "value-display" };
const _hoisted_57$5 = { class: "property-row" };
const _hoisted_58$5 = ["value", "onInput"];
const _hoisted_59$5 = { class: "value-display" };
const _hoisted_60$5 = { class: "property-row" };
const _hoisted_61$5 = ["value", "onInput"];
const _hoisted_62$5 = { class: "value-display" };
const _hoisted_63$3 = { class: "property-row" };
const _hoisted_64$3 = ["value", "onInput"];
const _hoisted_65$3 = { class: "value-display" };
const _hoisted_66$3 = { class: "property-row" };
const _hoisted_67$3 = ["value", "onInput"];
const _hoisted_68$3 = { class: "value-display" };
const _hoisted_69$3 = { class: "property-row" };
const _hoisted_70$3 = ["value", "onInput"];
const _hoisted_71$3 = { class: "value-display" };
const _hoisted_72$3 = { class: "property-row" };
const _hoisted_73$3 = ["value", "onInput"];
const _hoisted_74$3 = { class: "value-display" };
const _hoisted_75$3 = { class: "property-row" };
const _hoisted_76$3 = ["value", "onInput"];
const _hoisted_77$3 = { class: "value-display" };
const _hoisted_78$3 = { class: "property-row" };
const _hoisted_79$3 = ["value", "onInput"];
const _hoisted_80$3 = { class: "property-row" };
const _hoisted_81$3 = ["value", "onInput"];
const _hoisted_82$3 = { class: "value-display" };
const _hoisted_83$3 = { class: "property-row" };
const _hoisted_84$3 = ["value", "onInput"];
const _hoisted_85$3 = { class: "value-display" };
const _hoisted_86$3 = { class: "property-row" };
const _hoisted_87$3 = ["value", "onInput"];
const _hoisted_88$3 = { class: "value-display" };
const _hoisted_89$3 = { class: "property-row checkbox-row" };
const _hoisted_90$3 = ["checked", "onChange"];
const _hoisted_91$2 = {
  key: 0,
  class: "property-row"
};
const _hoisted_92$2 = ["value", "onInput"];
const _hoisted_93$1 = { class: "value-display" };
const _hoisted_94$1 = { class: "property-row" };
const _hoisted_95 = ["value", "onChange"];
const _hoisted_96 = {
  key: 1,
  class: "property-row"
};
const _hoisted_97 = ["value", "onInput"];
const _hoisted_98 = { class: "value-display" };
const _hoisted_99 = {
  key: 2,
  class: "property-row"
};
const _hoisted_100 = ["value", "onInput"];
const _hoisted_101 = { class: "value-display" };
const _hoisted_102 = {
  key: 3,
  class: "property-row"
};
const _hoisted_103 = ["value", "onInput"];
const _hoisted_104 = { class: "value-display" };
const _hoisted_105 = {
  key: 4,
  class: "property-row"
};
const _hoisted_106 = ["value", "onInput"];
const _hoisted_107 = { class: "value-display" };
const _hoisted_108 = {
  key: 5,
  class: "property-row"
};
const _hoisted_109 = ["value", "onInput"];
const _hoisted_110 = { class: "value-display" };
const _hoisted_111 = {
  key: 6,
  class: "property-row checkbox-row"
};
const _hoisted_112 = ["checked", "onChange"];
const _hoisted_113 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_114 = { class: "property-section" };
const _hoisted_115 = {
  key: 0,
  class: "section-content"
};
const _hoisted_116 = { class: "force-tabs" };
const _hoisted_117 = {
  key: 0,
  class: "force-list"
};
const _hoisted_118 = { class: "force-header" };
const _hoisted_119 = ["value", "onInput"];
const _hoisted_120 = { class: "enabled-toggle" };
const _hoisted_121 = ["checked", "onChange"];
const _hoisted_122 = ["onClick"];
const _hoisted_123 = { class: "property-row" };
const _hoisted_124 = ["value", "onInput"];
const _hoisted_125 = { class: "value-display" };
const _hoisted_126 = { class: "property-row" };
const _hoisted_127 = ["value", "onInput"];
const _hoisted_128 = { class: "value-display" };
const _hoisted_129 = { class: "property-row" };
const _hoisted_130 = ["value", "onInput"];
const _hoisted_131 = { class: "value-display" };
const _hoisted_132 = { class: "property-row" };
const _hoisted_133 = ["value", "onInput"];
const _hoisted_134 = { class: "value-display" };
const _hoisted_135 = { class: "property-row" };
const _hoisted_136 = ["value", "onChange"];
const _hoisted_137 = {
  key: 1,
  class: "force-list"
};
const _hoisted_138 = { class: "force-header" };
const _hoisted_139 = ["value", "onInput"];
const _hoisted_140 = { class: "enabled-toggle" };
const _hoisted_141 = ["checked", "onChange"];
const _hoisted_142 = ["onClick"];
const _hoisted_143 = { class: "property-row" };
const _hoisted_144 = ["value", "onInput"];
const _hoisted_145 = { class: "value-display" };
const _hoisted_146 = { class: "property-row" };
const _hoisted_147 = ["value", "onInput"];
const _hoisted_148 = { class: "value-display" };
const _hoisted_149 = { class: "property-row" };
const _hoisted_150 = ["value", "onInput"];
const _hoisted_151 = { class: "value-display" };
const _hoisted_152 = { class: "property-row" };
const _hoisted_153 = ["value", "onInput"];
const _hoisted_154 = { class: "value-display" };
const _hoisted_155 = { class: "property-row" };
const _hoisted_156 = ["value", "onInput"];
const _hoisted_157 = { class: "value-display" };
const _hoisted_158 = { class: "property-row" };
const _hoisted_159 = ["value", "onInput"];
const _hoisted_160 = { class: "value-display" };
const _hoisted_161 = { class: "property-section" };
const _hoisted_162 = {
  key: 0,
  class: "section-content"
};
const _hoisted_163 = { class: "force-header" };
const _hoisted_164 = { class: "enabled-toggle" };
const _hoisted_165 = ["checked", "onChange"];
const _hoisted_166 = ["onClick"];
const _hoisted_167 = { class: "property-row" };
const _hoisted_168 = ["value", "onInput"];
const _hoisted_169 = { class: "value-display" };
const _hoisted_170 = { class: "property-row" };
const _hoisted_171 = ["value", "onInput"];
const _hoisted_172 = { class: "value-display" };
const _hoisted_173 = { class: "property-row" };
const _hoisted_174 = ["value", "onInput"];
const _hoisted_175 = { class: "value-display" };
const _hoisted_176 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_177 = { class: "property-section" };
const _hoisted_178 = {
  key: 0,
  class: "section-content"
};
const _hoisted_179 = { class: "force-header" };
const _hoisted_180 = ["value", "onChange"];
const _hoisted_181 = ["value"];
const _hoisted_182 = { class: "enabled-toggle" };
const _hoisted_183 = ["checked", "onChange"];
const _hoisted_184 = ["onClick"];
const _hoisted_185 = { class: "property-row" };
const _hoisted_186 = ["value", "onChange"];
const _hoisted_187 = { class: "property-row" };
const _hoisted_188 = ["value", "onInput"];
const _hoisted_189 = { class: "value-display" };
const _hoisted_190 = { class: "property-row" };
const _hoisted_191 = ["value", "onInput"];
const _hoisted_192 = { class: "value-display" };
const _hoisted_193 = { class: "property-row" };
const _hoisted_194 = ["value", "onInput"];
const _hoisted_195 = { class: "value-display" };
const _hoisted_196 = { class: "property-row" };
const _hoisted_197 = ["value", "onInput"];
const _hoisted_198 = { class: "value-display" };
const _hoisted_199 = { class: "property-row" };
const _hoisted_200 = ["value", "onInput"];
const _hoisted_201 = { class: "value-display" };
const _hoisted_202 = { class: "property-row" };
const _hoisted_203 = ["value", "onInput"];
const _hoisted_204 = { class: "value-display" };
const _hoisted_205 = { class: "property-row" };
const _hoisted_206 = ["value", "onInput"];
const _hoisted_207 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_208 = { class: "property-section" };
const _hoisted_209 = {
  key: 0,
  class: "section-content"
};
const _hoisted_210 = { class: "modulation-header" };
const _hoisted_211 = ["value", "onChange"];
const _hoisted_212 = ["value"];
const _hoisted_213 = ["onClick"];
const _hoisted_214 = { class: "property-row" };
const _hoisted_215 = ["value", "onChange"];
const _hoisted_216 = { class: "property-row" };
const _hoisted_217 = ["value", "onInput"];
const _hoisted_218 = { class: "property-row" };
const _hoisted_219 = ["value", "onInput"];
const _hoisted_220 = { class: "property-row" };
const _hoisted_221 = ["value", "onChange"];
const _hoisted_222 = {
  key: 0,
  class: "empty-message"
};
const _hoisted_223 = { class: "property-section" };
const _hoisted_224 = {
  key: 0,
  class: "section-content"
};
const _hoisted_225 = { class: "property-row" };
const _hoisted_226 = ["value"];
const _hoisted_227 = { class: "property-row" };
const _hoisted_228 = ["value"];
const _hoisted_229 = { class: "property-row checkbox-row" };
const _hoisted_230 = ["checked"];
const _hoisted_231 = {
  key: 0,
  class: "property-row"
};
const _hoisted_232 = ["value"];
const _hoisted_233 = { class: "value-display" };
const _hoisted_234 = {
  key: 1,
  class: "property-row"
};
const _hoisted_235 = ["value"];
const _hoisted_236 = { class: "value-display" };
const _hoisted_237 = { class: "property-row checkbox-row" };
const _hoisted_238 = ["checked"];
const _hoisted_239 = {
  key: 2,
  class: "property-row"
};
const _hoisted_240 = ["value"];
const _hoisted_241 = { class: "value-display" };
const _hoisted_242 = {
  key: 3,
  class: "property-row"
};
const _hoisted_243 = ["value"];
const _hoisted_244 = { class: "value-display" };
const _hoisted_245 = { class: "property-row checkbox-row" };
const _hoisted_246 = ["checked"];
const _hoisted_247 = {
  key: 4,
  class: "property-row"
};
const _hoisted_248 = ["value"];
const _hoisted_249 = { class: "value-display" };
const _hoisted_250 = {
  key: 5,
  class: "property-row"
};
const _hoisted_251 = ["value"];
const _hoisted_252 = { class: "value-display" };
const _hoisted_253 = { class: "property-row checkbox-row" };
const _hoisted_254 = ["checked"];
const _hoisted_255 = {
  key: 6,
  class: "property-row"
};
const _hoisted_256 = ["value"];
const _hoisted_257 = { class: "value-display" };
const _hoisted_258 = {
  key: 7,
  class: "property-row"
};
const _hoisted_259 = ["value"];
const _hoisted_260 = { class: "value-display" };
const _hoisted_261 = {
  key: 8,
  class: "property-row"
};
const _hoisted_262 = ["value"];
const _hoisted_263 = { class: "value-display" };
const _hoisted_264 = {
  key: 9,
  class: "property-row"
};
const _hoisted_265 = ["value"];
const _hoisted_266 = { class: "value-display" };
const _hoisted_267 = {
  key: 10,
  class: "property-row checkbox-row"
};
const _hoisted_268 = ["checked"];
const _hoisted_269 = { class: "particle-count" };
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const presetStore = usePresetStore();
    presetStore.initialize();
    const webgpuAvailable = ref(false);
    onMounted(async () => {
      webgpuAvailable.value = await ParticleGPUCompute.isAvailable();
    });
    const selectedPresetId = ref("");
    const showSaveDialog = ref(false);
    const newPresetName = ref("");
    const newPresetDescription = ref("");
    const newPresetTags = ref("");
    const builtInPresets = computed(
      () => presetStore.particlePresets.filter((p) => p.isBuiltIn)
    );
    const userPresets = computed(
      () => presetStore.particlePresets.filter((p) => !p.isBuiltIn)
    );
    const isBuiltInPreset = computed(() => {
      if (!selectedPresetId.value) return false;
      const preset = presetStore.getPreset(selectedPresetId.value);
      return preset?.isBuiltIn ?? false;
    });
    const props = __props;
    const emit = __emit;
    const expandedSections = ref(/* @__PURE__ */ new Set(["system", "emitters"]));
    const expandedEmitters = ref(/* @__PURE__ */ new Set());
    const forceTab = ref("wells");
    const layerData = computed(() => {
      const data = props.layer.data;
      return data || {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: false,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [],
        gravityWells: [],
        vortices: [],
        modulations: [],
        renderOptions: {
          blendMode: "additive",
          renderTrails: false,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: false,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: false,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: false,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: true
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
    });
    const systemConfig = computed(() => layerData.value.systemConfig);
    const emitters = computed(() => layerData.value.emitters);
    const gravityWells = computed(() => layerData.value.gravityWells);
    const vortices = computed(() => layerData.value.vortices);
    const modulations = computed(() => layerData.value.modulations);
    const renderOptions = computed(() => layerData.value.renderOptions);
    const turbulenceFields = computed(() => layerData.value.turbulenceFields || []);
    const subEmitters = computed(() => layerData.value.subEmitters || []);
    const connections = computed(() => renderOptions.value.connections || {
      enabled: false,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: true
    });
    const particleCount = computed(() => props.particleCount);
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleEmitter(id) {
      if (expandedEmitters.value.has(id)) {
        expandedEmitters.value.delete(id);
      } else {
        expandedEmitters.value.add(id);
      }
    }
    function applySelectedPreset() {
      if (!selectedPresetId.value) return;
      const preset = presetStore.getPreset(selectedPresetId.value);
      if (!preset || preset.category !== "particle") return;
      const config = preset.config;
      const updates = {};
      if (config.maxParticles !== void 0) {
        updates.systemConfig = {
          ...systemConfig.value,
          maxParticles: config.maxParticles
        };
      }
      if (config.gravity) {
        updates.systemConfig = {
          ...updates.systemConfig || systemConfig.value,
          gravity: config.gravity.y || 0
        };
      }
      if (config.emissionRate || config.lifespan || config.startSize || config.endSize) {
        const defaultEmitter = emitters.value[0] || createDefaultEmitter();
        updates.emitters = [{
          ...defaultEmitter,
          emissionRate: config.emissionRate ?? defaultEmitter.emissionRate,
          lifespan: config.lifespan ?? defaultEmitter.lifespan,
          startSize: config.startSize ?? defaultEmitter.startSize,
          endSize: config.endSize ?? defaultEmitter.endSize,
          startColor: config.startColor ?? defaultEmitter.startColor,
          endColor: config.endColor ?? defaultEmitter.endColor,
          velocitySpread: config.velocitySpread ?? defaultEmitter.velocitySpread
        }];
      }
      if (config.turbulenceStrength !== void 0) {
        updates.turbulenceFields = [{
          id: "turbulence-from-preset",
          enabled: true,
          strength: config.turbulenceStrength,
          scale: 0.01,
          octaves: 3,
          persistence: 0.5,
          animationSpeed: 1
        }];
      }
      emit("update", updates);
    }
    function createDefaultEmitter() {
      return {
        id: `emitter_${Date.now()}`,
        enabled: true,
        emissionMode: "point",
        emissionRate: 50,
        emissionBurstSize: 10,
        emissionBurstInterval: 0,
        position: { x: 0, y: 0, z: 0 },
        direction: { x: 0, y: -1, z: 0 },
        spread: 30,
        velocity: { min: 50, max: 150 },
        lifespan: 2,
        startSize: 10,
        endSize: 2,
        startColor: "#ffffff",
        endColor: "#ffffff",
        startOpacity: 1,
        endOpacity: 0,
        rotation: { min: 0, max: 360 },
        rotationSpeed: { min: 0, max: 0 },
        velocitySpread: 30
      };
    }
    function saveCurrentAsPreset() {
      if (!newPresetName.value.trim()) return;
      const tags = newPresetTags.value.split(",").map((t) => t.trim()).filter((t) => t.length > 0);
      const emitter = emitters.value[0];
      const turbulence = turbulenceFields.value[0];
      presetStore.saveParticlePreset(
        newPresetName.value.trim(),
        {
          maxParticles: systemConfig.value.maxParticles,
          emissionRate: emitter?.emissionRate,
          lifespan: emitter?.lifespan,
          startSize: emitter?.startSize,
          endSize: emitter?.endSize,
          startColor: emitter?.startColor,
          endColor: emitter?.endColor,
          gravity: { x: 0, y: systemConfig.value.gravity, z: 0 },
          turbulenceStrength: turbulence?.strength,
          velocitySpread: emitter?.velocitySpread
        },
        {
          description: newPresetDescription.value.trim() || void 0,
          tags: tags.length > 0 ? tags : void 0
        }
      );
      showSaveDialog.value = false;
      newPresetName.value = "";
      newPresetDescription.value = "";
      newPresetTags.value = "";
    }
    function deleteSelectedPreset() {
      if (!selectedPresetId.value || isBuiltInPreset.value) return;
      if (confirm("Delete this preset?")) {
        presetStore.deletePreset(selectedPresetId.value);
        selectedPresetId.value = "";
      }
    }
    function updateSystemConfig(key, value) {
      emit("update", {
        systemConfig: { ...systemConfig.value, [key]: value }
      });
    }
    function updateEmitter(id, key, value) {
      const updated = emitters.value.map(
        (e) => e.id === id ? { ...e, [key]: value } : e
      );
      emit("update", { emitters: updated });
    }
    function updateEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateEmitter(id, "color", rgb);
    }
    function addEmitter() {
      const newEmitter = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${emitters.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: true,
        burstOnBeat: false,
        burstCount: 20
      };
      emit("update", { emitters: [...emitters.value, newEmitter] });
      expandedEmitters.value.add(newEmitter.id);
    }
    function removeEmitter(id) {
      emit("update", { emitters: emitters.value.filter((e) => e.id !== id) });
    }
    function updateGravityWell(id, key, value) {
      const updated = gravityWells.value.map(
        (w) => w.id === id ? { ...w, [key]: value } : w
      );
      emit("update", { gravityWells: updated });
    }
    function addGravityWell() {
      const newWell = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${gravityWells.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: true
      };
      emit("update", { gravityWells: [...gravityWells.value, newWell] });
    }
    function removeGravityWell(id) {
      emit("update", { gravityWells: gravityWells.value.filter((w) => w.id !== id) });
    }
    function updateVortex(id, key, value) {
      const updated = vortices.value.map(
        (v) => v.id === id ? { ...v, [key]: value } : v
      );
      emit("update", { vortices: updated });
    }
    function addVortex() {
      const newVortex = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${vortices.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: true
      };
      emit("update", { vortices: [...vortices.value, newVortex] });
    }
    function removeVortex(id) {
      emit("update", { vortices: vortices.value.filter((v) => v.id !== id) });
    }
    function updateModulation(id, key, value) {
      const updated = modulations.value.map(
        (m) => m.id === id ? { ...m, [key]: value } : m
      );
      emit("update", { modulations: updated });
    }
    function addModulation() {
      const newMod = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      emit("update", { modulations: [...modulations.value, newMod] });
    }
    function removeModulation(id) {
      emit("update", { modulations: modulations.value.filter((m) => m.id !== id) });
    }
    function updateRenderOption(key, value) {
      emit("update", {
        renderOptions: { ...renderOptions.value, [key]: value }
      });
    }
    function updateConnection(key, value) {
      emit("update", {
        renderOptions: {
          ...renderOptions.value,
          connections: { ...connections.value, [key]: value }
        }
      });
    }
    function updateTurbulence(id, key, value) {
      const updated = turbulenceFields.value.map(
        (t) => t.id === id ? { ...t, [key]: value } : t
      );
      emit("update", { turbulenceFields: updated });
    }
    function addTurbulence() {
      const newTurb = {
        id: `turb_${Date.now()}`,
        enabled: true,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      emit("update", { turbulenceFields: [...turbulenceFields.value, newTurb] });
    }
    function removeTurbulence(id) {
      emit("update", { turbulenceFields: turbulenceFields.value.filter((t) => t.id !== id) });
    }
    function updateSubEmitter(id, key, value) {
      const updated = subEmitters.value.map(
        (s) => s.id === id ? { ...s, [key]: value } : s
      );
      emit("update", { subEmitters: updated });
    }
    function updateSubEmitterColor(id, hex) {
      const rgb = hexToRgb(hex);
      updateSubEmitter(id, "color", rgb);
    }
    function addSubEmitter() {
      const newSub = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: true
      };
      emit("update", { subEmitters: [...subEmitters.value, newSub] });
    }
    function removeSubEmitter(id) {
      emit("update", { subEmitters: subEmitters.value.filter((s) => s.id !== id) });
    }
    function rgbToHex(rgb) {
      return "#" + rgb.map((c) => c.toString(16).padStart(2, "0")).join("");
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [255, 255, 255];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        createBaseVNode("div", _hoisted_2$A, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("presets"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presets") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[45] || (_cache[45] = createBaseVNode("span", null, "Presets", -1))
          ]),
          expandedSections.value.has("presets") ? (openBlock(), createElementBlock("div", _hoisted_3$A, [
            createBaseVNode("div", _hoisted_4$A, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedPresetId.value = $event),
                class: "preset-select"
              }, [
                _cache[46] || (_cache[46] = createBaseVNode("option", { value: "" }, "Select a preset...", -1)),
                createBaseVNode("optgroup", _hoisted_5$A, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(builtInPresets.value, (p) => {
                    return openBlock(), createElementBlock("option", {
                      key: p.id,
                      value: p.id
                    }, toDisplayString(p.name), 9, _hoisted_6$A);
                  }), 128))
                ]),
                userPresets.value.length > 0 ? (openBlock(), createElementBlock("optgroup", _hoisted_7$A, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(userPresets.value, (p) => {
                    return openBlock(), createElementBlock("option", {
                      key: p.id,
                      value: p.id
                    }, toDisplayString(p.name), 9, _hoisted_8$z);
                  }), 128))
                ])) : createCommentVNode("", true)
              ], 512), [
                [vModelSelect, selectedPresetId.value]
              ]),
              createBaseVNode("button", {
                class: "preset-btn apply",
                onClick: applySelectedPreset,
                disabled: !selectedPresetId.value,
                title: "Apply Preset"
              }, " Apply ", 8, _hoisted_9$z)
            ]),
            createBaseVNode("div", _hoisted_10$z, [
              createBaseVNode("button", {
                class: "preset-btn save",
                onClick: _cache[2] || (_cache[2] = ($event) => showSaveDialog.value = true),
                title: "Save Current Settings as Preset"
              }, " Save Preset "),
              createBaseVNode("button", {
                class: "preset-btn delete",
                onClick: deleteSelectedPreset,
                disabled: !selectedPresetId.value || isBuiltInPreset.value,
                title: "Delete Preset"
              }, " Delete ", 8, _hoisted_11$y)
            ])
          ])) : createCommentVNode("", true)
        ]),
        showSaveDialog.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "preset-dialog-overlay",
          onClick: _cache[7] || (_cache[7] = withModifiers(($event) => showSaveDialog.value = false, ["self"]))
        }, [
          createBaseVNode("div", _hoisted_12$w, [
            _cache[50] || (_cache[50] = createBaseVNode("h3", null, "Save Particle Preset", -1)),
            createBaseVNode("div", _hoisted_13$w, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Name", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newPresetName.value = $event),
                type: "text",
                placeholder: "My Preset"
              }, null, 512), [
                [vModelText, newPresetName.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_14$t, [
              _cache[48] || (_cache[48] = createBaseVNode("label", null, "Description", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newPresetDescription.value = $event),
                type: "text",
                placeholder: "Optional description..."
              }, null, 512), [
                [vModelText, newPresetDescription.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_15$s, [
              _cache[49] || (_cache[49] = createBaseVNode("label", null, "Tags (comma-separated)", -1)),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newPresetTags.value = $event),
                type: "text",
                placeholder: "fire, glow, magic"
              }, null, 512), [
                [vModelText, newPresetTags.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_16$r, [
              createBaseVNode("button", {
                class: "dialog-btn cancel",
                onClick: _cache[6] || (_cache[6] = ($event) => showSaveDialog.value = false)
              }, "Cancel"),
              createBaseVNode("button", {
                class: "dialog-btn save",
                onClick: saveCurrentAsPreset,
                disabled: !newPresetName.value.trim()
              }, "Save", 8, _hoisted_17$q)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_18$p, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[8] || (_cache[8] = ($event) => toggleSection("system"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[51] || (_cache[51] = createBaseVNode("span", null, "System Settings", -1))
          ]),
          expandedSections.value.has("system") ? (openBlock(), createElementBlock("div", _hoisted_19$p, [
            createBaseVNode("div", _hoisted_20$p, [
              _cache[52] || (_cache[52] = createBaseVNode("label", null, "Max Particles", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.maxParticles,
                min: "100",
                max: "50000",
                step: "100",
                onInput: _cache[9] || (_cache[9] = ($event) => updateSystemConfig("maxParticles", Number($event.target.value)))
              }, null, 40, _hoisted_21$o),
              createBaseVNode("span", _hoisted_22$n, toDisplayString(systemConfig.value.maxParticles), 1)
            ]),
            createBaseVNode("div", _hoisted_23$m, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Gravity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.gravity,
                min: "-1000",
                max: "1000",
                step: "10",
                onInput: _cache[10] || (_cache[10] = ($event) => updateSystemConfig("gravity", Number($event.target.value)))
              }, null, 40, _hoisted_24$j),
              createBaseVNode("span", _hoisted_25$i, toDisplayString(systemConfig.value.gravity), 1)
            ]),
            createBaseVNode("div", _hoisted_26$h, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Wind Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windStrength,
                min: "0",
                max: "1000",
                step: "10",
                onInput: _cache[11] || (_cache[11] = ($event) => updateSystemConfig("windStrength", Number($event.target.value)))
              }, null, 40, _hoisted_27$g),
              createBaseVNode("span", _hoisted_28$g, toDisplayString(systemConfig.value.windStrength), 1)
            ]),
            createBaseVNode("div", _hoisted_29$g, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Wind Direction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.windDirection,
                min: "0",
                max: "360",
                step: "5",
                onInput: _cache[12] || (_cache[12] = ($event) => updateSystemConfig("windDirection", Number($event.target.value)))
              }, null, 40, _hoisted_30$f),
              createBaseVNode("span", _hoisted_31$c, toDisplayString(systemConfig.value.windDirection) + "", 1)
            ]),
            createBaseVNode("div", _hoisted_32$c, [
              _cache[56] || (_cache[56] = createBaseVNode("label", null, "Friction", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.friction,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[13] || (_cache[13] = ($event) => updateSystemConfig("friction", Number($event.target.value)))
              }, null, 40, _hoisted_33$c),
              createBaseVNode("span", _hoisted_34$c, toDisplayString(systemConfig.value.friction.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_35$b, [
              _cache[58] || (_cache[58] = createBaseVNode("label", null, "Boundary", -1)),
              createBaseVNode("select", {
                value: systemConfig.value.boundaryBehavior,
                onChange: _cache[14] || (_cache[14] = ($event) => updateSystemConfig("boundaryBehavior", $event.target.value))
              }, [..._cache[57] || (_cache[57] = [
                createBaseVNode("option", { value: "kill" }, "Kill", -1),
                createBaseVNode("option", { value: "bounce" }, "Bounce", -1),
                createBaseVNode("option", { value: "wrap" }, "Wrap", -1)
              ])], 40, _hoisted_36$b)
            ]),
            createBaseVNode("div", _hoisted_37$b, [
              _cache[59] || (_cache[59] = createBaseVNode("label", null, "Warmup Period", -1)),
              createBaseVNode("input", {
                type: "range",
                value: systemConfig.value.warmupPeriod,
                min: "0",
                max: "120",
                step: "1",
                onInput: _cache[15] || (_cache[15] = ($event) => updateSystemConfig("warmupPeriod", Number($event.target.value)))
              }, null, 40, _hoisted_38$b),
              createBaseVNode("span", _hoisted_39$b, toDisplayString(systemConfig.value.warmupPeriod) + "f", 1)
            ]),
            createBaseVNode("div", _hoisted_40$a, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: systemConfig.value.respectMaskBoundary,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateSystemConfig("respectMaskBoundary", $event.target.checked))
                }, null, 40, _hoisted_41$8),
                _cache[60] || (_cache[60] = createTextVNode(" Respect Mask Boundary ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_42$7, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: systemConfig.value.useGPU,
                  disabled: !webgpuAvailable.value,
                  onChange: _cache[17] || (_cache[17] = ($event) => updateSystemConfig("useGPU", $event.target.checked))
                }, null, 40, _hoisted_43$7),
                _cache[61] || (_cache[61] = createTextVNode(" GPU Acceleration ", -1)),
                webgpuAvailable.value ? (openBlock(), createElementBlock("span", _hoisted_44$7, "(WebGPU)")) : (openBlock(), createElementBlock("span", _hoisted_45$7, "(Not Available)"))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_46$7, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[18] || (_cache[18] = ($event) => toggleSection("emitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[63] || (_cache[63] = createBaseVNode("span", null, "Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addEmitter, ["stop"]),
              title: "Add Emitter"
            }, [..._cache[62] || (_cache[62] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("emitters") ? (openBlock(), createElementBlock("div", _hoisted_47$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (emitter) => {
              return openBlock(), createElementBlock("div", {
                key: emitter.id,
                class: "emitter-item"
              }, [
                createBaseVNode("div", {
                  class: "emitter-header",
                  onClick: ($event) => toggleEmitter(emitter.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedEmitters.value.has(emitter.id) ? "pi-chevron-down" : "pi-chevron-right"])
                  }, null, 2),
                  createBaseVNode("input", {
                    type: "text",
                    value: emitter.name,
                    onInput: ($event) => updateEmitter(emitter.id, "name", $event.target.value),
                    onClick: _cache[19] || (_cache[19] = withModifiers(() => {
                    }, ["stop"])),
                    class: "emitter-name"
                  }, null, 40, _hoisted_49$7),
                  createBaseVNode("label", _hoisted_50$6, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: emitter.enabled,
                      onChange: ($event) => updateEmitter(emitter.id, "enabled", $event.target.checked),
                      onClick: _cache[20] || (_cache[20] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 40, _hoisted_51$6)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: withModifiers(($event) => removeEmitter(emitter.id), ["stop"]),
                    title: "Remove"
                  }, [..._cache[64] || (_cache[64] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_52$6)
                ], 8, _hoisted_48$7),
                expandedEmitters.value.has(emitter.id) ? (openBlock(), createElementBlock("div", _hoisted_53$6, [
                  createBaseVNode("div", _hoisted_54$6, [
                    _cache[65] || (_cache[65] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_55$6),
                    createBaseVNode("span", _hoisted_56$6, toDisplayString(emitter.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_57$5, [
                    _cache[66] || (_cache[66] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_58$5),
                    createBaseVNode("span", _hoisted_59$5, toDisplayString(emitter.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_60$5, [
                    _cache[67] || (_cache[67] = createBaseVNode("label", null, "Direction", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.direction,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "direction", Number($event.target.value))
                    }, null, 40, _hoisted_61$5),
                    createBaseVNode("span", _hoisted_62$5, toDisplayString(emitter.direction) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_63$3, [
                    _cache[68] || (_cache[68] = createBaseVNode("label", null, "Spread", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.spread,
                      min: "0",
                      max: "360",
                      step: "5",
                      onInput: ($event) => updateEmitter(emitter.id, "spread", Number($event.target.value))
                    }, null, 40, _hoisted_64$3),
                    createBaseVNode("span", _hoisted_65$3, toDisplayString(emitter.spread) + "", 1)
                  ]),
                  createBaseVNode("div", _hoisted_66$3, [
                    _cache[69] || (_cache[69] = createBaseVNode("label", null, "Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speed,
                      min: "1",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speed", Number($event.target.value))
                    }, null, 40, _hoisted_67$3),
                    createBaseVNode("span", _hoisted_68$3, toDisplayString(emitter.speed), 1)
                  ]),
                  createBaseVNode("div", _hoisted_69$3, [
                    _cache[70] || (_cache[70] = createBaseVNode("label", null, "Speed Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.speedVariance,
                      min: "0",
                      max: "500",
                      step: "10",
                      onInput: ($event) => updateEmitter(emitter.id, "speedVariance", Number($event.target.value))
                    }, null, 40, _hoisted_70$3),
                    createBaseVNode("span", _hoisted_71$3, toDisplayString(emitter.speedVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_72$3, [
                    _cache[71] || (_cache[71] = createBaseVNode("label", null, "Size", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.size,
                      min: "1",
                      max: "400",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "size", Number($event.target.value))
                    }, null, 40, _hoisted_73$3),
                    createBaseVNode("span", _hoisted_74$3, toDisplayString(emitter.size) + "px", 1)
                  ]),
                  createBaseVNode("div", _hoisted_75$3, [
                    _cache[72] || (_cache[72] = createBaseVNode("label", null, "Size Variance", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.sizeVariance,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "sizeVariance", Number($event.target.value))
                    }, null, 40, _hoisted_76$3),
                    createBaseVNode("span", _hoisted_77$3, toDisplayString(emitter.sizeVariance), 1)
                  ]),
                  createBaseVNode("div", _hoisted_78$3, [
                    _cache[73] || (_cache[73] = createBaseVNode("label", null, "Color", -1)),
                    createBaseVNode("input", {
                      type: "color",
                      value: rgbToHex(emitter.color),
                      onInput: ($event) => updateEmitterColor(emitter.id, $event.target.value)
                    }, null, 40, _hoisted_79$3)
                  ]),
                  createBaseVNode("div", _hoisted_80$3, [
                    _cache[74] || (_cache[74] = createBaseVNode("label", null, "Emission Rate", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.emissionRate,
                      min: "0.1",
                      max: "100",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "emissionRate", Number($event.target.value))
                    }, null, 40, _hoisted_81$3),
                    createBaseVNode("span", _hoisted_82$3, toDisplayString(emitter.emissionRate.toFixed(1)) + "/s", 1)
                  ]),
                  createBaseVNode("div", _hoisted_83$3, [
                    _cache[75] || (_cache[75] = createBaseVNode("label", null, "Lifetime", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.particleLifetime,
                      min: "1",
                      max: "300",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "particleLifetime", Number($event.target.value))
                    }, null, 40, _hoisted_84$3),
                    createBaseVNode("span", _hoisted_85$3, toDisplayString(emitter.particleLifetime) + "f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_86$3, [
                    _cache[76] || (_cache[76] = createBaseVNode("label", null, "Initial Burst", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.initialBurst,
                      min: "0",
                      max: "1",
                      step: "0.1",
                      onInput: ($event) => updateEmitter(emitter.id, "initialBurst", Number($event.target.value))
                    }, null, 40, _hoisted_87$3),
                    createBaseVNode("span", _hoisted_88$3, toDisplayString((emitter.initialBurst * 100).toFixed(0)) + "%", 1)
                  ]),
                  createBaseVNode("div", _hoisted_89$3, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.burstOnBeat,
                        onChange: ($event) => updateEmitter(emitter.id, "burstOnBeat", $event.target.checked)
                      }, null, 40, _hoisted_90$3),
                      _cache[77] || (_cache[77] = createTextVNode(" Burst on Beat ", -1))
                    ])
                  ]),
                  emitter.burstOnBeat ? (openBlock(), createElementBlock("div", _hoisted_91$2, [
                    _cache[78] || (_cache[78] = createBaseVNode("label", null, "Burst Count", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.burstCount,
                      min: "1",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateEmitter(emitter.id, "burstCount", Number($event.target.value))
                    }, null, 40, _hoisted_92$2),
                    createBaseVNode("span", _hoisted_93$1, toDisplayString(emitter.burstCount), 1)
                  ])) : createCommentVNode("", true),
                  _cache[87] || (_cache[87] = createBaseVNode("div", { class: "subsection-divider" }, "Emitter Shape", -1)),
                  createBaseVNode("div", _hoisted_94$1, [
                    _cache[80] || (_cache[80] = createBaseVNode("label", null, "Shape", -1)),
                    createBaseVNode("select", {
                      value: emitter.shape || "point",
                      onChange: ($event) => updateEmitter(emitter.id, "shape", $event.target.value)
                    }, [..._cache[79] || (_cache[79] = [
                      createStaticVNode('<option value="point" data-v-65c727f4>Point</option><option value="line" data-v-65c727f4>Line</option><option value="circle" data-v-65c727f4>Circle</option><option value="box" data-v-65c727f4>Box</option><option value="sphere" data-v-65c727f4>Sphere</option><option value="ring" data-v-65c727f4>Ring</option><option value="spline" data-v-65c727f4>Spline Path</option>', 7)
                    ])], 40, _hoisted_95)
                  ]),
                  emitter.shape === "circle" || emitter.shape === "sphere" || emitter.shape === "ring" ? (openBlock(), createElementBlock("div", _hoisted_96, [
                    _cache[81] || (_cache[81] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeRadius || 0.1,
                      min: "0.01",
                      max: "0.5",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeRadius", Number($event.target.value))
                    }, null, 40, _hoisted_97),
                    createBaseVNode("span", _hoisted_98, toDisplayString((emitter.shapeRadius || 0.1).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "ring" ? (openBlock(), createElementBlock("div", _hoisted_99, [
                    _cache[82] || (_cache[82] = createBaseVNode("label", null, "Inner Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeInnerRadius || 0.05,
                      min: "0",
                      max: "0.4",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeInnerRadius", Number($event.target.value))
                    }, null, 40, _hoisted_100),
                    createBaseVNode("span", _hoisted_101, toDisplayString((emitter.shapeInnerRadius || 0.05).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "box" ? (openBlock(), createElementBlock("div", _hoisted_102, [
                    _cache[83] || (_cache[83] = createBaseVNode("label", null, "Width", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeWidth || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeWidth", Number($event.target.value))
                    }, null, 40, _hoisted_103),
                    createBaseVNode("span", _hoisted_104, toDisplayString((emitter.shapeWidth || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "box" ? (openBlock(), createElementBlock("div", _hoisted_105, [
                    _cache[84] || (_cache[84] = createBaseVNode("label", null, "Height", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeHeight || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeHeight", Number($event.target.value))
                    }, null, 40, _hoisted_106),
                    createBaseVNode("span", _hoisted_107, toDisplayString((emitter.shapeHeight || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape === "line" ? (openBlock(), createElementBlock("div", _hoisted_108, [
                    _cache[85] || (_cache[85] = createBaseVNode("label", null, "Length", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: emitter.shapeWidth || 0.2,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateEmitter(emitter.id, "shapeWidth", Number($event.target.value))
                    }, null, 40, _hoisted_109),
                    createBaseVNode("span", _hoisted_110, toDisplayString((emitter.shapeWidth || 0.2).toFixed(2)), 1)
                  ])) : createCommentVNode("", true),
                  emitter.shape !== "point" && emitter.shape !== "spline" ? (openBlock(), createElementBlock("div", _hoisted_111, [
                    createBaseVNode("label", null, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: emitter.emitFromEdge,
                        onChange: ($event) => updateEmitter(emitter.id, "emitFromEdge", $event.target.checked)
                      }, null, 40, _hoisted_112),
                      _cache[86] || (_cache[86] = createTextVNode(" Emit from Edge Only ", -1))
                    ])
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            emitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_113, " No emitters. Click + to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_114, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[21] || (_cache[21] = ($event) => toggleSection("forces"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[88] || (_cache[88] = createBaseVNode("span", null, "Force Fields", -1))
          ]),
          expandedSections.value.has("forces") ? (openBlock(), createElementBlock("div", _hoisted_115, [
            createBaseVNode("div", _hoisted_116, [
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "wells" }),
                onClick: _cache[22] || (_cache[22] = ($event) => forceTab.value = "wells")
              }, " Gravity Wells ", 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: forceTab.value === "vortices" }),
                onClick: _cache[23] || (_cache[23] = ($event) => forceTab.value = "vortices")
              }, " Vortices ", 2)
            ]),
            forceTab.value === "wells" ? (openBlock(), createElementBlock("div", _hoisted_117, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addGravityWell
              }, [..._cache[89] || (_cache[89] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Gravity Well ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(gravityWells.value, (well) => {
                return openBlock(), createElementBlock("div", {
                  key: well.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_118, [
                    createBaseVNode("input", {
                      type: "text",
                      value: well.name,
                      onInput: ($event) => updateGravityWell(well.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_119),
                    createBaseVNode("label", _hoisted_120, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: well.enabled,
                        onChange: ($event) => updateGravityWell(well.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_121)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeGravityWell(well.id)
                    }, [..._cache[90] || (_cache[90] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_122)
                  ]),
                  createBaseVNode("div", _hoisted_123, [
                    _cache[91] || (_cache[91] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_124),
                    createBaseVNode("span", _hoisted_125, toDisplayString(well.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_126, [
                    _cache[92] || (_cache[92] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_127),
                    createBaseVNode("span", _hoisted_128, toDisplayString(well.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_129, [
                    _cache[93] || (_cache[93] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.strength,
                      min: "-1000",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateGravityWell(well.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_130),
                    createBaseVNode("span", _hoisted_131, toDisplayString(well.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_132, [
                    _cache[94] || (_cache[94] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: well.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateGravityWell(well.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_133),
                    createBaseVNode("span", _hoisted_134, toDisplayString(well.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_135, [
                    _cache[96] || (_cache[96] = createBaseVNode("label", null, "Falloff", -1)),
                    createBaseVNode("select", {
                      value: well.falloff,
                      onChange: ($event) => updateGravityWell(well.id, "falloff", $event.target.value)
                    }, [..._cache[95] || (_cache[95] = [
                      createBaseVNode("option", { value: "linear" }, "Linear", -1),
                      createBaseVNode("option", { value: "quadratic" }, "Quadratic", -1),
                      createBaseVNode("option", { value: "constant" }, "Constant", -1)
                    ])], 40, _hoisted_136)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            forceTab.value === "vortices" ? (openBlock(), createElementBlock("div", _hoisted_137, [
              createBaseVNode("button", {
                class: "add-btn full-width",
                onClick: addVortex
              }, [..._cache[97] || (_cache[97] = [
                createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
                createTextVNode(" Add Vortex ", -1)
              ])]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(vortices.value, (vortex) => {
                return openBlock(), createElementBlock("div", {
                  key: vortex.id,
                  class: "force-item"
                }, [
                  createBaseVNode("div", _hoisted_138, [
                    createBaseVNode("input", {
                      type: "text",
                      value: vortex.name,
                      onInput: ($event) => updateVortex(vortex.id, "name", $event.target.value),
                      class: "force-name"
                    }, null, 40, _hoisted_139),
                    createBaseVNode("label", _hoisted_140, [
                      createBaseVNode("input", {
                        type: "checkbox",
                        checked: vortex.enabled,
                        onChange: ($event) => updateVortex(vortex.id, "enabled", $event.target.checked)
                      }, null, 40, _hoisted_141)
                    ]),
                    createBaseVNode("button", {
                      class: "remove-btn",
                      onClick: ($event) => removeVortex(vortex.id)
                    }, [..._cache[98] || (_cache[98] = [
                      createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                    ])], 8, _hoisted_142)
                  ]),
                  createBaseVNode("div", _hoisted_143, [
                    _cache[99] || (_cache[99] = createBaseVNode("label", null, "Position X", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.x,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "x", Number($event.target.value))
                    }, null, 40, _hoisted_144),
                    createBaseVNode("span", _hoisted_145, toDisplayString(vortex.x.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_146, [
                    _cache[100] || (_cache[100] = createBaseVNode("label", null, "Position Y", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.y,
                      min: "0",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "y", Number($event.target.value))
                    }, null, 40, _hoisted_147),
                    createBaseVNode("span", _hoisted_148, toDisplayString(vortex.y.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_149, [
                    _cache[101] || (_cache[101] = createBaseVNode("label", null, "Strength", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.strength,
                      min: "0",
                      max: "1000",
                      step: "10",
                      onInput: ($event) => updateVortex(vortex.id, "strength", Number($event.target.value))
                    }, null, 40, _hoisted_150),
                    createBaseVNode("span", _hoisted_151, toDisplayString(vortex.strength), 1)
                  ]),
                  createBaseVNode("div", _hoisted_152, [
                    _cache[102] || (_cache[102] = createBaseVNode("label", null, "Radius", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.radius,
                      min: "0.01",
                      max: "1",
                      step: "0.01",
                      onInput: ($event) => updateVortex(vortex.id, "radius", Number($event.target.value))
                    }, null, 40, _hoisted_153),
                    createBaseVNode("span", _hoisted_154, toDisplayString(vortex.radius.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_155, [
                    _cache[103] || (_cache[103] = createBaseVNode("label", null, "Rotation Speed", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.rotationSpeed,
                      min: "0",
                      max: "50",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "rotationSpeed", Number($event.target.value))
                    }, null, 40, _hoisted_156),
                    createBaseVNode("span", _hoisted_157, toDisplayString(vortex.rotationSpeed) + "/f", 1)
                  ]),
                  createBaseVNode("div", _hoisted_158, [
                    _cache[104] || (_cache[104] = createBaseVNode("label", null, "Inward Pull", -1)),
                    createBaseVNode("input", {
                      type: "range",
                      value: vortex.inwardPull,
                      min: "0",
                      max: "100",
                      step: "1",
                      onInput: ($event) => updateVortex(vortex.id, "inwardPull", Number($event.target.value))
                    }, null, 40, _hoisted_159),
                    createBaseVNode("span", _hoisted_160, toDisplayString(vortex.inwardPull), 1)
                  ])
                ]);
              }), 128))
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_161, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[24] || (_cache[24] = ($event) => toggleSection("turbulence"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[106] || (_cache[106] = createBaseVNode("span", null, "Turbulence", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addTurbulence, ["stop"]),
              title: "Add Turbulence Field"
            }, [..._cache[105] || (_cache[105] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("turbulence") ? (openBlock(), createElementBlock("div", _hoisted_162, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(turbulenceFields.value, (turb) => {
              return openBlock(), createElementBlock("div", {
                key: turb.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_163, [
                  _cache[108] || (_cache[108] = createBaseVNode("span", { class: "force-label" }, "Turbulence Field", -1)),
                  createBaseVNode("label", _hoisted_164, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: turb.enabled,
                      onChange: ($event) => updateTurbulence(turb.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_165)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeTurbulence(turb.id)
                  }, [..._cache[107] || (_cache[107] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_166)
                ]),
                createBaseVNode("div", _hoisted_167, [
                  _cache[109] || (_cache[109] = createBaseVNode("label", null, "Scale", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.scale,
                    min: "0.001",
                    max: "0.02",
                    step: "0.001",
                    onInput: ($event) => updateTurbulence(turb.id, "scale", Number($event.target.value))
                  }, null, 40, _hoisted_168),
                  createBaseVNode("span", _hoisted_169, toDisplayString(turb.scale.toFixed(3)), 1)
                ]),
                createBaseVNode("div", _hoisted_170, [
                  _cache[110] || (_cache[110] = createBaseVNode("label", null, "Strength", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.strength,
                    min: "0",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateTurbulence(turb.id, "strength", Number($event.target.value))
                  }, null, 40, _hoisted_171),
                  createBaseVNode("span", _hoisted_172, toDisplayString(turb.strength), 1)
                ]),
                createBaseVNode("div", _hoisted_173, [
                  _cache[111] || (_cache[111] = createBaseVNode("label", null, "Evolution", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: turb.evolutionSpeed,
                    min: "0",
                    max: "1",
                    step: "0.01",
                    onInput: ($event) => updateTurbulence(turb.id, "evolutionSpeed", Number($event.target.value))
                  }, null, 40, _hoisted_174),
                  createBaseVNode("span", _hoisted_175, toDisplayString(turb.evolutionSpeed.toFixed(2)), 1)
                ])
              ]);
            }), 128)),
            turbulenceFields.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_176, " No turbulence fields. Add one for organic particle motion. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_177, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[25] || (_cache[25] = ($event) => toggleSection("subEmitters"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[113] || (_cache[113] = createBaseVNode("span", null, "Sub-Emitters", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addSubEmitter, ["stop"]),
              title: "Add Sub-Emitter"
            }, [..._cache[112] || (_cache[112] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("subEmitters") ? (openBlock(), createElementBlock("div", _hoisted_178, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(subEmitters.value, (sub) => {
              return openBlock(), createElementBlock("div", {
                key: sub.id,
                class: "force-item"
              }, [
                createBaseVNode("div", _hoisted_179, [
                  createBaseVNode("select", {
                    value: sub.parentEmitterId,
                    onChange: ($event) => updateSubEmitter(sub.id, "parentEmitterId", $event.target.value),
                    class: "sub-emitter-parent"
                  }, [
                    _cache[114] || (_cache[114] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_181);
                    }), 128))
                  ], 40, _hoisted_180),
                  createBaseVNode("label", _hoisted_182, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: sub.enabled,
                      onChange: ($event) => updateSubEmitter(sub.id, "enabled", $event.target.checked)
                    }, null, 40, _hoisted_183)
                  ]),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeSubEmitter(sub.id)
                  }, [..._cache[115] || (_cache[115] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_184)
                ]),
                createBaseVNode("div", _hoisted_185, [
                  _cache[117] || (_cache[117] = createBaseVNode("label", null, "Trigger", -1)),
                  createBaseVNode("select", {
                    value: sub.trigger,
                    onChange: ($event) => updateSubEmitter(sub.id, "trigger", $event.target.value)
                  }, [..._cache[116] || (_cache[116] = [
                    createBaseVNode("option", { value: "death" }, "On Death", -1)
                  ])], 40, _hoisted_186)
                ]),
                createBaseVNode("div", _hoisted_187, [
                  _cache[118] || (_cache[118] = createBaseVNode("label", null, "Spawn Count", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spawnCount,
                    min: "1",
                    max: "10",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "spawnCount", Number($event.target.value))
                  }, null, 40, _hoisted_188),
                  createBaseVNode("span", _hoisted_189, toDisplayString(sub.spawnCount), 1)
                ]),
                createBaseVNode("div", _hoisted_190, [
                  _cache[119] || (_cache[119] = createBaseVNode("label", null, "Inherit Velocity", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.inheritVelocity,
                    min: "0",
                    max: "1",
                    step: "0.1",
                    onInput: ($event) => updateSubEmitter(sub.id, "inheritVelocity", Number($event.target.value))
                  }, null, 40, _hoisted_191),
                  createBaseVNode("span", _hoisted_192, toDisplayString((sub.inheritVelocity * 100).toFixed(0)) + "%", 1)
                ]),
                createBaseVNode("div", _hoisted_193, [
                  _cache[120] || (_cache[120] = createBaseVNode("label", null, "Size", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.size,
                    min: "1",
                    max: "100",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "size", Number($event.target.value))
                  }, null, 40, _hoisted_194),
                  createBaseVNode("span", _hoisted_195, toDisplayString(sub.size) + "px", 1)
                ]),
                createBaseVNode("div", _hoisted_196, [
                  _cache[121] || (_cache[121] = createBaseVNode("label", null, "Lifetime", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.lifetime,
                    min: "1",
                    max: "120",
                    step: "1",
                    onInput: ($event) => updateSubEmitter(sub.id, "lifetime", Number($event.target.value))
                  }, null, 40, _hoisted_197),
                  createBaseVNode("span", _hoisted_198, toDisplayString(sub.lifetime) + "f", 1)
                ]),
                createBaseVNode("div", _hoisted_199, [
                  _cache[122] || (_cache[122] = createBaseVNode("label", null, "Speed", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.speed,
                    min: "1",
                    max: "500",
                    step: "10",
                    onInput: ($event) => updateSubEmitter(sub.id, "speed", Number($event.target.value))
                  }, null, 40, _hoisted_200),
                  createBaseVNode("span", _hoisted_201, toDisplayString(sub.speed), 1)
                ]),
                createBaseVNode("div", _hoisted_202, [
                  _cache[123] || (_cache[123] = createBaseVNode("label", null, "Spread", -1)),
                  createBaseVNode("input", {
                    type: "range",
                    value: sub.spread,
                    min: "0",
                    max: "360",
                    step: "5",
                    onInput: ($event) => updateSubEmitter(sub.id, "spread", Number($event.target.value))
                  }, null, 40, _hoisted_203),
                  createBaseVNode("span", _hoisted_204, toDisplayString(sub.spread) + "", 1)
                ]),
                createBaseVNode("div", _hoisted_205, [
                  _cache[124] || (_cache[124] = createBaseVNode("label", null, "Color", -1)),
                  createBaseVNode("input", {
                    type: "color",
                    value: rgbToHex(sub.color),
                    onInput: ($event) => updateSubEmitterColor(sub.id, $event.target.value)
                  }, null, 40, _hoisted_206)
                ])
              ]);
            }), 128)),
            subEmitters.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_207, " No sub-emitters. Add one for particle death effects. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_208, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[26] || (_cache[26] = ($event) => toggleSection("modulations"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[126] || (_cache[126] = createBaseVNode("span", null, "Modulations", -1)),
            createBaseVNode("button", {
              class: "add-btn",
              onClick: withModifiers(addModulation, ["stop"]),
              title: "Add Modulation"
            }, [..._cache[125] || (_cache[125] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1)
            ])])
          ]),
          expandedSections.value.has("modulations") ? (openBlock(), createElementBlock("div", _hoisted_209, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(modulations.value, (mod) => {
              return openBlock(), createElementBlock("div", {
                key: mod.id,
                class: "modulation-item"
              }, [
                createBaseVNode("div", _hoisted_210, [
                  createBaseVNode("select", {
                    value: mod.emitterId,
                    onChange: ($event) => updateModulation(mod.id, "emitterId", $event.target.value)
                  }, [
                    _cache[127] || (_cache[127] = createBaseVNode("option", { value: "*" }, "All Emitters", -1)),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(emitters.value, (e) => {
                      return openBlock(), createElementBlock("option", {
                        key: e.id,
                        value: e.id
                      }, toDisplayString(e.name), 9, _hoisted_212);
                    }), 128))
                  ], 40, _hoisted_211),
                  createBaseVNode("button", {
                    class: "remove-btn",
                    onClick: ($event) => removeModulation(mod.id)
                  }, [..._cache[128] || (_cache[128] = [
                    createBaseVNode("i", { class: "pi pi-trash" }, null, -1)
                  ])], 8, _hoisted_213)
                ]),
                createBaseVNode("div", _hoisted_214, [
                  _cache[130] || (_cache[130] = createBaseVNode("label", null, "Property", -1)),
                  createBaseVNode("select", {
                    value: mod.property,
                    onChange: ($event) => updateModulation(mod.id, "property", $event.target.value)
                  }, [..._cache[129] || (_cache[129] = [
                    createStaticVNode('<option value="size" data-v-65c727f4>Size</option><option value="speed" data-v-65c727f4>Speed</option><option value="opacity" data-v-65c727f4>Opacity</option><option value="colorR" data-v-65c727f4>Color R</option><option value="colorG" data-v-65c727f4>Color G</option><option value="colorB" data-v-65c727f4>Color B</option>', 6)
                  ])], 40, _hoisted_215)
                ]),
                createBaseVNode("div", _hoisted_216, [
                  _cache[131] || (_cache[131] = createBaseVNode("label", null, "Start Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.startValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "startValue", Number($event.target.value))
                  }, null, 40, _hoisted_217)
                ]),
                createBaseVNode("div", _hoisted_218, [
                  _cache[132] || (_cache[132] = createBaseVNode("label", null, "End Value", -1)),
                  createBaseVNode("input", {
                    type: "number",
                    value: mod.endValue,
                    step: "0.1",
                    onInput: ($event) => updateModulation(mod.id, "endValue", Number($event.target.value))
                  }, null, 40, _hoisted_219)
                ]),
                createBaseVNode("div", _hoisted_220, [
                  _cache[134] || (_cache[134] = createBaseVNode("label", null, "Easing", -1)),
                  createBaseVNode("select", {
                    value: mod.easing,
                    onChange: ($event) => updateModulation(mod.id, "easing", $event.target.value)
                  }, [..._cache[133] || (_cache[133] = [
                    createStaticVNode('<option value="linear" data-v-65c727f4>Linear</option><option value="easeIn" data-v-65c727f4>Ease In</option><option value="easeOut" data-v-65c727f4>Ease Out</option><option value="easeInOut" data-v-65c727f4>Ease In Out</option><option value="bounce" data-v-65c727f4>Bounce</option><option value="elastic" data-v-65c727f4>Elastic</option>', 6)
                  ])], 40, _hoisted_221)
                ])
              ]);
            }), 128)),
            modulations.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_222, " No modulations. Add one to animate particle properties over lifetime. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_223, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[27] || (_cache[27] = ($event) => toggleSection("render"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[135] || (_cache[135] = createBaseVNode("span", null, "Render Options", -1))
          ]),
          expandedSections.value.has("render") ? (openBlock(), createElementBlock("div", _hoisted_224, [
            createBaseVNode("div", _hoisted_225, [
              _cache[137] || (_cache[137] = createBaseVNode("label", null, "Blend Mode", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.blendMode,
                onChange: _cache[28] || (_cache[28] = ($event) => updateRenderOption("blendMode", $event.target.value))
              }, [..._cache[136] || (_cache[136] = [
                createBaseVNode("option", { value: "normal" }, "Normal", -1),
                createBaseVNode("option", { value: "additive" }, "Additive", -1),
                createBaseVNode("option", { value: "multiply" }, "Multiply", -1),
                createBaseVNode("option", { value: "screen" }, "Screen", -1)
              ])], 40, _hoisted_226)
            ]),
            createBaseVNode("div", _hoisted_227, [
              _cache[139] || (_cache[139] = createBaseVNode("label", null, "Shape", -1)),
              createBaseVNode("select", {
                value: renderOptions.value.particleShape,
                onChange: _cache[29] || (_cache[29] = ($event) => updateRenderOption("particleShape", $event.target.value))
              }, [..._cache[138] || (_cache[138] = [
                createBaseVNode("option", { value: "circle" }, "Circle", -1),
                createBaseVNode("option", { value: "square" }, "Square", -1),
                createBaseVNode("option", { value: "triangle" }, "Triangle", -1),
                createBaseVNode("option", { value: "star" }, "Star", -1)
              ])], 40, _hoisted_228)
            ]),
            createBaseVNode("div", _hoisted_229, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.renderTrails,
                  onChange: _cache[30] || (_cache[30] = ($event) => updateRenderOption("renderTrails", $event.target.checked))
                }, null, 40, _hoisted_230),
                _cache[140] || (_cache[140] = createTextVNode(" Render Trails ", -1))
              ])
            ]),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_231, [
              _cache[141] || (_cache[141] = createBaseVNode("label", null, "Trail Length", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailLength,
                min: "1",
                max: "20",
                step: "1",
                onInput: _cache[31] || (_cache[31] = ($event) => updateRenderOption("trailLength", Number($event.target.value)))
              }, null, 40, _hoisted_232),
              createBaseVNode("span", _hoisted_233, toDisplayString(renderOptions.value.trailLength), 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.renderTrails ? (openBlock(), createElementBlock("div", _hoisted_234, [
              _cache[142] || (_cache[142] = createBaseVNode("label", null, "Trail Falloff", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.trailOpacityFalloff,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[32] || (_cache[32] = ($event) => updateRenderOption("trailOpacityFalloff", Number($event.target.value)))
              }, null, 40, _hoisted_235),
              createBaseVNode("span", _hoisted_236, toDisplayString(renderOptions.value.trailOpacityFalloff.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_237, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.glowEnabled,
                  onChange: _cache[33] || (_cache[33] = ($event) => updateRenderOption("glowEnabled", $event.target.checked))
                }, null, 40, _hoisted_238),
                _cache[143] || (_cache[143] = createTextVNode(" Enable Glow ", -1))
              ])
            ]),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_239, [
              _cache[144] || (_cache[144] = createBaseVNode("label", null, "Glow Radius", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowRadius,
                min: "1",
                max: "50",
                step: "1",
                onInput: _cache[34] || (_cache[34] = ($event) => updateRenderOption("glowRadius", Number($event.target.value)))
              }, null, 40, _hoisted_240),
              createBaseVNode("span", _hoisted_241, toDisplayString(renderOptions.value.glowRadius) + "px", 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.glowEnabled ? (openBlock(), createElementBlock("div", _hoisted_242, [
              _cache[145] || (_cache[145] = createBaseVNode("label", null, "Glow Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.glowIntensity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[35] || (_cache[35] = ($event) => updateRenderOption("glowIntensity", Number($event.target.value)))
              }, null, 40, _hoisted_243),
              createBaseVNode("span", _hoisted_244, toDisplayString(renderOptions.value.glowIntensity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            _cache[155] || (_cache[155] = createBaseVNode("div", { class: "subsection-divider" }, "Motion Blur", -1)),
            createBaseVNode("div", _hoisted_245, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: renderOptions.value.motionBlur,
                  onChange: _cache[36] || (_cache[36] = ($event) => updateRenderOption("motionBlur", $event.target.checked))
                }, null, 40, _hoisted_246),
                _cache[146] || (_cache[146] = createTextVNode(" Enable Motion Blur ", -1))
              ])
            ]),
            renderOptions.value.motionBlur ? (openBlock(), createElementBlock("div", _hoisted_247, [
              _cache[147] || (_cache[147] = createBaseVNode("label", null, "Blur Strength", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.motionBlurStrength,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[37] || (_cache[37] = ($event) => updateRenderOption("motionBlurStrength", Number($event.target.value)))
              }, null, 40, _hoisted_248),
              createBaseVNode("span", _hoisted_249, toDisplayString(renderOptions.value.motionBlurStrength.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            renderOptions.value.motionBlur ? (openBlock(), createElementBlock("div", _hoisted_250, [
              _cache[148] || (_cache[148] = createBaseVNode("label", null, "Blur Samples", -1)),
              createBaseVNode("input", {
                type: "range",
                value: renderOptions.value.motionBlurSamples,
                min: "1",
                max: "16",
                step: "1",
                onInput: _cache[38] || (_cache[38] = ($event) => updateRenderOption("motionBlurSamples", Number($event.target.value)))
              }, null, 40, _hoisted_251),
              createBaseVNode("span", _hoisted_252, toDisplayString(renderOptions.value.motionBlurSamples), 1)
            ])) : createCommentVNode("", true),
            _cache[156] || (_cache[156] = createBaseVNode("div", { class: "subsection-divider" }, "Particle Connections", -1)),
            createBaseVNode("div", _hoisted_253, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.enabled,
                  onChange: _cache[39] || (_cache[39] = ($event) => updateConnection("enabled", $event.target.checked))
                }, null, 40, _hoisted_254),
                _cache[149] || (_cache[149] = createTextVNode(" Enable Connections ", -1))
              ])
            ]),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_255, [
              _cache[150] || (_cache[150] = createBaseVNode("label", null, "Max Distance", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxDistance,
                min: "10",
                max: "300",
                step: "10",
                onInput: _cache[40] || (_cache[40] = ($event) => updateConnection("maxDistance", Number($event.target.value)))
              }, null, 40, _hoisted_256),
              createBaseVNode("span", _hoisted_257, toDisplayString(connections.value.maxDistance) + "px", 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_258, [
              _cache[151] || (_cache[151] = createBaseVNode("label", null, "Max Connections", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.maxConnections,
                min: "1",
                max: "5",
                step: "1",
                onInput: _cache[41] || (_cache[41] = ($event) => updateConnection("maxConnections", Number($event.target.value)))
              }, null, 40, _hoisted_259),
              createBaseVNode("span", _hoisted_260, toDisplayString(connections.value.maxConnections), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_261, [
              _cache[152] || (_cache[152] = createBaseVNode("label", null, "Line Width", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineWidth,
                min: "0.5",
                max: "3",
                step: "0.1",
                onInput: _cache[42] || (_cache[42] = ($event) => updateConnection("lineWidth", Number($event.target.value)))
              }, null, 40, _hoisted_262),
              createBaseVNode("span", _hoisted_263, toDisplayString(connections.value.lineWidth.toFixed(1)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_264, [
              _cache[153] || (_cache[153] = createBaseVNode("label", null, "Line Opacity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: connections.value.lineOpacity,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[43] || (_cache[43] = ($event) => updateConnection("lineOpacity", Number($event.target.value)))
              }, null, 40, _hoisted_265),
              createBaseVNode("span", _hoisted_266, toDisplayString(connections.value.lineOpacity.toFixed(2)), 1)
            ])) : createCommentVNode("", true),
            connections.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_267, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: connections.value.fadeByDistance,
                  onChange: _cache[44] || (_cache[44] = ($event) => updateConnection("fadeByDistance", $event.target.checked))
                }, null, 40, _hoisted_268),
                _cache[154] || (_cache[154] = createTextVNode(" Fade by Distance ", -1))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_269, [
          _cache[157] || (_cache[157] = createBaseVNode("i", { class: "pi pi-circle-fill" }, null, -1)),
          createBaseVNode("span", null, toDisplayString(particleCount.value) + " particles", 1)
        ])
      ]);
    };
  }
});

const ParticleProperties = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__scopeId", "data-v-65c727f4"]]);

const _hoisted_1$A = ["title"];
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const hasKeyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return false;
      return props.property.keyframes.some((k) => k.frame === store.currentFrame);
    });
    const keyframeAtCurrentFrame = computed(() => {
      if (!props.property.animated) return null;
      return props.property.keyframes.find((k) => k.frame === store.currentFrame) || null;
    });
    const iconClass = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "pi-circle-fill";
      }
      if (props.property.animated) {
        return "pi-circle";
      }
      return "pi-times";
    });
    const buttonTitle = computed(() => {
      if (hasKeyframeAtCurrentFrame.value) {
        return "Remove keyframe at current frame";
      }
      if (props.property.animated) {
        return "Add keyframe at current frame";
      }
      return "Enable animation (add keyframe)";
    });
    function toggleKeyframe() {
      if (hasKeyframeAtCurrentFrame.value) {
        removeKeyframe();
      } else {
        addKeyframe();
      }
    }
    function addKeyframe() {
      const defaultHandle = { frame: 0, value: 0, enabled: false };
      const newKeyframe = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: store.currentFrame,
        value: props.property.value,
        interpolation: "linear",
        inHandle: { ...defaultHandle },
        outHandle: { ...defaultHandle },
        controlMode: "smooth"
      };
      if (!props.property.animated) {
        props.property.animated = true;
        emit("animationToggled", true);
      }
      props.property.keyframes.push(newKeyframe);
      props.property.keyframes.sort((a, b) => a.frame - b.frame);
      emit("keyframeAdded", newKeyframe);
    }
    function removeKeyframe() {
      const keyframe = keyframeAtCurrentFrame.value;
      if (!keyframe) return;
      const index = props.property.keyframes.findIndex((k) => k.id === keyframe.id);
      if (index >= 0) {
        props.property.keyframes.splice(index, 1);
        emit("keyframeRemoved", keyframe.id);
      }
      if (props.property.keyframes.length === 0) {
        props.property.animated = false;
        emit("animationToggled", false);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass(["keyframe-toggle", {
          animated: __props.property.animated,
          "has-keyframe": hasKeyframeAtCurrentFrame.value
        }]),
        onClick: toggleKeyframe,
        title: buttonTitle.value
      }, [
        createBaseVNode("i", {
          class: normalizeClass(["pi", iconClass.value])
        }, null, 2)
      ], 10, _hoisted_1$A);
    };
  }
});

const KeyframeToggle = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__scopeId", "data-v-cec5e1c1"]]);

const _hoisted_1$z = { class: "depthflow-properties" };
const _hoisted_2$z = { class: "property-section" };
const _hoisted_3$z = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$z = { class: "property-row" };
const _hoisted_5$z = ["value"];
const _hoisted_6$z = ["value"];
const _hoisted_7$z = { class: "property-row" };
const _hoisted_8$y = ["value"];
const _hoisted_9$y = ["value"];
const _hoisted_10$y = { class: "property-section" };
const _hoisted_11$x = {
  key: 0,
  class: "section-content"
};
const _hoisted_12$v = { class: "preset-grid" };
const _hoisted_13$v = ["onClick"];
const _hoisted_14$s = {
  key: 0,
  class: "property-row"
};
const _hoisted_15$r = ["value"];
const _hoisted_16$q = { class: "value-display" };
const _hoisted_17$p = { class: "property-section" };
const _hoisted_18$o = {
  key: 0,
  class: "section-content"
};
const _hoisted_19$o = { class: "property-row" };
const _hoisted_20$o = ["value"];
const _hoisted_21$n = { class: "value-display" };
const _hoisted_22$m = { class: "property-row" };
const _hoisted_23$l = ["value"];
const _hoisted_24$i = { class: "value-display" };
const _hoisted_25$h = { class: "property-row" };
const _hoisted_26$g = ["value"];
const _hoisted_27$f = { class: "value-display" };
const _hoisted_28$f = { class: "property-row" };
const _hoisted_29$f = ["value"];
const _hoisted_30$e = { class: "value-display" };
const _hoisted_31$b = { class: "property-section" };
const _hoisted_32$b = {
  key: 0,
  class: "section-content"
};
const _hoisted_33$b = { class: "property-row" };
const _hoisted_34$b = ["value"];
const _hoisted_35$a = { class: "value-display" };
const _hoisted_36$a = { class: "property-row" };
const _hoisted_37$a = ["value"];
const _hoisted_38$a = { class: "value-display" };
const _hoisted_39$a = {
  key: 0,
  class: "property-section"
};
const _hoisted_40$9 = {
  key: 0,
  class: "section-content"
};
const _hoisted_41$7 = { class: "property-row" };
const _hoisted_42$6 = ["value"];
const _hoisted_43$6 = { class: "value-display" };
const _hoisted_44$6 = { class: "property-row" };
const _hoisted_45$6 = ["value"];
const _hoisted_46$6 = { class: "value-display" };
const _hoisted_47$6 = { class: "property-row" };
const _hoisted_48$6 = ["value"];
const _hoisted_49$6 = { class: "value-display" };
const _hoisted_50$5 = { class: "property-row" };
const _hoisted_51$5 = ["value"];
const _hoisted_52$5 = { class: "value-display" };
const _hoisted_53$5 = {
  key: 2,
  class: "property-row"
};
const _hoisted_54$5 = ["value"];
const _hoisted_55$5 = { class: "value-display" };
const _hoisted_56$5 = { class: "property-section" };
const _hoisted_57$4 = {
  key: 0,
  class: "section-content"
};
const _hoisted_58$4 = { class: "property-row" };
const _hoisted_59$4 = ["value"];
const _hoisted_60$4 = { class: "value-display" };
const _hoisted_61$4 = { class: "property-row checkbox-row" };
const _hoisted_62$4 = ["checked"];
const _hoisted_63$2 = { class: "property-section" };
const _hoisted_64$2 = {
  key: 0,
  class: "sync-badge"
};
const _hoisted_65$2 = {
  key: 0,
  class: "section-content"
};
const _hoisted_66$2 = { class: "property-row checkbox-row" };
const _hoisted_67$2 = ["checked"];
const _hoisted_68$2 = { class: "property-row" };
const _hoisted_69$2 = ["value"];
const _hoisted_70$2 = ["value"];
const _hoisted_71$2 = { class: "property-row" };
const _hoisted_72$2 = ["value"];
const _hoisted_73$2 = { class: "value-display" };
const _hoisted_74$2 = { class: "property-row" };
const _hoisted_75$2 = ["value"];
const _hoisted_76$2 = { class: "value-display" };
const _hoisted_77$2 = { class: "property-row" };
const _hoisted_78$2 = ["value"];
const _hoisted_79$2 = { class: "value-display" };
const _hoisted_80$2 = { class: "property-row" };
const _hoisted_81$2 = ["value"];
const _hoisted_82$2 = { class: "value-display" };
const _hoisted_83$2 = { class: "property-row checkbox-row" };
const _hoisted_84$2 = ["checked"];
const _hoisted_85$2 = { style: { "margin-left": "16px" } };
const _hoisted_86$2 = ["checked"];
const _hoisted_87$2 = { class: "property-row" };
const _hoisted_88$2 = ["value"];
const _hoisted_89$2 = { class: "value-display" };
const _hoisted_90$2 = { class: "property-section" };
const _hoisted_91$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_92$1 = { class: "preview-container" };
const _hoisted_93 = { class: "preview-controls" };
const _hoisted_94 = { class: "frame-indicator" };
const previewSize = 200;
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const DEFAULT_CAMERA_SYNC_CONFIG = {
      sensitivityX: 0.5,
      sensitivityY: 0.5,
      sensitivityZ: 1e-3,
      sensitivityRotation: 1,
      baseZoom: 1,
      invertX: false,
      invertY: false,
      zoomClamp: { min: 0.5, max: 3 },
      offsetClamp: { min: -1, max: 1 }
    };
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const previewCanvas = ref(null);
    const isPreviewPlaying = ref(false);
    const previewFrame = ref(0);
    const previewAnimationId = ref(null);
    const expandedSections = ref(/* @__PURE__ */ new Set(["source", "preset", "camera"]));
    const presetIntensity = ref(1);
    const presets = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ];
    const config = computed(() => {
      const data = props.layer.data;
      return data || {
        sourceLayerId: "",
        depthLayerId: "",
        config: {
          preset: "static",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: true
        }
      };
    });
    const depthflowConfig = computed(() => config.value.config);
    const totalFrames = computed(() => store.frameCount);
    const imageLayers = computed(
      () => store.layers.filter((l) => l.type === "image" || l.type === "generated")
    );
    const depthLayers = computed(
      () => store.layers.filter((l) => l.type === "depth" || l.type === "generated")
    );
    const cameraLayers = computed(
      () => store.layers.filter((l) => l.type === "camera")
    );
    const cameraSyncConfig = computed(() => {
      return config.value.cameraSyncConfig ?? DEFAULT_CAMERA_SYNC_CONFIG;
    });
    const isOrbitPreset = computed(
      () => ["circle_cw", "circle_ccw"].includes(depthflowConfig.value.preset)
    );
    const isSwingPreset = computed(
      () => ["horizontal_swing", "vertical_swing"].includes(depthflowConfig.value.preset)
    );
    const isDollyPreset = computed(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(depthflowConfig.value.preset)
    );
    const showPresetSettings = computed(
      () => isOrbitPreset.value || isSwingPreset.value || isDollyPreset.value
    );
    const presetSettingsTitle = computed(() => {
      if (isOrbitPreset.value) return "Orbit Settings";
      if (isSwingPreset.value) return "Swing Settings";
      if (isDollyPreset.value) return "Dolly Zoom Settings";
      return "Preset Settings";
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function updateConfig(key, value) {
      emit("update", { [key]: value });
    }
    function updateDepthflowConfig(key, value) {
      emit("update", {
        config: { ...depthflowConfig.value, [key]: value }
      });
    }
    function selectPreset(preset) {
      updateDepthflowConfig("preset", preset);
    }
    function updateCameraSyncConfig(key, value) {
      emit("update", {
        cameraSyncConfig: { ...cameraSyncConfig.value, [key]: value }
      });
    }
    function updatePresetIntensity(intensity) {
      presetIntensity.value = intensity;
      if (isOrbitPreset.value) {
        updateDepthflowConfig("orbitRadius", 0.1 * intensity);
      } else if (isSwingPreset.value) {
        updateDepthflowConfig("swingAmplitude", 0.1 * intensity);
      } else {
        updateDepthflowConfig("depthScale", 1 * intensity);
      }
    }
    function togglePreview() {
      isPreviewPlaying.value = !isPreviewPlaying.value;
      if (isPreviewPlaying.value) {
        playPreview();
      } else {
        if (previewAnimationId.value !== null) {
          cancelAnimationFrame(previewAnimationId.value);
          previewAnimationId.value = null;
        }
      }
    }
    function playPreview() {
      if (!isPreviewPlaying.value) return;
      previewFrame.value = (previewFrame.value + 1) % totalFrames.value;
      renderPreview();
      previewAnimationId.value = requestAnimationFrame(() => {
        setTimeout(playPreview, 1e3 / store.fps);
      });
    }
    function renderPreview() {
      const canvas = previewCanvas.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, previewSize, previewSize);
      ctx.fillStyle = "#333";
      ctx.fillRect(10, 10, previewSize - 20, previewSize - 20);
      ctx.fillStyle = "#666";
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Depthflow Preview", previewSize / 2, previewSize / 2);
      ctx.fillText(`Frame ${previewFrame.value}`, previewSize / 2, previewSize / 2 + 16);
    }
    onMounted(() => {
      renderPreview();
    });
    onUnmounted(() => {
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        createBaseVNode("div", _hoisted_2$z, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("source"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Source Selection", -1))
          ]),
          expandedSections.value.has("source") ? (openBlock(), createElementBlock("div", _hoisted_3$z, [
            createBaseVNode("div", _hoisted_4$z, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Source Layer", -1)),
              createBaseVNode("select", {
                value: config.value.sourceLayerId,
                onChange: _cache[1] || (_cache[1] = ($event) => updateConfig("sourceLayerId", $event.target.value))
              }, [
                _cache[34] || (_cache[34] = createBaseVNode("option", { value: "" }, "Select source...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(imageLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_6$z);
                }), 128))
              ], 40, _hoisted_5$z)
            ]),
            createBaseVNode("div", _hoisted_7$z, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Depth Layer", -1)),
              createBaseVNode("select", {
                value: config.value.depthLayerId,
                onChange: _cache[2] || (_cache[2] = ($event) => updateConfig("depthLayerId", $event.target.value))
              }, [
                _cache[36] || (_cache[36] = createBaseVNode("option", { value: "" }, "Select depth map...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(depthLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_9$y);
                }), 128))
              ], 40, _hoisted_8$y)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_10$y, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[3] || (_cache[3] = ($event) => toggleSection("preset"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[38] || (_cache[38] = createBaseVNode("span", null, "Motion Preset", -1))
          ]),
          expandedSections.value.has("preset") ? (openBlock(), createElementBlock("div", _hoisted_11$x, [
            createBaseVNode("div", _hoisted_12$v, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.value,
                  class: normalizeClass(["preset-btn", { active: depthflowConfig.value.preset === preset.value }]),
                  onClick: ($event) => selectPreset(preset.value)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(preset.icon)
                  }, null, 2),
                  createBaseVNode("span", null, toDisplayString(preset.label), 1)
                ], 10, _hoisted_13$v);
              }), 64))
            ]),
            depthflowConfig.value.preset !== "static" ? (openBlock(), createElementBlock("div", _hoisted_14$s, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("input", {
                type: "range",
                value: presetIntensity.value,
                min: "0.1",
                max: "2",
                step: "0.1",
                onInput: _cache[4] || (_cache[4] = ($event) => updatePresetIntensity(Number($event.target.value)))
              }, null, 40, _hoisted_15$r),
              createBaseVNode("span", _hoisted_16$q, toDisplayString(presetIntensity.value.toFixed(1)) + "x", 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_17$p, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("camera"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[40] || (_cache[40] = createBaseVNode("span", null, "Camera Controls", -1))
          ]),
          expandedSections.value.has("camera") ? (openBlock(), createElementBlock("div", _hoisted_18$o, [
            createBaseVNode("div", _hoisted_19$o, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Zoom", -1)),
              config.value.animatedZoom ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedZoom,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.zoom,
                min: "0.5",
                max: "2",
                step: "0.01",
                onInput: _cache[6] || (_cache[6] = ($event) => updateDepthflowConfig("zoom", Number($event.target.value)))
              }, null, 40, _hoisted_20$o),
              createBaseVNode("span", _hoisted_21$n, toDisplayString(depthflowConfig.value.zoom.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_22$m, [
              _cache[42] || (_cache[42] = createBaseVNode("label", null, "Offset X", -1)),
              config.value.animatedOffsetX ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetX,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetX,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[7] || (_cache[7] = ($event) => updateDepthflowConfig("offsetX", Number($event.target.value)))
              }, null, 40, _hoisted_23$l),
              createBaseVNode("span", _hoisted_24$i, toDisplayString(depthflowConfig.value.offsetX.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_25$h, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Offset Y", -1)),
              config.value.animatedOffsetY ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedOffsetY,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.offsetY,
                min: "-1",
                max: "1",
                step: "0.01",
                onInput: _cache[8] || (_cache[8] = ($event) => updateDepthflowConfig("offsetY", Number($event.target.value)))
              }, null, 40, _hoisted_26$g),
              createBaseVNode("span", _hoisted_27$f, toDisplayString(depthflowConfig.value.offsetY.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_28$f, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Rotation", -1)),
              config.value.animatedRotation ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedRotation,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.rotation,
                min: "-180",
                max: "180",
                step: "1",
                onInput: _cache[9] || (_cache[9] = ($event) => updateDepthflowConfig("rotation", Number($event.target.value)))
              }, null, 40, _hoisted_29$f),
              createBaseVNode("span", _hoisted_30$e, toDisplayString(depthflowConfig.value.rotation) + "", 1)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_31$b, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("depth"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[45] || (_cache[45] = createBaseVNode("span", null, "Depth Settings", -1))
          ]),
          expandedSections.value.has("depth") ? (openBlock(), createElementBlock("div", _hoisted_32$b, [
            createBaseVNode("div", _hoisted_33$b, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Depth Scale", -1)),
              config.value.animatedDepthScale ? (openBlock(), createBlock(KeyframeToggle, {
                key: 0,
                property: config.value.animatedDepthScale,
                "layer-id": __props.layer.id
              }, null, 8, ["property", "layer-id"])) : createCommentVNode("", true),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.depthScale,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: _cache[11] || (_cache[11] = ($event) => updateDepthflowConfig("depthScale", Number($event.target.value)))
              }, null, 40, _hoisted_34$b),
              createBaseVNode("span", _hoisted_35$a, toDisplayString(depthflowConfig.value.depthScale.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_36$a, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Focus Depth", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.focusDepth,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: _cache[12] || (_cache[12] = ($event) => updateDepthflowConfig("focusDepth", Number($event.target.value)))
              }, null, 40, _hoisted_37$a),
              createBaseVNode("span", _hoisted_38$a, toDisplayString(depthflowConfig.value.focusDepth.toFixed(2)), 1)
            ]),
            _cache[48] || (_cache[48] = createBaseVNode("div", { class: "depth-hint" }, [
              createTextVNode(" Objects at focus depth stay stationary."),
              createBaseVNode("br"),
              createTextVNode(" Closer objects move more, distant objects move less. ")
            ], -1))
          ])) : createCommentVNode("", true)
        ]),
        showPresetSettings.value ? (openBlock(), createElementBlock("div", _hoisted_39$a, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[13] || (_cache[13] = ($event) => toggleSection("presetSettings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            createBaseVNode("span", null, toDisplayString(presetSettingsTitle.value), 1)
          ]),
          expandedSections.value.has("presetSettings") ? (openBlock(), createElementBlock("div", _hoisted_40$9, [
            isOrbitPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_41$7, [
                _cache[49] || (_cache[49] = createBaseVNode("label", null, "Orbit Radius", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitRadius,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[14] || (_cache[14] = ($event) => updateDepthflowConfig("orbitRadius", Number($event.target.value)))
                }, null, 40, _hoisted_42$6),
                createBaseVNode("span", _hoisted_43$6, toDisplayString(depthflowConfig.value.orbitRadius.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_44$6, [
                _cache[50] || (_cache[50] = createBaseVNode("label", null, "Orbit Speed", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.orbitSpeed,
                  min: "1",
                  max: "720",
                  step: "1",
                  onInput: _cache[15] || (_cache[15] = ($event) => updateDepthflowConfig("orbitSpeed", Number($event.target.value)))
                }, null, 40, _hoisted_45$6),
                createBaseVNode("span", _hoisted_46$6, toDisplayString(depthflowConfig.value.orbitSpeed) + "", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isSwingPreset.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_47$6, [
                _cache[51] || (_cache[51] = createBaseVNode("label", null, "Amplitude", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingAmplitude,
                  min: "0.01",
                  max: "0.5",
                  step: "0.01",
                  onInput: _cache[16] || (_cache[16] = ($event) => updateDepthflowConfig("swingAmplitude", Number($event.target.value)))
                }, null, 40, _hoisted_48$6),
                createBaseVNode("span", _hoisted_49$6, toDisplayString(depthflowConfig.value.swingAmplitude.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_50$5, [
                _cache[52] || (_cache[52] = createBaseVNode("label", null, "Frequency", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: depthflowConfig.value.swingFrequency,
                  min: "0.1",
                  max: "5",
                  step: "0.1",
                  onInput: _cache[17] || (_cache[17] = ($event) => updateDepthflowConfig("swingFrequency", Number($event.target.value)))
                }, null, 40, _hoisted_51$5),
                createBaseVNode("span", _hoisted_52$5, toDisplayString(depthflowConfig.value.swingFrequency.toFixed(1)) + " Hz", 1)
              ])
            ], 64)) : createCommentVNode("", true),
            isDollyPreset.value ? (openBlock(), createElementBlock("div", _hoisted_53$5, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Dolly Rate", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.dollyZoom,
                min: "0",
                max: "1",
                step: "0.05",
                onInput: _cache[18] || (_cache[18] = ($event) => updateDepthflowConfig("dollyZoom", Number($event.target.value)))
              }, null, 40, _hoisted_54$5),
              createBaseVNode("span", _hoisted_55$5, toDisplayString(depthflowConfig.value.dollyZoom.toFixed(2)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_56$5, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[19] || (_cache[19] = ($event) => toggleSection("quality"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[54] || (_cache[54] = createBaseVNode("span", null, "Quality", -1))
          ]),
          expandedSections.value.has("quality") ? (openBlock(), createElementBlock("div", _hoisted_57$4, [
            createBaseVNode("div", _hoisted_58$4, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Edge Dilation", -1)),
              createBaseVNode("input", {
                type: "range",
                value: depthflowConfig.value.edgeDilation,
                min: "0",
                max: "50",
                step: "1",
                onInput: _cache[20] || (_cache[20] = ($event) => updateDepthflowConfig("edgeDilation", Number($event.target.value)))
              }, null, 40, _hoisted_59$4),
              createBaseVNode("span", _hoisted_60$4, toDisplayString(depthflowConfig.value.edgeDilation) + "px", 1)
            ]),
            createBaseVNode("div", _hoisted_61$4, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: depthflowConfig.value.inpaintEdges,
                  onChange: _cache[21] || (_cache[21] = ($event) => updateDepthflowConfig("inpaintEdges", $event.target.checked))
                }, null, 40, _hoisted_62$4),
                _cache[56] || (_cache[56] = createTextVNode(" Inpaint Edges ", -1))
              ])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_63$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[22] || (_cache[22] = ($event) => toggleSection("cameraSync"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("cameraSync") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[57] || (_cache[57] = createBaseVNode("span", null, "Camera Sync", -1)),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock("span", _hoisted_64$2, "Active")) : createCommentVNode("", true)
          ]),
          expandedSections.value.has("cameraSync") ? (openBlock(), createElementBlock("div", _hoisted_65$2, [
            createBaseVNode("div", _hoisted_66$2, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: config.value.cameraSyncEnabled ?? false,
                  onChange: _cache[23] || (_cache[23] = ($event) => updateConfig("cameraSyncEnabled", $event.target.checked))
                }, null, 40, _hoisted_67$2),
                _cache[58] || (_cache[58] = createTextVNode(" Enable Camera Sync ", -1))
              ])
            ]),
            config.value.cameraSyncEnabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_68$2, [
                _cache[60] || (_cache[60] = createBaseVNode("label", null, "Camera Layer", -1)),
                createBaseVNode("select", {
                  value: config.value.cameraSyncLayerId ?? "",
                  onChange: _cache[24] || (_cache[24] = ($event) => updateConfig("cameraSyncLayerId", $event.target.value))
                }, [
                  _cache[59] || (_cache[59] = createBaseVNode("option", { value: "" }, "Select camera...", -1)),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(cameraLayers.value, (layer) => {
                    return openBlock(), createElementBlock("option", {
                      key: layer.id,
                      value: layer.id
                    }, toDisplayString(layer.name), 9, _hoisted_70$2);
                  }), 128))
                ], 40, _hoisted_69$2)
              ]),
              _cache[68] || (_cache[68] = createBaseVNode("div", { class: "sync-hint" }, " Camera movement will drive parallax. Adjust sensitivity below. ", -1)),
              createBaseVNode("div", _hoisted_71$2, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "X Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityX,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[25] || (_cache[25] = ($event) => updateCameraSyncConfig("sensitivityX", Number($event.target.value)))
                }, null, 40, _hoisted_72$2),
                createBaseVNode("span", _hoisted_73$2, toDisplayString(cameraSyncConfig.value.sensitivityX.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_74$2, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Y Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityY,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[26] || (_cache[26] = ($event) => updateCameraSyncConfig("sensitivityY", Number($event.target.value)))
                }, null, 40, _hoisted_75$2),
                createBaseVNode("span", _hoisted_76$2, toDisplayString(cameraSyncConfig.value.sensitivityY.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_77$2, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Z Sensitivity", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityZ * 1e3,
                  min: "0",
                  max: "10",
                  step: "0.1",
                  onInput: _cache[27] || (_cache[27] = ($event) => updateCameraSyncConfig("sensitivityZ", Number($event.target.value) / 1e3))
                }, null, 40, _hoisted_78$2),
                createBaseVNode("span", _hoisted_79$2, toDisplayString((cameraSyncConfig.value.sensitivityZ * 1e3).toFixed(1)), 1)
              ]),
              createBaseVNode("div", _hoisted_80$2, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "Rotation Sens.", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.sensitivityRotation,
                  min: "0",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[28] || (_cache[28] = ($event) => updateCameraSyncConfig("sensitivityRotation", Number($event.target.value)))
                }, null, 40, _hoisted_81$2),
                createBaseVNode("span", _hoisted_82$2, toDisplayString(cameraSyncConfig.value.sensitivityRotation.toFixed(2)), 1)
              ]),
              createBaseVNode("div", _hoisted_83$2, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertX,
                    onChange: _cache[29] || (_cache[29] = ($event) => updateCameraSyncConfig("invertX", $event.target.checked))
                  }, null, 40, _hoisted_84$2),
                  _cache[65] || (_cache[65] = createTextVNode(" Invert X ", -1))
                ]),
                createBaseVNode("label", _hoisted_85$2, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: cameraSyncConfig.value.invertY,
                    onChange: _cache[30] || (_cache[30] = ($event) => updateCameraSyncConfig("invertY", $event.target.checked))
                  }, null, 40, _hoisted_86$2),
                  _cache[66] || (_cache[66] = createTextVNode(" Invert Y ", -1))
                ])
              ]),
              createBaseVNode("div", _hoisted_87$2, [
                _cache[67] || (_cache[67] = createBaseVNode("label", null, "Base Zoom", -1)),
                createBaseVNode("input", {
                  type: "range",
                  value: cameraSyncConfig.value.baseZoom,
                  min: "0.5",
                  max: "2",
                  step: "0.05",
                  onInput: _cache[31] || (_cache[31] = ($event) => updateCameraSyncConfig("baseZoom", Number($event.target.value)))
                }, null, 40, _hoisted_88$2),
                createBaseVNode("span", _hoisted_89$2, toDisplayString(cameraSyncConfig.value.baseZoom.toFixed(2)), 1)
              ])
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_90$2, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[32] || (_cache[32] = ($event) => toggleSection("preview"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[69] || (_cache[69] = createBaseVNode("span", null, "Preview", -1))
          ]),
          expandedSections.value.has("preview") ? (openBlock(), createElementBlock("div", _hoisted_91$1, [
            createBaseVNode("div", _hoisted_92$1, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                class: "preview-canvas",
                width: previewSize,
                height: previewSize
              }, null, 512)
            ]),
            createBaseVNode("div", _hoisted_93, [
              createBaseVNode("button", {
                class: normalizeClass(["preview-btn", { active: isPreviewPlaying.value }]),
                onClick: togglePreview
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(isPreviewPlaying.value ? "pi pi-pause" : "pi pi-play")
                }, null, 2),
                createTextVNode(" " + toDisplayString(isPreviewPlaying.value ? "Pause" : "Play"), 1)
              ], 2),
              createBaseVNode("span", _hoisted_94, " Frame " + toDisplayString(previewFrame.value) + " / " + toDisplayString(totalFrames.value - 1), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const DepthflowProperties = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__scopeId", "data-v-fdaa9d3f"]]);

const _hoisted_1$y = { class: "light-properties" };
const _hoisted_2$y = { class: "property-section" };
const _hoisted_3$y = { class: "section-content" };
const _hoisted_4$y = { class: "property-row" };
const _hoisted_5$y = ["value"];
const _hoisted_6$y = { class: "property-group" };
const _hoisted_7$y = { class: "property-group" };
const _hoisted_8$x = { class: "control-row" };
const _hoisted_9$x = { class: "property-group" };
const _hoisted_10$x = { class: "control-row" };
const _hoisted_11$w = { class: "property-group" };
const _hoisted_12$u = {
  key: 1,
  class: "property-row"
};
const _hoisted_13$u = ["value"];
const _hoisted_14$r = {
  key: 2,
  class: "property-group"
};
const _hoisted_15$q = {
  key: 3,
  class: "property-group"
};
const _hoisted_16$p = { class: "property-group checkbox-row" };
const _hoisted_17$o = ["checked"];
const _hoisted_18$n = { class: "property-group" };
const _hoisted_19$n = { class: "property-group" };
const _hoisted_20$n = {
  key: 5,
  class: "note"
};
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const lightData = computed(() => {
      return props.layer.data || {
        lightType: "spot",
        color: "#ffffff",
        intensity: 100,
        radius: 500,
        falloff: "none",
        falloffDistance: 500,
        castShadows: false,
        shadowDarkness: 100,
        shadowDiffusion: 0,
        coneAngle: 90,
        coneFeather: 50
      };
    });
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...lightData.value, [key]: value }
      });
      emit("update");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        createBaseVNode("div", _hoisted_2$y, [
          _cache[25] || (_cache[25] = createBaseVNode("div", { class: "section-header" }, "Light Settings", -1)),
          createBaseVNode("div", _hoisted_3$y, [
            createBaseVNode("div", _hoisted_4$y, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Type", -1)),
              createBaseVNode("select", {
                value: lightData.value.lightType,
                onChange: _cache[0] || (_cache[0] = ($event) => update("lightType", $event.target.value)),
                class: "type-select"
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("option", { value: "parallel" }, "Parallel", -1),
                createBaseVNode("option", { value: "spot" }, "Spot", -1),
                createBaseVNode("option", { value: "point" }, "Point", -1),
                createBaseVNode("option", { value: "ambient" }, "Ambient", -1)
              ])], 40, _hoisted_5$y)
            ]),
            createBaseVNode("div", _hoisted_6$y, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: lightData.value.color,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => update("color", v))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$y, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Intensity", -1)),
              createBaseVNode("div", _hoisted_8$x, [
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.intensity,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => update("intensity", v)),
                  min: 0,
                  max: 500,
                  step: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ]),
            lightData.value.lightType === "spot" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_9$x, [
                _cache[16] || (_cache[16] = createBaseVNode("label", null, "Cone Angle", -1)),
                createBaseVNode("div", _hoisted_10$x, [
                  createVNode(unref(AngleDial), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => update("coneAngle", v)),
                    size: 32
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: lightData.value.coneAngle ?? 90,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => update("coneAngle", v)),
                    unit: ""
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_11$w, [
                _cache[17] || (_cache[17] = createBaseVNode("label", null, "Cone Feather", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.coneFeather ?? 50,
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => update("coneFeather", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_12$u, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Falloff", -1)),
              createBaseVNode("select", {
                value: lightData.value.falloff,
                onChange: _cache[6] || (_cache[6] = ($event) => update("falloff", $event.target.value)),
                class: "type-select"
              }, [..._cache[18] || (_cache[18] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "smooth" }, "Smooth", -1),
                createBaseVNode("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
              ])], 40, _hoisted_13$u)
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" && lightData.value.lightType !== "parallel" ? (openBlock(), createElementBlock("div", _hoisted_14$r, [
              _cache[20] || (_cache[20] = createBaseVNode("label", null, "Radius", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.radius,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => update("radius", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            lightData.value.lightType !== "ambient" ? (openBlock(), createElementBlock("div", _hoisted_15$q, [
              _cache[21] || (_cache[21] = createBaseVNode("label", null, "Falloff Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: lightData.value.falloffDistance ?? 500,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => update("falloffDistance", v)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_16$p, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: lightData.value.castShadows,
                  onChange: _cache[9] || (_cache[9] = ($event) => update("castShadows", $event.target.checked))
                }, null, 40, _hoisted_17$o),
                _cache[22] || (_cache[22] = createTextVNode(" Casts Shadows ", -1))
              ])
            ]),
            lightData.value.castShadows ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
              createBaseVNode("div", _hoisted_18$n, [
                _cache[23] || (_cache[23] = createBaseVNode("label", null, "Shadow Darkness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: lightData.value.shadowDarkness ?? 100,
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => update("shadowDarkness", v)),
                  min: 0,
                  max: 100,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$n, [
                _cache[24] || (_cache[24] = createBaseVNode("label", null, "Shadow Diffusion", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: lightData.value.shadowDiffusion ?? 0,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => update("shadowDiffusion", v)),
                  min: 0,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : createCommentVNode("", true),
            lightData.value.castShadows ? (openBlock(), createElementBlock("div", _hoisted_20$n, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const LightProperties = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__scopeId", "data-v-8b65d6d1"]]);

const _hoisted_1$x = { class: "shape-properties" };
const _hoisted_2$x = { class: "prop-section" };
const _hoisted_3$x = { class: "expand-icon" };
const _hoisted_4$x = ["checked"];
const _hoisted_5$x = {
  key: 0,
  class: "section-content"
};
const _hoisted_6$x = { class: "property-row" };
const _hoisted_7$x = { class: "color-input-wrapper" };
const _hoisted_8$w = ["value"];
const _hoisted_9$w = { class: "property-row" };
const _hoisted_10$w = { class: "property-row" };
const _hoisted_11$v = { class: "property-row" };
const _hoisted_12$t = { class: "icon-toggle-group" };
const _hoisted_13$t = { class: "property-row" };
const _hoisted_14$q = { class: "icon-toggle-group" };
const _hoisted_15$p = { class: "property-row" };
const _hoisted_16$o = ["value"];
const _hoisted_17$n = {
  key: 0,
  class: "property-row"
};
const _hoisted_18$m = { class: "prop-section" };
const _hoisted_19$m = { class: "expand-icon" };
const _hoisted_20$m = ["checked"];
const _hoisted_21$m = {
  key: 0,
  class: "section-content"
};
const _hoisted_22$l = { class: "property-row" };
const _hoisted_23$k = { class: "color-input-wrapper" };
const _hoisted_24$h = ["value"];
const _hoisted_25$g = { class: "property-row" };
const _hoisted_26$f = { class: "prop-section" };
const _hoisted_27$e = { class: "expand-icon" };
const _hoisted_28$e = {
  key: 0,
  class: "section-content"
};
const _hoisted_29$e = { class: "property-row" };
const _hoisted_30$d = { class: "property-row" };
const _hoisted_31$a = { class: "property-row" };
const _hoisted_32$a = { class: "prop-section" };
const _hoisted_33$a = { class: "expand-icon" };
const _hoisted_34$a = {
  key: 0,
  class: "effect-count"
};
const _hoisted_35$9 = {
  key: 0,
  class: "section-content"
};
const _hoisted_36$9 = { class: "add-effect-row" };
const _hoisted_37$9 = ["disabled"];
const _hoisted_38$9 = { class: "effect-header" };
const _hoisted_39$9 = ["onClick"];
const _hoisted_40$8 = { class: "effect-name" };
const _hoisted_41$6 = { class: "effect-actions" };
const _hoisted_42$5 = ["onClick", "disabled"];
const _hoisted_43$5 = ["onClick", "disabled"];
const _hoisted_44$5 = ["onClick"];
const _hoisted_45$5 = {
  key: 0,
  class: "effect-params"
};
const _hoisted_46$5 = { class: "property-row" };
const _hoisted_47$5 = ["onClick"];
const _hoisted_48$5 = { class: "property-row" };
const _hoisted_49$5 = { class: "icon-toggle-group" };
const _hoisted_50$4 = ["onClick"];
const _hoisted_51$4 = ["onClick"];
const _hoisted_52$4 = ["onClick"];
const _hoisted_53$4 = { class: "property-row" };
const _hoisted_54$4 = ["onClick"];
const _hoisted_55$4 = { class: "property-row" };
const _hoisted_56$4 = ["onClick"];
const _hoisted_57$3 = { class: "property-row" };
const _hoisted_58$3 = { class: "property-row" };
const _hoisted_59$3 = ["onClick"];
const _hoisted_60$3 = { class: "property-row" };
const _hoisted_61$3 = ["onClick"];
const _hoisted_62$3 = { class: "property-row" };
const _hoisted_63$1 = ["onClick"];
const _hoisted_64$1 = { class: "property-row" };
const _hoisted_65$1 = ["onClick"];
const _hoisted_66$1 = { class: "property-row" };
const _hoisted_67$1 = ["onClick"];
const _hoisted_68$1 = { class: "property-row" };
const _hoisted_69$1 = ["onClick"];
const _hoisted_70$1 = { class: "property-row" };
const _hoisted_71$1 = { class: "icon-toggle-group" };
const _hoisted_72$1 = ["onClick"];
const _hoisted_73$1 = ["onClick"];
const _hoisted_74$1 = { class: "property-row" };
const _hoisted_75$1 = ["onClick"];
const _hoisted_76$1 = { class: "property-row" };
const _hoisted_77$1 = ["onClick"];
const _hoisted_78$1 = { class: "property-row" };
const _hoisted_79$1 = ["onClick"];
const _hoisted_80$1 = { class: "property-row" };
const _hoisted_81$1 = { class: "icon-toggle-group wide" };
const _hoisted_82$1 = ["onClick"];
const _hoisted_83$1 = ["onClick"];
const _hoisted_84$1 = ["onClick"];
const _hoisted_85$1 = {
  key: 0,
  class: "no-effects"
};
const _hoisted_86$1 = { class: "prop-section" };
const _hoisted_87$1 = { class: "expand-icon" };
const _hoisted_88$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_89$1 = { class: "property-row checkbox-row" };
const _hoisted_90$1 = ["checked"];
const _hoisted_91 = { class: "property-row info-row" };
const _hoisted_92 = { class: "info-value" };
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["stroke", "fill", "trim"]);
    const newEffectType = ref("");
    const shapeData = computed(() => {
      return props.layer.data || {
        pathData: "",
        controlPoints: [],
        closed: false,
        stroke: "#ffffff",
        strokeWidth: 2,
        strokeOpacity: 100,
        strokeLineCap: "round",
        strokeLineJoin: "round",
        fill: "",
        fillOpacity: 100,
        trimStart: 0,
        trimEnd: 100,
        trimOffset: 0
      };
    });
    const hasFill = computed(() => !!shapeData.value.fill && shapeData.value.fill !== "transparent");
    const hasStroke = computed(() => !!shapeData.value.stroke && (shapeData.value.strokeWidth ?? 0) > 0);
    const strokeLineCap = computed(() => shapeData.value.strokeLineCap || "round");
    const strokeLineJoin = computed(() => shapeData.value.strokeLineJoin || "round");
    const hasDashes = computed(() => (shapeData.value.strokeDashArray?.length ?? 0) > 0);
    const dashArrayString = computed(() => {
      return shapeData.value.strokeDashArray?.join(", ") || "";
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...shapeData.value, [key]: value }
      });
      emit("update");
    }
    function toggleFill(e) {
      const checked = e.target.checked;
      update("fill", checked ? "#ffffff" : "");
    }
    function toggleStroke(e) {
      const checked = e.target.checked;
      if (checked) {
        update("stroke", "#ffffff");
        if ((shapeData.value.strokeWidth ?? 0) <= 0) {
          update("strokeWidth", 2);
        }
      } else {
        update("strokeWidth", 0);
      }
    }
    function updateDashArray(e) {
      const input = e.target.value;
      if (!input.trim()) {
        update("strokeDashArray", []);
        return;
      }
      const values = input.split(",").map((v) => parseFloat(v.trim())).filter((v) => !isNaN(v) && v >= 0);
      update("strokeDashArray", values);
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      update(dataKey, value);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
    }
    function toggleKeyframe(propName, dataKey) {
      ensureProperty(propName, dataKey);
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function ensureProperty(propName, dataKey) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        const currentValue = shapeData.value[dataKey] ?? 0;
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: currentValue,
          animated: false,
          keyframes: [],
          group: propName.includes("Trim") ? "Trim Paths" : propName.includes("Stroke") ? "Stroke" : propName.includes("Fill") ? "Fill" : "Shape"
        });
      }
    }
    const pathEffects = computed(() => {
      return (shapeData.value.pathEffects || []).sort((a, b) => a.order - b.order);
    });
    function getEffectDisplayName(type) {
      const names = {
        offsetPath: "Offset Path",
        roughen: "Roughen",
        wiggle: "Wiggle Path",
        zigzag: "Zig Zag",
        wave: "Wave"
      };
      return names[type] || type;
    }
    function generateId() {
      return `effect_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
    }
    function createAnimatableProp(value, name) {
      return {
        id: generateId(),
        name,
        type: "number",
        value,
        animated: false,
        keyframes: []
      };
    }
    function addEffect() {
      if (!newEffectType.value) return;
      const effects = [...shapeData.value.pathEffects || []];
      const newOrder = effects.length > 0 ? Math.max(...effects.map((e) => e.order)) + 1 : 0;
      let newEffect;
      switch (newEffectType.value) {
        case "offsetPath":
          newEffect = {
            id: generateId(),
            type: "offsetPath",
            enabled: true,
            order: newOrder,
            amount: createAnimatableProp(0, "Offset Amount"),
            lineJoin: "round",
            miterLimit: createAnimatableProp(4, "Miter Limit")
          };
          break;
        case "roughen":
          newEffect = {
            id: generateId(),
            type: "roughen",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(5, "Roughen Size"),
            detail: createAnimatableProp(2, "Roughen Detail"),
            seed: Math.floor(Math.random() * 99999)
          };
          break;
        case "wiggle":
          newEffect = {
            id: generateId(),
            type: "wiggle",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(10, "Wiggle Size"),
            detail: createAnimatableProp(3, "Wiggle Detail"),
            temporalPhase: createAnimatableProp(0, "Temporal Phase"),
            spatialPhase: createAnimatableProp(0, "Spatial Phase"),
            correlation: createAnimatableProp(50, "Correlation"),
            seed: Math.floor(Math.random() * 99999)
          };
          break;
        case "zigzag":
          newEffect = {
            id: generateId(),
            type: "zigzag",
            enabled: true,
            order: newOrder,
            size: createAnimatableProp(10, "Zig Zag Size"),
            ridgesPerSegment: createAnimatableProp(5, "Ridges Per Segment"),
            pointType: "smooth"
          };
          break;
        case "wave":
          newEffect = {
            id: generateId(),
            type: "wave",
            enabled: true,
            order: newOrder,
            amplitude: createAnimatableProp(10, "Wave Amplitude"),
            frequency: createAnimatableProp(2, "Wave Frequency"),
            phase: createAnimatableProp(0, "Wave Phase"),
            waveType: "sine"
          };
          break;
        default:
          return;
      }
      effects.push(newEffect);
      update("pathEffects", effects);
      newEffectType.value = "";
    }
    function removeEffect(effectId) {
      const effects = (shapeData.value.pathEffects || []).filter((e) => e.id !== effectId);
      update("pathEffects", effects);
    }
    function toggleEffect(effectId) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (effect) {
        effect.enabled = !effect.enabled;
        update("pathEffects", effects);
      }
    }
    function moveEffect(index, direction) {
      const effects = [...shapeData.value.pathEffects || []].sort((a, b) => a.order - b.order);
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= effects.length) return;
      const tempOrder = effects[index].order;
      effects[index].order = effects[newIndex].order;
      effects[newIndex].order = tempOrder;
      update("pathEffects", effects);
    }
    function getEffectPropValue(effect, propName) {
      const prop = effect[propName];
      if (prop === void 0) return 0;
      if (typeof prop === "number") return prop;
      return prop.value;
    }
    function isEffectPropAnimated(effect, propName) {
      const prop = effect[propName];
      if (!prop || typeof prop === "number") return false;
      return prop.animated ?? false;
    }
    function updateEffectProp(effectId, propName, value) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      const prop = effect[propName];
      if (prop && typeof prop === "object") {
        prop.value = value;
      } else {
        effect[propName] = value;
      }
      update("pathEffects", effects);
    }
    function updateEffectMeta(effectId, key, value) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      effect[key] = value;
      update("pathEffects", effects);
    }
    function toggleEffectKeyframe(effectId, propName) {
      const effects = [...shapeData.value.pathEffects || []];
      const effect = effects.find((e) => e.id === effectId);
      if (!effect) return;
      const prop = effect[propName];
      if (!prop || typeof prop === "number") return;
      const frame = store.currentFrame;
      const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
      if (hasKeyframeAtFrame) {
        prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
        prop.animated = prop.keyframes.length > 0;
      } else {
        prop.keyframes.push({
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          frame,
          value: prop.value,
          easing: "linear"
        });
        prop.animated = true;
      }
      update("pathEffects", effects);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("div", _hoisted_2$x, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("stroke"))
          }, [
            createBaseVNode("span", _hoisted_3$x, toDisplayString(expandedSections.value.includes("stroke") ? "" : ""), 1),
            _cache[31] || (_cache[31] = createBaseVNode("span", { class: "section-title" }, "Stroke", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasStroke.value,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleStroke,
              class: "section-toggle"
            }, null, 40, _hoisted_4$x)
          ]),
          expandedSections.value.includes("stroke") && hasStroke.value ? (openBlock(), createElementBlock("div", _hoisted_5$x, [
            createBaseVNode("div", _hoisted_6$x, [
              _cache[32] || (_cache[32] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_7$x, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.stroke || "#ffffff",
                  onInput: _cache[2] || (_cache[2] = (e) => update("stroke", e.target.value))
                }, null, 40, _hoisted_8$w)
              ])
            ]),
            createBaseVNode("div", _hoisted_9$w, [
              _cache[33] || (_cache[33] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Opacity") ?? shapeData.value.strokeOpacity ?? 100,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updateAnimatable("Stroke Opacity", v, "strokeOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Opacity") }]),
                onClick: _cache[4] || (_cache[4] = ($event) => toggleKeyframe("Stroke Opacity", "strokeOpacity"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_10$w, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Width", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Stroke Width") ?? shapeData.value.strokeWidth ?? 2,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateAnimatable("Stroke Width", v, "strokeWidth")),
                min: 0,
                max: 500,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Stroke Width") }]),
                onClick: _cache[6] || (_cache[6] = ($event) => toggleKeyframe("Stroke Width", "strokeWidth"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_11$v, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "Line Cap", -1)),
              createBaseVNode("div", _hoisted_12$t, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "butt" }),
                  onClick: _cache[7] || (_cache[7] = ($event) => update("strokeLineCap", "butt")),
                  title: "Butt Cap"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "round" }),
                  onClick: _cache[8] || (_cache[8] = ($event) => update("strokeLineCap", "round")),
                  title: "Round Cap"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineCap.value === "square" }),
                  onClick: _cache[9] || (_cache[9] = ($event) => update("strokeLineCap", "square")),
                  title: "Square Cap"
                }, "", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$t, [
              _cache[36] || (_cache[36] = createBaseVNode("label", null, "Line Join", -1)),
              createBaseVNode("div", _hoisted_14$q, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "miter" }),
                  onClick: _cache[10] || (_cache[10] = ($event) => update("strokeLineJoin", "miter")),
                  title: "Miter Join"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "round" }),
                  onClick: _cache[11] || (_cache[11] = ($event) => update("strokeLineJoin", "round")),
                  title: "Round Join"
                }, "", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: strokeLineJoin.value === "bevel" }),
                  onClick: _cache[12] || (_cache[12] = ($event) => update("strokeLineJoin", "bevel")),
                  title: "Bevel Join"
                }, "", 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_15$p, [
              _cache[37] || (_cache[37] = createBaseVNode("label", null, "Dashes", -1)),
              createBaseVNode("input", {
                type: "text",
                class: "dash-input",
                value: dashArrayString.value,
                onChange: updateDashArray,
                placeholder: "e.g. 10, 5",
                title: "Comma-separated dash pattern"
              }, null, 40, _hoisted_16$o)
            ]),
            hasDashes.value ? (openBlock(), createElementBlock("div", _hoisted_17$n, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Dash Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Dash Offset") ?? shapeData.value.strokeDashOffset ?? 0,
                "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateAnimatable("Dash Offset", v, "strokeDashOffset"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Dash Offset") }]),
                onClick: _cache[14] || (_cache[14] = ($event) => toggleKeyframe("Dash Offset", "strokeDashOffset"))
              }, "", 2)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_18$m, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[16] || (_cache[16] = ($event) => toggleSection("fill"))
          }, [
            createBaseVNode("span", _hoisted_19$m, toDisplayString(expandedSections.value.includes("fill") ? "" : ""), 1),
            _cache[39] || (_cache[39] = createBaseVNode("span", { class: "section-title" }, "Fill", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: hasFill.value,
              onClick: _cache[15] || (_cache[15] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleFill,
              class: "section-toggle"
            }, null, 40, _hoisted_20$m)
          ]),
          expandedSections.value.includes("fill") && hasFill.value ? (openBlock(), createElementBlock("div", _hoisted_21$m, [
            createBaseVNode("div", _hoisted_22$l, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Color", -1)),
              createBaseVNode("div", _hoisted_23$k, [
                createBaseVNode("input", {
                  type: "color",
                  value: shapeData.value.fill || "#ffffff",
                  onInput: _cache[17] || (_cache[17] = (e) => update("fill", e.target.value))
                }, null, 40, _hoisted_24$h)
              ])
            ]),
            createBaseVNode("div", _hoisted_25$g, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Fill Opacity") ?? shapeData.value.fillOpacity ?? 100,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updateAnimatable("Fill Opacity", v, "fillOpacity")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Fill Opacity") }]),
                onClick: _cache[19] || (_cache[19] = ($event) => toggleKeyframe("Fill Opacity", "fillOpacity"))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_26$f, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[20] || (_cache[20] = ($event) => toggleSection("trim"))
          }, [
            createBaseVNode("span", _hoisted_27$e, toDisplayString(expandedSections.value.includes("trim") ? "" : ""), 1),
            _cache[42] || (_cache[42] = createBaseVNode("span", { class: "section-title" }, "Trim Paths", -1))
          ]),
          expandedSections.value.includes("trim") ? (openBlock(), createElementBlock("div", _hoisted_28$e, [
            createBaseVNode("div", _hoisted_29$e, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Start", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Start") ?? shapeData.value.trimStart ?? 0,
                "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateAnimatable("Trim Start", v, "trimStart")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Start") }]),
                onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("Trim Start", "trimStart"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_30$d, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "End", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim End") ?? shapeData.value.trimEnd ?? 100,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updateAnimatable("Trim End", v, "trimEnd")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim End") }]),
                onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("Trim End", "trimEnd"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_31$a, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Trim Offset") ?? shapeData.value.trimOffset ?? 0,
                "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateAnimatable("Trim Offset", v, "trimOffset")),
                min: -360,
                max: 360,
                unit: ""
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Trim Offset") }]),
                onClick: _cache[26] || (_cache[26] = ($event) => toggleKeyframe("Trim Offset", "trimOffset"))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$a, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[27] || (_cache[27] = ($event) => toggleSection("effects"))
          }, [
            createBaseVNode("span", _hoisted_33$a, toDisplayString(expandedSections.value.includes("effects") ? "" : ""), 1),
            _cache[46] || (_cache[46] = createBaseVNode("span", { class: "section-title" }, "Path Effects", -1)),
            pathEffects.value.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_34$a, toDisplayString(pathEffects.value.length), 1)) : createCommentVNode("", true)
          ]),
          expandedSections.value.includes("effects") ? (openBlock(), createElementBlock("div", _hoisted_35$9, [
            createBaseVNode("div", _hoisted_36$9, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => newEffectType.value = $event),
                class: "effect-select"
              }, [..._cache[47] || (_cache[47] = [
                createStaticVNode('<option value="" data-v-3b6d48f0>Add Effect...</option><option value="offsetPath" data-v-3b6d48f0>Offset Path</option><option value="roughen" data-v-3b6d48f0>Roughen</option><option value="wiggle" data-v-3b6d48f0>Wiggle Path</option><option value="zigzag" data-v-3b6d48f0>Zig Zag</option><option value="wave" data-v-3b6d48f0>Wave</option>', 6)
              ])], 512), [
                [vModelSelect, newEffectType.value]
              ]),
              createBaseVNode("button", {
                class: "add-btn",
                onClick: addEffect,
                disabled: !newEffectType.value
              }, "+", 8, _hoisted_37$9)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(pathEffects.value, (effect, index) => {
              return openBlock(), createElementBlock("div", {
                key: effect.id,
                class: "effect-item"
              }, [
                createBaseVNode("div", _hoisted_38$9, [
                  createBaseVNode("button", {
                    class: "effect-toggle",
                    onClick: ($event) => toggleEffect(effect.id)
                  }, toDisplayString(effect.enabled ? "" : ""), 9, _hoisted_39$9),
                  createBaseVNode("span", _hoisted_40$8, toDisplayString(getEffectDisplayName(effect.type)), 1),
                  createBaseVNode("div", _hoisted_41$6, [
                    createBaseVNode("button", {
                      class: "effect-action",
                      onClick: ($event) => moveEffect(index, -1),
                      disabled: index === 0,
                      title: "Move Up"
                    }, "", 8, _hoisted_42$5),
                    createBaseVNode("button", {
                      class: "effect-action",
                      onClick: ($event) => moveEffect(index, 1),
                      disabled: index === pathEffects.value.length - 1,
                      title: "Move Down"
                    }, "", 8, _hoisted_43$5),
                    createBaseVNode("button", {
                      class: "effect-action delete",
                      onClick: ($event) => removeEffect(effect.id),
                      title: "Delete"
                    }, "", 8, _hoisted_44$5)
                  ])
                ]),
                effect.enabled ? (openBlock(), createElementBlock("div", _hoisted_45$5, [
                  effect.type === "offsetPath" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("div", _hoisted_46$5, [
                      _cache[48] || (_cache[48] = createBaseVNode("label", null, "Amount", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "amount"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "amount", v),
                        min: -100,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "amount") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "amount")
                      }, "", 10, _hoisted_47$5)
                    ]),
                    createBaseVNode("div", _hoisted_48$5, [
                      _cache[49] || (_cache[49] = createBaseVNode("label", null, "Join", -1)),
                      createBaseVNode("div", _hoisted_49$5, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "miter" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "miter")
                        }, "", 10, _hoisted_50$4),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "round" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "round")
                        }, "", 10, _hoisted_51$4),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.lineJoin === "bevel" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "lineJoin", "bevel")
                        }, "", 10, _hoisted_52$4)
                      ])
                    ])
                  ], 64)) : effect.type === "roughen" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createBaseVNode("div", _hoisted_53$4, [
                      _cache[50] || (_cache[50] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_54$4)
                    ]),
                    createBaseVNode("div", _hoisted_55$4, [
                      _cache[51] || (_cache[51] = createBaseVNode("label", null, "Detail", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "detail"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "detail", v),
                        min: 1,
                        max: 10,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "detail") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "detail")
                      }, "", 10, _hoisted_56$4)
                    ]),
                    createBaseVNode("div", _hoisted_57$3, [
                      _cache[52] || (_cache[52] = createBaseVNode("label", null, "Seed", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: effect.seed ?? 12345,
                        "onUpdate:modelValue": (v) => updateEffectMeta(effect.id, "seed", v),
                        min: 0,
                        max: 99999,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])
                  ], 64)) : effect.type === "wiggle" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createBaseVNode("div", _hoisted_58$3, [
                      _cache[53] || (_cache[53] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_59$3)
                    ]),
                    createBaseVNode("div", _hoisted_60$3, [
                      _cache[54] || (_cache[54] = createBaseVNode("label", null, "Detail", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "detail"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "detail", v),
                        min: 1,
                        max: 10,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "detail") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "detail")
                      }, "", 10, _hoisted_61$3)
                    ]),
                    createBaseVNode("div", _hoisted_62$3, [
                      _cache[55] || (_cache[55] = createBaseVNode("label", null, "Correlation", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "correlation"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "correlation", v),
                        min: 0,
                        max: 100,
                        unit: "%"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "correlation") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "correlation")
                      }, "", 10, _hoisted_63$1)
                    ]),
                    createBaseVNode("div", _hoisted_64$1, [
                      _cache[56] || (_cache[56] = createBaseVNode("label", null, "Temp Phase", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "temporalPhase"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "temporalPhase", v),
                        min: 0,
                        max: 360,
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "temporalPhase") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "temporalPhase")
                      }, "", 10, _hoisted_65$1)
                    ])
                  ], 64)) : effect.type === "zigzag" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                    createBaseVNode("div", _hoisted_66$1, [
                      _cache[57] || (_cache[57] = createBaseVNode("label", null, "Size", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "size"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "size", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "size") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "size")
                      }, "", 10, _hoisted_67$1)
                    ]),
                    createBaseVNode("div", _hoisted_68$1, [
                      _cache[58] || (_cache[58] = createBaseVNode("label", null, "Ridges", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "ridgesPerSegment"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "ridgesPerSegment", v),
                        min: 1,
                        max: 20,
                        step: 1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "ridgesPerSegment") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "ridgesPerSegment")
                      }, "", 10, _hoisted_69$1)
                    ]),
                    createBaseVNode("div", _hoisted_70$1, [
                      _cache[59] || (_cache[59] = createBaseVNode("label", null, "Points", -1)),
                      createBaseVNode("div", _hoisted_71$1, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.pointType === "corner" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "pointType", "corner")
                        }, "", 10, _hoisted_72$1),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.pointType === "smooth" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "pointType", "smooth")
                        }, "", 10, _hoisted_73$1)
                      ])
                    ])
                  ], 64)) : effect.type === "wave" ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                    createBaseVNode("div", _hoisted_74$1, [
                      _cache[60] || (_cache[60] = createBaseVNode("label", null, "Amplitude", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "amplitude"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "amplitude", v),
                        min: 0,
                        max: 100,
                        unit: "px"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "amplitude") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "amplitude")
                      }, "", 10, _hoisted_75$1)
                    ]),
                    createBaseVNode("div", _hoisted_76$1, [
                      _cache[61] || (_cache[61] = createBaseVNode("label", null, "Frequency", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "frequency"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "frequency", v),
                        min: 0.1,
                        max: 20,
                        step: 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "frequency") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "frequency")
                      }, "", 10, _hoisted_77$1)
                    ]),
                    createBaseVNode("div", _hoisted_78$1, [
                      _cache[62] || (_cache[62] = createBaseVNode("label", null, "Phase", -1)),
                      createVNode(unref(ScrubableNumber), {
                        modelValue: getEffectPropValue(effect, "phase"),
                        "onUpdate:modelValue": (v) => updateEffectProp(effect.id, "phase", v),
                        min: 0,
                        max: 360,
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      createBaseVNode("button", {
                        class: normalizeClass(["keyframe-btn", { active: isEffectPropAnimated(effect, "phase") }]),
                        onClick: ($event) => toggleEffectKeyframe(effect.id, "phase")
                      }, "", 10, _hoisted_79$1)
                    ]),
                    createBaseVNode("div", _hoisted_80$1, [
                      _cache[63] || (_cache[63] = createBaseVNode("label", null, "Type", -1)),
                      createBaseVNode("div", _hoisted_81$1, [
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "sine" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "sine")
                        }, "", 10, _hoisted_82$1),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "triangle" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "triangle")
                        }, "", 10, _hoisted_83$1),
                        createBaseVNode("button", {
                          class: normalizeClass({ active: effect.waveType === "square" }),
                          onClick: ($event) => updateEffectMeta(effect.id, "waveType", "square")
                        }, "", 10, _hoisted_84$1)
                      ])
                    ])
                  ], 64)) : createCommentVNode("", true)
                ])) : createCommentVNode("", true)
              ]);
            }), 128)),
            pathEffects.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_85$1, " No path effects. Use the dropdown above to add one. ")) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_86$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_87$1, toDisplayString(expandedSections.value.includes("path") ? "" : ""), 1),
            _cache[64] || (_cache[64] = createBaseVNode("span", { class: "section-title" }, "Path", -1))
          ]),
          expandedSections.value.includes("path") ? (openBlock(), createElementBlock("div", _hoisted_88$1, [
            createBaseVNode("div", _hoisted_89$1, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: shapeData.value.closed,
                  onChange: _cache[30] || (_cache[30] = ($event) => update("closed", $event.target.checked))
                }, null, 40, _hoisted_90$1),
                _cache[65] || (_cache[65] = createTextVNode(" Closed Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_91, [
              _cache[66] || (_cache[66] = createBaseVNode("span", { class: "info-label" }, "Points:", -1)),
              createBaseVNode("span", _hoisted_92, toDisplayString(shapeData.value.controlPoints?.length || 0), 1)
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ShapeProperties = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__scopeId", "data-v-3b6d48f0"]]);

const _hoisted_1$w = { class: "video-properties" };
const _hoisted_2$w = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$w = { class: "section-content info-grid" };
const _hoisted_4$w = { class: "info-row" };
const _hoisted_5$w = { class: "info-value" };
const _hoisted_6$w = { class: "info-row" };
const _hoisted_7$w = { class: "info-value" };
const _hoisted_8$v = { class: "info-row" };
const _hoisted_9$v = { class: "info-value" };
const _hoisted_10$v = { class: "info-row" };
const _hoisted_11$u = { class: "info-value" };
const _hoisted_12$s = { class: "property-section" };
const _hoisted_13$s = { class: "section-content" };
const _hoisted_14$p = { class: "property-row" };
const _hoisted_15$o = { class: "property-row" };
const _hoisted_16$n = { class: "property-row" };
const _hoisted_17$m = { class: "checkbox-group" };
const _hoisted_18$l = { class: "checkbox-row" };
const _hoisted_19$l = ["checked"];
const _hoisted_20$l = { class: "checkbox-row" };
const _hoisted_21$l = ["checked"];
const _hoisted_22$k = { class: "property-section" };
const _hoisted_23$j = { class: "section-header" };
const _hoisted_24$g = { class: "header-toggle" };
const _hoisted_25$f = ["checked"];
const _hoisted_26$e = {
  key: 0,
  class: "section-content"
};
const _hoisted_27$d = { class: "property-row" };
const _hoisted_28$d = { class: "control-with-keyframe" };
const _hoisted_29$d = { class: "property-section" };
const _hoisted_30$c = { class: "section-content" };
const _hoisted_31$9 = { class: "property-row" };
const _hoisted_32$9 = ["value"];
const _hoisted_33$9 = {
  key: 1,
  class: "property-section"
};
const _hoisted_34$9 = { class: "section-content" };
const _hoisted_35$8 = { class: "checkbox-group" };
const _hoisted_36$8 = { class: "checkbox-row" };
const _hoisted_37$8 = ["checked"];
const _hoisted_38$8 = {
  key: 0,
  class: "property-row"
};
const _hoisted_39$8 = { class: "control-with-keyframe" };
const _hoisted_40$7 = {
  key: 1,
  class: "property-row"
};
const _hoisted_41$5 = {
  key: 2,
  class: "waveform-container"
};
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const videoData = computed(() => {
      return props.layer.data || {
        assetId: null,
        loop: false,
        pingPong: false,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: false,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: true,
        audioLevel: 100,
        posterFrame: 0
      };
    });
    const assetInfo = computed(() => {
      const assetId = videoData.value.assetId;
      if (!assetId) return null;
      return store.assets[assetId] || null;
    });
    const audioLevel = computed(() => {
      return props.layer.audio?.level;
    });
    const timeRemapValue = computed(() => {
      if (!videoData.value.timeRemap) return 0;
      return videoData.value.timeRemap.value;
    });
    function formatDuration(seconds) {
      if (!seconds) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = Math.floor(seconds % 1 * (assetInfo.value?.fps || 30));
      return `${mins}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
    }
    function updateSpeed(val) {
      store.updateVideoLayerData(props.layer.id, { speed: val });
      emit("update");
    }
    function updateStartTime(val) {
      store.updateVideoLayerData(props.layer.id, { startTime: val });
      emit("update");
    }
    function updateEndTime(val) {
      store.updateVideoLayerData(props.layer.id, { endTime: val });
      emit("update");
    }
    function updateLoop(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { loop: target.checked });
      emit("update");
    }
    function updatePingPong(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { pingPong: target.checked });
      emit("update");
    }
    function toggleTimeRemap(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { timeRemapEnabled: target.checked });
      emit("update");
    }
    function updateTimeRemap(val) {
      const data = props.layer.data;
      if (data.timeRemap) {
        data.timeRemap.value = val;
      }
      emit("update");
    }
    function updateFrameBlending(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { frameBlending: target.value });
      emit("update");
    }
    function updateAudioEnabled(e) {
      const target = e.target;
      store.updateVideoLayerData(props.layer.id, { audioEnabled: target.checked });
      emit("update");
    }
    function updateAudioLevel(val) {
      store.updateVideoLayerData(props.layer.id, { audioLevel: val });
      emit("update");
    }
    function updateLevel(val) {
      if (props.layer.audio?.level) {
        props.layer.audio.level.value = val;
        emit("update");
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$w, [
        assetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "section-header" }, "Video Info", -1)),
          createBaseVNode("div", _hoisted_3$w, [
            createBaseVNode("div", _hoisted_4$w, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_5$w, toDisplayString(assetInfo.value.width) + "  " + toDisplayString(assetInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_6$w, [
              _cache[1] || (_cache[1] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_7$w, toDisplayString(formatDuration(assetInfo.value.duration)), 1)
            ]),
            createBaseVNode("div", _hoisted_8$v, [
              _cache[2] || (_cache[2] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_9$v, toDisplayString(assetInfo.value.fps?.toFixed(2) || "?") + " fps", 1)
            ]),
            createBaseVNode("div", _hoisted_10$v, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "info-label" }, "Has Audio", -1)),
              createBaseVNode("span", _hoisted_11$u, toDisplayString(assetInfo.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_12$s, [
          _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, "Playback", -1)),
          createBaseVNode("div", _hoisted_13$s, [
            createBaseVNode("div", _hoisted_14$p, [
              _cache[5] || (_cache[5] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.speed,
                "onUpdate:modelValue": updateSpeed,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$o, [
              _cache[6] || (_cache[6] = createBaseVNode("label", null, "Start Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.startTime,
                "onUpdate:modelValue": updateStartTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_16$n, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "End Time", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.endTime || assetInfo.value?.duration || 0,
                "onUpdate:modelValue": updateEndTime,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_17$m, [
              createBaseVNode("label", _hoisted_18$l, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.loop,
                  onChange: updateLoop
                }, null, 40, _hoisted_19$l),
                _cache[8] || (_cache[8] = createBaseVNode("span", null, "Loop", -1))
              ]),
              createBaseVNode("label", _hoisted_20$l, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.pingPong,
                  onChange: updatePingPong
                }, null, 40, _hoisted_21$l),
                _cache[9] || (_cache[9] = createBaseVNode("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_22$k, [
          createBaseVNode("div", _hoisted_23$j, [
            _cache[11] || (_cache[11] = createBaseVNode("span", null, "Time Remap", -1)),
            createBaseVNode("label", _hoisted_24$g, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: videoData.value.timeRemapEnabled,
                onChange: toggleTimeRemap
              }, null, 40, _hoisted_25$f)
            ])
          ]),
          videoData.value.timeRemapEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$e, [
            createBaseVNode("div", _hoisted_27$d, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Remap Time", -1)),
              createBaseVNode("div", _hoisted_28$d, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: timeRemapValue.value,
                  "onUpdate:modelValue": updateTimeRemap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                videoData.value.timeRemap ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: videoData.value.timeRemap,
                  layerId: __props.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[13] || (_cache[13] = createBaseVNode("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_29$d, [
          _cache[16] || (_cache[16] = createBaseVNode("div", { class: "section-header" }, "Frame Blending", -1)),
          createBaseVNode("div", _hoisted_30$c, [
            createBaseVNode("div", _hoisted_31$9, [
              _cache[15] || (_cache[15] = createBaseVNode("label", null, "Mode", -1)),
              createBaseVNode("select", {
                value: videoData.value.frameBlending,
                onChange: updateFrameBlending,
                class: "select-input"
              }, [..._cache[14] || (_cache[14] = [
                createBaseVNode("option", { value: "none" }, "None", -1),
                createBaseVNode("option", { value: "frame-mix" }, "Frame Mix", -1),
                createBaseVNode("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, _hoisted_32$9)
            ])
          ])
        ]),
        assetInfo.value?.hasAudio !== false ? (openBlock(), createElementBlock("div", _hoisted_33$9, [
          _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, "Audio", -1)),
          createBaseVNode("div", _hoisted_34$9, [
            createBaseVNode("div", _hoisted_35$8, [
              createBaseVNode("label", _hoisted_36$8, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: videoData.value.audioEnabled,
                  onChange: updateAudioEnabled
                }, null, 40, _hoisted_37$8),
                _cache[17] || (_cache[17] = createBaseVNode("span", null, "Audio Enabled", -1))
              ])
            ]),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_38$8, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Level", -1)),
              createBaseVNode("div", _hoisted_39$8, [
                audioLevel.value ? (openBlock(), createBlock(unref(ScrubableNumber), {
                  key: 0,
                  modelValue: audioLevel.value.value,
                  "onUpdate:modelValue": updateLevel,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : createCommentVNode("", true),
                audioLevel.value ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 1,
                  property: audioLevel.value,
                  layerId: __props.layer.id
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_40$7, [
              _cache[19] || (_cache[19] = createBaseVNode("label", null, "Volume", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: videoData.value.audioLevel,
                "onUpdate:modelValue": updateAudioLevel,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true),
            videoData.value.audioEnabled ? (openBlock(), createElementBlock("div", _hoisted_41$5, [..._cache[20] || (_cache[20] = [
              createBaseVNode("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const VideoProperties = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__scopeId", "data-v-7359ac3b"]]);

const _hoisted_1$v = { class: "camera-properties" };
const _hoisted_2$v = { class: "prop-section" };
const _hoisted_3$v = { class: "expand-icon" };
const _hoisted_4$v = {
  key: 0,
  class: "section-content"
};
const _hoisted_5$v = { class: "property-row checkbox-row" };
const _hoisted_6$v = ["checked"];
const _hoisted_7$v = { class: "property-row" };
const _hoisted_8$u = { class: "property-row" };
const _hoisted_9$u = { class: "prop-section" };
const _hoisted_10$u = { class: "expand-icon" };
const _hoisted_11$t = ["checked"];
const _hoisted_12$r = {
  key: 0,
  class: "section-content"
};
const _hoisted_13$r = { class: "property-row" };
const _hoisted_14$o = { class: "property-row" };
const _hoisted_15$n = { class: "property-row" };
const _hoisted_16$m = { class: "prop-section" };
const _hoisted_17$l = { class: "expand-icon" };
const _hoisted_18$k = ["checked"];
const _hoisted_19$k = {
  key: 0,
  class: "section-content"
};
const _hoisted_20$k = { class: "property-row" };
const _hoisted_21$k = ["value"];
const _hoisted_22$j = ["value"];
const _hoisted_23$i = { class: "property-row" };
const _hoisted_24$f = { class: "property-row" };
const _hoisted_25$e = { class: "property-row" };
const _hoisted_26$d = { class: "property-row" };
const _hoisted_27$c = { class: "property-row checkbox-row" };
const _hoisted_28$c = ["checked"];
const _hoisted_29$c = { class: "property-row checkbox-row" };
const _hoisted_30$b = ["checked"];
const _hoisted_31$8 = {
  key: 0,
  class: "property-row"
};
const _hoisted_32$8 = { class: "prop-section" };
const _hoisted_33$8 = { class: "expand-icon" };
const _hoisted_34$8 = {
  key: 0,
  class: "section-content"
};
const _hoisted_35$7 = { class: "property-row" };
const _hoisted_36$7 = { class: "property-row" };
const _hoisted_37$7 = { class: "property-row" };
const _hoisted_38$7 = { class: "property-row" };
const _hoisted_39$7 = { class: "property-row" };
const _hoisted_40$6 = { class: "property-row" };
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const expandedSections = ref(["settings", "dof"]);
    const cameraData = computed(() => {
      return props.layer.data || {
        cameraId: "",
        isActiveCamera: false
      };
    });
    const depthOfField = computed(() => {
      return cameraData.value.depthOfField || {
        enabled: false,
        focusDistance: 500,
        aperture: 2.8,
        blurLevel: 50
      };
    });
    const dofEnabled = computed(() => depthOfField.value.enabled);
    const pathFollowing = computed(() => {
      return cameraData.value.pathFollowing || {
        enabled: false,
        pathLayerId: "",
        parameter: { id: "", name: "Path Position", type: "number", value: 0, animated: false, keyframes: [], group: "Path Following" },
        lookAhead: 0.05,
        bankingStrength: 0,
        offsetY: 0,
        alignToPath: true,
        autoAdvance: false,
        autoAdvanceSpeed: 0.01
      };
    });
    const splineLayers = computed(() => {
      return store.layers.filter((l) => l.type === "spline" && l.id !== props.layer.id);
    });
    function toggleSection(section) {
      const idx = expandedSections.value.indexOf(section);
      if (idx >= 0) {
        expandedSections.value.splice(idx, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function update(key, value) {
      store.updateLayer(props.layer.id, {
        data: { ...cameraData.value, [key]: value }
      });
      emit("update");
    }
    function toggleDOF(e) {
      const checked = e.target.checked;
      const newDOF = { ...depthOfField.value, enabled: checked };
      update("depthOfField", newDOF);
    }
    function togglePathFollowing(e) {
      const checked = e.target.checked;
      const newPath = { ...pathFollowing.value, enabled: checked };
      update("pathFollowing", newPath);
    }
    function updatePathLayer(e) {
      const layerId = e.target.value;
      const newPath = { ...pathFollowing.value, pathLayerId: layerId };
      update("pathFollowing", newPath);
    }
    function updatePathConfig(key, value) {
      const newPath = { ...pathFollowing.value, [key]: value };
      update("pathFollowing", newPath);
    }
    function updatePathProperty(key, value) {
      const param = pathFollowing.value.parameter;
      const newParam = { ...param, value };
      const newPath = { ...pathFollowing.value, parameter: newParam };
      update("pathFollowing", newPath);
      const prop = getProperty("Path Position");
      if (prop) {
        prop.value = value;
      }
    }
    function getProperty(name) {
      return props.layer.properties?.find((p) => p.name === name);
    }
    function getPropertyValue(name) {
      const prop = getProperty(name);
      return prop?.value;
    }
    function isAnimated(name) {
      const prop = getProperty(name);
      return prop?.animated ?? false;
    }
    function updateAnimatable(propName, value, dataKey) {
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      const animProp = cameraData.value[dataKey];
      if (animProp) {
        animProp.value = value;
        update(dataKey, animProp);
      }
      emit("update");
    }
    function updateDOFAnimatable(propName, value, dofKey) {
      const newDOF = { ...depthOfField.value, [dofKey]: value };
      update("depthOfField", newDOF);
      const prop = getProperty(propName);
      if (prop) {
        prop.value = value;
      }
      emit("update");
    }
    function ensureProperty(propName, defaultValue, group) {
      if (!props.layer.properties) {
        props.layer.properties = [];
      }
      const existing = props.layer.properties.find((p) => p.name === propName);
      if (!existing) {
        props.layer.properties.push({
          id: `prop_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          name: propName,
          type: "number",
          value: defaultValue,
          animated: false,
          keyframes: [],
          group
        });
      }
    }
    function toggleKeyframe(propName, dataKey, defaultValue) {
      ensureProperty(propName, defaultValue, propName.includes("Focus") || propName.includes("Aperture") || propName.includes("Blur") ? "Depth of Field" : "Camera");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function togglePathKeyframe(propName) {
      ensureProperty(propName, pathFollowing.value.parameter?.value ?? 0, "Path Following");
      const prop = getProperty(propName);
      if (prop) {
        const frame = store.currentFrame;
        const hasKeyframeAtFrame = prop.keyframes.some((k) => k.frame === frame);
        if (hasKeyframeAtFrame) {
          prop.keyframes = prop.keyframes.filter((k) => k.frame !== frame);
          prop.animated = prop.keyframes.length > 0;
        } else {
          prop.keyframes.push({
            id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            frame,
            value: prop.value,
            easing: "linear"
          });
          prop.animated = true;
        }
        emit("update");
      }
    }
    function getVec3Value(propName, axis) {
      const dataKey = propName === "Position" ? "animatedPosition" : "animatedTarget";
      const animProp = cameraData.value[dataKey];
      if (animProp?.value) {
        return animProp.value[axis] ?? 0;
      }
      return 0;
    }
    function updateVec3Property(propName, axis, value, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const newValue = { ...animProp.value, [axis]: value };
      animProp.value = newValue;
      update(dataKey, animProp);
    }
    function toggleVec3Keyframe(propName, dataKey) {
      let animProp = cameraData.value[dataKey];
      if (!animProp) {
        animProp = {
          id: `prop_${dataKey}_${Date.now()}`,
          name: propName,
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: [],
          group: "Position & Target"
        };
      }
      const frame = store.currentFrame;
      const hasKeyframeAtFrame = animProp.keyframes.some((k) => k.frame === frame);
      if (hasKeyframeAtFrame) {
        animProp.keyframes = animProp.keyframes.filter((k) => k.frame !== frame);
        animProp.animated = animProp.keyframes.length > 0;
      } else {
        animProp.keyframes.push({
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          frame,
          value: { ...animProp.value },
          easing: "linear"
        });
        animProp.animated = true;
      }
      update(dataKey, animProp);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$v, [
        createBaseVNode("div", _hoisted_2$v, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("settings"))
          }, [
            createBaseVNode("span", _hoisted_3$v, toDisplayString(expandedSections.value.includes("settings") ? "" : ""), 1),
            _cache[33] || (_cache[33] = createBaseVNode("span", { class: "section-title" }, "Camera Settings", -1))
          ]),
          expandedSections.value.includes("settings") ? (openBlock(), createElementBlock("div", _hoisted_4$v, [
            createBaseVNode("div", _hoisted_5$v, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: cameraData.value.isActiveCamera,
                  onChange: _cache[1] || (_cache[1] = ($event) => update("isActiveCamera", $event.target.checked))
                }, null, 40, _hoisted_6$v),
                _cache[34] || (_cache[34] = createTextVNode(" Active Camera ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_7$v, [
              _cache[35] || (_cache[35] = createBaseVNode("label", null, "FOV", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("FOV") ?? 50,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updateAnimatable("FOV", v, "animatedFov")),
                min: 10,
                max: 120,
                unit: ""
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("FOV") }]),
                onClick: _cache[3] || (_cache[3] = ($event) => toggleKeyframe("FOV", "animatedFov", 50))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_8$u, [
              _cache[36] || (_cache[36] = createBaseVNode("label", null, "Focal Length", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focal Length") ?? 50,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updateAnimatable("Focal Length", v, "animatedFocalLength")),
                min: 10,
                max: 300,
                unit: "mm"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focal Length") }]),
                onClick: _cache[5] || (_cache[5] = ($event) => toggleKeyframe("Focal Length", "animatedFocalLength", 50))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_9$u, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("dof"))
          }, [
            createBaseVNode("span", _hoisted_10$u, toDisplayString(expandedSections.value.includes("dof") ? "" : ""), 1),
            _cache[37] || (_cache[37] = createBaseVNode("span", { class: "section-title" }, "Depth of Field", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: dofEnabled.value,
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"])),
              onChange: toggleDOF,
              class: "section-toggle"
            }, null, 40, _hoisted_11$t)
          ]),
          expandedSections.value.includes("dof") && dofEnabled.value ? (openBlock(), createElementBlock("div", _hoisted_12$r, [
            createBaseVNode("div", _hoisted_13$r, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Focus Distance", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Focus Distance") ?? depthOfField.value.focusDistance,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateDOFAnimatable("Focus Distance", v, "focusDistance")),
                min: 0,
                max: 1e4,
                unit: "px"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Focus Distance") }]),
                onClick: _cache[9] || (_cache[9] = ($event) => toggleKeyframe("Focus Distance", "animatedFocusDistance", depthOfField.value.focusDistance))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_14$o, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Aperture", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Aperture") ?? depthOfField.value.aperture,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateDOFAnimatable("Aperture", v, "aperture")),
                min: 0.5,
                max: 32,
                step: 0.1,
                unit: "f/"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Aperture") }]),
                onClick: _cache[11] || (_cache[11] = ($event) => toggleKeyframe("Aperture", "animatedAperture", depthOfField.value.aperture))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_15$n, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Blur Level", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Blur Level") ?? depthOfField.value.blurLevel,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateDOFAnimatable("Blur Level", v, "blurLevel")),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Blur Level") }]),
                onClick: _cache[13] || (_cache[13] = ($event) => toggleKeyframe("Blur Level", "animatedBlurLevel", depthOfField.value.blurLevel))
              }, "", 2)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_16$m, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[15] || (_cache[15] = ($event) => toggleSection("path"))
          }, [
            createBaseVNode("span", _hoisted_17$l, toDisplayString(expandedSections.value.includes("path") ? "" : ""), 1),
            _cache[41] || (_cache[41] = createBaseVNode("span", { class: "section-title" }, "Path Following", -1)),
            createBaseVNode("input", {
              type: "checkbox",
              checked: pathFollowing.value.enabled,
              onClick: _cache[14] || (_cache[14] = withModifiers(() => {
              }, ["stop"])),
              onChange: togglePathFollowing,
              class: "section-toggle"
            }, null, 40, _hoisted_18$k)
          ]),
          expandedSections.value.includes("path") && pathFollowing.value.enabled ? (openBlock(), createElementBlock("div", _hoisted_19$k, [
            createBaseVNode("div", _hoisted_20$k, [
              _cache[43] || (_cache[43] = createBaseVNode("label", null, "Path Layer", -1)),
              createBaseVNode("select", {
                class: "path-select",
                value: pathFollowing.value.pathLayerId,
                onChange: updatePathLayer
              }, [
                _cache[42] || (_cache[42] = createBaseVNode("option", { value: "" }, "Select Path...", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(splineLayers.value, (layer) => {
                  return openBlock(), createElementBlock("option", {
                    key: layer.id,
                    value: layer.id
                  }, toDisplayString(layer.name), 9, _hoisted_22$j);
                }), 128))
              ], 40, _hoisted_21$k)
            ]),
            createBaseVNode("div", _hoisted_23$i, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Position", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getPropertyValue("Path Position") ?? pathFollowing.value.parameter?.value ?? 0,
                "onUpdate:modelValue": _cache[16] || (_cache[16] = (v) => updatePathProperty("parameter", v)),
                min: 0,
                max: 1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Path Position") }]),
                onClick: _cache[17] || (_cache[17] = ($event) => togglePathKeyframe("Path Position"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_24$f, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Look Ahead", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.lookAhead ?? 0.05,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = (v) => updatePathConfig("lookAhead", v)),
                min: 0,
                max: 0.5,
                step: 0.01,
                precision: 2
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$e, [
              _cache[46] || (_cache[46] = createBaseVNode("label", null, "Banking", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.bankingStrength ?? 0,
                "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updatePathConfig("bankingStrength", v)),
                min: 0,
                max: 1,
                step: 0.05
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_26$d, [
              _cache[47] || (_cache[47] = createBaseVNode("label", null, "Height Offset", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.offsetY ?? 0,
                "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updatePathConfig("offsetY", v)),
                unit: "px"
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_27$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.alignToPath,
                  onChange: _cache[21] || (_cache[21] = ($event) => updatePathConfig("alignToPath", $event.target.checked))
                }, null, 40, _hoisted_28$c),
                _cache[48] || (_cache[48] = createTextVNode(" Align to Path ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$c, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: pathFollowing.value.autoAdvance,
                  onChange: _cache[22] || (_cache[22] = ($event) => updatePathConfig("autoAdvance", $event.target.checked))
                }, null, 40, _hoisted_30$b),
                _cache[49] || (_cache[49] = createTextVNode(" Auto Advance ", -1))
              ])
            ]),
            pathFollowing.value.autoAdvance ? (openBlock(), createElementBlock("div", _hoisted_31$8, [
              _cache[50] || (_cache[50] = createBaseVNode("label", null, "Speed", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: pathFollowing.value.autoAdvanceSpeed ?? 0.01,
                "onUpdate:modelValue": _cache[23] || (_cache[23] = (v) => updatePathConfig("autoAdvanceSpeed", v)),
                min: 1e-3,
                max: 0.1,
                step: 1e-3,
                precision: 3
              }, null, 8, ["modelValue"])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_32$8, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[24] || (_cache[24] = ($event) => toggleSection("position"))
          }, [
            createBaseVNode("span", _hoisted_33$8, toDisplayString(expandedSections.value.includes("position") ? "" : ""), 1),
            _cache[51] || (_cache[51] = createBaseVNode("span", { class: "section-title" }, "Position & Target", -1))
          ]),
          expandedSections.value.includes("position") ? (openBlock(), createElementBlock("div", _hoisted_34$8, [
            createBaseVNode("div", _hoisted_35$7, [
              _cache[52] || (_cache[52] = createBaseVNode("label", null, "Position X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "x"),
                "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateVec3Property("Position", "x", v, "animatedPosition"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Position") }]),
                onClick: _cache[26] || (_cache[26] = ($event) => toggleVec3Keyframe("Position", "animatedPosition"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_36$7, [
              _cache[53] || (_cache[53] = createBaseVNode("label", null, "Position Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "y"),
                "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateVec3Property("Position", "y", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_37$7, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Position Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Position", "z"),
                "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateVec3Property("Position", "z", v, "animatedPosition"))
              }, null, 8, ["modelValue"])
            ]),
            _cache[58] || (_cache[58] = createBaseVNode("div", { class: "property-row separator" }, [
              createBaseVNode("span", { class: "separator-line" })
            ], -1)),
            createBaseVNode("div", _hoisted_38$7, [
              _cache[55] || (_cache[55] = createBaseVNode("label", null, "Target X", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "x"),
                "onUpdate:modelValue": _cache[29] || (_cache[29] = (v) => updateVec3Property("Target", "x", v, "animatedTarget"))
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["keyframe-btn", { active: isAnimated("Target") }]),
                onClick: _cache[30] || (_cache[30] = ($event) => toggleVec3Keyframe("Target", "animatedTarget"))
              }, "", 2)
            ]),
            createBaseVNode("div", _hoisted_39$7, [
              _cache[56] || (_cache[56] = createBaseVNode("label", null, "Target Y", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "y"),
                "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateVec3Property("Target", "y", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_40$6, [
              _cache[57] || (_cache[57] = createBaseVNode("label", null, "Target Z", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: getVec3Value("Target", "z"),
                "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateVec3Property("Target", "z", v, "animatedTarget"))
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const CameraProperties$1 = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-90372e3d"]]);

const _hoisted_1$u = { class: "nested-comp-properties" };
const _hoisted_2$u = {
  key: 0,
  class: "property-section"
};
const _hoisted_3$u = { class: "section-content info-grid" };
const _hoisted_4$u = { class: "info-row" };
const _hoisted_5$u = { class: "info-value" };
const _hoisted_6$u = { class: "info-row" };
const _hoisted_7$u = { class: "info-value" };
const _hoisted_8$t = { class: "info-row" };
const _hoisted_9$t = { class: "info-value" };
const _hoisted_10$t = { class: "info-row" };
const _hoisted_11$s = { class: "info-value" };
const _hoisted_12$q = { class: "property-section" };
const _hoisted_13$q = { class: "section-header" };
const _hoisted_14$n = { class: "header-toggle" };
const _hoisted_15$m = ["checked"];
const _hoisted_16$l = {
  key: 0,
  class: "section-content"
};
const _hoisted_17$k = { class: "property-row" };
const _hoisted_18$j = { class: "control-with-keyframe" };
const _hoisted_19$j = { class: "property-section" };
const _hoisted_20$j = { class: "section-header" };
const _hoisted_21$j = { class: "header-toggle" };
const _hoisted_22$i = ["checked"];
const _hoisted_23$h = {
  key: 0,
  class: "section-content"
};
const _hoisted_24$e = { class: "property-row" };
const _hoisted_25$d = { class: "property-section" };
const _hoisted_26$c = { class: "section-content" };
const _hoisted_27$b = { class: "checkbox-group" };
const _hoisted_28$b = { class: "checkbox-row" };
const _hoisted_29$b = ["checked"];
const _hoisted_30$a = {
  key: 0,
  class: "hint"
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "NestedCompProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const nestedCompData = computed(() => {
      const data = props.layer.data;
      return {
        compositionId: data?.compositionId ?? "",
        timeRemapEnabled: data?.timeRemapEnabled ?? false,
        timeRemap: data?.timeRemap,
        flattenTransform: data?.flattenTransform ?? false,
        overrideFrameRate: data?.overrideFrameRate ?? false,
        frameRate: data?.frameRate
      };
    });
    const compInfo = computed(() => {
      if (!nestedCompData.value.compositionId) return null;
      const comp = store.project.compositions[nestedCompData.value.compositionId];
      if (!comp) return null;
      return {
        name: comp.name,
        width: comp.settings.width,
        height: comp.settings.height,
        frameCount: comp.settings.frameCount,
        fps: comp.settings.fps,
        duration: comp.settings.duration
      };
    });
    const timeRemapValue = computed(() => {
      if (!nestedCompData.value.timeRemap) return 0;
      return nestedCompData.value.timeRemap.value;
    });
    function formatDuration(seconds) {
      if (seconds === void 0) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(2);
      return `${mins}:${secs.padStart(5, "0")}`;
    }
    function enterNestedComp() {
      if (nestedCompData.value.compositionId) {
        store.enterNestedComp(nestedCompData.value.compositionId);
      }
    }
    function toggleTimeRemap(e) {
      const enabled = e.target.checked;
      const updates = { timeRemapEnabled: enabled };
      if (enabled && !nestedCompData.value.timeRemap) {
        updates.timeRemap = createAnimatableProperty("Time Remap", 0, "number");
      }
      store.updateLayerData(props.layer.id, updates);
      emit("update", updates);
    }
    function updateTimeRemap(value) {
      if (nestedCompData.value.timeRemap) {
        const timeRemap = {
          ...nestedCompData.value.timeRemap,
          value
        };
        store.updateLayerData(props.layer.id, { timeRemap });
        emit("update", { timeRemap });
      }
    }
    function toggleFrameRateOverride(e) {
      const enabled = e.target.checked;
      const updates = {
        overrideFrameRate: enabled,
        frameRate: enabled ? compInfo.value?.fps || 30 : void 0
      };
      store.updateLayerData(props.layer.id, updates);
      emit("update", updates);
    }
    function updateFrameRate(value) {
      store.updateLayerData(props.layer.id, { frameRate: value });
      emit("update", { frameRate: value });
    }
    function updateFlattenTransform(e) {
      const enabled = e.target.checked;
      store.updateLayerData(props.layer.id, { flattenTransform: enabled });
      store.updateLayer(props.layer.id, { flattenTransform: enabled });
      emit("update", { flattenTransform: enabled });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$u, [
        compInfo.value ? (openBlock(), createElementBlock("div", _hoisted_2$u, [
          _cache[4] || (_cache[4] = createBaseVNode("div", { class: "section-header" }, "Composition Info", -1)),
          createBaseVNode("div", _hoisted_3$u, [
            createBaseVNode("div", _hoisted_4$u, [
              _cache[0] || (_cache[0] = createBaseVNode("span", { class: "info-label" }, "Name", -1)),
              createBaseVNode("span", _hoisted_5$u, toDisplayString(compInfo.value.name), 1)
            ]),
            createBaseVNode("div", _hoisted_6$u, [
              _cache[1] || (_cache[1] = createBaseVNode("span", { class: "info-label" }, "Dimensions", -1)),
              createBaseVNode("span", _hoisted_7$u, toDisplayString(compInfo.value.width) + " x " + toDisplayString(compInfo.value.height), 1)
            ]),
            createBaseVNode("div", _hoisted_8$t, [
              _cache[2] || (_cache[2] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
              createBaseVNode("span", _hoisted_9$t, toDisplayString(compInfo.value.frameCount) + " frames (" + toDisplayString(formatDuration(compInfo.value.duration)) + ")", 1)
            ]),
            createBaseVNode("div", _hoisted_10$t, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
              createBaseVNode("span", _hoisted_11$s, toDisplayString(compInfo.value.fps) + " fps", 1)
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", { class: "property-section" }, [
          _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, "Actions", -1)),
          createBaseVNode("div", { class: "section-content" }, [
            createBaseVNode("button", {
              class: "action-btn",
              onClick: enterNestedComp
            }, " Enter Composition ")
          ])
        ]),
        createBaseVNode("div", _hoisted_12$q, [
          createBaseVNode("div", _hoisted_13$q, [
            _cache[6] || (_cache[6] = createBaseVNode("span", null, "Time Remap", -1)),
            createBaseVNode("label", _hoisted_14$n, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: nestedCompData.value.timeRemapEnabled,
                onChange: toggleTimeRemap
              }, null, 40, _hoisted_15$m)
            ])
          ]),
          nestedCompData.value.timeRemapEnabled ? (openBlock(), createElementBlock("div", _hoisted_16$l, [
            createBaseVNode("div", _hoisted_17$k, [
              _cache[7] || (_cache[7] = createBaseVNode("label", null, "Remap Time", -1)),
              createBaseVNode("div", _hoisted_18$j, [
                createVNode(unref(ScrubableNumber), {
                  modelValue: timeRemapValue.value,
                  "onUpdate:modelValue": updateTimeRemap,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                nestedCompData.value.timeRemap ? (openBlock(), createBlock(KeyframeToggle, {
                  key: 0,
                  property: nestedCompData.value.timeRemap,
                  layerId: __props.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : createCommentVNode("", true)
              ])
            ]),
            _cache[8] || (_cache[8] = createBaseVNode("p", { class: "hint" }, "Animate to control nested comp playback independently of composition time.", -1))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_19$j, [
          createBaseVNode("div", _hoisted_20$j, [
            _cache[9] || (_cache[9] = createBaseVNode("span", null, "Frame Rate Override", -1)),
            createBaseVNode("label", _hoisted_21$j, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: nestedCompData.value.overrideFrameRate,
                onChange: toggleFrameRateOverride
              }, null, 40, _hoisted_22$i)
            ])
          ]),
          nestedCompData.value.overrideFrameRate ? (openBlock(), createElementBlock("div", _hoisted_23$h, [
            createBaseVNode("div", _hoisted_24$e, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Frame Rate", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: nestedCompData.value.frameRate || compInfo.value?.fps || 30,
                "onUpdate:modelValue": updateFrameRate,
                min: 1,
                max: 120,
                step: 1,
                precision: 0,
                unit: "fps"
              }, null, 8, ["modelValue"])
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_25$d, [
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "section-header" }, "Options", -1)),
          createBaseVNode("div", _hoisted_26$c, [
            createBaseVNode("div", _hoisted_27$b, [
              createBaseVNode("label", _hoisted_28$b, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: nestedCompData.value.flattenTransform,
                  onChange: updateFlattenTransform
                }, null, 40, _hoisted_29$b),
                _cache[11] || (_cache[11] = createBaseVNode("span", null, "Flatten Transform", -1))
              ])
            ]),
            nestedCompData.value.flattenTransform ? (openBlock(), createElementBlock("p", _hoisted_30$a, " 3D layers render in parent's 3D space. Effects are rasterized. ")) : createCommentVNode("", true)
          ])
        ])
      ]);
    };
  }
});

const NestedCompProperties = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__scopeId", "data-v-de9568d8"]]);

const _hoisted_1$t = ["title"];
const _hoisted_2$t = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
};
const _hoisted_3$t = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_4$t = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
};
const _hoisted_5$t = ["x1", "y1", "x2", "y2"];
const _hoisted_6$t = ["cx", "cy"];
const _hoisted_7$t = { class: "drop-label" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const containerRef = ref(null);
    const isDragging = ref(false);
    const dragStart = ref({ x: 0, y: 0 });
    const dragEnd = ref({ x: 0, y: 0 });
    const currentDropTarget = ref(null);
    const hasLink = computed(() => !!props.linkedTo);
    const linkTargetName = computed(() => {
      if (!props.linkedTo) return "";
      return `${props.linkedTo.layerId}.${props.linkedTo.property}`;
    });
    const lineStyle = computed(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    }));
    const dropTargetStyle = computed(() => {
      if (!currentDropTarget.value) return {};
      const rect = currentDropTarget.value.rect;
      return {
        position: "fixed",
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        zIndex: 9999
      };
    });
    function findDropTargets() {
      const targets = [];
      const elements = document.querySelectorAll("[data-pickwhip-target]");
      elements.forEach((el) => {
        const htmlEl = el;
        const layerId = htmlEl.dataset.pickwhipLayerId;
        const property = htmlEl.dataset.pickwhipTarget;
        const label = htmlEl.dataset.pickwhipLabel || property;
        if (layerId === props.layerId && property === props.property) {
          return;
        }
        if (layerId && property) {
          targets.push({
            layerId,
            property,
            label,
            element: htmlEl,
            rect: htmlEl.getBoundingClientRect()
          });
        }
      });
      return targets;
    }
    function findTargetAtPosition(x, y, targets) {
      for (const target of targets) {
        const rect = target.rect;
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return target;
        }
      }
      return null;
    }
    let dropTargets = [];
    function startDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      const rect = containerRef.value?.getBoundingClientRect();
      if (rect) {
        dragStart.value = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      } else {
        dragStart.value = { x: clientX, y: clientY };
      }
      dragEnd.value = { x: clientX, y: clientY };
      isDragging.value = true;
      dropTargets = findDropTargets();
      window.addEventListener("mousemove", onDrag);
      window.addEventListener("mouseup", endDrag);
      window.addEventListener("touchmove", onDrag);
      window.addEventListener("touchend", endDrag);
    }
    function onDrag(e) {
      if (!isDragging.value) return;
      const clientX = "touches" in e ? e.touches[0].clientX : e.clientX;
      const clientY = "touches" in e ? e.touches[0].clientY : e.clientY;
      dragEnd.value = { x: clientX, y: clientY };
      dropTargets.forEach((t) => {
        t.rect = t.element.getBoundingClientRect();
      });
      currentDropTarget.value = findTargetAtPosition(clientX, clientY, dropTargets);
    }
    function endDrag(e) {
      if (!isDragging.value) return;
      const clientX = "changedTouches" in e ? e.changedTouches[0].clientX : e.clientX;
      const clientY = "changedTouches" in e ? e.changedTouches[0].clientY : e.clientY;
      const target = findTargetAtPosition(clientX, clientY, dropTargets);
      if (target) {
        emit("link", { layerId: target.layerId, property: target.property });
      }
      isDragging.value = false;
      currentDropTarget.value = null;
      dropTargets = [];
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    }
    function clearLink() {
      emit("unlink");
    }
    onUnmounted(() => {
      window.removeEventListener("mousemove", onDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchmove", onDrag);
      window.removeEventListener("touchend", endDrag);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "pickwhip-container",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["pickwhip-handle", { dragging: isDragging.value, linked: hasLink.value }]),
          onMousedown: startDrag,
          onTouchstart: withModifiers(startDrag, ["prevent"]),
          title: hasLink.value ? `Linked to: ${linkTargetName.value}` : "Drag to link property"
        }, [
          (openBlock(), createElementBlock("svg", _hoisted_2$t, [
            _cache[0] || (_cache[0] = createBaseVNode("circle", {
              cx: "8",
              cy: "8",
              r: "3",
              fill: "currentColor"
            }, null, -1)),
            !hasLink.value ? (openBlock(), createElementBlock("path", _hoisted_3$t)) : (openBlock(), createElementBlock("path", _hoisted_4$t))
          ]))
        ], 42, _hoisted_1$t),
        hasLink.value ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: "clear-link-btn",
          onClick: clearLink,
          title: "Remove link"
        }, "  ")) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value ? (openBlock(), createElementBlock("svg", {
            key: 0,
            class: "pickwhip-line",
            style: normalizeStyle(lineStyle.value)
          }, [
            createBaseVNode("line", {
              x1: dragStart.value.x,
              y1: dragStart.value.y,
              x2: dragEnd.value.x,
              y2: dragEnd.value.y,
              stroke: "#4a90d9",
              "stroke-width": "2",
              "stroke-dasharray": "4 2"
            }, null, 8, _hoisted_5$t),
            createBaseVNode("circle", {
              cx: dragEnd.value.x,
              cy: dragEnd.value.y,
              r: "6",
              fill: "#4a90d9",
              stroke: "#fff",
              "stroke-width": "1"
            }, null, 8, _hoisted_6$t)
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          isDragging.value && currentDropTarget.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "drop-target-highlight",
            style: normalizeStyle(dropTargetStyle.value)
          }, [
            createBaseVNode("span", _hoisted_7$t, toDisplayString(currentDropTarget.value.label), 1)
          ], 4)) : createCommentVNode("", true)
        ]))
      ], 512);
    };
  }
});

const Pickwhip = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-9093c1d1"]]);

const _hoisted_1$s = {
  key: 0,
  class: "driver-list"
};
const _hoisted_2$s = { class: "expand-icon" };
const _hoisted_3$s = { class: "count" };
const _hoisted_4$s = {
  key: 0,
  class: "driver-items"
};
const _hoisted_5$s = { class: "driver-header" };
const _hoisted_6$s = ["onClick"];
const _hoisted_7$s = { class: "driver-info" };
const _hoisted_8$s = { class: "target" };
const _hoisted_9$s = {
  key: 0,
  class: "source"
};
const _hoisted_10$s = {
  key: 1,
  class: "source audio"
};
const _hoisted_11$r = {
  key: 2,
  class: "source time"
};
const _hoisted_12$p = ["onClick"];
const _hoisted_13$p = {
  key: 0,
  class: "driver-transforms"
};
const _hoisted_14$m = ["title"];
const _hoisted_15$l = {
  key: 1,
  class: "add-driver-section"
};
const _hoisted_16$k = {
  key: 0,
  class: "add-menu"
};
const _hoisted_17$j = { class: "menu-section" };
const _hoisted_18$i = { class: "menu-section" };
const _hoisted_19$i = { class: "menu-section" };
const _hoisted_20$i = { class: "menu-section" };
const _hoisted_21$i = { class: "menu-actions" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(__props) {
    const props = __props;
    const store = useCompositorStore();
    const expanded = ref(true);
    const showAddMenu = ref(false);
    const newDriver = ref({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    });
    const drivers = computed(() => {
      return store.getDriversForLayer(props.layerId);
    });
    function formatProperty(prop) {
      if (!prop) return "?";
      const names = {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        "opacity": "Opacity"
      };
      return names[prop] || prop;
    }
    function getSourceLayerName(layerId) {
      if (!layerId) return "?";
      const layer = store.layers.find((l) => l.id === layerId);
      return layer?.name || layerId.slice(0, 8);
    }
    function formatTransform(t) {
      switch (t.type) {
        case "scale":
          return `Scale: ${t.factor}`;
        case "offset":
          return `Offset: ${t.amount}`;
        case "clamp":
          return `Clamp: ${t.min}-${t.max}`;
        case "smooth":
          return `Smooth: ${t.smoothing}`;
        case "threshold":
          return `Threshold: ${t.threshold}`;
        default:
          return t.type;
      }
    }
    function toggleDriver(driverId) {
      store.togglePropertyDriver(driverId);
    }
    function removeDriver(driverId) {
      store.removePropertyDriver(driverId);
    }
    function createAudioDriver() {
      store.createAudioPropertyDriver(
        props.layerId,
        newDriver.value.targetProperty,
        newDriver.value.audioFeature,
        {
          scale: newDriver.value.scale,
          threshold: newDriver.value.threshold > 0 ? newDriver.value.threshold : void 0
        }
      );
      showAddMenu.value = false;
    }
    return (_ctx, _cache) => {
      return drivers.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$s, [
        createBaseVNode("div", {
          class: "driver-list-header",
          onClick: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
        }, [
          createBaseVNode("span", _hoisted_2$s, toDisplayString(expanded.value ? "" : ""), 1),
          _cache[7] || (_cache[7] = createBaseVNode("span", { class: "title" }, "Property Drivers", -1)),
          createBaseVNode("span", _hoisted_3$s, "(" + toDisplayString(drivers.value.length) + ")", 1)
        ]),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_4$s, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(drivers.value, (driver) => {
            return openBlock(), createElementBlock("div", {
              key: driver.id,
              class: normalizeClass(["driver-item", { disabled: !driver.enabled }])
            }, [
              createBaseVNode("div", _hoisted_5$s, [
                createBaseVNode("button", {
                  class: normalizeClass(["toggle-btn", { active: driver.enabled }]),
                  onClick: ($event) => toggleDriver(driver.id),
                  title: "Toggle driver"
                }, "  ", 10, _hoisted_6$s),
                createBaseVNode("div", _hoisted_7$s, [
                  createBaseVNode("span", _hoisted_8$s, toDisplayString(formatProperty(driver.targetProperty)), 1),
                  _cache[8] || (_cache[8] = createBaseVNode("span", { class: "arrow" }, "", -1)),
                  driver.sourceType === "property" ? (openBlock(), createElementBlock("span", _hoisted_9$s, toDisplayString(getSourceLayerName(driver.sourceLayerId)) + "." + toDisplayString(formatProperty(driver.sourceProperty)), 1)) : driver.sourceType === "audio" ? (openBlock(), createElementBlock("span", _hoisted_10$s, "  " + toDisplayString(driver.audioFeature), 1)) : driver.sourceType === "time" ? (openBlock(), createElementBlock("span", _hoisted_11$r, "  Time ")) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: "remove-btn",
                  onClick: ($event) => removeDriver(driver.id),
                  title: "Remove driver"
                }, "  ", 8, _hoisted_12$p)
              ]),
              driver.transforms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$p, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(driver.transforms, (t, i) => {
                  return openBlock(), createElementBlock("span", {
                    key: i,
                    class: "transform-chip",
                    title: formatTransform(t)
                  }, toDisplayString(t.type), 9, _hoisted_14$m);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true),
        expanded.value ? (openBlock(), createElementBlock("div", _hoisted_15$l, [
          createBaseVNode("button", {
            class: "add-driver-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => showAddMenu.value = !showAddMenu.value)
          }, " + Add Audio Driver "),
          showAddMenu.value ? (openBlock(), createElementBlock("div", _hoisted_16$k, [
            createBaseVNode("div", _hoisted_17$j, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Audio Feature:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => newDriver.value.audioFeature = $event)
              }, [..._cache[9] || (_cache[9] = [
                createStaticVNode('<option value="amplitude" data-v-ffb799cf>Amplitude</option><option value="bass" data-v-ffb799cf>Bass</option><option value="mid" data-v-ffb799cf>Mid</option><option value="high" data-v-ffb799cf>High</option><option value="rms" data-v-ffb799cf>RMS</option>', 5)
              ])], 512), [
                [vModelSelect, newDriver.value.audioFeature]
              ])
            ]),
            createBaseVNode("div", _hoisted_18$i, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Target Property:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => newDriver.value.targetProperty = $event)
              }, [..._cache[11] || (_cache[11] = [
                createStaticVNode('<option value="transform.position.x" data-v-ffb799cf>Position X</option><option value="transform.position.y" data-v-ffb799cf>Position Y</option><option value="transform.scale.x" data-v-ffb799cf>Scale X</option><option value="transform.scale.y" data-v-ffb799cf>Scale Y</option><option value="transform.rotation" data-v-ffb799cf>Rotation</option><option value="opacity" data-v-ffb799cf>Opacity</option>', 6)
              ])], 512), [
                [vModelSelect, newDriver.value.targetProperty]
              ])
            ]),
            createBaseVNode("div", _hoisted_19$i, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Scale:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newDriver.value.scale = $event),
                step: "10"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.scale,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_20$i, [
              _cache[14] || (_cache[14] = createBaseVNode("label", null, "Threshold:", -1)),
              withDirectives(createBaseVNode("input", {
                type: "number",
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newDriver.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  newDriver.value.threshold,
                  void 0,
                  { number: true }
                ]
              ])
            ]),
            createBaseVNode("div", _hoisted_21$i, [
              createBaseVNode("button", { onClick: createAudioDriver }, "Create"),
              createBaseVNode("button", {
                onClick: _cache[6] || (_cache[6] = ($event) => showAddMenu.value = false)
              }, "Cancel")
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true);
    };
  }
});

const DriverList = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__scopeId", "data-v-ffb799cf"]]);

const _hoisted_1$r = { class: "properties-panel" };
const _hoisted_2$r = { class: "panel-header" };
const _hoisted_3$r = { class: "panel-title" };
const _hoisted_4$r = {
  key: 0,
  class: "panel-content"
};
const _hoisted_5$r = { class: "property-section" };
const _hoisted_6$r = { class: "expand-icon" };
const _hoisted_7$r = {
  key: 0,
  class: "section-content"
};
const _hoisted_8$r = { class: "property-row" };
const _hoisted_9$r = { class: "value-group" };
const _hoisted_10$r = { class: "value-group" };
const _hoisted_11$q = { class: "value-group scale-group" };
const _hoisted_12$o = { class: "property-row" };
const _hoisted_13$o = { class: "value-group" };
const _hoisted_14$l = { class: "property-row" };
const _hoisted_15$k = { class: "value-group" };
const _hoisted_16$j = { class: "property-row" };
const _hoisted_17$i = { class: "value-group" };
const _hoisted_18$h = { class: "property-row" };
const _hoisted_19$h = { class: "value-group" };
const _hoisted_20$h = { class: "value-group" };
const _hoisted_21$h = { class: "value-group opacity-value" };
const _hoisted_22$h = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "PropertiesPanel",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(["transform"]);
    const scaleLocked = ref(true);
    const layerName = ref("");
    const transform = ref({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100, z: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0, z: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    });
    const blendMode = ref("normal");
    const keyframes = ref([]);
    const selectedLayer = computed(() => store.selectedLayer);
    computed(() => {
      if (!selectedLayer.value) return [];
      const selfId = selectedLayer.value.id;
      const getDescendantIds = (layerId) => {
        const children = store.layers.filter((l) => l.parentId === layerId);
        let ids = children.map((c) => c.id);
        for (const child of children) {
          ids = ids.concat(getDescendantIds(child.id));
        }
        return ids;
      };
      const descendantIds = new Set(getDescendantIds(selfId));
      return store.layers.filter(
        (l) => l.id !== selfId && !descendantIds.has(l.id) && l.type !== "camera"
        // Camera layers shouldn't be parents
      );
    });
    const layerPropertiesComponent = computed(() => {
      if (!selectedLayer.value) return null;
      switch (selectedLayer.value.type) {
        case "text":
          return markRaw(TextProperties);
        case "particles":
          return markRaw(ParticleProperties);
        case "depthflow":
          return markRaw(DepthflowProperties);
        case "light":
          return markRaw(LightProperties);
        case "spline":
          return markRaw(ShapeProperties);
        case "video":
          return markRaw(VideoProperties);
        case "camera":
          return markRaw(CameraProperties$1);
        case "nestedComp":
          return markRaw(NestedCompProperties);
        default:
          return null;
      }
    });
    function syncTransformFromLayer(layer) {
      if (!layer) return;
      layerName.value = layer.name;
      const t = layer.transform;
      transform.value = {
        position: {
          x: t?.position?.value?.x ?? 0,
          y: t?.position?.value?.y ?? 0,
          z: t?.position?.value?.z ?? 0
        },
        scale: { x: t?.scale?.value?.x ?? 100, y: t?.scale?.value?.y ?? 100, z: t?.scale?.value?.z ?? 100 },
        rotation: t?.rotation?.value ?? 0,
        anchorPoint: { x: t?.anchorPoint?.value?.x ?? 0, y: t?.anchorPoint?.value?.y ?? 0, z: t?.anchorPoint?.value?.z ?? 0 },
        opacity: layer.opacity?.value ?? 100,
        // 3D properties
        orientationX: t?.orientation?.value?.x ?? 0,
        orientationY: t?.orientation?.value?.y ?? 0,
        orientationZ: t?.orientation?.value?.z ?? 0,
        rotationX: t?.rotationX?.value ?? 0,
        rotationY: t?.rotationY?.value ?? 0,
        rotationZ: t?.rotationZ?.value ?? 0
      };
      blendMode.value = layer.blendMode || "normal";
    }
    watch(selectedLayer, (layer) => {
      syncTransformFromLayer(layer);
    }, { immediate: true });
    watch(
      () => selectedLayer.value?.transform,
      () => {
        syncTransformFromLayer(selectedLayer.value);
      },
      { deep: true }
    );
    watch(
      () => selectedLayer.value?.opacity?.value,
      (newVal) => {
        if (newVal !== void 0) {
          transform.value.opacity = newVal;
        }
      }
    );
    watch(() => transform.value.scale.x, (newX, oldX) => {
      if (scaleLocked.value && newX !== oldX) {
        const ratio = newX / oldX;
        transform.value.scale.y = Math.round(transform.value.scale.y * ratio * 10) / 10;
      }
    });
    function toggleSection(section) {
      const index = expandedSections.value.indexOf(section);
      if (index >= 0) {
        expandedSections.value.splice(index, 1);
      } else {
        expandedSections.value.push(section);
      }
    }
    function updateTransform() {
      if (!selectedLayer.value) return;
      const t = selectedLayer.value.transform;
      const v = transform.value;
      if (t?.position) {
        t.position.value = { x: v.position.x, y: v.position.y, z: v.position.z };
      }
      if (t?.scale) {
        t.scale.value = { x: v.scale.x, y: v.scale.y, z: v.scale.z };
      }
      if (t?.rotation) {
        t.rotation.value = v.rotation;
      }
      if (t?.anchorPoint) {
        t.anchorPoint.value = { x: v.anchorPoint.x, y: v.anchorPoint.y, z: v.anchorPoint.z };
      }
      if (selectedLayer.value.opacity) {
        selectedLayer.value.opacity.value = v.opacity;
      }
      if (selectedLayer.value.threeD) {
        if (t?.orientation) {
          t.orientation.value = { x: v.orientationX, y: v.orientationY, z: v.orientationZ };
        }
        if (t?.rotationX) t.rotationX.value = v.rotationX;
        if (t?.rotationY) t.rotationY.value = v.rotationY;
        if (t?.rotationZ) t.rotationZ.value = v.rotationZ;
      }
      onLayerUpdate();
    }
    function hasKeyframe(property) {
      return keyframes.value.includes(property);
    }
    function toggleKeyframe(property) {
      const index = keyframes.value.indexOf(property);
      if (index >= 0) {
        keyframes.value.splice(index, 1);
      } else {
        keyframes.value.push(property);
        console.log(`Added keyframe for ${property} at frame ${store.currentFrame}`);
      }
    }
    function onLayerUpdate(dataUpdates) {
      if (!selectedLayer.value) return;
      if (dataUpdates && Object.keys(dataUpdates).length > 0) {
        store.updateLayerData(selectedLayer.value.id, dataUpdates);
      } else {
        store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    function getDriverForProperty(property) {
      if (!selectedLayer.value) return null;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === property && d.sourceType === "property");
      if (driver && driver.sourceLayerId && driver.sourceProperty) {
        return {
          layerId: driver.sourceLayerId,
          property: driver.sourceProperty
        };
      }
      return null;
    }
    function onPickwhipLink(targetProperty, source) {
      if (!selectedLayer.value) return;
      store.createPropertyLink(
        selectedLayer.value.id,
        targetProperty,
        source.layerId,
        source.property,
        { blendMode: "add" }
      );
      console.log(`[PropertiesPanel] Linked ${selectedLayer.value.id}.${targetProperty} <- ${source.layerId}.${source.property}`);
    }
    function onPickwhipUnlink(targetProperty) {
      if (!selectedLayer.value) return;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      const driver = drivers.find((d) => d.targetProperty === targetProperty && d.sourceType === "property");
      if (driver) {
        store.removePropertyDriver(driver.id);
        console.log(`[PropertiesPanel] Unlinked ${selectedLayer.value.id}.${targetProperty}`);
      }
    }
    function resetTransform() {
      if (!selectedLayer.value) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const centerX = comp.settings.width / 2;
      const centerY = comp.settings.height / 2;
      transform.anchorPoint.x = centerX;
      transform.anchorPoint.y = centerY;
      transform.anchorPoint.z = 0;
      transform.position.x = centerX;
      transform.position.y = centerY;
      transform.position.z = 0;
      transform.scale.x = 100;
      transform.scale.y = 100;
      transform.scale.z = 100;
      transform.rotation = 0;
      transform.rotationX = 0;
      transform.rotationY = 0;
      transform.rotationZ = 0;
      transform.orientationX = 0;
      transform.orientationY = 0;
      transform.orientationZ = 0;
      transform.opacity = 100;
      updateTransform();
    }
    function hasDriver(property) {
      if (!selectedLayer.value) return false;
      const drivers = store.getDriversForLayer(selectedLayer.value.id);
      return drivers.some((d) => d.targetProperty === property && d.enabled);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        createBaseVNode("div", _hoisted_2$r, [
          createBaseVNode("span", _hoisted_3$r, "Properties: " + toDisplayString(selectedLayer.value?.name || "No Selection"), 1)
        ]),
        selectedLayer.value ? (openBlock(), createElementBlock("div", _hoisted_4$r, [
          createBaseVNode("div", _hoisted_5$r, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_6$r, toDisplayString(expandedSections.value.includes("transform") ? "" : ""), 1),
              _cache[30] || (_cache[30] = createBaseVNode("span", { class: "section-title" }, "Layer Transform", -1)),
              createBaseVNode("span", {
                class: "reset-link",
                onClick: withModifiers(resetTransform, ["stop"])
              }, "Reset")
            ]),
            expandedSections.value.includes("transform") ? (openBlock(), createElementBlock("div", _hoisted_7$r, [
              createBaseVNode("div", _hoisted_8$r, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("anchorPoint") }]),
                  onClick: _cache[1] || (_cache[1] = ($event) => toggleKeyframe("anchorPoint"))
                }, "", 2),
                _cache[31] || (_cache[31] = createBaseVNode("label", null, "Anchor Point", -1)),
                createBaseVNode("div", _hoisted_9$r, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      _cache[2] || (_cache[2] = ($event) => transform.value.anchorPoint.x = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      _cache[3] || (_cache[3] = ($event) => transform.value.anchorPoint.y = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.anchorPoint.z,
                    "onUpdate:modelValue": [
                      _cache[4] || (_cache[4] = ($event) => transform.value.anchorPoint.z = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ]),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.position.x") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("position") }]),
                  onClick: _cache[5] || (_cache[5] = ($event) => toggleKeyframe("position"))
                }, "", 2),
                selectedLayer.value ? (openBlock(), createBlock(Pickwhip, {
                  key: 0,
                  layerId: selectedLayer.value.id,
                  property: "transform.position.x",
                  linkedTo: getDriverForProperty("transform.position.x"),
                  onLink: _cache[6] || (_cache[6] = (target) => onPickwhipLink("transform.position.x", target)),
                  onUnlink: _cache[7] || (_cache[7] = () => onPickwhipUnlink("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : createCommentVNode("", true),
                _cache[32] || (_cache[32] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_10$r, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.x,
                    "onUpdate:modelValue": [
                      _cache[8] || (_cache[8] = ($event) => transform.value.position.x = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.position.y,
                    "onUpdate:modelValue": [
                      _cache[9] || (_cache[9] = ($event) => transform.value.position.y = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.position.z,
                    "onUpdate:modelValue": [
                      _cache[10] || (_cache[10] = ($event) => transform.value.position.z = $event),
                      updateTransform
                    ],
                    precision: 1
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.scale.x") || hasDriver("transform.scale.y") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("scale") }]),
                  onClick: _cache[11] || (_cache[11] = ($event) => toggleKeyframe("scale"))
                }, "", 2),
                _cache[33] || (_cache[33] = createBaseVNode("label", null, "Scale", -1)),
                createBaseVNode("div", _hoisted_11$q, [
                  createBaseVNode("button", {
                    class: normalizeClass(["link-btn", { active: scaleLocked.value }]),
                    onClick: _cache[12] || (_cache[12] = ($event) => scaleLocked.value = !scaleLocked.value),
                    title: "Constrain Proportions"
                  }, toDisplayString(scaleLocked.value ? "" : ""), 3),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.x,
                    "onUpdate:modelValue": [
                      _cache[13] || (_cache[13] = ($event) => transform.value.scale.x = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.scale.y,
                    "onUpdate:modelValue": [
                      _cache[14] || (_cache[14] = ($event) => transform.value.scale.y = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"]),
                  selectedLayer.value?.threeD ? (openBlock(), createBlock(unref(ScrubableNumber), {
                    key: 0,
                    modelValue: transform.value.scale.z,
                    "onUpdate:modelValue": [
                      _cache[15] || (_cache[15] = ($event) => transform.value.scale.z = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 1e3,
                    suffix: "%"
                  }, null, 8, ["modelValue"])) : createCommentVNode("", true)
                ])
              ], 2),
              selectedLayer.value?.threeD ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_12$o, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("orientation") }]),
                    onClick: _cache[16] || (_cache[16] = ($event) => toggleKeyframe("orientation"))
                  }, "", 2),
                  _cache[34] || (_cache[34] = createBaseVNode("label", null, "Orientation", -1)),
                  createBaseVNode("div", _hoisted_13$o, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationX,
                      "onUpdate:modelValue": [
                        _cache[17] || (_cache[17] = ($event) => transform.value.orientationX = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationY,
                      "onUpdate:modelValue": [
                        _cache[18] || (_cache[18] = ($event) => transform.value.orientationY = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"]),
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.orientationZ,
                      "onUpdate:modelValue": [
                        _cache[19] || (_cache[19] = ($event) => transform.value.orientationZ = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_14$l, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationX") }]),
                    onClick: _cache[20] || (_cache[20] = ($event) => toggleKeyframe("rotationX"))
                  }, "", 2),
                  _cache[35] || (_cache[35] = createBaseVNode("label", null, "X Rotation", -1)),
                  createBaseVNode("div", _hoisted_15$k, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationX,
                      "onUpdate:modelValue": [
                        _cache[21] || (_cache[21] = ($event) => transform.value.rotationX = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_16$j, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationY") }]),
                    onClick: _cache[22] || (_cache[22] = ($event) => toggleKeyframe("rotationY"))
                  }, "", 2),
                  _cache[36] || (_cache[36] = createBaseVNode("label", null, "Y Rotation", -1)),
                  createBaseVNode("div", _hoisted_17$i, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationY,
                      "onUpdate:modelValue": [
                        _cache[23] || (_cache[23] = ($event) => transform.value.rotationY = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$h, [
                  createBaseVNode("span", {
                    class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotationZ") }]),
                    onClick: _cache[24] || (_cache[24] = ($event) => toggleKeyframe("rotationZ"))
                  }, "", 2),
                  _cache[37] || (_cache[37] = createBaseVNode("label", null, "Z Rotation", -1)),
                  createBaseVNode("div", _hoisted_19$h, [
                    createVNode(unref(ScrubableNumber), {
                      modelValue: transform.value.rotationZ,
                      "onUpdate:modelValue": [
                        _cache[25] || (_cache[25] = ($event) => transform.value.rotationZ = $event),
                        updateTransform
                      ],
                      suffix: ""
                    }, null, 8, ["modelValue"])
                  ])
                ])
              ], 64)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["property-row", { "has-driver": hasDriver("transform.rotation") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("rotation") }]),
                  onClick: _cache[26] || (_cache[26] = ($event) => toggleKeyframe("rotation"))
                }, "", 2),
                _cache[38] || (_cache[38] = createBaseVNode("label", null, "Rotation", -1)),
                createBaseVNode("div", _hoisted_20$h, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.rotation,
                    "onUpdate:modelValue": [
                      _cache[27] || (_cache[27] = ($event) => transform.value.rotation = $event),
                      updateTransform
                    ],
                    suffix: ""
                  }, null, 8, ["modelValue"])
                ])
              ], 2)),
              createBaseVNode("div", {
                class: normalizeClass(["property-row", { "has-driver": hasDriver("opacity") }])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(["keyframe-toggle", { active: hasKeyframe("opacity") }]),
                  onClick: _cache[28] || (_cache[28] = ($event) => toggleKeyframe("opacity"))
                }, "", 2),
                _cache[39] || (_cache[39] = createBaseVNode("label", null, "Opacity", -1)),
                createBaseVNode("div", _hoisted_21$h, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: transform.value.opacity,
                    "onUpdate:modelValue": [
                      _cache[29] || (_cache[29] = ($event) => transform.value.opacity = $event),
                      updateTransform
                    ],
                    min: 0,
                    max: 100,
                    suffix: "%"
                  }, null, 8, ["modelValue"])
                ])
              ], 2)
            ])) : createCommentVNode("", true)
          ]),
          layerPropertiesComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(layerPropertiesComponent.value), {
            key: 0,
            layer: selectedLayer.value,
            onUpdate: onLayerUpdate
          }, null, 40, ["layer"])) : createCommentVNode("", true),
          selectedLayer.value ? (openBlock(), createBlock(DriverList, {
            key: 1,
            layerId: selectedLayer.value.id
          }, null, 8, ["layerId"])) : createCommentVNode("", true)
        ])) : (openBlock(), createElementBlock("div", _hoisted_22$h, [..._cache[40] || (_cache[40] = [
          createBaseVNode("p", null, "No layer selected", -1),
          createBaseVNode("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
});

const PropertiesPanel = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-a7866ac3"]]);

const DEFAULT_TRAJECTORY = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: false
};
const TRAJECTORY_PRESETS = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function applyEasing(t, easing) {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t;
    case "ease-out":
      return 1 - (1 - t) * (1 - t);
    case "ease-in-out":
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    case "bounce":
      if (t < 0.5) {
        return 8 * t * t * t * t;
      }
      const f = t - 1;
      return 1 - 8 * f * f * f * f;
    default:
      return t;
  }
}
function getTrajectoryPosition(config, t) {
  const easedT = applyEasing(t, config.easing);
  const { center, baseDistance, amplitude, loops, startPhase, type } = config;
  let position = { x: center.x, y: center.y, z: center.z - baseDistance };
  let target = { ...center };
  switch (type) {
    case "orbit":
    case "orbit_reverse": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI * Math.sign(amplitude);
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const maxAngle = Math.abs(amplitude) * Math.PI;
      const angle = Math.sin(easedT * Math.PI) * maxAngle;
      position = {
        x: center.x + Math.sin(angle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(angle) * baseDistance
      };
      break;
    }
    case "dolly_in": {
      const distance = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "dolly_out": {
      const distance = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x,
        y: center.y,
        z: center.z - distance
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const panAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x + Math.sin(panAngle) * baseDistance,
        y: center.y,
        z: center.z + Math.cos(panAngle) * baseDistance - baseDistance
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const tiltAngle = easedT * amplitude * (Math.PI / 180);
      target = {
        x: center.x,
        y: center.y + Math.sin(tiltAngle) * baseDistance,
        z: center.z
      };
      break;
    }
    case "circle": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.cos(angle) * radius * 0.5,
        // Elliptical
        z: center.z - baseDistance + Math.cos(angle) * radius * 0.3
      };
      break;
    }
    case "figure8": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * 0.3 * Math.abs(amplitude);
      position = {
        x: center.x + Math.sin(angle) * radius,
        y: center.y + Math.sin(angle * 2) * radius * 0.3,
        z: center.z - baseDistance
      };
      break;
    }
    case "spiral_in": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 - easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "spiral_out": {
      const angle = (startPhase + easedT * loops) * 2 * Math.PI;
      const radius = baseDistance * (1 + easedT * Math.abs(amplitude));
      position = {
        x: center.x + Math.sin(angle) * radius * 0.3,
        y: center.y,
        z: center.z - radius
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      position = {
        x: center.x,
        y: center.y + easedT * amplitude,
        z: center.z - baseDistance
      };
      target = {
        x: center.x,
        y: center.y + easedT * amplitude * 0.5,
        // Target moves less
        z: center.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      position = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z - baseDistance
      };
      target = {
        x: center.x + easedT * amplitude,
        y: center.y,
        z: center.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const arcAngle = easedT * amplitude * 2 * Math.PI;
      position = {
        x: center.x + Math.sin(arcAngle) * baseDistance,
        y: center.y,
        z: center.z - Math.cos(arcAngle) * baseDistance
      };
      break;
    }
  }
  return { position, target };
}
function generateTrajectoryKeyframes(config, startFrame = 0, keyframeInterval = 5) {
  const positionKeyframes = [];
  const poiKeyframes = [];
  const zoomKeyframes = [];
  const numKeyframes = Math.ceil(config.duration / keyframeInterval) + 1;
  for (let i = 0; i < numKeyframes; i++) {
    const frame = startFrame + Math.min(i * keyframeInterval, config.duration);
    const t = Math.min(i * keyframeInterval, config.duration) / config.duration;
    const { position, target } = getTrajectoryPosition(config, t);
    positionKeyframes.push({
      frame,
      position,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    poiKeyframes.push({
      frame,
      pointOfInterest: target,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    });
    if (config.type === "zoom_in" || config.type === "zoom_out") {
      const easedT = applyEasing(t, config.easing);
      const zoomMultiplier = config.type === "zoom_in" ? 1 + easedT * Math.abs(config.amplitude) : 1 - easedT * Math.abs(config.amplitude);
      zoomKeyframes.push({
        frame,
        zoom: 1778 * zoomMultiplier,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: positionKeyframes,
    pointOfInterest: poiKeyframes,
    zoom: zoomKeyframes.length > 0 ? zoomKeyframes : void 0
  };
}
function getTrajectoryDescription(type) {
  const descriptions = {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  };
  return descriptions[type] || "Unknown trajectory";
}
function getTrajectoryCategory(type) {
  const categories = {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  };
  return categories[type] || "Other";
}
function getTrajectoryTypesByCategory() {
  const types = Object.keys(TRAJECTORY_PRESETS);
  const grouped = {};
  for (const type of types) {
    const category = getTrajectoryCategory(type);
    if (!grouped[category]) {
      grouped[category] = [];
    }
    grouped[category].push(type);
  }
  return grouped;
}

const SHAKE_PRESETS = {
  handheld: {
    intensity: 0.3,
    frequency: 1,
    rotationEnabled: true,
    rotationScale: 0.5,
    decay: 0
  },
  impact: {
    intensity: 0.8,
    frequency: 3,
    rotationEnabled: true,
    rotationScale: 1,
    decay: 0.9
  },
  earthquake: {
    intensity: 0.6,
    frequency: 2,
    rotationEnabled: true,
    rotationScale: 0.3,
    decay: 0.5
  },
  subtle: {
    intensity: 0.1,
    frequency: 0.5,
    rotationEnabled: false,
    rotationScale: 0,
    decay: 0
  },
  custom: {}
};
const DEFAULT_SHAKE_CONFIG = {
  intensity: 0.3,
  frequency: 1,
  rotationEnabled: true,
  rotationScale: 0.5,
  seed: 12345,
  decay: 0,
  type: "handheld"
};
class CameraShake {
  noise2D;
  noise3D;
  config;
  startFrame;
  duration;
  constructor(config = {}, startFrame = 0, duration = Infinity) {
    this.config = { ...DEFAULT_SHAKE_CONFIG, ...SHAKE_PRESETS[config.type || "handheld"], ...config };
    this.startFrame = startFrame;
    this.duration = duration;
    const seedFn = () => this.config.seed / 1e5;
    this.noise2D = createNoise2D(seedFn);
    this.noise3D = createNoise3D(seedFn);
  }
  /**
   * Get shake offset for a specific frame
   */
  getOffset(frame) {
    const relativeFrame = frame - this.startFrame;
    if (relativeFrame < 0 || relativeFrame > this.duration) {
      return {
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
      };
    }
    const { intensity, frequency, rotationEnabled, rotationScale, decay } = this.config;
    const decayFactor = decay > 0 ? 1 - relativeFrame / this.duration * decay : 1;
    const time = relativeFrame * frequency * 0.1;
    const scale = intensity * decayFactor * 10;
    const posX = (this.noise2D(time, 0) * 0.5 + this.noise2D(time * 2.3, 100) * 0.3 + this.noise2D(time * 5.7, 200) * 0.2) * scale;
    const posY = (this.noise2D(time, 1e3) * 0.5 + this.noise2D(time * 2.1, 1100) * 0.3 + this.noise2D(time * 4.9, 1200) * 0.2) * scale;
    const posZ = (this.noise2D(time, 2e3) * 0.3 + this.noise2D(time * 1.7, 2100) * 0.2) * scale * 0.5;
    let rotation = { x: 0, y: 0, z: 0 };
    if (rotationEnabled) {
      const rotScale = rotationScale * decayFactor * 2;
      rotation = {
        x: this.noise2D(time, 3e3) * rotScale,
        y: this.noise2D(time, 4e3) * rotScale,
        z: this.noise2D(time, 5e3) * rotScale * 0.5
        // Less roll
      };
    }
    return {
      position: { x: posX, y: posY, z: posZ },
      rotation
    };
  }
  /**
   * Apply shake to camera
   */
  applyToCamera(camera, frame) {
    const offset = this.getOffset(frame);
    return {
      ...camera,
      position: {
        x: camera.position.x + offset.position.x,
        y: camera.position.y + offset.position.y,
        z: camera.position.z + offset.position.z
      },
      xRotation: camera.xRotation + offset.rotation.x,
      yRotation: camera.yRotation + offset.rotation.y,
      zRotation: camera.zRotation + offset.rotation.z
    };
  }
  /**
   * Generate keyframes with shake applied
   */
  generateKeyframes(baseKeyframes, interval = 1) {
    const result = [];
    const frames = /* @__PURE__ */ new Set();
    for (const kf of baseKeyframes) {
      frames.add(kf.frame);
    }
    const minFrame = Math.min(...frames);
    const maxFrame = Math.max(...frames);
    for (let f = minFrame; f <= maxFrame; f += interval) {
      frames.add(f);
    }
    const sortedFrames = Array.from(frames).sort((a, b) => a - b);
    for (const frame of sortedFrames) {
      const base = this.interpolateBaseKeyframe(baseKeyframes, frame);
      const offset = this.getOffset(frame);
      const keyframe = {
        frame,
        temporalInterpolation: "linear"
      };
      if (base.position) {
        keyframe.position = {
          x: base.position.x + offset.position.x,
          y: base.position.y + offset.position.y,
          z: base.position.z + offset.position.z
        };
      }
      if (base.xRotation !== void 0) {
        keyframe.xRotation = base.xRotation + offset.rotation.x;
      }
      if (base.yRotation !== void 0) {
        keyframe.yRotation = base.yRotation + offset.rotation.y;
      }
      if (base.zRotation !== void 0) {
        keyframe.zRotation = base.zRotation + offset.rotation.z;
      }
      result.push(keyframe);
    }
    return result;
  }
  interpolateBaseKeyframe(keyframes, frame) {
    if (keyframes.length === 0) return {};
    if (keyframes.length === 1) return keyframes[0];
    let before = null;
    let after = null;
    for (const kf of keyframes) {
      if (kf.frame <= frame) {
        if (!before || kf.frame > before.frame) before = kf;
      }
      if (kf.frame >= frame) {
        if (!after || kf.frame < after.frame) after = kf;
      }
    }
    if (!before) return after || {};
    if (!after) return before;
    if (before.frame === after.frame) return before;
    const t = (frame - before.frame) / (after.frame - before.frame);
    return {
      frame,
      position: before.position && after.position ? {
        x: before.position.x + (after.position.x - before.position.x) * t,
        y: before.position.y + (after.position.y - before.position.y) * t,
        z: before.position.z + (after.position.z - before.position.z) * t
      } : before.position || after.position,
      xRotation: before.xRotation !== void 0 && after.xRotation !== void 0 ? before.xRotation + (after.xRotation - before.xRotation) * t : before.xRotation ?? after.xRotation,
      yRotation: before.yRotation !== void 0 && after.yRotation !== void 0 ? before.yRotation + (after.yRotation - before.yRotation) * t : before.yRotation ?? after.yRotation,
      zRotation: before.zRotation !== void 0 && after.zRotation !== void 0 ? before.zRotation + (after.zRotation - before.zRotation) * t : before.zRotation ?? after.zRotation
    };
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
function createCameraShake(type, overrides, startFrame, duration) {
  return new CameraShake(
    { type, ...overrides },
    startFrame,
    duration
  );
}

const _hoisted_1$q = { class: "camera-properties" };
const _hoisted_2$q = { class: "panel-header" };
const _hoisted_3$q = { class: "camera-name" };
const _hoisted_4$q = {
  key: 0,
  class: "properties-content"
};
const _hoisted_5$q = { class: "property-section" };
const _hoisted_6$q = { class: "property-row" };
const _hoisted_7$q = ["value"];
const _hoisted_8$q = { class: "property-section" };
const _hoisted_9$q = { class: "toggle-icon" };
const _hoisted_10$q = { class: "section-content" };
const _hoisted_11$p = { class: "property-group" };
const _hoisted_12$n = { class: "xyz-inputs" };
const _hoisted_13$n = {
  key: 0,
  class: "property-group"
};
const _hoisted_14$k = { class: "xyz-inputs" };
const _hoisted_15$j = { class: "property-group" };
const _hoisted_16$i = { class: "xyz-inputs" };
const _hoisted_17$h = { class: "property-group" };
const _hoisted_18$g = { class: "property-group" };
const _hoisted_19$g = { class: "property-group" };
const _hoisted_20$g = { class: "property-section" };
const _hoisted_21$g = { class: "toggle-icon" };
const _hoisted_22$g = { class: "section-content" };
const _hoisted_23$g = { class: "preset-row" };
const _hoisted_24$d = ["onClick"];
const _hoisted_25$c = { class: "property-group" };
const _hoisted_26$b = { class: "property-group" };
const _hoisted_27$a = { class: "property-group" };
const _hoisted_28$a = { class: "property-group" };
const _hoisted_29$a = ["value"];
const _hoisted_30$9 = { class: "property-section" };
const _hoisted_31$7 = { class: "toggle-icon" };
const _hoisted_32$7 = { class: "section-content" };
const _hoisted_33$7 = { class: "property-group checkbox-group" };
const _hoisted_34$7 = ["checked"];
const _hoisted_35$6 = { class: "property-group" };
const _hoisted_36$6 = { class: "property-group" };
const _hoisted_37$6 = { class: "property-group" };
const _hoisted_38$6 = { class: "property-group checkbox-group" };
const _hoisted_39$6 = ["checked"];
const _hoisted_40$5 = { class: "property-section" };
const _hoisted_41$4 = { class: "toggle-icon" };
const _hoisted_42$4 = { class: "section-content" };
const _hoisted_43$4 = { class: "property-group" };
const _hoisted_44$4 = { class: "property-group" };
const _hoisted_45$4 = { class: "property-group" };
const _hoisted_46$4 = { class: "property-group" };
const _hoisted_47$4 = { class: "property-group" };
const _hoisted_48$4 = { class: "property-section" };
const _hoisted_49$4 = { class: "toggle-icon" };
const _hoisted_50$3 = { class: "section-content" };
const _hoisted_51$3 = { class: "property-group" };
const _hoisted_52$3 = { class: "property-group" };
const _hoisted_53$3 = { class: "property-group" };
const _hoisted_54$3 = { class: "property-section" };
const _hoisted_55$3 = { class: "toggle-icon" };
const _hoisted_56$3 = { class: "section-content" };
const _hoisted_57$2 = { class: "property-group" };
const _hoisted_58$2 = ["value"];
const _hoisted_59$2 = { class: "property-section" };
const _hoisted_60$2 = { class: "toggle-icon" };
const _hoisted_61$2 = { class: "section-content" };
const _hoisted_62$2 = { class: "property-group" };
const _hoisted_63 = { class: "property-group" };
const _hoisted_64 = { class: "property-section" };
const _hoisted_65 = { class: "toggle-icon" };
const _hoisted_66 = { class: "section-content" };
const _hoisted_67 = { class: "property-group" };
const _hoisted_68 = ["label"];
const _hoisted_69 = ["value"];
const _hoisted_70 = { class: "trajectory-description" };
const _hoisted_71 = { class: "property-group" };
const _hoisted_72 = { class: "property-group" };
const _hoisted_73 = {
  key: 0,
  class: "property-group"
};
const _hoisted_74 = { class: "property-group" };
const _hoisted_75 = { class: "property-group checkbox-group" };
const _hoisted_76 = { class: "property-group" };
const _hoisted_77 = { class: "property-group" };
const _hoisted_78 = { class: "property-section" };
const _hoisted_79 = { class: "toggle-icon" };
const _hoisted_80 = { class: "section-content" };
const _hoisted_81 = { class: "property-group" };
const _hoisted_82 = { class: "shake-description" };
const _hoisted_83 = { class: "property-group" };
const _hoisted_84 = { class: "property-group" };
const _hoisted_85 = { class: "property-group" };
const _hoisted_86 = { class: "property-group checkbox-group" };
const _hoisted_87 = {
  key: 0,
  class: "property-group"
};
const _hoisted_88 = { class: "property-group" };
const _hoisted_89 = { class: "property-group" };
const _hoisted_90 = {
  key: 1,
  class: "no-camera"
};
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "CameraProperties",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "camera" && selectedLayer.data) {
        const cameraData = selectedLayer.data;
        return store.getCamera(cameraData.cameraId);
      }
      return store.activeCamera;
    });
    const expandedSections = reactive({
      transform: true,
      lens: true,
      dof: false,
      iris: false,
      highlight: false,
      autoOrient: false,
      clipping: false,
      trajectory: false,
      shake: false
    });
    const trajectoryConfig = reactive({
      ...DEFAULT_TRAJECTORY
    });
    const shakeConfig = reactive({
      ...DEFAULT_SHAKE_CONFIG
    });
    ref(false);
    const shakeDuration = ref(81);
    let activeCameraShake = null;
    const trajectoryTypesByCategory = computed(() => getTrajectoryTypesByCategory());
    const trajectoryDescription = computed(() => getTrajectoryDescription(trajectoryConfig.type));
    const isOrbitalTrajectory = computed(() => {
      const orbitalTypes = ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"];
      return orbitalTypes.includes(trajectoryConfig.type);
    });
    function formatTrajectoryName(type) {
      return type.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
    }
    const previewAnimationId = ref(null);
    function previewTrajectory() {
      if (!camera.value) return;
      if (previewAnimationId.value !== null) {
        cancelAnimationFrame(previewAnimationId.value);
      }
      const startTime = performance.now();
      const duration = trajectoryConfig.duration / 30 * 1e3;
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
        )
      };
      function animate() {
        const elapsed = performance.now() - startTime;
        const t = Math.min(elapsed / duration, 1);
        const { position, target } = getTrajectoryPosition(config, t);
        store.updateCamera(camera.value.id, {
          position,
          pointOfInterest: target
        });
        if (t < 1) {
          previewAnimationId.value = requestAnimationFrame(animate);
        } else {
          previewAnimationId.value = null;
        }
      }
      animate();
    }
    function applyTrajectory() {
      if (!camera.value) return;
      const baseDistance = Math.sqrt(
        Math.pow(camera.value.position.x - camera.value.pointOfInterest.x, 2) + Math.pow(camera.value.position.y - camera.value.pointOfInterest.y, 2) + Math.pow(camera.value.position.z - camera.value.pointOfInterest.z, 2)
      );
      const config = {
        ...trajectoryConfig,
        center: { ...camera.value.pointOfInterest },
        baseDistance
      };
      const keyframes = generateTrajectoryKeyframes(config, store.currentFrame);
      for (const kf of keyframes.position) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          position: kf.position,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      for (const kf of keyframes.pointOfInterest) {
        store.addCameraKeyframe(camera.value.id, {
          frame: kf.frame,
          pointOfInterest: kf.pointOfInterest,
          spatialInterpolation: kf.spatialInterpolation,
          temporalInterpolation: kf.temporalInterpolation
        });
      }
      if (keyframes.zoom) {
        for (const kf of keyframes.zoom) {
          store.addCameraKeyframe(camera.value.id, {
            frame: kf.frame,
            zoom: kf.zoom,
            temporalInterpolation: kf.temporalInterpolation
          });
        }
      }
      console.log(`Applied ${keyframes.position.length} camera trajectory keyframes`);
    }
    function applyShakePreset(preset) {
      const presetConfig = SHAKE_PRESETS[preset];
      Object.assign(shakeConfig, presetConfig, { type: preset });
    }
    function previewShake() {
      if (!camera.value) return;
      activeCameraShake = createCameraShake(
        shakeConfig.type,
        shakeConfig,
        store.currentFrame,
        shakeDuration.value
      );
      const originalPosition = { ...camera.value.position };
      const originalOrientation = { ...camera.value.orientation };
      const startTime = performance.now();
      const duration = shakeDuration.value / 30 * 1e3;
      function animate() {
        const elapsed = performance.now() - startTime;
        const frame = Math.floor(elapsed / 1e3 * 30) + store.currentFrame;
        if (elapsed < duration && activeCameraShake) {
          const offset = activeCameraShake.getOffset(frame);
          store.updateCamera(camera.value.id, {
            position: {
              x: originalPosition.x + offset.position.x,
              y: originalPosition.y + offset.position.y,
              z: originalPosition.z + offset.position.z
            },
            orientation: {
              x: originalOrientation.x + offset.rotation.x,
              y: originalOrientation.y + offset.rotation.y,
              z: originalOrientation.z + offset.rotation.z
            }
          });
          requestAnimationFrame(animate);
        } else {
          store.updateCamera(camera.value.id, {
            position: originalPosition,
            orientation: originalOrientation
          });
          activeCameraShake = null;
        }
      }
      requestAnimationFrame(animate);
    }
    function applyShakeKeyframes() {
      if (!camera.value) return;
      const shake = createCameraShake(
        shakeConfig.type,
        shakeConfig,
        store.currentFrame,
        shakeDuration.value
      );
      const existingKeyframes = camera.value.keyframes || [];
      const shakenKeyframes = shake.generateKeyframes(existingKeyframes, 2);
      for (const kf of shakenKeyframes) {
        store.addCameraKeyframe(camera.value.id, kf);
      }
      console.log(`Applied ${shakenKeyframes.length} camera shake keyframes`);
    }
    function toggleSection(section) {
      expandedSections[section] = !expandedSections[section];
    }
    function updateProperty(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, { [key]: value });
    }
    function updatePosition(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        position: { ...camera.value.position, [axis]: value }
      });
    }
    function updatePOI(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        pointOfInterest: { ...camera.value.pointOfInterest, [axis]: value }
      });
    }
    function updateOrientation(axis, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        orientation: { ...camera.value.orientation, [axis]: value }
      });
    }
    function updateFocalLength(value) {
      if (!camera.value) return;
      const angleOfView = focalLengthToFOV(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        focalLength: value,
        angleOfView
      });
    }
    function updateAngleOfView(value) {
      if (!camera.value) return;
      const focalLength = fovToFocalLength(value, camera.value.filmSize);
      store.updateCamera(camera.value.id, {
        angleOfView: value,
        focalLength
      });
    }
    function updateDOF(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        depthOfField: { ...camera.value.depthOfField, [key]: value }
      });
    }
    function updateIris(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        iris: { ...camera.value.iris, [key]: value }
      });
    }
    function updateHighlight(key, value) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        highlight: { ...camera.value.highlight, [key]: value }
      });
    }
    function applyPreset(preset) {
      if (!camera.value) return;
      store.updateCamera(camera.value.id, {
        focalLength: preset.focalLength,
        angleOfView: preset.angleOfView,
        zoom: preset.zoom
      });
    }
    function createCamera() {
      store.createCameraLayer();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createBaseVNode("div", _hoisted_2$q, [
          _cache[57] || (_cache[57] = createBaseVNode("span", { class: "panel-title" }, "Camera", -1)),
          createBaseVNode("span", _hoisted_3$q, toDisplayString(camera.value?.name ?? "No Camera"), 1)
        ]),
        camera.value ? (openBlock(), createElementBlock("div", _hoisted_4$q, [
          createBaseVNode("div", _hoisted_5$q, [
            _cache[59] || (_cache[59] = createBaseVNode("div", { class: "section-header" }, "Type", -1)),
            createBaseVNode("div", _hoisted_6$q, [
              createBaseVNode("select", {
                value: camera.value.type,
                onChange: _cache[0] || (_cache[0] = ($event) => updateProperty("type", $event.target.value)),
                class: "type-select"
              }, [..._cache[58] || (_cache[58] = [
                createBaseVNode("option", { value: "one-node" }, "One-Node Camera", -1),
                createBaseVNode("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, _hoisted_7$q)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$q, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("transform"))
            }, [
              createBaseVNode("span", _hoisted_9$q, toDisplayString(expandedSections.transform ? "" : ""), 1),
              _cache[60] || (_cache[60] = createTextVNode(" Transform ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_10$q, [
              createBaseVNode("div", _hoisted_11$p, [
                _cache[61] || (_cache[61] = createBaseVNode("label", null, "Position", -1)),
                createBaseVNode("div", _hoisted_12$n, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.x,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = (v) => updatePosition("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.y,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = (v) => updatePosition("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.position.z,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = (v) => updatePosition("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              camera.value.type === "two-node" ? (openBlock(), createElementBlock("div", _hoisted_13$n, [
                _cache[62] || (_cache[62] = createBaseVNode("label", null, "Point of Interest", -1)),
                createBaseVNode("div", _hoisted_14$k, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updatePOI("x", v)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updatePOI("y", v)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.pointOfInterest.z,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = (v) => updatePOI("z", v)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_15$j, [
                _cache[63] || (_cache[63] = createBaseVNode("label", null, "Orientation", -1)),
                createBaseVNode("div", _hoisted_16$i, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.x,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = (v) => updateOrientation("x", v)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.y,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = (v) => updateOrientation("y", v)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.orientation.z,
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = (v) => updateOrientation("z", v)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$h, [
                _cache[64] || (_cache[64] = createBaseVNode("label", null, "X Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.xRotation,
                  "onUpdate:modelValue": _cache[11] || (_cache[11] = (v) => updateProperty("xRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_18$g, [
                _cache[65] || (_cache[65] = createBaseVNode("label", null, "Y Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.yRotation,
                  "onUpdate:modelValue": _cache[12] || (_cache[12] = (v) => updateProperty("yRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_19$g, [
                _cache[66] || (_cache[66] = createBaseVNode("label", null, "Z Rotation", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.zRotation,
                  "onUpdate:modelValue": _cache[13] || (_cache[13] = (v) => updateProperty("zRotation", v)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.transform]
            ])
          ]),
          createBaseVNode("div", _hoisted_20$g, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[14] || (_cache[14] = ($event) => toggleSection("lens"))
            }, [
              createBaseVNode("span", _hoisted_21$g, toDisplayString(expandedSections.lens ? "" : ""), 1),
              _cache[67] || (_cache[67] = createTextVNode(" Lens ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_22$g, [
              createBaseVNode("div", _hoisted_23$g, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(CAMERA_PRESETS), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.name,
                    class: normalizeClass({ active: Math.abs(camera.value.focalLength - preset.focalLength) < 0.5 }),
                    onClick: ($event) => applyPreset(preset)
                  }, toDisplayString(preset.name), 11, _hoisted_24$d);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_25$c, [
                _cache[68] || (_cache[68] = createBaseVNode("label", null, "Focal Length", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.focalLength,
                  "onUpdate:modelValue": updateFocalLength,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_26$b, [
                _cache[69] || (_cache[69] = createBaseVNode("label", null, "Angle of View", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.angleOfView,
                  "onUpdate:modelValue": updateAngleOfView,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_27$a, [
                _cache[70] || (_cache[70] = createBaseVNode("label", null, "Film Size", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.filmSize,
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = (v) => updateProperty("filmSize", v)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_28$a, [
                _cache[72] || (_cache[72] = createBaseVNode("label", null, "Measure Film Size", -1)),
                createBaseVNode("select", {
                  value: camera.value.measureFilmSize,
                  onChange: _cache[16] || (_cache[16] = ($event) => updateProperty("measureFilmSize", $event.target.value))
                }, [..._cache[71] || (_cache[71] = [
                  createBaseVNode("option", { value: "horizontal" }, "Horizontal", -1),
                  createBaseVNode("option", { value: "vertical" }, "Vertical", -1),
                  createBaseVNode("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, _hoisted_29$a)
              ])
            ], 512), [
              [vShow, expandedSections.lens]
            ])
          ]),
          createBaseVNode("div", _hoisted_30$9, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[17] || (_cache[17] = ($event) => toggleSection("dof"))
            }, [
              createBaseVNode("span", _hoisted_31$7, toDisplayString(expandedSections.dof ? "" : ""), 1),
              _cache[73] || (_cache[73] = createTextVNode(" Depth of Field ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_32$7, [
              createBaseVNode("div", _hoisted_33$7, [
                createBaseVNode("label", null, [
                  createBaseVNode("input", {
                    type: "checkbox",
                    checked: camera.value.depthOfField.enabled,
                    onChange: _cache[18] || (_cache[18] = ($event) => updateDOF("enabled", $event.target.checked))
                  }, null, 40, _hoisted_34$7),
                  _cache[74] || (_cache[74] = createTextVNode(" Enable DOF ", -1))
                ])
              ]),
              camera.value.depthOfField.enabled ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_35$6, [
                  _cache[75] || (_cache[75] = createBaseVNode("label", null, "Focus Distance", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = (v) => updateDOF("focusDistance", v)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_36$6, [
                  _cache[76] || (_cache[76] = createBaseVNode("label", null, "f-Stop", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: camera.value.depthOfField.fStop,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = (v) => updateDOF("fStop", v)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_37$6, [
                  _cache[77] || (_cache[77] = createBaseVNode("label", null, "Blur Level", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: camera.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => updateDOF("blurLevel", v)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_38$6, [
                  createBaseVNode("label", null, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: camera.value.depthOfField.lockToZoom,
                      onChange: _cache[22] || (_cache[22] = ($event) => updateDOF("lockToZoom", $event.target.checked))
                    }, null, 40, _hoisted_39$6),
                    _cache[78] || (_cache[78] = createTextVNode(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : createCommentVNode("", true)
            ], 512), [
              [vShow, expandedSections.dof]
            ])
          ]),
          createBaseVNode("div", _hoisted_40$5, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[23] || (_cache[23] = ($event) => toggleSection("iris"))
            }, [
              createBaseVNode("span", _hoisted_41$4, toDisplayString(expandedSections.iris ? "" : ""), 1),
              _cache[79] || (_cache[79] = createTextVNode(" Iris ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_42$4, [
              createBaseVNode("div", _hoisted_43$4, [
                createBaseVNode("label", null, "Shape (" + toDisplayString(Math.round(camera.value.iris.shape)) + "-gon)", 1),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.shape,
                  "onUpdate:modelValue": _cache[24] || (_cache[24] = (v) => updateIris("shape", v)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_44$4, [
                _cache[80] || (_cache[80] = createBaseVNode("label", null, "Rotation", -1)),
                createVNode(unref(AngleDial), {
                  modelValue: camera.value.iris.rotation,
                  "onUpdate:modelValue": _cache[25] || (_cache[25] = (v) => updateIris("rotation", v)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_45$4, [
                _cache[81] || (_cache[81] = createBaseVNode("label", null, "Roundness", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.roundness,
                  "onUpdate:modelValue": _cache[26] || (_cache[26] = (v) => updateIris("roundness", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_46$4, [
                _cache[82] || (_cache[82] = createBaseVNode("label", null, "Aspect Ratio", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.aspectRatio,
                  "onUpdate:modelValue": _cache[27] || (_cache[27] = (v) => updateIris("aspectRatio", v)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_47$4, [
                _cache[83] || (_cache[83] = createBaseVNode("label", null, "Diffraction Fringe", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.iris.diffractionFringe,
                  "onUpdate:modelValue": _cache[28] || (_cache[28] = (v) => updateIris("diffractionFringe", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.iris]
            ])
          ]),
          createBaseVNode("div", _hoisted_48$4, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[29] || (_cache[29] = ($event) => toggleSection("highlight"))
            }, [
              createBaseVNode("span", _hoisted_49$4, toDisplayString(expandedSections.highlight ? "" : ""), 1),
              _cache[84] || (_cache[84] = createTextVNode(" Highlight ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_50$3, [
              createBaseVNode("div", _hoisted_51$3, [
                _cache[85] || (_cache[85] = createBaseVNode("label", null, "Gain", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.gain,
                  "onUpdate:modelValue": _cache[30] || (_cache[30] = (v) => updateHighlight("gain", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_52$3, [
                _cache[86] || (_cache[86] = createBaseVNode("label", null, "Threshold", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.threshold,
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = (v) => updateHighlight("threshold", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_53$3, [
                _cache[87] || (_cache[87] = createBaseVNode("label", null, "Saturation", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: camera.value.highlight.saturation,
                  "onUpdate:modelValue": _cache[32] || (_cache[32] = (v) => updateHighlight("saturation", v)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.highlight]
            ])
          ]),
          createBaseVNode("div", _hoisted_54$3, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[33] || (_cache[33] = ($event) => toggleSection("autoOrient"))
            }, [
              createBaseVNode("span", _hoisted_55$3, toDisplayString(expandedSections.autoOrient ? "" : ""), 1),
              _cache[88] || (_cache[88] = createTextVNode(" Auto-Orient ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_56$3, [
              createBaseVNode("div", _hoisted_57$2, [
                createBaseVNode("select", {
                  value: camera.value.autoOrient,
                  onChange: _cache[34] || (_cache[34] = ($event) => updateProperty("autoOrient", $event.target.value))
                }, [..._cache[89] || (_cache[89] = [
                  createBaseVNode("option", { value: "off" }, "Off", -1),
                  createBaseVNode("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  createBaseVNode("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, _hoisted_58$2)
              ])
            ], 512), [
              [vShow, expandedSections.autoOrient]
            ])
          ]),
          createBaseVNode("div", _hoisted_59$2, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[35] || (_cache[35] = ($event) => toggleSection("clipping"))
            }, [
              createBaseVNode("span", _hoisted_60$2, toDisplayString(expandedSections.clipping ? "" : ""), 1),
              _cache[90] || (_cache[90] = createTextVNode(" Clipping ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_61$2, [
              createBaseVNode("div", _hoisted_62$2, [
                _cache[91] || (_cache[91] = createBaseVNode("label", null, "Near Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.nearClip,
                  "onUpdate:modelValue": _cache[36] || (_cache[36] = (v) => updateProperty("nearClip", v)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_63, [
                _cache[92] || (_cache[92] = createBaseVNode("label", null, "Far Clip", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: camera.value.farClip,
                  "onUpdate:modelValue": _cache[37] || (_cache[37] = (v) => updateProperty("farClip", v)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [vShow, expandedSections.clipping]
            ])
          ]),
          createBaseVNode("div", _hoisted_64, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[38] || (_cache[38] = ($event) => toggleSection("trajectory"))
            }, [
              createBaseVNode("span", _hoisted_65, toDisplayString(expandedSections.trajectory ? "" : ""), 1),
              _cache[93] || (_cache[93] = createTextVNode(" Trajectory ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_66, [
              createBaseVNode("div", _hoisted_67, [
                _cache[94] || (_cache[94] = createBaseVNode("label", null, "Motion Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[39] || (_cache[39] = ($event) => trajectoryConfig.type = $event),
                  class: "trajectory-select"
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(trajectoryTypesByCategory.value, (types, category) => {
                    return openBlock(), createElementBlock("optgroup", {
                      key: category,
                      label: category
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(types, (type) => {
                        return openBlock(), createElementBlock("option", {
                          key: type,
                          value: type
                        }, toDisplayString(formatTrajectoryName(type)), 9, _hoisted_69);
                      }), 128))
                    ], 8, _hoisted_68);
                  }), 128))
                ], 512), [
                  [vModelSelect, trajectoryConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_70, toDisplayString(trajectoryDescription.value), 1),
              createBaseVNode("div", _hoisted_71, [
                _cache[95] || (_cache[95] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.duration,
                  "onUpdate:modelValue": _cache[40] || (_cache[40] = (v) => trajectoryConfig.duration = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_72, [
                _cache[96] || (_cache[96] = createBaseVNode("label", null, "Amplitude", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: Math.abs(trajectoryConfig.amplitude),
                  "onUpdate:modelValue": _cache[41] || (_cache[41] = (v) => trajectoryConfig.amplitude = v * Math.sign(trajectoryConfig.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              isOrbitalTrajectory.value ? (openBlock(), createElementBlock("div", _hoisted_73, [
                _cache[97] || (_cache[97] = createBaseVNode("label", null, "Loops", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: trajectoryConfig.loops,
                  "onUpdate:modelValue": _cache[42] || (_cache[42] = (v) => trajectoryConfig.loops = v),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_74, [
                _cache[99] || (_cache[99] = createBaseVNode("label", null, "Easing", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => trajectoryConfig.easing = $event)
                }, [..._cache[98] || (_cache[98] = [
                  createStaticVNode('<option value="linear" data-v-6f99837e>Linear</option><option value="ease-in" data-v-6f99837e>Ease In</option><option value="ease-out" data-v-6f99837e>Ease Out</option><option value="ease-in-out" data-v-6f99837e>Ease In-Out</option><option value="bounce" data-v-6f99837e>Bounce</option>', 5)
                ])], 512), [
                  [vModelSelect, trajectoryConfig.easing]
                ])
              ]),
              createBaseVNode("div", _hoisted_75, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => trajectoryConfig.audioReactive = $event)
                  }, null, 512), [
                    [vModelCheckbox, trajectoryConfig.audioReactive]
                  ]),
                  _cache[100] || (_cache[100] = createTextVNode(" Audio Reactive ", -1))
                ])
              ]),
              trajectoryConfig.audioReactive ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createBaseVNode("div", _hoisted_76, [
                  _cache[102] || (_cache[102] = createBaseVNode("label", null, "Audio Feature", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[45] || (_cache[45] = ($event) => trajectoryConfig.audioFeature = $event)
                  }, [..._cache[101] || (_cache[101] = [
                    createStaticVNode('<option value="amplitude" data-v-6f99837e>Amplitude</option><option value="bass" data-v-6f99837e>Bass</option><option value="mid" data-v-6f99837e>Mid</option><option value="high" data-v-6f99837e>High</option><option value="onsets" data-v-6f99837e>Onsets</option>', 5)
                  ])], 512), [
                    [vModelSelect, trajectoryConfig.audioFeature]
                  ])
                ]),
                createBaseVNode("div", _hoisted_77, [
                  _cache[103] || (_cache[103] = createBaseVNode("label", null, "Sensitivity", -1)),
                  createVNode(unref(SliderInput), {
                    modelValue: trajectoryConfig.audioSensitivity ?? 1,
                    "onUpdate:modelValue": _cache[46] || (_cache[46] = (v) => trajectoryConfig.audioSensitivity = v),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("div", { class: "trajectory-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewTrajectory
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyTrajectory
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.trajectory]
            ])
          ]),
          createBaseVNode("div", _hoisted_78, [
            createBaseVNode("div", {
              class: "section-header",
              onClick: _cache[47] || (_cache[47] = ($event) => toggleSection("shake"))
            }, [
              createBaseVNode("span", _hoisted_79, toDisplayString(expandedSections.shake ? "" : ""), 1),
              _cache[104] || (_cache[104] = createTextVNode(" Camera Shake ", -1))
            ]),
            withDirectives(createBaseVNode("div", _hoisted_80, [
              createBaseVNode("div", _hoisted_81, [
                _cache[106] || (_cache[106] = createBaseVNode("label", null, "Preset", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[48] || (_cache[48] = ($event) => shakeConfig.type = $event),
                  onChange: _cache[49] || (_cache[49] = ($event) => applyShakePreset(shakeConfig.type))
                }, [..._cache[105] || (_cache[105] = [
                  createStaticVNode('<option value="handheld" data-v-6f99837e>Handheld</option><option value="subtle" data-v-6f99837e>Subtle</option><option value="impact" data-v-6f99837e>Impact</option><option value="earthquake" data-v-6f99837e>Earthquake</option><option value="custom" data-v-6f99837e>Custom</option>', 5)
                ])], 544), [
                  [vModelSelect, shakeConfig.type]
                ])
              ]),
              createBaseVNode("div", _hoisted_82, [
                shakeConfig.type === "handheld" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode("Simulates natural handheld camera movement")
                ], 64)) : shakeConfig.type === "subtle" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode("Gentle shake for atmospheric tension")
                ], 64)) : shakeConfig.type === "impact" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createTextVNode("Sharp, sudden shake for impacts or explosions")
                ], 64)) : shakeConfig.type === "earthquake" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                  createTextVNode("Violent, sustained shaking")
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 4 }, [
                  createTextVNode("Custom shake parameters")
                ], 64))
              ]),
              createBaseVNode("div", _hoisted_83, [
                _cache[107] || (_cache[107] = createBaseVNode("label", null, "Intensity", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.intensity,
                  "onUpdate:modelValue": _cache[50] || (_cache[50] = (v) => shakeConfig.intensity = v),
                  min: 0,
                  max: 1,
                  step: 0.05
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_84, [
                _cache[108] || (_cache[108] = createBaseVNode("label", null, "Frequency", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.frequency,
                  "onUpdate:modelValue": _cache[51] || (_cache[51] = (v) => shakeConfig.frequency = v),
                  min: 0.1,
                  max: 5,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_85, [
                _cache[109] || (_cache[109] = createBaseVNode("label", null, "Duration (frames)", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: shakeDuration.value,
                  "onUpdate:modelValue": _cache[52] || (_cache[52] = (v) => shakeDuration.value = v),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_86, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[53] || (_cache[53] = ($event) => shakeConfig.rotationEnabled = $event)
                  }, null, 512), [
                    [vModelCheckbox, shakeConfig.rotationEnabled]
                  ]),
                  _cache[110] || (_cache[110] = createTextVNode(" Rotation Shake ", -1))
                ])
              ]),
              shakeConfig.rotationEnabled ? (openBlock(), createElementBlock("div", _hoisted_87, [
                _cache[111] || (_cache[111] = createBaseVNode("label", null, "Rotation Scale", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.rotationScale,
                  "onUpdate:modelValue": _cache[54] || (_cache[54] = (v) => shakeConfig.rotationScale = v),
                  min: 0,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_88, [
                _cache[112] || (_cache[112] = createBaseVNode("label", null, "Decay", -1)),
                createVNode(unref(SliderInput), {
                  modelValue: shakeConfig.decay,
                  "onUpdate:modelValue": _cache[55] || (_cache[55] = (v) => shakeConfig.decay = v),
                  min: 0,
                  max: 1,
                  step: 0.05
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", _hoisted_89, [
                _cache[113] || (_cache[113] = createBaseVNode("label", null, "Seed", -1)),
                createVNode(unref(ScrubableNumber), {
                  modelValue: shakeConfig.seed,
                  "onUpdate:modelValue": _cache[56] || (_cache[56] = (v) => shakeConfig.seed = v),
                  min: 0,
                  max: 99999,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("div", { class: "shake-actions" }, [
                createBaseVNode("button", {
                  class: "action-btn preview",
                  onClick: previewShake
                }, " Preview "),
                createBaseVNode("button", {
                  class: "action-btn apply",
                  onClick: applyShakeKeyframes
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [vShow, expandedSections.shake]
            ])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_90, [
          _cache[114] || (_cache[114] = createBaseVNode("p", null, "No camera selected", -1)),
          createBaseVNode("button", { onClick: createCamera }, "Create Camera")
        ]))
      ]);
    };
  }
});

const CameraProperties = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-6f99837e"]]);

const _hoisted_1$p = { class: "audio-properties" };
const _hoisted_2$p = { class: "property-section" };
const _hoisted_3$p = {
  key: 0,
  class: "section-content"
};
const _hoisted_4$p = { class: "property-row" };
const _hoisted_5$p = { class: "value-display" };
const _hoisted_6$p = { class: "property-row" };
const _hoisted_7$p = { class: "value-display" };
const _hoisted_8$p = { class: "property-row" };
const _hoisted_9$p = { class: "value-display" };
const _hoisted_10$p = { class: "property-row" };
const _hoisted_11$o = {
  key: 0,
  class: "peak-count"
};
const _hoisted_12$m = { class: "property-section" };
const _hoisted_13$m = { class: "mapping-count" };
const _hoisted_14$j = {
  key: 0,
  class: "section-content"
};
const _hoisted_15$i = { class: "mapping-header" };
const _hoisted_16$h = { class: "mapping-enabled" };
const _hoisted_17$g = ["onUpdate:modelValue"];
const _hoisted_18$f = { class: "mapping-name" };
const _hoisted_19$f = ["onClick"];
const _hoisted_20$f = {
  key: 0,
  class: "mapping-details"
};
const _hoisted_21$f = { class: "property-row" };
const _hoisted_22$f = ["onUpdate:modelValue"];
const _hoisted_23$f = ["label"];
const _hoisted_24$c = ["value"];
const _hoisted_25$b = { class: "property-row" };
const _hoisted_26$a = ["onUpdate:modelValue"];
const _hoisted_27$9 = ["label"];
const _hoisted_28$9 = ["value"];
const _hoisted_29$9 = { class: "property-row" };
const _hoisted_30$8 = ["onUpdate:modelValue"];
const _hoisted_31$6 = { class: "value-display" };
const _hoisted_32$6 = { class: "property-row" };
const _hoisted_33$6 = ["onUpdate:modelValue"];
const _hoisted_34$6 = { class: "value-display" };
const _hoisted_35$5 = { class: "property-row" };
const _hoisted_36$5 = ["onUpdate:modelValue"];
const _hoisted_37$5 = { class: "value-display" };
const _hoisted_38$5 = { class: "property-row" };
const _hoisted_39$5 = ["onUpdate:modelValue"];
const _hoisted_40$4 = ["onUpdate:modelValue"];
const _hoisted_41$3 = { class: "property-row" };
const _hoisted_42$3 = ["onUpdate:modelValue"];
const _hoisted_43$3 = { class: "value-display" };
const _hoisted_44$3 = { class: "property-row" };
const _hoisted_45$3 = ["onUpdate:modelValue"];
const _hoisted_46$3 = { class: "value-display" };
const _hoisted_47$3 = { class: "property-row" };
const _hoisted_48$3 = ["onUpdate:modelValue"];
const _hoisted_49$3 = { class: "property-row" };
const _hoisted_50$2 = ["onUpdate:modelValue"];
const _hoisted_51$2 = {
  key: 0,
  class: "property-row"
};
const _hoisted_52$2 = ["onUpdate:modelValue"];
const _hoisted_53$2 = { class: "value-display" };
const _hoisted_54$2 = { class: "property-row checkbox-row" };
const _hoisted_55$2 = ["onUpdate:modelValue"];
const _hoisted_56$2 = ["onClick"];
const _hoisted_57$1 = { class: "property-section" };
const _hoisted_58$1 = {
  key: 0,
  class: "section-content"
};
const _hoisted_59$1 = { class: "property-row" };
const _hoisted_60$1 = ["value"];
const _hoisted_61$1 = { class: "visualizer-canvas-container" };
const _hoisted_62$1 = { class: "visualizer-value" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "AudioProperties",
  setup(__props) {
    const store = useCompositorStore();
    const expandedSections = ref(/* @__PURE__ */ new Set(["peaks", "mappings"]));
    const expandedMappings = ref(/* @__PURE__ */ new Set());
    const peakConfig = ref({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    });
    const peakData = ref(null);
    const mappings = ref([]);
    const visualizerFeature = ref("amplitude");
    const visualizerCanvas = ref(null);
    const allFeatures = computed(() => getAllFeatures());
    const featuresByCategory = computed(() => getFeaturesByCategory());
    const targetsByCategory = computed(() => getTargetsByCategory());
    const playheadPosition = computed(
      () => store.currentFrame / store.frameCount * 100
    );
    const currentFeatureValue = computed(() => {
      if (!store.audioAnalysis) return 0;
      return getFeatureAtFrame(store.audioAnalysis, visualizerFeature.value, store.currentFrame);
    });
    function toggleSection(section) {
      if (expandedSections.value.has(section)) {
        expandedSections.value.delete(section);
      } else {
        expandedSections.value.add(section);
      }
    }
    function toggleMappingExpanded(id) {
      if (expandedMappings.value.has(id)) {
        expandedMappings.value.delete(id);
      } else {
        expandedMappings.value.add(id);
      }
    }
    function detectPeaks$1() {
      if (!store.audioAnalysis) return;
      const weights = store.audioAnalysis.amplitudeEnvelope;
      peakData.value = detectPeaks(weights, peakConfig.value);
      store.setPeakData(peakData.value);
    }
    function addMapping() {
      const mapping = createDefaultAudioMapping();
      mappings.value.push(mapping);
      expandedMappings.value.add(mapping.id);
      store.addAudioMapping(mapping);
    }
    function removeMapping(id) {
      const index = mappings.value.findIndex((m) => m.id === id);
      if (index >= 0) {
        mappings.value.splice(index, 1);
        expandedMappings.value.delete(id);
        store.removeAudioMapping(id);
      }
    }
    function drawVisualizer() {
      const canvas = visualizerCanvas.value;
      if (!canvas || !store.audioAnalysis) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.fillStyle = "#1e1e1e";
      ctx.fillRect(0, 0, width, height);
      let featureData = [];
      const analysis = store.audioAnalysis;
      switch (visualizerFeature.value) {
        case "amplitude":
          featureData = analysis.amplitudeEnvelope;
          break;
        case "rms":
          featureData = analysis.rmsEnergy;
          break;
        case "spectralCentroid":
          featureData = analysis.spectralCentroid;
          break;
        case "bass":
          featureData = analysis.frequencyBands.bass;
          break;
        case "mid":
          featureData = analysis.frequencyBands.mid;
          break;
        case "high":
          featureData = analysis.frequencyBands.high;
          break;
        case "sub":
          featureData = analysis.frequencyBands.sub;
          break;
        case "lowMid":
          featureData = analysis.frequencyBands.lowMid;
          break;
        case "highMid":
          featureData = analysis.frequencyBands.highMid;
          break;
        case "spectralFlux":
          featureData = analysis.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          featureData = analysis.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          featureData = analysis.spectralRolloff || [];
          break;
        case "spectralFlatness":
          featureData = analysis.spectralFlatness || [];
          break;
        case "chromaEnergy":
          featureData = analysis.chromaFeatures?.chromaEnergy || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if (analysis.chromaFeatures?.chroma) {
            const pitchIndex = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(visualizerFeature.value);
            featureData = analysis.chromaFeatures.chroma.map((frame) => frame[pitchIndex] || 0);
          }
          break;
        case "onsets":
          featureData = new Array(analysis.frameCount).fill(0);
          for (const onset of analysis.onsets) {
            if (onset < featureData.length) featureData[onset] = 1;
          }
          break;
        case "peaks":
          if (peakData.value) {
            featureData = new Array(analysis.frameCount).fill(0);
            for (const peakIndex of peakData.value.indices) {
              if (peakIndex < featureData.length) featureData[peakIndex] = 1;
            }
          }
          break;
      }
      if (featureData.length === 0) return;
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < featureData.length; i++) {
        const x = i / featureData.length * width;
        const y = height - featureData[i] * height * 0.9 - 5;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      if (peakData.value && visualizerFeature.value !== "peaks") {
        ctx.fillStyle = "#ff6b6b";
        for (const peakIndex of peakData.value.indices) {
          const x = peakIndex / featureData.length * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.strokeStyle = "rgba(255, 107, 107, 0.3)";
          ctx.stroke();
        }
      }
    }
    watch(
      () => [store.audioAnalysis, visualizerFeature.value, peakData.value],
      () => {
        drawVisualizer();
      }
    );
    watch(
      mappings,
      (newMappings) => {
        for (const mapping of newMappings) {
          store.updateAudioMapping(mapping.id, mapping);
        }
      },
      { deep: true }
    );
    onMounted(() => {
      drawVisualizer();
      const existingMappings = store.getAudioMappings();
      if (existingMappings.length > 0) {
        mappings.value = [...existingMappings];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        createBaseVNode("div", _hoisted_2$p, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[0] || (_cache[0] = ($event) => toggleSection("peaks"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[7] || (_cache[7] = createBaseVNode("span", null, "Peak Detection", -1))
          ]),
          expandedSections.value.has("peaks") ? (openBlock(), createElementBlock("div", _hoisted_3$p, [
            createBaseVNode("div", _hoisted_4$p, [
              _cache[8] || (_cache[8] = createBaseVNode("label", null, "Threshold", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => peakConfig.value.threshold = $event),
                min: "0",
                max: "1",
                step: "0.01"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.threshold,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_5$p, toDisplayString(peakConfig.value.threshold.toFixed(2)), 1)
            ]),
            createBaseVNode("div", _hoisted_6$p, [
              _cache[9] || (_cache[9] = createBaseVNode("label", null, "Min Peak Distance", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => peakConfig.value.minPeaksDistance = $event),
                min: "1",
                max: "60",
                step: "1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.minPeaksDistance,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_7$p, toDisplayString(peakConfig.value.minPeaksDistance) + " frames", 1)
            ]),
            createBaseVNode("div", _hoisted_8$p, [
              _cache[10] || (_cache[10] = createBaseVNode("label", null, "Multiply", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => peakConfig.value.multiply = $event),
                min: "0.1",
                max: "5",
                step: "0.1"
              }, null, 512), [
                [
                  vModelText,
                  peakConfig.value.multiply,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$p, toDisplayString(peakConfig.value.multiply.toFixed(1)) + "x", 1)
            ]),
            createBaseVNode("div", _hoisted_10$p, [
              createBaseVNode("button", {
                class: "action-btn",
                onClick: detectPeaks$1
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("i", { class: "pi pi-bolt" }, null, -1),
                createTextVNode(" Detect Peaks ", -1)
              ])]),
              peakData.value ? (openBlock(), createElementBlock("span", _hoisted_11$o, toDisplayString(peakData.value.count) + " peaks found ", 1)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_12$m, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[4] || (_cache[4] = ($event) => toggleSection("mappings"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[12] || (_cache[12] = createBaseVNode("span", null, "Audio Mappings", -1)),
            createBaseVNode("span", _hoisted_13$m, toDisplayString(mappings.value.length), 1)
          ]),
          expandedSections.value.has("mappings") ? (openBlock(), createElementBlock("div", _hoisted_14$j, [
            createBaseVNode("button", {
              class: "action-btn add-mapping-btn",
              onClick: addMapping
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("i", { class: "pi pi-plus" }, null, -1),
              createTextVNode(" Add Mapping ", -1)
            ])]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(mappings.value, (mapping) => {
              return openBlock(), createElementBlock("div", {
                key: mapping.id,
                class: "mapping-item"
              }, [
                createBaseVNode("div", _hoisted_15$i, [
                  createBaseVNode("label", _hoisted_16$h, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ($event) => mapping.enabled = $event
                    }, null, 8, _hoisted_17$g), [
                      [vModelCheckbox, mapping.enabled]
                    ])
                  ]),
                  createBaseVNode("span", _hoisted_18$f, toDisplayString(unref(getFeatureDisplayName)(mapping.feature)) + "  " + toDisplayString(unref(getTargetDisplayName)(mapping.target)), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: ($event) => removeMapping(mapping.id)
                  }, [..._cache[14] || (_cache[14] = [
                    createBaseVNode("i", { class: "pi pi-times" }, null, -1)
                  ])], 8, _hoisted_19$f)
                ]),
                expandedMappings.value.has(mapping.id) ? (openBlock(), createElementBlock("div", _hoisted_20$f, [
                  createBaseVNode("div", _hoisted_21$f, [
                    _cache[15] || (_cache[15] = createBaseVNode("label", null, "Feature", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.feature = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(featuresByCategory.value, (feats, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(feats, (feat) => {
                            return openBlock(), createElementBlock("option", {
                              key: feat,
                              value: feat
                            }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_24$c);
                          }), 128))
                        ], 8, _hoisted_23$f);
                      }), 128))
                    ], 8, _hoisted_22$f), [
                      [vModelSelect, mapping.feature]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_25$b, [
                    _cache[16] || (_cache[16] = createBaseVNode("label", null, "Target", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.target = $event
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targetsByCategory.value, (targets, category) => {
                        return openBlock(), createElementBlock("optgroup", {
                          key: category,
                          label: category
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                            return openBlock(), createElementBlock("option", {
                              key: target,
                              value: target
                            }, toDisplayString(unref(getTargetDisplayName)(target)), 9, _hoisted_28$9);
                          }), 128))
                        ], 8, _hoisted_27$9);
                      }), 128))
                    ], 8, _hoisted_26$a), [
                      [vModelSelect, mapping.target]
                    ])
                  ]),
                  _cache[30] || (_cache[30] = createBaseVNode("div", { class: "subsection-header" }, "Basic Controls", -1)),
                  createBaseVNode("div", _hoisted_29$9, [
                    _cache[17] || (_cache[17] = createBaseVNode("label", null, "Sensitivity", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.sensitivity = $event,
                      min: "0.1",
                      max: "5",
                      step: "0.1"
                    }, null, 8, _hoisted_30$8), [
                      [
                        vModelText,
                        mapping.sensitivity,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_31$6, toDisplayString(mapping.sensitivity.toFixed(1)) + "x", 1)
                  ]),
                  createBaseVNode("div", _hoisted_32$6, [
                    _cache[18] || (_cache[18] = createBaseVNode("label", null, "Threshold", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.threshold = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_33$6), [
                      [
                        vModelText,
                        mapping.threshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_34$6, toDisplayString(mapping.threshold.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_35$5, [
                    _cache[19] || (_cache[19] = createBaseVNode("label", null, "Smoothing", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.smoothing = $event,
                      min: "0",
                      max: "0.99",
                      step: "0.01"
                    }, null, 8, _hoisted_36$5), [
                      [
                        vModelText,
                        mapping.smoothing,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_37$5, toDisplayString(mapping.smoothing.toFixed(2)), 1)
                  ]),
                  createBaseVNode("div", _hoisted_38$5, [
                    _cache[20] || (_cache[20] = createBaseVNode("label", null, "Min/Max", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.min = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_39$5), [
                      [
                        vModelText,
                        mapping.min,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[21] || (_cache[21] = createBaseVNode("span", { class: "separator" }, "-", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": ($event) => mapping.max = $event,
                      step: "0.1",
                      class: "small-input"
                    }, null, 8, _hoisted_40$4), [
                      [
                        vModelText,
                        mapping.max,
                        void 0,
                        { number: true }
                      ]
                    ])
                  ]),
                  _cache[31] || (_cache[31] = createBaseVNode("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                  createBaseVNode("div", _hoisted_41$3, [
                    _cache[22] || (_cache[22] = createBaseVNode("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.amplitudeCurve = $event,
                      min: "0.1",
                      max: "4",
                      step: "0.1"
                    }, null, 8, _hoisted_42$3), [
                      [
                        vModelText,
                        mapping.amplitudeCurve,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_43$3, toDisplayString(mapping.amplitudeCurve?.toFixed(1) || "1.0"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_44$3, [
                    _cache[23] || (_cache[23] = createBaseVNode("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.release = $event,
                      min: "0",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_45$3), [
                      [
                        vModelText,
                        mapping.release,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_46$3, toDisplayString(mapping.release?.toFixed(2) || "0.50"), 1)
                  ]),
                  createBaseVNode("div", _hoisted_47$3, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", null, "Curve", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.curve = $event,
                      class: "curve-select"
                    }, [..._cache[24] || (_cache[24] = [
                      createStaticVNode('<option value="linear" data-v-9de93668>Linear</option><option value="exponential" data-v-9de93668>Exponential</option><option value="logarithmic" data-v-9de93668>Logarithmic</option><option value="smoothstep" data-v-9de93668>Smoothstep</option><option value="bounce" data-v-9de93668>Bounce</option>', 5)
                    ])], 8, _hoisted_48$3), [
                      [vModelSelect, mapping.curve]
                    ])
                  ]),
                  _cache[32] || (_cache[32] = createBaseVNode("div", { class: "subsection-header" }, "Beat Response", -1)),
                  createBaseVNode("div", _hoisted_49$3, [
                    _cache[27] || (_cache[27] = createBaseVNode("label", null, "On Beat", -1)),
                    withDirectives(createBaseVNode("select", {
                      "onUpdate:modelValue": ($event) => mapping.beatResponse = $event,
                      class: "beat-select"
                    }, [..._cache[26] || (_cache[26] = [
                      createBaseVNode("option", { value: "none" }, "None", -1),
                      createBaseVNode("option", { value: "flip" }, "Flip (reverse direction)", -1),
                      createBaseVNode("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                      createBaseVNode("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                    ])], 8, _hoisted_50$2), [
                      [vModelSelect, mapping.beatResponse]
                    ])
                  ]),
                  mapping.beatResponse !== "none" ? (openBlock(), createElementBlock("div", _hoisted_51$2, [
                    _cache[28] || (_cache[28] = createBaseVNode("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "range",
                      "onUpdate:modelValue": ($event) => mapping.beatThreshold = $event,
                      min: "0.01",
                      max: "1",
                      step: "0.01"
                    }, null, 8, _hoisted_52$2), [
                      [
                        vModelText,
                        mapping.beatThreshold,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    createBaseVNode("span", _hoisted_53$2, toDisplayString(mapping.beatThreshold?.toFixed(2) || "0.50"), 1)
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_54$2, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": ($event) => mapping.invert = $event
                      }, null, 8, _hoisted_55$2), [
                        [vModelCheckbox, mapping.invert]
                      ]),
                      _cache[29] || (_cache[29] = createTextVNode(" Invert Output ", -1))
                    ])
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  class: "expand-btn",
                  onClick: ($event) => toggleMappingExpanded(mapping.id)
                }, [
                  createBaseVNode("i", {
                    class: normalizeClass(["pi", expandedMappings.value.has(mapping.id) ? "pi-chevron-up" : "pi-chevron-down"])
                  }, null, 2)
                ], 8, _hoisted_56$2)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_57$1, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[5] || (_cache[5] = ($event) => toggleSection("visualizer"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", expandedSections.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[33] || (_cache[33] = createBaseVNode("span", null, "Feature Visualizer", -1))
          ]),
          expandedSections.value.has("visualizer") ? (openBlock(), createElementBlock("div", _hoisted_58$1, [
            createBaseVNode("div", _hoisted_59$1, [
              _cache[34] || (_cache[34] = createBaseVNode("label", null, "Feature", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => visualizerFeature.value = $event)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(allFeatures.value, (feat) => {
                  return openBlock(), createElementBlock("option", {
                    key: feat,
                    value: feat
                  }, toDisplayString(unref(getFeatureDisplayName)(feat)), 9, _hoisted_60$1);
                }), 128))
              ], 512), [
                [vModelSelect, visualizerFeature.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_61$1, [
              createBaseVNode("canvas", {
                ref_key: "visualizerCanvas",
                ref: visualizerCanvas,
                class: "visualizer-canvas",
                width: "240",
                height: "60"
              }, null, 512),
              createBaseVNode("div", {
                class: "visualizer-playhead",
                style: normalizeStyle({ left: `${playheadPosition.value}%` })
              }, null, 4)
            ]),
            createBaseVNode("div", _hoisted_62$1, " Current: " + toDisplayString(currentFeatureValue.value.toFixed(3)), 1)
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const AudioProperties = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__scopeId", "data-v-9de93668"]]);

const _hoisted_1$o = { class: "audio-panel" };
const _hoisted_2$o = {
  key: 0,
  class: "panel-content"
};
const _hoisted_3$o = { class: "audio-info" };
const _hoisted_4$o = { class: "file-info" };
const _hoisted_5$o = { class: "file-details" };
const _hoisted_6$o = { class: "file-name" };
const _hoisted_7$o = { class: "file-meta" };
const _hoisted_8$o = { class: "control-section" };
const _hoisted_9$o = { class: "control-row" };
const _hoisted_10$o = { class: "waveform-section" };
const _hoisted_11$n = { class: "waveform-display" };
const _hoisted_12$l = { class: "linker-section" };
const _hoisted_13$l = {
  key: 1,
  class: "empty-state"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "AudioPanel",
  setup(__props) {
    const store = useCompositorStore();
    const audioFileInput = ref(null);
    const waveformCanvas = ref(null);
    const masterVolume = computed({
      get: () => store.audioVolume,
      set: (val) => store.setAudioVolume(val)
    });
    const isMuted = computed({
      get: () => store.audioMuted,
      set: (val) => store.setAudioMuted(val)
    });
    const hasAudio = computed(() => !!store.audioBuffer);
    const audioFileName = computed(() => store.audioFile?.name || "Unknown");
    const audioSampleRate = computed(() => store.audioBuffer ? `${(store.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "");
    const audioDuration = computed(() => {
      if (!store.audioBuffer) return "0:00";
      const m = Math.floor(store.audioBuffer.duration / 60);
      const s = Math.floor(store.audioBuffer.duration % 60);
      return `${m}:${s.toString().padStart(2, "0")}`;
    });
    function loadAudioFile() {
      audioFileInput.value?.click();
    }
    async function handleAudioFileSelected(e) {
      const input = e.target;
      if (input.files?.length) await store.loadAudio(input.files[0]);
      input.value = "";
    }
    function removeAudio() {
      store.clearAudio();
    }
    function toggleMute() {
      store.toggleAudioMute();
    }
    function drawWaveform() {
      if (!waveformCanvas.value || !store.audioBuffer) return;
      const canvas = waveformCanvas.value;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = 60 * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      const data = store.audioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / rect.width);
      const amp = 30;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, rect.width, 60);
      ctx.beginPath();
      ctx.strokeStyle = "#4a90d9";
      ctx.lineWidth = 1;
      for (let i = 0; i < rect.width; i++) {
        let min = 1;
        let max = -1;
        for (let j = 0; j < step; j++) {
          const datum = data[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.stroke();
      const px = store.currentFrame / store.frameCount * rect.width;
      ctx.fillStyle = "#fff";
      ctx.fillRect(px, 0, 1, 60);
    }
    watch(() => [store.audioBuffer, store.currentFrame], drawWaveform);
    onMounted(() => {
      if (hasAudio.value) {
        setTimeout(drawWaveform, 100);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$o, [
        createBaseVNode("div", { class: "panel-header" }, [
          _cache[2] || (_cache[2] = createBaseVNode("span", { class: "panel-title" }, "Audio Source", -1)),
          createBaseVNode("div", { class: "header-actions" }, [
            createBaseVNode("button", {
              onClick: loadAudioFile,
              title: "Load Audio"
            }, [..._cache[1] || (_cache[1] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ])
        ]),
        hasAudio.value ? (openBlock(), createElementBlock("div", _hoisted_2$o, [
          createBaseVNode("div", _hoisted_3$o, [
            createBaseVNode("div", _hoisted_4$o, [
              _cache[3] || (_cache[3] = createBaseVNode("span", { class: "file-icon" }, "", -1)),
              createBaseVNode("div", _hoisted_5$o, [
                createBaseVNode("span", _hoisted_6$o, toDisplayString(audioFileName.value), 1),
                createBaseVNode("span", _hoisted_7$o, toDisplayString(audioDuration.value) + "  " + toDisplayString(audioSampleRate.value), 1)
              ]),
              createBaseVNode("button", {
                class: "remove-btn",
                onClick: removeAudio,
                title: "Remove Audio"
              }, "")
            ])
          ]),
          createBaseVNode("div", _hoisted_8$o, [
            createBaseVNode("div", _hoisted_9$o, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Master Vol", -1)),
              createVNode(unref(SliderInput), {
                modelValue: masterVolume.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => masterVolume.value = $event),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"]),
              createBaseVNode("button", {
                class: normalizeClass(["mute-btn", { active: isMuted.value }]),
                onClick: toggleMute,
                title: "Mute"
              }, toDisplayString(isMuted.value ? "" : ""), 3)
            ])
          ]),
          createBaseVNode("div", _hoisted_10$o, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Waveform")
            ], -1)),
            createBaseVNode("div", _hoisted_11$n, [
              createBaseVNode("canvas", {
                ref_key: "waveformCanvas",
                ref: waveformCanvas,
                class: "waveform-canvas"
              }, null, 512)
            ])
          ]),
          createBaseVNode("div", _hoisted_12$l, [
            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "linker-header" }, "Audio Linker", -1)),
            createVNode(AudioProperties)
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_13$l, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "empty-icon" }, "", -1)),
          _cache[8] || (_cache[8] = createBaseVNode("p", null, "No audio loaded", -1)),
          createBaseVNode("button", {
            class: "load-btn",
            onClick: loadAudioFile
          }, "Load Audio File"),
          _cache[9] || (_cache[9] = createBaseVNode("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
        ])),
        createBaseVNode("input", {
          ref_key: "audioFileInput",
          ref: audioFileInput,
          type: "file",
          accept: "audio/*",
          style: { "display": "none" },
          onChange: handleAudioFileSelected
        }, null, 544)
      ]);
    };
  }
});

const AudioPanel = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-63f3ca66"]]);

class SVGExtrusionService {
  svgLoader;
  documentCache = /* @__PURE__ */ new Map();
  meshCache = /* @__PURE__ */ new Map();
  constructor() {
    this.svgLoader = new SVGLoader();
  }
  // ==========================================================================
  // SVG LOADING AND PARSING
  // ==========================================================================
  /**
   * Load and parse an SVG file from URL
   * @throws Error if URL is invalid or blocked for security reasons
   */
  async loadFromURL(url, name) {
    const validatedUrl = validateURL(url, "SVG loading", {
      allowData: true,
      allowBlob: true,
      allowHttp: true
      // Allow HTTP for local development
    });
    return new Promise((resolve, reject) => {
      this.svgLoader.load(
        validatedUrl,
        (data) => {
          const doc = this.parseSVGResult(data, name || url);
          this.documentCache.set(doc.id, doc);
          resolve(doc);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load and parse SVG from string content
   */
  loadFromString(svgString, name = "svg") {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
    const svgElement = svgDoc.querySelector("svg");
    if (!svgElement) {
      throw new Error("Invalid SVG: No SVG element found");
    }
    const data = this.svgLoader.parse(svgString);
    const doc = this.parseSVGResult(data, name);
    this.documentCache.set(doc.id, doc);
    return doc;
  }
  /**
   * Parse SVGLoader result into our format
   */
  parseSVGResult(data, name) {
    const id = `svg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const paths = [];
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    data.paths.forEach((shapePath, index) => {
      const shapes = SVGLoader.createShapes(shapePath);
      if (shapes.length === 0) return;
      const fillColor = shapePath.userData?.style?.fill;
      const color = new Color(
        fillColor && fillColor !== "none" ? fillColor : "#ffffff"
      );
      const fillOpacity = shapePath.userData?.style?.fillOpacity ?? 1;
      const strokeColor = shapePath.userData?.style?.stroke;
      const strokeWidth = shapePath.userData?.style?.strokeWidth ?? 0;
      const pathBounds = this.calculatePathBounds(shapes);
      minX = Math.min(minX, pathBounds.minX);
      minY = Math.min(minY, pathBounds.minY);
      maxX = Math.max(maxX, pathBounds.maxX);
      maxY = Math.max(maxY, pathBounds.maxY);
      paths.push({
        id: `${id}_path_${index}`,
        name: `Path ${index + 1}`,
        path: shapePath,
        shapes,
        color,
        fillOpacity,
        strokeColor: strokeColor && strokeColor !== "none" ? new Color(strokeColor) : null,
        strokeWidth,
        bounds: pathBounds,
        originalTransform: new Matrix4()
      });
    });
    const viewBox = {
      x: 0,
      y: 0,
      width: maxX - minX,
      height: maxY - minY
    };
    return {
      id,
      name,
      paths,
      viewBox,
      bounds: {
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      }
    };
  }
  /**
   * Calculate bounds for a set of shapes
   */
  calculatePathBounds(shapes) {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    for (const shape of shapes) {
      const points = shape.getPoints(50);
      for (const point of points) {
        minX = Math.min(minX, point.x);
        minY = Math.min(minY, point.y);
        maxX = Math.max(maxX, point.x);
        maxY = Math.max(maxY, point.y);
      }
      for (const hole of shape.holes) {
        const holePoints = hole.getPoints(50);
        for (const point of holePoints) {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }
      }
    }
    const width = maxX - minX;
    const height = maxY - minY;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width,
      height,
      centerX: minX + width / 2,
      centerY: minY + height / 2
    };
  }
  // ==========================================================================
  // EXTRUSION
  // ==========================================================================
  /**
   * Create extruded geometry from an SVG path
   */
  createExtrudedGeometry(path, config = {}) {
    const cacheKey = `${path.id}_${JSON.stringify(config)}`;
    const cached = this.meshCache.get(cacheKey);
    if (cached) return cached.clone();
    const extrudeSettings = {
      depth: config.depth ?? 10,
      bevelEnabled: config.bevelEnabled ?? false,
      bevelThickness: config.bevelThickness ?? 1,
      bevelSize: config.bevelSize ?? 0.5,
      bevelOffset: config.bevelOffset ?? 0,
      bevelSegments: config.bevelSegments ?? 3,
      curveSegments: config.curveSegments ?? 12,
      steps: config.steps ?? 1
    };
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ExtrudeGeometry(shape, extrudeSettings);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    finalGeometry.computeVertexNormals();
    this.meshCache.set(cacheKey, finalGeometry);
    return finalGeometry.clone();
  }
  /**
   * Create a flat (2D) geometry from SVG path
   */
  createFlatGeometry(path) {
    const geometries = [];
    for (const shape of path.shapes) {
      const geometry = new ShapeGeometry(shape);
      geometries.push(geometry);
    }
    let finalGeometry;
    if (geometries.length === 1) {
      finalGeometry = geometries[0];
    } else {
      finalGeometry = this.mergeGeometries(geometries);
      geometries.forEach((g) => g.dispose());
    }
    finalGeometry.scale(1, -1, 1);
    return finalGeometry;
  }
  /**
   * Merge multiple geometries into one
   */
  mergeGeometries(geometries) {
    let totalVertices = 0;
    let totalIndices = 0;
    let hasNormals = true;
    let hasUVs = true;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      if (pos) totalVertices += pos.count;
      const idx = geom.getIndex();
      if (idx) totalIndices += idx.count;
      else totalIndices += pos?.count ?? 0;
      if (!geom.getAttribute("normal")) hasNormals = false;
      if (!geom.getAttribute("uv")) hasUVs = false;
    }
    const positions = new Float32Array(totalVertices * 3);
    const normals = hasNormals ? new Float32Array(totalVertices * 3) : null;
    const uvs = hasUVs ? new Float32Array(totalVertices * 2) : null;
    const indices = new Uint32Array(totalIndices);
    let vertexOffset = 0;
    let indexOffset = 0;
    let indexVertexOffset = 0;
    for (const geom of geometries) {
      const pos = geom.getAttribute("position");
      const norm = geom.getAttribute("normal");
      const uv = geom.getAttribute("uv");
      const idx = geom.getIndex();
      if (pos) {
        positions.set(pos.array, vertexOffset * 3);
        if (normals && norm) {
          normals.set(norm.array, vertexOffset * 3);
        }
        if (uvs && uv) {
          uvs.set(uv.array, vertexOffset * 2);
        }
        if (idx) {
          for (let i = 0; i < idx.count; i++) {
            indices[indexOffset + i] = idx.getX(i) + indexVertexOffset;
          }
          indexOffset += idx.count;
        } else {
          for (let i = 0; i < pos.count; i++) {
            indices[indexOffset + i] = i + indexVertexOffset;
          }
          indexOffset += pos.count;
        }
        indexVertexOffset += pos.count;
        vertexOffset += pos.count;
      }
    }
    const merged = new BufferGeometry();
    merged.setAttribute("position", new BufferAttribute(positions, 3));
    if (normals) {
      merged.setAttribute("normal", new BufferAttribute(normals, 3));
    }
    if (uvs) {
      merged.setAttribute("uv", new BufferAttribute(uvs, 2));
    }
    merged.setIndex(new BufferAttribute(indices, 1));
    return merged;
  }
  // ==========================================================================
  // MESH CREATION
  // ==========================================================================
  /**
   * Create a 3D mesh from extruded SVG path
   */
  createMesh(path, extrusionConfig = {}, materialConfig = {}) {
    const geometry = this.createExtrudedGeometry(path, extrusionConfig);
    const material = this.createMaterial(path, materialConfig);
    const mesh = new Mesh(geometry, material);
    mesh.name = path.name;
    mesh.userData.svgPathId = path.id;
    return mesh;
  }
  /**
   * Create material for extruded mesh
   */
  createMaterial(path, config = {}) {
    const type = config.type ?? "standard";
    const color = config.color ?? `#${path.color.getHexString()}`;
    const side = this.getSide(config.side ?? "double");
    const baseParams = {
      color: new Color(color),
      transparent: config.transparent ?? path.fillOpacity < 1,
      opacity: config.opacity ?? path.fillOpacity,
      side
    };
    switch (type) {
      case "basic":
        return new MeshBasicMaterial(baseParams);
      case "physical":
        return new MeshPhysicalMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
      case "standard":
      default:
        return new MeshStandardMaterial({
          ...baseParams,
          metalness: config.metalness ?? 0,
          roughness: config.roughness ?? 0.5,
          emissive: new Color(config.emissive ?? "#000000"),
          emissiveIntensity: config.emissiveIntensity ?? 0
        });
    }
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  // ==========================================================================
  // LAYER CREATION (LOGO WORKFLOW)
  // ==========================================================================
  /**
   * Create multiple layers from an SVG document for depth stacking
   * This is the main entry point for the logo workflow
   */
  createLayeredMeshes(document, layerConfigs) {
    const group = new Group();
    group.name = document.name;
    const centerX = document.bounds.minX + document.bounds.width / 2;
    const centerY = document.bounds.minY + document.bounds.height / 2;
    for (const config of layerConfigs) {
      const path = document.paths.find((p) => p.id === config.pathId);
      if (!path) continue;
      const mesh = this.createMesh(
        path,
        { depth: config.extrusionDepth },
        config.material
      );
      mesh.scale.setScalar(config.scale);
      mesh.position.set(
        config.position.x - centerX * config.scale,
        config.position.y + centerY * config.scale,
        // Flip Y
        config.position.z + config.depth
      );
      mesh.rotation.set(
        config.rotation.x * (Math.PI / 180),
        config.rotation.y * (Math.PI / 180),
        config.rotation.z * (Math.PI / 180)
      );
      group.add(mesh);
    }
    return group;
  }
  /**
   * Auto-generate layer configs for all paths in a document
   * Assigns incrementing depths to each path
   */
  generateAutoLayerConfigs(document, baseDepth = 0, depthIncrement = 5, extrusionDepth = 2) {
    return document.paths.map((path, index) => ({
      pathId: path.id,
      depth: baseDepth + index * depthIncrement,
      extrusionDepth,
      scale: 1,
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0, z: 0 },
      material: {
        type: "standard",
        color: `#${path.color.getHexString()}`,
        metalness: 0,
        roughness: 0.5,
        emissive: "#000000",
        emissiveIntensity: 0,
        opacity: path.fillOpacity,
        transparent: path.fillOpacity < 1,
        side: "double"
      }
    }));
  }
  // ==========================================================================
  // PARTICLE MESH GENERATION
  // ==========================================================================
  /**
   * Create a particle-ready mesh from SVG path
   * Optimized for instanced rendering
   */
  createParticleMesh(path, config = {}) {
    const extrusionDepth = config.extrusionDepth ?? 1;
    const scale = config.scale ?? 1;
    let geometry = this.createExtrudedGeometry(path, {
      depth: extrusionDepth,
      bevelEnabled: false,
      curveSegments: config.simplify ? 6 : 12
    });
    if (config.simplify) {
      geometry = this.simplifyGeometry(
        geometry,
        config.simplifyTolerance ?? 0.1
      );
    }
    if (config.centerOrigin !== false) {
      geometry.computeBoundingBox();
      const center = new Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);
    }
    if (scale !== 1) {
      geometry.scale(scale, scale, scale);
    }
    geometry.computeVertexNormals();
    return geometry;
  }
  /**
   * Simple geometry simplification (reduces vertex count)
   */
  simplifyGeometry(geometry, tolerance) {
    const position = geometry.getAttribute("position");
    const index = geometry.getIndex();
    if (!position) return geometry;
    const vertices = /* @__PURE__ */ new Map();
    const newPositions = [];
    const newIndices = [];
    const indexMap = /* @__PURE__ */ new Map();
    const roundToTolerance = (v) => Math.round(v / tolerance) * tolerance;
    for (let i = 0; i < position.count; i++) {
      const x = roundToTolerance(position.getX(i));
      const y = roundToTolerance(position.getY(i));
      const z = roundToTolerance(position.getZ(i));
      const key = `${x},${y},${z}`;
      if (!vertices.has(key)) {
        vertices.set(key, newPositions.length / 3);
        newPositions.push(x, y, z);
      }
      indexMap.set(i, vertices.get(key));
    }
    if (index) {
      for (let i = 0; i < index.count; i++) {
        const oldIdx = index.getX(i);
        newIndices.push(indexMap.get(oldIdx));
      }
    } else {
      for (let i = 0; i < position.count; i++) {
        newIndices.push(indexMap.get(i));
      }
    }
    const simplified = new BufferGeometry();
    simplified.setAttribute(
      "position",
      new Float32BufferAttribute(newPositions, 3)
    );
    simplified.setIndex(newIndices);
    simplified.computeVertexNormals();
    return simplified;
  }
  // ==========================================================================
  // STROKE/OUTLINE GEOMETRY
  // ==========================================================================
  /**
   * Create tube geometry from SVG stroke
   * Useful for neon-style effects or 3D outlines
   */
  createStrokeGeometry(path, tubeRadius = 1, tubularSegments = 64, radialSegments = 8) {
    const geometries = [];
    for (const shape of path.shapes) {
      const points = shape.getPoints(tubularSegments);
      const points3D = points.map((p) => new Vector3(p.x, -p.y, 0));
      const curve = new CatmullRomCurve3(points3D);
      const tubeGeometry = new TubeGeometry(
        curve,
        tubularSegments,
        tubeRadius,
        radialSegments,
        false
        // closed
      );
      geometries.push(tubeGeometry);
    }
    return geometries;
  }
  // ==========================================================================
  // UTILITY METHODS
  // ==========================================================================
  /**
   * Get cached document
   */
  getDocument(id) {
    return this.documentCache.get(id);
  }
  /**
   * Get all cached documents
   */
  getAllDocuments() {
    return Array.from(this.documentCache.values());
  }
  /**
   * Clear caches
   */
  clearCache() {
    this.documentCache.clear();
    for (const geometry of this.meshCache.values()) {
      geometry.dispose();
    }
    this.meshCache.clear();
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.clearCache();
  }
}
const svgExtrusionService = new SVGExtrusionService();

class MeshParticleManager {
  /** Registered mesh particles */
  meshRegistry = /* @__PURE__ */ new Map();
  /** Instanced mesh renderers */
  instancedMeshes = /* @__PURE__ */ new Map();
  /** Default material for mesh particles */
  defaultMaterial;
  /** Texture loader for thumbnails */
  textureLoader;
  constructor() {
    this.defaultMaterial = new MeshStandardMaterial({
      color: 16777215,
      metalness: 0,
      roughness: 0.5,
      side: DoubleSide
    });
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // MESH REGISTRATION
  // ==========================================================================
  /**
   * Register a mesh for use as particles
   */
  registerMesh(id, name, geometry, source, config) {
    geometry.computeBoundingBox();
    geometry.computeBoundingSphere();
    const registration = {
      id,
      name,
      source,
      geometry,
      boundingBox: geometry.boundingBox.clone(),
      boundingSphere: geometry.boundingSphere.clone(),
      vertexCount: geometry.getAttribute("position")?.count ?? 0,
      faceCount: geometry.index ? geometry.index.count / 3 : (geometry.getAttribute("position")?.count ?? 0) / 3,
      config
    };
    this.meshRegistry.set(id, registration);
    return registration;
  }
  /**
   * Register mesh from SVG path
   */
  registerFromSVG(svgDocumentId, svgPathId, name, options = {}) {
    const document2 = svgExtrusionService.getDocument(svgDocumentId);
    if (!document2) {
      console.warn(`SVG document not found: ${svgDocumentId}`);
      return null;
    }
    const path = document2.paths.find((p) => p.id === svgPathId);
    if (!path) {
      console.warn(`SVG path not found: ${svgPathId}`);
      return null;
    }
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: svgPathId
    });
    const id = `svg_particle_${svgDocumentId}_${svgPathId}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgDocumentId,
      svgPathId,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register mesh from parsed SVG path directly
   */
  registerFromSVGPath(path, name, options = {}) {
    const geometry = svgExtrusionService.createParticleMesh(path, {
      ...options,
      pathId: path.id
    });
    const id = `svg_particle_${path.id}`;
    return this.registerMesh(id, name, geometry, "svg", {
      source: "svg",
      svgPathId: path.id,
      svgExtrusionDepth: options.extrusionDepth ?? 1,
      scale: options.scale ?? 0.01,
      centerOrigin: options.centerOrigin ?? true,
      simplify: options.simplify ?? true,
      simplifyTolerance: options.simplifyTolerance ?? 0.1
    });
  }
  /**
   * Register a primitive shape as mesh particle
   */
  registerPrimitive(type, name, size = 1, detail = 1) {
    let geometry;
    switch (type) {
      case "cube":
        geometry = new BoxGeometry(size, size, size);
        break;
      case "sphere":
        geometry = new SphereGeometry(size / 2, 8 * detail, 6 * detail);
        break;
      case "cone":
        geometry = new ConeGeometry(size / 2, size, 8 * detail);
        break;
      case "cylinder":
        geometry = new CylinderGeometry(size / 2, size / 2, size, 8 * detail);
        break;
      case "torus":
        geometry = new TorusGeometry(size / 2, size / 6, 8 * detail, 12 * detail);
        break;
      case "tetrahedron":
        geometry = new TetrahedronGeometry(size / 2, detail - 1);
        break;
      case "octahedron":
        geometry = new OctahedronGeometry(size / 2, detail - 1);
        break;
      case "icosahedron":
        geometry = new IcosahedronGeometry(size / 2, detail - 1);
        break;
      default:
        geometry = new BoxGeometry(size, size, size);
    }
    const id = `primitive_${type}_${size}_${detail}`;
    const displayName = name ?? `${type?.charAt(0).toUpperCase()}${type?.slice(1)}`;
    return this.registerMesh(id, displayName, geometry, "primitive", {
      source: "primitive",
      primitiveType: type,
      primitiveSize: size,
      primitiveDetail: detail,
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0
    });
  }
  /**
   * Register a custom geometry
   */
  registerCustom(id, name, geometry, config) {
    return this.registerMesh(id, name, geometry, "custom", {
      source: "custom",
      scale: 1,
      centerOrigin: true,
      simplify: false,
      simplifyTolerance: 0,
      ...config
    });
  }
  // ==========================================================================
  // INSTANCED MESH RENDERING
  // ==========================================================================
  /**
   * Create an instanced mesh for particle rendering
   */
  createInstancedMesh(meshId, maxInstances, material) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) {
      console.warn(`Mesh not found: ${meshId}`);
      return null;
    }
    const mat = material ?? this.createMaterialForMesh(registration);
    const instancedMesh = new InstancedMesh(
      registration.geometry,
      mat,
      maxInstances
    );
    instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);
    instancedMesh.count = 0;
    instancedMesh.frustumCulled = false;
    const instance = {
      mesh: instancedMesh,
      maxInstances,
      activeInstances: 0,
      geometry: registration.geometry,
      material: mat
    };
    this.instancedMeshes.set(meshId, instance);
    return instance;
  }
  /**
   * Update instanced mesh with particle data
   * @param meshId - Registered mesh ID
   * @param particles - Array of particle transforms
   */
  updateInstancedMesh(meshId, particles) {
    const instance = this.instancedMeshes.get(meshId);
    if (!instance) return;
    const matrix = new Matrix4();
    const quaternion = new Quaternion();
    const scaleVec = new Vector3();
    const count = Math.min(particles.length, instance.maxInstances);
    instance.mesh.count = count;
    instance.activeInstances = count;
    for (let i = 0; i < count; i++) {
      const p = particles[i];
      if (p.rotation instanceof Euler) {
        quaternion.setFromEuler(p.rotation);
      } else {
        quaternion.copy(p.rotation);
      }
      if (typeof p.scale === "number") {
        scaleVec.set(p.scale, p.scale, p.scale);
      } else {
        scaleVec.copy(p.scale);
      }
      matrix.compose(p.position, quaternion, scaleVec);
      instance.mesh.setMatrixAt(i, matrix);
      if (p.color && instance.mesh.instanceColor) {
        instance.mesh.setColorAt(i, p.color);
      }
    }
    instance.mesh.instanceMatrix.needsUpdate = true;
    if (instance.mesh.instanceColor) {
      instance.mesh.instanceColor.needsUpdate = true;
    }
  }
  /**
   * Create default material for a mesh
   */
  createMaterialForMesh(registration) {
    const config = registration.config;
    if (!config) {
      return this.defaultMaterial.clone();
    }
    return new MeshStandardMaterial({
      color: new Color(config.color ?? "#ffffff"),
      metalness: config.metalness ?? 0,
      roughness: config.roughness ?? 0.5,
      emissive: new Color(config.emissive ?? "#000000"),
      emissiveIntensity: config.emissiveIntensity ?? 0,
      side: DoubleSide
    });
  }
  // ==========================================================================
  // EMITTER INTEGRATION
  // ==========================================================================
  /**
   * Get EmitterShapeConfig for mesh emission
   * Particles emit from mesh vertices
   */
  getEmitterShapeConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const position = registration.geometry.getAttribute("position");
    const normal = registration.geometry.getAttribute("normal");
    if (!position) return null;
    const vertices = new Float32Array(position.array);
    const normals = normal ? new Float32Array(normal.array) : void 0;
    return {
      type: "mesh",
      meshVertices: vertices,
      meshNormals: normals
    };
  }
  /**
   * Get RenderConfig for mesh particle rendering
   */
  getRenderConfig(meshId) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    return {
      mode: "mesh",
      meshGeometry: meshId
    };
  }
  // ==========================================================================
  // LOD MANAGEMENT
  // ==========================================================================
  /**
   * Add LOD levels to a registered mesh
   */
  addLODLevels(meshId, lodGeometries, lodDistances) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return;
    registration.lodGeometries = lodGeometries;
    registration.lodDistances = lodDistances;
  }
  /**
   * Get appropriate LOD geometry for distance
   */
  getLODGeometry(meshId, distance) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    if (!registration.lodGeometries || !registration.lodDistances) {
      return registration.geometry;
    }
    for (let i = registration.lodDistances.length - 1; i >= 0; i--) {
      if (distance >= registration.lodDistances[i]) {
        return registration.lodGeometries[i];
      }
    }
    return registration.geometry;
  }
  // ==========================================================================
  // THUMBNAIL GENERATION
  // ==========================================================================
  /**
   * Generate a thumbnail preview for a mesh
   */
  async generateThumbnail(meshId, size = 128) {
    const registration = this.meshRegistry.get(meshId);
    if (!registration) return null;
    const scene = new Scene();
    scene.background = new Color(1710618);
    const mesh = new Mesh(
      registration.geometry,
      new MeshStandardMaterial({
        color: 16777215,
        metalness: 0.3,
        roughness: 0.6
      })
    );
    scene.add(mesh);
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    const radius = registration.boundingSphere.radius;
    const distance = radius / Math.sin(camera.fov * Math.PI / 360);
    camera.position.set(distance * 0.8, distance * 0.5, distance * 0.8);
    camera.lookAt(registration.boundingSphere.center);
    const ambient = new AmbientLight(16777215, 0.5);
    const directional = new DirectionalLight(16777215, 1);
    directional.position.set(5, 10, 5);
    scene.add(ambient, directional);
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const renderer = new WebGLRenderer({
      canvas,
      antialias: true,
      preserveDrawingBuffer: true
    });
    renderer.setSize(size, size);
    renderer.render(scene, camera);
    const dataUrl = canvas.toDataURL("image/png");
    renderer.dispose();
    mesh.geometry.dispose();
    mesh.material.dispose();
    registration.thumbnail = dataUrl;
    return dataUrl;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a registered mesh
   */
  getMesh(id) {
    return this.meshRegistry.get(id);
  }
  /**
   * Get all registered meshes
   */
  getAllMeshes() {
    return Array.from(this.meshRegistry.values());
  }
  /**
   * Get meshes by source type
   */
  getMeshesBySource(source) {
    return Array.from(this.meshRegistry.values()).filter(
      (m) => m.source === source
    );
  }
  /**
   * Get instanced mesh renderer
   */
  getInstancedMesh(meshId) {
    return this.instancedMeshes.get(meshId);
  }
  /**
   * Check if a mesh is registered
   */
  hasMesh(id) {
    return this.meshRegistry.has(id);
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Unregister a mesh
   */
  unregisterMesh(id) {
    const registration = this.meshRegistry.get(id);
    if (registration) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.delete(id);
    const instance = this.instancedMeshes.get(id);
    if (instance) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const registration of this.meshRegistry.values()) {
      registration.geometry.dispose();
      registration.lodGeometries?.forEach((g) => g.dispose());
    }
    this.meshRegistry.clear();
    for (const instance of this.instancedMeshes.values()) {
      instance.mesh.dispose();
      instance.material.dispose();
    }
    this.instancedMeshes.clear();
    this.defaultMaterial.dispose();
  }
}
const meshParticleManager = new MeshParticleManager();

class SpriteSheetService {
  sheets = /* @__PURE__ */ new Map();
  textureLoader;
  constructor() {
    this.textureLoader = new TextureLoader();
  }
  // ==========================================================================
  // LOADING
  // ==========================================================================
  /**
   * Load a sprite sheet from URL with grid-based layout
   */
  async loadFromGrid(url, columns, rows, options = {}) {
    const texture = await this.loadTexture(url);
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            // Flip Y for Three.js
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: {
            x,
            y,
            width: frameWidth,
            height: frameHeight
          }
        });
      }
    }
    const config = {
      id,
      name: options.name || url,
      url,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load a sprite sheet from URL with JSON metadata
   */
  async loadFromMetadata(imageUrl, metadataUrl, options = {}) {
    const [texture, metadataResponse] = await Promise.all([
      this.loadTexture(imageUrl),
      fetch(metadataUrl)
    ]);
    const metadata = await metadataResponse.json();
    const id = `spritesheet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frames = [];
    const frameEntries = Object.entries(metadata.frames);
    frameEntries.forEach(([name, frameData], index) => {
      const f = frameData.frame;
      frames.push({
        index,
        name,
        uv: {
          u: f.x / imageWidth,
          v: 1 - (f.y + f.h) / imageHeight,
          w: f.w / imageWidth,
          h: f.h / imageHeight
        },
        source: {
          x: f.x,
          y: f.y,
          width: f.w,
          height: f.h
        },
        duration: frameData.duration
      });
    });
    const columns = Math.ceil(Math.sqrt(frames.length));
    const rows = Math.ceil(frames.length / columns);
    const config = {
      id,
      name: options.name || imageUrl,
      url: imageUrl,
      texture,
      columns,
      rows,
      frames,
      totalFrames: frames.length,
      frameWidth: frames[0]?.source.width ?? 0,
      frameHeight: frames[0]?.source.height ?? 0,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: true
    };
    if (metadata.meta?.frameTags) {
      for (const tag of metadata.meta.frameTags) {
        const animFrames = [];
        for (let i = tag.from; i <= tag.to; i++) {
          animFrames.push(i);
        }
        config.animations.set(tag.name, {
          name: tag.name,
          frames: animFrames,
          frameRate: config.defaultFrameRate,
          loop: true,
          pingPong: tag.direction === "pingpong"
        });
      }
    }
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  /**
   * Load texture from URL
   */
  loadTexture(url) {
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          texture.magFilter = NearestFilter;
          texture.minFilter = NearestFilter;
          texture.generateMipmaps = false;
          texture.colorSpace = SRGBColorSpace;
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Create a sprite sheet from an existing texture
   */
  createFromTexture(texture, columns, rows, options = {}) {
    const id = options.id || `spritesheet_${Date.now()}`;
    const imageWidth = texture.image.width;
    const imageHeight = texture.image.height;
    const frameWidth = imageWidth / columns;
    const frameHeight = imageHeight / rows;
    const totalFrames = columns * rows;
    const frames = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        const index = row * columns + col;
        const x = col * frameWidth;
        const y = row * frameHeight;
        frames.push({
          index,
          uv: {
            u: x / imageWidth,
            v: 1 - (y + frameHeight) / imageHeight,
            w: frameWidth / imageWidth,
            h: frameHeight / imageHeight
          },
          source: { x, y, width: frameWidth, height: frameHeight }
        });
      }
    }
    const config = {
      id,
      name: options.name || id,
      texture,
      columns,
      rows,
      frames,
      totalFrames,
      frameWidth,
      frameHeight,
      imageWidth,
      imageHeight,
      animations: /* @__PURE__ */ new Map(),
      defaultFrameRate: options.frameRate ?? 12,
      defaultLoop: options.loop ?? true
    };
    config.animations.set("all", {
      name: "all",
      frames: frames.map((f) => f.index),
      frameRate: config.defaultFrameRate,
      loop: config.defaultLoop,
      pingPong: false
    });
    this.sheets.set(id, config);
    return config;
  }
  // ==========================================================================
  // ANIMATION MANAGEMENT
  // ==========================================================================
  /**
   * Add a custom animation to a sprite sheet
   */
  addAnimation(sheetId, animation) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) {
      console.warn(`Sprite sheet not found: ${sheetId}`);
      return;
    }
    sheet.animations.set(animation.name, animation);
  }
  /**
   * Get frame index for a specific time in an animation
   */
  getFrameAtTime(sheetId, animationName, timeMs) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet) return 0;
    const animation = sheet.animations.get(animationName);
    if (!animation || animation.frames.length === 0) return 0;
    const frameDuration = 1e3 / animation.frameRate;
    const totalDuration = animation.frames.length * frameDuration;
    let t = timeMs;
    if (animation.loop) {
      if (animation.pingPong) {
        const fullCycle = totalDuration * 2 - frameDuration * 2;
        t = t % fullCycle;
        if (t > totalDuration - frameDuration) {
          t = fullCycle - t;
        }
      } else {
        t = t % totalDuration;
      }
    } else {
      t = Math.min(t, totalDuration - frameDuration);
    }
    const frameIndex = Math.floor(t / frameDuration);
    return animation.frames[Math.min(frameIndex, animation.frames.length - 1)];
  }
  /**
   * Get UV coordinates for a specific frame
   */
  getFrameUV(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || frameIndex < 0 || frameIndex >= sheet.frames.length) {
      return null;
    }
    return sheet.frames[frameIndex].uv;
  }
  // ==========================================================================
  // PARTICLE SYSTEM INTEGRATION
  // ==========================================================================
  /**
   * Get texture config for GPU particle system
   */
  getParticleTextureConfig(sheetId, animationName) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet || !sheet.url) return null;
    const animation = animationName ? sheet.animations.get(animationName) : sheet.animations.get("all");
    return {
      diffuseMap: sheet.url,
      spriteSheetColumns: sheet.columns,
      spriteSheetRows: sheet.rows,
      animateSprite: true,
      spriteFrameRate: animation?.frameRate ?? sheet.defaultFrameRate,
      randomStartFrame: true
    };
  }
  /**
   * Create a Three.js SpriteMaterial for a specific frame
   */
  createSpriteMaterial(sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture) return null;
    const frame = sheet.frames[frameIndex];
    if (!frame) return null;
    const texture = sheet.texture.clone();
    texture.offset.set(frame.uv.u, frame.uv.v);
    texture.repeat.set(frame.uv.w, frame.uv.h);
    texture.needsUpdate = true;
    return new SpriteMaterial({
      map: texture,
      transparent: true
    });
  }
  /**
   * Update a SpriteMaterial to show a specific frame
   */
  updateSpriteMaterialFrame(material, sheetId, frameIndex) {
    const sheet = this.sheets.get(sheetId);
    if (!sheet?.texture || !material.map) return;
    const frame = sheet.frames[frameIndex];
    if (!frame) return;
    material.map.offset.set(frame.uv.u, frame.uv.v);
    material.map.repeat.set(frame.uv.w, frame.uv.h);
    material.map.needsUpdate = true;
  }
  // ==========================================================================
  // ACCESSORS
  // ==========================================================================
  /**
   * Get a sprite sheet by ID
   */
  getSheet(id) {
    return this.sheets.get(id);
  }
  /**
   * Get all sprite sheets
   */
  getAllSheets() {
    return Array.from(this.sheets.values());
  }
  /**
   * Check if a sprite sheet exists
   */
  hasSheet(id) {
    return this.sheets.has(id);
  }
  /**
   * Get texture for a sprite sheet
   */
  getTexture(sheetId) {
    return this.sheets.get(sheetId)?.texture;
  }
  // ==========================================================================
  // CLEANUP
  // ==========================================================================
  /**
   * Remove a sprite sheet
   */
  removeSheet(id) {
    const sheet = this.sheets.get(id);
    if (sheet?.texture) {
      sheet.texture.dispose();
    }
    this.sheets.delete(id);
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const sheet of this.sheets.values()) {
      if (sheet.texture) {
        sheet.texture.dispose();
      }
    }
    this.sheets.clear();
  }
}
const spriteSheetService = new SpriteSheetService();

class MaterialSystem {
  /** Texture cache */
  textureCache = /* @__PURE__ */ new Map();
  /** Material cache */
  materialCache = /* @__PURE__ */ new Map();
  /** Current environment map */
  envMap = null;
  /** Environment configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true
  };
  /** HDRI loader */
  rgbeLoader;
  exrLoader;
  /** Texture loader */
  textureLoader;
  /** PMREMGenerator for environment maps */
  pmremGenerator = null;
  /** Asset getter callback */
  assetGetter;
  constructor() {
    this.rgbeLoader = new RGBELoader();
    this.exrLoader = new EXRLoader();
    this.textureLoader = new TextureLoader();
  }
  /**
   * Initialize with WebGL renderer (required for PMREM)
   */
  initialize(renderer) {
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Set asset getter callback
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  // ============================================================================
  // TEXTURE LOADING
  // ============================================================================
  /**
   * Load a texture from URL or asset ID
   */
  async loadTexture(urlOrAssetId, mapType, options) {
    const cacheKey = `${urlOrAssetId}:${mapType}`;
    const cached = this.textureCache.get(cacheKey);
    if (cached) return cached;
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.configureTextureForMapType(texture, mapType);
          if (options?.repeat) {
            texture.repeat.set(options.repeat.x, options.repeat.y);
            texture.wrapS = RepeatWrapping;
            texture.wrapT = RepeatWrapping;
          }
          if (options?.offset) {
            texture.offset.set(options.offset.x, options.offset.y);
          }
          if (options?.rotation !== void 0) {
            texture.rotation = options.rotation * (Math.PI / 180);
          }
          this.textureCache.set(cacheKey, texture);
          resolve(texture);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Configure texture settings based on map type
   */
  configureTextureForMapType(texture, mapType) {
    texture.generateMipmaps = true;
    texture.minFilter = LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    switch (mapType) {
      case "albedo":
      case "emissive":
        texture.colorSpace = SRGBColorSpace;
        break;
      case "normal":
      case "roughness":
      case "metalness":
      case "ao":
      case "height":
      case "opacity":
      case "specular":
        texture.colorSpace = LinearSRGBColorSpace;
        break;
    }
  }
  // ============================================================================
  // PBR MATERIAL CREATION
  // ============================================================================
  /**
   * Create a PBR material from configuration
   */
  async createPBRMaterial(config) {
    const cached = this.materialCache.get(config.id);
    if (cached) return cached;
    const material = new MeshStandardMaterial({
      color: new Color(config.color),
      metalness: config.metalness,
      roughness: config.roughness,
      transparent: config.transparent,
      opacity: config.opacity,
      emissive: new Color(config.emissive),
      emissiveIntensity: config.emissiveIntensity,
      envMapIntensity: config.envMapIntensity,
      normalScale: new Vector2(config.normalScale, config.normalScale),
      displacementScale: config.displacementScale,
      displacementBias: config.displacementBias,
      aoMapIntensity: config.aoMapIntensity,
      flatShading: config.flatShading,
      wireframe: config.wireframe,
      depthWrite: config.depthWrite,
      depthTest: config.depthTest,
      side: this.getSide(config.side)
    });
    const texturePromises = [];
    if (config.maps.albedo) {
      texturePromises.push(
        this.loadTexture(config.maps.albedo, "albedo", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.map = tex;
        })
      );
    }
    if (config.maps.normal) {
      texturePromises.push(
        this.loadTexture(config.maps.normal, "normal", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.normalMap = tex;
        })
      );
    }
    if (config.maps.roughness) {
      texturePromises.push(
        this.loadTexture(config.maps.roughness, "roughness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.roughnessMap = tex;
        })
      );
    }
    if (config.maps.metalness) {
      texturePromises.push(
        this.loadTexture(config.maps.metalness, "metalness", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.metalnessMap = tex;
        })
      );
    }
    if (config.maps.ao) {
      texturePromises.push(
        this.loadTexture(config.maps.ao, "ao", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.aoMap = tex;
        })
      );
    }
    if (config.maps.emissive) {
      texturePromises.push(
        this.loadTexture(config.maps.emissive, "emissive", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.emissiveMap = tex;
        })
      );
    }
    if (config.maps.height) {
      texturePromises.push(
        this.loadTexture(config.maps.height, "height", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.displacementMap = tex;
        })
      );
    }
    if (config.maps.opacity) {
      texturePromises.push(
        this.loadTexture(config.maps.opacity, "opacity", {
          repeat: config.textureRepeat,
          offset: config.textureOffset,
          rotation: config.textureRotation
        }).then((tex) => {
          material.alphaMap = tex;
          material.transparent = true;
        })
      );
    }
    if (this.envMap && this.envConfig.enabled) {
      material.envMap = this.envMap;
    }
    await Promise.all(texturePromises);
    material.needsUpdate = true;
    this.materialCache.set(config.id, material);
    return material;
  }
  /**
   * Get THREE.Side from string
   */
  getSide(side) {
    switch (side) {
      case "front":
        return FrontSide;
      case "back":
        return BackSide;
      case "double":
        return DoubleSide;
    }
  }
  /**
   * Create default PBR material config
   */
  static createDefaultConfig(id, name) {
    return {
      id,
      name,
      color: "#ffffff",
      opacity: 1,
      transparent: false,
      metalness: 0,
      roughness: 0.5,
      envMapIntensity: 1,
      emissive: "#000000",
      emissiveIntensity: 1,
      normalScale: 1,
      displacementScale: 0,
      displacementBias: 0,
      aoMapIntensity: 1,
      maps: {},
      textureRepeat: { x: 1, y: 1 },
      textureOffset: { x: 0, y: 0 },
      textureRotation: 0,
      side: "double",
      flatShading: false,
      wireframe: false,
      depthWrite: true,
      depthTest: true
    };
  }
  // ============================================================================
  // ENVIRONMENT MAPS (HDRI)
  // ============================================================================
  /**
   * Load an environment map (HDR/EXR)
   */
  async loadEnvironmentMap(urlOrAssetId) {
    if (!this.pmremGenerator) {
      throw new Error("MaterialSystem not initialized. Call initialize() with renderer first.");
    }
    let url = urlOrAssetId;
    if (this.assetGetter) {
      const asset = this.assetGetter(urlOrAssetId);
      if (asset?.data) {
        url = asset.data;
      }
    }
    const isEXR = url.toLowerCase().endsWith(".exr");
    const loader = isEXR ? this.exrLoader : this.rgbeLoader;
    return new Promise((resolve, reject) => {
      loader.load(
        url,
        (texture) => {
          const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
          texture.dispose();
          this.envMap = envMap;
          this.envConfig.enabled = true;
          this.updateMaterialsEnvMap();
          resolve(envMap);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Set environment configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (config.intensity !== void 0) {
      for (const material of this.materialCache.values()) {
        material.envMapIntensity = config.intensity;
      }
    }
  }
  /**
   * Get current environment map for scene background
   */
  getEnvironmentMap() {
    return this.envMap;
  }
  /**
   * Get environment config
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Update all materials with current environment map
   */
  updateMaterialsEnvMap() {
    for (const material of this.materialCache.values()) {
      material.envMap = this.envConfig.enabled ? this.envMap : null;
      material.envMapIntensity = this.envConfig.intensity;
      material.needsUpdate = true;
    }
  }
  // ============================================================================
  // MATERIAL PRESETS
  // ============================================================================
  /**
   * Get built-in material presets
   */
  static getPresets() {
    return [
      // Metals
      {
        id: "chrome",
        name: "Chrome",
        category: "Metal",
        config: {
          color: "#ffffff",
          metalness: 1,
          roughness: 0.05,
          envMapIntensity: 1.5
        }
      },
      {
        id: "brushed_steel",
        name: "Brushed Steel",
        category: "Metal",
        config: {
          color: "#c0c0c0",
          metalness: 1,
          roughness: 0.4
        }
      },
      {
        id: "gold",
        name: "Gold",
        category: "Metal",
        config: {
          color: "#ffd700",
          metalness: 1,
          roughness: 0.2
        }
      },
      {
        id: "copper",
        name: "Copper",
        category: "Metal",
        config: {
          color: "#b87333",
          metalness: 1,
          roughness: 0.3
        }
      },
      // Plastics
      {
        id: "glossy_plastic",
        name: "Glossy Plastic",
        category: "Plastic",
        config: {
          color: "#ff0000",
          metalness: 0,
          roughness: 0.1
        }
      },
      {
        id: "matte_plastic",
        name: "Matte Plastic",
        category: "Plastic",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.8
        }
      },
      // Glass
      {
        id: "clear_glass",
        name: "Clear Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0,
          opacity: 0.2,
          transparent: true,
          envMapIntensity: 2
        }
      },
      {
        id: "frosted_glass",
        name: "Frosted Glass",
        category: "Glass",
        config: {
          color: "#ffffff",
          metalness: 0,
          roughness: 0.5,
          opacity: 0.5,
          transparent: true
        }
      },
      // Natural
      {
        id: "clay",
        name: "Clay",
        category: "Natural",
        config: {
          color: "#d4a574",
          metalness: 0,
          roughness: 0.9
        }
      },
      {
        id: "stone",
        name: "Stone",
        category: "Natural",
        config: {
          color: "#808080",
          metalness: 0,
          roughness: 0.7
        }
      },
      // Emissive
      {
        id: "neon_glow",
        name: "Neon Glow",
        category: "Emissive",
        config: {
          color: "#000000",
          emissive: "#00ffff",
          emissiveIntensity: 2,
          metalness: 0,
          roughness: 0.5
        }
      },
      {
        id: "hot_metal",
        name: "Hot Metal",
        category: "Emissive",
        config: {
          color: "#ff4400",
          emissive: "#ff2200",
          emissiveIntensity: 1,
          metalness: 0.8,
          roughness: 0.4
        }
      }
    ];
  }
  /**
   * Create material from preset
   */
  async createFromPreset(presetId, materialId, overrides) {
    const preset = MaterialSystem.getPresets().find((p) => p.id === presetId);
    if (!preset) {
      throw new Error(`Preset not found: ${presetId}`);
    }
    const config = {
      ...MaterialSystem.createDefaultConfig(materialId, preset.name),
      ...preset.config,
      ...overrides,
      id: materialId
    };
    return this.createPBRMaterial(config);
  }
  // ============================================================================
  // MATERIAL UPDATES
  // ============================================================================
  /**
   * Update an existing material's properties
   */
  updateMaterial(materialId, updates) {
    const material = this.materialCache.get(materialId);
    if (!material) return;
    if (updates.color !== void 0) {
      material.color.set(updates.color);
    }
    if (updates.metalness !== void 0) {
      material.metalness = updates.metalness;
    }
    if (updates.roughness !== void 0) {
      material.roughness = updates.roughness;
    }
    if (updates.opacity !== void 0) {
      material.opacity = updates.opacity;
    }
    if (updates.transparent !== void 0) {
      material.transparent = updates.transparent;
    }
    if (updates.emissive !== void 0) {
      material.emissive.set(updates.emissive);
    }
    if (updates.emissiveIntensity !== void 0) {
      material.emissiveIntensity = updates.emissiveIntensity;
    }
    if (updates.envMapIntensity !== void 0) {
      material.envMapIntensity = updates.envMapIntensity;
    }
    if (updates.normalScale !== void 0) {
      material.normalScale.set(updates.normalScale, updates.normalScale);
    }
    if (updates.wireframe !== void 0) {
      material.wireframe = updates.wireframe;
    }
    if (updates.flatShading !== void 0) {
      material.flatShading = updates.flatShading;
    }
    if (updates.side !== void 0) {
      material.side = this.getSide(updates.side);
    }
    material.needsUpdate = true;
  }
  /**
   * Get a cached material
   */
  getMaterial(materialId) {
    return this.materialCache.get(materialId);
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  /**
   * Dispose a material
   */
  disposeMaterial(materialId) {
    const material = this.materialCache.get(materialId);
    if (material) {
      material.dispose();
      this.materialCache.delete(materialId);
    }
  }
  /**
   * Dispose all resources
   */
  dispose() {
    for (const texture of this.textureCache.values()) {
      texture.dispose();
    }
    this.textureCache.clear();
    for (const material of this.materialCache.values()) {
      material.dispose();
    }
    this.materialCache.clear();
    if (this.envMap) {
      this.envMap.dispose();
      this.envMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
  }
}
const materialSystem = new MaterialSystem();

const useAssetStore = defineStore("assets", {
  state: () => ({
    // Materials
    materials: /* @__PURE__ */ new Map(),
    selectedMaterialId: null,
    // SVG Documents
    svgDocuments: /* @__PURE__ */ new Map(),
    selectedSvgId: null,
    // Mesh Particles
    meshParticles: /* @__PURE__ */ new Map(),
    selectedMeshParticleId: null,
    // Sprite Sheets
    spriteSheets: /* @__PURE__ */ new Map(),
    selectedSpriteSheetId: null,
    // Environment
    environment: {
      enabled: false,
      url: null,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true
    },
    environmentTexture: null,
    // Loading states
    isLoadingMaterial: false,
    isLoadingSvg: false,
    isLoadingMesh: false,
    isLoadingSpriteSheet: false,
    isLoadingEnvironment: false,
    // Error states
    lastError: null
  }),
  getters: {
    // Materials
    materialList: (state) => Array.from(state.materials.values()),
    selectedMaterial: (state) => state.selectedMaterialId ? state.materials.get(state.selectedMaterialId) ?? null : null,
    // SVG Documents
    svgDocumentList: (state) => Array.from(state.svgDocuments.values()),
    selectedSvgDocument: (state) => state.selectedSvgId ? state.svgDocuments.get(state.selectedSvgId) ?? null : null,
    // Mesh Particles
    meshParticleList: (state) => Array.from(state.meshParticles.values()),
    selectedMeshParticle: (state) => state.selectedMeshParticleId ? state.meshParticles.get(state.selectedMeshParticleId) ?? null : null,
    // Sprite Sheets
    spriteSheetList: (state) => Array.from(state.spriteSheets.values()),
    selectedSpriteSheet: (state) => state.selectedSpriteSheetId ? state.spriteSheets.get(state.selectedSpriteSheetId) ?? null : null,
    // Combined loading state
    isLoading: (state) => state.isLoadingMaterial || state.isLoadingSvg || state.isLoadingMesh || state.isLoadingSpriteSheet || state.isLoadingEnvironment
  },
  actions: {
    // ========================================================================
    // MATERIALS
    // ========================================================================
    /**
     * Create a new material from preset
     */
    createMaterialFromPreset(presetName, customName) {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const presetConfigs = {
        chrome: { color: "#ffffff", metalness: 1, roughness: 0.1 },
        gold: { color: "#ffd700", metalness: 1, roughness: 0.2 },
        silver: { color: "#c0c0c0", metalness: 1, roughness: 0.15 },
        copper: { color: "#b87333", metalness: 1, roughness: 0.3 },
        brass: { color: "#b5a642", metalness: 0.9, roughness: 0.25 },
        glass: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true },
        plastic: { color: "#ffffff", metalness: 0, roughness: 0.4 },
        rubber: { color: "#222222", metalness: 0, roughness: 0.9 },
        wood: { color: "#8b4513", metalness: 0, roughness: 0.7 },
        concrete: { color: "#808080", metalness: 0, roughness: 0.9 },
        emissive: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2 },
        holographic: { color: "#88ffff", metalness: 0.8, roughness: 0.2, emissive: "#ff00ff", emissiveIntensity: 0.5 }
      };
      const presetConfig = presetConfigs[presetName] || {};
      const config = this.createDefaultMaterialConfig(id, customName || presetName, presetConfig);
      const stored = {
        id,
        name: customName || presetName,
        config,
        presetName,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      storeLogger.debug("Created material from preset:", presetName, id);
      return id;
    },
    /**
     * Create a new empty material
     */
    createEmptyMaterial(name = "New Material") {
      const id = `mat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const config = this.createDefaultMaterialConfig(id, name);
      const stored = {
        id,
        name,
        config,
        createdAt: Date.now(),
        modifiedAt: Date.now()
      };
      this.materials.set(id, stored);
      this.selectedMaterialId = id;
      return id;
    },
    /**
     * Helper to create a full default material config
     */
    createDefaultMaterialConfig(id, name, overrides = {}) {
      return {
        id,
        name,
        color: "#ffffff",
        opacity: 1,
        transparent: false,
        metalness: 0,
        roughness: 0.5,
        envMapIntensity: 1,
        emissive: "#000000",
        emissiveIntensity: 0,
        normalScale: 1,
        displacementScale: 0,
        displacementBias: 0,
        aoMapIntensity: 1,
        maps: {},
        textureRepeat: { x: 1, y: 1 },
        textureOffset: { x: 0, y: 0 },
        textureRotation: 0,
        side: "front",
        flatShading: false,
        wireframe: false,
        depthWrite: true,
        depthTest: true,
        ...overrides
      };
    },
    /**
     * Update material configuration
     */
    updateMaterial(id, updates) {
      const stored = this.materials.get(id);
      if (!stored) return;
      stored.config = { ...stored.config, ...updates };
      stored.modifiedAt = Date.now();
      this.materials.set(id, stored);
    },
    /**
     * Set texture for material
     */
    async setMaterialTexture(materialId, textureType, file) {
      const stored = this.materials.get(materialId);
      if (!stored) return;
      this.isLoadingMaterial = true;
      try {
        const url = URL.createObjectURL(file);
        stored.config[textureType] = url;
        stored.modifiedAt = Date.now();
        this.materials.set(materialId, stored);
      } catch (error) {
        this.lastError = `Failed to load texture: ${error}`;
      } finally {
        this.isLoadingMaterial = false;
      }
    },
    /**
     * Delete a material
     */
    deleteMaterial(id) {
      this.materials.delete(id);
      if (this.selectedMaterialId === id) {
        this.selectedMaterialId = null;
      }
    },
    /**
     * Get Three.js material from stored config
     * Note: This creates a simple THREE.MeshStandardMaterial without async texture loading
     * For full PBR with textures, use materialSystem.createPBRMaterial()
     */
    getThreeMaterial(id) {
      const stored = this.materials.get(id);
      if (!stored) return null;
      const config = stored.config;
      const material = new MeshStandardMaterial({
        color: new Color(config.color),
        metalness: config.metalness,
        roughness: config.roughness,
        transparent: config.transparent,
        opacity: config.opacity,
        flatShading: config.flatShading,
        wireframe: config.wireframe,
        side: config.side === "double" ? DoubleSide : config.side === "back" ? BackSide : FrontSide
      });
      if (config.emissive && config.emissive !== "#000000") {
        material.emissive = new Color(config.emissive);
        material.emissiveIntensity = config.emissiveIntensity;
      }
      return material;
    },
    // ========================================================================
    // SVG DOCUMENTS
    // ========================================================================
    /**
     * Import SVG from file
     */
    async importSvgFromFile(file) {
      this.isLoadingSvg = true;
      try {
        const text = await file.text();
        const name = file.name.replace(/\.svg$/i, "");
        const document = svgExtrusionService.loadFromString(text, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          // baseDepth
          5,
          // depthIncrement between layers
          2
          // extrusionDepth per layer
        );
        const id = document.id;
        const stored = {
          id,
          name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        storeLogger.debug("Imported SVG:", name, `${document.paths.length} paths`);
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Import SVG from URL
     */
    async importSvgFromUrl(url, name) {
      this.isLoadingSvg = true;
      try {
        const document = await svgExtrusionService.loadFromURL(url, name);
        const layerConfigs = svgExtrusionService.generateAutoLayerConfigs(
          document,
          0,
          5,
          2
        );
        const id = document.id;
        const stored = {
          id,
          name: document.name,
          document,
          layerConfigs,
          createdAt: Date.now()
        };
        this.svgDocuments.set(id, stored);
        this.selectedSvgId = id;
        return { success: true, assetId: id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `SVG import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSvg = false;
      }
    },
    /**
     * Update layer config for an SVG path
     */
    updateSvgLayerConfig(svgId, pathIndex, config) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.layerConfigs.length) return;
      stored.layerConfigs[pathIndex] = { ...stored.layerConfigs[pathIndex], ...config };
      this.svgDocuments.set(svgId, stored);
    },
    /**
     * Get extruded geometries for all paths in an SVG
     */
    getExtrudedGeometries(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return [];
      return stored.document.paths.map((path, i) => {
        const config = stored.layerConfigs[i];
        return svgExtrusionService.createExtrudedGeometry(path, {
          depth: config.extrusionDepth
        });
      });
    },
    /**
     * Create a Three.js Group with all extruded SVG paths
     */
    createExtrudedGroup(svgId) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored) return null;
      return svgExtrusionService.createLayeredMeshes(
        stored.document,
        stored.layerConfigs
      );
    },
    /**
     * Delete an SVG document
     */
    deleteSvgDocument(id) {
      this.svgDocuments.delete(id);
      if (this.selectedSvgId === id) {
        this.selectedSvgId = null;
      }
    },
    // ========================================================================
    // MESH PARTICLES
    // ========================================================================
    /**
     * Register a primitive shape as mesh particle
     */
    registerPrimitiveMesh(type, name, size = 1) {
      const registration = meshParticleManager.registerPrimitive(type, name, size);
      const stored = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "primitive"
      };
      this.meshParticles.set(registration.id, stored);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Register an SVG path as mesh particle
     */
    registerSvgPathAsMesh(svgId, pathIndex, name, options) {
      const stored = this.svgDocuments.get(svgId);
      if (!stored || pathIndex >= stored.document.paths.length) return null;
      const path = stored.document.paths[pathIndex];
      const registration = meshParticleManager.registerFromSVG(
        svgId,
        path.id,
        name || `${stored.name}_${pathIndex}`,
        options
      );
      if (!registration) return null;
      const storedMesh = {
        id: registration.id,
        name: registration.name,
        registration,
        source: "svg",
        sourceId: path.id
      };
      this.meshParticles.set(registration.id, storedMesh);
      this.selectedMeshParticleId = registration.id;
      return registration.id;
    },
    /**
     * Get emitter config for mesh-based emission
     */
    getMeshEmitterConfig(meshId) {
      return meshParticleManager.getEmitterShapeConfig(meshId);
    },
    /**
     * Create instanced mesh for particle rendering
     */
    createInstancedMesh(meshId, maxInstances, materialId) {
      const material = materialId ? this.getThreeMaterial(materialId) : void 0;
      const result = meshParticleManager.createInstancedMesh(meshId, maxInstances, material || void 0);
      return result?.mesh || null;
    },
    /**
     * Delete a mesh particle
     */
    deleteMeshParticle(id) {
      meshParticleManager.unregisterMesh(id);
      this.meshParticles.delete(id);
      if (this.selectedMeshParticleId === id) {
        this.selectedMeshParticleId = null;
      }
    },
    // ========================================================================
    // SPRITE SHEETS
    // ========================================================================
    /**
     * Import sprite sheet from file
     */
    async importSpriteSheet(file, columns, rows, options) {
      this.isLoadingSpriteSheet = true;
      try {
        const url = URL.createObjectURL(file);
        const config = await spriteSheetService.loadFromGrid(url, columns, rows, {
          name: options?.name || file.name.replace(/\.[^.]+$/, ""),
          frameRate: options?.frameRate
        });
        const stored = {
          id: config.id,
          name: config.name || config.id,
          config,
          textureUrl: url
        };
        this.spriteSheets.set(config.id, stored);
        this.selectedSpriteSheetId = config.id;
        return { success: true, assetId: config.id };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Sprite sheet import failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingSpriteSheet = false;
      }
    },
    /**
     * Add animation to sprite sheet
     */
    addSpriteAnimation(sheetId, name, frames, options) {
      spriteSheetService.addAnimation(sheetId, {
        name,
        frames,
        frameRate: options?.frameRate ?? 24,
        loop: options?.loop ?? true,
        pingPong: options?.pingPong ?? false
      });
    },
    /**
     * Get particle texture config for GPU particles
     */
    getParticleTextureConfig(sheetId) {
      return spriteSheetService.getParticleTextureConfig(sheetId);
    },
    /**
     * Delete a sprite sheet
     */
    deleteSpriteSheet(id) {
      const stored = this.spriteSheets.get(id);
      if (stored?.textureUrl) {
        URL.revokeObjectURL(stored.textureUrl);
      }
      spriteSheetService.removeSheet(id);
      this.spriteSheets.delete(id);
      if (this.selectedSpriteSheetId === id) {
        this.selectedSpriteSheetId = null;
      }
    },
    // ========================================================================
    // ENVIRONMENT
    // ========================================================================
    /**
     * Load HDRI environment map
     */
    async loadEnvironment(file, options) {
      this.isLoadingEnvironment = true;
      try {
        const url = URL.createObjectURL(file);
        this.environment = {
          ...this.environment,
          url,
          intensity: options?.intensity ?? this.environment.intensity,
          rotation: options?.rotation ?? this.environment.rotation,
          useAsBackground: options?.useAsBackground ?? this.environment.useAsBackground,
          enabled: true
        };
        storeLogger.debug("Environment loaded:", file.name);
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Load environment from preset URL
     */
    async loadEnvironmentPreset(presetUrl, presetName) {
      this.isLoadingEnvironment = true;
      try {
        this.environment = {
          ...this.environment,
          url: presetUrl,
          presetName,
          enabled: true
        };
        return { success: true };
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.lastError = `Environment preset load failed: ${message}`;
        return { success: false, error: message };
      } finally {
        this.isLoadingEnvironment = false;
      }
    },
    /**
     * Update environment settings
     */
    updateEnvironment(settings) {
      this.environment = { ...this.environment, ...settings };
    },
    /**
     * Clear environment
     */
    clearEnvironment() {
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      this.environment = {
        enabled: false,
        url: null,
        intensity: 1,
        rotation: 0,
        backgroundBlur: 0,
        useAsBackground: true
      };
      this.environmentTexture = null;
    },
    // ========================================================================
    // UTILITIES
    // ========================================================================
    /**
     * Clear last error
     */
    clearError() {
      this.lastError = null;
    },
    /**
     * Dispose all assets and free resources
     */
    dispose() {
      for (const stored of this.materials.values()) {
        for (const key of Object.keys(stored.config)) {
          const value = stored.config[key];
          if (typeof value === "string" && value.startsWith("blob:")) {
            URL.revokeObjectURL(value);
          }
        }
      }
      for (const stored of this.spriteSheets.values()) {
        if (stored.textureUrl.startsWith("blob:")) {
          URL.revokeObjectURL(stored.textureUrl);
        }
      }
      if (this.environment.url && !this.environment.presetName) {
        URL.revokeObjectURL(this.environment.url);
      }
      svgExtrusionService.dispose();
      meshParticleManager.dispose();
      spriteSheetService.dispose();
      materialSystem.dispose();
      this.materials.clear();
      this.svgDocuments.clear();
      this.meshParticles.clear();
      this.spriteSheets.clear();
      this.selectedMaterialId = null;
      this.selectedSvgId = null;
      this.selectedMeshParticleId = null;
      this.selectedSpriteSheetId = null;
      this.clearEnvironment();
    }
  }
});

const _hoisted_1$n = {
  key: 0,
  class: "texture-preview"
};
const _hoisted_2$n = ["src", "alt"];
const _hoisted_3$n = { class: "texture-info" };
const _hoisted_4$n = { class: "texture-name" };
const _hoisted_5$n = { class: "texture-size" };
const _hoisted_6$n = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_7$n = { class: "map-label" };
const _hoisted_8$n = {
  key: 0,
  class: "texture-settings"
};
const _hoisted_9$n = { class: "setting-row" };
const _hoisted_10$n = { class: "repeat-inputs" };
const _hoisted_11$m = { class: "setting-row" };
const _hoisted_12$k = { class: "offset-inputs" };
const _hoisted_13$k = {
  key: 0,
  class: "setting-row"
};
const acceptedFormats = "image/png,image/jpeg,image/webp,image/exr";
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "TextureUpload",
  props: {
    mapType: {},
    textureUrl: {},
    textureName: {},
    repeatX: {},
    repeatY: {},
    offsetX: {},
    offsetY: {},
    normalScale: {},
    showSettings: { type: Boolean }
  },
  emits: ["upload", "remove", "update:repeatX", "update:repeatY", "update:offsetX", "update:offsetY", "update:normalScale"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const previewUrl = ref(props.textureUrl || "");
    const textureSize = ref("");
    const mapLabels = {
      albedo: "Albedo / Color",
      normal: "Normal Map",
      roughness: "Roughness",
      metalness: "Metalness",
      ao: "Ambient Occlusion",
      emissive: "Emissive",
      height: "Height / Displacement",
      opacity: "Opacity / Alpha",
      specular: "Specular"
    };
    const mapLabel = computed(() => mapLabels[props.mapType] || props.mapType);
    const hasTexture = computed(() => !!previewUrl.value || !!props.textureUrl);
    function openFilePicker() {
      fileInput.value?.click();
    }
    function onDragOver(e) {
      isDragging.value = true;
    }
    function onDragLeave(e) {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        handleFile(files[0]);
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        handleFile(input.files[0]);
      }
    }
    function handleFile(file) {
      if (!file.type.startsWith("image/")) {
        console.warn("Invalid file type:", file.type);
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target?.result;
        previewUrl.value = dataUrl;
        const img = new Image();
        img.onload = () => {
          textureSize.value = `${img.width} x ${img.height}`;
        };
        img.src = dataUrl;
        emit("upload", file, dataUrl);
      };
      reader.readAsDataURL(file);
    }
    function removeTexture() {
      previewUrl.value = "";
      textureSize.value = "";
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["texture-upload", { "has-texture": hasTexture.value, "drag-over": isDragging.value }])
      }, [
        createBaseVNode("div", {
          class: "upload-zone",
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasTexture.value ? (openBlock(), createElementBlock("div", _hoisted_1$n, [
            createBaseVNode("img", {
              src: previewUrl.value,
              alt: __props.mapType
            }, null, 8, _hoisted_2$n),
            createBaseVNode("div", _hoisted_3$n, [
              createBaseVNode("span", _hoisted_4$n, toDisplayString(__props.textureName), 1),
              createBaseVNode("span", _hoisted_5$n, toDisplayString(textureSize.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeTexture, ["stop"]),
              title: "Remove texture"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_6$n, [
            _cache[6] || (_cache[6] = createBaseVNode("i", { class: "pi pi-image" }, null, -1)),
            createBaseVNode("span", _hoisted_7$n, toDisplayString(mapLabel.value), 1),
            _cache[7] || (_cache[7] = createBaseVNode("span", { class: "hint" }, "Click or drop image", -1))
          ]))
        ], 32),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 544),
        hasTexture.value && __props.showSettings ? (openBlock(), createElementBlock("div", _hoisted_8$n, [
          createBaseVNode("div", _hoisted_9$n, [
            _cache[9] || (_cache[9] = createBaseVNode("label", null, "Repeat", -1)),
            createBaseVNode("div", _hoisted_10$n, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatX,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:repeatX", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"]),
              _cache[8] || (_cache[8] = createBaseVNode("span", { class: "separator" }, "x", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.repeatY,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:repeatY", $event)),
                min: 0.01,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$m, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Offset", -1)),
            createBaseVNode("div", _hoisted_12$k, [
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetX,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:offsetX", $event)),
                step: 0.01
              }, null, 8, ["modelValue"]),
              _cache[10] || (_cache[10] = createBaseVNode("span", { class: "separator" }, ",", -1)),
              createVNode(unref(ScrubableNumber), {
                modelValue: __props.offsetY,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:offsetY", $event)),
                step: 0.01
              }, null, 8, ["modelValue"])
            ])
          ]),
          __props.mapType === "normal" ? (openBlock(), createElementBlock("div", _hoisted_13$k, [
            _cache[12] || (_cache[12] = createBaseVNode("label", null, "Strength", -1)),
            createVNode(unref(SliderInput), {
              modelValue: __props.normalScale,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:normalScale", $event)),
              min: 0,
              max: 2,
              step: 0.1
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

const TextureUpload = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-fccc4721"]]);

const _hoisted_1$m = { class: "material-editor" };
const _hoisted_2$m = { class: "editor-header" };
const _hoisted_3$m = ["value"];
const _hoisted_4$m = { class: "property-section" };
const _hoisted_5$m = { class: "section-content" };
const _hoisted_6$m = { class: "property-group" };
const _hoisted_7$m = { class: "property-group" };
const _hoisted_8$m = { class: "property-group" };
const _hoisted_9$m = { class: "property-group" };
const _hoisted_10$m = { class: "property-row checkbox-row" };
const _hoisted_11$l = ["checked"];
const _hoisted_12$j = { class: "property-section" };
const _hoisted_13$j = { class: "section-content" };
const _hoisted_14$i = { class: "property-group" };
const _hoisted_15$h = { class: "property-group" };
const _hoisted_16$g = { class: "property-section" };
const _hoisted_17$f = { class: "section-content" };
const _hoisted_18$e = { class: "texture-grid" };
const _hoisted_19$e = {
  key: 0,
  class: "texture-global-settings"
};
const _hoisted_20$e = { class: "setting-row" };
const _hoisted_21$e = { class: "repeat-inputs" };
const _hoisted_22$e = { class: "property-section" };
const _hoisted_23$e = { class: "section-content" };
const _hoisted_24$b = { class: "property-group" };
const _hoisted_25$a = { class: "property-row checkbox-row" };
const _hoisted_26$9 = ["checked"];
const _hoisted_27$8 = { class: "property-row checkbox-row" };
const _hoisted_28$8 = ["checked"];
const _hoisted_29$8 = { class: "property-row" };
const _hoisted_30$7 = ["value"];
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "MaterialEditor",
  props: {
    modelValue: {},
    layerId: {},
    materialId: {},
    config: {}
  },
  emits: ["update:modelValue", "save-preset", "update", "texture-upload"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultMaterial = {
      color: "#ffffff",
      metalness: 0,
      roughness: 0.5,
      opacity: 1,
      transparent: false,
      emissive: "#000000",
      emissiveIntensity: 0,
      normalScale: 1,
      envMapIntensity: 1,
      flatShading: false,
      wireframe: false,
      side: "front",
      maps: {},
      textureRepeat: { x: 1, y: 1 }
    };
    const presets = [
      {
        id: "chrome",
        name: "Chrome",
        config: { color: "#ffffff", metalness: 1, roughness: 0.1 }
      },
      {
        id: "gold",
        name: "Gold",
        config: { color: "#ffd700", metalness: 1, roughness: 0.2 }
      },
      {
        id: "copper",
        name: "Copper",
        config: { color: "#b87333", metalness: 1, roughness: 0.3 }
      },
      {
        id: "plastic",
        name: "Plastic",
        config: { color: "#ffffff", metalness: 0, roughness: 0.4 }
      },
      {
        id: "rubber",
        name: "Rubber",
        config: { color: "#222222", metalness: 0, roughness: 0.9 }
      },
      {
        id: "glass",
        name: "Glass",
        config: { color: "#ffffff", metalness: 0, roughness: 0.1, opacity: 0.3, transparent: true }
      },
      {
        id: "emissive",
        name: "Emissive",
        config: { color: "#ffffff", emissive: "#00aaff", emissiveIntensity: 2, metalness: 0, roughness: 0.5 }
      },
      {
        id: "matte",
        name: "Matte",
        config: { color: "#cccccc", metalness: 0, roughness: 1 }
      }
    ];
    const material = reactive({ ...defaultMaterial, ...props.modelValue, ...props.config });
    const selectedPreset = ref("");
    const sections = reactive({
      basic: true,
      emissive: false,
      textures: true,
      environment: false
    });
    const hasAnyTexture = computed(() => {
      return Object.values(material.maps).some((url) => !!url);
    });
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(material, { ...defaultMaterial, ...newVal });
      }
    }, { deep: true });
    function toggleSection(section) {
      sections[section] = !sections[section];
    }
    function updateMaterial(key, value) {
      material[key] = value;
      selectedPreset.value = "";
      emitUpdate();
    }
    function updateTextureRepeat(axis, value) {
      material.textureRepeat[axis] = value;
      emitUpdate();
    }
    function uploadTexture(mapType, file, dataUrl) {
      material.maps[mapType] = dataUrl;
      emitUpdate();
      emit("texture-upload", mapType, file);
    }
    function removeTexture(mapType) {
      delete material.maps[mapType];
      emitUpdate();
    }
    function applyPreset() {
      if (!selectedPreset.value) return;
      const preset = presets.find((p) => p.id === selectedPreset.value);
      if (preset) {
        Object.assign(material, { ...defaultMaterial, ...preset.config });
        emitUpdate();
      }
    }
    function resetMaterial() {
      Object.assign(material, defaultMaterial);
      selectedPreset.value = "";
      emitUpdate();
    }
    function saveMaterial() {
      const name = prompt("Enter preset name:");
      if (name) {
        emit("save-preset", name, { ...material });
      }
    }
    function emitUpdate() {
      emit("update:modelValue", { ...material });
      emit("update", { ...material });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$m, [
          _cache[36] || (_cache[36] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-palette" }),
            createBaseVNode("span", null, "Material")
          ], -1)),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
            onChange: applyPreset,
            class: "preset-select"
          }, [
            _cache[35] || (_cache[35] = createBaseVNode("option", { value: "" }, "Custom", -1)),
            (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
              return createBaseVNode("option", {
                key: preset.id,
                value: preset.id
              }, toDisplayString(preset.name), 9, _hoisted_3$m);
            }), 64))
          ], 544), [
            [vModelSelect, selectedPreset.value]
          ])
        ]),
        createBaseVNode("div", _hoisted_4$m, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[1] || (_cache[1] = ($event) => toggleSection("basic"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.basic ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[37] || (_cache[37] = createBaseVNode("span", null, "Basic Properties", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_5$m, [
            createBaseVNode("div", _hoisted_6$m, [
              _cache[38] || (_cache[38] = createBaseVNode("label", null, "Base Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.color,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateMaterial("color", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_7$m, [
              _cache[39] || (_cache[39] = createBaseVNode("label", null, "Metalness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.metalness,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateMaterial("metalness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_8$m, [
              _cache[40] || (_cache[40] = createBaseVNode("label", null, "Roughness", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.roughness,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => updateMaterial("roughness", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_9$m, [
              _cache[41] || (_cache[41] = createBaseVNode("label", null, "Opacity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.opacity,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateMaterial("opacity", $event)),
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_10$m, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.transparent,
                  onChange: _cache[6] || (_cache[6] = ($event) => updateMaterial("transparent", $event.target.checked))
                }, null, 40, _hoisted_11$l),
                _cache[42] || (_cache[42] = createTextVNode(" Transparent ", -1))
              ])
            ])
          ], 512), [
            [vShow, sections.basic]
          ])
        ]),
        createBaseVNode("div", _hoisted_12$j, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[7] || (_cache[7] = ($event) => toggleSection("emissive"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.emissive ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[43] || (_cache[43] = createBaseVNode("span", null, "Emissive", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_13$j, [
            createBaseVNode("div", _hoisted_14$i, [
              _cache[44] || (_cache[44] = createBaseVNode("label", null, "Emissive Color", -1)),
              createVNode(unref(ColorPicker), {
                modelValue: material.emissive,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => updateMaterial("emissive", $event))
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_15$h, [
              _cache[45] || (_cache[45] = createBaseVNode("label", null, "Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.emissiveIntensity,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => updateMaterial("emissiveIntensity", $event)),
                min: 0,
                max: 5,
                step: 0.1
              }, null, 8, ["modelValue"])
            ])
          ], 512), [
            [vShow, sections.emissive]
          ])
        ]),
        createBaseVNode("div", _hoisted_16$g, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[10] || (_cache[10] = ($event) => toggleSection("textures"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.textures ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[46] || (_cache[46] = createBaseVNode("span", null, "Texture Maps", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_17$f, [
            createBaseVNode("div", _hoisted_18$e, [
              createVNode(TextureUpload, {
                mapType: "albedo",
                textureUrl: material.maps?.albedo,
                onUpload: _cache[11] || (_cache[11] = (file, dataUrl) => uploadTexture("albedo", file, dataUrl)),
                onRemove: _cache[12] || (_cache[12] = ($event) => removeTexture("albedo"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "normal",
                textureUrl: material.maps?.normal,
                normalScale: material.normalScale,
                showSettings: !!material.maps?.normal,
                onUpload: _cache[13] || (_cache[13] = (file, dataUrl) => uploadTexture("normal", file, dataUrl)),
                onRemove: _cache[14] || (_cache[14] = ($event) => removeTexture("normal")),
                "onUpdate:normalScale": _cache[15] || (_cache[15] = ($event) => updateMaterial("normalScale", $event))
              }, null, 8, ["textureUrl", "normalScale", "showSettings"]),
              createVNode(TextureUpload, {
                mapType: "roughness",
                textureUrl: material.maps?.roughness,
                onUpload: _cache[16] || (_cache[16] = (file, dataUrl) => uploadTexture("roughness", file, dataUrl)),
                onRemove: _cache[17] || (_cache[17] = ($event) => removeTexture("roughness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "metalness",
                textureUrl: material.maps?.metalness,
                onUpload: _cache[18] || (_cache[18] = (file, dataUrl) => uploadTexture("metalness", file, dataUrl)),
                onRemove: _cache[19] || (_cache[19] = ($event) => removeTexture("metalness"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "ao",
                textureUrl: material.maps?.ao,
                onUpload: _cache[20] || (_cache[20] = (file, dataUrl) => uploadTexture("ao", file, dataUrl)),
                onRemove: _cache[21] || (_cache[21] = ($event) => removeTexture("ao"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "emissive",
                textureUrl: material.maps?.emissive,
                onUpload: _cache[22] || (_cache[22] = (file, dataUrl) => uploadTexture("emissive", file, dataUrl)),
                onRemove: _cache[23] || (_cache[23] = ($event) => removeTexture("emissive"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "height",
                textureUrl: material.maps?.height,
                onUpload: _cache[24] || (_cache[24] = (file, dataUrl) => uploadTexture("height", file, dataUrl)),
                onRemove: _cache[25] || (_cache[25] = ($event) => removeTexture("height"))
              }, null, 8, ["textureUrl"]),
              createVNode(TextureUpload, {
                mapType: "opacity",
                textureUrl: material.maps?.opacity,
                onUpload: _cache[26] || (_cache[26] = (file, dataUrl) => uploadTexture("opacity", file, dataUrl)),
                onRemove: _cache[27] || (_cache[27] = ($event) => removeTexture("opacity"))
              }, null, 8, ["textureUrl"])
            ]),
            hasAnyTexture.value ? (openBlock(), createElementBlock("div", _hoisted_19$e, [
              createBaseVNode("div", _hoisted_20$e, [
                _cache[48] || (_cache[48] = createBaseVNode("label", null, "UV Repeat", -1)),
                createBaseVNode("div", _hoisted_21$e, [
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.x ?? 1,
                    "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => updateTextureRepeat("x", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"]),
                  _cache[47] || (_cache[47] = createBaseVNode("span", { class: "separator" }, "x", -1)),
                  createVNode(unref(ScrubableNumber), {
                    modelValue: material.textureRepeat?.y ?? 1,
                    "onUpdate:modelValue": _cache[29] || (_cache[29] = ($event) => updateTextureRepeat("y", $event)),
                    min: 0.01,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ])
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, sections.textures]
          ])
        ]),
        createBaseVNode("div", _hoisted_22$e, [
          createBaseVNode("div", {
            class: "section-header",
            onClick: _cache[30] || (_cache[30] = ($event) => toggleSection("environment"))
          }, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", sections.environment ? "pi-chevron-down" : "pi-chevron-right"])
            }, null, 2),
            _cache[49] || (_cache[49] = createBaseVNode("span", null, "Environment", -1))
          ]),
          withDirectives(createBaseVNode("div", _hoisted_23$e, [
            createBaseVNode("div", _hoisted_24$b, [
              _cache[50] || (_cache[50] = createBaseVNode("label", null, "Environment Intensity", -1)),
              createVNode(unref(SliderInput), {
                modelValue: material.envMapIntensity,
                "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => updateMaterial("envMapIntensity", $event)),
                min: 0,
                max: 3,
                step: 0.1
              }, null, 8, ["modelValue"])
            ]),
            createBaseVNode("div", _hoisted_25$a, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.flatShading,
                  onChange: _cache[32] || (_cache[32] = ($event) => updateMaterial("flatShading", $event.target.checked))
                }, null, 40, _hoisted_26$9),
                _cache[51] || (_cache[51] = createTextVNode(" Flat Shading ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_27$8, [
              createBaseVNode("label", null, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: material.wireframe,
                  onChange: _cache[33] || (_cache[33] = ($event) => updateMaterial("wireframe", $event.target.checked))
                }, null, 40, _hoisted_28$8),
                _cache[52] || (_cache[52] = createTextVNode(" Wireframe ", -1))
              ])
            ]),
            createBaseVNode("div", _hoisted_29$8, [
              _cache[54] || (_cache[54] = createBaseVNode("label", null, "Side", -1)),
              createBaseVNode("select", {
                value: material.side,
                onChange: _cache[34] || (_cache[34] = ($event) => updateMaterial("side", $event.target.value)),
                class: "type-select"
              }, [..._cache[53] || (_cache[53] = [
                createBaseVNode("option", { value: "front" }, "Front", -1),
                createBaseVNode("option", { value: "back" }, "Back", -1),
                createBaseVNode("option", { value: "double" }, "Double", -1)
              ])], 40, _hoisted_30$7)
            ])
          ], 512), [
            [vShow, sections.environment]
          ])
        ]),
        createBaseVNode("div", { class: "editor-actions" }, [
          createBaseVNode("button", {
            class: "action-btn",
            onClick: resetMaterial
          }, [..._cache[55] || (_cache[55] = [
            createBaseVNode("i", { class: "pi pi-refresh" }, null, -1),
            createTextVNode(" Reset ", -1)
          ])]),
          createBaseVNode("button", {
            class: "action-btn primary",
            onClick: saveMaterial
          }, [..._cache[56] || (_cache[56] = [
            createBaseVNode("i", { class: "pi pi-save" }, null, -1),
            createTextVNode(" Save as Preset ", -1)
          ])])
        ])
      ]);
    };
  }
});

const MaterialEditor = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-1b454841"]]);

const _hoisted_1$l = { class: "asset-uploader" };
const _hoisted_2$l = {
  key: 0,
  class: "asset-preview"
};
const _hoisted_3$l = { class: "preview-content" };
const _hoisted_4$l = ["src"];
const _hoisted_5$l = {
  key: 1,
  class: "preview-icon"
};
const _hoisted_6$l = { class: "asset-info" };
const _hoisted_7$l = { class: "asset-name" };
const _hoisted_8$l = { class: "asset-meta" };
const _hoisted_9$l = {
  key: 1,
  class: "upload-placeholder"
};
const _hoisted_10$l = { class: "upload-label" };
const _hoisted_11$k = { class: "upload-hint" };
const _hoisted_12$i = { class: "upload-formats" };
const _hoisted_13$i = ["accept", "multiple"];
const _hoisted_14$h = {
  key: 0,
  class: "upload-progress"
};
const _hoisted_15$g = { class: "progress-bar" };
const _hoisted_16$f = { class: "progress-text" };
const _hoisted_17$e = {
  key: 1,
  class: "error-message"
};
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "AssetUploader",
  props: {
    assetType: { default: "image" },
    label: {},
    multiple: { type: Boolean, default: false },
    maxSizeMB: { default: 100 },
    accept: {},
    buttonText: {}
  },
  emits: ["upload", "upload-multiple", "remove", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const fileInput = ref(null);
    const isDragging = ref(false);
    const isLoading = ref(false);
    const progress = ref(0);
    const progressText = ref("");
    const errorMessage = ref("");
    const assetName = ref("");
    const assetMeta = ref("");
    const previewImage = ref(null);
    const hasAsset = ref(false);
    const assetConfigs = {
      model: {
        formats: [".gltf", ".glb", ".obj", ".fbx", ".dae", ".usdz"],
        icon: "pi-box",
        hint: "Drop 3D model file"
      },
      pointcloud: {
        formats: [".ply", ".pcd", ".xyz", ".pts", ".las"],
        icon: "pi-th-large",
        hint: "Drop point cloud file"
      },
      texture: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".exr", ".hdr"],
        icon: "pi-image",
        hint: "Drop texture image"
      },
      material: {
        formats: [".json", ".mtl"],
        icon: "pi-palette",
        hint: "Drop material file"
      },
      hdri: {
        formats: [".hdr", ".exr", ".jpg", ".png"],
        icon: "pi-globe",
        hint: "Drop HDRI environment"
      },
      svg: {
        formats: [".svg"],
        icon: "pi-star",
        hint: "Drop SVG file"
      },
      spritesheet: {
        formats: [".png", ".jpg", ".webp", ".json"],
        icon: "pi-th-large",
        hint: "Drop sprite sheet"
      },
      lut: {
        formats: [".cube", ".3dl", ".png"],
        icon: "pi-sliders-h",
        hint: "Drop LUT file"
      },
      depth_map: {
        formats: [".png", ".jpg", ".exr"],
        icon: "pi-map",
        hint: "Drop depth map"
      },
      image: {
        formats: [".png", ".jpg", ".jpeg", ".webp", ".gif"],
        icon: "pi-image",
        hint: "Drop image file"
      },
      video: {
        formats: [".mp4", ".webm", ".mov"],
        icon: "pi-video",
        hint: "Drop video file"
      },
      audio: {
        formats: [".mp3", ".wav", ".ogg", ".m4a"],
        icon: "pi-volume-up",
        hint: "Drop audio file"
      }
    };
    const config = computed(() => assetConfigs[props.assetType] || assetConfigs.image);
    const acceptedFormats = computed(() => {
      if (props.accept) {
        return props.accept;
      }
      const formats = config.value.formats;
      return formats.map((f) => {
        if (f === ".jpg") return "image/jpeg";
        if (f === ".png") return "image/png";
        if (f === ".webp") return "image/webp";
        if (f === ".gif") return "image/gif";
        if (f === ".svg") return "image/svg+xml";
        if (f === ".mp4") return "video/mp4";
        if (f === ".webm") return "video/webm";
        if (f === ".mp3") return "audio/mpeg";
        if (f === ".wav") return "audio/wav";
        if (f === ".ogg") return "audio/ogg";
        return f;
      }).join(",");
    });
    const acceptedFormatsDisplay = computed(() => {
      return config.value.formats.join(", ");
    });
    const placeholderIcon = computed(() => config.value.icon);
    const hint = computed(() => config.value.hint);
    const label = computed(() => props.buttonText || props.label || `Upload ${props.assetType}`);
    const assetTypeIcon = computed(() => {
      return config.value.icon;
    });
    function openFilePicker() {
      if (hasAsset.value) return;
      fileInput.value?.click();
    }
    function onDragOver() {
      isDragging.value = true;
    }
    function onDragLeave() {
      isDragging.value = false;
    }
    function onDrop(e) {
      isDragging.value = false;
      const files = e.dataTransfer?.files;
      if (files && files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(files));
        } else {
          handleFile(files[0]);
        }
      }
    }
    function onFileSelected(e) {
      const input = e.target;
      if (input.files && input.files.length > 0) {
        if (props.multiple) {
          handleMultipleFiles(Array.from(input.files));
        } else {
          handleFile(input.files[0]);
        }
      }
    }
    async function handleFile(file) {
      errorMessage.value = "";
      const sizeMB = file.size / (1024 * 1024);
      if (sizeMB > props.maxSizeMB) {
        errorMessage.value = `File too large (max ${props.maxSizeMB}MB)`;
        emit("error", errorMessage.value);
        return;
      }
      const ext = "." + file.name.split(".").pop()?.toLowerCase();
      const validFormats = props.accept ? props.accept.split(",").map((f) => f.trim().toLowerCase()) : config.value.formats;
      const isValidExt = validFormats.some((f) => f === ext || f.includes("*") || f.includes("/"));
      if (!isValidExt && !props.accept) {
        errorMessage.value = `Invalid format. Accepted: ${acceptedFormatsDisplay.value}`;
        emit("error", errorMessage.value);
        return;
      }
      const mimeTypeMap = {
        ".png": ["image/png"],
        ".jpg": ["image/jpeg"],
        ".jpeg": ["image/jpeg"],
        ".gif": ["image/gif"],
        ".webp": ["image/webp"],
        ".svg": ["image/svg+xml"],
        ".mp4": ["video/mp4"],
        ".webm": ["video/webm"],
        ".mov": ["video/quicktime"],
        ".mp3": ["audio/mpeg"],
        ".wav": ["audio/wav", "audio/wave", "audio/x-wav"],
        ".json": ["application/json"],
        ".ttf": ["font/ttf", "application/x-font-ttf"],
        ".otf": ["font/otf", "application/x-font-otf"],
        ".woff": ["font/woff", "application/font-woff"],
        ".woff2": ["font/woff2", "application/font-woff2"]
      };
      const expectedMimes = mimeTypeMap[ext];
      if (expectedMimes && file.type && !expectedMimes.includes(file.type) && !file.type.includes("octet-stream")) {
        errorMessage.value = `File type mismatch: expected ${expectedMimes.join(" or ")}, got ${file.type}`;
        emit("error", errorMessage.value);
        return;
      }
      isLoading.value = true;
      progress.value = 0;
      progressText.value = "Loading...";
      try {
        let dataUrl;
        if (file.type.startsWith("image/")) {
          dataUrl = await readFileAsDataUrl(file);
          previewImage.value = dataUrl;
        } else {
          previewImage.value = null;
        }
        assetName.value = file.name;
        assetMeta.value = formatFileSize(file.size);
        hasAsset.value = true;
        emit("upload", file, dataUrl);
      } catch (err) {
        errorMessage.value = "Failed to load file";
        emit("error", errorMessage.value);
      } finally {
        isLoading.value = false;
      }
    }
    function handleMultipleFiles(files) {
      const validFiles = files.filter((file) => {
        const ext = "." + file.name.split(".").pop()?.toLowerCase();
        const sizeMB = file.size / (1024 * 1024);
        return config.value.formats.includes(ext) && sizeMB <= props.maxSizeMB;
      });
      if (validFiles.length === 0) {
        errorMessage.value = "No valid files found";
        emit("error", errorMessage.value);
        return;
      }
      emit("upload-multiple", validFiles);
      assetName.value = `${validFiles.length} files`;
      assetMeta.value = formatFileSize(validFiles.reduce((sum, f) => sum + f.size, 0));
      hasAsset.value = true;
    }
    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.onprogress = (e) => {
          if (e.lengthComputable) {
            progress.value = Math.round(e.loaded / e.total * 100);
            progressText.value = `${progress.value}%`;
          }
        };
        reader.readAsDataURL(file);
      });
    }
    function formatFileSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
    function removeAsset() {
      hasAsset.value = false;
      assetName.value = "";
      assetMeta.value = "";
      previewImage.value = null;
      if (fileInput.value) {
        fileInput.value.value = "";
      }
      emit("remove");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createBaseVNode("div", {
          class: normalizeClass(["drop-zone", { "drag-over": isDragging.value, "has-asset": hasAsset.value }]),
          onClick: openFilePicker,
          onDragover: withModifiers(onDragOver, ["prevent"]),
          onDragleave: withModifiers(onDragLeave, ["prevent"]),
          onDrop: withModifiers(onDrop, ["prevent"])
        }, [
          hasAsset.value ? (openBlock(), createElementBlock("div", _hoisted_2$l, [
            createBaseVNode("div", _hoisted_3$l, [
              previewImage.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: previewImage.value,
                class: "preview-image"
              }, null, 8, _hoisted_4$l)) : (openBlock(), createElementBlock("div", _hoisted_5$l, [
                createBaseVNode("i", {
                  class: normalizeClass(["pi", assetTypeIcon.value])
                }, null, 2)
              ]))
            ]),
            createBaseVNode("div", _hoisted_6$l, [
              createBaseVNode("span", _hoisted_7$l, toDisplayString(assetName.value), 1),
              createBaseVNode("span", _hoisted_8$l, toDisplayString(assetMeta.value), 1)
            ]),
            createBaseVNode("button", {
              class: "remove-btn",
              onClick: withModifiers(removeAsset, ["stop"]),
              title: "Remove"
            }, [..._cache[0] || (_cache[0] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ])) : (openBlock(), createElementBlock("div", _hoisted_9$l, [
            createBaseVNode("i", {
              class: normalizeClass(["pi", placeholderIcon.value])
            }, null, 2),
            createBaseVNode("span", _hoisted_10$l, toDisplayString(label.value), 1),
            createBaseVNode("span", _hoisted_11$k, toDisplayString(hint.value), 1),
            createBaseVNode("span", _hoisted_12$i, toDisplayString(acceptedFormatsDisplay.value), 1)
          ]))
        ], 34),
        createBaseVNode("input", {
          ref_key: "fileInput",
          ref: fileInput,
          type: "file",
          accept: acceptedFormats.value,
          multiple: __props.multiple,
          onChange: onFileSelected,
          style: { "display": "none" }
        }, null, 40, _hoisted_13$i),
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_14$h, [
          createBaseVNode("div", _hoisted_15$g, [
            createBaseVNode("div", {
              class: "progress-fill",
              style: normalizeStyle({ width: `${progress.value}%` })
            }, null, 4)
          ]),
          createBaseVNode("span", _hoisted_16$f, toDisplayString(progressText.value), 1)
        ])) : createCommentVNode("", true),
        errorMessage.value ? (openBlock(), createElementBlock("div", _hoisted_17$e, [
          _cache[1] || (_cache[1] = createBaseVNode("i", { class: "pi pi-exclamation-triangle" }, null, -1)),
          createTextVNode(" " + toDisplayString(errorMessage.value), 1)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetUploader = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-60bffb7c"]]);

const _hoisted_1$k = { class: "environment-settings" };
const _hoisted_2$k = { class: "settings-header" };
const _hoisted_3$k = { class: "enable-toggle" };
const _hoisted_4$k = ["checked"];
const _hoisted_5$k = {
  key: 0,
  class: "settings-content"
};
const _hoisted_6$k = { class: "setting-group" };
const _hoisted_7$k = {
  key: 0,
  class: "setting-group"
};
const _hoisted_8$k = { class: "preset-grid" };
const _hoisted_9$k = ["onClick"];
const _hoisted_10$k = { class: "setting-group" };
const _hoisted_11$j = { class: "setting-group" };
const _hoisted_12$h = { class: "rotation-control" };
const _hoisted_13$h = { class: "setting-group" };
const _hoisted_14$g = { class: "checkbox-label" };
const _hoisted_15$f = ["checked"];
const _hoisted_16$e = {
  key: 1,
  class: "setting-group"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "EnvironmentSettings",
  props: {
    modelValue: {},
    config: {}
  },
  emits: ["update:modelValue", "load-hdri", "update", "load", "clear"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const defaultConfig = {
      enabled: false,
      intensity: 1,
      rotation: 0,
      backgroundBlur: 0,
      useAsBackground: true,
      toneMapping: true
    };
    const configState = reactive({ ...defaultConfig, ...props.modelValue, ...props.config });
    const selectedPreset = ref(null);
    const config = configState;
    const presets = [
      { id: "studio", name: "Studio", color: "linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%)" },
      { id: "outdoor", name: "Outdoor", color: "linear-gradient(135deg, #87CEEB 0%, #98D8C8 100%)" },
      { id: "sunset", name: "Sunset", color: "linear-gradient(135deg, #ff6b6b 0%, #ffa600 100%)" },
      { id: "night", name: "Night", color: "linear-gradient(135deg, #1a1a3e 0%, #0d0d1a 100%)" }
    ];
    watch(() => props.modelValue, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    watch(() => props.config, (newVal) => {
      if (newVal) {
        Object.assign(configState, { ...defaultConfig, ...newVal });
      }
    }, { deep: true });
    function updateConfig(key, value) {
      configState[key] = value;
      emitUpdate();
    }
    function onHdriUpload(file, dataUrl) {
      if (dataUrl) {
        configState.url = dataUrl;
        selectedPreset.value = null;
        emitUpdate();
        emit("load-hdri", dataUrl);
        emit("load", file);
      }
    }
    function onHdriRemove() {
      configState.url = void 0;
      emitUpdate();
      emit("clear");
    }
    function applyPreset(preset) {
      selectedPreset.value = preset.id;
      if (preset.url) {
        configState.url = preset.url;
        emit("load-hdri", preset.url);
      }
      emitUpdate();
    }
    function emitUpdate() {
      emit("update:modelValue", { ...configState });
      emit("update", { ...configState });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("div", _hoisted_2$k, [
          _cache[7] || (_cache[7] = createBaseVNode("div", { class: "header-title" }, [
            createBaseVNode("i", { class: "pi pi-globe" }),
            createBaseVNode("span", null, "Environment")
          ], -1)),
          createBaseVNode("label", _hoisted_3$k, [
            createBaseVNode("input", {
              type: "checkbox",
              checked: unref(config).enabled,
              onChange: _cache[0] || (_cache[0] = ($event) => updateConfig("enabled", $event.target.checked))
            }, null, 40, _hoisted_4$k),
            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "toggle-label" }, "Enabled", -1))
          ])
        ]),
        unref(config).enabled ? (openBlock(), createElementBlock("div", _hoisted_5$k, [
          createBaseVNode("div", _hoisted_6$k, [
            _cache[8] || (_cache[8] = createBaseVNode("label", { class: "group-label" }, "Environment Map (HDRI)", -1)),
            createVNode(AssetUploader, {
              assetType: "hdri",
              label: "Upload HDRI",
              onUpload: onHdriUpload,
              onRemove: onHdriRemove
            })
          ]),
          !unref(config).url ? (openBlock(), createElementBlock("div", _hoisted_7$k, [
            _cache[9] || (_cache[9] = createBaseVNode("label", { class: "group-label" }, "Quick Presets", -1)),
            createBaseVNode("div", _hoisted_8$k, [
              (openBlock(), createElementBlock(Fragment, null, renderList(presets, (preset) => {
                return createBaseVNode("button", {
                  key: preset.id,
                  class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                  onClick: ($event) => applyPreset(preset)
                }, [
                  createBaseVNode("div", {
                    class: "preset-preview",
                    style: normalizeStyle({ background: preset.color })
                  }, null, 4),
                  createBaseVNode("span", null, toDisplayString(preset.name), 1)
                ], 10, _hoisted_9$k);
              }), 64))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_10$k, [
            _cache[10] || (_cache[10] = createBaseVNode("label", null, "Intensity", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).intensity,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => updateConfig("intensity", $event)),
              min: 0,
              max: 3,
              step: 0.1
            }, null, 8, ["modelValue"])
          ]),
          createBaseVNode("div", _hoisted_11$j, [
            _cache[11] || (_cache[11] = createBaseVNode("label", null, "Rotation", -1)),
            createBaseVNode("div", _hoisted_12$h, [
              createVNode(unref(AngleDial), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateConfig("rotation", $event)),
                size: 36
              }, null, 8, ["modelValue"]),
              createVNode(unref(ScrubableNumber), {
                modelValue: unref(config).rotation,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateConfig("rotation", $event)),
                unit: ""
              }, null, 8, ["modelValue"])
            ])
          ]),
          createBaseVNode("div", _hoisted_13$h, [
            createBaseVNode("label", _hoisted_14$g, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: unref(config).useAsBackground,
                onChange: _cache[4] || (_cache[4] = ($event) => updateConfig("useAsBackground", $event.target.checked))
              }, null, 40, _hoisted_15$f),
              _cache[12] || (_cache[12] = createTextVNode(" Use as Background ", -1))
            ])
          ]),
          unref(config).useAsBackground ? (openBlock(), createElementBlock("div", _hoisted_16$e, [
            _cache[13] || (_cache[13] = createBaseVNode("label", null, "Background Blur", -1)),
            createVNode(unref(SliderInput), {
              modelValue: unref(config).backgroundBlur,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => updateConfig("backgroundBlur", $event)),
              min: 0,
              max: 1,
              step: 0.05
            }, null, 8, ["modelValue"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const EnvironmentSettings = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-90d48964"]]);

const _hoisted_1$j = { class: "assets-panel" };
const _hoisted_2$j = { class: "asset-tabs" };
const _hoisted_3$j = ["onClick", "title"];
const _hoisted_4$j = { class: "tab-icon" };
const _hoisted_5$j = { class: "tab-label" };
const _hoisted_6$j = { class: "asset-content" };
const _hoisted_7$j = {
  key: 0,
  class: "tab-panel"
};
const _hoisted_8$j = { class: "panel-toolbar" };
const _hoisted_9$j = ["value"];
const _hoisted_10$j = { class: "material-list" };
const _hoisted_11$i = ["onClick"];
const _hoisted_12$g = { class: "material-name" };
const _hoisted_13$g = ["onClick"];
const _hoisted_14$f = {
  key: 1,
  class: "tab-panel"
};
const _hoisted_15$e = { class: "panel-toolbar" };
const _hoisted_16$d = { class: "svg-list" };
const _hoisted_17$d = ["onClick"];
const _hoisted_18$d = { class: "svg-preview" };
const _hoisted_19$d = { class: "path-count" };
const _hoisted_20$d = { class: "svg-name" };
const _hoisted_21$d = { class: "svg-actions" };
const _hoisted_22$d = ["onClick"];
const _hoisted_23$d = ["onClick"];
const _hoisted_24$a = ["onClick"];
const _hoisted_25$9 = {
  key: 0,
  class: "svg-details"
};
const _hoisted_26$8 = { class: "path-list" };
const _hoisted_27$7 = { class: "path-name" };
const _hoisted_28$7 = { class: "path-config" };
const _hoisted_29$7 = ["value", "onInput"];
const _hoisted_30$6 = ["value", "onInput"];
const _hoisted_31$5 = {
  key: 2,
  class: "tab-panel"
};
const _hoisted_32$5 = { class: "panel-toolbar" };
const _hoisted_33$5 = { class: "mesh-list" };
const _hoisted_34$5 = ["onClick"];
const _hoisted_35$4 = { class: "mesh-icon" };
const _hoisted_36$4 = { key: 0 };
const _hoisted_37$4 = { key: 1 };
const _hoisted_38$4 = { key: 2 };
const _hoisted_39$4 = { class: "mesh-info" };
const _hoisted_40$3 = { class: "mesh-name" };
const _hoisted_41$2 = { class: "mesh-verts" };
const _hoisted_42$2 = ["onClick"];
const _hoisted_43$2 = {
  key: 0,
  class: "mesh-details"
};
const _hoisted_44$2 = { class: "detail-row" };
const _hoisted_45$2 = { class: "value" };
const _hoisted_46$2 = { class: "detail-row" };
const _hoisted_47$2 = { class: "value" };
const _hoisted_48$2 = { class: "detail-row" };
const _hoisted_49$2 = { class: "value" };
const _hoisted_50$1 = {
  key: 3,
  class: "tab-panel"
};
const _hoisted_51$1 = { class: "panel-toolbar" };
const _hoisted_52$1 = { class: "sprite-list" };
const _hoisted_53$1 = ["onClick"];
const _hoisted_54$1 = ["src"];
const _hoisted_55$1 = { class: "sprite-info" };
const _hoisted_56$1 = { class: "sprite-name" };
const _hoisted_57 = { class: "sprite-frames" };
const _hoisted_58 = ["onClick"];
const _hoisted_59 = {
  key: 0,
  class: "sprite-import-dialog"
};
const _hoisted_60 = {
  key: 0,
  class: "sprite-config"
};
const _hoisted_61 = {
  key: 4,
  class: "tab-panel"
};
const _hoisted_62 = {
  key: 0,
  class: "loading-overlay"
};
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "AssetsPanel",
  emits: ["create-layers-from-svg", "use-mesh-as-emitter", "environment-update", "environment-load", "environment-clear"],
  setup(__props, { emit: __emit }) {
    const assetStore = useAssetStore();
    useCompositorStore();
    const tabs = [
      { id: "materials", label: "Materials", icon: "", tooltip: "PBR Materials" },
      { id: "svg", label: "SVG", icon: "", tooltip: "SVG Logos & Shapes" },
      { id: "meshes", label: "Meshes", icon: "", tooltip: "Mesh Particles" },
      { id: "sprites", label: "Sprites", icon: "", tooltip: "Sprite Sheets" },
      { id: "environment", label: "Env", icon: "", tooltip: "Environment Map" }
    ];
    const activeTab = ref("materials");
    const materialPresets = [
      "chrome",
      "gold",
      "silver",
      "copper",
      "brass",
      "glass",
      "plastic",
      "rubber",
      "wood",
      "concrete",
      "emissive",
      "holographic"
    ];
    const selectedPreset = ref("");
    const materials = computed(() => assetStore.materialList);
    const svgDocuments = computed(() => assetStore.svgDocumentList);
    const meshParticles = computed(() => assetStore.meshParticleList);
    const spriteSheets = computed(() => assetStore.spriteSheetList);
    const environment = computed(() => assetStore.environment);
    const selectedMaterial = computed(() => assetStore.selectedMaterial);
    const selectedSvg = computed(() => assetStore.selectedSvgDocument);
    const selectedMesh = computed(() => assetStore.selectedMeshParticle);
    const selectedPrimitive = ref("");
    const showSpriteImport = ref(false);
    const pendingSpriteFile = ref(null);
    const spriteColumns = ref(4);
    const spriteRows = ref(4);
    const spriteFrameRate = ref(24);
    function createMaterial() {
      assetStore.createEmptyMaterial("New Material");
    }
    function createFromPreset() {
      if (selectedPreset.value) {
        assetStore.createMaterialFromPreset(selectedPreset.value);
        selectedPreset.value = "";
      }
    }
    function selectMaterial(id) {
      assetStore.selectedMaterialId = id;
    }
    function deleteMaterial(id) {
      assetStore.deleteMaterial(id);
    }
    function onMaterialUpdate(updates) {
      if (assetStore.selectedMaterialId) {
        assetStore.updateMaterial(assetStore.selectedMaterialId, updates);
      }
    }
    function onTextureUpload(textureType, file) {
      if (assetStore.selectedMaterialId) {
        assetStore.setMaterialTexture(assetStore.selectedMaterialId, textureType, file);
      }
    }
    function getMaterialPreviewStyle(mat) {
      return {
        backgroundColor: mat.config.color || "#808080",
        backgroundImage: mat.config.albedoMap ? `url(${mat.config.albedoMap})` : "none",
        backgroundSize: "cover"
      };
    }
    async function onSvgUpload(file) {
      await assetStore.importSvgFromFile(file);
    }
    function selectSvg(id) {
      assetStore.selectedSvgId = id;
    }
    function deleteSvg(id) {
      assetStore.deleteSvgDocument(id);
    }
    function updatePathDepth(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 0;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { depth: value });
    }
    function updatePathExtrusion(pathIndex, event) {
      if (!assetStore.selectedSvgId) return;
      const value = parseFloat(event.target.value) || 2;
      assetStore.updateSvgLayerConfig(assetStore.selectedSvgId, pathIndex, { extrusionDepth: value });
    }
    function createLayersFromSvg(svgId) {
      emit("create-layers-from-svg", svgId);
    }
    function registerSvgAsMesh(svgId) {
      const svg = assetStore.svgDocuments.get(svgId);
      if (!svg) return;
      svg.document.paths.forEach((_, i) => {
        assetStore.registerSvgPathAsMesh(svgId, i);
      });
      activeTab.value = "meshes";
    }
    function addPrimitiveMesh() {
      if (selectedPrimitive.value) {
        assetStore.registerPrimitiveMesh(selectedPrimitive.value);
        selectedPrimitive.value = "";
      }
    }
    function selectMesh(id) {
      assetStore.selectedMeshParticleId = id;
    }
    function deleteMesh(id) {
      assetStore.deleteMeshParticle(id);
    }
    function useAsEmitterShape() {
      if (assetStore.selectedMeshParticleId) {
        emit("use-mesh-as-emitter", assetStore.selectedMeshParticleId);
      }
    }
    function onSpriteFileSelect(file) {
      pendingSpriteFile.value = file;
    }
    async function importSpriteSheet() {
      if (!pendingSpriteFile.value) return;
      await assetStore.importSpriteSheet(
        pendingSpriteFile.value,
        spriteColumns.value,
        spriteRows.value,
        { frameRate: spriteFrameRate.value }
      );
      cancelSpriteImport();
    }
    function cancelSpriteImport() {
      showSpriteImport.value = false;
      pendingSpriteFile.value = null;
      spriteColumns.value = 4;
      spriteRows.value = 4;
      spriteFrameRate.value = 24;
    }
    function selectSprite(id) {
      assetStore.selectedSpriteSheetId = id;
    }
    function deleteSprite(id) {
      assetStore.deleteSpriteSheet(id);
    }
    function onEnvironmentUpdate(settings) {
      assetStore.updateEnvironment(settings);
      emit("environment-update", settings);
    }
    async function onEnvironmentLoad(file) {
      await assetStore.loadEnvironment(file);
      emit("environment-load", assetStore.environment);
    }
    function onEnvironmentClear() {
      assetStore.clearEnvironment();
      emit("environment-clear");
    }
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createBaseVNode("div", _hoisted_2$j, [
          (openBlock(), createElementBlock(Fragment, null, renderList(tabs, (tab) => {
            return createBaseVNode("button", {
              key: tab.id,
              class: normalizeClass({ active: activeTab.value === tab.id }),
              onClick: ($event) => activeTab.value = tab.id,
              title: tab.tooltip
            }, [
              createBaseVNode("span", _hoisted_4$j, toDisplayString(tab.icon), 1),
              createBaseVNode("span", _hoisted_5$j, toDisplayString(tab.label), 1)
            ], 10, _hoisted_3$j);
          }), 64))
        ]),
        createBaseVNode("div", _hoisted_6$j, [
          activeTab.value === "materials" ? (openBlock(), createElementBlock("div", _hoisted_7$j, [
            createBaseVNode("div", _hoisted_8$j, [
              createBaseVNode("button", {
                onClick: createMaterial,
                title: "New Material"
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" New ", -1)
              ])]),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedPreset.value = $event),
                onChange: createFromPreset,
                class: "preset-select"
              }, [
                _cache[8] || (_cache[8] = createBaseVNode("option", { value: "" }, "From Preset...", -1)),
                (openBlock(), createElementBlock(Fragment, null, renderList(materialPresets, (preset) => {
                  return createBaseVNode("option", {
                    key: preset,
                    value: preset
                  }, toDisplayString(preset), 9, _hoisted_9$j);
                }), 64))
              ], 544), [
                [vModelSelect, selectedPreset.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_10$j, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(materials.value, (mat) => {
                return openBlock(), createElementBlock("div", {
                  key: mat.id,
                  class: normalizeClass(["material-item", { selected: mat.id === unref(assetStore).selectedMaterialId }]),
                  onClick: ($event) => selectMaterial(mat.id)
                }, [
                  createBaseVNode("div", {
                    class: "material-preview",
                    style: normalizeStyle(getMaterialPreviewStyle(mat))
                  }, null, 4),
                  createBaseVNode("span", _hoisted_12$g, toDisplayString(mat.name), 1),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMaterial(mat.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[9] || (_cache[9] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_13$g)
                ], 10, _hoisted_11$i);
              }), 128))
            ]),
            selectedMaterial.value ? (openBlock(), createBlock(MaterialEditor, {
              key: 0,
              "material-id": selectedMaterial.value.id,
              config: selectedMaterial.value.config,
              onUpdate: onMaterialUpdate,
              onTextureUpload
            }, null, 8, ["material-id", "config"])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "svg" ? (openBlock(), createElementBlock("div", _hoisted_14$f, [
            createBaseVNode("div", _hoisted_15$e, [
              createVNode(AssetUploader, {
                accept: ".svg",
                "asset-type": "svg",
                onUpload: onSvgUpload,
                "button-text": "Import SVG"
              })
            ]),
            createBaseVNode("div", _hoisted_16$d, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(svgDocuments.value, (svg) => {
                return openBlock(), createElementBlock("div", {
                  key: svg.id,
                  class: normalizeClass(["svg-item", { selected: svg.id === unref(assetStore).selectedSvgId }]),
                  onClick: ($event) => selectSvg(svg.id)
                }, [
                  createBaseVNode("div", _hoisted_18$d, [
                    createBaseVNode("span", _hoisted_19$d, toDisplayString(svg.document.paths.length) + " paths", 1)
                  ]),
                  createBaseVNode("span", _hoisted_20$d, toDisplayString(svg.name), 1),
                  createBaseVNode("div", _hoisted_21$d, [
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => createLayersFromSvg(svg.id), ["stop"]),
                      title: "Create Layers"
                    }, [..._cache[10] || (_cache[10] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_22$d),
                    createBaseVNode("button", {
                      onClick: withModifiers(($event) => registerSvgAsMesh(svg.id), ["stop"]),
                      title: "Use as Particle"
                    }, [..._cache[11] || (_cache[11] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_23$d),
                    createBaseVNode("button", {
                      class: "delete-btn",
                      onClick: withModifiers(($event) => deleteSvg(svg.id), ["stop"]),
                      title: "Delete"
                    }, [..._cache[12] || (_cache[12] = [
                      createBaseVNode("span", { class: "icon" }, "", -1)
                    ])], 8, _hoisted_24$a)
                  ])
                ], 10, _hoisted_17$d);
              }), 128))
            ]),
            selectedSvg.value ? (openBlock(), createElementBlock("div", _hoisted_25$9, [
              createBaseVNode("h4", null, toDisplayString(selectedSvg.value.name), 1),
              createBaseVNode("div", _hoisted_26$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(selectedSvg.value.document.paths, (path, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: path.id,
                    class: "path-item"
                  }, [
                    createBaseVNode("span", _hoisted_27$7, toDisplayString(path.id), 1),
                    createBaseVNode("div", {
                      class: "path-color",
                      style: normalizeStyle({ backgroundColor: path.fill || path.stroke || "#888" })
                    }, null, 4),
                    createBaseVNode("div", _hoisted_28$7, [
                      createBaseVNode("label", null, [
                        _cache[13] || (_cache[13] = createTextVNode(" Depth ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.depth || 0,
                          onInput: ($event) => updatePathDepth(i, $event),
                          step: "1"
                        }, null, 40, _hoisted_29$7)
                      ]),
                      createBaseVNode("label", null, [
                        _cache[14] || (_cache[14] = createTextVNode(" Extrusion ", -1)),
                        createBaseVNode("input", {
                          type: "number",
                          value: selectedSvg.value.layerConfigs[i]?.extrusionDepth || 2,
                          onInput: ($event) => updatePathExtrusion(i, $event),
                          step: "0.5"
                        }, null, 40, _hoisted_30$6)
                      ])
                    ])
                  ]);
                }), 128))
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "meshes" ? (openBlock(), createElementBlock("div", _hoisted_31$5, [
            createBaseVNode("div", _hoisted_32$5, [
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedPrimitive.value = $event),
                onChange: addPrimitiveMesh,
                class: "primitive-select"
              }, [..._cache[15] || (_cache[15] = [
                createStaticVNode('<option value="" data-v-5051fa15>Add Primitive...</option><option value="cube" data-v-5051fa15>Cube</option><option value="sphere" data-v-5051fa15>Sphere</option><option value="cone" data-v-5051fa15>Cone</option><option value="cylinder" data-v-5051fa15>Cylinder</option><option value="torus" data-v-5051fa15>Torus</option><option value="tetrahedron" data-v-5051fa15>Tetrahedron</option><option value="octahedron" data-v-5051fa15>Octahedron</option><option value="icosahedron" data-v-5051fa15>Icosahedron</option>', 9)
              ])], 544), [
                [vModelSelect, selectedPrimitive.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_33$5, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(meshParticles.value, (mesh) => {
                return openBlock(), createElementBlock("div", {
                  key: mesh.id,
                  class: normalizeClass(["mesh-item", { selected: mesh.id === unref(assetStore).selectedMeshParticleId }]),
                  onClick: ($event) => selectMesh(mesh.id)
                }, [
                  createBaseVNode("div", _hoisted_35$4, [
                    mesh.source === "primitive" ? (openBlock(), createElementBlock("span", _hoisted_36$4, "")) : mesh.source === "svg" ? (openBlock(), createElementBlock("span", _hoisted_37$4, "")) : (openBlock(), createElementBlock("span", _hoisted_38$4, ""))
                  ]),
                  createBaseVNode("div", _hoisted_39$4, [
                    createBaseVNode("span", _hoisted_40$3, toDisplayString(mesh.name), 1),
                    createBaseVNode("span", _hoisted_41$2, toDisplayString(mesh.registration.vertexCount) + " verts", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteMesh(mesh.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[16] || (_cache[16] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_42$2)
                ], 10, _hoisted_34$5);
              }), 128))
            ]),
            selectedMesh.value ? (openBlock(), createElementBlock("div", _hoisted_43$2, [
              createBaseVNode("h4", null, toDisplayString(selectedMesh.value.name), 1),
              createBaseVNode("div", _hoisted_44$2, [
                _cache[17] || (_cache[17] = createBaseVNode("span", { class: "label" }, "Source:", -1)),
                createBaseVNode("span", _hoisted_45$2, toDisplayString(selectedMesh.value.source), 1)
              ]),
              createBaseVNode("div", _hoisted_46$2, [
                _cache[18] || (_cache[18] = createBaseVNode("span", { class: "label" }, "Vertices:", -1)),
                createBaseVNode("span", _hoisted_47$2, toDisplayString(selectedMesh.value.registration.vertexCount), 1)
              ]),
              createBaseVNode("div", _hoisted_48$2, [
                _cache[19] || (_cache[19] = createBaseVNode("span", { class: "label" }, "Bounding Radius:", -1)),
                createBaseVNode("span", _hoisted_49$2, toDisplayString(selectedMesh.value.registration.boundingSphere.radius.toFixed(2)), 1)
              ]),
              createBaseVNode("button", {
                class: "action-btn",
                onClick: useAsEmitterShape
              }, " Use as Emitter Shape ")
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "sprites" ? (openBlock(), createElementBlock("div", _hoisted_50$1, [
            createBaseVNode("div", _hoisted_51$1, [
              createBaseVNode("button", {
                onClick: _cache[2] || (_cache[2] = ($event) => showSpriteImport.value = true),
                title: "Import Sprite Sheet"
              }, [..._cache[20] || (_cache[20] = [
                createBaseVNode("span", { class: "icon" }, "+", -1),
                createTextVNode(" Import ", -1)
              ])])
            ]),
            createBaseVNode("div", _hoisted_52$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(spriteSheets.value, (sprite) => {
                return openBlock(), createElementBlock("div", {
                  key: sprite.id,
                  class: normalizeClass(["sprite-item", { selected: sprite.id === unref(assetStore).selectedSpriteSheetId }]),
                  onClick: ($event) => selectSprite(sprite.id)
                }, [
                  createBaseVNode("img", {
                    src: sprite.textureUrl,
                    class: "sprite-preview"
                  }, null, 8, _hoisted_54$1),
                  createBaseVNode("div", _hoisted_55$1, [
                    createBaseVNode("span", _hoisted_56$1, toDisplayString(sprite.name), 1),
                    createBaseVNode("span", _hoisted_57, toDisplayString(sprite.config.totalFrames) + " frames", 1)
                  ]),
                  createBaseVNode("button", {
                    class: "delete-btn",
                    onClick: withModifiers(($event) => deleteSprite(sprite.id), ["stop"]),
                    title: "Delete"
                  }, [..._cache[21] || (_cache[21] = [
                    createBaseVNode("span", { class: "icon" }, "", -1)
                  ])], 8, _hoisted_58)
                ], 10, _hoisted_53$1);
              }), 128))
            ]),
            showSpriteImport.value ? (openBlock(), createElementBlock("div", _hoisted_59, [
              _cache[25] || (_cache[25] = createBaseVNode("h4", null, "Import Sprite Sheet", -1)),
              createVNode(AssetUploader, {
                accept: "image/*",
                "asset-type": "sprite",
                onUpload: onSpriteFileSelect,
                "button-text": "Select Image"
              }),
              pendingSpriteFile.value ? (openBlock(), createElementBlock("div", _hoisted_60, [
                createBaseVNode("label", null, [
                  _cache[22] || (_cache[22] = createTextVNode(" Columns ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => spriteColumns.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteColumns.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[23] || (_cache[23] = createTextVNode(" Rows ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => spriteRows.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteRows.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("label", null, [
                  _cache[24] || (_cache[24] = createTextVNode(" Frame Rate ", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => spriteFrameRate.value = $event),
                    type: "number",
                    min: "1"
                  }, null, 512), [
                    [
                      vModelText,
                      spriteFrameRate.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                createBaseVNode("div", { class: "dialog-actions" }, [
                  createBaseVNode("button", {
                    onClick: importSpriteSheet,
                    class: "confirm-btn"
                  }, "Import"),
                  createBaseVNode("button", {
                    onClick: cancelSpriteImport,
                    class: "cancel-btn"
                  }, "Cancel")
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          activeTab.value === "environment" ? (openBlock(), createElementBlock("div", _hoisted_61, [
            createVNode(EnvironmentSettings, {
              config: environment.value,
              onUpdate: onEnvironmentUpdate,
              onLoad: onEnvironmentLoad,
              onClear: onEnvironmentClear
            }, null, 8, ["config"])
          ])) : createCommentVNode("", true)
        ]),
        unref(assetStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_62, [..._cache[26] || (_cache[26] = [
          createBaseVNode("div", { class: "spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(assetStore).lastError ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "error-toast",
          onClick: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(assetStore).clearError && unref(assetStore).clearError(...args))
        }, toDisplayString(unref(assetStore).lastError), 1)) : createCommentVNode("", true)
      ]);
    };
  }
});

const AssetsPanel = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-5051fa15"]]);

function isWebCodecsSupported() {
  return typeof VideoEncoder !== "undefined" && typeof VideoFrame !== "undefined";
}
async function getSupportedCodecs() {
  if (!isWebCodecsSupported()) return [];
  const codecs = [];
  const testConfigs = [
    { codec: "avc1.42E01F", name: "avc" },
    // H.264 Baseline
    { codec: "avc1.640028", name: "avc" },
    // H.264 High
    { codec: "vp9", name: "vp9" },
    { codec: "vp8", name: "vp8" }
  ];
  for (const { codec, name } of testConfigs) {
    try {
      const support = await VideoEncoder.isConfigSupported({
        codec,
        width: 1920,
        height: 1080,
        bitrate: 5e6
      });
      if (support.supported && !codecs.includes(name)) {
        codecs.push(name);
      }
    } catch {
    }
  }
  return codecs;
}
class WebCodecsVideoEncoder {
  config;
  encoder = null;
  webmMuxer = null;
  mp4Muxer = null;
  frameCount = 0;
  totalBytesWritten = 0;
  onProgress;
  constructor(config) {
    this.config = config;
  }
  /**
   * Initialize the encoder
   */
  async initialize(onProgress) {
    if (!isWebCodecsSupported()) {
      throw new Error("WebCodecs API is not supported in this browser");
    }
    this.onProgress = onProgress;
    this.frameCount = 0;
    this.totalBytesWritten = 0;
    this.webmMuxer = null;
    this.mp4Muxer = null;
    const codecString = this.getCodecString();
    const bitrate = this.getBitrate();
    const support = await VideoEncoder.isConfigSupported({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate
    });
    if (!support.supported) {
      throw new Error(`Unsupported encoder configuration: ${codecString}`);
    }
    if (this.config.codec === "avc") {
      this.mp4Muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
          codec: "avc",
          width: this.config.width,
          height: this.config.height
        },
        fastStart: "in-memory"
        // Moves moov atom to beginning for streaming
      });
    } else {
      const webmCodec = this.config.codec === "vp9" ? "V_VP9" : "V_VP8";
      this.webmMuxer = new Muxer$1({
        target: new ArrayBufferTarget$1(),
        video: {
          codec: webmCodec,
          width: this.config.width,
          height: this.config.height
        }
      });
    }
    this.encoder = new VideoEncoder({
      output: (chunk, metadata) => {
        this.handleChunk(chunk, metadata);
      },
      error: (error) => {
        exportLogger.error("VideoEncoder: Encoding error:", error);
        throw error;
      }
    });
    this.encoder.configure({
      codec: codecString,
      width: this.config.width,
      height: this.config.height,
      bitrate,
      framerate: this.config.frameRate
    });
  }
  /**
   * Encode a single frame
   */
  async encodeFrame(imageData, frameIndex, totalFrames, keyFrame = false) {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    let frame;
    if (imageData instanceof ImageData) {
      frame = new VideoFrame(imageData.data, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate,
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        format: "RGBA"
      });
    } else {
      frame = new VideoFrame(imageData, {
        timestamp: frameIndex * 1e6 / this.config.frameRate,
        duration: 1e6 / this.config.frameRate
      });
    }
    const isKeyFrame = keyFrame || frameIndex === 0 || frameIndex % 30 === 0;
    this.encoder.encode(frame, { keyFrame: isKeyFrame });
    frame.close();
    this.frameCount++;
    if (this.onProgress) {
      this.onProgress({
        framesEncoded: this.frameCount,
        totalFrames,
        percentage: this.frameCount / totalFrames * 100,
        bytesWritten: this.totalBytesWritten
      });
    }
  }
  /**
   * Finish encoding and return the video blob
   */
  async finalize() {
    if (!this.encoder) {
      throw new Error("Encoder not initialized");
    }
    await this.encoder.flush();
    this.encoder.close();
    this.encoder = null;
    let blob;
    let mimeType;
    if (this.mp4Muxer) {
      this.mp4Muxer.finalize();
      const buffer = this.mp4Muxer.target.buffer;
      blob = new Blob([buffer], { type: "video/mp4" });
      mimeType = "video/mp4";
      this.mp4Muxer = null;
    } else if (this.webmMuxer) {
      this.webmMuxer.finalize();
      const buffer = this.webmMuxer.target.buffer;
      blob = new Blob([buffer], { type: "video/webm" });
      mimeType = "video/webm";
      this.webmMuxer = null;
    } else {
      throw new Error("No muxer initialized");
    }
    return {
      blob,
      mimeType,
      duration: this.frameCount / this.config.frameRate,
      frameCount: this.frameCount,
      size: blob.size
    };
  }
  /**
   * Cancel encoding
   */
  cancel() {
    if (this.encoder) {
      this.encoder.close();
      this.encoder = null;
    }
    this.webmMuxer = null;
    this.mp4Muxer = null;
  }
  // ============================================================================
  // Private Methods
  // ============================================================================
  handleChunk(chunk, metadata) {
    if (this.mp4Muxer) {
      this.mp4Muxer.addVideoChunk(chunk, metadata);
    } else if (this.webmMuxer) {
      this.webmMuxer.addVideoChunk(chunk, metadata);
    }
    this.totalBytesWritten += chunk.byteLength;
  }
  getCodecString() {
    switch (this.config.codec) {
      case "avc":
        return "avc1.640028";
      case "vp9":
        return "vp09.00.10.08";
      case "vp8":
        return "vp8";
      default:
        return "avc1.640028";
    }
  }
  getBitrate() {
    if (this.config.bitrate) {
      return this.config.bitrate;
    }
    const pixels = this.config.width * this.config.height;
    const baseRate = pixels * this.config.frameRate;
    switch (this.config.quality) {
      case "low":
        return Math.round(baseRate * 0.05);
      case "medium":
        return Math.round(baseRate * 0.1);
      case "high":
        return Math.round(baseRate * 0.2);
      case "lossless":
        return Math.round(baseRate * 0.5);
      default:
        return Math.round(baseRate * 0.1);
    }
  }
}
function downloadVideo(video, filename) {
  const extension = video.mimeType.includes("webm") ? "webm" : "mp4";
  const fullFilename = filename.includes(".") ? filename : `${filename}.${extension}`;
  const url = URL.createObjectURL(video.blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fullFilename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

const _hoisted_1$i = { class: "export-panel" };
const _hoisted_2$i = { class: "panel-content" };
const _hoisted_3$i = { class: "control-section" };
const _hoisted_4$i = { class: "control-row" };
const _hoisted_5$i = ["disabled"];
const _hoisted_6$i = ["value"];
const _hoisted_7$i = { class: "control-row" };
const _hoisted_8$i = ["disabled"];
const _hoisted_9$i = { class: "control-section" };
const _hoisted_10$i = { class: "info-grid" };
const _hoisted_11$h = { class: "info-item" };
const _hoisted_12$f = { class: "info-value" };
const _hoisted_13$f = { class: "info-item" };
const _hoisted_14$e = { class: "info-value" };
const _hoisted_15$d = { class: "info-item" };
const _hoisted_16$c = { class: "info-value" };
const _hoisted_17$c = { class: "info-item" };
const _hoisted_18$c = { class: "info-value" };
const _hoisted_19$c = {
  key: 0,
  class: "progress-section"
};
const _hoisted_20$c = { class: "progress-header" };
const _hoisted_21$c = { key: 0 };
const _hoisted_22$c = { class: "progress-bar" };
const _hoisted_23$c = {
  key: 0,
  class: "progress-details"
};
const _hoisted_24$9 = { class: "actions-section" };
const _hoisted_25$8 = ["disabled"];
const _hoisted_26$7 = {
  key: 1,
  class: "warning-message"
};
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "ExportPanel",
  setup(__props) {
    const store = useCompositorStore();
    const webCodecsSupported = ref(false);
    const availableCodecs = ref([]);
    const selectedCodec = ref("avc");
    const selectedQuality = ref("high");
    const isExporting = ref(false);
    const exportComplete = ref(false);
    const encodedVideo = ref(null);
    const currentEncoder = ref(null);
    const exportProgress = ref({
      framesEncoded: 0,
      totalFrames: 0,
      percentage: 0,
      bytesWritten: 0
    });
    const activeComp = computed(() => store.getActiveComp());
    const outputWidth = computed(() => activeComp.value?.settings.width || 1024);
    const outputHeight = computed(() => activeComp.value?.settings.height || 1024);
    const frameRate = computed(() => activeComp.value?.settings.fps || 16);
    const totalFrames = computed(() => activeComp.value?.settings.frameCount || 81);
    const duration = computed(() => {
      const seconds = totalFrames.value / frameRate.value;
      const m = Math.floor(seconds / 60);
      const s = (seconds % 60).toFixed(2);
      return m > 0 ? `${m}m ${s}s` : `${s}s`;
    });
    const canExport = computed(() => webCodecsSupported.value && !isExporting.value && store.layers.length > 0);
    const exportStatusText = computed(() => {
      if (exportComplete.value) return "Export complete!";
      if (isExporting.value) return "Encoding...";
      return "Ready";
    });
    onMounted(async () => {
      webCodecsSupported.value = isWebCodecsSupported();
      if (webCodecsSupported.value) {
        const codecs = await getSupportedCodecs();
        availableCodecs.value = [];
        if (codecs.includes("avc")) {
          availableCodecs.value.push({ value: "avc", label: "H.264 (MP4)" });
        }
        if (codecs.includes("vp9")) {
          availableCodecs.value.push({ value: "vp9", label: "VP9 (WebM)" });
        }
        if (codecs.includes("vp8")) {
          availableCodecs.value.push({ value: "vp8", label: "VP8 (WebM)" });
        }
        if (availableCodecs.value.length > 0) {
          selectedCodec.value = availableCodecs.value[0].value;
        }
      }
    });
    async function startExport() {
      if (!canExport.value) return;
      isExporting.value = true;
      exportComplete.value = false;
      encodedVideo.value = null;
      const config = {
        width: outputWidth.value,
        height: outputHeight.value,
        frameRate: frameRate.value,
        codec: selectedCodec.value,
        quality: selectedQuality.value
      };
      const encoder = new WebCodecsVideoEncoder(config);
      currentEncoder.value = encoder;
      try {
        await encoder.initialize((progress) => {
          exportProgress.value = progress;
        });
        const canvas = new OffscreenCanvas(outputWidth.value, outputHeight.value);
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("Could not get 2D context");
        for (let frame = 0; frame < totalFrames.value; frame++) {
          if (!isExporting.value) break;
          store.setFrame(frame);
          await new Promise((resolve) => setTimeout(resolve, 10));
          const frameImage = await captureCurrentFrame(canvas, ctx);
          await encoder.encodeFrame(frameImage, frame, totalFrames.value);
        }
        if (isExporting.value) {
          encodedVideo.value = await encoder.finalize();
          exportComplete.value = true;
        }
      } catch (error) {
        console.error("Export failed:", error);
        alert(`Export failed: ${error.message}`);
      } finally {
        isExporting.value = false;
        currentEncoder.value = null;
      }
    }
    async function captureCurrentFrame(canvas, ctx) {
      const glCanvas = document.querySelector(".three-canvas canvas");
      if (glCanvas) {
        ctx.drawImage(glCanvas, 0, 0, canvas.width, canvas.height);
      } else {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, "#1a1a2e");
        gradient.addColorStop(1, "#16213e");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Frame " + store.currentFrame, canvas.width / 2, canvas.height / 2);
      }
      return canvas;
    }
    function cancelExport() {
      isExporting.value = false;
      if (currentEncoder.value) {
        currentEncoder.value.cancel();
        currentEncoder.value = null;
      }
    }
    function downloadExport() {
      if (encodedVideo.value) {
        const compName = activeComp.value?.name || "composition";
        downloadVideo(encodedVideo.value, `${compName}-export`);
      }
    }
    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        _cache[12] || (_cache[12] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Export Video")
        ], -1)),
        createBaseVNode("div", _hoisted_2$i, [
          createBaseVNode("div", _hoisted_3$i, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Format")
            ], -1)),
            createBaseVNode("div", _hoisted_4$i, [
              _cache[2] || (_cache[2] = createBaseVNode("label", null, "Codec", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedCodec.value = $event),
                disabled: isExporting.value
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableCodecs.value, (codec) => {
                  return openBlock(), createElementBlock("option", {
                    key: codec.value,
                    value: codec.value
                  }, toDisplayString(codec.label), 9, _hoisted_6$i);
                }), 128))
              ], 8, _hoisted_5$i), [
                [vModelSelect, selectedCodec.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_7$i, [
              _cache[4] || (_cache[4] = createBaseVNode("label", null, "Quality", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedQuality.value = $event),
                disabled: isExporting.value
              }, [..._cache[3] || (_cache[3] = [
                createBaseVNode("option", { value: "low" }, "Low (smaller file)", -1),
                createBaseVNode("option", { value: "medium" }, "Medium", -1),
                createBaseVNode("option", { value: "high" }, "High", -1),
                createBaseVNode("option", { value: "lossless" }, "Lossless (largest)", -1)
              ])], 8, _hoisted_8$i), [
                [vModelSelect, selectedQuality.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_9$i, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, [
              createBaseVNode("span", { class: "section-title" }, "Output")
            ], -1)),
            createBaseVNode("div", _hoisted_10$i, [
              createBaseVNode("div", _hoisted_11$h, [
                _cache[6] || (_cache[6] = createBaseVNode("span", { class: "info-label" }, "Size", -1)),
                createBaseVNode("span", _hoisted_12$f, toDisplayString(outputWidth.value) + " x " + toDisplayString(outputHeight.value), 1)
              ]),
              createBaseVNode("div", _hoisted_13$f, [
                _cache[7] || (_cache[7] = createBaseVNode("span", { class: "info-label" }, "Frame Rate", -1)),
                createBaseVNode("span", _hoisted_14$e, toDisplayString(frameRate.value) + " fps", 1)
              ]),
              createBaseVNode("div", _hoisted_15$d, [
                _cache[8] || (_cache[8] = createBaseVNode("span", { class: "info-label" }, "Duration", -1)),
                createBaseVNode("span", _hoisted_16$c, toDisplayString(duration.value), 1)
              ]),
              createBaseVNode("div", _hoisted_17$c, [
                _cache[9] || (_cache[9] = createBaseVNode("span", { class: "info-label" }, "Total Frames", -1)),
                createBaseVNode("span", _hoisted_18$c, toDisplayString(totalFrames.value), 1)
              ])
            ])
          ]),
          isExporting.value || exportComplete.value ? (openBlock(), createElementBlock("div", _hoisted_19$c, [
            createBaseVNode("div", _hoisted_20$c, [
              createBaseVNode("span", null, toDisplayString(exportStatusText.value), 1),
              isExporting.value ? (openBlock(), createElementBlock("span", _hoisted_21$c, toDisplayString(exportProgress.value.percentage.toFixed(1)) + "%", 1)) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_22$c, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value.percentage}%` })
              }, null, 4)
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_23$c, [
              createBaseVNode("span", null, "Frame " + toDisplayString(exportProgress.value.framesEncoded) + " / " + toDisplayString(exportProgress.value.totalFrames), 1),
              createBaseVNode("span", null, toDisplayString(formatBytes(exportProgress.value.bytesWritten)), 1)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_24$9, [
            !isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "export-btn primary",
              disabled: !canExport.value,
              onClick: startExport
            }, " Export Video ", 8, _hoisted_25$8)) : createCommentVNode("", true),
            isExporting.value ? (openBlock(), createElementBlock("button", {
              key: 1,
              class: "export-btn cancel",
              onClick: cancelExport
            }, " Cancel ")) : createCommentVNode("", true),
            exportComplete.value && encodedVideo.value ? (openBlock(), createElementBlock("button", {
              key: 2,
              class: "export-btn download",
              onClick: downloadExport
            }, " Download " + toDisplayString(formatBytes(encodedVideo.value.size)), 1)) : createCommentVNode("", true)
          ]),
          !webCodecsSupported.value ? (openBlock(), createElementBlock("div", _hoisted_26$7, [..._cache[11] || (_cache[11] = [
            createBaseVNode("span", { class: "warning-icon" }, "", -1),
            createBaseVNode("span", null, "WebCodecs API not supported in this browser. Video export unavailable.", -1)
          ])])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});

const ExportPanel = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-1b652def"]]);

const _hoisted_1$h = { class: "preview-panel" };
const _hoisted_2$h = { class: "panel-content" };
const _hoisted_3$h = { class: "playback-section" };
const _hoisted_4$h = { class: "control-row" };
const _hoisted_5$h = { class: "control-row" };
const _hoisted_6$h = { class: "range-section" };
const _hoisted_7$h = { class: "range-row" };
const _hoisted_8$h = ["max"];
const _hoisted_9$h = ["min", "max"];
const _hoisted_10$h = { class: "frame-info" };
const _hoisted_11$g = { class: "cache-section" };
const _hoisted_12$e = {
  key: 0,
  class: "no-particles"
};
const _hoisted_13$e = { key: 1 };
const _hoisted_14$d = { class: "cache-controls" };
const _hoisted_15$c = ["disabled"];
const _hoisted_16$b = ["disabled"];
const _hoisted_17$b = {
  key: 0,
  class: "progress-container"
};
const _hoisted_18$b = { class: "progress-bar" };
const _hoisted_19$b = { class: "progress-text" };
const _hoisted_20$b = { class: "cache-stats" };
const _hoisted_21$b = { class: "layer-name" };
const _hoisted_22$b = { class: "cache-count" };
const _hoisted_23$b = { class: "quality-section" };
const _hoisted_24$8 = { class: "quality-row" };
const _hoisted_25$7 = { class: "quality-row" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "PreviewPanel",
  props: {
    engine: {}
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const store = useCompositorStore();
    const {
      currentFrame,
      fps,
      frameCount,
      layers,
      isPlaying
    } = storeToRefs(store);
    const loopPlayback = ref(true);
    const playbackSpeed = ref(1);
    const workAreaStart = ref(0);
    const workAreaEnd = ref(81);
    const isCaching = ref(false);
    const cacheProgress = ref(0);
    const currentCachingFrame = ref(0);
    const totalFramesToCache = ref(0);
    const previewResolution = ref(1);
    const adaptiveQuality = ref(true);
    const cacheStats = ref(/* @__PURE__ */ new Map());
    const formattedTime = computed(() => {
      const seconds = currentFrame.value / fps.value;
      const minutes = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(2);
      return `${minutes}:${secs.padStart(5, "0")}`;
    });
    const cacheProgressText = computed(() => {
      if (!isCaching.value) return "";
      return `${currentCachingFrame.value} / ${totalFramesToCache.value}`;
    });
    const particleLayers = computed(() => {
      return layers.value.filter((l) => l.type === "particles");
    });
    function togglePlayback() {
      store.togglePlayback();
    }
    function goToStart() {
      store.setCurrentFrame(workAreaStart.value);
    }
    function goToEnd() {
      store.setCurrentFrame(workAreaEnd.value - 1);
    }
    function stepForward() {
      const next = Math.min(currentFrame.value + 1, frameCount.value - 1);
      store.setCurrentFrame(next);
    }
    function stepBackward() {
      const prev = Math.max(currentFrame.value - 1, 0);
      store.setCurrentFrame(prev);
    }
    function getCacheCount(layerId) {
      return cacheStats.value.get(layerId)?.cachedFrames ?? 0;
    }
    async function cacheWorkArea() {
      if (isCaching.value) return;
      const particleLayerObjects = getParticleLayerObjects();
      if (particleLayerObjects.length === 0) return;
      isCaching.value = true;
      cacheProgress.value = 0;
      totalFramesToCache.value = workAreaEnd.value - workAreaStart.value;
      currentCachingFrame.value = 0;
      try {
        for (const layer of particleLayerObjects) {
          await layer.preCacheFrames(
            workAreaStart.value,
            workAreaEnd.value - 1,
            (current, total) => {
              currentCachingFrame.value = current;
              cacheProgress.value = current / total * 100;
            }
          );
          const stats = layer.getCacheStats();
          cacheStats.value.set(layer.id, { cachedFrames: stats.cachedFrames });
        }
      } catch (error) {
        console.error("Error caching particle frames:", error);
      } finally {
        isCaching.value = false;
        cacheProgress.value = 100;
      }
    }
    function clearAllCaches() {
      const particleLayerObjects = getParticleLayerObjects();
      for (const layer of particleLayerObjects) {
        layer.clearCache();
        cacheStats.value.set(layer.id, { cachedFrames: 0 });
      }
    }
    function getParticleLayerObjects() {
      if (!props.engine) return [];
      const result = [];
      for (const layerData of particleLayers.value) {
        const layer = props.engine.getLayerById(layerData.id);
        if (layer && "preCacheFrames" in layer) {
          result.push(layer);
        }
      }
      return result;
    }
    function updateCacheStats() {
      const particleLayerObjects = getParticleLayerObjects();
      for (const layer of particleLayerObjects) {
        const stats = layer.getCacheStats();
        cacheStats.value.set(layer.id, { cachedFrames: stats.cachedFrames });
      }
    }
    watch(frameCount, (newCount) => {
      if (workAreaEnd.value > newCount) {
        workAreaEnd.value = newCount;
      }
    }, { immediate: true });
    let statsInterval = null;
    onMounted(() => {
      updateCacheStats();
      statsInterval = window.setInterval(updateCacheStats, 2e3);
    });
    onUnmounted(() => {
      if (statsInterval !== null) {
        clearInterval(statsInterval);
      }
    });
    __expose({
      playbackSpeed,
      loopPlayback,
      previewResolution,
      adaptiveQuality
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        _cache[15] || (_cache[15] = createBaseVNode("div", { class: "panel-header" }, [
          createBaseVNode("span", { class: "panel-title" }, "Preview")
        ], -1)),
        createBaseVNode("div", _hoisted_2$h, [
          createBaseVNode("div", _hoisted_3$h, [
            createBaseVNode("div", _hoisted_4$h, [
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: goToStart,
                title: "Go to Start (Home)"
              }, "  "),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: stepBackward,
                title: "Step Backward (,)"
              }, "  "),
              createBaseVNode("button", {
                class: normalizeClass(["transport-btn play-btn", { playing: unref(isPlaying) }]),
                onClick: togglePlayback,
                title: "Play/Pause (Space)"
              }, toDisplayString(unref(isPlaying) ? "" : ""), 3),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: stepForward,
                title: "Step Forward (.)"
              }, "  "),
              createBaseVNode("button", {
                class: "transport-btn",
                onClick: goToEnd,
                title: "Go to End (End)"
              }, "  ")
            ]),
            createBaseVNode("div", _hoisted_5$h, [
              createBaseVNode("label", null, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => loopPlayback.value = $event)
                }, null, 512), [
                  [vModelCheckbox, loopPlayback.value]
                ]),
                _cache[6] || (_cache[6] = createTextVNode(" Loop ", -1))
              ]),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => playbackSpeed.value = $event),
                class: "speed-select"
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("option", { value: 0.25 }, "0.25x", -1),
                createBaseVNode("option", { value: 0.5 }, "0.5x", -1),
                createBaseVNode("option", { value: 1 }, "1x", -1),
                createBaseVNode("option", { value: 2 }, "2x", -1),
                createBaseVNode("option", { value: 4 }, "4x", -1)
              ])], 512), [
                [vModelSelect, playbackSpeed.value]
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_6$h, [
            createBaseVNode("div", _hoisted_7$h, [
              createBaseVNode("label", null, [
                _cache[8] || (_cache[8] = createTextVNode(" Work Area: ", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "number",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => workAreaStart.value = $event),
                  min: 0,
                  max: unref(frameCount) - 1,
                  class: "frame-input"
                }, null, 8, _hoisted_8$h), [
                  [
                    vModelText,
                    workAreaStart.value,
                    void 0,
                    { number: true }
                  ]
                ]),
                _cache[9] || (_cache[9] = createTextVNode(" - ", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "number",
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => workAreaEnd.value = $event),
                  min: workAreaStart.value,
                  max: unref(frameCount),
                  class: "frame-input"
                }, null, 8, _hoisted_9$h), [
                  [
                    vModelText,
                    workAreaEnd.value,
                    void 0,
                    { number: true }
                  ]
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_10$h, " Frame " + toDisplayString(unref(currentFrame)) + " / " + toDisplayString(unref(frameCount)) + " (" + toDisplayString(formattedTime.value) + ") ", 1)
          ]),
          createBaseVNode("div", _hoisted_11$g, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "section-header" }, "Particle Cache", -1)),
            particleLayers.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_12$e, " No particle layers in composition ")) : (openBlock(), createElementBlock("div", _hoisted_13$e, [
              createBaseVNode("div", _hoisted_14$d, [
                createBaseVNode("button", {
                  class: "cache-btn",
                  onClick: cacheWorkArea,
                  disabled: isCaching.value,
                  title: "Pre-cache particle frames for smooth playback"
                }, toDisplayString(isCaching.value ? "Caching..." : "Cache Work Area"), 9, _hoisted_15$c),
                createBaseVNode("button", {
                  class: "cache-btn secondary",
                  onClick: clearAllCaches,
                  disabled: isCaching.value,
                  title: "Clear all cached particle frames"
                }, " Clear Cache ", 8, _hoisted_16$b)
              ]),
              isCaching.value ? (openBlock(), createElementBlock("div", _hoisted_17$b, [
                createBaseVNode("div", _hoisted_18$b, [
                  createBaseVNode("div", {
                    class: "progress-fill",
                    style: normalizeStyle({ width: `${cacheProgress.value}%` })
                  }, null, 4)
                ]),
                createBaseVNode("span", _hoisted_19$b, toDisplayString(cacheProgressText.value), 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_20$b, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(particleLayers.value, (layer) => {
                  return openBlock(), createElementBlock("div", {
                    key: layer.id,
                    class: "layer-cache-info"
                  }, [
                    createBaseVNode("span", _hoisted_21$b, toDisplayString(layer.name), 1),
                    createBaseVNode("span", _hoisted_22$b, toDisplayString(getCacheCount(layer.id)) + " frames cached", 1)
                  ]);
                }), 128))
              ])
            ]))
          ]),
          createBaseVNode("div", _hoisted_23$b, [
            _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-header" }, "Preview Quality", -1)),
            createBaseVNode("div", _hoisted_24$8, [
              _cache[12] || (_cache[12] = createBaseVNode("label", null, "Resolution:", -1)),
              withDirectives(createBaseVNode("select", {
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => previewResolution.value = $event),
                class: "quality-select"
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("option", { value: 1 }, "Full (100%)", -1),
                createBaseVNode("option", { value: 0.5 }, "Half (50%)", -1),
                createBaseVNode("option", { value: 0.25 }, "Quarter (25%)", -1),
                createBaseVNode("option", { value: 0.125 }, "Eighth (12.5%)", -1)
              ])], 512), [
                [vModelSelect, previewResolution.value]
              ])
            ]),
            createBaseVNode("div", _hoisted_25$7, [
              createBaseVNode("label", null, [
                withDirectives(createBaseVNode("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => adaptiveQuality.value = $event)
                }, null, 512), [
                  [vModelCheckbox, adaptiveQuality.value]
                ]),
                _cache[13] || (_cache[13] = createTextVNode(" Adaptive (reduce during playback) ", -1))
              ])
            ])
          ])
        ])
      ]);
    };
  }
});

const PreviewPanel = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-443383d6"]]);

const SYSTEM_PROMPT$1 = `You are an expert motion graphics compositor AI agent. You have full control over a professional motion graphics application called Weyl Compositor. You can create, modify, and animate any element in the composition.

## Your Capabilities

You can perform ANY motion graphics task including:
- Creating layers (solid colors, text, shapes, particles, images, nested compositions)
- Animating properties with keyframes (position, scale, rotation, opacity, etc.)
- Applying effects (blur, glow, color correction, distortion, etc.)
- Creating particle systems with custom behaviors
- Animating text along paths
- Setting up 3D camera movements
- Using expressions for dynamic animations
- Time remapping and speed adjustments

## Composition Settings

- **Duration**: 81 frames at 16fps (5.0625 seconds) - optimized for Wan 2.1 video generation
- **Dimensions**: Must be divisible by 8 (e.g., 1024x576, 1280x720)
- **Frame Range**: 0-80 (81 frames total)
- **Coordinate System**: Origin (0,0) at top-left, Y increases downward

## Layer Types

### 1. Solid Layer
A rectangle filled with a solid color. Base for many effects.
\`\`\`
Properties:
- color: { r: 0-255, g: 0-255, b: 0-255, a: 0-1 }
\`\`\`

### 2. Text Layer
Animated text with full typography control.
\`\`\`
Properties:
- text: string
- fontSize: number (pixels)
- fontFamily: string
- fontWeight: 100-900
- color: { r, g, b, a }
- alignment: 'left' | 'center' | 'right'
- lineHeight: number (multiplier)
- letterSpacing: number (pixels)
- textPath: reference to spline layer (for text-on-path)
\`\`\`

### 3. Shape Layer
Vector shapes with fill and stroke.
\`\`\`
Properties:
- shapes: array of shape definitions
- fill: { color, opacity }
- stroke: { color, width, opacity }

Shape types:
- rectangle: { width, height, roundness }
- ellipse: { width, height }
- polygon: { points, radius }
- star: { points, innerRadius, outerRadius }
- path: { points: [{x, y, handleIn, handleOut}] }
\`\`\`

### 4. Spline Layer
Bezier curves for motion paths, text paths, or visual elements.
\`\`\`
Properties:
- points: array of control points
- closed: boolean
- strokeWidth: number
- strokeColor: { r, g, b, a }
\`\`\`

### 5. Particle Layer
Particle systems for effects like snow, rain, dust, petals, sparks.
\`\`\`
Properties:
- emitter:
  - type: 'point' | 'line' | 'box' | 'circle' | 'path'
  - position: { x, y }
  - size: { width, height }
  - pathReference: layer ID for path-based emission
- particles:
  - count: number
  - lifetime: { min, max } in frames
  - speed: { min, max }
  - direction: { min, max } in degrees
  - spread: degrees
  - size: { start, end }
  - opacity: { start, end }
  - color: { start, end } or gradient
  - rotation: { initial, speed }
  - sprite: 'circle' | 'square' | 'star' | 'custom'
- physics:
  - gravity: { x, y }
  - wind: { x, y }
  - turbulence: { strength, scale, speed }
  - friction: 0-1
- rendering:
  - blendMode: 'normal' | 'add' | 'screen' | 'multiply'
  - motionBlur: boolean
\`\`\`

### 6. Image Layer
Static or animated images.
\`\`\`
Properties:
- src: URL or base64
- fit: 'fill' | 'contain' | 'cover'
\`\`\`

### 7. Camera Layer
3D camera for depth-based compositions.
\`\`\`
Properties:
- position: { x, y, z }
- lookTarget: { x, y, z } (formerly "point of interest")
- fov: field of view in degrees
- zoom: multiplier
\`\`\`

### 8. Control Layer (formerly Null)
Invisible layer used as parent for grouping/controlling other layers.
\`\`\`
Properties:
- (transform only - no visual properties)
\`\`\`

### 9. Nested Composition Layer
Embeds another composition as a layer.
\`\`\`
Properties:
- compositionId: reference to nested composition
- flattenTransform: boolean (flattens child transforms into parent)
\`\`\`

## AI-Decomposed Layers

When the user decomposes an image using AI Layer Decomposition, it creates multiple RGBA layers from a single image. These layers have semantic labels that help you understand their content:

### Common Decomposed Layer Labels
- **Background (Solid)**: Full-coverage solid background
- **Background (Sky)**: Upper region, typically sky or environment
- **Background**: General background content
- **Back Elements (N)**: Elements in the back depth plane
- **Mid Elements (N)**: Middle depth elements
- **Front Elements (N)**: Closer elements
- **Edges/Outlines (N)**: Edge detection / line work
- **Sparse Elements (N)**: Small scattered details
- **Upper Details (N)**: Details in the top region
- **Lower Details (N)**: Details in the bottom region
- **Solid Region (N)**: Dense opaque areas
- **Foreground (Subject)**: Main subject / hero element
- **Foreground (Details)**: Fine foreground details

### Working with Decomposed Layers
1. **Layer Order**: Layers are stacked from back to front (Background at bottom)
2. **Alpha Channels**: All decomposed layers have alpha transparency
3. **Grouped**: Usually in a nested composition called "Decomposed (N layers)"
4. **Independent Animation**: Each layer can be animated separately for parallax effects
5. **Depth Perception**: Animate back layers slower than front layers for depth

### Example: Parallax Animation on Decomposed Image
\`\`\`
For a decomposed landscape with Background, Mid Elements, and Foreground:
1. Background layer: Slow pan (10% movement)
2. Mid Elements: Medium pan (50% movement)
3. Foreground: Full pan (100% movement)
This creates a parallax depth effect.
\`\`\`

### Example: Selective Effects on Decomposed Layers
\`\`\`
To focus attention on subject:
1. Apply gaussianBlur to Background layer (radius: 5)
2. Keep Foreground (Subject) sharp
3. Add slight glow to Foreground (Subject)
\`\`\`

## Transform Properties (All Layers)

Every layer has these animatable transform properties:
\`\`\`
- position: { x: number, y: number }
- anchorPoint: { x: number, y: number } (pivot point for rotation/scale)
- scale: { x: percent, y: percent } (100 = 100%)
- rotation: degrees
- opacity: 0-100
- inPoint: frame number (when layer appears)
- outPoint: frame number (when layer disappears)
\`\`\`

## Keyframe Animation

To animate any property:
1. Create a keyframe at a specific frame with a value
2. Create another keyframe at a different frame with a different value
3. The compositor interpolates between them

\`\`\`
Keyframe structure:
{
  frame: 0-80,
  value: (depends on property type),
  interpolation: 'linear' | 'bezier' | 'hold' | 'easeIn' | 'easeOut' | 'easeInOut',
  inHandle: { frame: offset, value: offset },   // For bezier curves
  outHandle: { frame: offset, value: offset }
}
\`\`\`

### Interpolation Types
- **linear**: Constant speed between keyframes
- **bezier**: Custom easing curve (use handles)
- **hold**: Jump instantly to value (no interpolation)
- **easeIn**: Start slow, accelerate
- **easeOut**: Start fast, decelerate
- **easeInOut**: Slow at both ends (smooth)
- **easeInQuad/Cubic/Quart/Quint**: Progressively stronger ease-in
- **easeOutQuad/Cubic/Quart/Quint**: Progressively stronger ease-out
- **easeInOutQuad/Cubic/Quart/Quint**: Progressively stronger ease-in-out
- **easeInElastic/easeOutElastic**: Bouncy overshoot
- **easeInBounce/easeOutBounce**: Ball bounce effect

## Expression Functions

Expressions add dynamic behavior to animations. Available functions:

### Motion Expressions
- **jitter(frequency, amplitude, octaves)**: Random wiggle motion (formerly "wiggle")
- **inertia(amplitude, frequency, decay)**: Momentum overshoot after keyframes
- **bounce(elasticity, gravity)**: Bouncing settle
- **elastic(amplitude, period)**: Spring-like oscillation

### Loop Expressions
- **repeatAfter(type, numKeyframes)**: Loop after last keyframe (formerly "loopOut")
  - type: 'cycle' | 'pingpong' | 'offset' | 'continue'
- **repeatBefore(type, numKeyframes)**: Loop before first keyframe (formerly "loopIn")

### Time Expressions
- **timeRamp(startTime, endTime, startValue, endValue)**: Linear value over time
- **sine(frequency, amplitude, phase)**: Sinusoidal oscillation
- **sawtooth(frequency, amplitude)**: Sawtooth wave
- **triangle(frequency, amplitude)**: Triangle wave

## Effects

Effects modify layer appearance. Apply to any layer:

### Blur Effects
- **gaussianBlur**: { radius: pixels }
- **motionBlur**: { angle: degrees, distance: pixels }
- **radialBlur**: { amount, center: {x, y} }
- **zoomBlur**: { amount, center: {x, y} }

### Color Effects
- **brightnessContrast**: { brightness: -100 to 100, contrast: -100 to 100 }
- **hueSaturation**: { hue: -180 to 180, saturation: -100 to 100, lightness: -100 to 100 }
- **colorBalance**: { shadows, midtones, highlights }
- **tint**: { color, amount }

### Stylize Effects
- **glow**: { threshold, radius, intensity, color }
- **dropShadow**: { color, opacity, angle, distance, blur }
- **stroke**: { color, width, position: 'outside' | 'inside' | 'center' }

### Distortion Effects
- **bulge**: { center, radius, amount }
- **twirl**: { center, radius, angle }
- **wave**: { type, amplitude, frequency, phase }
- **displacement**: { source, amount }

### Generate Effects
- **gradient**: { type: 'linear' | 'radial', colors, positions }
- **fractalNoise**: { type, scale, complexity, evolution }
- **checkerboard**: { size, color1, color2 }

## Time Remapping

To change the speed of a layer's animation:
\`\`\`
timeRemap: {
  enabled: true,
  keyframes: [
    { frame: 0, value: 0 },      // At frame 0, show frame 0
    { frame: 40, value: 80 },    // At frame 40, show frame 80 (2x speed)
    { frame: 80, value: 80 }     // Hold on frame 80
  ]
}
\`\`\`

- To speed up: Map more source frames to fewer output frames
- To slow down: Map fewer source frames to more output frames
- To reverse: Map from high to low values
- To freeze: Hold the same value across multiple frames

## Chain of Thought Process

When processing a user request, ALWAYS think step-by-step:

### Step 1: Understand the Request
- What is the user trying to create or modify?
- What elements are involved (layers, effects, animations)?
- What is the timing/duration?
- What is the motion path or trajectory?

### Step 2: Break Down into Tasks
- List each discrete action needed
- Identify dependencies (e.g., create layer before animating it)
- Determine the order of operations

### Step 3: Plan the Implementation
- Which layers need to be created?
- What properties need keyframes?
- What easing/interpolation is appropriate?
- Are expressions needed for dynamic behavior?

### Step 4: Execute with Tools
- Use the appropriate tool for each task
- Create layers first, then animate them
- Apply effects after base animation is set

### Step 5: Verify and Refine
- Check that the result matches the intent
- Look for issues (timing, positioning, easing)
- Make adjustments as needed

## Example Requests and Responses

### Example 1: Simple Text Animation
User: "Fade in the title over 1 second"

Thinking:
1. Need to find or create a text layer
2. Set opacity to 0 at frame 0
3. Set opacity to 100 at frame 16 (1 second at 16fps)
4. Use easeOut for smooth fade

Actions:
1. addKeyframe(layerId, "opacity", 0, 0, "hold")
2. addKeyframe(layerId, "opacity", 16, 100, "easeOut")

### Example 2: Particle Path Animation
User: "Create cherry blossom petals that enter from the left, spiral around the center, and exit right"

Thinking:
1. Create a spline layer defining the spiral path
2. Create a particle layer with petal-like particles
3. Set emitter to follow the path
4. Configure particle appearance (pink, small, rotating)
5. Time the animation: enter 0-20, spiral 20-60, exit 60-80

Actions:
1. createLayer("spline", { points: [...spiral path...] })
2. createLayer("particles", {
     emitter: { type: "path", pathReference: splineId },
     particles: {
       sprite: "custom", // petal shape
       color: { start: {r:255,g:182,b:193}, end: {r:255,g:105,b:180} },
       size: { start: 8, end: 4 },
       rotation: { initial: 0, speed: 180 }
     }
   })
3. Animate emitter position along path with keyframes

### Example 3: Speed Adjustment
User: "Make it faster"

Thinking:
1. User wants to speed up existing animation
2. Need to identify what "it" refers to (context from conversation)
3. Apply time remapping or adjust keyframe timing
4. Typically 2x speed means halving the frame numbers

Actions:
1. For each animated property, compress keyframe timing
   OR
2. Apply timeRemap to compress the timeline

## Important Guidelines

1. **Be Precise**: Use exact values, not vague descriptions
2. **Consider Timing**: 16fps means 16 frames = 1 second
3. **Use Appropriate Easing**: Match the motion feel to the content
4. **Layer Organization**: Name layers descriptively, use control layers for grouping
5. **Performance**: Keep particle counts reasonable (<1000 for smooth playback)
6. **Verify Changes**: After making changes, confirm they match the user's intent

## Error Handling

If you encounter an error:
1. Report what went wrong clearly
2. Suggest an alternative approach
3. Ask for clarification if the request is ambiguous

If the user's request is unclear:
1. Ask clarifying questions
2. Provide options for interpretation
3. Start with a reasonable default and offer to adjust

You are a creative partner. Help users bring their vision to life with professional motion graphics.`;

const TOOL_DEFINITIONS = [
  // ==========================================================================
  // LAYER MANAGEMENT
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "createLayer",
      description: "Create a new layer in the composition. Returns the new layer ID.",
      parameters: {
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["solid", "text", "shape", "spline", "particles", "image", "camera", "control", "nested"],
            description: "The type of layer to create"
          },
          name: {
            type: "string",
            description: "Display name for the layer"
          },
          properties: {
            type: "object",
            description: "Initial properties for the layer (type-specific)"
          },
          position: {
            type: "object",
            properties: {
              x: { type: "number" },
              y: { type: "number" }
            },
            description: "Initial position"
          },
          inPoint: {
            type: "number",
            description: "Frame where layer appears (default: 0)"
          },
          outPoint: {
            type: "number",
            description: "Frame where layer disappears (default: composition duration)"
          }
        },
        required: ["type"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "deleteLayer",
      description: "Delete a layer from the composition",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to delete"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "duplicateLayer",
      description: "Create a copy of an existing layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to duplicate"
          },
          newName: {
            type: "string",
            description: "Name for the duplicated layer"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "renameLayer",
      description: "Change the display name of a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to rename"
          },
          name: {
            type: "string",
            description: "New name for the layer"
          }
        },
        required: ["layerId", "name"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setLayerParent",
      description: "Set a layer's parent (for hierarchical transforms)",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the child layer"
          },
          parentId: {
            type: "string",
            description: "ID of the parent layer (null to unparent)",
            nullable: true
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "reorderLayers",
      description: "Change the stacking order of layers",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer to move"
          },
          newIndex: {
            type: "number",
            description: "New index in the layer stack (0 = top)"
          }
        },
        required: ["layerId", "newIndex"]
      }
    }
  },
  // ==========================================================================
  // PROPERTY MODIFICATION
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setLayerProperty",
      description: "Set a property value on a layer (non-animated)",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: 'Dot-notation path to property (e.g., "position.x", "opacity", "text")'
          },
          value: {
            description: "Value to set (type depends on property)"
          }
        },
        required: ["layerId", "propertyPath", "value"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setLayerTransform",
      description: "Set multiple transform properties at once",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          position: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          },
          scale: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          },
          rotation: {
            type: "number",
            description: "Rotation in degrees"
          },
          opacity: {
            type: "number",
            description: "Opacity 0-100"
          },
          anchorPoint: {
            type: "object",
            properties: { x: { type: "number" }, y: { type: "number" } }
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // KEYFRAME ANIMATION
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "addKeyframe",
      description: "Add a keyframe to animate a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: 'Property to animate (e.g., "position", "opacity", "scale")'
          },
          frame: {
            type: "number",
            description: "Frame number (0-80)"
          },
          value: {
            description: "Value at this keyframe"
          },
          interpolation: {
            type: "string",
            enum: [
              "linear",
              "bezier",
              "hold",
              "easeIn",
              "easeOut",
              "easeInOut",
              "easeInQuad",
              "easeOutQuad",
              "easeInOutQuad",
              "easeInCubic",
              "easeOutCubic",
              "easeInOutCubic",
              "easeInElastic",
              "easeOutElastic",
              "easeOutBounce"
            ],
            description: "Interpolation type (default: linear)"
          }
        },
        required: ["layerId", "propertyPath", "frame", "value"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeKeyframe",
      description: "Remove a keyframe from a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property path"
          },
          frame: {
            type: "number",
            description: "Frame number of keyframe to remove"
          }
        },
        required: ["layerId", "propertyPath", "frame"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setKeyframeEasing",
      description: "Change the interpolation of an existing keyframe",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property path"
          },
          frame: {
            type: "number",
            description: "Frame number of keyframe"
          },
          interpolation: {
            type: "string",
            description: "New interpolation type"
          }
        },
        required: ["layerId", "propertyPath", "frame", "interpolation"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "scaleKeyframeTiming",
      description: "Scale all keyframes on a layer to speed up or slow down animation",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          scaleFactor: {
            type: "number",
            description: "Scale factor (0.5 = 2x faster, 2.0 = 2x slower)"
          },
          propertyPath: {
            type: "string",
            description: "Specific property to scale (omit for all properties)"
          }
        },
        required: ["layerId", "scaleFactor"]
      }
    }
  },
  // ==========================================================================
  // EXPRESSIONS
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setExpression",
      description: "Apply an expression to a property for dynamic animation",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property to apply expression to"
          },
          expressionType: {
            type: "string",
            enum: ["jitter", "repeatAfter", "repeatBefore", "inertia", "bounce", "elastic"],
            description: "Type of expression"
          },
          params: {
            type: "object",
            description: "Expression parameters (varies by type)"
          }
        },
        required: ["layerId", "propertyPath", "expressionType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeExpression",
      description: "Remove an expression from a property",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          propertyPath: {
            type: "string",
            description: "Property to remove expression from"
          }
        },
        required: ["layerId", "propertyPath"]
      }
    }
  },
  // ==========================================================================
  // EFFECTS
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "addEffect",
      description: "Add an effect to a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectType: {
            type: "string",
            enum: [
              "gaussianBlur",
              "motionBlur",
              "radialBlur",
              "zoomBlur",
              "brightnessContrast",
              "hueSaturation",
              "colorBalance",
              "tint",
              "glow",
              "dropShadow",
              "stroke",
              "bulge",
              "twirl",
              "wave",
              "displacement",
              "gradient",
              "fractalNoise",
              "checkerboard"
            ],
            description: "Type of effect"
          },
          params: {
            type: "object",
            description: "Effect parameters"
          }
        },
        required: ["layerId", "effectType"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "updateEffect",
      description: "Update parameters of an existing effect",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectId: {
            type: "string",
            description: "ID of the effect"
          },
          params: {
            type: "object",
            description: "Parameters to update"
          }
        },
        required: ["layerId", "effectId", "params"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "removeEffect",
      description: "Remove an effect from a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          effectId: {
            type: "string",
            description: "ID of the effect to remove"
          }
        },
        required: ["layerId", "effectId"]
      }
    }
  },
  // ==========================================================================
  // PARTICLE SYSTEM
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "configureParticles",
      description: "Configure a particle layer's emission and behavior",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the particle layer"
          },
          emitter: {
            type: "object",
            properties: {
              type: { type: "string", enum: ["point", "line", "box", "circle", "path"] },
              position: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              size: { type: "object", properties: { width: { type: "number" }, height: { type: "number" } } },
              pathReference: { type: "string" }
            }
          },
          particles: {
            type: "object",
            properties: {
              count: { type: "number" },
              lifetime: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              speed: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              direction: { type: "object", properties: { min: { type: "number" }, max: { type: "number" } } },
              size: { type: "object", properties: { start: { type: "number" }, end: { type: "number" } } },
              opacity: { type: "object", properties: { start: { type: "number" }, end: { type: "number" } } },
              color: { type: "object" },
              rotation: { type: "object", properties: { initial: { type: "number" }, speed: { type: "number" } } }
            }
          },
          physics: {
            type: "object",
            properties: {
              gravity: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              wind: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } } },
              turbulence: { type: "object", properties: { strength: { type: "number" }, scale: { type: "number" } } }
            }
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // TEXT SPECIFIC
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setTextContent",
      description: "Set the text content and styling of a text layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the text layer"
          },
          text: {
            type: "string",
            description: "Text content"
          },
          fontSize: {
            type: "number",
            description: "Font size in pixels"
          },
          fontFamily: {
            type: "string",
            description: "Font family name"
          },
          fontWeight: {
            type: "number",
            description: "Font weight (100-900)"
          },
          color: {
            type: "object",
            properties: { r: { type: "number" }, g: { type: "number" }, b: { type: "number" }, a: { type: "number" } }
          },
          alignment: {
            type: "string",
            enum: ["left", "center", "right"]
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "setTextPath",
      description: "Attach text to follow a spline path",
      parameters: {
        type: "object",
        properties: {
          textLayerId: {
            type: "string",
            description: "ID of the text layer"
          },
          splineLayerId: {
            type: "string",
            description: "ID of the spline layer to follow (null to detach)",
            nullable: true
          },
          startOffset: {
            type: "number",
            description: "Starting position along path (0-1)"
          }
        },
        required: ["textLayerId"]
      }
    }
  },
  // ==========================================================================
  // SPLINE/PATH
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setSplinePoints",
      description: "Set the control points of a spline layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the spline layer"
          },
          points: {
            type: "array",
            items: {
              type: "object",
              properties: {
                x: { type: "number" },
                y: { type: "number" },
                handleIn: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } }, nullable: true },
                handleOut: { type: "object", properties: { x: { type: "number" }, y: { type: "number" } }, nullable: true }
              }
            },
            description: "Array of control points"
          },
          closed: {
            type: "boolean",
            description: "Whether the path is closed"
          }
        },
        required: ["layerId", "points"]
      }
    }
  },
  // ==========================================================================
  // TIME REMAPPING
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setTimeRemap",
      description: "Enable time remapping on a layer to control playback speed",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          },
          enabled: {
            type: "boolean",
            description: "Enable or disable time remapping"
          },
          keyframes: {
            type: "array",
            items: {
              type: "object",
              properties: {
                frame: { type: "number", description: "Output frame" },
                value: { type: "number", description: "Source frame to show" },
                interpolation: { type: "string" }
              }
            },
            description: "Time remap keyframes"
          }
        },
        required: ["layerId"]
      }
    }
  },
  // ==========================================================================
  // PLAYBACK CONTROL
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "setCurrentFrame",
      description: "Jump to a specific frame",
      parameters: {
        type: "object",
        properties: {
          frame: {
            type: "number",
            description: "Frame number (0-80)"
          }
        },
        required: ["frame"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "playPreview",
      description: "Start or stop playback preview",
      parameters: {
        type: "object",
        properties: {
          play: {
            type: "boolean",
            description: "True to play, false to stop"
          }
        },
        required: ["play"]
      }
    }
  },
  // ==========================================================================
  // AI IMAGE PROCESSING
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "decomposeImage",
      description: "Use AI to decompose an image into multiple RGBA layers (requires Qwen-Image-Layered model). Creates separate image layers for background, foreground, and intermediate elements.",
      parameters: {
        type: "object",
        properties: {
          sourceLayerId: {
            type: "string",
            description: "ID of the image layer to decompose"
          },
          numLayers: {
            type: "number",
            description: "Number of layers to generate (3-16, default 4)",
            minimum: 3,
            maximum: 16
          }
        },
        required: ["sourceLayerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "vectorizeImage",
      description: "Convert an image layer to vector spline paths. Creates one or more SplineLayer(s) with keyframeable control points that can be animated individually, by group, or as a whole layer. Ideal for logos, icons, and graphics.",
      parameters: {
        type: "object",
        properties: {
          sourceLayerId: {
            type: "string",
            description: "ID of the image layer to vectorize"
          },
          mode: {
            type: "string",
            enum: ["trace", "ai"],
            description: 'Vectorization mode: "trace" (VTracer, fast, works on any image) or "ai" (StarVector, best for icons/logos)'
          },
          separateLayers: {
            type: "boolean",
            description: "Create separate layer for each path (default: true)"
          },
          groupByPath: {
            type: "boolean",
            description: "Assign group IDs to control points for group animation (default: true)"
          },
          autoGroupByRegion: {
            type: "boolean",
            description: "Auto-group points by quadrant region (default: false)"
          },
          enableAnimation: {
            type: "boolean",
            description: "Enable keyframe animation on created layers (default: true)"
          },
          traceOptions: {
            type: "object",
            description: 'VTracer-specific options (only used if mode is "trace")',
            properties: {
              colorMode: {
                type: "string",
                enum: ["color", "binary"],
                description: 'Color mode: "color" for full color, "binary" for black & white'
              },
              filterSpeckle: {
                type: "number",
                description: "Filter speckle size (0-100, default 4)"
              },
              cornerThreshold: {
                type: "number",
                description: "Corner threshold in degrees (0-180, default 60)"
              },
              colorPrecision: {
                type: "number",
                description: "Color precision (1-10, default 6)"
              },
              layerDifference: {
                type: "number",
                description: "Layer difference threshold (1-256, default 16)"
              }
            }
          }
        },
        required: ["sourceLayerId"]
      }
    }
  },
  // ==========================================================================
  // UTILITY
  // ==========================================================================
  {
    type: "function",
    function: {
      name: "getLayerInfo",
      description: "Get detailed information about a layer",
      parameters: {
        type: "object",
        properties: {
          layerId: {
            type: "string",
            description: "ID of the layer"
          }
        },
        required: ["layerId"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "findLayers",
      description: "Find layers by name or type",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "Layer name to search for (partial match)"
          },
          type: {
            type: "string",
            description: "Layer type to filter by"
          }
        }
      }
    }
  },
  {
    type: "function",
    function: {
      name: "getProjectState",
      description: "Get a summary of the current project state",
      parameters: {
        type: "object",
        properties: {}
      }
    }
  }
];

async function executeToolCall(toolCall) {
  const store = useCompositorStore();
  const playbackStore = usePlaybackStore();
  useSelectionStore();
  const context = { store, playbackStore};
  const { name, arguments: args } = toolCall;
  switch (name) {
    case "createLayer":
      return executeCreateLayer(context, args);
    case "deleteLayer":
      return executeDeleteLayer(context, args);
    case "duplicateLayer":
      return executeDuplicateLayer(context, args);
    case "renameLayer":
      return executeRenameLayer(context, args);
    case "setLayerParent":
      return executeSetLayerParent(context, args);
    case "reorderLayers":
      return executeReorderLayers(context, args);
    case "setLayerProperty":
      return executeSetLayerProperty(context, args);
    case "setLayerTransform":
      return executeSetLayerTransform(context, args);
    case "addKeyframe":
      return executeAddKeyframe(context, args);
    case "removeKeyframe":
      return executeRemoveKeyframe(context, args);
    case "setKeyframeEasing":
      return executeSetKeyframeEasing(context, args);
    case "scaleKeyframeTiming":
      return executeScaleKeyframeTiming(context, args);
    case "setExpression":
      return executeSetExpression(context, args);
    case "removeExpression":
      return executeRemoveExpression(context, args);
    case "addEffect":
      return executeAddEffect(context, args);
    case "updateEffect":
      return executeUpdateEffect(context, args);
    case "removeEffect":
      return executeRemoveEffect(context, args);
    case "configureParticles":
      return executeConfigureParticles(context, args);
    case "setTextContent":
      return executeSetTextContent(context, args);
    case "setTextPath":
      return executeSetTextPath(context, args);
    case "setSplinePoints":
      return executeSetSplinePoints(context, args);
    case "setTimeRemap":
      return executeSetTimeRemap(context, args);
    case "setCurrentFrame":
      return executeSetCurrentFrame(context, args);
    case "playPreview":
      return executePlayPreview(context, args);
    case "decomposeImage":
      return executeDecomposeImage(context, args);
    case "vectorizeImage":
      return executeVectorizeImage(context, args);
    case "getLayerInfo":
      return executeGetLayerInfo(context, args);
    case "findLayers":
      return executeFindLayers(context, args);
    case "getProjectState":
      return executeGetProjectState(context);
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}
function executeCreateLayer(context, args) {
  const { store } = context;
  const { type, name, properties, position, inPoint, outPoint } = args;
  const typeMap = {
    solid: "solid",
    text: "text",
    shape: "shape",
    spline: "spline",
    particles: "particles",
    image: "image",
    camera: "camera",
    control: "null",
    // Control layer maps to null type
    nested: "nestedComp"
  };
  const internalType = typeMap[type] || type;
  const layer = createLayer(store, internalType, name);
  if (position) {
    layer.transform.position.value = position;
  }
  if (inPoint !== void 0) {
    layer.inPoint = inPoint;
  }
  if (outPoint !== void 0) {
    layer.outPoint = outPoint;
  }
  if (properties) {
    Object.assign(layer.data || {}, properties);
  }
  return {
    layerId: layer.id,
    message: `Created ${type} layer "${layer.name}" with ID ${layer.id}`
  };
}
function executeDeleteLayer(context, args) {
  const { store } = context;
  const { layerId } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const layerName = layer.name;
  deleteLayer(store, layerId);
  return {
    success: true,
    message: `Deleted layer "${layerName}"`
  };
}
function executeDuplicateLayer(context, args) {
  const { store } = context;
  const { layerId, newName } = args;
  const duplicate = duplicateLayer(store, layerId);
  if (!duplicate) {
    return { layerId: null, message: `Failed to duplicate layer ${layerId}` };
  }
  if (newName) {
    duplicate.name = newName;
  }
  return {
    layerId: duplicate.id,
    message: `Duplicated layer as "${duplicate.name}" with ID ${duplicate.id}`
  };
}
function executeRenameLayer(context, args) {
  const { store } = context;
  const { layerId, name } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const oldName = layer.name;
  layer.name = name;
  return {
    success: true,
    message: `Renamed layer from "${oldName}" to "${name}"`
  };
}
function executeSetLayerParent(context, args) {
  const { store } = context;
  const { layerId, parentId } = args;
  setLayerParent(store, layerId, parentId || null);
  return {
    success: true,
    message: parentId ? `Set parent of layer ${layerId} to ${parentId}` : `Removed parent from layer ${layerId}`
  };
}
function executeReorderLayers(context, args) {
  const { store } = context;
  const { layerId, newIndex } = args;
  moveLayer(store, layerId, newIndex);
  return {
    success: true,
    message: `Moved layer ${layerId} to index ${newIndex}`
  };
}
function executeSetLayerProperty(context, args) {
  const { store } = context;
  const { layerId, propertyPath, value } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const parts = propertyPath.split(".");
  if (parts[0] === "data" && layer.data) {
    setNestedProperty(layer.data, parts.slice(1), value);
  } else if (parts[0] === "transform") {
    const prop = layer.transform[parts[1]];
    if (prop && "value" in prop) {
      prop.value = value;
    }
  } else if (propertyPath === "opacity") {
    layer.opacity.value = value;
  } else if (propertyPath === "visible") {
    layer.visible = value;
  } else if (propertyPath === "locked") {
    layer.locked = value;
  } else if (propertyPath === "inPoint") {
    layer.inPoint = value;
  } else if (propertyPath === "outPoint") {
    layer.outPoint = value;
  } else {
    if (layer.data) {
      setNestedProperty(layer.data, parts, value);
    }
  }
  return {
    success: true,
    message: `Set ${propertyPath} to ${JSON.stringify(value)}`
  };
}
function executeSetLayerTransform(context, args) {
  const { store } = context;
  const { layerId, position, scale, rotation, opacity, anchorPoint } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const changes = [];
  if (position !== void 0) {
    layer.transform.position.value = position;
    changes.push("position");
  }
  if (scale !== void 0) {
    layer.transform.scale.value = scale;
    changes.push("scale");
  }
  if (rotation !== void 0) {
    layer.transform.rotation.value = rotation;
    changes.push("rotation");
  }
  if (opacity !== void 0) {
    layer.opacity.value = opacity;
    changes.push("opacity");
  }
  if (anchorPoint !== void 0) {
    layer.transform.anchorPoint.value = anchorPoint;
    changes.push("anchorPoint");
  }
  return {
    success: true,
    message: `Updated transform: ${changes.join(", ")}`
  };
}
function executeAddKeyframe(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame, value, interpolation } = args;
  const keyframe = addKeyframe(store, layerId, propertyPath, value, frame);
  if (!keyframe) {
    return { keyframeId: null, message: `Failed to add keyframe at frame ${frame}` };
  }
  if (interpolation && keyframe) {
    setKeyframeInterpolation(
      store,
      layerId,
      propertyPath,
      keyframe.id,
      interpolation
    );
  }
  return {
    keyframeId: keyframe.id,
    message: `Added keyframe at frame ${frame} for ${propertyPath}`
  };
}
function executeRemoveKeyframe(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  const keyframe = property.keyframes.find((k) => k.frame === frame);
  if (!keyframe) {
    return { success: false, message: `No keyframe at frame ${frame}` };
  }
  removeKeyframe(store, layerId, propertyPath, keyframe.id);
  return {
    success: true,
    message: `Removed keyframe at frame ${frame} from ${propertyPath}`
  };
}
function executeSetKeyframeEasing(context, args) {
  const { store } = context;
  const { layerId, propertyPath, frame, interpolation } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  const keyframe = property.keyframes.find((k) => k.frame === frame);
  if (!keyframe) {
    return { success: false, message: `No keyframe at frame ${frame}` };
  }
  setKeyframeInterpolation(
    store,
    layerId,
    propertyPath,
    keyframe.id,
    interpolation
  );
  return {
    success: true,
    message: `Set interpolation to ${interpolation} at frame ${frame}`
  };
}
function executeScaleKeyframeTiming(context, args) {
  const { store } = context;
  const { layerId, scaleFactor, propertyPath } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const propertiesToScale = propertyPath ? [propertyPath] : ["position", "scale", "rotation", "opacity", "anchorPoint"];
  let scaledCount = 0;
  for (const propPath of propertiesToScale) {
    const property = findPropertyByPath(layer, propPath);
    if (property?.keyframes && property.keyframes.length > 0) {
      for (const kf of property.keyframes) {
        kf.frame = Math.round(kf.frame * scaleFactor);
      }
      property.keyframes.sort((a, b) => a.frame - b.frame);
      scaledCount += property.keyframes.length;
    }
  }
  return {
    success: true,
    message: `Scaled ${scaledCount} keyframes by factor ${scaleFactor}`
  };
}
function executeSetExpression(context, args) {
  const { store } = context;
  const { layerId, propertyPath, expressionType, params } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  property.expression = {
    enabled: true,
    type: "preset",
    name: expressionType,
    params: params || {}
  };
  return {
    success: true,
    message: `Applied ${expressionType} expression to ${propertyPath}`
  };
}
function executeRemoveExpression(context, args) {
  const { store } = context;
  const { layerId, propertyPath } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  const property = findPropertyByPath(layer, propertyPath);
  if (!property) {
    return { success: false, message: `Property ${propertyPath} not found` };
  }
  property.expression = void 0;
  return {
    success: true,
    message: `Removed expression from ${propertyPath}`
  };
}
function executeAddEffect(context, args) {
  const { store } = context;
  const { layerId, effectType, params } = args;
  addEffectToLayer(store, layerId, effectType);
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  const effect = layer?.effects?.[layer.effects.length - 1];
  if (!effect) {
    return { effectId: null, message: `Failed to add effect ${effectType}` };
  }
  if (params) {
    for (const [key, value] of Object.entries(params)) {
      updateEffectParameter(store, layerId, effect.id, key, value);
    }
  }
  return {
    effectId: effect.id,
    message: `Added ${effectType} effect to layer`
  };
}
function executeUpdateEffect(context, args) {
  const { store } = context;
  const { layerId, effectId, params } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer?.effects) {
    return { success: false, message: `Layer ${layerId} not found or has no effects` };
  }
  const effect = layer.effects.find((e) => e.id === effectId);
  if (!effect) {
    return { success: false, message: `Effect ${effectId} not found` };
  }
  for (const [key, value] of Object.entries(params)) {
    updateEffectParameter(store, layerId, effectId, key, value);
  }
  return {
    success: true,
    message: `Updated ${Object.keys(params).length} effect parameters`
  };
}
function executeRemoveEffect(context, args) {
  const { store } = context;
  const { layerId, effectId } = args;
  removeEffectFromLayer(store, layerId, effectId);
  return {
    success: true,
    message: `Removed effect ${effectId}`
  };
}
function executeConfigureParticles(context, args) {
  const { store } = context;
  const { layerId, emitter, particles, physics } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "particles") {
    return { success: false, message: `Particle layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Particle layer has no data` };
  }
  const particleData = layer.data;
  if (emitter && particleData.emitters?.[0]) {
    Object.assign(particleData.emitters[0], emitter);
  }
  if (particles && particleData.emitters?.[0]) {
    Object.assign(particleData.emitters[0], particles);
  }
  if (physics && particleData.systemConfig) {
    if (physics.gravity) {
      particleData.systemConfig.gravity = physics.gravity.y || 0;
    }
    if (physics.wind) {
      particleData.systemConfig.windStrength = Math.sqrt(
        physics.wind.x ** 2 + physics.wind.y ** 2
      );
      particleData.systemConfig.windDirection = Math.atan2(
        physics.wind.y,
        physics.wind.x
      ) * (180 / Math.PI);
    }
  }
  return {
    success: true,
    message: `Configured particle system`
  };
}
function executeSetTextContent(context, args) {
  const { store } = context;
  const { layerId, text, fontSize, fontFamily, fontWeight, color, alignment } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "text") {
    return { success: false, message: `Text layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Text layer has no data` };
  }
  const textData = layer.data;
  if (text !== void 0) textData.text = text;
  if (fontSize !== void 0) textData.fontSize = fontSize;
  if (fontFamily !== void 0) textData.fontFamily = fontFamily;
  if (fontWeight !== void 0) textData.fontWeight = String(fontWeight);
  if (color !== void 0) {
    textData.fill = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a ?? 1})`;
  }
  if (alignment !== void 0) textData.textAlign = alignment;
  return {
    success: true,
    message: `Updated text content`
  };
}
function executeSetTextPath(context, args) {
  const { store } = context;
  const { textLayerId, splineLayerId, startOffset } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === textLayerId);
  if (!layer || layer.type !== "text") {
    return { success: false, message: `Text layer ${textLayerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Text layer has no data` };
  }
  const textData = layer.data;
  textData.pathLayerId = splineLayerId || null;
  if (startOffset !== void 0) {
    textData.pathOffset = startOffset;
  }
  return {
    success: true,
    message: splineLayerId ? `Attached text to path ${splineLayerId}` : `Detached text from path`
  };
}
function executeSetSplinePoints(context, args) {
  const { store } = context;
  const { layerId, points, closed } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer || layer.type !== "spline") {
    return { success: false, message: `Spline layer ${layerId} not found` };
  }
  if (!layer.data) {
    return { success: false, message: `Spline layer has no data` };
  }
  const splineData = layer.data;
  splineData.controlPoints = points.map((p, index) => ({
    id: `cp_${Date.now()}_${index}`,
    x: p.x,
    y: p.y,
    handleIn: p.handleIn || null,
    handleOut: p.handleOut || null,
    type: p.handleIn || p.handleOut ? "smooth" : "corner"
  }));
  if (closed !== void 0) {
    splineData.closed = closed;
  }
  return {
    success: true,
    message: `Set ${points.length} control points on spline`
  };
}
function executeSetTimeRemap(context, args) {
  const { store } = context;
  const { layerId, enabled, keyframes } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { success: false, message: `Layer ${layerId} not found` };
  }
  if (!layer.data) {
    layer.data = {};
  }
  layer.data.timeRemap = {
    enabled: enabled !== false,
    keyframes: keyframes || []
  };
  return {
    success: true,
    message: enabled ? `Enabled time remapping` : `Disabled time remapping`
  };
}
function executeSetCurrentFrame(context, args) {
  const { store} = context;
  const { frame } = args;
  const comp = store.getActiveComp();
  const frameCount = comp?.settings.frameCount || 81;
  const clampedFrame = Math.max(0, Math.min(frame, frameCount - 1));
  store.setFrame(clampedFrame);
  return {
    frame: clampedFrame,
    message: `Jumped to frame ${clampedFrame}`
  };
}
function executePlayPreview(context, args) {
  const { store, playbackStore } = context;
  const { play } = args;
  if (play) {
    const comp = store.getActiveComp();
    if (comp) {
      playbackStore.play(
        comp.settings.fps,
        comp.settings.frameCount,
        comp.currentFrame,
        (frame) => store.setFrame(frame)
      );
    }
  } else {
    playbackStore.stop();
  }
  return {
    playing: play,
    message: play ? `Started playback` : `Stopped playback`
  };
}
async function executeDecomposeImage(context, args) {
  const { store } = context;
  const { sourceLayerId, numLayers = 4 } = args;
  const sourceLayer = store.getActiveCompLayers().find((l) => l.id === sourceLayerId);
  if (!sourceLayer) {
    throw new Error(`Source layer ${sourceLayerId} not found`);
  }
  if (sourceLayer.type !== "image") {
    throw new Error(`Layer ${sourceLayerId} is not an image layer`);
  }
  const layerData = sourceLayer.data;
  const sourceUrl = layerData?.source || layerData?.url || layerData?.assetId;
  if (!sourceUrl) {
    throw new Error(`Source layer has no image source`);
  }
  let imageDataUrl;
  if (sourceUrl.startsWith("data:")) {
    imageDataUrl = sourceUrl;
  } else {
    imageDataUrl = await new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => reject(new Error("Failed to load source image"));
      img.src = sourceUrl;
    });
  }
  const service = getLayerDecompositionService();
  const decomposedLayers = await service.decomposeWithAutoSetup(
    imageDataUrl,
    { numLayers },
    (stage, message) => {
      console.log(`[AI Decompose] ${stage}: ${message}`);
    }
  );
  const createdLayerIds = [];
  for (let i = decomposedLayers.length - 1; i >= 0; i--) {
    const decomposed = decomposedLayers[i];
    const layer = createLayer(store, "image", decomposed.label);
    if (layer.data) {
      layer.data.source = decomposed.image;
    }
    createdLayerIds.push(layer.id);
  }
  store.pushHistory();
  return {
    layerIds: createdLayerIds,
    message: `Decomposed image into ${decomposedLayers.length} layers: ${decomposedLayers.map((l) => l.label).join(", ")}`
  };
}
async function executeVectorizeImage(context, args) {
  const { store } = context;
  const {
    sourceLayerId,
    mode = "trace",
    separateLayers = true,
    groupByPath = true,
    autoGroupByRegion = false,
    enableAnimation = true,
    traceOptions = {}
  } = args;
  const sourceLayer = store.getActiveCompLayers().find((l) => l.id === sourceLayerId);
  if (!sourceLayer) {
    throw new Error(`Source layer ${sourceLayerId} not found`);
  }
  if (sourceLayer.type !== "image" && sourceLayer.type !== "video" && sourceLayer.type !== "solid") {
    throw new Error(`Layer ${sourceLayerId} must be an image, video, or solid layer`);
  }
  const layerData = sourceLayer.data;
  let imageDataUrl;
  if (layerData?.source) {
    imageDataUrl = layerData.source;
  } else if (layerData?.assetId) {
    const asset = store.project?.assets[layerData.assetId];
    if (!asset?.data) throw new Error("Asset data not found");
    imageDataUrl = asset.data;
  } else if (layerData?.url) {
    imageDataUrl = layerData.url;
  } else {
    throw new Error("Source layer has no image source");
  }
  if (!imageDataUrl.startsWith("data:")) {
    imageDataUrl = await new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => reject(new Error("Failed to load source image"));
      img.src = imageDataUrl;
    });
  }
  const vectorizeService = getVectorizeService();
  const result = await vectorizeService.vectorize(
    imageDataUrl,
    {
      mode,
      traceOptions: {
        colorMode: traceOptions.colorMode || "color",
        filterSpeckle: traceOptions.filterSpeckle ?? 4,
        cornerThreshold: traceOptions.cornerThreshold ?? 60,
        colorPrecision: traceOptions.colorPrecision ?? 6,
        layerDifference: traceOptions.layerDifference ?? 16
      }
    },
    (stage, message) => {
      console.log(`[AI Vectorize] ${stage}: ${message}`);
    }
  );
  let paths = filterSmallPaths(result.paths, 2);
  paths = normalizeControlPoints(paths, {
    groupByPath,
    prefix: "vec"
  });
  const createdLayerIds = [];
  if (separateLayers) {
    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      let controlPoints = path.controlPoints;
      if (autoGroupByRegion) {
        controlPoints = autoGroupPoints(controlPoints, { method: "quadrant" });
      }
      const layer = createLayer(store, "spline", `Vector Path ${i + 1}`);
      if (layer.data) {
        Object.assign(layer.data, {
          controlPoints,
          closed: path.closed,
          stroke: path.stroke || "#00ff00",
          strokeWidth: 2,
          fill: path.fill || "",
          animated: enableAnimation
        });
      }
      createdLayerIds.push(layer.id);
    }
  } else {
    const allPoints = [];
    let pointIdx = 0;
    for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {
      const path = paths[pathIdx];
      for (const cp of path.controlPoints) {
        allPoints.push({
          ...cp,
          id: `vec_${pointIdx++}`,
          group: `path_${pathIdx}`
        });
      }
    }
    let controlPoints = allPoints;
    if (autoGroupByRegion) {
      controlPoints = autoGroupPoints(allPoints, { method: "quadrant" });
    }
    const layer = createLayer(store, "spline", "Vectorized Paths");
    if (layer.data) {
      Object.assign(layer.data, {
        controlPoints,
        closed: false,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: "",
        animated: enableAnimation
      });
    }
    createdLayerIds.push(layer.id);
  }
  store.pushHistory();
  return {
    layerIds: createdLayerIds,
    message: `Vectorized image into ${createdLayerIds.length} spline layer(s) with ${result.pathCount} paths`
  };
}
function executeGetLayerInfo(context, args) {
  const { store } = context;
  const { layerId } = args;
  const layer = store.getActiveCompLayers().find((l) => l.id === layerId);
  if (!layer) {
    return { layer: null, message: `Layer ${layerId} not found` };
  }
  return {
    layer: {
      id: layer.id,
      name: layer.name,
      type: layer.type,
      visible: layer.visible,
      locked: layer.locked,
      inPoint: layer.inPoint,
      outPoint: layer.outPoint,
      transform: {
        position: layer.transform.position,
        scale: layer.transform.scale,
        rotation: layer.transform.rotation,
        anchorPoint: layer.transform.anchorPoint
      },
      opacity: layer.opacity,
      effects: layer.effects?.map((e) => ({
        id: e.id,
        effectKey: e.effectKey,
        name: e.name,
        enabled: e.enabled
      }))
    },
    message: `Layer info for "${layer.name}"`
  };
}
function executeFindLayers(context, args) {
  const { store } = context;
  const { name, type } = args;
  let layers = store.getActiveCompLayers();
  if (name) {
    const lowerName = name.toLowerCase();
    layers = layers.filter((l) => l.name.toLowerCase().includes(lowerName));
  }
  if (type) {
    layers = layers.filter((l) => l.type === type);
  }
  return {
    layers: layers.map((l) => ({
      id: l.id,
      name: l.name,
      type: l.type
    })),
    message: `Found ${layers.length} layer(s)`
  };
}
function executeGetProjectState(context, _args) {
  const { store } = context;
  const comp = store.getActiveComp();
  return {
    state: {
      composition: comp ? {
        id: comp.id,
        name: comp.name,
        width: comp.settings.width,
        height: comp.settings.height,
        frameCount: comp.settings.frameCount,
        fps: comp.settings.fps,
        currentFrame: comp.currentFrame
      } : null,
      layerCount: store.getActiveCompLayers().length,
      layers: store.getActiveCompLayers().map((l) => ({
        id: l.id,
        name: l.name,
        type: l.type,
        visible: l.visible
      }))
    },
    message: `Project state summary`
  };
}
function setNestedProperty(obj, path, value) {
  let current = obj;
  for (let i = 0; i < path.length - 1; i++) {
    if (!(path[i] in current)) {
      current[path[i]] = {};
    }
    current = current[path[i]];
  }
  current[path[path.length - 1]] = value;
}

function serializeProjectState(includeKeyframes = true) {
  const store = useCompositorStore();
  const comp = store.getActiveComp();
  if (!comp) {
    return JSON.stringify({ error: "No active composition" }, null, 2);
  }
  const state = {
    composition: serializeComposition(comp),
    layers: store.getActiveCompLayers().map(
      (layer) => serializeLayer(layer, includeKeyframes)
    ),
    selectedLayerIds: [...store.selectedLayerIds],
    currentFrame: comp.currentFrame
  };
  return JSON.stringify(state, null, 2);
}
function serializeComposition(comp) {
  return {
    id: comp.id,
    name: comp.name,
    width: comp.settings.width,
    height: comp.settings.height,
    frameCount: comp.settings.frameCount,
    fps: comp.settings.fps,
    duration: comp.settings.duration
  };
}
function serializeLayer(layer, includeKeyframes) {
  const serialized = {
    id: layer.id,
    name: layer.name,
    type: layer.type,
    visible: layer.visible,
    locked: layer.locked,
    inPoint: layer.inPoint,
    outPoint: layer.outPoint,
    parentId: layer.parentId,
    transform: {
      position: serializeAnimatableProperty(layer.transform.position, includeKeyframes),
      scale: serializeAnimatableProperty(layer.transform.scale, includeKeyframes),
      rotation: serializeAnimatableProperty(layer.transform.rotation, includeKeyframes),
      anchorPoint: serializeAnimatableProperty(layer.transform.anchorPoint, includeKeyframes)
    },
    opacity: serializeAnimatableProperty(layer.opacity, includeKeyframes)
  };
  if (layer.effects && layer.effects.length > 0) {
    serialized.effects = layer.effects.map(serializeEffect);
  }
  if (layer.data) {
    serialized.data = serializeLayerData(layer.type, layer.data);
  }
  return serialized;
}
function serializeAnimatableProperty(prop, includeKeyframes) {
  const serialized = {
    value: prop.value,
    animated: prop.animated || false
  };
  if (prop.keyframes && prop.keyframes.length > 0) {
    serialized.keyframeCount = prop.keyframes.length;
    if (includeKeyframes) {
      serialized.keyframes = prop.keyframes.map((kf) => ({
        frame: kf.frame,
        value: kf.value,
        interpolation: kf.interpolation
      }));
    }
  }
  return serialized;
}
function serializeEffect(effect) {
  const parameters = {};
  for (const [key, param] of Object.entries(effect.parameters)) {
    parameters[key] = param.value;
  }
  return {
    id: effect.id,
    name: effect.name,
    type: effect.effectKey,
    enabled: effect.enabled,
    parameters
  };
}
function serializeLayerData(type, data) {
  switch (type) {
    case "text":
      return {
        text: data.text,
        fontFamily: data.fontFamily,
        fontSize: data.fontSize,
        fill: data.fill,
        textAlign: data.textAlign,
        pathLayerId: data.pathLayerId
      };
    case "solid":
      return {
        color: data.color,
        width: data.width,
        height: data.height
      };
    case "spline":
      return {
        pointCount: data.controlPoints?.length || 0,
        closed: data.closed,
        stroke: data.stroke,
        strokeWidth: data.strokeWidth
      };
    case "particles":
      return {
        emitterCount: data.emitters?.length || 0,
        maxParticles: data.systemConfig?.maxParticles,
        gravity: data.systemConfig?.gravity,
        firstEmitter: data.emitters?.[0] ? {
          x: data.emitters[0].x,
          y: data.emitters[0].y,
          direction: data.emitters[0].direction,
          spread: data.emitters[0].spread,
          speed: data.emitters[0].speed,
          emissionRate: data.emitters[0].emissionRate,
          particleLifetime: data.emitters[0].particleLifetime,
          color: data.emitters[0].color
        } : null
      };
    case "image":
      return {
        assetId: data.assetId,
        fit: data.fit
      };
    case "video":
      return {
        assetId: data.assetId,
        loop: data.loop,
        speed: data.speed
      };
    case "camera":
      return {
        cameraId: data.cameraId,
        isActiveCamera: data.isActiveCamera
      };
    case "shape":
      return {
        shapeCount: data.shapes?.length || 0,
        fill: data.fill,
        stroke: data.stroke,
        strokeWidth: data.strokeWidth
      };
    case "nestedComp":
      return {
        compositionId: data.compositionId,
        hasTimeRemap: !!data.timeRemap
      };
    case "depthflow":
      return {
        sourceLayerId: data.sourceLayerId,
        depthLayerId: data.depthLayerId,
        preset: data.config?.preset
      };
    case "light":
      return {
        lightType: data.lightType,
        color: data.color,
        intensity: data.intensity
      };
    default:
      return Object.fromEntries(
        Object.entries(data).slice(0, 10)
      );
  }
}

const DEFAULT_CONFIG = {
  model: "gpt-4o",
  maxTokens: 4096,
  temperature: 0.3,
  // Lower for more deterministic tool use
  maxIterations: 10,
  autoVerify: true
};
class AICompositorAgent {
  config;
  state;
  abortController = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.state = {
      isProcessing: false,
      currentTask: null,
      messages: [],
      lastError: null,
      iterationCount: 0
    };
  }
  // ==========================================================================
  // PUBLIC API
  // ==========================================================================
  /**
   * Process a user instruction
   * This is the main entry point for the AI agent
   */
  async processInstruction(instruction) {
    if (this.state.isProcessing) {
      throw new Error("Agent is already processing a request");
    }
    this.state.isProcessing = true;
    this.state.currentTask = instruction;
    this.state.lastError = null;
    this.state.iterationCount = 0;
    this.abortController = new AbortController();
    try {
      this.addMessage({ role: "user", content: instruction, timestamp: Date.now() });
      const projectState = serializeProjectState();
      const contextualPrompt = this.buildContextualPrompt(instruction, projectState);
      const response = await this.runAgentLoop(contextualPrompt);
      this.addMessage({ role: "assistant", content: response, timestamp: Date.now() });
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      this.state.lastError = errorMessage;
      throw error;
    } finally {
      this.state.isProcessing = false;
      this.state.currentTask = null;
      this.abortController = null;
    }
  }
  /**
   * Cancel the current operation
   */
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
  /**
   * Clear conversation history
   */
  clearHistory() {
    this.state.messages = [];
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get conversation history
   */
  getHistory() {
    return [...this.state.messages];
  }
  // ==========================================================================
  // PRIVATE METHODS
  // ==========================================================================
  addMessage(message) {
    this.state.messages.push(message);
  }
  buildContextualPrompt(instruction, projectState) {
    return `${SYSTEM_PROMPT$1}

## Current Project State
\`\`\`json
${projectState}
\`\`\`

## User Request
${instruction}

## Instructions
1. Analyze the user's request carefully
2. Think step-by-step about what needs to be done
3. Use the available tools to make changes
4. After making changes, verify they match the user's intent
5. Provide a clear summary of what you did`;
  }
  async runAgentLoop(initialPrompt) {
    let currentMessages = [
      { role: "system", content: SYSTEM_PROMPT$1 },
      { role: "user", content: initialPrompt }
    ];
    while (this.state.iterationCount < this.config.maxIterations) {
      if (this.abortController?.signal.aborted) {
        throw new Error("Operation cancelled");
      }
      this.state.iterationCount++;
      const response = await this.callLLM(currentMessages);
      if (response.toolCalls && response.toolCalls.length > 0) {
        const toolResults = await this.executeToolCalls(response.toolCalls);
        currentMessages.push({
          role: "assistant",
          content: response.content,
          tool_calls: response.toolCalls
        });
        for (const result of toolResults) {
          currentMessages.push({
            role: "tool",
            content: JSON.stringify(result),
            tool_call_id: result.toolCallId
          });
        }
        continue;
      }
      return response.content;
    }
    return "Maximum iterations reached. Please try a simpler request or break it into steps.";
  }
  async callLLM(messages) {
    const response = await fetch("/weyl/api/ai/agent", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: this.config.model,
        messages,
        tools: TOOL_DEFINITIONS,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature
      }),
      signal: this.abortController?.signal
    });
    const result = await response.json();
    if (result.status !== "success") {
      throw new Error(result.message || "LLM API error");
    }
    return {
      content: result.data.content || "",
      toolCalls: result.data.toolCalls
    };
  }
  async executeToolCalls(toolCalls) {
    const results = [];
    for (const call of toolCalls) {
      try {
        const result = await executeToolCall(call);
        results.push({
          toolCallId: call.id,
          success: true,
          result
        });
      } catch (error) {
        results.push({
          toolCallId: call.id,
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    return results;
  }
}
let agentInstance = null;
function getAIAgent() {
  if (!agentInstance) {
    agentInstance = new AICompositorAgent();
  }
  return agentInstance;
}

const _hoisted_1$g = {
  class: "ai-chat-panel",
  role: "region",
  "aria-label": "AI Compositor Agent"
};
const _hoisted_2$g = { class: "panel-header" };
const _hoisted_3$g = { class: "header-actions" };
const _hoisted_4$g = {
  key: 0,
  class: "welcome-message"
};
const _hoisted_5$g = { class: "example-prompts" };
const _hoisted_6$g = ["onClick"];
const _hoisted_7$g = { class: "message-header" };
const _hoisted_8$g = { class: "role-label" };
const _hoisted_9$g = { class: "timestamp" };
const _hoisted_10$g = ["innerHTML"];
const _hoisted_11$f = {
  key: 0,
  class: "tool-calls"
};
const _hoisted_12$d = { class: "tool-icon" };
const _hoisted_13$d = { class: "tool-name" };
const _hoisted_14$c = {
  key: 1,
  class: "message assistant processing"
};
const _hoisted_15$b = { class: "message-content" };
const _hoisted_16$a = { class: "processing-text" };
const _hoisted_17$a = { class: "input-area" };
const _hoisted_18$a = ["onKeydown", "disabled"];
const _hoisted_19$a = ["disabled"];
const _hoisted_20$a = {
  key: 0,
  class: "spinner"
};
const _hoisted_21$a = { key: 1 };
const _hoisted_22$a = { class: "status-bar" };
const _hoisted_23$a = { class: "status-text" };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "AIChatPanel",
  setup(__props) {
    const selectedModel = ref("gpt-4o");
    const inputText = ref("");
    const messages = ref([]);
    const isProcessing = ref(false);
    const processingText = ref("Thinking...");
    const messagesContainer = ref(null);
    const apiConnected = ref(false);
    const apiError = ref(false);
    const examplePrompts = [
      "Fade in a title over 1 second",
      "Create floating particles that drift upward",
      "Make the selected layer bounce in from the left",
      "Add a glow effect to all text layers"
    ];
    const statusText = computed(() => {
      if (isProcessing.value) return `Processing with ${selectedModel.value}...`;
      if (apiError.value) return "API not configured";
      if (apiConnected.value) return `Ready (${selectedModel.value})`;
      return "Checking API status...";
    });
    async function checkApiStatus() {
      try {
        const response = await fetch("/weyl/api/status");
        const data = await response.json();
        if (data.status === "success") {
          apiConnected.value = data.providers.openai || data.providers.anthropic;
          apiError.value = !apiConnected.value;
        }
      } catch {
        apiConnected.value = false;
        apiError.value = true;
      }
    }
    async function sendMessage() {
      const text = inputText.value.trim();
      if (!text || isProcessing.value) return;
      inputText.value = "";
      isProcessing.value = true;
      processingText.value = "Thinking...";
      try {
        const agent = getAIAgent();
        agent.config.model = selectedModel.value;
        await agent.processInstruction(text);
        messages.value = agent.getHistory();
        scrollToBottom();
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        messages.value.push({
          role: "assistant",
          content: `Error: ${errorMessage}`,
          timestamp: Date.now()
        });
      } finally {
        isProcessing.value = false;
      }
    }
    function clearHistory() {
      const agent = getAIAgent();
      agent.clearHistory();
      messages.value = [];
    }
    function useExample(example) {
      inputText.value = example;
      sendMessage();
    }
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    function formatContent(content) {
      return content.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>").replace(/\n/g, "<br>");
    }
    function formatToolName(name) {
      return name.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).trim();
    }
    function getToolIcon(name) {
      const icons = {
        createLayer: "+",
        deleteLayer: "-",
        duplicateLayer: "++",
        addKeyframe: "K",
        removeKeyframe: "-K",
        addEffect: "fx",
        setLayerProperty: "=",
        setLayerTransform: "T",
        configureParticles: "P",
        setTextContent: "A",
        setSplinePoints: "~"
      };
      return icons[name] || "*";
    }
    function scrollToBottom() {
      nextTick(() => {
        if (messagesContainer.value) {
          messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
        }
      });
    }
    onMounted(() => {
      checkApiStatus();
    });
    watch(messages, scrollToBottom, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$g, [
          _cache[4] || (_cache[4] = createBaseVNode("span", { class: "panel-title" }, "AI Agent", -1)),
          createBaseVNode("div", _hoisted_3$g, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
              class: "model-selector",
              "aria-label": "Select AI model"
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("option", { value: "gpt-4o" }, "GPT-4o", -1),
              createBaseVNode("option", { value: "claude-sonnet" }, "Claude Sonnet", -1)
            ])], 512), [
              [vModelSelect, selectedModel.value]
            ]),
            createBaseVNode("button", {
              class: "clear-btn",
              onClick: clearHistory,
              title: "Clear conversation",
              "aria-label": "Clear conversation history"
            }, " Clear ")
          ])
        ]),
        createBaseVNode("div", {
          class: "chat-messages",
          ref_key: "messagesContainer",
          ref: messagesContainer
        }, [
          messages.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_4$g, [
            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "welcome-icon" }, "AI", -1)),
            _cache[6] || (_cache[6] = createBaseVNode("h3", null, "AI Compositor Agent", -1)),
            _cache[7] || (_cache[7] = createBaseVNode("p", null, " Describe the motion graphics you want to create, and I'll build it for you. ", -1)),
            createBaseVNode("div", _hoisted_5$g, [
              (openBlock(), createElementBlock(Fragment, null, renderList(examplePrompts, (example) => {
                return createBaseVNode("button", {
                  key: example,
                  class: "example-btn",
                  onClick: ($event) => useExample(example)
                }, toDisplayString(example), 9, _hoisted_6$g);
              }), 64))
            ])
          ])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(messages.value, (message, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["message", message.role])
            }, [
              createBaseVNode("div", _hoisted_7$g, [
                createBaseVNode("span", _hoisted_8$g, toDisplayString(message.role === "user" ? "You" : "AI Agent"), 1),
                createBaseVNode("span", _hoisted_9$g, toDisplayString(formatTime(message.timestamp)), 1)
              ]),
              createBaseVNode("div", {
                class: "message-content",
                innerHTML: formatContent(message.content)
              }, null, 8, _hoisted_10$g),
              message.toolCalls && message.toolCalls.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_11$f, [
                _cache[8] || (_cache[8] = createBaseVNode("div", { class: "tool-calls-header" }, "Actions taken:", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(message.toolCalls, (call, i) => {
                  return openBlock(), createElementBlock("div", {
                    key: i,
                    class: "tool-call"
                  }, [
                    createBaseVNode("span", _hoisted_12$d, toDisplayString(getToolIcon(call.name)), 1),
                    createBaseVNode("span", _hoisted_13$d, toDisplayString(formatToolName(call.name)), 1)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 2);
          }), 128)),
          isProcessing.value ? (openBlock(), createElementBlock("div", _hoisted_14$c, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "message-header" }, [
              createBaseVNode("span", { class: "role-label" }, "AI Agent")
            ], -1)),
            createBaseVNode("div", _hoisted_15$b, [
              _cache[9] || (_cache[9] = createBaseVNode("span", { class: "processing-dots" }, [
                createBaseVNode("span"),
                createBaseVNode("span"),
                createBaseVNode("span")
              ], -1)),
              createBaseVNode("span", _hoisted_16$a, toDisplayString(processingText.value), 1)
            ])
          ])) : createCommentVNode("", true)
        ], 512),
        createBaseVNode("div", _hoisted_17$a, [
          withDirectives(createBaseVNode("textarea", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputText.value = $event),
            onKeydown: [
              withKeys(withModifiers(sendMessage, ["exact", "prevent"]), ["enter"]),
              _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
              }, ["shift", "stop"]), ["enter"]))
            ],
            placeholder: "Describe the animation you want to create...",
            disabled: isProcessing.value,
            rows: "2",
            "aria-label": "Message input"
          }, null, 40, _hoisted_18$a), [
            [vModelText, inputText.value]
          ]),
          createBaseVNode("button", {
            class: "send-btn",
            onClick: sendMessage,
            disabled: !inputText.value.trim() || isProcessing.value,
            "aria-label": "Send message"
          }, [
            isProcessing.value ? (openBlock(), createElementBlock("span", _hoisted_20$a)) : (openBlock(), createElementBlock("span", _hoisted_21$a, "Send"))
          ], 8, _hoisted_19$a)
        ]),
        createBaseVNode("div", _hoisted_22$a, [
          createBaseVNode("span", {
            class: normalizeClass(["status-indicator", { connected: apiConnected.value, error: apiError.value }])
          }, null, 2),
          createBaseVNode("span", _hoisted_23$a, toDisplayString(statusText.value), 1)
        ])
      ]);
    };
  }
});

const AIChatPanel = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-990822c4"]]);

const CAMERA_BODY_SIZE = 40;
const CAMERA_LENS_LENGTH = 30;
function generateCameraBody(camera) {
  const lines = [];
  const color = "#ffcc00";
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const halfSize = CAMERA_BODY_SIZE / 2;
  const bodyBack = addVec3(pos, scaleVec3(forward, -CAMERA_BODY_SIZE));
  const corners = [];
  for (let z = 0; z < 2; z++) {
    const zOffset = z === 0 ? pos : bodyBack;
    for (let x = -1; x <= 1; x += 2) {
      for (let y = -1; y <= 1; y += 2) {
        corners.push(addVec3(
          addVec3(zOffset, scaleVec3(right, x * halfSize)),
          scaleVec3(up, y * halfSize)
        ));
      }
    }
  }
  lines.push({ start: corners[0], end: corners[1], color });
  lines.push({ start: corners[1], end: corners[3], color });
  lines.push({ start: corners[3], end: corners[2], color });
  lines.push({ start: corners[2], end: corners[0], color });
  lines.push({ start: corners[4], end: corners[5], color });
  lines.push({ start: corners[5], end: corners[7], color });
  lines.push({ start: corners[7], end: corners[6], color });
  lines.push({ start: corners[6], end: corners[4], color });
  lines.push({ start: corners[0], end: corners[4], color });
  lines.push({ start: corners[1], end: corners[5], color });
  lines.push({ start: corners[2], end: corners[6], color });
  lines.push({ start: corners[3], end: corners[7], color });
  const lensEnd = addVec3(pos, scaleVec3(forward, CAMERA_LENS_LENGTH));
  const lensPoints = 8;
  for (let i = 0; i < lensPoints; i++) {
    const angle = i / lensPoints * Math.PI * 2;
    const nextAngle = (i + 1) / lensPoints * Math.PI * 2;
    const p1 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(angle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(angle) * halfSize * 0.5)
    );
    const p2 = addVec3(
      addVec3(pos, scaleVec3(right, Math.cos(nextAngle) * halfSize * 0.5)),
      scaleVec3(up, Math.sin(nextAngle) * halfSize * 0.5)
    );
    lines.push({ start: p1, end: p2, color });
    lines.push({ start: p1, end: lensEnd, color });
  }
  return lines;
}
function generateFrustum(camera, compWidth, compHeight, maxDistance = 2e3) {
  const lines = [];
  const color = "#7c9cff";
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  const aspect = compWidth / compHeight;
  const pos = camera.position;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const near = camera.nearClip;
  const far = Math.min(camera.farClip, maxDistance);
  const nearHalfHeight = near * Math.tan(fovY * Math.PI / 360);
  const nearHalfWidth = nearHalfHeight * aspect;
  const farHalfHeight = far * Math.tan(fovY * Math.PI / 360);
  const farHalfWidth = farHalfHeight * aspect;
  const nearCenter = addVec3(pos, scaleVec3(forward, near));
  const nearCorners = [
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, nearHalfWidth)), scaleVec3(up, -nearHalfHeight)),
    addVec3(addVec3(nearCenter, scaleVec3(right, -nearHalfWidth)), scaleVec3(up, -nearHalfHeight))
  ];
  const farCenter = addVec3(pos, scaleVec3(forward, far));
  const farCorners = [
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, farHalfWidth)), scaleVec3(up, -farHalfHeight)),
    addVec3(addVec3(farCenter, scaleVec3(right, -farHalfWidth)), scaleVec3(up, -farHalfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: nearCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: farCorners[i], end: farCorners[(i + 1) % 4], color });
  }
  for (let i = 0; i < 4; i++) {
    lines.push({ start: nearCorners[i], end: farCorners[i], color });
  }
  return lines;
}
function generateCompositionBounds(compWidth, compHeight) {
  const color = "#00ff88";
  const corners = [
    vec3(0, 0, 0),
    vec3(compWidth, 0, 0),
    vec3(compWidth, compHeight, 0),
    vec3(0, compHeight, 0)
  ];
  const lines = [];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  lines.push({ start: corners[0], end: corners[2], color: "#005533" });
  lines.push({ start: corners[1], end: corners[3], color: "#005533" });
  return lines;
}
function generatePOILine(camera) {
  if (camera.type !== "two-node") {
    return null;
  }
  return {
    start: camera.position,
    end: camera.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function generateFocalPlane(camera, compWidth, compHeight) {
  if (!camera.depthOfField.enabled) {
    return [];
  }
  const color = "#ff00ff";
  const lines = [];
  const pos = camera.position;
  const focusDist = camera.depthOfField.focusDistance;
  let forward;
  if (camera.type === "two-node") {
    forward = normalizeVec3(subVec3(camera.pointOfInterest, pos));
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
  }
  const worldUp = vec3(0, -1, 0);
  let right = normalizeVec3(crossVec3(forward, worldUp));
  if (isNaN(right.x)) {
    right = vec3(1, 0, 0);
  }
  const up = normalizeVec3(crossVec3(right, forward));
  const center = addVec3(pos, scaleVec3(forward, focusDist));
  const halfWidth = compWidth / 4;
  const halfHeight = compHeight / 4;
  const corners = [
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, halfWidth)), scaleVec3(up, -halfHeight)),
    addVec3(addVec3(center, scaleVec3(right, -halfWidth)), scaleVec3(up, -halfHeight))
  ];
  for (let i = 0; i < 4; i++) {
    lines.push({ start: corners[i], end: corners[(i + 1) % 4], color });
  }
  return lines;
}
function generateCameraVisualization(camera, compWidth, compHeight, showFrustum = true, showBounds = true, showFocalPlane = false) {
  return {
    body: generateCameraBody(camera),
    frustum: showFrustum ? generateFrustum(camera, compWidth, compHeight) : [],
    compositionBounds: showBounds ? generateCompositionBounds(compWidth, compHeight) : [],
    poiLine: generatePOILine(camera),
    focalPlane: showFocalPlane ? generateFocalPlane(camera, compWidth, compHeight) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function getCameraViewMatrices(camera, compWidth, compHeight) {
  const aspect = compWidth / compHeight;
  const fovY = focalLengthToFOV(camera.focalLength, camera.filmSize);
  let target;
  if (camera.type === "two-node") {
    target = camera.pointOfInterest;
  } else {
    const radX = camera.orientation.x * Math.PI / 180;
    const radY = camera.orientation.y * Math.PI / 180;
    const forward = vec3(
      Math.sin(radY) * Math.cos(radX),
      -Math.sin(radX),
      Math.cos(radY) * Math.cos(radX)
    );
    target = addVec3(camera.position, scaleVec3(forward, 1e3));
  }
  const view = lookAtMat4(camera.position, target, vec3(0, -1, 0));
  const projection = perspectiveMat4(fovY, aspect, camera.nearClip, camera.farClip);
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function getOrthoViewMatrices(viewType, compWidth, compHeight, customView) {
  const aspect = compWidth / compHeight;
  let view;
  let size = 1e3;
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  switch (viewType) {
    case "front":
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "back":
      view = lookAtMat4(
        vec3(centerX, centerY, 2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "left":
      view = lookAtMat4(
        vec3(-2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "right":
      view = lookAtMat4(
        vec3(centerX + 2e3, centerY, 0),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
      break;
    case "top":
      view = lookAtMat4(
        vec3(centerX, -2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, 1)
      );
      break;
    case "bottom":
      view = lookAtMat4(
        vec3(centerX, centerY + 2e3, 0),
        vec3(centerX, centerY, 0),
        vec3(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (customView) {
        const phi = customView.orbitPhi * Math.PI / 180;
        const theta = customView.orbitTheta * Math.PI / 180;
        const dist = customView.orbitDistance;
        const eye = vec3(
          customView.orbitCenter.x + dist * Math.sin(phi) * Math.sin(theta),
          customView.orbitCenter.y + dist * Math.cos(phi),
          customView.orbitCenter.z + dist * Math.sin(phi) * Math.cos(theta)
        );
        view = lookAtMat4(
          eye,
          customView.orbitCenter,
          vec3(0, -1, 0)
        );
        size = 1e3 / customView.orthoZoom;
      } else {
        view = lookAtMat4(
          vec3(centerX, centerY, -2e3),
          vec3(centerX, centerY, 0),
          vec3(0, -1, 0)
        );
      }
      break;
    default:
      view = lookAtMat4(
        vec3(centerX, centerY, -2e3),
        vec3(centerX, centerY, 0),
        vec3(0, -1, 0)
      );
  }
  const projection = orthographicMat4(
    -size * aspect,
    size * aspect,
    -size,
    size,
    1,
    1e4
  );
  const viewProjection = multiplyMat4Local(projection, view);
  return { view, projection, viewProjection };
}
function multiplyMat4Local(a, b) {
  const ae = a.elements;
  const be = b.elements;
  const result = new Float32Array(16);
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      let sum = 0;
      for (let i = 0; i < 4; i++) {
        sum += ae[row + i * 4] * be[i + col * 4];
      }
      result[row + col * 4] = sum;
    }
  }
  return { elements: result };
}
function projectToScreen(point, viewProjection, screenWidth, screenHeight) {
  const transformed = transformPoint(viewProjection, point);
  const vp = viewProjection.elements;
  const w = point.x * vp[3] + point.y * vp[7] + point.z * vp[11] + vp[15];
  if (w <= 0) {
    return { x: 0, y: 0, z: transformed.z, visible: false };
  }
  const x = (transformed.x / w * 0.5 + 0.5) * screenWidth;
  const y = (-transformed.y / w * 0.5 + 0.5) * screenHeight;
  return {
    x,
    y,
    z: transformed.z / w,
    visible: true
  };
}
function generate3DAxes(center, length = 100) {
  return [
    { start: center, end: addVec3(center, vec3(length, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: center, end: addVec3(center, vec3(0, length, 0)), color: "#00ff00" },
    // Y - Green
    { start: center, end: addVec3(center, vec3(0, 0, length)), color: "#0000ff" }
    // Z - Blue
  ];
}
function generateGrid(compWidth, compHeight, spacing = 100) {
  const lines = [];
  const color = "#333333";
  const centerColor = "#444444";
  const centerX = compWidth / 2;
  const centerY = compHeight / 2;
  const extent = Math.max(compWidth, compHeight);
  for (let x = -extent; x <= extent + compWidth; x += spacing) {
    const isCenter = Math.abs(x - centerX) < spacing / 2;
    lines.push({
      start: vec3(x, -extent, 0),
      end: vec3(x, extent + compHeight, 0),
      color: isCenter ? centerColor : color
    });
  }
  for (let y = -extent; y <= extent + compHeight; y += spacing) {
    const isCenter = Math.abs(y - centerY) < spacing / 2;
    lines.push({
      start: vec3(-extent, y, 0),
      end: vec3(extent + compWidth, y, 0),
      color: isCenter ? centerColor : color
    });
  }
  return lines;
}

const _hoisted_1$f = ["onClick"];
const _hoisted_2$f = { class: "view-header" };
const _hoisted_3$f = ["value", "onChange"];
const _hoisted_4$f = { class: "view-tools" };
const _hoisted_5$f = ["onClick"];
const _hoisted_6$f = ["onMousedown", "onWheel"];
const _hoisted_7$f = { class: "view-info" };
const _hoisted_8$f = { class: "view-name" };
const _hoisted_9$f = {
  key: 0,
  class: "view-coords"
};
const _hoisted_10$f = { class: "layout-controls" };
const _hoisted_11$e = ["onClick", "title"];
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "ViewportRenderer",
  setup(__props) {
    const store = useCompositorStore();
    const camera = computed(() => store.activeCamera);
    const compWidth = computed(() => store.width);
    const compHeight = computed(() => store.height);
    const viewportState = computed(() => store.viewportState);
    const viewOptions = computed(() => store.viewOptions);
    const layers = computed(() => {
      return store.layers.filter((l) => l.type !== "camera").map((l) => ({
        id: l.id,
        name: l.name,
        position: {
          x: l.transform.position.value.x,
          y: l.transform.position.value.y,
          z: 0
          // 2D layers at z=0
        },
        selected: store.selectedLayerIds.includes(l.id)
      }));
    });
    const canvasRefs = ref([null, null, null, null]);
    const contexts = ref([null, null, null, null]);
    const isDragging = ref(false);
    const dragStartPos = ref({ x: 0, y: 0 });
    const dragViewIndex = ref(0);
    const dragButton = ref(0);
    const layoutOptions = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ];
    const layout = computed(() => viewportState.value.layout);
    const activeViewIndex = computed(() => viewportState.value.activeViewIndex);
    const customViews = computed(() => viewportState.value.customViews);
    const activeViews = computed(() => {
      switch (viewportState.value.layout) {
        case "1-view":
          return [viewportState.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return viewportState.value.views.slice(0, 2);
        case "4-view":
          return viewportState.value.views.slice(0, 4);
        default:
          return [viewportState.value.views[0]];
      }
    });
    function setCanvasRef(el, index) {
      canvasRefs.value[index] = el;
      if (el) {
        contexts.value[index] = el.getContext("2d");
      }
    }
    function isCustomView(viewType) {
      return viewType.startsWith("custom-");
    }
    function getViewDisplayName(viewType) {
      const names = {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        "front": "Front",
        "back": "Back",
        "left": "Left",
        "right": "Right",
        "top": "Top",
        "bottom": "Bottom"
      };
      return names[viewType];
    }
    function setActiveView(index) {
      store.updateViewportState({
        activeViewIndex: index
      });
    }
    function updateViewType(index, viewType) {
      const newViews = [...viewportState.value.views];
      newViews[index] = viewType;
      store.updateViewportState({
        views: newViews
      });
    }
    function setLayout(newLayout) {
      const defaultFourViews = ["active-camera", "top", "front", "right"];
      let newViews = [...viewportState.value.views];
      while (newViews.length < 4) {
        newViews.push(defaultFourViews[newViews.length] || "front");
      }
      store.updateViewportState({
        layout: newLayout,
        views: newViews,
        activeViewIndex: Math.min(viewportState.value.activeViewIndex, getViewCount(newLayout) - 1)
      });
    }
    function getViewCount(layout2) {
      switch (layout2) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function resetCustomView(viewType) {
      const defaultView = {
        orbitCenter: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      store.updateViewportState({
        customViews: {
          ...viewportState.value.customViews,
          [viewType]: defaultView
        }
      });
    }
    function onCanvasMouseDown(e, viewIndex) {
      isDragging.value = true;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      dragViewIndex.value = viewIndex;
      dragButton.value = e.button;
      document.addEventListener("mousemove", onCanvasMouseMove);
      document.addEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasMouseMove(e) {
      if (!isDragging.value) return;
      const dx = e.clientX - dragStartPos.value.x;
      const dy = e.clientY - dragStartPos.value.y;
      dragStartPos.value = { x: e.clientX, y: e.clientY };
      const viewType = activeViews.value[dragViewIndex.value];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        if (dragButton.value === 0) {
          const newTheta = customView.orbitTheta + dx * 0.5;
          const newPhi = Math.max(1, Math.min(179, customView.orbitPhi + dy * 0.5));
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orbitTheta: newTheta,
                orbitPhi: newPhi
              }
            }
          });
        } else if (dragButton.value === 1 || dragButton.value === 2) {
          store.updateViewportState({
            customViews: {
              ...viewportState.value.customViews,
              [viewType]: {
                ...customView,
                orthoOffset: {
                  x: customView.orthoOffset.x + dx,
                  y: customView.orthoOffset.y + dy
                }
              }
            }
          });
        }
      }
    }
    function onCanvasMouseUp() {
      isDragging.value = false;
      document.removeEventListener("mousemove", onCanvasMouseMove);
      document.removeEventListener("mouseup", onCanvasMouseUp);
    }
    function onCanvasWheel(e, viewIndex) {
      e.preventDefault();
      const viewType = activeViews.value[viewIndex];
      if (isCustomView(viewType)) {
        const customView = customViews.value[viewType];
        const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [viewType]: {
              ...customView,
              orbitDistance: customView.orbitDistance * zoomFactor
            }
          }
        });
      }
    }
    function render() {
      activeViews.value.forEach((viewType, index) => {
        const canvas = canvasRefs.value[index];
        const ctx = contexts.value[index];
        if (!canvas || !ctx) return;
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, rect.width, rect.height);
        let matrices;
        if (viewType === "active-camera" && camera.value) {
          matrices = getCameraViewMatrices(camera.value, compWidth.value, compHeight.value);
        } else if (isCustomView(viewType)) {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value, customViews.value[viewType]);
        } else {
          matrices = getOrthoViewMatrices(viewType, compWidth.value, compHeight.value);
        }
        const lines = [];
        if (viewOptions.value.showGrid) {
          lines.push(...generateGrid(compWidth.value, compHeight.value));
        }
        if (viewOptions.value.show3DReferenceAxes) {
          lines.push(...generate3DAxes(vec3(compWidth.value / 2, compHeight.value / 2, 0)));
        }
        if (viewOptions.value.showCompositionBounds) {
          const viz = generateCameraVisualization(
            camera.value ?? createDummyCamera(),
            compWidth.value,
            compHeight.value,
            false,
            true,
            false
          );
          lines.push(...viz.compositionBounds);
        }
        if (viewType !== "active-camera" && camera.value) {
          const showWireframe = viewOptions.value.cameraWireframes === "always" || viewOptions.value.cameraWireframes === "selected";
          if (showWireframe) {
            const viz = generateCameraVisualization(
              camera.value,
              compWidth.value,
              compHeight.value,
              true,
              false,
              viewOptions.value.showFocalPlane
            );
            lines.push(...viz.body);
            lines.push(...viz.frustum);
            lines.push(...viz.focalPlane);
            if (viz.poiLine) {
              lines.push(viz.poiLine);
            }
          }
        }
        for (const line of lines) {
          const start = projectToScreen(line.start, matrices.viewProjection, rect.width, rect.height);
          const end = projectToScreen(line.end, matrices.viewProjection, rect.width, rect.height);
          if (!start.visible && !end.visible) continue;
          ctx.beginPath();
          ctx.strokeStyle = line.color;
          ctx.lineWidth = 1;
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
        }
        if (viewOptions.value.showLayerHandles) {
          for (const layer of layers.value) {
            const pos = projectToScreen(layer.position, matrices.viewProjection, rect.width, rect.height);
            if (!pos.visible) continue;
            ctx.beginPath();
            ctx.fillStyle = layer.selected ? "#ffcc00" : "#888888";
            ctx.arc(pos.x, pos.y, layer.selected ? 6 : 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.font = "10px sans-serif";
            ctx.fillText(layer.name, pos.x + 8, pos.y + 4);
          }
        }
      });
    }
    function createDummyCamera() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: compWidth.value / 2, y: compHeight.value / 2, z: -1500 },
        pointOfInterest: { x: compWidth.value / 2, y: compHeight.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: false,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let animationId;
    function animate() {
      render();
      animationId = requestAnimationFrame(animate);
    }
    function onKeyDown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA" || document.activeElement?.tagName === "SELECT") {
        return;
      }
      const activeView = activeViews.value[activeViewIndex.value];
      switch (e.code) {
        case "Numpad1":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "back");
          } else {
            updateViewType(activeViewIndex.value, "front");
          }
          e.preventDefault();
          break;
        case "Numpad3":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "left");
          } else {
            updateViewType(activeViewIndex.value, "right");
          }
          e.preventDefault();
          break;
        case "Numpad7":
          if (e.ctrlKey) {
            updateViewType(activeViewIndex.value, "bottom");
          } else {
            updateViewType(activeViewIndex.value, "top");
          }
          e.preventDefault();
          break;
        case "Numpad0":
          updateViewType(activeViewIndex.value, "active-camera");
          e.preventDefault();
          break;
        case "Numpad5":
          if (!isCustomView(activeView)) {
            const targetView = "custom-1";
            let theta = 0;
            let phi = 90;
            switch (activeView) {
              case "front":
                theta = 0;
                phi = 90;
                break;
              case "back":
                theta = 180;
                phi = 90;
                break;
              case "left":
                theta = -90;
                phi = 90;
                break;
              case "right":
                theta = 90;
                phi = 90;
                break;
              case "top":
                theta = 0;
                phi = 1;
                break;
              case "bottom":
                theta = 0;
                phi = 179;
                break;
              default:
                theta = 45;
                phi = 60;
            }
            store.updateViewportState({
              customViews: {
                ...viewportState.value.customViews,
                [targetView]: {
                  ...viewportState.value.customViews[targetView],
                  orbitTheta: theta,
                  orbitPhi: phi
                }
              }
            });
            updateViewType(activeViewIndex.value, targetView);
          } else {
            const theta = customViews.value[activeView].orbitTheta % 360;
            const phi = customViews.value[activeView].orbitPhi;
            let closestView = "front";
            if (phi < 30) {
              closestView = "top";
            } else if (phi > 150) {
              closestView = "bottom";
            } else {
              const normalizedTheta = (theta % 360 + 360) % 360;
              if (normalizedTheta >= 315 || normalizedTheta < 45) {
                closestView = "front";
              } else if (normalizedTheta >= 45 && normalizedTheta < 135) {
                closestView = "right";
              } else if (normalizedTheta >= 135 && normalizedTheta < 225) {
                closestView = "back";
              } else {
                closestView = "left";
              }
            }
            updateViewType(activeViewIndex.value, closestView);
          }
          e.preventDefault();
          break;
        case "NumpadDecimal":
        case "Period":
          focusOnSelectedLayer();
          e.preventDefault();
          break;
        case "Home":
          if (isCustomView(activeView)) {
            resetCustomView(activeView);
          }
          e.preventDefault();
          break;
        case "KeyG":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showGrid: !viewOptions.value.showGrid
            });
            e.preventDefault();
          }
          break;
        case "KeyH":
          if (!e.ctrlKey && !e.metaKey) {
            store.updateViewOptions({
              showLayerHandles: !viewOptions.value.showLayerHandles
            });
            e.preventDefault();
          }
          break;
        case "KeyC":
          if (!e.ctrlKey && !e.metaKey && !e.shiftKey) {
            store.updateViewOptions({
              showCompositionBounds: !viewOptions.value.showCompositionBounds
            });
            e.preventDefault();
          }
          break;
        case "KeyA":
          if (!e.ctrlKey && !e.metaKey && e.shiftKey) {
            store.updateViewOptions({
              show3DReferenceAxes: !viewOptions.value.show3DReferenceAxes
            });
            e.preventDefault();
          }
          break;
      }
    }
    function focusOnSelectedLayer() {
      const selectedLayer = store.layers.find((l) => store.selectedLayerIds.includes(l.id));
      if (!selectedLayer) return;
      const pos = selectedLayer.transform.position.value;
      const width = 100;
      const height = 100;
      const activeView = activeViews.value[activeViewIndex.value];
      if (isCustomView(activeView)) {
        store.updateViewportState({
          customViews: {
            ...viewportState.value.customViews,
            [activeView]: {
              ...customViews.value[activeView],
              orbitCenter: { x: pos.x + width / 2, y: pos.y + height / 2, z: 0 },
              orbitDistance: Math.max(width, height) * 3
              // Zoom to fit
            }
          }
        });
      }
    }
    onMounted(() => {
      animate();
      window.addEventListener("keydown", onKeyDown);
    });
    onUnmounted(() => {
      cancelAnimationFrame(animationId);
      window.removeEventListener("keydown", onKeyDown);
    });
    watch([camera, viewportState, viewOptions, layers], () => {
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["viewport-renderer", [`layout-${layout.value}`]])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(activeViews.value, (viewType, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass(["view-panel", { active: index === activeViewIndex.value }]),
            onClick: ($event) => setActiveView(index)
          }, [
            createBaseVNode("div", _hoisted_2$f, [
              createBaseVNode("select", {
                value: viewType,
                onChange: ($event) => updateViewType(index, $event.target.value),
                class: "view-select"
              }, [..._cache[1] || (_cache[1] = [
                createStaticVNode('<option value="active-camera" data-v-6a91f63d>Active Camera</option><option value="custom-1" data-v-6a91f63d>Custom View 1</option><option value="custom-2" data-v-6a91f63d>Custom View 2</option><option value="custom-3" data-v-6a91f63d>Custom View 3</option><option value="front" data-v-6a91f63d>Front</option><option value="back" data-v-6a91f63d>Back</option><option value="left" data-v-6a91f63d>Left</option><option value="right" data-v-6a91f63d>Right</option><option value="top" data-v-6a91f63d>Top</option><option value="bottom" data-v-6a91f63d>Bottom</option>', 10)
              ])], 40, _hoisted_3$f),
              createBaseVNode("div", _hoisted_4$f, [
                isCustomView(viewType) ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: withModifiers(($event) => resetCustomView(viewType), ["stop"]),
                  title: "Reset View"
                }, [..._cache[2] || (_cache[2] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])], 8, _hoisted_5$f)) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("canvas", {
              ref_for: true,
              ref: (el) => setCanvasRef(el, index),
              class: "view-canvas",
              onMousedown: ($event) => onCanvasMouseDown($event, index),
              onWheel: ($event) => onCanvasWheel($event, index),
              onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, null, 40, _hoisted_6$f),
            createBaseVNode("div", _hoisted_7$f, [
              createBaseVNode("span", _hoisted_8$f, toDisplayString(getViewDisplayName(viewType)), 1),
              isCustomView(viewType) ? (openBlock(), createElementBlock("span", _hoisted_9$f, " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitTheta ?? 0)) + " : " + toDisplayString(Math.round(customViews.value[viewType]?.orbitPhi ?? 0)) + " ", 1)) : createCommentVNode("", true)
            ])
          ], 10, _hoisted_1$f);
        }), 128)),
        createBaseVNode("div", _hoisted_10$f, [
          (openBlock(), createElementBlock(Fragment, null, renderList(layoutOptions, (layoutOption) => {
            return createBaseVNode("button", {
              key: layoutOption.value,
              class: normalizeClass({ active: layout.value === layoutOption.value }),
              onClick: ($event) => setLayout(layoutOption.value),
              title: layoutOption.label
            }, toDisplayString(layoutOption.icon), 11, _hoisted_11$e);
          }), 64))
        ])
      ], 2);
    };
  }
});

const ViewportRenderer = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-6a91f63d"]]);

class SceneManager {
  /** The main Three.js scene */
  scene;
  /** Group for composition layers (rendered content) */
  compositionGroup;
  /** Group for UI overlay elements */
  overlayGroup;
  /** Group for debug helpers */
  debugGroup;
  /** Environment map texture */
  environmentMap = null;
  /** Environment map configuration */
  envConfig = {
    enabled: false,
    intensity: 1,
    rotation: 0,
    backgroundBlur: 0,
    useAsBackground: true,
    toneMapping: true
  };
  /** PMREM Generator for environment maps */
  pmremGenerator = null;
  /** HDRI loaders */
  rgbeLoader = null;
  exrLoader = null;
  /** Composition bounds frame */
  compositionBounds = null;
  /** Composition grid helper */
  compositionGrid = null;
  /** Dark overlay outside composition */
  outsideOverlay = null;
  /** Composition dimensions */
  compositionWidth = 1920;
  compositionHeight = 1080;
  /** O(1) layer lookup map - optimization for frequent ID-based lookups */
  layerLookupMap = /* @__PURE__ */ new Map();
  /** Track Z positions to avoid unnecessary sorting */
  zPositionCache = /* @__PURE__ */ new Map();
  needsZSort = false;
  constructor(backgroundColor = null) {
    this.scene = new Scene();
    this.scene.name = "WeylScene";
    if (backgroundColor) {
      this.scene.background = new Color(backgroundColor);
    } else {
      this.scene.background = null;
    }
    this.compositionGroup = new Group();
    this.compositionGroup.name = "composition";
    this.scene.add(this.compositionGroup);
    this.overlayGroup = new Group();
    this.overlayGroup.name = "overlay";
    this.overlayGroup.renderOrder = 1e3;
    this.scene.add(this.overlayGroup);
    this.debugGroup = new Group();
    this.debugGroup.name = "debug";
    this.debugGroup.visible = false;
    this.scene.add(this.debugGroup);
    this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const ambient = new AmbientLight(16777215, 0.6);
    ambient.name = "ambientLight";
    this.scene.add(ambient);
    const keyLight = new DirectionalLight(16777215, 0.8);
    keyLight.name = "keyLight";
    keyLight.position.set(1e3, -1e3, 2e3);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    this.scene.add(keyLight);
    const fillLight = new DirectionalLight(16777215, 0.3);
    fillLight.name = "fillLight";
    fillLight.position.set(-500, 500, 1e3);
    this.scene.add(fillLight);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(object) {
    this.compositionGroup.add(object);
    this.markNeedsZSort();
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.set(layerId, object);
    }
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(object) {
    this.compositionGroup.remove(object);
    const layerId = object.userData?.layerId;
    if (layerId) {
      this.layerLookupMap.delete(layerId);
    }
    this.zPositionCache.delete(object);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let hasChanges = false;
      for (const child of this.compositionGroup.children) {
        const cachedZ = this.zPositionCache.get(child);
        const currentZ = child.position.z || 0;
        if (cachedZ === void 0 || cachedZ !== currentZ) {
          hasChanges = true;
          break;
        }
      }
      if (!hasChanges) {
        return;
      }
    }
    this.compositionGroup.children.sort((a, b) => {
      return (a.position.z || 0) - (b.position.z || 0);
    });
    for (const child of this.compositionGroup.children) {
      this.zPositionCache.set(child, child.position.z || 0);
    }
    this.needsZSort = false;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = true;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(object) {
    this.overlayGroup.add(object);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(object) {
    this.overlayGroup.remove(object);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    while (this.overlayGroup.children.length > 0) {
      const child = this.overlayGroup.children[0];
      this.overlayGroup.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(object) {
    this.scene.add(object);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(object) {
    this.scene.remove(object);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(visible) {
    this.debugGroup.visible = visible;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(size = 500) {
    const existing = this.debugGroup.getObjectByName("axisHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new AxesHelper(size);
    helper.name = "axisHelper";
    this.debugGroup.add(helper);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(size = 2e3, divisions = 40) {
    const existing = this.debugGroup.getObjectByName("gridHelper");
    if (existing) {
      this.debugGroup.remove(existing);
    }
    const helper = new GridHelper(size, divisions, 4473924, 2236962);
    helper.name = "gridHelper";
    helper.rotation.x = Math.PI / 2;
    this.debugGroup.add(helper);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(color) {
    if (color) {
      this.scene.background = new Color(color);
    } else {
      this.scene.background = null;
    }
  }
  /**
   * Get current background color
   */
  getBackground() {
    if (this.scene.background instanceof Color) {
      return "#" + this.scene.background.getHexString();
    }
    return null;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize PMREM generator (requires WebGL renderer)
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport(renderer) {
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
    }
    this.pmremGenerator = new PMREMGenerator(renderer);
    this.pmremGenerator.compileEquirectangularShader();
  }
  /**
   * Load and set an environment map from URL (HDR, EXR, or standard image)
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    if (!this.pmremGenerator) {
      throw new Error("Environment support not initialized. Call initializeEnvironmentSupport() first.");
    }
    if (config) {
      Object.assign(this.envConfig, config);
    }
    this.envConfig.url = url;
    this.envConfig.enabled = true;
    const isHDR = url.toLowerCase().endsWith(".hdr");
    const isEXR = url.toLowerCase().endsWith(".exr");
    return new Promise((resolve, reject) => {
      if (isHDR) {
        if (!this.rgbeLoader) {
          this.rgbeLoader = new RGBELoader();
        }
        this.rgbeLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else if (isEXR) {
        if (!this.exrLoader) {
          this.exrLoader = new EXRLoader();
        }
        this.exrLoader.load(
          url,
          (texture) => this.processEnvironmentTexture(texture, resolve),
          void 0,
          reject
        );
      } else {
        const loader = new TextureLoader();
        loader.load(
          url,
          (texture) => {
            texture.mapping = EquirectangularReflectionMapping;
            this.processEnvironmentTexture(texture, resolve);
          },
          void 0,
          reject
        );
      }
    });
  }
  /**
   * Process loaded environment texture
   */
  processEnvironmentTexture(texture, resolve) {
    const envMap = this.pmremGenerator.fromEquirectangular(texture).texture;
    texture.dispose();
    this.setEnvironmentMapTexture(envMap);
    resolve(envMap);
  }
  /**
   * Set environment map from pre-loaded texture
   */
  setEnvironmentMapTexture(texture) {
    if (this.environmentMap && this.environmentMap !== texture) {
      this.environmentMap.dispose();
    }
    this.environmentMap = texture;
    if (texture && this.envConfig.enabled) {
      this.scene.environment = texture;
      if (this.envConfig.useAsBackground) {
        this.scene.background = texture;
        this.scene.backgroundIntensity = this.envConfig.intensity;
        this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
        this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
      }
      this.scene.environmentIntensity = this.envConfig.intensity;
      this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
    } else {
      this.scene.environment = null;
      if (this.envConfig.useAsBackground) {
        this.scene.background = null;
      }
    }
  }
  /**
   * Update environment map configuration
   */
  setEnvironmentConfig(config) {
    Object.assign(this.envConfig, config);
    if (this.environmentMap) {
      if (this.envConfig.enabled) {
        this.scene.environment = this.environmentMap;
        this.scene.environmentIntensity = this.envConfig.intensity;
        this.scene.environmentRotation.y = this.envConfig.rotation * (Math.PI / 180);
        if (this.envConfig.useAsBackground) {
          this.scene.background = this.environmentMap;
          this.scene.backgroundIntensity = this.envConfig.intensity;
          this.scene.backgroundBlurriness = this.envConfig.backgroundBlur;
          this.scene.backgroundRotation.y = this.envConfig.rotation * (Math.PI / 180);
        }
      } else {
        this.scene.environment = null;
        if (this.envConfig.useAsBackground) {
          this.scene.background = null;
        }
      }
    }
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return { ...this.envConfig };
  }
  /**
   * Get current environment map texture
   */
  getEnvironmentMap() {
    return this.environmentMap;
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.setEnvironmentConfig({ enabled });
  }
  /**
   * Set environment intensity
   */
  setEnvironmentIntensity(intensity) {
    this.setEnvironmentConfig({ intensity });
  }
  /**
   * Set environment rotation (degrees)
   */
  setEnvironmentRotation(rotation) {
    this.setEnvironmentConfig({ rotation });
  }
  /**
   * Set background blur amount (0-1)
   */
  setBackgroundBlur(blur) {
    this.setEnvironmentConfig({ backgroundBlur: blur });
  }
  /**
   * Toggle using HDRI as background
   */
  setUseAsBackground(use) {
    this.setEnvironmentConfig({ useAsBackground: use });
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(width, height) {
    this.compositionWidth = width;
    this.compositionHeight = height;
    this.updateCompositionBounds();
    this.updateCompositionGrid();
    this.updateOutsideOverlay();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    if (this.compositionBounds) {
      this.overlayGroup.remove(this.compositionBounds);
      this.compositionBounds.geometry.dispose();
      this.compositionBounds.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const points = [
      new Vector3(0, 0, 0),
      new Vector3(w, 0, 0),
      new Vector3(w, -h, 0),
      new Vector3(0, -h, 0)
    ];
    const geometry = new BufferGeometry().setFromPoints(points);
    const material = new LineBasicMaterial({
      color: 4886745,
      linewidth: 2,
      depthTest: false
    });
    this.compositionBounds = new LineLoop(geometry, material);
    this.compositionBounds.name = "compositionBounds";
    this.compositionBounds.renderOrder = 998;
    this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(visible) {
    if (this.compositionBounds) {
      this.compositionBounds.visible = visible;
    }
  }
  /**
   * Create or update composition grid
   * Shows a grid inside the composition area for spatial reference
   */
  updateCompositionGrid(divisions = 20) {
    if (this.compositionGrid) {
      this.overlayGroup.remove(this.compositionGrid);
      this.compositionGrid.traverse((obj) => {
        if (obj instanceof Line) {
          obj.geometry.dispose();
          obj.material.dispose();
        }
      });
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const gridGroup = new Group();
    gridGroup.name = "compositionGrid";
    const material = new LineBasicMaterial({
      color: 3355443,
      transparent: true,
      opacity: 0.5,
      depthTest: false
    });
    const stepX = w / divisions;
    for (let i = 0; i <= divisions; i++) {
      const x = i * stepX;
      const points = [
        new Vector3(x, 0, 0),
        new Vector3(x, -h, 0)
      ];
      const geometry = new BufferGeometry().setFromPoints(points);
      const line = new Line(geometry, material.clone());
      gridGroup.add(line);
    }
    const stepY = h / divisions;
    for (let i = 0; i <= divisions; i++) {
      const y = -i * stepY;
      const points = [
        new Vector3(0, y, 0),
        new Vector3(w, y, 0)
      ];
      const geometry = new BufferGeometry().setFromPoints(points);
      const line = new Line(geometry, material.clone());
      gridGroup.add(line);
    }
    const centerX = w / 2;
    const centerY = -h / 2;
    const axisLength = Math.min(w, h) / 4;
    const xAxisMaterial = new LineBasicMaterial({
      color: 16729156,
      transparent: true,
      opacity: 0.9,
      depthTest: false,
      linewidth: 2
    });
    const xAxisPoints = [
      new Vector3(centerX, centerY, 0),
      new Vector3(centerX + axisLength, centerY, 0)
    ];
    const xAxisGeom = new BufferGeometry().setFromPoints(xAxisPoints);
    gridGroup.add(new Line(xAxisGeom, xAxisMaterial));
    const yAxisMaterial = new LineBasicMaterial({
      color: 4521796,
      transparent: true,
      opacity: 0.9,
      depthTest: false,
      linewidth: 2
    });
    const yAxisPoints = [
      new Vector3(centerX, centerY, 0),
      new Vector3(centerX, centerY + axisLength, 0)
    ];
    const yAxisGeom = new BufferGeometry().setFromPoints(yAxisPoints);
    gridGroup.add(new Line(yAxisGeom, yAxisMaterial));
    const zAxisMaterial = new LineBasicMaterial({
      color: 4474111,
      transparent: true,
      opacity: 0.9,
      depthTest: false,
      linewidth: 2
    });
    const zAxisPoints = [
      new Vector3(centerX, centerY, 0),
      new Vector3(centerX, centerY, axisLength)
    ];
    const zAxisGeom = new BufferGeometry().setFromPoints(zAxisPoints);
    gridGroup.add(new Line(zAxisGeom, zAxisMaterial));
    const originMarkerGeom = new SphereGeometry(4, 8, 8);
    const originMarkerMat = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const originMarker = new Mesh(originMarkerGeom, originMarkerMat);
    originMarker.position.set(centerX, centerY, 0);
    originMarker.renderOrder = 998;
    gridGroup.add(originMarker);
    const centerMaterial = new LineBasicMaterial({
      color: 5592405,
      transparent: true,
      opacity: 0.5,
      depthTest: false
    });
    const vCenterPoints = [
      new Vector3(centerX, 0, 0),
      new Vector3(centerX, -h, 0)
    ];
    const vCenterGeom = new BufferGeometry().setFromPoints(vCenterPoints);
    gridGroup.add(new Line(vCenterGeom, centerMaterial));
    const hCenterPoints = [
      new Vector3(0, centerY, 0),
      new Vector3(w, centerY, 0)
    ];
    const hCenterGeom = new BufferGeometry().setFromPoints(hCenterPoints);
    gridGroup.add(new Line(hCenterGeom, centerMaterial.clone()));
    gridGroup.renderOrder = 997;
    this.compositionGrid = gridGroup;
    this.overlayGroup.add(gridGroup);
  }
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    if (this.compositionGrid) {
      this.compositionGrid.visible = visible;
    }
  }
  /**
   * Create dark overlay outside composition bounds
   * Creates a large plane with a rectangular hole for the composition area
   */
  updateOutsideOverlay() {
    if (this.outsideOverlay) {
      this.overlayGroup.remove(this.outsideOverlay);
      this.outsideOverlay.geometry.dispose();
      this.outsideOverlay.material.dispose();
    }
    const w = this.compositionWidth;
    const h = this.compositionHeight;
    const size = Math.max(w, h) * 10;
    const outer = new Shape();
    outer.moveTo(-size, size);
    outer.lineTo(size + w, size);
    outer.lineTo(size + w, -size - h);
    outer.lineTo(-size, -size - h);
    outer.lineTo(-size, size);
    const hole = new Path();
    hole.moveTo(0, 0);
    hole.lineTo(0, -h);
    hole.lineTo(w, -h);
    hole.lineTo(w, 0);
    hole.lineTo(0, 0);
    outer.holes.push(hole);
    const geometry = new ShapeGeometry(outer);
    const material = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      opacity: 0.6,
      side: DoubleSide,
      depthTest: false
    });
    this.outsideOverlay = new Mesh(geometry, material);
    this.outsideOverlay.name = "outsideOverlay";
    this.outsideOverlay.position.z = -2;
    this.outsideOverlay.renderOrder = 996;
    this.overlayGroup.add(this.outsideOverlay);
  }
  /**
   * Show/hide outside overlay
   */
  setOutsideOverlayVisible(visible) {
    if (this.outsideOverlay) {
      this.outsideOverlay.visible = visible;
    }
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(raycaster) {
    return raycaster.intersectObjects(this.compositionGroup.children, true);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(layerId) {
    return this.layerLookupMap.get(layerId) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(object) {
    if (object instanceof Mesh) {
      object.geometry?.dispose();
      if (Array.isArray(object.material)) {
        object.material.forEach((m) => {
          this.disposeMaterial(m);
        });
      } else if (object.material) {
        this.disposeMaterial(object.material);
      }
    }
    while (object.children.length > 0) {
      const child = object.children[0];
      object.remove(child);
      this.disposeObject(child);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(material) {
    const mat = material;
    mat.map?.dispose();
    mat.normalMap?.dispose();
    mat.roughnessMap?.dispose();
    mat.metalnessMap?.dispose();
    mat.aoMap?.dispose();
    mat.emissiveMap?.dispose();
    mat.alphaMap?.dispose();
    mat.envMap?.dispose();
    material.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    while (this.compositionGroup.children.length > 0) {
      const child = this.compositionGroup.children[0];
      this.compositionGroup.remove(child);
      this.disposeObject(child);
    }
    this.layerLookupMap.clear();
    this.zPositionCache.clear();
    this.clearOverlay();
    while (this.debugGroup.children.length > 0) {
      const child = this.debugGroup.children[0];
      this.debugGroup.remove(child);
      this.disposeObject(child);
    }
    if (this.environmentMap) {
      this.environmentMap.dispose();
      this.environmentMap = null;
    }
    if (this.pmremGenerator) {
      this.pmremGenerator.dispose();
      this.pmremGenerator = null;
    }
    this.scene.clear();
  }
}

class RenderPipeline {
  renderer;
  composer;
  scene;
  camera;
  // Render targets
  colorTarget;
  depthTarget;
  // Frame capture
  captureCanvas;
  captureCtx;
  // Depth capture material
  depthMaterial;
  // Normal material for normal pass
  normalMaterial;
  // Dimensions
  width;
  height;
  pixelRatio;
  // Render mode
  renderMode = "color";
  // DOF pass
  bokehPass = null;
  dofConfig = {
    enabled: false,
    focusDistance: 500,
    aperture: 0.025,
    maxBlur: 0.01
  };
  // SSAO pass
  ssaoPass = null;
  ssaoConfig = {
    enabled: false,
    kernelRadius: 8,
    minDistance: 5e-3,
    maxDistance: 0.1,
    intensity: 1,
    output: "default"
  };
  // Bloom pass (for emissive objects and lights)
  bloomPass = null;
  bloomConfig = {
    enabled: false,
    strength: 1.5,
    radius: 0.4,
    threshold: 0.85
  };
  // Motion blur processor (canvas-based, applied post-render)
  motionBlurProcessor;
  motionBlurConfig = {
    enabled: false,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  };
  previousFrameTransform = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1
  };
  constructor(config, scene, camera) {
    this.scene = scene;
    this.camera = camera;
    this.width = config.width;
    this.height = config.height;
    this.pixelRatio = config.pixelRatio ?? Math.min(window.devicePixelRatio, 2);
    this.renderer = new WebGLRenderer({
      canvas: config.canvas,
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      preserveDrawingBuffer: true,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: false,
      depth: true
    });
    this.renderer.setPixelRatio(this.pixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.renderer.toneMapping = ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1;
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = PCFSoftShadowMap;
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer = new EffectComposer(this.renderer, this.colorTarget);
    this.setupDefaultPasses();
    this.captureCanvas = new OffscreenCanvas(scaledWidth, scaledHeight);
    this.captureCtx = this.captureCanvas.getContext("2d");
    this.depthMaterial = this.createDepthMaterial();
    this.normalMaterial = new MeshNormalMaterial();
    this.motionBlurProcessor = new MotionBlurProcessor(scaledWidth, scaledHeight);
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat,
      type: HalfFloatType,
      colorSpace: SRGBColorSpace,
      depthBuffer: true,
      stencilBuffer: false,
      samples: 4
      // MSAA
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = UnsignedIntType;
    return target;
  }
  createDepthTarget(width, height) {
    const target = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      depthBuffer: true,
      stencilBuffer: false
    });
    target.depthTexture = new DepthTexture(width, height);
    target.depthTexture.format = DepthFormat;
    target.depthTexture.type = FloatType;
    return target;
  }
  createDepthMaterial() {
    return new ShaderMaterial({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: false,
      depthTest: false
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const renderPass = new RenderPass(this.scene.scene, this.camera.camera);
    this.composer.addPass(renderPass);
    const outputPass = new OutputPass();
    this.composer.addPass(outputPass);
  }
  /**
   * Add a post-processing pass
   */
  addPass(pass) {
    const outputIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "OutputPass"
    );
    if (outputIndex > -1) {
      this.composer.insertPass(pass, outputIndex);
    } else {
      this.composer.addPass(pass);
    }
  }
  /**
   * Remove a post-processing pass
   */
  removePass(pass) {
    this.composer.removePass(pass);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(config) {
    this.dofConfig = { ...this.dofConfig, ...config };
    if (this.dofConfig.enabled) {
      if (!this.bokehPass) {
        this.createBokehPass();
      }
      this.updateBokehPass();
    } else {
      if (this.bokehPass) {
        this.composer.removePass(this.bokehPass);
        this.bokehPass = null;
      }
    }
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    this.bokehPass = new BokehPass(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    );
    this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const uniforms = this.bokehPass.uniforms;
    if (uniforms) {
      uniforms.focus.value = this.dofConfig.focusDistance;
      uniforms.aperture.value = this.dofConfig.aperture;
      uniforms.maxblur.value = this.dofConfig.maxBlur;
    }
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(distance) {
    this.setDOF({ focusDistance: distance });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(aperture) {
    this.setDOF({ aperture });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(enabled) {
    this.setDOF({ enabled });
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   */
  setSSAO(config) {
    this.ssaoConfig = { ...this.ssaoConfig, ...config };
    if (this.ssaoConfig.enabled) {
      if (!this.ssaoPass) {
        this.createSSAOPass();
      }
      this.updateSSAOPass();
    } else {
      if (this.ssaoPass) {
        this.composer.removePass(this.ssaoPass);
        this.ssaoPass = null;
      }
    }
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return { ...this.ssaoConfig };
  }
  /**
   * Create the SSAO pass
   */
  createSSAOPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.ssaoPass = new SSAOPass(
      this.scene.scene,
      this.camera.camera,
      scaledWidth,
      scaledHeight
    );
    const renderPassIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "RenderPass"
    );
    if (renderPassIndex > -1) {
      this.composer.insertPass(this.ssaoPass, renderPassIndex + 1);
    } else {
      this.addPass(this.ssaoPass);
    }
  }
  /**
   * Update SSAO pass parameters
   */
  updateSSAOPass() {
    if (!this.ssaoPass) return;
    this.ssaoPass.kernelRadius = this.ssaoConfig.kernelRadius;
    this.ssaoPass.minDistance = this.ssaoConfig.minDistance;
    this.ssaoPass.maxDistance = this.ssaoConfig.maxDistance;
    const outputMap = {
      "default": SSAOPass.OUTPUT.Default,
      "ssao": SSAOPass.OUTPUT.SSAO,
      "blur": SSAOPass.OUTPUT.Blur,
      "depth": SSAOPass.OUTPUT.Depth,
      "normal": SSAOPass.OUTPUT.Normal
    };
    this.ssaoPass.output = outputMap[this.ssaoConfig.output];
  }
  /**
   * Enable/disable SSAO (convenience method)
   */
  setSSAOEnabled(enabled) {
    this.setSSAO({ enabled });
  }
  /**
   * Set SSAO intensity (convenience method)
   */
  setSSAOIntensity(intensity) {
    this.setSSAO({ intensity });
  }
  /**
   * Set SSAO kernel radius (convenience method)
   */
  setSSAORadius(radius) {
    this.setSSAO({ kernelRadius: radius });
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, particles) glow
   */
  setBloom(config) {
    this.bloomConfig = { ...this.bloomConfig, ...config };
    if (this.bloomConfig.enabled) {
      if (!this.bloomPass) {
        this.createBloomPass();
      }
      this.updateBloomPass();
    } else {
      if (this.bloomPass) {
        this.composer.removePass(this.bloomPass);
        this.bloomPass = null;
      }
    }
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return { ...this.bloomConfig };
  }
  /**
   * Create the bloom pass
   */
  createBloomPass() {
    const scaledWidth = Math.floor(this.width * this.pixelRatio);
    const scaledHeight = Math.floor(this.height * this.pixelRatio);
    this.bloomPass = new UnrealBloomPass(
      new Vector2(scaledWidth, scaledHeight),
      this.bloomConfig.strength,
      this.bloomConfig.radius,
      this.bloomConfig.threshold
    );
    const ssaoIndex = this.composer.passes.findIndex(
      (p) => p.constructor.name === "SSAOPass"
    );
    if (ssaoIndex > -1) {
      this.composer.insertPass(this.bloomPass, ssaoIndex + 1);
    } else {
      const renderIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "RenderPass"
      );
      if (renderIndex > -1) {
        this.composer.insertPass(this.bloomPass, renderIndex + 1);
      } else {
        this.addPass(this.bloomPass);
      }
    }
  }
  /**
   * Update bloom pass parameters
   */
  updateBloomPass() {
    if (!this.bloomPass) return;
    this.bloomPass.strength = this.bloomConfig.strength;
    this.bloomPass.radius = this.bloomConfig.radius;
    this.bloomPass.threshold = this.bloomConfig.threshold;
  }
  /**
   * Enable/disable bloom (convenience method)
   */
  setBloomEnabled(enabled) {
    this.setBloom({ enabled });
  }
  /**
   * Set bloom intensity (convenience method)
   */
  setBloomStrength(strength) {
    this.setBloom({ strength });
  }
  /**
   * Set bloom threshold (convenience method)
   */
  setBloomThreshold(threshold) {
    this.setBloom({ threshold });
  }
  // ============================================================================
  // MOTION BLUR CONFIGURATION
  // ============================================================================
  /**
   * Configure motion blur
   */
  setMotionBlur(config) {
    this.motionBlurConfig = { ...this.motionBlurConfig, ...config };
    this.motionBlurProcessor.setSettings({
      enabled: this.motionBlurConfig.enabled,
      type: this.motionBlurConfig.type,
      shutterAngle: this.motionBlurConfig.shutterAngle,
      shutterPhase: this.motionBlurConfig.shutterPhase,
      samplesPerFrame: this.motionBlurConfig.samplesPerFrame
    });
  }
  /**
   * Enable/disable motion blur
   */
  setMotionBlurEnabled(enabled) {
    this.setMotionBlur({ enabled });
  }
  /**
   * Set motion blur type
   */
  setMotionBlurType(type) {
    this.setMotionBlur({ type });
  }
  /**
   * Set shutter angle (0-720, 180 = standard film)
   */
  setMotionBlurShutterAngle(shutterAngle) {
    this.setMotionBlur({ shutterAngle });
  }
  /**
   * Apply a motion blur preset by name
   */
  setMotionBlurPreset(presetName) {
    const preset = MOTION_BLUR_PRESETS[presetName];
    if (preset) {
      this.setMotionBlur({
        enabled: true,
        type: preset.type || "standard",
        shutterAngle: preset.shutterAngle || 180,
        shutterPhase: preset.shutterPhase || -90,
        samplesPerFrame: preset.samplesPerFrame || 16,
        preset: presetName
      });
    }
  }
  /**
   * Get current motion blur configuration
   */
  getMotionBlurConfig() {
    return { ...this.motionBlurConfig };
  }
  /**
   * Get the motion blur processor (for advanced use)
   */
  getMotionBlurProcessor() {
    return this.motionBlurProcessor;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ();
    this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.render(this.scene.scene, this.camera.camera);
    this.renderer.setRenderTarget(prevTarget);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  // Depth visualization pass for post-processing
  depthVisualizationPass = null;
  // Normal visualization pass for post-processing
  normalVisualizationPass = null;
  /**
   * Set the render mode (color, depth, normal)
   * Uses post-processing to visualize depth/normals from the depth buffer
   * This works with ALL geometry including text since it reads from the depth buffer
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    if (this.depthVisualizationPass) {
      this.composer.removePass(this.depthVisualizationPass);
      this.depthVisualizationPass = null;
    }
    if (this.normalVisualizationPass) {
      this.composer.removePass(this.normalVisualizationPass);
      this.normalVisualizationPass = null;
    }
    this.scene.scene.overrideMaterial = null;
    if (mode === "depth") {
      this.depthVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          varying vec2 vUv;

          float readDepth(sampler2D depthSampler, vec2 coord) {
            float fragCoordZ = texture2D(depthSampler, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          void main() {
            float depth = readDepth(tDepth, vUv);
            // White = close, Black = far (standard depth map convention for AI video)
            gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.depthVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.depthVisualizationPass);
      }
    } else if (mode === "normal") {
      const scaledWidth = Math.floor(this.width * this.pixelRatio);
      const scaledHeight = Math.floor(this.height * this.pixelRatio);
      this.normalVisualizationPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: this.colorTarget.depthTexture },
          cameraNear: { value: this.camera.camera.near },
          cameraFar: { value: this.camera.camera.far },
          resolution: { value: new Vector2(scaledWidth, scaledHeight) },
          cameraProjectionMatrix: { value: this.camera.camera.projectionMatrix },
          cameraProjectionMatrixInverse: { value: this.camera.camera.projectionMatrixInverse }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          #include <packing>
          uniform sampler2D tDiffuse;
          uniform sampler2D tDepth;
          uniform float cameraNear;
          uniform float cameraFar;
          uniform vec2 resolution;
          uniform mat4 cameraProjectionMatrix;
          uniform mat4 cameraProjectionMatrixInverse;
          varying vec2 vUv;

          // Convert depth buffer value to linear depth
          float getLinearDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
            return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
          }

          // Reconstruct view-space position from depth
          vec3 getViewPosition(vec2 coord, float depth) {
            vec4 clipPos = vec4(coord * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
            vec4 viewPos = cameraProjectionMatrixInverse * clipPos;
            return viewPos.xyz / viewPos.w;
          }

          void main() {
            // Sample depth at current pixel and neighbors
            vec2 texelSize = 1.0 / resolution;

            float depthC = getLinearDepth(vUv);
            float depthL = getLinearDepth(vUv - vec2(texelSize.x, 0.0));
            float depthR = getLinearDepth(vUv + vec2(texelSize.x, 0.0));
            float depthU = getLinearDepth(vUv + vec2(0.0, texelSize.y));
            float depthD = getLinearDepth(vUv - vec2(0.0, texelSize.y));

            // Handle edges and background (depth = 1.0)
            if (depthC > 0.999) {
              gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0); // Default normal pointing at camera
              return;
            }

            // Reconstruct view-space positions
            vec3 posC = getViewPosition(vUv, depthC);
            vec3 posL = getViewPosition(vUv - vec2(texelSize.x, 0.0), depthL);
            vec3 posR = getViewPosition(vUv + vec2(texelSize.x, 0.0), depthR);
            vec3 posU = getViewPosition(vUv + vec2(0.0, texelSize.y), depthU);
            vec3 posD = getViewPosition(vUv - vec2(0.0, texelSize.y), depthD);

            // Calculate screen-space derivatives
            // Use the neighbor with smaller depth difference to reduce artifacts at edges
            vec3 ddx = abs(depthR - depthC) < abs(depthC - depthL) ? posR - posC : posC - posL;
            vec3 ddy = abs(depthU - depthC) < abs(depthC - depthD) ? posU - posC : posC - posD;

            // Calculate normal from cross product
            vec3 normal = normalize(cross(ddx, ddy));

            // Flip normal to face camera if needed
            if (normal.z < 0.0) normal = -normal;

            // Convert from view-space normal (-1 to 1) to color (0 to 1)
            // Standard normal map convention: RGB = (normal + 1) / 2
            gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
          }
        `
      });
      const outputIndex = this.composer.passes.findIndex(
        (p) => p.constructor.name === "OutputPass"
      );
      if (outputIndex > -1) {
        this.composer.insertPass(this.normalVisualizationPass, outputIndex);
      } else {
        this.composer.addPass(this.normalVisualizationPass);
      }
    }
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    const buffer = new Uint8Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const flipped = new Uint8ClampedArray(buffer.length);
    const rowSize = width * 4;
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * rowSize;
      const dstRow = y * rowSize;
      flipped.set(buffer.subarray(srcRow, srcRow + rowSize), dstRow);
    }
    return new ImageData(flipped, width, height);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const width = Math.floor(this.width * this.pixelRatio);
    const height = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const buffer = new Float32Array(width * height * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      width,
      height,
      buffer
    );
    const depth = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      depth[i] = buffer[i * 4];
    }
    const flipped = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width;
      const dstRow = y * width;
      flipped.set(depth.subarray(srcRow, srcRow + width), dstRow);
    }
    return flipped;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(width, height) {
    this.width = width;
    this.height = height;
    const scaledWidth = Math.floor(width * this.pixelRatio);
    const scaledHeight = Math.floor(height * this.pixelRatio);
    this.renderer.setSize(width, height);
    this.composer.setSize(scaledWidth, scaledHeight);
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.colorTarget = this.createColorTarget(scaledWidth, scaledHeight);
    this.depthTarget = this.createDepthTarget(scaledWidth, scaledHeight);
    this.composer.renderTarget1.dispose();
    this.composer.renderTarget2.dispose();
    this.composer.renderTarget1 = this.colorTarget.clone();
    this.composer.renderTarget2 = this.colorTarget.clone();
    this.captureCanvas.width = scaledWidth;
    this.captureCanvas.height = scaledHeight;
    if (this.bokehPass && this.dofConfig.enabled) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
      this.createBokehPass();
    }
    if (this.ssaoPass && this.ssaoConfig.enabled) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
      this.createSSAOPass();
      this.updateSSAOPass();
    }
    if (this.bloomPass && this.bloomConfig.enabled) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
      this.createBloomPass();
      this.updateBloomPass();
    }
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // NESTED COMPOSITION RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of render targets for nested compositions (keyed by compositionId) */
  nestedCompTargets = /* @__PURE__ */ new Map();
  /**
   * Create or get a render target for a nested composition
   */
  getNestedCompRenderTarget(compositionId, width, height) {
    const key = `${compositionId}_${width}_${height}`;
    let target = this.nestedCompTargets.get(key);
    if (!target) {
      target = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat,
        type: UnsignedByteType,
        colorSpace: SRGBColorSpace,
        depthBuffer: true,
        stencilBuffer: false
      });
      this.nestedCompTargets.set(key, target);
    }
    return target;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for nested composition rendering
   */
  renderSceneToTexture(scene, camera, target) {
    const prevTarget = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(target);
    this.renderer.clear();
    this.renderer.render(scene, camera);
    this.renderer.setRenderTarget(prevTarget);
    return target.texture;
  }
  /**
   * Dispose a nested composition render target
   */
  disposeNestedCompTarget(compositionId) {
    for (const [key, target] of this.nestedCompTargets.entries()) {
      if (key.startsWith(compositionId + "_")) {
        target.dispose();
        this.nestedCompTargets.delete(key);
      }
    }
  }
  /**
   * Dispose all nested composition render targets
   */
  disposeAllNestedCompTargets() {
    for (const target of this.nestedCompTargets.values()) {
      target.dispose();
    }
    this.nestedCompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    if (this.bokehPass) {
      this.composer.removePass(this.bokehPass);
      this.bokehPass = null;
    }
    if (this.ssaoPass) {
      this.composer.removePass(this.ssaoPass);
      this.ssaoPass = null;
    }
    if (this.bloomPass) {
      this.composer.removePass(this.bloomPass);
      this.bloomPass.dispose();
      this.bloomPass = null;
    }
    this.disposeAllNestedCompTargets();
    this.colorTarget.dispose();
    this.depthTarget.dispose();
    this.depthMaterial.dispose();
    this.normalMaterial.dispose();
    this.composer.dispose();
    this.renderer.dispose();
  }
}

class ImageLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  texture = null;
  /** Resource manager for texture loading */
  resources;
  /** Image dimensions */
  imageWidth = 100;
  imageHeight = 100;
  /** Source URL or asset ID */
  sourceUrl = null;
  /** Original (unprocessed) texture for effects source */
  originalTexture = null;
  /** Canvas for rendering texture to 2D for effect processing */
  textureCanvas = null;
  textureCanvasCtx = null;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 16777215,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `image_${this.id}`;
    this.group.add(this.mesh);
    const imageData = this.extractImageData(layerData);
    if (imageData.source) {
      this.loadImage(imageData.source);
    }
    this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(layerData) {
    const data = layerData.data;
    return {
      source: data?.source ?? data?.url ?? data?.assetId ?? null,
      width: data?.width ?? 100,
      height: data?.height ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(url) {
    this.sourceUrl = url;
    try {
      const texture = await this.resources.loadTexture(url, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      });
      this.setTexture(texture);
    } catch (error) {
      layerLogger.error(`ImageLayer: Failed to load image: ${url}`, error);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(texture) {
    this.texture = texture;
    this.originalTexture = texture;
    this.material.map = texture;
    this.material.needsUpdate = true;
    if (texture.image) {
      this.imageWidth = texture.image.width || texture.image.videoWidth || 100;
      this.imageHeight = texture.image.height || texture.image.videoHeight || 100;
      this.updateMeshSize();
      this.textureCanvas = null;
      this.textureCanvasCtx = null;
      this.effectsDirty = true;
    }
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(imageData) {
    const texture = this.resources.createTextureFromImageData(
      imageData,
      `layer_${this.id}_imagedata`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(canvas) {
    const texture = this.resources.createTextureFromCanvas(
      canvas,
      `layer_${this.id}_canvas`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.setTexture(texture);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(this.imageWidth, this.imageHeight);
    this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(width, height) {
    this.imageWidth = width;
    this.imageHeight = height;
    this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(color) {
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215);
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.originalTexture?.image) {
      return null;
    }
    const image = this.originalTexture.image;
    if (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.width = this.imageWidth;
      this.textureCanvas.height = this.imageHeight;
      this.textureCanvasCtx = this.textureCanvas.getContext("2d");
    }
    if (!this.textureCanvasCtx) {
      return null;
    }
    this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight);
    this.textureCanvasCtx.drawImage(image, 0, 0, this.imageWidth, this.imageHeight);
    return this.textureCanvas;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(processedCanvas) {
    const processedTexture = this.resources.createTextureFromCanvas(
      processedCanvas,
      `layer_${this.id}_effects`,
      {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        generateMipmaps: false,
        colorSpace: SRGBColorSpace
      }
    );
    this.texture = processedTexture;
    this.material.map = processedTexture;
    this.material.needsUpdate = true;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    this.evaluateEffects(frame);
  }
  onApplyEvaluatedState(state) {
    if (state.properties["tint"] !== void 0) {
      this.setTint(state.properties["tint"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.source || data?.url || data?.assetId) {
      const newSource = data.source ?? data.url ?? data.assetId;
      if (newSource !== this.sourceUrl) {
        this.loadImage(newSource);
      }
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data.width ?? this.imageWidth,
        data.height ?? this.imageHeight
      );
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class SolidLayer extends BaseLayer {
  mesh;
  geometry;
  material;
  /** Solid color */
  color;
  /** Solid dimensions */
  width;
  height;
  /** Animated color property */
  animatedColor;
  constructor(layerData) {
    super(layerData);
    const solidData = this.extractSolidData(layerData);
    this.color = solidData.color;
    this.width = solidData.width;
    this.height = solidData.height;
    this.animatedColor = solidData.animatedColor;
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new MeshBasicMaterial({
      color: this.color,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `solid_${this.id}`;
    this.group.add(this.mesh);
    this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(layerData) {
    const data = layerData.data;
    return {
      color: data?.color ?? "#808080",
      width: data?.width ?? 1920,
      height: data?.height ?? 1080,
      animatedColor: data?.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(color) {
    this.color = color;
    this.material.color.set(color);
    this.material.needsUpdate = true;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.animatedColor, frame);
      this.material.color.set(color);
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    if (state.properties["color"] !== void 0) {
      this.material.color.set(state.properties["color"]);
      this.material.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data?.color !== void 0) {
      this.setColor(data.color);
    }
    if (data?.width !== void 0 || data?.height !== void 0) {
      this.setDimensions(
        data?.width ?? this.width,
        data?.height ?? this.height
      );
    }
    if (data?.animatedColor !== void 0) {
      this.animatedColor = data.animatedColor;
    }
    if (data === void 0 && properties.labelColor !== void 0) {
      this.setColor(properties.labelColor);
    }
  }
  onDispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ControlLayer extends BaseLayer {
  /** Visual indicator (crosshair) for editor visibility */
  indicator = null;
  /** Whether to show the control indicator */
  showIndicator;
  /** Indicator size */
  indicatorSize;
  constructor(layerData, showIndicator = true) {
    super(layerData);
    this.showIndicator = showIndicator;
    this.indicatorSize = 50;
    if (this.showIndicator) {
      this.createIndicator();
    }
  }
  /**
   * Create visual indicator (crosshair) for the control layer
   */
  createIndicator() {
    this.indicator = new Group();
    this.indicator.name = `control_indicator_${this.id}`;
    const size = this.indicatorSize;
    const color = 16737792;
    const material = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const hPoints = [
      new Vector3(-size / 2, 0, 0),
      new Vector3(size / 2, 0, 0)
    ];
    const hGeometry = new BufferGeometry().setFromPoints(hPoints);
    const hLine = new Line(hGeometry, material);
    this.indicator.add(hLine);
    const vPoints = [
      new Vector3(0, -size / 2, 0),
      new Vector3(0, size / 2, 0)
    ];
    const vGeometry = new BufferGeometry().setFromPoints(vPoints);
    const vLine = new Line(vGeometry, material);
    this.indicator.add(vLine);
    if (this.threeD) {
      const zPoints = [
        new Vector3(0, 0, -size / 2),
        new Vector3(0, 0, size / 2)
      ];
      const zGeometry = new BufferGeometry().setFromPoints(zPoints);
      const zLine = new Line(zGeometry, material);
      this.indicator.add(zLine);
    }
    const centerGeometry = new CircleGeometry(3, 16);
    const centerMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.8,
      depthTest: false,
      side: DoubleSide
    });
    const centerPoint = new Mesh(centerGeometry, centerMaterial);
    this.indicator.add(centerPoint);
    this.group.add(this.indicator);
    this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(visible) {
    if (this.indicator) {
      this.indicator.visible = visible;
    }
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(size) {
    if (size === this.indicatorSize) return;
    this.indicatorSize = size;
    if (this.indicator) {
      this.group.remove(this.indicator);
      this.disposeIndicator();
      this.createIndicator();
    }
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    if (!this.indicator) return;
    this.indicator.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
      if (child instanceof Mesh) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.indicator.clear();
    this.indicator = null;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(_frame) {
  }
  onApplyEvaluatedState(_state) {
  }
  onUpdate(properties) {
    if (properties.threeD !== void 0 && properties.threeD !== this.threeD) {
      this.threeD = properties.threeD;
      if (this.indicator && this.showIndicator) {
        this.group.remove(this.indicator);
        this.disposeIndicator();
        this.createIndicator();
      }
    }
  }
  onDispose() {
    this.disposeIndicator();
  }
}

class ArcLengthTable {
  constructor(curve, resolution = 500) {
    this.curve = curve;
    this.build(resolution);
  }
  entries = [];
  totalLength = 0;
  build(resolution) {
    this.entries = [];
    let accumulatedLength = 0;
    let prevPoint = this.curve.getPointAt(0);
    for (let i = 0; i <= resolution; i++) {
      const t = i / resolution;
      const point = this.curve.getPointAt(t);
      const tangent = this.curve.getTangentAt(t);
      if (i > 0) {
        accumulatedLength += point.distanceTo(prevPoint);
      }
      this.entries.push({
        t,
        distance: accumulatedLength,
        position: point.clone(),
        tangent: tangent.clone().normalize()
      });
      prevPoint = point;
    }
    this.totalLength = accumulatedLength;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    let low = 0;
    let high = this.entries.length - 1;
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (this.entries[mid].distance < distance) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    const entry = this.entries[low];
    const prevEntry = this.entries[Math.max(0, low - 1)];
    if (entry.distance === prevEntry.distance) {
      return entry.t;
    }
    const ratio = (distance - prevEntry.distance) / (entry.distance - prevEntry.distance);
    return prevEntry.t + ratio * (entry.t - prevEntry.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(distance) {
    const t = this.distanceToT(distance);
    const position = this.curve.getPointAt(t);
    const tangent = this.curve.getTangentAt(t).normalize();
    const normal = new Vector3(-tangent.y, tangent.x, 0).normalize();
    return {
      position,
      tangent,
      normal,
      t,
      distance
    };
  }
}
class TextOnPathService {
  arcLengthTable = null;
  curve = null;
  /**
   * Set the path from control points
   */
  setPath(controlPoints, closed = false) {
    if (controlPoints.length < 2) {
      this.curve = null;
      this.arcLengthTable = null;
      return;
    }
    this.curve = new CurvePath();
    for (let i = 0; i < controlPoints.length - 1; i++) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.x + (p0.handleOut?.x ?? 0),
          -(p0.y + (p0.handleOut?.y ?? 0)),
          z0
        ),
        new Vector3(
          p1.x + (p1.handleIn?.x ?? 0),
          -(p1.y + (p1.handleIn?.y ?? 0)),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (closed && controlPoints.length > 2) {
      const lastPoint = controlPoints[controlPoints.length - 1];
      const firstPoint = controlPoints[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.x + (lastPoint.handleOut?.x ?? 0),
          -(lastPoint.y + (lastPoint.handleOut?.y ?? 0)),
          zLast
        ),
        new Vector3(
          firstPoint.x + (firstPoint.handleIn?.x ?? 0),
          -(firstPoint.y + (firstPoint.handleIn?.y ?? 0)),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    this.arcLengthTable = new ArcLengthTable(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(curve) {
    this.curve = curve;
    this.arcLengthTable = new ArcLengthTable(curve);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    return this.arcLengthTable?.totalLength ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(characterWidths, config, tracking = 0, fontSize = 72) {
    if (!this.arcLengthTable || characterWidths.length === 0) {
      return [];
    }
    const totalLength = this.arcLengthTable.totalLength;
    const placements = [];
    const trackingPx = tracking / 1e3 * fontSize;
    let totalTextWidth = 0;
    for (let i = 0; i < characterWidths.length; i++) {
      totalTextWidth += characterWidths[i];
      if (i < characterWidths.length - 1) {
        totalTextWidth += trackingPx;
      }
    }
    const availableLength = totalLength - config.firstMargin - config.lastMargin;
    let startDistance;
    switch (config.align) {
      case "center":
        startDistance = config.firstMargin + (availableLength - totalTextWidth) / 2;
        break;
      case "right":
        startDistance = config.firstMargin + availableLength - totalTextWidth;
        break;
      default:
        startDistance = config.firstMargin;
    }
    const offsetDistance = config.offset / 100 * availableLength;
    startDistance += offsetDistance;
    if (config.reversed) {
      startDistance = totalLength - startDistance - totalTextWidth;
    }
    let currentDistance = startDistance;
    for (let i = 0; i < characterWidths.length; i++) {
      const charWidth = characterWidths[i];
      const charCenterDistance = currentDistance + charWidth / 2;
      let actualDistance = charCenterDistance;
      let visible = true;
      if (actualDistance < 0 || actualDistance > totalLength) {
        if (config.forceAlignment) {
          actualDistance = (actualDistance % totalLength + totalLength) % totalLength;
        } else {
          visible = actualDistance >= -charWidth && actualDistance <= totalLength + charWidth;
          actualDistance = Math.max(0, Math.min(totalLength, actualDistance));
        }
      }
      const pathPoint = this.arcLengthTable.getPointAtDistance(actualDistance);
      let rotation;
      if (config.perpendicularToPath) {
        const angle = Math.atan2(pathPoint.tangent.y, pathPoint.tangent.x);
        rotation = new Euler(0, 0, config.reversed ? angle + Math.PI : angle);
      } else {
        rotation = new Euler(0, 0, 0);
      }
      placements.push({
        index: i,
        position: pathPoint.position.clone(),
        rotation,
        scale: 1,
        pathDistance: actualDistance,
        pathT: pathPoint.t,
        visible
      });
      currentDistance += charWidth + trackingPx;
    }
    return placements;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(percent) {
    if (!this.arcLengthTable) return null;
    const distance = percent / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(distance);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(count) {
    if (!this.arcLengthTable || count < 2) return [];
    const points = [];
    const spacing = this.arcLengthTable.totalLength / (count - 1);
    for (let i = 0; i < count; i++) {
      const distance = i * spacing;
      points.push(this.arcLengthTable.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null;
    this.arcLengthTable = null;
  }
}
function createDefaultPathConfig() {
  return {
    pathLayerId: null,
    reversed: false,
    perpendicularToPath: true,
    forceAlignment: false,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}

class TextLayer extends BaseLayer {
  resources;
  // Text rendering
  textMesh;
  perCharacterGroup = null;
  characterMeshes = [];
  // Text data from layer
  textData;
  // Animatable text properties (from layer.properties)
  fontSizeProp;
  trackingProp;
  lineSpacingProp;
  fillColorProp;
  strokeColorProp;
  strokeWidthProp;
  pathOffsetProp;
  firstMarginProp;
  lastMarginProp;
  characterOffsetProp;
  // Per-character animation
  characterTransforms;
  // Path following service
  textOnPath;
  pathConfig;
  pathControlPoints = [];
  pathClosed = false;
  // Character width cache (recalculated when text/font changes)
  characterWidths = [];
  characterWidthsDirty = true;
  // Additional evaluator for text-specific properties
  textEvaluator;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.textEvaluator = new KeyframeEvaluator();
    this.textOnPath = new TextOnPathService();
    this.pathConfig = createDefaultPathConfig();
    this.textData = this.extractTextData(layerData);
    this.extractAnimatableProperties(layerData);
    this.textMesh = this.createTextMesh();
    this.group.add(this.textMesh);
    if (this.textData.perCharacter3D || this.textData.pathLayerId) {
      this.enablePerCharacter3D();
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(layerData) {
    const data = layerData.data;
    return {
      text: data?.text ?? "Text",
      fontFamily: data?.fontFamily ?? "Impact",
      fontSize: data?.fontSize ?? 72,
      fontWeight: data?.fontWeight ?? "400",
      fontStyle: data?.fontStyle ?? "normal",
      fill: data?.fill ?? "#ffffff",
      stroke: data?.stroke ?? "",
      strokeWidth: data?.strokeWidth ?? 0,
      // Character properties
      tracking: data?.tracking ?? 0,
      lineSpacing: data?.lineSpacing ?? 0,
      lineAnchor: data?.lineAnchor ?? 50,
      characterOffset: data?.characterOffset ?? 0,
      characterValue: data?.characterValue ?? 0,
      blur: data?.blur ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: data?.letterSpacing ?? data?.tracking ?? 0,
      lineHeight: data?.lineHeight ?? data?.lineSpacing ?? 1.2,
      textAlign: data?.textAlign ?? "left",
      // Path options (full AE parity)
      pathLayerId: data?.pathLayerId ?? null,
      pathReversed: data?.pathReversed ?? false,
      pathPerpendicularToPath: data?.pathPerpendicularToPath ?? true,
      pathForceAlignment: data?.pathForceAlignment ?? false,
      pathFirstMargin: data?.pathFirstMargin ?? 0,
      pathLastMargin: data?.pathLastMargin ?? 0,
      pathOffset: data?.pathOffset ?? 0,
      pathAlign: data?.pathAlign ?? "left",
      // More Options
      anchorPointGrouping: data?.anchorPointGrouping ?? "character",
      groupingAlignment: data?.groupingAlignment ?? { x: 0, y: 0 },
      fillAndStroke: data?.fillAndStroke ?? "fill-over-stroke",
      interCharacterBlending: data?.interCharacterBlending ?? "normal",
      // 3D
      perCharacter3D: data?.perCharacter3D ?? false
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(layerData) {
    if (!layerData.properties) return;
    for (const prop of layerData.properties) {
      switch (prop.name) {
        case "Font Size":
          this.fontSizeProp = prop;
          break;
        case "Tracking":
          this.trackingProp = prop;
          break;
        case "Line Spacing":
          this.lineSpacingProp = prop;
          break;
        case "Fill Color":
          this.fillColorProp = prop;
          break;
        case "Stroke Color":
          this.strokeColorProp = prop;
          break;
        case "Stroke Width":
          this.strokeWidthProp = prop;
          break;
        case "Path Offset":
          this.pathOffsetProp = prop;
          break;
        case "First Margin":
          this.firstMarginProp = prop;
          break;
        case "Last Margin":
          this.lastMarginProp = prop;
          break;
        case "Character Offset":
          this.characterOffsetProp = prop;
          break;
      }
    }
    this.syncPathConfig();
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId;
    this.pathConfig.reversed = this.textData.pathReversed;
    this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath;
    this.pathConfig.forceAlignment = this.textData.pathForceAlignment;
    this.pathConfig.firstMargin = this.textData.pathFirstMargin;
    this.pathConfig.lastMargin = this.textData.pathLastMargin;
    this.pathConfig.offset = this.textData.pathOffset;
    this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const text = new Text();
    text.text = this.textData.text;
    text.font = this.getFontUrl(this.textData.fontFamily) ?? null;
    text.fontSize = this.textData.fontSize;
    text.fontWeight = this.textData.fontWeight || "400";
    text.fontStyle = this.textData.fontStyle || "normal";
    text.color = this.textData.fill;
    if (this.textData.stroke && this.textData.strokeWidth > 0) {
      text.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
      text.outlineColor = this.textData.stroke;
    }
    text.letterSpacing = (this.textData.tracking || 0) / 1e3;
    text.lineHeight = this.textData.lineHeight || 1.2;
    text.textAlign = this.textData.textAlign;
    text.anchorX = this.getAnchorX();
    text.anchorY = "middle";
    text.depthOffset = 0;
    text.renderOrder = 0;
    text.sdfGlyphSize = 256;
    text.gpuAccelerateSDF = true;
    if (this.textData.strokeWidth > 0) {
      text.outlineBlur = 3e-3;
    }
    text.sync();
    return text;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(fontFamily) {
    const systemFonts = [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ];
    if (systemFonts.includes(fontFamily)) {
      return void 0;
    }
    const googleFonts = {
      "Roboto": "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      "Lato": "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      "Montserrat": "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      "Oswald": "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      "Poppins": "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    };
    return googleFonts[fontFamily];
  }
  /**
   * Get anchor X based on text alignment
   * Note: Swapped to match intuitive arrow button behavior:
   * -  (left) button makes text appear on LEFT (anchor right edge)
   * -  (right) button makes text appear on RIGHT (anchor left edge)
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "right";
      case "right":
        return "left";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(controlPoints, closed = false) {
    this.pathControlPoints = controlPoints;
    this.pathClosed = closed;
    if (controlPoints.length >= 2) {
      this.textOnPath.setPath(controlPoints, closed);
      if (!this.perCharacterGroup) {
        this.enablePerCharacter3D();
      }
      this.updatePathLayout();
    } else {
      this.textOnPath.dispose();
      this.resetPathLayout();
    }
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(curve) {
    this.textOnPath.setCurve(curve);
    if (!this.perCharacterGroup) {
      this.enablePerCharacter3D();
    }
    this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null;
    this.pathConfig.pathLayerId = null;
    this.textOnPath.dispose();
    this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup) {
      return;
    }
    this.ensureCharacterWidths();
    const placements = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(placements);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(placements) {
    for (let i = 0; i < this.characterMeshes.length && i < placements.length; i++) {
      const mesh = this.characterMeshes[i];
      const placement = placements[i];
      mesh.position.copy(placement.position);
      mesh.rotation.copy(placement.rotation);
      mesh.scale.setScalar(placement.scale);
      mesh.visible = placement.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    if (this.textData.perCharacter3D) {
      this.createCharacterMeshes();
    } else {
      this.disablePerCharacter3D();
    }
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const text = this.textData.text;
    const avgCharWidth = this.textData.fontSize * 0.6;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (`iIl1|!.,;:'"`.includes(char)) {
        this.characterWidths.push(avgCharWidth * 0.4);
      } else if ("mwMW".includes(char)) {
        this.characterWidths.push(avgCharWidth * 1.3);
      } else if (char === " ") {
        this.characterWidths.push(avgCharWidth * 0.5);
      } else {
        this.characterWidths.push(avgCharWidth);
      }
    }
    this.characterWidthsDirty = false;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    if (this.perCharacterGroup) return;
    this.textMesh.visible = false;
    this.perCharacterGroup = new Group();
    this.perCharacterGroup.name = `text_chars_${this.id}`;
    this.group.add(this.perCharacterGroup);
    this.createCharacterMeshes();
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    if (!this.perCharacterGroup) return;
    this.textMesh.visible = true;
    this.disposeCharacterMeshes();
    this.group.remove(this.perCharacterGroup);
    this.perCharacterGroup = null;
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes();
    this.characterWidthsDirty = true;
    const text = this.textData.text;
    let xOffset = 0;
    this.ensureCharacterWidths();
    const totalWidth = this.characterWidths.reduce((a, b) => a + b, 0) + (text.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let startX = 0;
    switch (this.textData.textAlign) {
      case "center":
        startX = -totalWidth / 2;
        break;
      case "right":
        startX = -totalWidth;
        break;
      default:
        startX = 0;
    }
    xOffset = startX;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const charMesh = new Text();
      charMesh.text = char;
      charMesh.font = this.getFontUrl(this.textData.fontFamily) ?? null;
      charMesh.fontSize = this.textData.fontSize;
      charMesh.fontWeight = this.textData.fontWeight || "400";
      charMesh.fontStyle = this.textData.fontStyle || "normal";
      charMesh.color = this.textData.fill;
      charMesh.anchorX = "center";
      charMesh.anchorY = "middle";
      if (this.textData.stroke && this.textData.strokeWidth > 0) {
        charMesh.outlineWidth = this.textData.strokeWidth / this.textData.fontSize;
        charMesh.outlineColor = this.textData.stroke;
        charMesh.outlineBlur = 5e-3;
      }
      charMesh.sdfGlyphSize = 128;
      const charWidth = this.characterWidths[i];
      charMesh.position.x = xOffset + charWidth / 2;
      charMesh.position.y = 0;
      charMesh.position.z = 0;
      xOffset += charWidth + this.textData.tracking / 1e3 * this.textData.fontSize;
      charMesh.sync();
      this.characterMeshes.push(charMesh);
      this.perCharacterGroup.add(charMesh);
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    for (const mesh of this.characterMeshes) {
      mesh.dispose();
      this.perCharacterGroup?.remove(mesh);
    }
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(text) {
    this.textData.text = text;
    this.textMesh.text = text;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    if (this.perCharacterGroup) {
      this.createCharacterMeshes();
    }
  }
  setFontFamily(family) {
    this.textData.fontFamily = family;
    const fontUrl = this.getFontUrl(family) ?? null;
    this.textMesh.font = fontUrl;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.font = fontUrl;
      charMesh.sync();
    }
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setFontSize(size) {
    this.textData.fontSize = size;
    this.textMesh.fontSize = size;
    this.textMesh.sync();
    this.characterWidthsDirty = true;
    for (const charMesh of this.characterMeshes) {
      charMesh.fontSize = size;
      charMesh.sync();
    }
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setFontWeight(weight) {
    this.textData.fontWeight = weight;
    this.textMesh.fontWeight = weight;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontWeight = weight;
      charMesh.sync();
    }
  }
  setFontStyle(style) {
    this.textData.fontStyle = style;
    this.textMesh.fontStyle = style;
    this.textMesh.sync();
    for (const charMesh of this.characterMeshes) {
      charMesh.fontStyle = style;
      charMesh.sync();
    }
  }
  setFillColor(color) {
    this.textData.fill = color;
    this.textMesh.color = color;
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.color = color;
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setStroke(color, width) {
    this.textData.stroke = color;
    this.textData.strokeWidth = width;
    const outlineWidth = width > 0 ? width / this.textData.fontSize : 0;
    this.textMesh.outlineWidth = outlineWidth;
    this.textMesh.outlineColor = width > 0 ? color : "";
    if (this.textMesh.material) {
      this.textMesh.material.needsUpdate = true;
    }
    for (const charMesh of this.characterMeshes) {
      charMesh.outlineWidth = outlineWidth;
      charMesh.outlineColor = width > 0 ? color : "";
      if (charMesh.material) {
        charMesh.material.needsUpdate = true;
      }
    }
  }
  setTracking(tracking) {
    this.textData.tracking = tracking;
    this.textMesh.letterSpacing = tracking / 1e3;
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  setTextAlign(align) {
    this.textData.textAlign = align;
    this.textMesh.textAlign = align;
    this.textMesh.anchorX = this.getAnchorX();
    this.textMesh.sync();
    if (this.perCharacterGroup) {
      if (this.textOnPath.hasPath()) {
        this.pathConfig.align = align;
        this.updatePathLayout();
      } else {
        this.createCharacterMeshes();
      }
    }
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(offset) {
    this.textData.pathOffset = offset;
    this.pathConfig.offset = offset;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(margin) {
    this.textData.pathFirstMargin = margin;
    this.pathConfig.firstMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(margin) {
    this.textData.pathLastMargin = margin;
    this.pathConfig.lastMargin = margin;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set path reversed
   */
  setPathReversed(reversed) {
    this.textData.pathReversed = reversed;
    this.pathConfig.reversed = reversed;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(perpendicular) {
    this.textData.pathPerpendicularToPath = perpendicular;
    this.pathConfig.perpendicularToPath = perpendicular;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  /**
   * Set force alignment
   */
  setForceAlignment(force) {
    this.textData.pathForceAlignment = force;
    this.pathConfig.forceAlignment = force;
    if (this.textOnPath.hasPath()) {
      this.updatePathLayout();
    }
  }
  setAnchorPointGrouping(grouping) {
    this.textData.anchorPointGrouping = grouping;
  }
  setFillAndStroke(order) {
    this.textData.fillAndStroke = order;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.fontSizeProp?.animated) {
      const size = this.textEvaluator.evaluate(this.fontSizeProp, frame);
      this.setFontSize(size);
    }
    if (this.trackingProp?.animated) {
      const tracking = this.textEvaluator.evaluate(this.trackingProp, frame);
      this.setTracking(tracking);
    }
    if (this.fillColorProp?.animated) {
      const color = this.textEvaluator.evaluate(this.fillColorProp, frame);
      this.setFillColor(color);
    }
    if (this.strokeColorProp?.animated && this.strokeWidthProp) {
      const color = this.textEvaluator.evaluate(this.strokeColorProp, frame);
      const width = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, frame) : this.textData.strokeWidth;
      this.setStroke(color, width);
    }
    if (this.pathOffsetProp) {
      const offset = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, frame) : this.textData.pathOffset;
      this.setPathOffset(offset);
    }
    if (this.firstMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.firstMarginProp, frame);
      this.setFirstMargin(margin);
    }
    if (this.lastMarginProp?.animated) {
      const margin = this.textEvaluator.evaluate(this.lastMarginProp, frame);
      this.setLastMargin(margin);
    }
    if (this.characterTransforms?.animated && this.perCharacterGroup) {
      this.applyCharacterTransforms(frame);
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["fontSize"] !== void 0) {
      this.setFontSize(props["fontSize"]);
    }
    if (props["tracking"] !== void 0) {
      this.setTracking(props["tracking"]);
    }
    if (props["fillColor"] !== void 0) {
      this.setFillColor(props["fillColor"]);
    }
    if (props["strokeColor"] !== void 0 || props["strokeWidth"] !== void 0) {
      this.setStroke(
        props["strokeColor"] ?? this.textData.stroke,
        props["strokeWidth"] ?? this.textData.strokeWidth
      );
    }
    if (props["pathOffset"] !== void 0) {
      this.setPathOffset(props["pathOffset"]);
    }
    if (props["firstMargin"] !== void 0) {
      this.setFirstMargin(props["firstMargin"]);
    }
    if (props["lastMargin"] !== void 0) {
      this.setLastMargin(props["lastMargin"]);
    }
    if (state.effects.length > 0) {
      this.applyEvaluatedEffects(state.effects);
    }
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(frame) {
    if (!this.characterTransforms) return;
    const transforms = this.textEvaluator.evaluate(this.characterTransforms, frame);
    for (let i = 0; i < this.characterMeshes.length && i < transforms.length; i++) {
      const charMesh = this.characterMeshes[i];
      const t = transforms[i];
      charMesh.position.x += t.position.x;
      charMesh.position.y += t.position.y;
      charMesh.position.z += t.position.z;
      charMesh.rotation.x += MathUtils.degToRad(t.rotation.x);
      charMesh.rotation.y += MathUtils.degToRad(t.rotation.y);
      charMesh.rotation.z += MathUtils.degToRad(t.rotation.z);
      charMesh.scale.x *= t.scale.x;
      charMesh.scale.y *= t.scale.y;
      if (charMesh.material) {
        charMesh.material.opacity *= t.opacity;
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.text !== void 0) {
        this.setText(data.text);
      }
      if (data.fontFamily !== void 0) {
        this.setFontFamily(data.fontFamily);
      }
      if (data.fontSize !== void 0) {
        this.setFontSize(data.fontSize);
      }
      if (data.fontWeight !== void 0) {
        this.setFontWeight(data.fontWeight);
      }
      if (data.fontStyle !== void 0) {
        this.setFontStyle(data.fontStyle);
      }
      if (data.fill !== void 0) {
        this.setFillColor(data.fill);
      }
      if (data.stroke !== void 0 || data.strokeWidth !== void 0) {
        this.setStroke(
          data.stroke ?? this.textData.stroke,
          data.strokeWidth ?? this.textData.strokeWidth
        );
      }
      if (data.tracking !== void 0) {
        this.setTracking(data.tracking);
      }
      if (data.textAlign !== void 0) {
        this.setTextAlign(data.textAlign);
      }
      if (data.pathLayerId !== void 0) {
        this.textData.pathLayerId = data.pathLayerId;
        this.pathConfig.pathLayerId = data.pathLayerId;
      }
      if (data.pathOffset !== void 0) {
        this.setPathOffset(data.pathOffset);
      }
      if (data.pathFirstMargin !== void 0) {
        this.setFirstMargin(data.pathFirstMargin);
      }
      if (data.pathLastMargin !== void 0) {
        this.setLastMargin(data.pathLastMargin);
      }
      if (data.pathReversed !== void 0) {
        this.setPathReversed(data.pathReversed);
      }
      if (data.pathPerpendicularToPath !== void 0) {
        this.setPerpendicularToPath(data.pathPerpendicularToPath);
      }
      if (data.pathForceAlignment !== void 0) {
        this.setForceAlignment(data.pathForceAlignment);
      }
      if (data.perCharacter3D !== void 0) {
        if (data.perCharacter3D && !this.perCharacterGroup) {
          this.enablePerCharacter3D();
        } else if (!data.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup) {
          this.disablePerCharacter3D();
        }
      }
      if (data.anchorPointGrouping !== void 0) {
        this.setAnchorPointGrouping(data.anchorPointGrouping);
      }
      if (data.fillAndStroke !== void 0) {
        this.setFillAndStroke(data.fillAndStroke);
      }
    }
    if (properties.properties) {
      this.extractAnimatableProperties(properties);
    }
  }
  // ============================================================================
  // OPACITY OVERRIDE FOR TROIKA TEXT
  // ============================================================================
  /**
   * Override base class opacity to use Troika's fillOpacity
   */
  applyOpacity(opacity) {
    const normalizedOpacity = Math.max(0, Math.min(100, opacity)) / 100;
    this.textMesh.fillOpacity = normalizedOpacity;
    this.textMesh.outlineOpacity = normalizedOpacity;
    for (const charMesh of this.characterMeshes) {
      charMesh.fillOpacity = normalizedOpacity;
      charMesh.outlineOpacity = normalizedOpacity;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    const bounds = this.textMesh.textRenderInfo?.blockBounds;
    if (bounds) {
      return {
        width: bounds[2] - bounds[0],
        height: bounds[3] - bounds[1]
      };
    }
    return { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose();
    this.disposeCharacterMeshes();
    this.textOnPath.dispose();
    if (this.perCharacterGroup) {
      this.group.remove(this.perCharacterGroup);
    }
  }
}

/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var Node = /** @class */ (function () {
    function Node(key, data) {
        this.next = null;
        this.key = key;
        this.data = data;
        this.left = null;
        this.right = null;
    }
    return Node;
}());

/* follows "An implementation of top-down splaying"
 * by D. Sleator <sleator@cs.cmu.edu> March 1992
 */
function DEFAULT_COMPARE(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Simple top down splay, not requiring i to be in the tree t.
 */
function splay(i, t, comparator) {
    var N = new Node(null, null);
    var l = N;
    var r = N;
    while (true) {
        var cmp = comparator(i, t.key);
        //if (i < t.key) {
        if (cmp < 0) {
            if (t.left === null)
                break;
            //if (i < t.left.key) {
            if (comparator(i, t.left.key) < 0) {
                var y = t.left; /* rotate right */
                t.left = y.right;
                y.right = t;
                t = y;
                if (t.left === null)
                    break;
            }
            r.left = t; /* link right */
            r = t;
            t = t.left;
            //} else if (i > t.key) {
        }
        else if (cmp > 0) {
            if (t.right === null)
                break;
            //if (i > t.right.key) {
            if (comparator(i, t.right.key) > 0) {
                var y = t.right; /* rotate left */
                t.right = y.left;
                y.left = t;
                t = y;
                if (t.right === null)
                    break;
            }
            l.right = t; /* link left */
            l = t;
            t = t.right;
        }
        else
            break;
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
}
function insert(i, data, t, comparator) {
    var node = new Node(i, data);
    if (t === null) {
        node.left = node.right = null;
        return node;
    }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
    }
    else if (cmp >= 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
    }
    return node;
}
function split(key, v, comparator) {
    var left = null;
    var right = null;
    if (v) {
        v = splay(key, v, comparator);
        var cmp = comparator(v.key, key);
        if (cmp === 0) {
            left = v.left;
            right = v.right;
        }
        else if (cmp < 0) {
            right = v.right;
            v.right = null;
            left = v;
        }
        else {
            left = v.left;
            v.left = null;
            right = v;
        }
    }
    return { left: left, right: right };
}
function merge(left, right, comparator) {
    if (right === null)
        return left;
    if (left === null)
        return right;
    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
}
/**
 * Prints level of the tree
 */
function printRow(root, prefix, isTail, out, printNode) {
    if (root) {
        out("" + prefix + (isTail ? ' ' : ' ') + printNode(root) + "\n");
        var indent = prefix + (isTail ? '    ' : '   ');
        if (root.left)
            printRow(root.left, indent, false, out, printNode);
        if (root.right)
            printRow(root.right, indent, true, out, printNode);
    }
}
var Tree = /** @class */ (function () {
    function Tree(comparator) {
        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }
        this._root = null;
        this._size = 0;
        this._comparator = comparator;
    }
    /**
     * Inserts a key, allows duplicates
     */
    Tree.prototype.insert = function (key, data) {
        this._size++;
        return this._root = insert(key, data, this._root, this._comparator);
    };
    /**
     * Adds a key, if it is not present in the tree
     */
    Tree.prototype.add = function (key, data) {
        var node = new Node(key, data);
        if (this._root === null) {
            node.left = node.right = null;
            this._size++;
            this._root = node;
        }
        var comparator = this._comparator;
        var t = splay(key, this._root, comparator);
        var cmp = comparator(key, t.key);
        if (cmp === 0)
            this._root = t;
        else {
            if (cmp < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
            }
            else if (cmp > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
            }
            this._size++;
            this._root = node;
        }
        return this._root;
    };
    /**
     * @param  {Key} key
     * @return {Node|null}
     */
    Tree.prototype.remove = function (key) {
        this._root = this._remove(key, this._root, this._comparator);
    };
    /**
     * Deletes i from the tree if it's there
     */
    Tree.prototype._remove = function (i, t, comparator) {
        var x;
        if (t === null)
            return null;
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp === 0) { /* found it */
            if (t.left === null) {
                x = t.right;
            }
            else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
            }
            this._size--;
            return x;
        }
        return t; /* It wasn't there */
    };
    /**
     * Removes and returns the node with smallest key
     */
    Tree.prototype.pop = function () {
        var node = this._root;
        if (node) {
            while (node.left)
                node = node.left;
            this._root = splay(node.key, this._root, this._comparator);
            this._root = this._remove(node.key, this._root, this._comparator);
            return { key: node.key, data: node.data };
        }
        return null;
    };
    /**
     * Find without splaying
     */
    Tree.prototype.findStatic = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0)
                return current;
            else if (cmp < 0)
                current = current.left;
            else
                current = current.right;
        }
        return null;
    };
    Tree.prototype.find = function (key) {
        if (this._root) {
            this._root = splay(key, this._root, this._comparator);
            if (this._comparator(key, this._root.key) !== 0)
                return null;
        }
        return this._root;
    };
    Tree.prototype.contains = function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0)
                return true;
            else if (cmp < 0)
                current = current.left;
            else
                current = current.right;
        }
        return false;
    };
    Tree.prototype.forEach = function (visitor, ctx) {
        var current = this._root;
        var Q = []; /* Initialize stack s */
        var done = false;
        while (!done) {
            if (current !== null) {
                Q.push(current);
                current = current.left;
            }
            else {
                if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                }
                else
                    done = true;
            }
        }
        return this;
    };
    /**
     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
     */
    Tree.prototype.range = function (low, high, fn, ctx) {
        var Q = [];
        var compare = this._comparator;
        var node = this._root;
        var cmp;
        while (Q.length !== 0 || node) {
            if (node) {
                Q.push(node);
                node = node.left;
            }
            else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp > 0) {
                    break;
                }
                else if (compare(node.key, low) >= 0) {
                    if (fn.call(ctx, node))
                        return this; // stop if smth is returned
                }
                node = node.right;
            }
        }
        return this;
    };
    /**
     * Returns array of keys
     */
    Tree.prototype.keys = function () {
        var keys = [];
        this.forEach(function (_a) {
            var key = _a.key;
            return keys.push(key);
        });
        return keys;
    };
    /**
     * Returns array of all the data in the nodes
     */
    Tree.prototype.values = function () {
        var values = [];
        this.forEach(function (_a) {
            var data = _a.data;
            return values.push(data);
        });
        return values;
    };
    Tree.prototype.min = function () {
        if (this._root)
            return this.minNode(this._root).key;
        return null;
    };
    Tree.prototype.max = function () {
        if (this._root)
            return this.maxNode(this._root).key;
        return null;
    };
    Tree.prototype.minNode = function (t) {
        if (t === void 0) { t = this._root; }
        if (t)
            while (t.left)
                t = t.left;
        return t;
    };
    Tree.prototype.maxNode = function (t) {
        if (t === void 0) { t = this._root; }
        if (t)
            while (t.right)
                t = t.right;
        return t;
    };
    /**
     * Returns node at given index
     */
    Tree.prototype.at = function (index) {
        var current = this._root;
        var done = false;
        var i = 0;
        var Q = [];
        while (!done) {
            if (current) {
                Q.push(current);
                current = current.left;
            }
            else {
                if (Q.length > 0) {
                    current = Q.pop();
                    if (i === index)
                        return current;
                    i++;
                    current = current.right;
                }
                else
                    done = true;
            }
        }
        return null;
    };
    Tree.prototype.next = function (d) {
        var root = this._root;
        var successor = null;
        if (d.right) {
            successor = d.right;
            while (successor.left)
                successor = successor.left;
            return successor;
        }
        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0)
                break;
            else if (cmp < 0) {
                successor = root;
                root = root.left;
            }
            else
                root = root.right;
        }
        return successor;
    };
    Tree.prototype.prev = function (d) {
        var root = this._root;
        var predecessor = null;
        if (d.left !== null) {
            predecessor = d.left;
            while (predecessor.right)
                predecessor = predecessor.right;
            return predecessor;
        }
        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0)
                break;
            else if (cmp < 0)
                root = root.left;
            else {
                predecessor = root;
                root = root.right;
            }
        }
        return predecessor;
    };
    Tree.prototype.clear = function () {
        this._root = null;
        this._size = 0;
        return this;
    };
    Tree.prototype.toList = function () {
        return toList(this._root);
    };
    /**
     * Bulk-load items. Both array have to be same size
     */
    Tree.prototype.load = function (keys, values, presort) {
        if (values === void 0) { values = []; }
        if (presort === void 0) { presort = false; }
        var size = keys.length;
        var comparator = this._comparator;
        // sort if needed
        if (presort)
            sort(keys, values, 0, size - 1, comparator);
        if (this._root === null) { // empty tree
            this._root = loadRecursive(keys, values, 0, size);
            this._size = size;
        }
        else { // that re-builds the whole tree from two in-order traversals
            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
            size = this._size + size;
            this._root = sortedListToBST({ head: mergedList }, 0, size);
        }
        return this;
    };
    Tree.prototype.isEmpty = function () { return this._root === null; };
    Object.defineProperty(Tree.prototype, "size", {
        get: function () { return this._size; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tree.prototype, "root", {
        get: function () { return this._root; },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.toString = function (printNode) {
        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }
        var out = [];
        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
        return out.join('');
    };
    Tree.prototype.update = function (key, newKey, newData) {
        var comparator = this._comparator;
        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
        if (comparator(key, newKey) < 0) {
            right = insert(newKey, newData, right, comparator);
        }
        else {
            left = insert(newKey, newData, left, comparator);
        }
        this._root = merge(left, right, comparator);
    };
    Tree.prototype.split = function (key) {
        return split(key, this._root, this._comparator);
    };
    Tree.prototype[Symbol.iterator] = function () {
        var current, Q, done;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this._root;
                    Q = [];
                    done = false;
                    _a.label = 1;
                case 1:
                    if (!!done) return [3 /*break*/, 6];
                    if (!(current !== null)) return [3 /*break*/, 2];
                    Q.push(current);
                    current = current.left;
                    return [3 /*break*/, 5];
                case 2:
                    if (!(Q.length !== 0)) return [3 /*break*/, 4];
                    current = Q.pop();
                    return [4 /*yield*/, current];
                case 3:
                    _a.sent();
                    current = current.right;
                    return [3 /*break*/, 5];
                case 4:
                    done = true;
                    _a.label = 5;
                case 5: return [3 /*break*/, 1];
                case 6: return [2 /*return*/];
            }
        });
    };
    return Tree;
}());
function loadRecursive(keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var key = keys[middle];
        var data = values[middle];
        var node = new Node(key, data);
        node.left = loadRecursive(keys, values, start, middle);
        node.right = loadRecursive(keys, values, middle + 1, end);
        return node;
    }
    return null;
}
function createList(keys, values) {
    var head = new Node(null, null);
    var p = head;
    for (var i = 0; i < keys.length; i++) {
        p = p.next = new Node(keys[i], values[i]);
    }
    p.next = null;
    return head.next;
}
function toList(root) {
    var current = root;
    var Q = [];
    var done = false;
    var head = new Node(null, null);
    var p = head;
    while (!done) {
        if (current) {
            Q.push(current);
            current = current.left;
        }
        else {
            if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
            }
            else
                done = true;
        }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
}
function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
        var middle = start + Math.floor(size / 2);
        var left = sortedListToBST(list, start, middle);
        var root = list.head;
        root.left = left;
        list.head = list.head.next;
        root.right = sortedListToBST(list, middle + 1, end);
        return root;
    }
    return null;
}
function mergeLists(l1, l2, compare) {
    var head = new Node(null, null); // dummy
    var p = head;
    var p1 = l1;
    var p2 = l2;
    while (p1 !== null && p2 !== null) {
        if (compare(p1.key, p2.key) < 0) {
            p.next = p1;
            p1 = p1.next;
        }
        else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next;
    }
    if (p1 !== null) {
        p.next = p1;
    }
    else if (p2 !== null) {
        p.next = p2;
    }
    return head.next;
}
function sort(keys, values, left, right, compare) {
    if (left >= right)
        return;
    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;
    while (true) {
        do
            i++;
        while (compare(keys[i], pivot) < 0);
        do
            j--;
        while (compare(keys[j], pivot) > 0);
        if (i >= j)
            break;
        var tmp = keys[i];
        keys[i] = keys[j];
        keys[j] = tmp;
        tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }
    sort(keys, values, left, j, compare);
    sort(keys, values, j + 1, right, compare);
}

const epsilon$1 = 1.1102230246251565e-16;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;

// fast_expansion_sum_zeroelim routine from oritinal code
function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if ((fnow > enow) === (fnow > -enow)) {
        Q = enow;
        enow = e[++eindex];
    } else {
        Q = fnow;
        fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
        if ((fnow > enow) === (fnow > -enow)) {
            Qnew = enow + Q;
            hh = Q - (Qnew - enow);
            enow = e[++eindex];
        } else {
            Qnew = fnow + Q;
            hh = Q - (Qnew - fnow);
            fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
        while (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
            } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
    }
    while (eindex < elen) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    while (findex < flen) {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    if (Q !== 0 || hindex === 0) {
        h[hindex++] = Q;
    }
    return hindex;
}

function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++) Q += e[i];
    return Q;
}

function vec(n) {
    return new Float64Array(n);
}

const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;

const B = vec(4);
const C1 = vec(8);
const C2 = vec(12);
const D = vec(16);
const u = vec(4);

function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;

    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;

    let det = estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
        return det;
    }

    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);

    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
        return det;
    }

    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;

    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = sum(4, B, 4, u, C1);

    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = sum(C1len, C1, 4, u, C2);

    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = sum(C2len, C2, 4, u, D);

    return D[Dlen - 1];
}

function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;

    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;

    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

var define_process_default = { };
var define_process_env_default = {};
const isInBbox = (bbox, point) => {
  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
};
const getBboxOverlap = (b1, b2) => {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;
  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
let epsilon = Number.EPSILON;
if (epsilon === void 0) epsilon = Math.pow(2, -52);
const EPSILON_SQ = epsilon * epsilon;
const cmp = (a, b) => {
  if (-epsilon < a && a < epsilon) {
    if (-epsilon < b && b < epsilon) {
      return 0;
    }
  }
  const ab = a - b;
  if (ab * ab < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
class PtRounder {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new CoordRounder();
    this.yRounder = new CoordRounder();
  }
  round(x, y) {
    return {
      x: this.xRounder.round(x),
      y: this.yRounder.round(y)
    };
  }
}
class CoordRounder {
  constructor() {
    this.tree = new Tree();
    this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(coord) {
    const node = this.tree.add(coord);
    const prevNode = this.tree.prev(node);
    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
      this.tree.remove(coord);
      return prevNode.key;
    }
    const nextNode = this.tree.next(node);
    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
      this.tree.remove(coord);
      return nextNode.key;
    }
    return coord;
  }
}
const rounder = new PtRounder();
const crossProduct = (a, b) => a.x * b.y - a.y * b.x;
const dotProduct = (a, b) => a.x * b.x + a.y * b.y;
const compareVectorAngles = (basePt, endPt1, endPt2) => {
  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
  if (res > 0) return -1;
  if (res < 0) return 1;
  return 0;
};
const length = (v) => Math.sqrt(dotProduct(v, v));
const sineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
const cosineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
const horizontalIntersection = (pt, v, y) => {
  if (v.y === 0) return null;
  return {
    x: pt.x + v.x / v.y * (y - pt.y),
    y
  };
};
const verticalIntersection = (pt, v, x) => {
  if (v.x === 0) return null;
  return {
    x,
    y: pt.y + v.y / v.x * (x - pt.x)
  };
};
const intersection$1 = (pt1, v1, pt2, v2) => {
  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);
  const kross = crossProduct(v1, v2);
  if (kross == 0) return null;
  const ve = {
    x: pt2.x - pt1.x,
    y: pt2.y - pt1.y
  };
  const d1 = crossProduct(ve, v1) / kross;
  const d2 = crossProduct(ve, v2) / kross;
  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
  const x = (x1 + x2) / 2;
  const y = (y1 + y2) / 2;
  return {
    x,
    y
  };
};
class SweepEvent {
  // for ordering sweep events in the sweep event queue
  static compare(a, b) {
    const ptCmp = SweepEvent.comparePoints(a.point, b.point);
    if (ptCmp !== 0) return ptCmp;
    if (a.point !== b.point) a.link(b);
    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;
    return Segment.compare(a.segment, b.segment);
  }
  // for ordering points in sweep line order
  static comparePoints(aPt, bPt) {
    if (aPt.x < bPt.x) return -1;
    if (aPt.x > bPt.x) return 1;
    if (aPt.y < bPt.y) return -1;
    if (aPt.y > bPt.y) return 1;
    return 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(point, isLeft) {
    if (point.events === void 0) point.events = [this];
    else point.events.push(this);
    this.point = point;
    this.isLeft = isLeft;
  }
  link(other) {
    if (other.point === this.point) {
      throw new Error("Tried to link already linked events");
    }
    const otherEvents = other.point.events;
    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
      const evt = otherEvents[i];
      this.point.events.push(evt);
      evt.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const numEvents = this.point.events.length;
    for (let i = 0; i < numEvents; i++) {
      const evt1 = this.point.events[i];
      if (evt1.segment.consumedBy !== void 0) continue;
      for (let j = i + 1; j < numEvents; j++) {
        const evt2 = this.point.events[j];
        if (evt2.consumedBy !== void 0) continue;
        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
        evt1.segment.consume(evt2.segment);
      }
    }
  }
  getAvailableLinkedEvents() {
    const events = [];
    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
      const evt = this.point.events[i];
      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
        events.push(evt);
      }
    }
    return events;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(baseEvent) {
    const cache = /* @__PURE__ */ new Map();
    const fillCache = (linkedEvent) => {
      const nextEvent = linkedEvent.otherSE;
      cache.set(linkedEvent, {
        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
      });
    };
    return (a, b) => {
      if (!cache.has(a)) fillCache(a);
      if (!cache.has(b)) fillCache(b);
      const {
        sine: asine,
        cosine: acosine
      } = cache.get(a);
      const {
        sine: bsine,
        cosine: bcosine
      } = cache.get(b);
      if (asine >= 0 && bsine >= 0) {
        if (acosine < bcosine) return 1;
        if (acosine > bcosine) return -1;
        return 0;
      }
      if (asine < 0 && bsine < 0) {
        if (acosine < bcosine) return -1;
        if (acosine > bcosine) return 1;
        return 0;
      }
      if (bsine < asine) return -1;
      if (bsine > asine) return 1;
      return 0;
    };
  }
}
let segmentId = 0;
class Segment {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(a, b) {
    const alx = a.leftSE.point.x;
    const blx = b.leftSE.point.x;
    const arx = a.rightSE.point.x;
    const brx = b.rightSE.point.x;
    if (brx < alx) return 1;
    if (arx < blx) return -1;
    const aly = a.leftSE.point.y;
    const bly = b.leftSE.point.y;
    const ary = a.rightSE.point.y;
    const bry = b.rightSE.point.y;
    if (alx < blx) {
      if (bly < aly && bly < ary) return 1;
      if (bly > aly && bly > ary) return -1;
      const aCmpBLeft = a.comparePoint(b.leftSE.point);
      if (aCmpBLeft < 0) return 1;
      if (aCmpBLeft > 0) return -1;
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
      return -1;
    }
    if (alx > blx) {
      if (aly < bly && aly < bry) return -1;
      if (aly > bly && aly > bry) return 1;
      const bCmpALeft = b.comparePoint(a.leftSE.point);
      if (bCmpALeft !== 0) return bCmpALeft;
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
      return 1;
    }
    if (aly < bly) return -1;
    if (aly > bly) return 1;
    if (arx < brx) {
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0) return bCmpARight;
    }
    if (arx > brx) {
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0) return 1;
      if (aCmpBRight > 0) return -1;
    }
    if (arx !== brx) {
      const ay = ary - aly;
      const ax = arx - alx;
      const by = bry - bly;
      const bx = brx - blx;
      if (ay > ax && by < bx) return 1;
      if (ay < ax && by > bx) return -1;
    }
    if (arx > brx) return 1;
    if (arx < brx) return -1;
    if (ary < bry) return -1;
    if (ary > bry) return 1;
    if (a.id < b.id) return -1;
    if (a.id > b.id) return 1;
    return 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(leftSE, rightSE, rings, windings) {
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  static fromRing(pt1, pt2, ring) {
    let leftPt, rightPt, winding;
    const cmpPts = SweepEvent.comparePoints(pt1, pt2);
    if (cmpPts < 0) {
      leftPt = pt1;
      rightPt = pt2;
      winding = 1;
    } else if (cmpPts > 0) {
      leftPt = pt2;
      rightPt = pt1;
      winding = -1;
    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
    const leftSE = new SweepEvent(leftPt, true);
    const rightSE = new SweepEvent(rightPt, false);
    return new Segment(leftSE, rightSE, [ring], [winding]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(newRightSE) {
    this.rightSE = newRightSE;
    this.rightSE.segment = this;
    this.rightSE.otherSE = this.leftSE;
    this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const y1 = this.leftSE.point.y;
    const y2 = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: y1 < y2 ? y1 : y2
      },
      ur: {
        x: this.rightSE.point.x,
        y: y1 > y2 ? y1 : y2
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(pt) {
    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(point) {
    if (this.isAnEndpoint(point)) return 0;
    const lPt = this.leftSE.point;
    const rPt = this.rightSE.point;
    const v = this.vector();
    if (lPt.x === rPt.x) {
      if (point.x === lPt.x) return 0;
      return point.x < lPt.x ? 1 : -1;
    }
    const yDist = (point.y - lPt.y) / v.y;
    const xFromYDist = lPt.x + yDist * v.x;
    if (point.x === xFromYDist) return 0;
    const xDist = (point.x - lPt.x) / v.x;
    const yFromXDist = lPt.y + xDist * v.y;
    if (point.y === yFromXDist) return 0;
    return point.y < yFromXDist ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(other) {
    const tBbox = this.bbox();
    const oBbox = other.bbox();
    const bboxOverlap = getBboxOverlap(tBbox, oBbox);
    if (bboxOverlap === null) return null;
    const tlp = this.leftSE.point;
    const trp = this.rightSE.point;
    const olp = other.leftSE.point;
    const orp = other.rightSE.point;
    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
    if (touchesThisLSE && touchesOtherLSE) {
      if (touchesThisRSE && !touchesOtherRSE) return trp;
      if (!touchesThisRSE && touchesOtherRSE) return orp;
      return null;
    }
    if (touchesThisLSE) {
      if (touchesOtherRSE) {
        if (tlp.x === orp.x && tlp.y === orp.y) return null;
      }
      return tlp;
    }
    if (touchesOtherLSE) {
      if (touchesThisRSE) {
        if (trp.x === olp.x && trp.y === olp.y) return null;
      }
      return olp;
    }
    if (touchesThisRSE && touchesOtherRSE) return null;
    if (touchesThisRSE) return trp;
    if (touchesOtherRSE) return orp;
    const pt = intersection$1(tlp, this.vector(), olp, other.vector());
    if (pt === null) return null;
    if (!isInBbox(bboxOverlap, pt)) return null;
    return rounder.round(pt.x, pt.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(point) {
    const newEvents = [];
    const alreadyLinked = point.events !== void 0;
    const newLeftSE = new SweepEvent(point, true);
    const newRightSE = new SweepEvent(point, false);
    const oldRightSE = this.rightSE;
    this.replaceRightSE(newRightSE);
    newEvents.push(newRightSE);
    newEvents.push(newLeftSE);
    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
      newSeg.swapEvents();
    }
    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
      this.swapEvents();
    }
    if (alreadyLinked) {
      newLeftSE.checkForConsuming();
      newRightSE.checkForConsuming();
    }
    return newEvents;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const tmpEvt = this.rightSE;
    this.rightSE = this.leftSE;
    this.leftSE = tmpEvt;
    this.leftSE.isLeft = true;
    this.rightSE.isLeft = false;
    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
      this.windings[i] *= -1;
    }
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(other) {
    let consumer = this;
    let consumee = other;
    while (consumer.consumedBy) consumer = consumer.consumedBy;
    while (consumee.consumedBy) consumee = consumee.consumedBy;
    const cmp2 = Segment.compare(consumer, consumee);
    if (cmp2 === 0) return;
    if (cmp2 > 0) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    if (consumer.prev === consumee) {
      const tmp = consumer;
      consumer = consumee;
      consumee = tmp;
    }
    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
      const ring = consumee.rings[i];
      const winding = consumee.windings[i];
      const index2 = consumer.rings.indexOf(ring);
      if (index2 === -1) {
        consumer.rings.push(ring);
        consumer.windings.push(winding);
      } else consumer.windings[index2] += winding;
    }
    consumee.rings = null;
    consumee.windings = null;
    consumee.consumedBy = consumer;
    consumee.leftSE.consumedBy = consumer.leftSE;
    consumee.rightSE.consumedBy = consumer.rightSE;
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    if (this._prevInResult !== void 0) return this._prevInResult;
    if (!this.prev) this._prevInResult = null;
    else if (this.prev.isInResult()) this._prevInResult = this.prev;
    else this._prevInResult = this.prev.prevInResult();
    return this._prevInResult;
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const seg = this.prev.consumedBy || this.prev;
      this._beforeState = seg.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const beforeState = this.beforeState();
    this._afterState = {
      rings: beforeState.rings.slice(0),
      windings: beforeState.windings.slice(0),
      multiPolys: []
    };
    const ringsAfter = this._afterState.rings;
    const windingsAfter = this._afterState.windings;
    const mpsAfter = this._afterState.multiPolys;
    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
      const ring = this.rings[i];
      const winding = this.windings[i];
      const index2 = ringsAfter.indexOf(ring);
      if (index2 === -1) {
        ringsAfter.push(ring);
        windingsAfter.push(winding);
      } else windingsAfter[index2] += winding;
    }
    const polysAfter = [];
    const polysExclude = [];
    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
      if (windingsAfter[i] === 0) continue;
      const ring = ringsAfter[i];
      const poly = ring.poly;
      if (polysExclude.indexOf(poly) !== -1) continue;
      if (ring.isExterior) polysAfter.push(poly);
      else {
        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);
        const index2 = polysAfter.indexOf(ring.poly);
        if (index2 !== -1) polysAfter.splice(index2, 1);
      }
    }
    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
      const mp = polysAfter[i].multiPoly;
      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return false;
    if (this._isInResult !== void 0) return this._isInResult;
    const mpsBefore = this.beforeState().multiPolys;
    const mpsAfter = this.afterState().multiPolys;
    switch (operation.type) {
      case "union": {
        const noBefores = mpsBefore.length === 0;
        const noAfters = mpsAfter.length === 0;
        this._isInResult = noBefores !== noAfters;
        break;
      }
      case "intersection": {
        let least;
        let most;
        if (mpsBefore.length < mpsAfter.length) {
          least = mpsBefore.length;
          most = mpsAfter.length;
        } else {
          least = mpsAfter.length;
          most = mpsBefore.length;
        }
        this._isInResult = most === operation.numMultiPolys && least < most;
        break;
      }
      case "xor": {
        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
        this._isInResult = diff % 2 === 1;
        break;
      }
      case "difference": {
        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${operation.type}`);
    }
    return this._isInResult;
  }
}
class RingIn {
  constructor(geomRing, poly, isExterior) {
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    let prevPoint = firstPoint;
    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      let point = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
      this.segments.push(Segment.fromRing(prevPoint, point, this));
      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
      prevPoint = point;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
    }
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
      const segment = this.segments[i];
      sweepEvents.push(segment.leftSE);
      sweepEvents.push(segment.rightSE);
    }
    return sweepEvents;
  }
}
class PolyIn {
  constructor(geomPoly, multiPoly) {
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
      const ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  getSweepEvents() {
    const sweepEvents = this.exteriorRing.getSweepEvents();
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringSweepEvents = this.interiorRings[i].getSweepEvents();
      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
        sweepEvents.push(ringSweepEvents[j]);
      }
    }
    return sweepEvents;
  }
}
class MultiPolyIn {
  constructor(geom, isSubject) {
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number") geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let i = 0, iMax = geom.length; i < iMax; i++) {
      const poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polySweepEvents = this.polys[i].getSweepEvents();
      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
        sweepEvents.push(polySweepEvents[j]);
      }
    }
    return sweepEvents;
  }
}
class RingOut {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(allSegments) {
    const ringsOut = [];
    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
      const segment = allSegments[i];
      if (!segment.isInResult() || segment.ringOut) continue;
      let prevEvent = null;
      let event = segment.leftSE;
      let nextEvent = segment.rightSE;
      const events = [event];
      const startingPoint = event.point;
      const intersectionLEs = [];
      while (true) {
        prevEvent = event;
        event = nextEvent;
        events.push(event);
        if (event.point === startingPoint) break;
        while (true) {
          const availableLEs = event.getAvailableLinkedEvents();
          if (availableLEs.length === 0) {
            const firstPt = events[0].point;
            const lastPt = events[events.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
          }
          if (availableLEs.length === 1) {
            nextEvent = availableLEs[0].otherSE;
            break;
          }
          let indexLE = null;
          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
            if (intersectionLEs[j].point === event.point) {
              indexLE = j;
              break;
            }
          }
          if (indexLE !== null) {
            const intersectionLE = intersectionLEs.splice(indexLE)[0];
            const ringEvents = events.splice(intersectionLE.index);
            ringEvents.unshift(ringEvents[0].otherSE);
            ringsOut.push(new RingOut(ringEvents.reverse()));
            continue;
          }
          intersectionLEs.push({
            index: events.length,
            point: event.point
          });
          const comparator = event.getLeftmostComparator(prevEvent);
          nextEvent = availableLEs.sort(comparator)[0].otherSE;
          break;
        }
      }
      ringsOut.push(new RingOut(events));
    }
    return ringsOut;
  }
  constructor(events) {
    this.events = events;
    for (let i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  getGeom() {
    let prevPt = this.events[0].point;
    const points = [prevPt];
    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
      const pt2 = this.events[i].point;
      const nextPt2 = this.events[i + 1].point;
      if (compareVectorAngles(pt2, prevPt, nextPt2) === 0) continue;
      points.push(pt2);
      prevPt = pt2;
    }
    if (points.length === 1) return null;
    const pt = points[0];
    const nextPt = points[1];
    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
    points.push(points[0]);
    const step = this.isExteriorRing() ? 1 : -1;
    const iStart = this.isExteriorRing() ? 0 : points.length - 1;
    const iEnd = this.isExteriorRing() ? points.length : -1;
    const orderedPoints = [];
    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);
    return orderedPoints;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const enclosing = this.enclosingRing();
      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    if (this._enclosingRing === void 0) {
      this._enclosingRing = this._calcEnclosingRing();
    }
    return this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let leftMostEvt = this.events[0];
    for (let i = 1, iMax = this.events.length; i < iMax; i++) {
      const evt = this.events[i];
      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
    }
    let prevSeg = leftMostEvt.segment.prevInResult();
    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    while (true) {
      if (!prevSeg) return null;
      if (!prevPrevSeg) return prevSeg.ringOut;
      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
          return prevSeg.ringOut;
        } else return prevSeg.ringOut.enclosingRing();
      }
      prevSeg = prevPrevSeg.prevInResult();
      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    }
  }
}
class PolyOut {
  constructor(exteriorRing) {
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  addInterior(ring) {
    this.interiorRings.push(ring);
    ring.poly = this;
  }
  getGeom() {
    const geom = [this.exteriorRing.getGeom()];
    if (geom[0] === null) return null;
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringGeom = this.interiorRings[i].getGeom();
      if (ringGeom === null) continue;
      geom.push(ringGeom);
    }
    return geom;
  }
}
class MultiPolyOut {
  constructor(rings) {
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  getGeom() {
    const geom = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polyGeom = this.polys[i].getGeom();
      if (polyGeom === null) continue;
      geom.push(polyGeom);
    }
    return geom;
  }
  _composePolys(rings) {
    const polys = [];
    for (let i = 0, iMax = rings.length; i < iMax; i++) {
      const ring = rings[i];
      if (ring.poly) continue;
      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));
      else {
        const enclosingRing = ring.enclosingRing();
        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
        enclosingRing.poly.addInterior(ring);
      }
    }
    return polys;
  }
}
class SweepLine {
  constructor(queue) {
    let comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
    this.queue = queue;
    this.tree = new Tree(comparator);
    this.segments = [];
  }
  process(event) {
    const segment = event.segment;
    const newEvents = [];
    if (event.consumedBy) {
      if (event.isLeft) this.queue.remove(event.otherSE);
      else this.tree.remove(segment);
      return newEvents;
    }
    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
    if (!node) throw new Error(`Unable to find segment #${segment.id} [${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> [${segment.rightSE.point.x}, ${segment.rightSE.point.y}] in SweepLine tree.`);
    let prevNode = node;
    let nextNode = node;
    let prevSeg = void 0;
    let nextSeg = void 0;
    while (prevSeg === void 0) {
      prevNode = this.tree.prev(prevNode);
      if (prevNode === null) prevSeg = null;
      else if (prevNode.key.consumedBy === void 0) prevSeg = prevNode.key;
    }
    while (nextSeg === void 0) {
      nextNode = this.tree.next(nextNode);
      if (nextNode === null) nextSeg = null;
      else if (nextNode.key.consumedBy === void 0) nextSeg = nextNode.key;
    }
    if (event.isLeft) {
      let prevMySplitter = null;
      if (prevSeg) {
        const prevInter = prevSeg.getIntersection(segment);
        if (prevInter !== null) {
          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;
          if (!prevSeg.isAnEndpoint(prevInter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      let nextMySplitter = null;
      if (nextSeg) {
        const nextInter = nextSeg.getIntersection(segment);
        if (nextInter !== null) {
          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;
          if (!nextSeg.isAnEndpoint(nextInter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      if (prevMySplitter !== null || nextMySplitter !== null) {
        let mySplitter = null;
        if (prevMySplitter === null) mySplitter = nextMySplitter;
        else if (nextMySplitter === null) mySplitter = prevMySplitter;
        else {
          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
        }
        this.queue.remove(segment.rightSE);
        newEvents.push(segment.rightSE);
        const newEventsFromSplit = segment.split(mySplitter);
        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
          newEvents.push(newEventsFromSplit[i]);
        }
      }
      if (newEvents.length > 0) {
        this.tree.remove(segment);
        newEvents.push(event);
      } else {
        this.segments.push(segment);
        segment.prev = prevSeg;
      }
    } else {
      if (prevSeg && nextSeg) {
        const inter = prevSeg.getIntersection(nextSeg);
        if (inter !== null) {
          if (!prevSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (!nextSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      this.tree.remove(segment);
    }
    return newEvents;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(seg, pt) {
    this.tree.remove(seg);
    const rightSE = seg.rightSE;
    this.queue.remove(rightSE);
    const newEvents = seg.split(pt);
    newEvents.push(rightSE);
    if (seg.consumedBy === void 0) this.tree.add(seg);
    return newEvents;
  }
}
const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof define_process_default !== "undefined" && define_process_env_default.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof define_process_default !== "undefined" && define_process_env_default.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class Operation {
  run(type, geom, moreGeoms) {
    operation.type = type;
    rounder.reset();
    const multipolys = [new MultiPolyIn(geom, true)];
    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
      multipolys.push(new MultiPolyIn(moreGeoms[i], false));
    }
    operation.numMultiPolys = multipolys.length;
    if (operation.type === "difference") {
      const subject = multipolys[0];
      let i = 1;
      while (i < multipolys.length) {
        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;
        else multipolys.splice(i, 1);
      }
    }
    if (operation.type === "intersection") {
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const mpA = multipolys[i];
        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
        }
      }
    }
    const queue = new Tree(SweepEvent.compare);
    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
      const sweepEvents = multipolys[i].getSweepEvents();
      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
        queue.insert(sweepEvents[j]);
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
        }
      }
    }
    const sweepLine = new SweepLine(queue);
    let prevQueueSize = queue.size;
    let node = queue.pop();
    while (node) {
      const evt = node.key;
      if (queue.size === prevQueueSize) {
        const seg = evt.segment;
        throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent [${evt.point.x}, ${evt.point.y}] from segment #${seg.id} [${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> [${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
      }
      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      }
      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      }
      const newEvents = sweepLine.process(evt);
      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
        const evt2 = newEvents[i];
        if (evt2.consumedBy === void 0) queue.insert(evt2);
      }
      prevQueueSize = queue.size;
      node = queue.pop();
    }
    rounder.reset();
    const ringsOut = RingOut.factory(sweepLine.segments);
    const result = new MultiPolyOut(ringsOut);
    return result.getGeom();
  }
}
const operation = new Operation();
const union = function(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
const intersection = function(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
const xor = function(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
const difference = function(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index = {
  union,
  intersection,
  xor,
  difference
};

function distance$1(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function lerpPoint(a, b, t) {
  return {
    x: a.x + (b.x - a.x) * t,
    y: a.y + (b.y - a.y) * t
  };
}
function addPoints(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
function subtractPoints(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function scalePoint$1(p, s) {
  return { x: p.x * s, y: p.y * s };
}
function normalize(p) {
  const len = Math.sqrt(p.x * p.x + p.y * p.y);
  if (len < 1e-4) return { x: 0, y: 0 };
  return { x: p.x / len, y: p.y / len };
}
function perpendicular(p) {
  return { x: -p.y, y: p.x };
}
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function rotatePoint$1(p, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: p.x * cos - p.y * sin,
    y: p.x * sin + p.y * cos
  };
}
function rotateAround(p, center, angle) {
  const translated = subtractPoints(p, center);
  const rotated = rotatePoint$1(translated, angle);
  return addPoints(rotated, center);
}
function clonePoint(p) {
  return { x: p.x, y: p.y };
}
function cloneVertex(v) {
  return {
    point: clonePoint(v.point),
    inHandle: clonePoint(v.inHandle),
    outHandle: clonePoint(v.outHandle)
  };
}
function clonePath(path) {
  return {
    vertices: path.vertices.map(cloneVertex),
    closed: path.closed
  };
}
function cubicBezierPoint(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = t * t;
  const t3 = t2 * t;
  return {
    x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
    y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y
  };
}
function cubicBezierDerivative(p0, p1, p2, p3, t) {
  const mt = 1 - t;
  const mt2 = mt * mt;
  const t2 = t * t;
  return {
    x: 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x),
    y: 3 * mt2 * (p1.y - p0.y) + 6 * mt * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y)
  };
}
function splitCubicBezier(p0, p1, p2, p3, t) {
  const q0 = lerpPoint(p0, p1, t);
  const q1 = lerpPoint(p1, p2, t);
  const q2 = lerpPoint(p2, p3, t);
  const r0 = lerpPoint(q0, q1, t);
  const r1 = lerpPoint(q1, q2, t);
  const s = lerpPoint(r0, r1, t);
  return [
    [p0, q0, r0, s],
    [s, r1, q2, p3]
  ];
}
function cubicBezierLength(p0, p1, p2, p3, subdivisions = 32) {
  let length = 0;
  let prev = p0;
  for (let i = 1; i <= subdivisions; i++) {
    const t = i / subdivisions;
    const curr = cubicBezierPoint(p0, p1, p2, p3, t);
    length += distance$1(prev, curr);
    prev = curr;
  }
  return length;
}
function getPathLength(path) {
  if (path.vertices.length < 2) return 0;
  let totalLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    totalLength += cubicBezierLength(p0, p1, p2, p3);
  }
  return totalLength;
}
function getPointAtDistance(path, targetDistance, totalLength) {
  if (path.vertices.length < 2) return null;
  const pathLength = totalLength ?? getPathLength(path);
  if (pathLength < 1e-4) return null;
  targetDistance = Math.max(0, Math.min(pathLength, targetDistance));
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    if (accumulatedLength + segmentLength >= targetDistance) {
      const remainingDistance = targetDistance - accumulatedLength;
      const localT = remainingDistance / segmentLength;
      const point = cubicBezierPoint(p0, p1, p2, p3, localT);
      const tangent = normalize(cubicBezierDerivative(p0, p1, p2, p3, localT));
      const globalT = (i + localT) / numSegments;
      return { point, tangent, t: globalT };
    }
    accumulatedLength += segmentLength;
  }
  const lastVertex = path.vertices[path.closed ? 0 : path.vertices.length - 1];
  return {
    point: clonePoint(lastVertex.point),
    tangent: { x: 1, y: 0 },
    t: 1
  };
}
function trimPath(path, startPercent, endPercent, offsetDegrees = 0) {
  if (path.vertices.length < 2) return clonePath(path);
  const totalLength = getPathLength(path);
  if (totalLength < 1e-4) return clonePath(path);
  const offsetPercent = offsetDegrees / 360 * 100;
  let start = ((startPercent + offsetPercent) % 100 + 100) % 100;
  let end = ((endPercent + offsetPercent) % 100 + 100) % 100;
  if (start > end && path.closed) {
    const part1 = trimPathSimple(path, start, 100, totalLength);
    const part2 = trimPathSimple(path, 0, end, totalLength);
    return joinPaths(part1, part2);
  }
  if (start > end) {
    [start, end] = [end, start];
  }
  return trimPathSimple(path, start, end, totalLength);
}
function trimPathSimple(path, startPercent, endPercent, totalLength) {
  const startDist = startPercent / 100 * totalLength;
  const endDist = endPercent / 100 * totalLength;
  if (endDist - startDist < 1e-3) {
    return { vertices: [], closed: false };
  }
  const result = [];
  let accumulatedLength = 0;
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  let inTrimRegion = false;
  let lastPoint = null;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    const segmentLength = cubicBezierLength(p0, p1, p2, p3);
    const segmentStart = accumulatedLength;
    const segmentEnd = accumulatedLength + segmentLength;
    if (segmentEnd > startDist && segmentStart < endDist) {
      const tStart = Math.max(0, (startDist - segmentStart) / segmentLength);
      const tEnd = Math.min(1, (endDist - segmentStart) / segmentLength);
      let trimmedPoints;
      if (tStart > 0 && tEnd < 1) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        const newTEnd = (tEnd - tStart) / (1 - tStart);
        const [left] = splitCubicBezier(right[0], right[1], right[2], right[3], newTEnd);
        trimmedPoints = left;
      } else if (tStart > 0) {
        const [, right] = splitCubicBezier(p0, p1, p2, p3, tStart);
        trimmedPoints = right;
      } else if (tEnd < 1) {
        const [left] = splitCubicBezier(p0, p1, p2, p3, tEnd);
        trimmedPoints = left;
      } else {
        trimmedPoints = [p0, p1, p2, p3];
      }
      if (!inTrimRegion || result.length === 0) {
        result.push({
          point: trimmedPoints[0],
          inHandle: { x: 0, y: 0 },
          outHandle: subtractPoints(trimmedPoints[1], trimmedPoints[0])
        });
        inTrimRegion = true;
      } else if (lastPoint && distance$1(lastPoint, trimmedPoints[0]) > 0.01) {
        if (result.length > 0) {
          result[result.length - 1].outHandle = subtractPoints(trimmedPoints[1], result[result.length - 1].point);
        }
      }
      result.push({
        point: trimmedPoints[3],
        inHandle: subtractPoints(trimmedPoints[2], trimmedPoints[3]),
        outHandle: { x: 0, y: 0 }
      });
      lastPoint = trimmedPoints[3];
    }
    accumulatedLength += segmentLength;
  }
  return { vertices: result, closed: false };
}
function joinPaths(path1, path2) {
  if (path1.vertices.length === 0) return clonePath(path2);
  if (path2.vertices.length === 0) return clonePath(path1);
  const result = clonePath(path1);
  const p2Verts = path2.vertices.map(cloneVertex);
  const lastP1 = result.vertices[result.vertices.length - 1];
  const firstP2 = p2Verts[0];
  if (distance$1(lastP1.point, firstP2.point) < 0.01) {
    lastP1.outHandle = firstP2.outHandle;
    result.vertices.push(...p2Verts.slice(1));
  } else {
    result.vertices.push(...p2Verts);
  }
  return result;
}
function mergePaths(paths, mode) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const polygons = paths.map(pathToPolygon);
  let result = [polygons[0]];
  for (let i = 1; i < polygons.length; i++) {
    const newPolygons = [];
    for (const existing of result) {
      switch (mode) {
        case "add":
          newPolygons.push(...polygonUnion(existing, polygons[i]));
          break;
        case "subtract":
        case "minusFront":
          newPolygons.push(...polygonDifference(existing, polygons[i]));
          break;
        case "minusBack":
          newPolygons.push(...polygonDifference(polygons[i], existing));
          break;
        case "intersect":
          newPolygons.push(...polygonIntersection(existing, polygons[i]));
          break;
        case "exclude":
          newPolygons.push(...polygonXor(existing, polygons[i]));
          break;
      }
    }
    result = newPolygons;
  }
  return result.map(polygonToPath);
}
function booleanOperation(paths, operation, segmentsPerCurve = 32) {
  if (paths.length === 0) return [];
  if (paths.length === 1) return [clonePath(paths[0])];
  const multiPolygons = paths.map((path) => {
    const polygon = pathToPolygon(path, segmentsPerCurve);
    return [point2DArrayToPolygon(polygon)];
  });
  let result;
  try {
    if (multiPolygons.length === 0) {
      return [];
    }
    if (multiPolygons.length === 1) {
      return [clonePath(paths[0])];
    }
    switch (operation) {
      case "union":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.union(result, multiPolygons[i]);
        }
        break;
      case "subtract":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.difference(result, multiPolygons[i]);
        }
        break;
      case "intersect":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.intersection(result, multiPolygons[i]);
        }
        break;
      case "exclude":
        result = multiPolygons[0];
        for (let i = 1; i < multiPolygons.length; i++) {
          result = index.xor(result, multiPolygons[i]);
        }
        break;
      default:
        return paths.map(clonePath);
    }
  } catch {
    return paths.map(clonePath);
  }
  const outputPaths = [];
  for (const polygon of result) {
    if (polygon.length > 0) {
      const points = ringToPoint2DArray(polygon[0]);
      if (points.length >= 3) {
        const bezierPath = fitBezierToPolygon(points, true);
        outputPaths.push(bezierPath);
      }
    }
  }
  return outputPaths;
}
function fitBezierToPolygon(points, closed) {
  if (points.length < 2) {
    return { vertices: [], closed };
  }
  const simplified = simplifyPolygon(points, 0.5);
  if (simplified.length < 2) {
    return polygonToPath(points);
  }
  const vertices = [];
  for (let i = 0; i < simplified.length; i++) {
    const curr = simplified[i];
    const prev = simplified[(i - 1 + simplified.length) % simplified.length];
    const next = simplified[(i + 1) % simplified.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const distPrev = distance$1(curr, prev);
    const distNext = distance$1(curr, next);
    const handleScale = 0.25;
    let inHandle;
    let outHandle;
    {
      const tangent = normalize(subtractPoints(toNext, toPrev));
      inHandle = scalePoint$1(tangent, -distPrev * handleScale);
      outHandle = scalePoint$1(tangent, distNext * handleScale);
    }
    vertices.push({
      point: clonePoint(curr),
      inHandle,
      outHandle
    });
  }
  return { vertices, closed };
}
function simplifyPolygon(points, tolerance) {
  if (points.length <= 2) return points;
  let maxDist = 0;
  let maxIndex = 0;
  const first = points[0];
  const last = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const d = perpendicularDistance(points[i], first, last);
    if (d > maxDist) {
      maxDist = d;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = simplifyPolygon(points.slice(0, maxIndex + 1), tolerance);
    const right = simplifyPolygon(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  }
  return [first, last];
}
function perpendicularDistance(point, lineStart, lineEnd) {
  const dx = lineEnd.x - lineStart.x;
  const dy = lineEnd.y - lineStart.y;
  const lineLengthSq = dx * dx + dy * dy;
  if (lineLengthSq === 0) {
    return distance$1(point, lineStart);
  }
  const t = Math.max(0, Math.min(
    1,
    ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq
  ));
  const projection = {
    x: lineStart.x + t * dx,
    y: lineStart.y + t * dy
  };
  return distance$1(point, projection);
}
function pathToPolygon(path, segments = 16) {
  const points = [];
  const numSegments = path.closed ? path.vertices.length : path.vertices.length - 1;
  for (let i = 0; i < numSegments; i++) {
    const v0 = path.vertices[i];
    const v1 = path.vertices[(i + 1) % path.vertices.length];
    const p0 = v0.point;
    const p1 = addPoints(v0.point, v0.outHandle);
    const p2 = addPoints(v1.point, v1.inHandle);
    const p3 = v1.point;
    for (let j = 0; j < segments; j++) {
      const t = j / segments;
      points.push(cubicBezierPoint(p0, p1, p2, p3, t));
    }
  }
  return points;
}
function polygonToPath(polygon) {
  const vertices = polygon.map((p) => ({
    point: clonePoint(p),
    inHandle: { x: 0, y: 0 },
    outHandle: { x: 0, y: 0 }
  }));
  return { vertices, closed: true };
}
function point2DArrayToRing(points) {
  return points.map((p) => [p.x, p.y]);
}
function ringToPoint2DArray(ring) {
  return ring.map(([x, y]) => ({ x, y }));
}
function point2DArrayToPolygon(points) {
  return [point2DArrayToRing(points)];
}
function multiPolygonToPoint2DArrays(multiPoly) {
  const result = [];
  for (const polygon of multiPoly) {
    if (polygon.length > 0) {
      result.push(ringToPoint2DArray(polygon[0]));
    }
  }
  return result;
}
function polygonUnion(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.union([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a, b];
  }
}
function polygonDifference(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.difference([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a];
  }
}
function polygonIntersection(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.intersection([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [];
  }
}
function polygonXor(a, b) {
  try {
    const polyA = point2DArrayToPolygon(a);
    const polyB = point2DArrayToPolygon(b);
    const result = index.xor([polyA], [polyB]);
    return multiPolygonToPoint2DArrays(result);
  } catch {
    return [a, b];
  }
}
function offsetPath(path, amount, join = "miter", miterLimit = 4) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  const isClosed = path.closed;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    let inDir;
    let outDir;
    if (i === 0 && !isClosed) {
      inDir = { x: 0, y: 0 };
      outDir = normalize(subtractPoints(
        addPoints(next.point, next.inHandle),
        addPoints(curr.point, curr.outHandle)
      ));
    } else if (i === numVertices - 1 && !isClosed) {
      inDir = normalize(subtractPoints(
        addPoints(curr.point, curr.inHandle),
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = { x: 0, y: 0 };
    } else {
      inDir = normalize(subtractPoints(
        curr.point,
        addPoints(prev.point, prev.outHandle)
      ));
      outDir = normalize(subtractPoints(
        addPoints(curr.point, curr.outHandle),
        curr.point
      ));
    }
    let offsetDir;
    if (Math.abs(inDir.x) < 1e-3 && Math.abs(inDir.y) < 1e-3) {
      offsetDir = perpendicular(outDir);
    } else if (Math.abs(outDir.x) < 1e-3 && Math.abs(outDir.y) < 1e-3) {
      offsetDir = perpendicular(inDir);
    } else {
      const perpIn = perpendicular(inDir);
      const perpOut = perpendicular(outDir);
      offsetDir = normalize(addPoints(perpIn, perpOut));
      const angle = Math.acos(Math.max(-1, Math.min(1, dot(inDir, outDir))));
      if (angle > 0.01) {
        const miterFactor = 1 / Math.cos(angle / 2);
        if (join === "miter" && miterFactor <= miterLimit) {
          offsetDir = scalePoint$1(offsetDir, miterFactor);
        }
      }
    }
    const newPoint = addPoints(curr.point, scalePoint$1(offsetDir, amount));
    const handleScale = 1;
    result.push({
      point: newPoint,
      inHandle: scalePoint$1(curr.inHandle, handleScale),
      outHandle: scalePoint$1(curr.outHandle, handleScale)
    });
  }
  return { vertices: result, closed: isClosed };
}
function offsetPathMultiple(path, baseAmount, copies, copyOffset, join = "miter", miterLimit = 4) {
  const results = [clonePath(path)];
  for (let i = 1; i < copies; i++) {
    const amount = baseAmount + copyOffset * i;
    results.push(offsetPath(path, amount, join, miterLimit));
  }
  return results;
}
function puckerBloat(path, amount) {
  if (path.vertices.length < 2 || Math.abs(amount) < 1e-3) {
    return clonePath(path);
  }
  const centroid = { x: 0, y: 0 };
  for (const v of path.vertices) {
    centroid.x += v.point.x;
    centroid.y += v.point.y;
  }
  centroid.x /= path.vertices.length;
  centroid.y /= path.vertices.length;
  const factor = amount / 100;
  const result = path.vertices.map((v) => {
    const dir = subtractPoints(v.point, centroid);
    const dist = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
    if (dist < 1e-3) return cloneVertex(v);
    const moveAmount = dist * factor;
    const newPoint = addPoints(v.point, scalePoint$1(normalize(dir), moveAmount));
    const handleFactor = 1 + factor * 0.5;
    return {
      point: newPoint,
      inHandle: scalePoint$1(v.inHandle, handleFactor),
      outHandle: scalePoint$1(v.outHandle, handleFactor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function wigglePath(path, size, detail, pointType, correlation, temporalPhase, spatialPhase, seed) {
  if (path.vertices.length < 2 || size < 1e-3) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  for (let i = 0; i < Math.floor(temporalPhase * 100); i++) {
    rng.next();
  }
  const correlationFactor = correlation / 100;
  const result = [];
  const subdividedPath = subdividePath(path, Math.max(1, Math.floor(detail)));
  let prevOffset = { x: 0, y: 0 };
  for (let i = 0; i < subdividedPath.vertices.length; i++) {
    const v = subdividedPath.vertices[i];
    const angle = rng.next() * Math.PI * 2 + spatialPhase;
    const magnitude = rng.next() * size;
    const newOffset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const offset = {
      x: prevOffset.x * correlationFactor + newOffset.x * (1 - correlationFactor),
      y: prevOffset.y * correlationFactor + newOffset.y * (1 - correlationFactor)
    };
    prevOffset = offset;
    const newVertex = {
      point: addPoints(v.point, offset),
      inHandle: pointType === "smooth" ? clonePoint(v.inHandle) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? clonePoint(v.outHandle) : { x: 0, y: 0 }
    };
    result.push(newVertex);
  }
  return { vertices: result, closed: path.closed };
}
function subdividePath(path, levels = 1) {
  if (levels <= 0) return clonePath(path);
  let current = clonePath(path);
  for (let level = 0; level < levels; level++) {
    const result = [];
    const numSegments = current.closed ? current.vertices.length : current.vertices.length - 1;
    for (let i = 0; i < numSegments; i++) {
      const v0 = current.vertices[i];
      const v1 = current.vertices[(i + 1) % current.vertices.length];
      const p0 = v0.point;
      const p1 = addPoints(v0.point, v0.outHandle);
      const p2 = addPoints(v1.point, v1.inHandle);
      const p3 = v1.point;
      const [left, right] = splitCubicBezier(p0, p1, p2, p3, 0.5);
      result.push({
        point: left[0],
        inHandle: i === 0 ? v0.inHandle : subtractPoints(left[1], left[0]),
        outHandle: subtractPoints(left[1], left[0])
      });
      result.push({
        point: left[3],
        inHandle: subtractPoints(left[2], left[3]),
        outHandle: subtractPoints(right[1], right[0])
      });
    }
    if (!current.closed) {
      const lastV = current.vertices[current.vertices.length - 1];
      result.push(cloneVertex(lastV));
    }
    current = { vertices: result, closed: current.closed };
  }
  return current;
}
function zigZagPath(path, size, ridgesPerSegment, pointType) {
  if (path.vertices.length < 2 || size < 1e-3 || ridgesPerSegment < 1) {
    return clonePath(path);
  }
  const result = [];
  const totalLength = getPathLength(path);
  const ridgeLength = totalLength / (ridgesPerSegment * (path.vertices.length - (path.closed ? 0 : 1)));
  let currentDistance = 0;
  let zigDirection = 1;
  while (currentDistance < totalLength) {
    const pointData = getPointAtDistance(path, currentDistance, totalLength);
    if (!pointData) break;
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint$1(perp, size * zigDirection);
    const vertex = {
      point: addPoints(pointData.point, offset),
      inHandle: pointType === "smooth" ? scalePoint$1(pointData.tangent, -ridgeLength * 0.3) : { x: 0, y: 0 },
      outHandle: pointType === "smooth" ? scalePoint$1(pointData.tangent, ridgeLength * 0.3) : { x: 0, y: 0 }
    };
    result.push(vertex);
    currentDistance += ridgeLength;
    zigDirection *= -1;
  }
  if (result.length > 0 && !path.closed) {
    const lastVertex = path.vertices[path.vertices.length - 1];
    result.push({
      point: clonePoint(lastVertex.point),
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function roughenPath(path, size, detail, seed, relative = false) {
  if (path.vertices.length < 2 || size < 1e-3 || detail < 1) {
    return clonePath(path);
  }
  const rng = new SeededRandom(seed);
  const result = [];
  let actualSize = size;
  if (relative) {
    const bounds = getPathBounds(path);
    const diagonal = Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height);
    actualSize = size / 100 * diagonal;
  }
  const subdivided = subdividePath(path, Math.max(1, Math.floor(detail)));
  for (const v of subdivided.vertices) {
    const angle = rng.next() * Math.PI * 2;
    const magnitude = rng.next() * actualSize;
    const offset = {
      x: Math.cos(angle) * magnitude,
      y: Math.sin(angle) * magnitude
    };
    const newPoint = addPoints(v.point, offset);
    const handleRoughness = actualSize * 0.5;
    const handleAngle1 = rng.next() * Math.PI * 2;
    const handleMag1 = rng.next() * handleRoughness;
    const handleAngle2 = rng.next() * Math.PI * 2;
    const handleMag2 = rng.next() * handleRoughness;
    result.push({
      point: newPoint,
      inHandle: addPoints(v.inHandle, {
        x: Math.cos(handleAngle1) * handleMag1,
        y: Math.sin(handleAngle1) * handleMag1
      }),
      outHandle: addPoints(v.outHandle, {
        x: Math.cos(handleAngle2) * handleMag2,
        y: Math.sin(handleAngle2) * handleMag2
      })
    });
  }
  return { vertices: result, closed: path.closed };
}
function wavePath(path, amplitude, frequency, phase = 0, waveType = "sine") {
  if (path.vertices.length < 2 || amplitude < 1e-3 || frequency < 0.1) {
    return clonePath(path);
  }
  const totalLength = getPathLength(path);
  if (totalLength < 1e-3) return clonePath(path);
  const samplesPerWave = 16;
  const totalSamples = Math.max(4, Math.ceil(frequency * samplesPerWave));
  const sampleDistance = totalLength / totalSamples;
  const result = [];
  for (let i = 0; i <= totalSamples; i++) {
    const distance2 = Math.min(i * sampleDistance, totalLength - 1e-3);
    const pointData = getPointAtDistance(path, distance2, totalLength);
    if (!pointData) continue;
    const t = distance2 / totalLength;
    const waveInput = t * frequency * Math.PI * 2 + phase;
    let waveValue;
    switch (waveType) {
      case "triangle":
        waveValue = Math.abs(waveInput / Math.PI % 2 - 1) * 2 - 1;
        break;
      case "square":
        waveValue = Math.sin(waveInput) >= 0 ? 1 : -1;
        break;
      case "sine":
      default:
        waveValue = Math.sin(waveInput);
    }
    const perp = perpendicular(pointData.tangent);
    const offset = scalePoint$1(perp, waveValue * amplitude);
    const newPoint = addPoints(pointData.point, offset);
    const handleLength = sampleDistance * 0.3;
    const inHandle = scalePoint$1(pointData.tangent, -handleLength);
    const outHandle = scalePoint$1(pointData.tangent, handleLength);
    result.push({
      point: newPoint,
      inHandle,
      outHandle
    });
  }
  return { vertices: result, closed: path.closed };
}
function getPathBounds(path) {
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minX = Math.min(minX, v.point.x);
    minY = Math.min(minY, v.point.y);
    maxX = Math.max(maxX, v.point.x);
    maxY = Math.max(maxY, v.point.y);
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function twistPath(path, angle, center) {
  if (path.vertices.length < 2 || Math.abs(angle) < 1e-3) {
    return clonePath(path);
  }
  let minY = Infinity, maxY = -Infinity;
  for (const v of path.vertices) {
    minY = Math.min(minY, v.point.y);
    maxY = Math.max(maxY, v.point.y);
  }
  const height = maxY - minY;
  if (height < 1e-3) return clonePath(path);
  const angleRad = angle * Math.PI / 180;
  const result = path.vertices.map((v) => {
    const yNorm = (v.point.y - minY) / height;
    const localAngle = angleRad * yNorm;
    const rotatedPoint = rotateAround(v.point, center, localAngle);
    const absInHandle = addPoints(v.point, v.inHandle);
    const absOutHandle = addPoints(v.point, v.outHandle);
    const rotatedIn = rotateAround(absInHandle, center, localAngle);
    const rotatedOut = rotateAround(absOutHandle, center, localAngle);
    return {
      point: rotatedPoint,
      inHandle: subtractPoints(rotatedIn, rotatedPoint),
      outHandle: subtractPoints(rotatedOut, rotatedPoint)
    };
  });
  return { vertices: result, closed: path.closed };
}
function roundCorners(path, radius) {
  if (path.vertices.length < 2 || radius < 1e-3) {
    return clonePath(path);
  }
  const result = [];
  const numVertices = path.vertices.length;
  for (let i = 0; i < numVertices; i++) {
    const curr = path.vertices[i];
    const prev = path.vertices[(i - 1 + numVertices) % numVertices];
    const next = path.vertices[(i + 1) % numVertices];
    if (!path.closed && (i === 0 || i === numVertices - 1)) {
      result.push(cloneVertex(curr));
      continue;
    }
    const toPrev = normalize(subtractPoints(prev.point, curr.point));
    const toNext = normalize(subtractPoints(next.point, curr.point));
    const dotProduct = dot(toPrev, toNext);
    if (dotProduct > 0.99) {
      result.push(cloneVertex(curr));
      continue;
    }
    const distPrev = distance$1(curr.point, prev.point);
    const distNext = distance$1(curr.point, next.point);
    const maxRadius = Math.min(radius, distPrev / 2, distNext / 2);
    const startPoint = addPoints(curr.point, scalePoint$1(toPrev, maxRadius));
    const endPoint = addPoints(curr.point, scalePoint$1(toNext, maxRadius));
    const kappa = 0.5522847498;
    const handleLength = maxRadius * kappa;
    result.push({
      point: startPoint,
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint$1(toPrev, -handleLength)
    });
    result.push({
      point: endPoint,
      inHandle: scalePoint$1(toNext, -handleLength),
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: result, closed: path.closed };
}
function generateRectangle(position, size, roundness = 0, direction = 1) {
  const hw = size.x / 2;
  const hh = size.y / 2;
  const r = Math.min(roundness, hw, hh);
  const corners = [
    { x: position.x - hw, y: position.y - hh },
    // TL
    { x: position.x + hw, y: position.y - hh },
    // TR
    { x: position.x + hw, y: position.y + hh },
    // BR
    { x: position.x - hw, y: position.y + hh }
    // BL
  ];
  if (direction === -1) {
    corners.reverse();
  }
  if (r < 0.01) {
    return {
      vertices: corners.map((p) => ({
        point: p,
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      })),
      closed: true
    };
  }
  const kappa = 0.5522847498 * r;
  const vertices = [];
  for (let i = 0; i < 4; i++) {
    const curr = corners[i];
    const next = corners[(i + 1) % 4];
    const dir = normalize(subtractPoints(next, curr));
    vertices.push({
      point: addPoints(curr, scalePoint$1(dir, r)),
      inHandle: scalePoint$1(dir, -kappa),
      outHandle: { x: 0, y: 0 }
    });
    vertices.push({
      point: subtractPoints(next, scalePoint$1(dir, r)),
      inHandle: { x: 0, y: 0 },
      outHandle: scalePoint$1(dir, kappa)
    });
  }
  return { vertices, closed: true };
}
function generateEllipse(position, size, direction = 1) {
  const rx = size.x / 2;
  const ry = size.y / 2;
  const kappa = 0.5522847498;
  let vertices = [
    {
      // Top
      point: { x: position.x, y: position.y - ry },
      inHandle: { x: -rx * kappa, y: 0 },
      outHandle: { x: rx * kappa, y: 0 }
    },
    {
      // Right
      point: { x: position.x + rx, y: position.y },
      inHandle: { x: 0, y: -ry * kappa },
      outHandle: { x: 0, y: ry * kappa }
    },
    {
      // Bottom
      point: { x: position.x, y: position.y + ry },
      inHandle: { x: rx * kappa, y: 0 },
      outHandle: { x: -rx * kappa, y: 0 }
    },
    {
      // Left
      point: { x: position.x - rx, y: position.y },
      inHandle: { x: 0, y: ry * kappa },
      outHandle: { x: 0, y: -ry * kappa }
    }
  ];
  if (direction === -1) {
    vertices = vertices.reverse().map((v) => ({
      point: v.point,
      inHandle: v.outHandle,
      outHandle: v.inHandle
    }));
  }
  return { vertices, closed: true };
}
function generatePolygon(position, points, radius, roundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI * 2 / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints; i++) {
    const idx = direction === 1 ? i : numPoints - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.5;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function generateStar(position, points, outerRadius, innerRadius, outerRoundness = 0, innerRoundness = 0, rotation = 0, direction = 1) {
  const numPoints = Math.max(3, Math.floor(points));
  const angleStep = Math.PI / numPoints;
  const startAngle = (rotation - 90) * (Math.PI / 180);
  const vertices = [];
  for (let i = 0; i < numPoints * 2; i++) {
    const idx = direction === 1 ? i : numPoints * 2 - 1 - i;
    const angle = startAngle + angleStep * idx * direction;
    const isOuter = idx % 2 === 0;
    const radius = isOuter ? outerRadius : innerRadius;
    const roundness = isOuter ? outerRoundness : innerRoundness;
    const point = {
      x: position.x + Math.cos(angle) * radius,
      y: position.y + Math.sin(angle) * radius
    };
    const handleLength = radius * (roundness / 100) * 0.3;
    const tangentAngle = angle + Math.PI / 2 * direction;
    vertices.push({
      point,
      inHandle: roundness > 0 ? {
        x: Math.cos(tangentAngle) * handleLength,
        y: Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 },
      outHandle: roundness > 0 ? {
        x: -Math.cos(tangentAngle) * handleLength,
        y: -Math.sin(tangentAngle) * handleLength
      } : { x: 0, y: 0 }
    });
  }
  return { vertices, closed: true };
}
function simplifyPath(path, tolerance, straightLines = false) {
  if (path.vertices.length <= 2) return clonePath(path);
  const points = pathToPolygon(path, 32);
  const simplified = douglasPeucker(points, tolerance);
  if (straightLines) {
    return polygonToPath(simplified);
  } else {
    return fitBezierToPoints(simplified, path.closed);
  }
}
function douglasPeucker(points, tolerance) {
  if (points.length <= 2) return [...points];
  let maxDist = 0;
  let maxIndex = 0;
  const start = points[0];
  const end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const dist = perpendicularDistance(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIndex = i;
    }
  }
  if (maxDist > tolerance) {
    const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
    const right = douglasPeucker(points.slice(maxIndex), tolerance);
    return [...left.slice(0, -1), ...right];
  } else {
    return [start, end];
  }
}
function fitBezierToPoints(points, closed) {
  const vertices = [];
  for (let i = 0; i < points.length; i++) {
    const prev = points[(i - 1 + points.length) % points.length];
    const curr = points[i];
    const next = points[(i + 1) % points.length];
    const toPrev = subtractPoints(prev, curr);
    const toNext = subtractPoints(next, curr);
    const handleLength = Math.min(
      distance$1(curr, prev) * 0.3,
      distance$1(curr, next) * 0.3
    );
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    vertices.push({
      point: clonePoint(curr),
      inHandle: scalePoint$1(avgDir, -handleLength),
      outHandle: scalePoint$1(avgDir, handleLength)
    });
  }
  return { vertices, closed };
}
function smoothPath(path, amount) {
  if (path.vertices.length < 2) return clonePath(path);
  const factor = amount / 100;
  const result = path.vertices.map((v, i) => {
    const prev = path.vertices[(i - 1 + path.vertices.length) % path.vertices.length];
    const next = path.vertices[(i + 1) % path.vertices.length];
    const toPrev = subtractPoints(prev.point, v.point);
    const toNext = subtractPoints(next.point, v.point);
    const avgDir = normalize(subtractPoints(toNext, toPrev));
    const idealHandleLength = (distance$1(v.point, prev.point) + distance$1(v.point, next.point)) / 6;
    const idealIn = scalePoint$1(avgDir, -idealHandleLength);
    const idealOut = scalePoint$1(avgDir, idealHandleLength);
    return {
      point: clonePoint(v.point),
      inHandle: lerpPoint(v.inHandle, idealIn, factor),
      outHandle: lerpPoint(v.outHandle, idealOut, factor)
    };
  });
  return { vertices: result, closed: path.closed };
}
function applyRepeater(paths, copies, offset, anchorPoint, position, scale, rotation, startOpacity, endOpacity) {
  const results = [];
  for (let i = 0; i < copies; i++) {
    const t = copies > 1 ? i / (copies - 1) : 0;
    const copyRotation = rotation * i;
    const copyScale = {
      x: 100 + (scale.x - 100) * i,
      y: 100 + (scale.y - 100) * i
    };
    const copyPosition = {
      x: position.x * i,
      y: position.y * i
    };
    const copyOpacity = startOpacity + (endOpacity - startOpacity) * t;
    const transformedPaths = paths.map((path) => {
      return transformPath(path, anchorPoint, copyPosition, copyScale, copyRotation);
    });
    results.push({
      paths: transformedPaths,
      opacities: paths.map(() => copyOpacity / 100)
    });
  }
  return results;
}
function transformPath(path, anchorPoint, position, scale, rotation) {
  const rotRad = rotation * Math.PI / 180;
  const cos = Math.cos(rotRad);
  const sin = Math.sin(rotRad);
  const transformPoint = (p) => {
    let x = p.x - anchorPoint.x;
    let y = p.y - anchorPoint.y;
    x *= scale.x / 100;
    y *= scale.y / 100;
    const rx = x * cos - y * sin;
    const ry = x * sin + y * cos;
    return {
      x: rx + anchorPoint.x + position.x,
      y: ry + anchorPoint.y + position.y
    };
  };
  const vertices = path.vertices.map((v) => {
    const newPoint = transformPoint(v.point);
    const absIn = addPoints(v.point, v.inHandle);
    const absOut = addPoints(v.point, v.outHandle);
    const newIn = transformPoint(absIn);
    const newOut = transformPoint(absOut);
    return {
      point: newPoint,
      inHandle: subtractPoints(newIn, newPoint),
      outHandle: subtractPoints(newOut, newPoint)
    };
  });
  return { vertices, closed: path.closed };
}
const ShapeOperations = {
  // Utilities
  distance: distance$1,
  lerpPoint,
  addPoints,
  subtractPoints,
  scalePoint: scalePoint$1,
  normalize,
  perpendicular,
  clonePath,
  // Bezier
  cubicBezierPoint,
  cubicBezierLength,
  getPathLength,
  getPointAtDistance,
  splitCubicBezier,
  // Path operators
  trimPath,
  mergePaths,
  offsetPath,
  offsetPathMultiple,
  puckerBloat,
  wigglePath,
  zigZagPath,
  roughenPath,
  wavePath,
  twistPath,
  roundCorners,
  booleanOperation,
  // Generators
  generateRectangle,
  generateEllipse,
  generatePolygon,
  generateStar,
  // Illustrator features
  simplifyPath,
  smoothPath,
  // Repeater
  applyRepeater,
  transformPath
};

const logger$3 = createLogger("VectorLOD");
const DEFAULT_LOD_CONFIG = {
  enabled: true,
  mode: "both",
  levels: [],
  maxPointsForPreview: 100,
  simplificationTolerance: 2,
  cullingEnabled: true,
  cullMargin: 50
};
class VectorLODService {
  // Cache for generated LOD levels by layer ID
  lodCache = /* @__PURE__ */ new Map();
  /**
   * Generate LOD levels for a set of control points
   *
   * @param layerId Layer ID for caching (optional - pass empty string to skip caching)
   * @param controlPoints Original high-quality points
   * @param levelCount Number of LOD levels to generate
   * @param baseTolerance Base tolerance for simplification
   * @returns Array of LOD levels from highest to lowest quality
   */
  generateLODLevels(layerId, controlPoints, levelCount = 4, baseTolerance = 2) {
    if (layerId && this.lodCache.has(layerId)) {
      return this.lodCache.get(layerId);
    }
    const levels = [];
    const originalCount = controlPoints.length;
    levels.push({
      tolerance: 0,
      controlPoints: [...controlPoints],
      pointCount: originalCount,
      complexity: 1
    });
    const toleranceMultipliers = [0.5, 1, 2, 5, 10];
    for (let i = 0; i < Math.min(levelCount - 1, toleranceMultipliers.length); i++) {
      const tolerance = baseTolerance * toleranceMultipliers[i];
      const simplified = this.simplifyPath(controlPoints, tolerance);
      const prevCount = levels[levels.length - 1].pointCount;
      if (simplified.length < prevCount * 0.9) {
        levels.push({
          tolerance,
          controlPoints: simplified,
          pointCount: simplified.length,
          complexity: simplified.length / originalCount
        });
      }
    }
    if (layerId) {
      this.lodCache.set(layerId, levels);
    }
    logger$3.debug("Generated LOD levels:", levels.map((l) => l.pointCount));
    return levels;
  }
  /**
   * Clear LOD cache for a specific layer or all layers
   */
  clearCache(layerId) {
    if (layerId) {
      this.lodCache.delete(layerId);
    } else {
      this.lodCache.clear();
    }
  }
  /**
   * Select appropriate LOD level based on context
   */
  selectLODLevel(levels, context) {
    if (levels.length === 0) {
      throw new Error("No LOD levels available");
    }
    if (levels.length === 1) {
      return levels[0];
    }
    let targetQuality = 1;
    if (context.zoom < 1) {
      targetQuality *= Math.max(0.2, context.zoom);
    }
    if (context.isPlaying) {
      targetQuality *= 0.7;
    }
    if (context.targetFPS && context.currentFPS) {
      const fpsRatio = context.currentFPS / context.targetFPS;
      if (fpsRatio < 0.8) {
        targetQuality *= fpsRatio;
      }
    }
    let bestLevel = levels[0];
    let bestDiff = Math.abs(levels[0].complexity - targetQuality);
    for (const level of levels) {
      const diff = Math.abs(level.complexity - targetQuality);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestLevel = level;
      }
    }
    return bestLevel;
  }
  /**
   * Cull points outside viewport
   * Returns indices of visible points
   */
  cullOffScreenPoints(points, viewport, margin = 50) {
    const minX = viewport.x - margin;
    const minY = viewport.y - margin;
    const maxX = viewport.x + viewport.width + margin;
    const maxY = viewport.y + viewport.height + margin;
    const visible = /* @__PURE__ */ new Set();
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      if (p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY) {
        visible.add(Math.max(0, i - 1));
        visible.add(i);
        visible.add(Math.min(points.length - 1, i + 1));
      }
    }
    if (visible.size === 0) {
      return [];
    }
    const culled = [];
    for (let i = 0; i < points.length; i++) {
      if (visible.has(i)) {
        culled.push(points[i]);
      }
    }
    return culled;
  }
  /**
   * Simplify path using Ramer-Douglas-Peucker algorithm
   */
  simplifyPath(points, tolerance) {
    if (points.length <= 2) return [...points];
    const simplePoints = points.map((p) => ({ x: p.x, y: p.y }));
    const simplified = this.rdpSimplify(simplePoints, tolerance);
    const result = [];
    let simplifiedIndex = 0;
    for (let i = 0; i < points.length && simplifiedIndex < simplified.length; i++) {
      const p = points[i];
      const s = simplified[simplifiedIndex];
      if (Math.abs(p.x - s.x) < 0.01 && Math.abs(p.y - s.y) < 0.01) {
        result.push({ ...p });
        simplifiedIndex++;
      }
    }
    if (result.length < 2 && points.length >= 2) {
      return [points[0], points[points.length - 1]];
    }
    return result;
  }
  /**
   * Ramer-Douglas-Peucker line simplification
   */
  rdpSimplify(points, tolerance) {
    if (points.length <= 2) return points;
    let maxDist = 0;
    let maxIndex = 0;
    const first = points[0];
    const last = points[points.length - 1];
    for (let i = 1; i < points.length - 1; i++) {
      const d = this.perpendicularDistance(points[i], first, last);
      if (d > maxDist) {
        maxDist = d;
        maxIndex = i;
      }
    }
    if (maxDist > tolerance) {
      const left = this.rdpSimplify(points.slice(0, maxIndex + 1), tolerance);
      const right = this.rdpSimplify(points.slice(maxIndex), tolerance);
      return [...left.slice(0, -1), ...right];
    }
    return [first, last];
  }
  /**
   * Calculate perpendicular distance from point to line
   */
  perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lineLengthSq = dx * dx + dy * dy;
    if (lineLengthSq === 0) {
      return Math.sqrt(
        (point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2
      );
    }
    const t = Math.max(0, Math.min(
      1,
      ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq
    ));
    const projX = lineStart.x + t * dx;
    const projY = lineStart.y + t * dy;
    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);
  }
  /**
   * Estimate rendering complexity of a path
   */
  estimateComplexity(points) {
    let complexity = points.length;
    for (const p of points) {
      if (p.handleIn || p.handleOut) {
        complexity += 0.5;
      }
    }
    return complexity;
  }
  /**
   * Check if LOD should be used for a spline
   */
  shouldUseLOD(splineData, context) {
    if (!splineData.lod?.enabled) return false;
    const pointCount = splineData.controlPoints.length;
    if (pointCount < 50) return false;
    if (context.isPlaying && splineData.lod.mode !== "zoom") return true;
    if (context.zoom < 0.5 && splineData.lod.mode !== "playback") return true;
    return false;
  }
  /**
   * Auto-generate LOD config for a spline if point count exceeds threshold
   */
  autoGenerateLOD(splineData, threshold = 200) {
    if (splineData.controlPoints.length < threshold) {
      return null;
    }
    const levels = this.generateLODLevels("", splineData.controlPoints, 4, 2);
    return {
      ...DEFAULT_LOD_CONFIG,
      enabled: true,
      levels
    };
  }
}
const vectorLODService = new VectorLODService();
const vectorLOD = vectorLODService;

const DEFAULT_WARP_WEIGHT_OPTIONS = {
  method: "inverse-distance",
  falloffPower: 2,
  normalize: true,
  minWeight: 1e-3
};

const logger$2 = createLogger("MeshWarpDeformation");
function distance(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function rotatePoint(point, origin, angleDegrees) {
  const angleRadians = angleDegrees * Math.PI / 180;
  const cos = Math.cos(angleRadians);
  const sin = Math.sin(angleRadians);
  const dx = point.x - origin.x;
  const dy = point.y - origin.y;
  return {
    x: origin.x + dx * cos - dy * sin,
    y: origin.y + dx * sin + dy * cos
  };
}
function scalePoint(point, origin, scale) {
  return {
    x: origin.x + (point.x - origin.x) * scale,
    y: origin.y + (point.y - origin.y) * scale
  };
}
function delaunayTriangulate(points) {
  if (points.length < 3) {
    return [];
  }
  const minX = Math.min(...points.map((p) => p.x));
  const maxX = Math.max(...points.map((p) => p.x));
  const minY = Math.min(...points.map((p) => p.y));
  const maxY = Math.max(...points.map((p) => p.y));
  const dx = maxX - minX;
  const dy = maxY - minY;
  const deltaMax = Math.max(dx, dy) * 2;
  const superA = { x: minX - deltaMax, y: minY - deltaMax };
  const superB = { x: minX + deltaMax * 2, y: minY - deltaMax };
  const superC = { x: minX + deltaMax / 2, y: maxY + deltaMax * 2 };
  const allPoints = [...points, superA, superB, superC];
  const superIndices = [points.length, points.length + 1, points.length + 2];
  let triangles = [{ a: superIndices[0], b: superIndices[1], c: superIndices[2] }];
  for (let i = 0; i < points.length; i++) {
    const point = points[i];
    const badTriangles = [];
    const polygon = [];
    for (const tri of triangles) {
      if (isPointInCircumcircle(point, allPoints[tri.a], allPoints[tri.b], allPoints[tri.c])) {
        badTriangles.push(tri);
      }
    }
    for (const tri of badTriangles) {
      const edges = [
        { a: tri.a, b: tri.b },
        { a: tri.b, b: tri.c },
        { a: tri.c, b: tri.a }
      ];
      for (const edge of edges) {
        let isShared = false;
        for (const other of badTriangles) {
          if (other === tri) continue;
          const otherEdges = [
            { a: other.a, b: other.b },
            { a: other.b, b: other.c },
            { a: other.c, b: other.a }
          ];
          for (const otherEdge of otherEdges) {
            if (edge.a === otherEdge.a && edge.b === otherEdge.b || edge.a === otherEdge.b && edge.b === otherEdge.a) {
              isShared = true;
              break;
            }
          }
          if (isShared) break;
        }
        if (!isShared) {
          polygon.push(edge);
        }
      }
    }
    triangles = triangles.filter((t) => !badTriangles.includes(t));
    for (const edge of polygon) {
      triangles.push({ a: edge.a, b: edge.b, c: i });
    }
  }
  return triangles.filter(
    (t) => !superIndices.includes(t.a) && !superIndices.includes(t.b) && !superIndices.includes(t.c)
  );
}
function isPointInCircumcircle(point, a, b, c) {
  const ax = a.x - point.x;
  const ay = a.y - point.y;
  const bx = b.x - point.x;
  const by = b.y - point.y;
  const cx = c.x - point.x;
  const cy = c.y - point.y;
  const det = (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay);
  const orientation = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
  return orientation > 0 ? det > 0 : det < 0;
}
function calculateWeights(vertices, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
  const vertexCount = vertices.length / 2;
  const pinCount = pins.length;
  if (pinCount === 0) {
    return new Float32Array(0);
  }
  const weights = new Float32Array(vertexCount * pinCount);
  for (let v = 0; v < vertexCount; v++) {
    const vx = vertices[v * 2];
    const vy = vertices[v * 2 + 1];
    let totalWeight = 0;
    const vertexWeights = [];
    for (let p = 0; p < pinCount; p++) {
      const pin = pins[p];
      const pinPos = pin.position.value;
      const dist = distance({ x: vx, y: vy }, pinPos);
      let weight;
      switch (options.method) {
        case "bounded":
        case "radial-basis":
        case "heat-diffusion":
        case "inverse-distance":
        default: {
          if (dist < 1e-3) {
            weight = 1e3;
          } else if (dist > pin.radius * 3) {
            weight = 0;
          } else {
            const normalizedDist = dist / pin.radius;
            weight = Math.pow(1 / (1 + normalizedDist), options.falloffPower);
            if (pin.stiffness > 0) {
              weight *= 1 - pin.stiffness * 0.5;
            }
          }
          break;
        }
      }
      if (weight < options.minWeight) {
        weight = 0;
      }
      vertexWeights.push(weight);
      totalWeight += weight;
    }
    for (let p = 0; p < pinCount; p++) {
      let finalWeight = vertexWeights[p];
      if (options.normalize && totalWeight > 0) {
        finalWeight = finalWeight / totalWeight;
      }
      weights[v * pinCount + p] = finalWeight;
    }
  }
  return weights;
}
function evaluatePinAtFrame(pin, restState, frame) {
  const position = {
    x: interpolateProperty(pin.position, frame).x,
    y: interpolateProperty(pin.position, frame).y
  };
  const rotation = interpolateProperty(pin.rotation, frame);
  const scale = interpolateProperty(pin.scale, frame);
  const delta = {
    x: position.x - restState.position.x,
    y: position.y - restState.position.y
  };
  return { position, rotation, scale, delta };
}
function deformMesh(mesh, frame) {
  const { originalVertices, pins, weights, pinRestStates, vertexCount } = mesh;
  const pinCount = pins.length;
  if (pinCount === 0 || vertexCount === 0) {
    return new Float32Array(originalVertices);
  }
  const pinStates = pins.map(
    (pin, i) => evaluatePinAtFrame(pin, pinRestStates[i], frame)
  );
  const deformedVertices = new Float32Array(vertexCount * 2);
  for (let v = 0; v < vertexCount; v++) {
    const origX = originalVertices[v * 2];
    const origY = originalVertices[v * 2 + 1];
    let deformedX = 0;
    let deformedY = 0;
    let totalWeight = 0;
    for (let p = 0; p < pinCount; p++) {
      const weight = weights[v * pinCount + p];
      if (weight <= 0) continue;
      const pin = pins[p];
      const pinState = pinStates[p];
      const restState = pinRestStates[p];
      let pinDeformed = { x: origX, y: origY };
      pinDeformed = {
        x: pinDeformed.x + pinState.delta.x,
        y: pinDeformed.y + pinState.delta.y
      };
      if (pin.type === "rotation" || Math.abs(pinState.rotation - restState.rotation) > 1e-3) {
        const rotationDelta = pinState.rotation - restState.rotation;
        pinDeformed = rotatePoint(
          pinDeformed,
          pinState.position,
          rotationDelta
        );
      }
      if (Math.abs(pinState.scale - restState.scale) > 1e-3) {
        const scaleDelta = pinState.scale / restState.scale;
        pinDeformed = scalePoint(
          pinDeformed,
          pinState.position,
          scaleDelta
        );
      }
      deformedX += pinDeformed.x * weight;
      deformedY += pinDeformed.y * weight;
      totalWeight += weight;
    }
    if (totalWeight > 0) {
      deformedVertices[v * 2] = deformedX / totalWeight;
      deformedVertices[v * 2 + 1] = deformedY / totalWeight;
    } else {
      deformedVertices[v * 2] = origX;
      deformedVertices[v * 2 + 1] = origY;
    }
  }
  return deformedVertices;
}
class MeshWarpDeformationService {
  meshCache = /* @__PURE__ */ new Map();
  /**
   * Build a warp mesh from control points and pins
   */
  buildMesh(layerId, controlPoints, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const vertices = new Float32Array(controlPoints.length * 2);
    for (let i = 0; i < controlPoints.length; i++) {
      vertices[i * 2] = controlPoints[i].x;
      vertices[i * 2 + 1] = controlPoints[i].y;
    }
    const pinRestStates = pins.map((pin) => ({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    }));
    const allPoints = [
      ...controlPoints.map((cp) => ({ x: cp.x, y: cp.y })),
      ...pins.map((pin) => pin.position.value)
    ];
    const triangles = delaunayTriangulate(allPoints);
    const triangulation = [];
    for (const tri of triangles) {
      triangulation.push(tri.a, tri.b, tri.c);
    }
    const weights = calculateWeights(vertices, pins, options);
    const mesh = {
      layerId,
      pins,
      triangulation,
      weights,
      originalVertices: vertices,
      pinRestStates,
      vertexCount: controlPoints.length,
      dirty: false
    };
    this.meshCache.set(layerId, mesh);
    logger$2.debug(`Built warp mesh: ${controlPoints.length} vertices, ${pins.length} pins`);
    return mesh;
  }
  /**
   * Get or build a mesh for a layer
   */
  getMesh(layerId) {
    return this.meshCache.get(layerId);
  }
  /**
   * Clear cached mesh for a layer
   */
  clearMesh(layerId) {
    this.meshCache.delete(layerId);
  }
  /**
   * Update mesh when pins change
   */
  updateMeshPins(layerId, pins, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    mesh.pins = pins;
    mesh.pinRestStates = pins.map((pin) => ({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    }));
    mesh.weights = calculateWeights(mesh.originalVertices, pins, options);
    mesh.dirty = false;
  }
  /**
   * Add a pin to an existing mesh
   */
  addPin(layerId, pin, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    mesh.pins.push(pin);
    mesh.pinRestStates.push({
      pinId: pin.id,
      position: { ...pin.position.value },
      rotation: pin.rotation.value,
      scale: pin.scale.value
    });
    mesh.weights = calculateWeights(mesh.originalVertices, mesh.pins, options);
  }
  /**
   * Remove a pin from an existing mesh
   */
  removePin(layerId, pinId, options = DEFAULT_WARP_WEIGHT_OPTIONS) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    const pinIndex = mesh.pins.findIndex((p) => p.id === pinId);
    if (pinIndex === -1) return;
    mesh.pins.splice(pinIndex, 1);
    mesh.pinRestStates.splice(pinIndex, 1);
    mesh.weights = calculateWeights(mesh.originalVertices, mesh.pins, options);
  }
  /**
   * Get deformed control points at a specific frame
   */
  getDeformedControlPoints(layerId, frame, originalControlPoints) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh || mesh.pins.length === 0) {
      return originalControlPoints;
    }
    const deformedVertices = deformMesh(mesh, frame);
    const deformedPoints = originalControlPoints.map((cp, i) => {
      const newX = deformedVertices[i * 2];
      const newY = deformedVertices[i * 2 + 1];
      const dx = newX - cp.x;
      const dy = newY - cp.y;
      return {
        ...cp,
        x: newX,
        y: newY,
        // Also offset handles to maintain shape
        handleIn: cp.handleIn ? { x: cp.handleIn.x + dx, y: cp.handleIn.y + dy } : null,
        handleOut: cp.handleOut ? { x: cp.handleOut.x + dx, y: cp.handleOut.y + dy } : null
      };
    });
    return deformedPoints;
  }
  /**
   * Deform a mesh and return result
   */
  deform(layerId, frame) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return null;
    const vertices = deformMesh(mesh, frame);
    const controlPoints = [];
    for (let i = 0; i < mesh.vertexCount; i++) {
      controlPoints.push({
        x: vertices[i * 2],
        y: vertices[i * 2 + 1],
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      });
    }
    return { vertices, controlPoints };
  }
  /**
   * Get all pins for a layer
   */
  getPins(layerId) {
    return this.meshCache.get(layerId)?.pins ?? [];
  }
  /**
   * Update a pin's position (for UI dragging)
   */
  updatePinPosition(layerId, pinId, x, y) {
    const mesh = this.meshCache.get(layerId);
    if (!mesh) return;
    const pin = mesh.pins.find((p) => p.id === pinId);
    if (pin) {
      pin.position.value = { x, y };
    }
  }
  /**
   * Clear all cached meshes
   */
  clearAllMeshes() {
    this.meshCache.clear();
  }
}
const meshWarpDeformation = new MeshWarpDeformationService();

class SplineLayer extends BaseLayer {
  /** The line mesh for the spline (using Line2 for proper width support) */
  lineMesh = null;
  /** The fill mesh (if closed path with fill) */
  fillMesh = null;
  /** Canvas resolution for LineMaterial (needed for proper width rendering) */
  resolution = new Vector2(1920, 1080);
  /** Spline data */
  splineData;
  /** Cached curve for path calculations */
  curve = null;
  /** Animated control points (if spline is animated) */
  animatedPoints = null;
  /** Last evaluated frame for cache invalidation */
  lastEvaluatedFrame = -1;
  /** Cached evaluated points for the current frame */
  cachedEvaluatedPoints = null;
  /** Hash of last evaluated points for change detection */
  lastPointsHash = "";
  /** Trim start property (static or animated) */
  trimStartProp;
  /** Trim end property (static or animated) */
  trimEndProp;
  /** Trim offset property (static or animated) */
  trimOffsetProp;
  /** Path effects to apply */
  pathEffects;
  /** LOD levels for this spline */
  lodLevels = [];
  /** Whether LOD is enabled for this spline */
  lodEnabled = false;
  /** Current LOD context (updated during playback) */
  lodContext = {
    zoom: 1,
    isPlaying: false,
    isScrubbing: false,
    targetFps: 60,
    actualFps: 60,
    viewport: { width: 1920, height: 1080 }
  };
  /** Whether warp (mesh warp) deformation is enabled for this spline */
  warpEnabled = false;
  /** Warp pins for this spline (stored on layer, mesh managed by service) */
  warpPins = [];
  // Backwards compatibility getters
  /** @deprecated Use warpEnabled instead */
  get puppetEnabled() {
    return this.warpEnabled;
  }
  set puppetEnabled(val) {
    this.warpEnabled = val;
  }
  /** @deprecated Use warpPins instead */
  get puppetPins() {
    return this.warpPins;
  }
  set puppetPins(val) {
    this.warpPins = val;
  }
  constructor(layerData) {
    super(layerData);
    this.splineData = this.extractSplineData(layerData);
    if (this.splineData.animated && this.splineData.animatedControlPoints) {
      this.animatedPoints = this.splineData.animatedControlPoints;
    }
    const data = layerData.data;
    this.trimStartProp = data?.trimStart;
    this.trimEndProp = data?.trimEnd;
    this.trimOffsetProp = data?.trimOffset;
    this.pathEffects = data?.pathEffects;
    this.initializeLOD(data);
    this.initializeWarp(data);
    this.buildSpline();
    this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(layerData) {
    const data = layerData.data;
    return {
      controlPoints: data?.controlPoints ?? [],
      closed: data?.closed ?? false,
      stroke: data?.stroke ?? "#00ff00",
      strokeWidth: data?.strokeWidth ?? 2,
      fill: data?.fill ?? "",
      pathData: data?.pathData ?? ""
    };
  }
  /**
   * Initialize LOD levels for complex paths
   */
  initializeLOD(data) {
    if (!data) return;
    const lodSettings = data.lod;
    const points = data.controlPoints;
    const shouldAutoEnable = points.length > 100;
    if (lodSettings?.enabled || shouldAutoEnable) {
      this.lodEnabled = true;
      if (lodSettings?.levels && lodSettings.levels.length > 0) {
        this.lodLevels = lodSettings.levels.map((level) => ({
          tolerance: level.tolerance,
          controlPoints: level.controlPoints,
          pointCount: level.controlPoints.length,
          quality: 0
          // Will be set by index
        }));
        this.lodLevels.forEach((level, i) => {
          level.quality = i;
        });
      } else {
        const tolerance = lodSettings?.simplificationTolerance ?? 2;
        this.lodLevels = vectorLOD.generateLODLevels(
          this.layerData.id,
          points,
          4,
          // 4 levels
          tolerance
        );
      }
    }
  }
  /**
   * Update LOD context (call this when playback state changes)
   */
  updateLODContext(context) {
    this.lodContext = { ...this.lodContext, ...context };
  }
  /**
   * Get control points at appropriate LOD level
   */
  getPointsAtLOD(points) {
    if (!this.lodEnabled || this.lodLevels.length === 0) {
      return points;
    }
    const level = vectorLOD.selectLODLevel(this.lodLevels, this.lodContext);
    if (level) {
      return level.controlPoints;
    }
    return points;
  }
  /**
   * Initialize mesh warp deformation from layer data
   */
  initializeWarp(data) {
    const pins = data?.warpPins ?? data?.puppetPins;
    if (!data || !pins || pins.length === 0) {
      return;
    }
    this.warpPins = pins;
    this.warpEnabled = true;
    meshWarpDeformation.buildMesh(
      this.layerData.id,
      data.controlPoints,
      pins
    );
  }
  /** @deprecated Use initializeWarp instead */
  initializePuppet(data) {
    return this.initializeWarp(data);
  }
  /**
   * Enable mesh warp deformation mode
   * Creates a deformation mesh from current control points
   */
  enableWarpMode() {
    if (this.warpEnabled) return;
    this.warpEnabled = true;
    meshWarpDeformation.buildMesh(
      this.layerData.id,
      this.splineData.controlPoints,
      this.warpPins
    );
    this.lastPointsHash = "";
  }
  /** @deprecated Use enableWarpMode instead */
  enablePuppetMode() {
    return this.enableWarpMode();
  }
  /**
   * Disable mesh warp deformation mode
   */
  disableWarpMode() {
    if (!this.warpEnabled) return;
    this.warpEnabled = false;
    this.warpPins = [];
    meshWarpDeformation.clearMesh(this.layerData.id);
    this.lastPointsHash = "";
  }
  /** @deprecated Use disableWarpMode instead */
  disablePuppetMode() {
    return this.disableWarpMode();
  }
  /**
   * Check if mesh warp deformation is enabled
   */
  isWarpEnabled() {
    return this.warpEnabled;
  }
  /** @deprecated Use isWarpEnabled instead */
  isPuppetEnabled() {
    return this.isWarpEnabled();
  }
  /**
   * Add a warp pin at the specified position
   * @param x - X position of the pin
   * @param y - Y position of the pin
   * @param type - Pin type (position, rotation, or starch)
   * @returns The created pin
   */
  addWarpPin(x, y, type = "position") {
    const { createDefaultWarpPin } = require("@/types/meshWarp");
    const id = `pin_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    const pin = createDefaultWarpPin(id, x, y, type);
    this.warpPins.push(pin);
    if (!this.warpEnabled) {
      this.enableWarpMode();
    }
    meshWarpDeformation.addPin(this.layerData.id, pin);
    this.lastPointsHash = "";
    return pin;
  }
  /** @deprecated Use addWarpPin instead */
  addPuppetPin(x, y, type = "position") {
    return this.addWarpPin(x, y, type);
  }
  /**
   * Remove a warp pin by ID
   * @param pinId - The ID of the pin to remove
   */
  removeWarpPin(pinId) {
    const index = this.warpPins.findIndex((p) => p.id === pinId);
    if (index === -1) return;
    this.warpPins.splice(index, 1);
    meshWarpDeformation.removePin(this.layerData.id, pinId);
    if (this.warpPins.length === 0) {
      this.disableWarpMode();
    }
    this.lastPointsHash = "";
  }
  /** @deprecated Use removeWarpPin instead */
  removePuppetPin(pinId) {
    return this.removeWarpPin(pinId);
  }
  /**
   * Get all warp pins
   */
  getWarpPins() {
    return this.warpPins;
  }
  /** @deprecated Use getWarpPins instead */
  getPuppetPins() {
    return this.getWarpPins();
  }
  /**
   * Update a warp pin's position
   * @param pinId - The ID of the pin to update
   * @param x - New X position
   * @param y - New Y position
   */
  updateWarpPinPosition(pinId, x, y) {
    const pin = this.warpPins.find((p) => p.id === pinId);
    if (!pin) return;
    pin.position.value = { x, y };
    meshWarpDeformation.updatePinPosition(this.layerData.id, pinId, x, y);
    this.lastPointsHash = "";
  }
  /** @deprecated Use updateWarpPinPosition instead */
  updatePuppetPinPosition(pinId, x, y) {
    return this.updateWarpPinPosition(pinId, x, y);
  }
  /**
   * Set warp pins (replacing all existing pins)
   * @param pins - Array of warp pins
   */
  setWarpPins(pins) {
    this.warpPins = pins;
    if (pins.length > 0) {
      if (!this.warpEnabled) {
        this.enableWarpMode();
      }
      meshWarpDeformation.updateMeshPins(this.layerData.id, pins);
    } else {
      this.disableWarpMode();
    }
    this.lastPointsHash = "";
  }
  /** @deprecated Use setWarpPins instead */
  setPuppetPins(pins) {
    return this.setWarpPins(pins);
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    this.clearMeshes();
    const points = this.splineData.controlPoints;
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth ?? 0;
      const z1 = p1.depth ?? 0;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth ?? 0;
      const zFirst = firstPoint.depth ?? 0;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          zLast
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const positions = [];
    for (const pt of curvePoints) {
      positions.push(pt.x, pt.y, pt.z);
    }
    const lineGeometry = new LineGeometry();
    lineGeometry.setPositions(positions);
    const color = new Color(this.splineData.stroke);
    const lineMaterial = new LineMaterial({
      color: color.getHex(),
      linewidth: this.splineData.strokeWidth,
      transparent: true,
      resolution: this.resolution,
      // Use world units so linewidth is in pixels
      worldUnits: false
    });
    this.lineMesh = new Line2(lineGeometry, lineMaterial);
    this.lineMesh.computeLineDistances();
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(curvePoints) {
    if (curvePoints.length < 3) return;
    const shape = new Shape();
    shape.moveTo(curvePoints[0].x, curvePoints[0].y);
    for (let i = 1; i < curvePoints.length; i++) {
      shape.lineTo(curvePoints[i].x, curvePoints[i].y);
    }
    shape.closePath();
    const fillGeometry = new ShapeGeometry(shape);
    const fillMaterial = new MeshBasicMaterial({
      color: this.splineData.fill,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.fillMesh = new Mesh(fillGeometry, fillMaterial);
    this.fillMesh.name = `spline_fill_${this.id}`;
    this.fillMesh.position.z = -0.1;
    this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    if (this.lineMesh) {
      this.group.remove(this.lineMesh);
      this.lineMesh.geometry.dispose();
      this.lineMesh.material.dispose();
      this.lineMesh = null;
    }
    if (this.fillMesh) {
      this.group.remove(this.fillMesh);
      this.fillMesh.geometry.dispose();
      this.fillMesh.material.dispose();
      this.fillMesh = null;
    }
    this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(t) {
    if (!this.curve) return null;
    return this.curve.getPointAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(t) {
    if (!this.curve) return null;
    return this.curve.getTangentAt(Math.max(0, Math.min(1, t)));
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    if (!this.curve) return 0;
    return this.curve.getLength();
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(t) {
    const point = this.getPointAt(t);
    const tangent = this.getTangentAt(t);
    if (!point || !tangent) return null;
    const rotation = Math.atan2(tangent.y, tangent.x) * (180 / Math.PI);
    return { position: point, rotation };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(color) {
    this.splineData.stroke = color;
    if (this.lineMesh) {
      this.lineMesh.material.color.set(color);
    }
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(width) {
    this.splineData.strokeWidth = width;
    if (this.lineMesh) {
      this.lineMesh.material.linewidth = width;
      this.lineMesh.material.needsUpdate = true;
    }
  }
  /**
   * Set fill color
   */
  setFill(color) {
    this.splineData.fill = color;
    if (this.fillMesh) {
      this.fillMesh.material.color.set(color);
    } else if (color && this.splineData.closed && this.curve) {
      const curvePoints = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(curvePoints);
    }
  }
  /**
   * Set resolution for line material (call when canvas resizes)
   */
  setResolution(width, height) {
    this.resolution.set(width, height);
    if (this.lineMesh) {
      this.lineMesh.material.resolution.set(width, height);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(points) {
    this.splineData.controlPoints = points;
    this.animatedPoints = null;
    this.splineData.animated = false;
    this.buildSpline();
  }
  /**
   * Set animated control points
   * Enables animation mode for this spline
   */
  setAnimatedControlPoints(points) {
    this.animatedPoints = points;
    this.splineData.animatedControlPoints = points;
    this.splineData.animated = true;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
  }
  /**
   * Enable animation on this spline by converting static control points
   * to AnimatableControlPoint format
   */
  enableAnimation() {
    if (this.animatedPoints) {
      return this.animatedPoints;
    }
    const { controlPointToAnimatable } = require("@/types/project");
    const animatedPoints = this.splineData.controlPoints.map(
      (cp) => controlPointToAnimatable(cp)
    );
    this.setAnimatedControlPoints(animatedPoints);
    return animatedPoints;
  }
  /**
   * Disable animation and convert back to static control points
   */
  disableAnimation() {
    if (!this.animatedPoints) return;
    const { animatableToControlPoint } = require("@/types/project");
    this.splineData.controlPoints = this.animatedPoints.map(
      (acp) => animatableToControlPoint(acp)
    );
    this.animatedPoints = null;
    this.splineData.animatedControlPoints = void 0;
    this.splineData.animated = false;
    this.lastEvaluatedFrame = -1;
    this.cachedEvaluatedPoints = null;
    this.lastPointsHash = "";
    this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(closed) {
    if (this.splineData.closed === closed) return;
    this.splineData.closed = closed;
    this.buildSpline();
  }
  /**
   * Check if the spline path is closed
   */
  isClosed() {
    return this.splineData.closed;
  }
  // ============================================================================
  // TRIM PATH SETTERS/GETTERS
  // ============================================================================
  /**
   * Set trim start (static value)
   * @param value - Trim start percentage (0-100)
   */
  setTrimStart(value) {
    this.trimStartProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set trim end (static value)
   * @param value - Trim end percentage (0-100)
   */
  setTrimEnd(value) {
    this.trimEndProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set trim offset (static value)
   * @param value - Trim offset in degrees
   */
  setTrimOffset(value) {
    this.trimOffsetProp = value;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim start property
   * @param prop - AnimatableProperty for trim start
   */
  setAnimatedTrimStart(prop) {
    this.trimStartProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim end property
   * @param prop - AnimatableProperty for trim end
   */
  setAnimatedTrimEnd(prop) {
    this.trimEndProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Set animated trim offset property
   * @param prop - AnimatableProperty for trim offset
   */
  setAnimatedTrimOffset(prop) {
    this.trimOffsetProp = prop;
    this.lastPointsHash = "";
  }
  /**
   * Get current trim values at a specific frame
   * Useful for UI display and debugging
   */
  getTrimValues(frame) {
    return {
      start: this.evaluateStaticOrAnimated(this.trimStartProp, frame, 0),
      end: this.evaluateStaticOrAnimated(this.trimEndProp, frame, 100),
      offset: this.evaluateStaticOrAnimated(this.trimOffsetProp, frame, 0)
    };
  }
  /**
   * Check if trim path is enabled (has non-default values or animated)
   */
  hasTrimPath() {
    return this.trimStartProp !== void 0 || this.trimEndProp !== void 0 || this.trimOffsetProp !== void 0;
  }
  /**
   * Set path effects
   * @param effects - Array of path effects to apply
   */
  setPathEffects(effects) {
    this.pathEffects = effects;
    this.lastPointsHash = "";
  }
  /**
   * Get current path effects
   */
  getPathEffects() {
    return this.pathEffects;
  }
  // ============================================================================
  // ANIMATED SPLINE EVALUATION
  // ============================================================================
  /**
   * Check if this spline has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   * Uses interpolateProperty from interpolation.ts
   * Driven values override interpolated values
   */
  evaluateControlPointAtFrame(acp, frame, index) {
    const interpolatedX = interpolateProperty(acp.x, frame);
    const interpolatedY = interpolateProperty(acp.y, frame);
    const interpolatedDepth = acp.depth ? interpolateProperty(acp.depth, frame) : 0;
    return {
      id: acp.id,
      x: this.getDrivenControlPointValue(index, "x", interpolatedX),
      y: this.getDrivenControlPointValue(index, "y", interpolatedY),
      depth: this.getDrivenControlPointValue(index, "depth", interpolatedDepth),
      handleIn: acp.handleIn ? {
        x: interpolateProperty(acp.handleIn.x, frame),
        y: interpolateProperty(acp.handleIn.y, frame)
      } : null,
      handleOut: acp.handleOut ? {
        x: interpolateProperty(acp.handleOut.x, frame),
        y: interpolateProperty(acp.handleOut.y, frame)
      } : null,
      type: acp.type,
      group: acp.group
    };
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer and other consumers
   *
   * For static splines, returns the static control points converted to EvaluatedControlPoint
   * For animated splines, interpolates all control points at the given frame
   * Driven values (from PropertyDriverSystem) override interpolated values
   *
   * DETERMINISM: Same frame + same drivers = same output (pure function)
   */
  getEvaluatedControlPoints(frame) {
    const hasDrivenValues = this.hasSplineDrivers();
    if (frame === this.lastEvaluatedFrame && this.cachedEvaluatedPoints && !hasDrivenValues) {
      return this.cachedEvaluatedPoints;
    }
    let points;
    if (this.animatedPoints && this.animatedPoints.length > 0) {
      points = this.animatedPoints.map(
        (acp, index) => this.evaluateControlPointAtFrame(acp, frame, index)
      );
    } else {
      points = this.splineData.controlPoints.map((cp, index) => ({
        id: cp.id,
        x: this.getDrivenControlPointValue(index, "x", cp.x),
        y: this.getDrivenControlPointValue(index, "y", cp.y),
        depth: this.getDrivenControlPointValue(index, "depth", cp.depth ?? 0),
        handleIn: cp.handleIn,
        handleOut: cp.handleOut,
        type: cp.type,
        group: cp.group
      }));
    }
    this.lastEvaluatedFrame = frame;
    if (!hasDrivenValues) {
      this.cachedEvaluatedPoints = points;
    }
    return points;
  }
  /**
   * Check if any spline control point drivers are active
   */
  hasSplineDrivers() {
    for (const key of this.drivenValues.keys()) {
      if (isSplineControlPointPath(key)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get a driven control point value, falling back to base value
   */
  getDrivenControlPointValue(index, property, baseValue) {
    const path = createSplineControlPointPath(index, property);
    return this.getDrivenOrBase(path, baseValue);
  }
  /**
   * Compute a hash of control point positions for change detection
   * Used to avoid rebuilding geometry when positions haven't changed
   */
  computePointsHash(points) {
    return points.map(
      (p) => `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.depth.toFixed(2)}`
    ).join("|");
  }
  // ============================================================================
  // TRIM PATH & PATH EFFECTS HELPERS
  // ============================================================================
  /**
   * Evaluate a property that can be either a static value or AnimatableProperty
   * @param prop - Static value or AnimatableProperty
   * @param frame - Current frame number
   * @param defaultValue - Value to use if prop is undefined
   */
  evaluateStaticOrAnimated(prop, frame, defaultValue) {
    if (prop === void 0) {
      return defaultValue;
    }
    if (typeof prop === "number") {
      return prop;
    }
    return interpolateProperty(prop, frame);
  }
  /**
   * Check if trim is active (differs from default values)
   */
  isTrimActive(trimStart, trimEnd, trimOffset) {
    return trimStart !== 0 || trimEnd !== 100 || trimOffset !== 0;
  }
  /**
   * Check if any path effects are enabled
   */
  hasActivePathEffects() {
    return this.pathEffects?.some((e) => e.enabled) ?? false;
  }
  /**
   * Convert EvaluatedControlPoint[] to BezierPath format for shapeOperations
   * Note: EvaluatedControlPoint handles are ABSOLUTE, BezierVertex handles are RELATIVE
   */
  evaluatedPointsToBezierPath(points) {
    const vertices = points.map((p) => {
      const inHandle = p.handleIn ? { x: p.handleIn.x - p.x, y: p.handleIn.y - p.y } : { x: 0, y: 0 };
      const outHandle = p.handleOut ? { x: p.handleOut.x - p.x, y: p.handleOut.y - p.y } : { x: 0, y: 0 };
      return {
        point: { x: p.x, y: p.y },
        inHandle,
        outHandle
      };
    });
    return {
      vertices,
      closed: this.splineData.closed
    };
  }
  /**
   * Convert BezierPath back to EvaluatedControlPoint[] format
   * Note: Depth information is lost during trim - we interpolate from original points
   */
  bezierPathToEvaluatedPoints(bezierPath, originalPoints) {
    return bezierPath.vertices.map((v, i) => {
      const originalDepth = i < originalPoints.length ? originalPoints[i].depth : 0;
      const handleIn = v.inHandle.x !== 0 || v.inHandle.y !== 0 ? { x: v.point.x + v.inHandle.x, y: v.point.y + v.inHandle.y } : null;
      const handleOut = v.outHandle.x !== 0 || v.outHandle.y !== 0 ? { x: v.point.x + v.outHandle.x, y: v.point.y + v.outHandle.y } : null;
      return {
        id: `trimmed_${i}`,
        x: v.point.x,
        y: v.point.y,
        depth: originalDepth,
        handleIn,
        handleOut,
        type: "smooth"
      };
    });
  }
  /**
   * Apply path effects in order (before trim)
   * @param bezierPath - The input path
   * @param frame - Current frame for animated effect properties
   */
  applyPathEffects(bezierPath, frame) {
    if (!this.pathEffects || this.pathEffects.length === 0) {
      return bezierPath;
    }
    const sortedEffects = [...this.pathEffects].filter((e) => e.enabled).sort((a, b) => a.order - b.order);
    let result = bezierPath;
    for (const effect of sortedEffects) {
      switch (effect.type) {
        case "offsetPath": {
          const offsetEffect = effect;
          const amount = interpolateProperty(offsetEffect.amount, frame);
          const miterLimit = interpolateProperty(offsetEffect.miterLimit, frame);
          result = offsetPath(result, amount, offsetEffect.lineJoin, miterLimit);
          break;
        }
        case "wiggle": {
          const wiggleEffect = effect;
          const size = interpolateProperty(wiggleEffect.size, frame);
          const detail = interpolateProperty(wiggleEffect.detail, frame);
          const temporalPhase = interpolateProperty(wiggleEffect.temporalPhase, frame);
          const spatialPhase = interpolateProperty(wiggleEffect.spatialPhase, frame);
          const correlation = interpolateProperty(wiggleEffect.correlation, frame);
          result = wigglePath(
            result,
            size,
            detail,
            "smooth",
            // WigglePathEffect pointType mapping
            correlation,
            temporalPhase,
            spatialPhase,
            wiggleEffect.seed
          );
          break;
        }
        case "zigzag": {
          const zigzagEffect = effect;
          const size = interpolateProperty(zigzagEffect.size, frame);
          const ridges = interpolateProperty(zigzagEffect.ridgesPerSegment, frame);
          result = zigZagPath(result, size, ridges, zigzagEffect.pointType);
          break;
        }
        case "roughen": {
          const roughenEffect = effect;
          const size = interpolateProperty(roughenEffect.size, frame);
          const detail = interpolateProperty(roughenEffect.detail, frame);
          result = roughenPath(result, size, detail, roughenEffect.seed);
          break;
        }
        case "wave": {
          const waveEffect = effect;
          const amplitude = interpolateProperty(waveEffect.amplitude, frame);
          const frequency = interpolateProperty(waveEffect.frequency, frame);
          const phase = interpolateProperty(waveEffect.phase, frame);
          result = wavePath(result, amplitude, frequency, phase, waveEffect.waveType);
          break;
        }
      }
    }
    return result;
  }
  /**
   * Build spline geometry from evaluated control points
   * Called when control points change during animation
   */
  buildSplineFromEvaluatedPoints(points) {
    this.clearMeshes();
    if (points.length < 2) return;
    this.curve = new CurvePath();
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const z0 = p0.depth;
      const z1 = p1.depth;
      const bezier = new CubicBezierCurve3(
        new Vector3(p0.x, -p0.y, z0),
        new Vector3(
          p0.handleOut?.x ?? p0.x,
          -(p0.handleOut?.y ?? p0.y),
          z0
        ),
        new Vector3(
          p1.handleIn?.x ?? p1.x,
          -(p1.handleIn?.y ?? p1.y),
          z1
        ),
        new Vector3(p1.x, -p1.y, z1)
      );
      this.curve.add(bezier);
    }
    if (this.splineData.closed && points.length > 2) {
      const lastPoint = points[points.length - 1];
      const firstPoint = points[0];
      const zLast = lastPoint.depth;
      const zFirst = firstPoint.depth;
      const closingBezier = new CubicBezierCurve3(
        new Vector3(lastPoint.x, -lastPoint.y, zLast),
        new Vector3(
          lastPoint.handleOut?.x ?? lastPoint.x,
          -(lastPoint.handleOut?.y ?? lastPoint.y),
          zLast
        ),
        new Vector3(
          firstPoint.handleIn?.x ?? firstPoint.x,
          -(firstPoint.handleIn?.y ?? firstPoint.y),
          zFirst
        ),
        new Vector3(firstPoint.x, -firstPoint.y, zFirst)
      );
      this.curve.add(closingBezier);
    }
    const curvePoints = this.curve.getPoints(points.length * 20);
    const positions = [];
    for (const pt of curvePoints) {
      positions.push(pt.x, pt.y, pt.z);
    }
    const lineGeometry = new LineGeometry();
    lineGeometry.setPositions(positions);
    const color = new Color(this.splineData.stroke);
    const lineMaterial = new LineMaterial({
      color: color.getHex(),
      linewidth: this.splineData.strokeWidth,
      transparent: true,
      resolution: this.resolution,
      worldUnits: false
    });
    this.lineMesh = new Line2(lineGeometry, lineMaterial);
    this.lineMesh.computeLineDistances();
    this.lineMesh.name = `spline_line_${this.id}`;
    this.group.add(this.lineMesh);
    if (this.splineData.fill && this.splineData.closed) {
      this.createFill(curvePoints);
    }
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const trimStart = this.evaluateStaticOrAnimated(this.trimStartProp, frame, 0);
    const trimEnd = this.evaluateStaticOrAnimated(this.trimEndProp, frame, 100);
    const trimOffset = this.evaluateStaticOrAnimated(this.trimOffsetProp, frame, 0);
    const needsTrim = this.isTrimActive(trimStart, trimEnd, trimOffset);
    const hasEffects = this.hasActivePathEffects();
    const useLOD = this.shouldUseLOD();
    const hasWarp = this.warpEnabled && this.warpPins.length > 0;
    if (!this.isAnimated() && !needsTrim && !hasEffects && !useLOD && !hasWarp) {
      return;
    }
    let evaluatedPoints = this.getEvaluatedControlPoints(frame);
    const lodHash = useLOD ? `|lod:${this.lodContext.isPlaying},${this.lodContext.zoom.toFixed(2)}` : "";
    const trimHash = needsTrim || hasEffects ? `|trim:${trimStart.toFixed(2)},${trimEnd.toFixed(2)},${trimOffset.toFixed(2)}|fx:${frame}` : "";
    const warpHash = hasWarp ? `|warp:${frame}` : "";
    const pointsHash = this.computePointsHash(evaluatedPoints) + trimHash + lodHash + warpHash;
    if (pointsHash !== this.lastPointsHash) {
      let finalPoints = evaluatedPoints;
      if (hasWarp) {
        const controlPoints = evaluatedPoints.map((ep) => ({
          id: ep.id,
          x: ep.x,
          y: ep.y,
          depth: ep.depth,
          handleIn: ep.handleIn,
          handleOut: ep.handleOut,
          type: ep.type,
          group: ep.group
        }));
        const deformedPoints = meshWarpDeformation.getDeformedControlPoints(
          this.layerData.id,
          frame,
          controlPoints
        );
        finalPoints = deformedPoints.map((cp) => ({
          id: cp.id,
          x: cp.x,
          y: cp.y,
          depth: cp.depth ?? 0,
          handleIn: cp.handleIn,
          handleOut: cp.handleOut,
          type: cp.type,
          group: cp.group
        }));
      }
      if (needsTrim || hasEffects) {
        let bezierPath = this.evaluatedPointsToBezierPath(finalPoints);
        if (hasEffects) {
          bezierPath = this.applyPathEffects(bezierPath, frame);
        }
        if (needsTrim) {
          bezierPath = trimPath(bezierPath, trimStart, trimEnd, trimOffset);
        }
        finalPoints = this.bezierPathToEvaluatedPoints(bezierPath, evaluatedPoints);
      }
      if (useLOD && finalPoints.length > 50) {
        const lodLevel = vectorLOD.selectLODLevel(this.lodLevels, this.lodContext);
        if (lodLevel && lodLevel.pointCount < finalPoints.length) {
          finalPoints = lodLevel.controlPoints.map((cp, i) => ({
            id: cp.id,
            x: cp.x,
            y: cp.y,
            handleIn: cp.handleIn ?? { x: cp.x, y: cp.y },
            handleOut: cp.handleOut ?? { x: cp.x, y: cp.y },
            depth: cp.depth ?? 0,
            type: cp.type,
            group: cp.group
          }));
        }
      }
      this.buildSplineFromEvaluatedPoints(finalPoints);
      this.lastPointsHash = pointsHash;
    }
  }
  /**
   * Check if LOD should be used based on current context
   */
  shouldUseLOD() {
    if (!this.lodEnabled || this.lodLevels.length === 0) {
      return false;
    }
    if (this.lodContext.isPlaying || this.lodContext.isScrubbing) {
      return true;
    }
    if (this.lodContext.zoom < 0.5) {
      return true;
    }
    if (this.lodContext.actualFps < this.lodContext.targetFps * 0.8) {
      return true;
    }
    return false;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["controlPoints"] !== void 0) {
      const points = props["controlPoints"];
      const pointsHash = this.computePointsHash(points);
      if (pointsHash !== this.lastPointsHash) {
        this.buildSplineFromEvaluatedPoints(points);
        this.lastPointsHash = pointsHash;
      }
    }
    if (props["strokeWidth"] !== void 0) {
      this.setStrokeWidth(props["strokeWidth"]);
    }
    if (props["strokeColor"] !== void 0) {
      this.setStroke(props["strokeColor"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      let needsRebuild = false;
      if (data.animatedControlPoints !== void 0) {
        this.setAnimatedControlPoints(data.animatedControlPoints);
        needsRebuild = false;
      } else if (data.controlPoints !== void 0) {
        this.splineData.controlPoints = data.controlPoints;
        if (!data.animated) {
          this.animatedPoints = null;
          this.splineData.animated = false;
        }
        needsRebuild = true;
      }
      if (data.animated !== void 0) {
        if (data.animated && !this.animatedPoints) {
          this.enableAnimation();
          needsRebuild = false;
        } else if (!data.animated && this.animatedPoints) {
          this.disableAnimation();
          needsRebuild = false;
        }
      }
      if (data.closed !== void 0 && data.closed !== this.splineData.closed) {
        this.splineData.closed = data.closed;
        needsRebuild = true;
      }
      if (data.stroke !== void 0) {
        this.setStroke(data.stroke);
      }
      if (data.strokeWidth !== void 0) {
        this.setStrokeWidth(data.strokeWidth);
      }
      if (data.fill !== void 0) {
        this.setFill(data.fill);
      }
      if (data.trimStart !== void 0) {
        this.trimStartProp = data.trimStart;
        this.lastPointsHash = "";
      }
      if (data.trimEnd !== void 0) {
        this.trimEndProp = data.trimEnd;
        this.lastPointsHash = "";
      }
      if (data.trimOffset !== void 0) {
        this.trimOffsetProp = data.trimOffset;
        this.lastPointsHash = "";
      }
      if (data.pathEffects !== void 0) {
        this.pathEffects = data.pathEffects;
        this.lastPointsHash = "";
      }
      const warpPinsData = data.warpPins ?? data.puppetPins;
      if (warpPinsData !== void 0) {
        this.setWarpPins(warpPinsData);
      }
      if (needsRebuild) {
        this.buildSpline();
      }
    }
  }
  onDispose() {
    this.clearMeshes();
    if (this.warpEnabled) {
      meshWarpDeformation.clearMesh(this.layerData.id);
    }
  }
}

const GLSL_NOISE = `
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289(i);
  vec4 p = permute(permute(permute(
    i.z + vec4(0.0, i1.z, i2.z, 1.0))
    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0) * 2.0 + 1.0;
  vec4 s1 = floor(b1) * 2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}
`;
const GLSL_FORCE_CALC = `
vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
  vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
  vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
  vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
  vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);
  vec3 fieldPos = row0.xyz;
  int fieldType = int(row0.w);
  float strength = row1.x;
  float falloffStart = row1.y;
  float falloffEnd = row1.z;
  int falloffType = int(row1.w);
  vec3 toField = fieldPos - pos;
  float dist = length(toField);
  float falloff = 1.0;
  if (dist > falloffStart && falloffEnd > falloffStart) {
    float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
    if (falloffType == 1) falloff = 1.0 - t;
    else if (falloffType == 2) falloff = 1.0 - t * t;
    else if (falloffType == 3) falloff = exp(-t * 3.0);
    else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t);
  }
  vec3 force = vec3(0.0);
  float effectiveStrength = strength * falloff;
  if (fieldType == 0) { force = row2.xyz * effectiveStrength; }
  else if (fieldType == 1) {
    if (dist > 0.001) { force = normalize(toField) * effectiveStrength / max(mass, 0.1); }
  }
  else if (fieldType == 2) {
    if (dist > 0.001) {
      vec3 axis = normalize(row2.xyz);
      vec3 tangent = normalize(cross(axis, toField));
      force = tangent * effectiveStrength + normalize(toField) * row2.w;
    }
  }
  else if (fieldType == 3) {
    float noiseScale = row3.x;
    float noiseSpeed = row3.y;
    vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
    force.x = snoise(noisePos) * effectiveStrength;
    force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
    force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
  }
  else if (fieldType == 4) {
    float linearDrag = row3.x;
    float quadDrag = row3.y;
    float speed = length(vel);
    if (speed > 0.001) {
      float dragMag = linearDrag * speed + quadDrag * speed * speed;
      force = -normalize(vel) * dragMag * effectiveStrength;
    }
  }
  else if (fieldType == 5) {
    vec3 windDir = normalize(row2.xyz);
    float gustStrength = row3.x;
    float gustFreq = row3.y;
    float gust = sin(u_time * gustFreq) * gustStrength;
    force = windDir * (effectiveStrength + gust);
  }
  return force;
}
`;
const TRANSFORM_FEEDBACK_VERTEX_SHADER = `#version 300 es
precision highp float;
layout(location = 0) in vec3 a_position;
layout(location = 1) in vec3 a_velocity;
layout(location = 2) in vec2 a_life;
layout(location = 3) in vec2 a_physical;
layout(location = 4) in vec2 a_rotation;
layout(location = 5) in vec4 a_color;
out vec3 tf_position;
out vec3 tf_velocity;
out vec2 tf_life;
out vec2 tf_physical;
out vec2 tf_rotation;
out vec4 tf_color;
uniform float u_deltaTime;
uniform float u_time;
uniform int u_forceFieldCount;
uniform sampler2D u_forceFields;
${GLSL_NOISE}
${GLSL_FORCE_CALC}
void main() {
  if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
    tf_position = a_position;
    tf_velocity = a_velocity;
    tf_life = a_life;
    tf_physical = a_physical;
    tf_rotation = a_rotation;
    tf_color = a_color;
    return;
  }
  vec3 pos = a_position;
  vec3 vel = a_velocity;
  float age = a_life.x;
  float lifetime = a_life.y;
  float mass = a_physical.x;
  float size = a_physical.y;
  float rotation = a_rotation.x;
  float angularVel = a_rotation.y;
  vec3 totalForce = vec3(0.0);
  for (int i = 0; i < u_forceFieldCount; i++) {
    totalForce += calculateForce(i, pos, vel, mass);
  }
  vec3 acceleration = totalForce / max(mass, 0.1);
  vel += acceleration * u_deltaTime;
  pos += vel * u_deltaTime;
  rotation += angularVel * u_deltaTime;
  age += u_deltaTime;
  float lifeRatio = age / lifetime;
  float sizeMod = 1.0 - lifeRatio * 0.5;
  size = a_physical.y * sizeMod;
  float opacityMod = 1.0 - lifeRatio;
  tf_position = pos;
  tf_velocity = vel;
  tf_life = vec2(age, lifetime);
  tf_physical = vec2(mass, size);
  tf_rotation = vec2(rotation, angularVel);
  tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
}
`;
const TRANSFORM_FEEDBACK_FRAGMENT_SHADER = `#version 300 es
precision highp float;
out vec4 fragColor;
void main() { fragColor = vec4(0.0); }
`;
const PARTICLE_VERTEX_SHADER = `
precision highp float;
attribute vec2 position;
attribute vec2 uv;
attribute vec3 i_position;
attribute vec3 i_velocity;
attribute vec2 i_life;
attribute vec2 i_physical;
attribute vec2 i_rotation;
attribute vec4 i_color;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 cameraPosition;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;
void main() {
  if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
    gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
    return;
  }
  float size = i_physical.y;
  float rotation = i_rotation.x;
  float lifeRatio = i_life.x / i_life.y;
  vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
  vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);
  float cosR = cos(rotation);
  float sinR = sin(rotation);
  vec2 rotatedPos = vec2(
    position.x * cosR - position.y * sinR,
    position.x * sinR + position.y * cosR
  );
  vec3 vertexPos = i_position + cameraRight * rotatedPos.x * size + cameraUp * rotatedPos.y * size;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);
  vUv = uv;
  vColor = i_color;
  vLifeRatio = lifeRatio;
}
`;
const PARTICLE_FRAGMENT_SHADER = `
precision highp float;
varying vec2 vUv;
varying vec4 vColor;
varying float vLifeRatio;
uniform sampler2D diffuseMap;
uniform int hasDiffuseMap;
uniform int proceduralShape;
float proceduralAlpha(vec2 uv, int shape) {
  vec2 centered = uv * 2.0 - 1.0;
  float dist = length(centered);
  if (shape == 1) { return 1.0 - smoothstep(0.8, 1.0, dist); }
  else if (shape == 2) { return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist)); }
  return 1.0;
}
void main() {
  vec4 texColor = vec4(1.0);
  if (hasDiffuseMap == 1) { texColor = texture2D(diffuseMap, vUv); }
  else if (proceduralShape > 0) {
    float alpha = proceduralAlpha(vUv, proceduralShape);
    texColor = vec4(1.0, 1.0, 1.0, alpha);
  }
  vec4 finalColor = texColor * vColor;
  if (finalColor.a < 0.01) discard;
  gl_FragColor = finalColor;
}
`;

const PARTICLE_STRIDE = 16;
const MAX_FORCE_FIELDS = 16;
const SPATIAL_CELL_SIZE = 50;
const TF_VARYINGS = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function createDefaultEmitter(id) {
  return {
    id: id || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: true,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: false,
    beatEmissionMultiplier: 5
  };
}
function createDefaultForceField(type, id) {
  const base = {
    id: id || `force_${Date.now()}`,
    name: type.charAt(0).toUpperCase() + type.slice(1),
    type,
    enabled: true,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (type) {
    case "gravity":
      base.direction = { x: 0, y: 1, z: 0 };
      base.strength = 98;
      break;
    case "vortex":
      base.vortexAxis = { x: 0, y: 0, z: 1 };
      base.inwardForce = 20;
      break;
    case "turbulence":
      base.noiseScale = 5e-3;
      base.noiseSpeed = 0.5;
      base.noiseOctaves = 3;
      base.noiseLacunarity = 2;
      base.noiseGain = 0.5;
      break;
    case "drag":
      base.linearDrag = 0.1;
      base.quadraticDrag = 0.01;
      break;
    case "wind":
      base.windDirection = { x: 1, y: 0, z: 0 };
      base.gustStrength = 50;
      base.gustFrequency = 0.1;
      break;
    case "lorenz":
      base.lorenzSigma = 10;
      base.lorenzRho = 28;
      base.lorenzBeta = 2.667;
      break;
  }
  return base;
}
function createDefaultConfig() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: true,
      depthWrite: false,
      depthTest: true,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: false,
        receiveShadows: false,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: false,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: false,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: false,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: false,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: false,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: SPATIAL_CELL_SIZE,
    updateFrequency: 1,
    cullOffscreen: true
  };
}
class GPUParticleSystem {
  config;
  gl = null;
  renderer = null;
  // Double-buffered particle data
  particleBufferA;
  particleBufferB;
  currentBuffer = "A";
  // WebGL resources
  transformFeedbackProgram = null;
  renderProgram = null;
  vaoA = null;
  vaoB = null;
  particleVboA = null;
  particleVboB = null;
  transformFeedbackA = null;
  transformFeedbackB = null;
  // Three.js integration
  particleMesh = null;
  instancedGeometry = null;
  material = null;
  // Textures for modulation curves
  sizeOverLifetimeTexture = null;
  opacityOverLifetimeTexture = null;
  colorOverLifetimeTexture = null;
  // Emitter state
  emitters = /* @__PURE__ */ new Map();
  forceFields = /* @__PURE__ */ new Map();
  subEmitters = /* @__PURE__ */ new Map();
  // Runtime state
  state = {
    particleCount: 0,
    activeEmitters: 0,
    simulationTime: 0,
    frameCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0,
    gpuMemoryBytes: 0,
    currentAudioFeatures: /* @__PURE__ */ new Map()
  };
  // Audio reactivity
  audioFeatures = /* @__PURE__ */ new Map();
  // Spatial hash for neighbor queries (flocking)
  spatialHash = /* @__PURE__ */ new Map();
  // Event system
  eventHandlers = /* @__PURE__ */ new Map();
  // Pool of free particle indices
  freeIndices = [];
  nextParticleIndex = 0;
  // Random number generator with seed
  rng;
  initialRngSeed;
  currentRngState;
  // Tracks RNG state for save/restore
  // ============================================================================
  // FRAME CACHING SYSTEM
  // Caches particle state every N frames for fast scrubbing
  // ============================================================================
  frameCache = /* @__PURE__ */ new Map();
  cacheInterval = 5;
  // Cache every 5 frames
  maxCacheSize = 200;
  // Max cached frames (1000 frames / 5 = 200)
  cacheVersion = 0;
  // Incremented on parameter changes to invalidate cache
  currentSimulatedFrame = -1;
  // Track which frame we're at
  constructor(config = {}) {
    this.config = { ...createDefaultConfig(), ...config };
    const bufferSize = this.config.maxParticles * PARTICLE_STRIDE;
    this.particleBufferA = new Float32Array(bufferSize);
    this.particleBufferB = new Float32Array(bufferSize);
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.initialRngSeed = this.config.randomSeed ?? Date.now();
    this.currentRngState = this.initialRngSeed;
    this.rng = this.createSeededRandom(this.initialRngSeed);
    this.config.emitters.forEach((e) => this.addEmitter(e));
    this.config.forceFields.forEach((f) => this.addForceField(f));
    this.config.subEmitters.forEach((s) => this.addSubEmitter(s));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  // GPU physics mode flag
  useGPUPhysics = false;
  gpuPhysicsInitialized = false;
  // Force field uniform buffer for GPU physics
  forceFieldBuffer = null;
  forceFieldTexture = null;
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(renderer) {
    this.renderer = renderer;
    this.gl = renderer.getContext();
    if (!this.gl) {
      throw new Error("WebGL2 context required for GPU particle system");
    }
    this.createModulationTextures();
    this.createParticleMesh();
    this.initializeGPUPhysics();
    this.state.gpuMemoryBytes = this.config.maxParticles * PARTICLE_STRIDE * 4 * 2;
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    const tfExtension = gl.getExtension("EXT_color_buffer_float");
    if (!tfExtension) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback");
      this.useGPUPhysics = false;
      return;
    }
    try {
      this.transformFeedbackProgram = this.createTransformFeedbackProgram(gl);
      if (!this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics");
        this.useGPUPhysics = false;
        return;
      }
      this.particleVboA = gl.createBuffer();
      this.particleVboB = gl.createBuffer();
      if (!this.particleVboA || !this.particleVboB) {
        throw new Error("Failed to create particle VBOs");
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboA);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferA, gl.DYNAMIC_COPY);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.particleVboB);
      gl.bufferData(gl.ARRAY_BUFFER, this.particleBufferB, gl.DYNAMIC_COPY);
      this.vaoA = gl.createVertexArray();
      this.vaoB = gl.createVertexArray();
      if (!this.vaoA || !this.vaoB) {
        throw new Error("Failed to create VAOs");
      }
      this.setupParticleVAO(gl, this.vaoA, this.particleVboA);
      this.setupParticleVAO(gl, this.vaoB, this.particleVboB);
      this.transformFeedbackA = gl.createTransformFeedback();
      this.transformFeedbackB = gl.createTransformFeedback();
      if (!this.transformFeedbackA || !this.transformFeedbackB) {
        throw new Error("Failed to create transform feedback objects");
      }
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackA);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.transformFeedbackB);
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
      this.forceFieldBuffer = new Float32Array(MAX_FORCE_FIELDS * 16);
      this.forceFieldTexture = new DataTexture(
        this.forceFieldBuffer,
        MAX_FORCE_FIELDS,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        RGBAFormat,
        FloatType
      );
      this.useGPUPhysics = true;
      this.gpuPhysicsInitialized = true;
      console.log("GPU physics initialized with Transform Feedback");
    } catch (error) {
      console.warn("GPU physics initialization failed:", error);
      this.useGPUPhysics = false;
      this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(gl, vao, vbo) {
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const stride = PARTICLE_STRIDE * 4;
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, stride, 12);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 2, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 2, gl.FLOAT, false, stride, 32);
    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 2, gl.FLOAT, false, stride, 40);
    gl.enableVertexAttribArray(5);
    gl.vertexAttribPointer(5, 4, gl.FLOAT, false, stride, 48);
    gl.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(gl) {
    const vsSource = TRANSFORM_FEEDBACK_VERTEX_SHADER;
    const fsSource = TRANSFORM_FEEDBACK_FRAGMENT_SHADER;
    const vs = gl.createShader(gl.VERTEX_SHADER);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    if (!vs || !fs) return null;
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback vertex shader error:", gl.getShaderInfoLog(vs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      console.error("Transform feedback fragment shader error:", gl.getShaderInfoLog(fs));
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    const program = gl.createProgram();
    if (!program) {
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.transformFeedbackVaryings(program, TF_VARYINGS, gl.INTERLEAVED_ATTRIBS);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Transform feedback program link error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      gl.deleteShader(vs);
      gl.deleteShader(fs);
      return null;
    }
    gl.deleteShader(vs);
    gl.deleteShader(fs);
    return program;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    if (!this.gl) return;
    const gl = this.gl;
    if (this.transformFeedbackProgram) {
      gl.deleteProgram(this.transformFeedbackProgram);
      this.transformFeedbackProgram = null;
    }
    if (this.particleVboA) {
      gl.deleteBuffer(this.particleVboA);
      this.particleVboA = null;
    }
    if (this.particleVboB) {
      gl.deleteBuffer(this.particleVboB);
      this.particleVboB = null;
    }
    if (this.vaoA) {
      gl.deleteVertexArray(this.vaoA);
      this.vaoA = null;
    }
    if (this.vaoB) {
      gl.deleteVertexArray(this.vaoB);
      this.vaoB = null;
    }
    if (this.transformFeedbackA) {
      gl.deleteTransformFeedback(this.transformFeedbackA);
      this.transformFeedbackA = null;
    }
    if (this.transformFeedbackB) {
      gl.deleteTransformFeedback(this.transformFeedbackB);
      this.transformFeedbackB = null;
    }
    this.forceFieldTexture?.dispose();
    this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(enabled) {
    if (enabled && !this.gpuPhysicsInitialized) {
      this.initializeGPUPhysics();
    }
    this.useGPUPhysics = enabled && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const resolution = 256;
    const sizeData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, sizeData);
    this.sizeOverLifetimeTexture = new DataTexture(
      sizeData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.sizeOverLifetimeTexture.needsUpdate = true;
    const opacityData = new Float32Array(resolution);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, opacityData);
    this.opacityOverLifetimeTexture = new DataTexture(
      opacityData,
      resolution,
      1,
      RedFormat,
      FloatType
    );
    this.opacityOverLifetimeTexture.needsUpdate = true;
    const colorStops = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ];
    const colorData = new Float32Array(resolution * 4);
    for (let i = 0; i < resolution; i++) {
      const t = i / (resolution - 1);
      const color = this.sampleColorGradient(colorStops, t);
      colorData[i * 4] = color[0];
      colorData[i * 4 + 1] = color[1];
      colorData[i * 4 + 2] = color[2];
      colorData[i * 4 + 3] = color[3];
    }
    this.colorOverLifetimeTexture = new DataTexture(
      colorData,
      resolution,
      1,
      RGBAFormat,
      FloatType
    );
    this.colorOverLifetimeTexture.needsUpdate = true;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(curve, output) {
    const len = output.length;
    if (!curve) {
      output.fill(1);
      return;
    }
    for (let i = 0; i < len; i++) {
      const t = i / (len - 1);
      output[i] = this.evaluateModulationCurve(curve, t);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(curve, t) {
    switch (curve.type) {
      case "constant":
        return curve.value;
      case "linear":
        return curve.start + (curve.end - curve.start) * t;
      case "curve": {
        const points = curve.points;
        if (points.length === 0) return 1;
        if (points.length === 1) return points[0].value;
        let p0 = points[0];
        let p1 = points[points.length - 1];
        for (let i = 0; i < points.length - 1; i++) {
          if (t >= points[i].time && t <= points[i + 1].time) {
            p0 = points[i];
            p1 = points[i + 1];
            break;
          }
        }
        const localT = (t - p0.time) / (p1.time - p0.time);
        const t2 = localT * localT;
        const t3 = t2 * localT;
        const h1 = 2 * t3 - 3 * t2 + 1;
        const h2 = -2 * t3 + 3 * t2;
        const h3 = t3 - 2 * t2 + localT;
        const h4 = t3 - t2;
        return h1 * p0.value + h2 * p1.value + h3 * (p0.outTangent ?? 0) + h4 * (p1.inTangent ?? 0);
      }
      case "random":
        return curve.min + this.rng() * (curve.max - curve.min);
      case "randomCurve": {
        const min = this.evaluateModulationCurve(curve.minCurve, t);
        const max = this.evaluateModulationCurve(curve.maxCurve, t);
        return min + this.rng() * (max - min);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(stops, t) {
    if (stops.length === 0) return [1, 1, 1, 1];
    if (stops.length === 1) return stops[0].color;
    let s0 = stops[0];
    let s1 = stops[stops.length - 1];
    for (let i = 0; i < stops.length - 1; i++) {
      if (t >= stops[i].time && t <= stops[i + 1].time) {
        s0 = stops[i];
        s1 = stops[i + 1];
        break;
      }
    }
    const localT = (t - s0.time) / (s1.time - s0.time);
    return [
      s0.color[0] + (s1.color[0] - s0.color[0]) * localT,
      s0.color[1] + (s1.color[1] - s0.color[1]) * localT,
      s0.color[2] + (s1.color[2] - s0.color[2]) * localT,
      s0.color[3] + (s1.color[3] - s0.color[3]) * localT
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const quadVertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    const quadUVs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new InstancedBufferGeometry();
    this.instancedGeometry.setAttribute("position", new BufferAttribute(quadVertices, 2));
    this.instancedGeometry.setAttribute("uv", new BufferAttribute(quadUVs, 2));
    const positionAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const velocityAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 3),
      3
    );
    const lifeAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const physicalAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const rotationAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 2),
      2
    );
    const colorAttr = new InstancedBufferAttribute(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    positionAttr.setUsage(DynamicDrawUsage);
    velocityAttr.setUsage(DynamicDrawUsage);
    lifeAttr.setUsage(DynamicDrawUsage);
    physicalAttr.setUsage(DynamicDrawUsage);
    rotationAttr.setUsage(DynamicDrawUsage);
    colorAttr.setUsage(DynamicDrawUsage);
    this.instancedGeometry.setAttribute("i_position", positionAttr);
    this.instancedGeometry.setAttribute("i_velocity", velocityAttr);
    this.instancedGeometry.setAttribute("i_life", lifeAttr);
    this.instancedGeometry.setAttribute("i_physical", physicalAttr);
    this.instancedGeometry.setAttribute("i_rotation", rotationAttr);
    this.instancedGeometry.setAttribute("i_color", colorAttr);
    this.material = new ShaderMaterial({
      vertexShader: PARTICLE_VERTEX_SHADER,
      fragmentShader: PARTICLE_FRAGMENT_SHADER,
      uniforms: this.createUniforms(),
      transparent: true,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    });
    this.particleMesh = new Mesh(this.instancedGeometry, this.material);
    this.particleMesh.frustumCulled = false;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(config) {
    this.emitters.set(config.id, {
      ...config,
      accumulator: 0,
      velocity: new Vector3()
    });
    this.state.activeEmitters = this.emitters.size;
    this.invalidateCache();
  }
  updateEmitter(id, updates) {
    const emitter = this.emitters.get(id);
    if (emitter) {
      Object.assign(emitter, updates);
      this.invalidateCache();
    }
  }
  removeEmitter(id) {
    this.emitters.delete(id);
    this.state.activeEmitters = this.emitters.size;
    this.invalidateCache();
  }
  getEmitter(id) {
    return this.emitters.get(id);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(config) {
    this.forceFields.set(config.id, config);
    this.invalidateCache();
  }
  updateForceField(id, updates) {
    const field = this.forceFields.get(id);
    if (field) {
      Object.assign(field, updates);
      this.invalidateCache();
    }
  }
  removeForceField(id) {
    this.forceFields.delete(id);
    this.invalidateCache();
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(config) {
    this.subEmitters.set(config.id, config);
    this.invalidateCache();
  }
  removeSubEmitter(id) {
    this.subEmitters.delete(id);
    this.invalidateCache();
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(deltaTime) {
    const startTime = performance.now();
    const dt = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : deltaTime * this.config.timeScale;
    this.emitParticles(dt);
    if (this.useGPUPhysics && this.gl) {
      this.updatePhysicsGPU(dt);
    } else {
      this.updatePhysics(dt);
    }
    this.processSubEmitters();
    if (this.config.flocking?.enabled) {
      this.updateSpatialHash();
      this.applyFlocking(dt);
    }
    this.applyAudioModulation();
    this.updateInstanceBuffers();
    this.state.simulationTime += dt;
    this.state.frameCount++;
    this.state.updateTimeMs = performance.now() - startTime;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(dt) {
    for (const emitter of this.emitters.values()) {
      if (!emitter.enabled) continue;
      let emissionRate = emitter.emissionRate;
      const audioMod = this.getAudioModulation("emitter", emitter.id, "emissionRate");
      if (audioMod !== void 0) {
        emissionRate *= audioMod;
      }
      if (emitter.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const burstCount = Math.floor(emitter.burstCount * emitter.beatEmissionMultiplier);
        for (let i = 0; i < burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
      emitter.accumulator += emissionRate * dt;
      while (emitter.accumulator >= 1) {
        this.spawnParticle(emitter);
        emitter.accumulator -= 1;
      }
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(emitter) {
    if (this.freeIndices.length === 0) {
      let oldestIndex = 0;
      let oldestAge = 0;
      const buffer2 = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let i = 0; i < this.config.maxParticles; i++) {
        const age = buffer2[i * PARTICLE_STRIDE + 6];
        if (age > oldestAge) {
          oldestAge = age;
          oldestIndex = i;
        }
      }
      this.freeIndices.push(oldestIndex);
    }
    const index = this.freeIndices.pop();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const offset = index * PARTICLE_STRIDE;
    const pos = this.getEmitterPosition(emitter);
    const dir = this.getEmissionDirection(emitter);
    const speed = emitter.initialSpeed + (this.rng() - 0.5) * 2 * emitter.speedVariance;
    const inheritVel = emitter.velocity.clone().multiplyScalar(emitter.inheritEmitterVelocity);
    buffer[offset + 0] = pos.x;
    buffer[offset + 1] = pos.y;
    buffer[offset + 2] = pos.z;
    buffer[offset + 3] = dir.x * speed + inheritVel.x;
    buffer[offset + 4] = dir.y * speed + inheritVel.y;
    buffer[offset + 5] = dir.z * speed + inheritVel.z;
    buffer[offset + 6] = 0;
    buffer[offset + 7] = emitter.lifetime + (this.rng() - 0.5) * 2 * emitter.lifetimeVariance;
    buffer[offset + 8] = emitter.initialMass + (this.rng() - 0.5) * 2 * emitter.massVariance;
    buffer[offset + 9] = emitter.initialSize + (this.rng() - 0.5) * 2 * emitter.sizeVariance;
    buffer[offset + 10] = emitter.initialRotation + this.rng() * emitter.rotationVariance;
    buffer[offset + 11] = emitter.initialAngularVelocity + (this.rng() - 0.5) * 2 * emitter.angularVelocityVariance;
    const colorT = this.rng() * emitter.colorVariance;
    buffer[offset + 12] = emitter.colorStart[0] + (emitter.colorEnd[0] - emitter.colorStart[0]) * colorT;
    buffer[offset + 13] = emitter.colorStart[1] + (emitter.colorEnd[1] - emitter.colorStart[1]) * colorT;
    buffer[offset + 14] = emitter.colorStart[2] + (emitter.colorEnd[2] - emitter.colorStart[2]) * colorT;
    buffer[offset + 15] = emitter.colorStart[3];
    this.state.particleCount++;
    this.emit("particleBirth", { index, emitterId: emitter.id });
    return index;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(emitter) {
    const shape = emitter.shape;
    const base = new Vector3(emitter.position.x, emitter.position.y, emitter.position.z);
    switch (shape.type) {
      case "point":
        return base;
      case "circle": {
        const angle = this.rng() * Math.PI * 2;
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.sqrt(this.rng());
        }
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          0
        ));
      }
      case "sphere": {
        const theta = this.rng() * Math.PI * 2;
        const phi = Math.acos(2 * this.rng() - 1);
        let radius = shape.radius ?? 50;
        if (!shape.emitFromEdge) {
          radius *= Math.cbrt(this.rng());
        }
        return base.add(new Vector3(
          Math.sin(phi) * Math.cos(theta) * radius,
          Math.sin(phi) * Math.sin(theta) * radius,
          Math.cos(phi) * radius
        ));
      }
      case "box": {
        const size = shape.boxSize ?? { x: 100, y: 100, z: 100 };
        return base.add(new Vector3(
          (this.rng() - 0.5) * size.x,
          (this.rng() - 0.5) * size.y,
          (this.rng() - 0.5) * size.z
        ));
      }
      case "line": {
        const start = shape.lineStart ?? { x: -50, y: 0, z: 0 };
        const end = shape.lineEnd ?? { x: 50, y: 0, z: 0 };
        const t = this.rng();
        return base.add(new Vector3(
          start.x + (end.x - start.x) * t,
          start.y + (end.y - start.y) * t,
          start.z + (end.z - start.z) * t
        ));
      }
      case "cone": {
        const angle = this.rng() * Math.PI * 2;
        const t = this.rng();
        const radius = t * (shape.coneRadius ?? 50);
        const height = t * (shape.coneLength ?? 100);
        return base.add(new Vector3(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        ));
      }
      case "image": {
        if (!shape.imageData) return base;
        const { width, height, data } = shape.imageData;
        const threshold = shape.emissionThreshold ?? 0.1;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * width);
          const py = Math.floor(this.rng() * height);
          const idx = (py * width + px) * 4;
          const alpha = data[idx + 3] / 255;
          if (alpha > threshold) {
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              0
            ));
          }
        }
        return base;
      }
      case "depthEdge": {
        if (!shape.depthData || !shape.imageData) return base;
        const { width, height } = shape.imageData;
        const depthData = shape.depthData;
        const threshold = shape.emissionThreshold ?? 0.05;
        for (let attempt = 0; attempt < 100; attempt++) {
          const px = Math.floor(this.rng() * (width - 2)) + 1;
          const py = Math.floor(this.rng() * (height - 2)) + 1;
          const idx = py * width + px;
          const d = depthData[idx];
          const dLeft = depthData[idx - 1];
          const dRight = depthData[idx + 1];
          const dUp = depthData[idx - width];
          const dDown = depthData[idx + width];
          const gradX = Math.abs(dRight - dLeft);
          const gradY = Math.abs(dDown - dUp);
          const gradient = Math.sqrt(gradX * gradX + gradY * gradY);
          if (gradient > threshold) {
            const z = d * 500;
            return base.add(new Vector3(
              px - width / 2,
              -(py - height / 2),
              // Flip Y for screen coords
              z
            ));
          }
        }
        return base;
      }
      default:
        return base;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(emitter) {
    const baseDir = new Vector3(
      emitter.emissionDirection.x,
      emitter.emissionDirection.y,
      emitter.emissionDirection.z
    ).normalize();
    if (emitter.emissionSpread <= 0) {
      return baseDir;
    }
    const spreadRad = emitter.emissionSpread * Math.PI / 180;
    const theta = this.rng() * Math.PI * 2;
    const phi = Math.acos(1 - this.rng() * (1 - Math.cos(spreadRad)));
    const up = Math.abs(baseDir.y) < 0.99 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0);
    const right = new Vector3().crossVectors(up, baseDir).normalize();
    const realUp = new Vector3().crossVectors(baseDir, right);
    return new Vector3().addScaledVector(baseDir, Math.cos(phi)).addScaledVector(right, Math.sin(phi) * Math.cos(theta)).addScaledVector(realUp, Math.sin(phi) * Math.sin(theta)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(dt) {
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = buffer[offset + 6];
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0 || age >= lifetime) continue;
      let px = buffer[offset + 0];
      let py = buffer[offset + 1];
      let pz = buffer[offset + 2];
      let vx = buffer[offset + 3];
      let vy = buffer[offset + 4];
      let vz = buffer[offset + 5];
      const mass = buffer[offset + 8];
      let fx = 0, fy = 0, fz = 0;
      for (const field of this.forceFields.values()) {
        if (!field.enabled) continue;
        const force = this.calculateForceField(field, px, py, pz, vx, vy, vz, mass);
        fx += force.x;
        fy += force.y;
        fz += force.z;
      }
      const ax = fx / Math.max(mass, 0.1);
      const ay = fy / Math.max(mass, 0.1);
      const az = fz / Math.max(mass, 0.1);
      vx += ax * dt;
      vy += ay * dt;
      vz += az * dt;
      px += vx * dt;
      py += vy * dt;
      pz += vz * dt;
      const lifeRatio = age / lifetime;
      const sizeMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const opacityMod = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        lifeRatio
      );
      const rotation = buffer[offset + 10] + buffer[offset + 11] * dt;
      buffer[offset + 0] = px;
      buffer[offset + 1] = py;
      buffer[offset + 2] = pz;
      buffer[offset + 3] = vx;
      buffer[offset + 4] = vy;
      buffer[offset + 5] = vz;
      buffer[offset + 6] = age + dt;
      buffer[offset + 9] *= sizeMod;
      buffer[offset + 10] = rotation;
      buffer[offset + 15] *= opacityMod;
      if (age + dt >= lifetime) {
        this.freeIndices.push(i);
        this.state.particleCount--;
        this.emit("particleDeath", { index: i });
      }
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(dt) {
    if (!this.gl || !this.transformFeedbackProgram) return;
    const gl = this.gl;
    this.updateForceFieldTexture();
    gl.useProgram(this.transformFeedbackProgram);
    const dtLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime");
    const timeLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_time");
    const ffCountLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount");
    const ffTexLoc = gl.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    gl.uniform1f(dtLoc, dt);
    gl.uniform1f(timeLoc, this.state.simulationTime);
    gl.uniform1i(ffCountLoc, Math.min(this.forceFields.size, MAX_FORCE_FIELDS));
    if (this.forceFieldTexture) {
      gl.activeTexture(gl.TEXTURE0);
      const textureProps = this.renderer?.properties.get(this.forceFieldTexture);
      const tex = textureProps?.__webglTexture;
      if (tex) {
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(ffTexLoc, 0);
      }
    }
    const readVAO = this.currentBuffer === "A" ? this.vaoA : this.vaoB;
    const writeTF = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB;
    const writeVBO = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    gl.bindVertexArray(readVAO);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, writeTF);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, this.config.maxParticles);
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindVertexArray(null);
    this.currentBuffer = this.currentBuffer === "A" ? "B" : "A";
    if (this.state.frameCount % 10 === 0) {
      this.readBackParticleData(writeVBO);
    }
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let fieldIndex = 0;
    for (const field of this.forceFields.values()) {
      if (fieldIndex >= MAX_FORCE_FIELDS) break;
      if (!field.enabled) continue;
      const baseOffset = fieldIndex * 16;
      this.forceFieldBuffer[baseOffset + 0] = field.position.x;
      this.forceFieldBuffer[baseOffset + 1] = field.position.y;
      this.forceFieldBuffer[baseOffset + 2] = field.position.z;
      this.forceFieldBuffer[baseOffset + 3] = this.getForceFieldTypeIndex(field.type);
      this.forceFieldBuffer[baseOffset + 4] = field.strength;
      this.forceFieldBuffer[baseOffset + 5] = field.falloffStart;
      this.forceFieldBuffer[baseOffset + 6] = field.falloffEnd;
      this.forceFieldBuffer[baseOffset + 7] = this.getFalloffTypeIndex(field.falloffType);
      this.forceFieldBuffer[baseOffset + 8] = field.direction?.x ?? field.vortexAxis?.x ?? field.windDirection?.x ?? 0;
      this.forceFieldBuffer[baseOffset + 9] = field.direction?.y ?? field.vortexAxis?.y ?? field.windDirection?.y ?? 0;
      this.forceFieldBuffer[baseOffset + 10] = field.direction?.z ?? field.vortexAxis?.z ?? field.windDirection?.z ?? 0;
      this.forceFieldBuffer[baseOffset + 11] = field.inwardForce ?? 0;
      this.forceFieldBuffer[baseOffset + 12] = field.noiseScale ?? field.linearDrag ?? field.gustStrength ?? 0;
      this.forceFieldBuffer[baseOffset + 13] = field.noiseSpeed ?? field.quadraticDrag ?? field.gustFrequency ?? 0;
      this.forceFieldBuffer[baseOffset + 14] = 0;
      this.forceFieldBuffer[baseOffset + 15] = 0;
      fieldIndex++;
    }
    this.forceFieldTexture.needsUpdate = true;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(type) {
    switch (type) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(type) {
    switch (type) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(vbo) {
    if (!this.gl || !vbo) return;
    const gl = this.gl;
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.getBufferSubData(gl.ARRAY_BUFFER, 0, targetBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    let activeCount = 0;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const age = targetBuffer[offset + 6];
      const lifetime = targetBuffer[offset + 7];
      if (lifetime > 0 && age < lifetime) {
        activeCount++;
      } else if (lifetime > 0 && age >= lifetime) {
        if (!this.freeIndices.includes(i)) {
          this.freeIndices.push(i);
          this.emit("particleDeath", { index: i });
        }
      }
    }
    this.state.particleCount = activeCount;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(field, px, py, pz, vx, vy, vz, mass) {
    const force = new Vector3();
    const dx = px - field.position.x;
    const dy = py - field.position.y;
    const dz = pz - field.position.z;
    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
    let falloff = 1;
    if (dist > field.falloffStart) {
      const t = Math.min((dist - field.falloffStart) / (field.falloffEnd - field.falloffStart), 1);
      switch (field.falloffType) {
        case "linear":
          falloff = 1 - t;
          break;
        case "quadratic":
          falloff = 1 - t * t;
          break;
        case "exponential":
          falloff = Math.exp(-t * 3);
          break;
        case "smoothstep":
          falloff = 1 - (3 * t * t - 2 * t * t * t);
          break;
      }
    }
    const strength = field.strength * falloff;
    switch (field.type) {
      case "gravity":
        force.set(
          (field.direction?.x ?? 0) * strength,
          (field.direction?.y ?? 1) * strength,
          (field.direction?.z ?? 0) * strength
        );
        break;
      case "point":
        if (dist > 1e-3) {
          const dir = new Vector3(-dx, -dy, -dz).normalize();
          force.copy(dir).multiplyScalar(strength / mass);
        }
        break;
      case "vortex":
        if (dist > 1e-3) {
          const axis = new Vector3(
            field.vortexAxis?.x ?? 0,
            field.vortexAxis?.y ?? 0,
            field.vortexAxis?.z ?? 1
          ).normalize();
          const toParticle = new Vector3(dx, dy, dz);
          const tangent = new Vector3().crossVectors(axis, toParticle).normalize();
          const inward = toParticle.normalize().multiplyScalar(-(field.inwardForce ?? 0));
          force.copy(tangent).multiplyScalar(strength).add(inward);
        }
        break;
      case "turbulence": {
        const scale = field.noiseScale ?? 0.01;
        const speed = field.noiseSpeed ?? 0.5;
        const time = this.state.simulationTime * speed;
        const nx = Math.sin(px * scale + time) * Math.cos(py * scale * 1.3) * strength;
        const ny = Math.sin(py * scale + time * 1.1) * Math.cos(pz * scale * 1.2) * strength;
        const nz = Math.sin(pz * scale + time * 0.9) * Math.cos(px * scale * 1.1) * strength;
        force.set(nx, ny, nz);
        break;
      }
      case "drag": {
        const speed = Math.sqrt(vx * vx + vy * vy + vz * vz);
        if (speed > 1e-3) {
          const dragMag = (field.linearDrag ?? 0.1) * speed + (field.quadraticDrag ?? 0.01) * speed * speed;
          force.set(-vx, -vy, -vz).normalize().multiplyScalar(-dragMag * strength);
        }
        break;
      }
      case "wind": {
        const windDir = new Vector3(
          field.windDirection?.x ?? 1,
          field.windDirection?.y ?? 0,
          field.windDirection?.z ?? 0
        ).normalize();
        const gust = Math.sin(this.state.simulationTime * (field.gustFrequency ?? 0.5)) * (field.gustStrength ?? 0);
        force.copy(windDir).multiplyScalar(strength + gust);
        break;
      }
      case "lorenz": {
        const sigma = field.lorenzSigma ?? 10;
        const rho = field.lorenzRho ?? 28;
        const beta = field.lorenzBeta ?? 2.667;
        force.set(
          sigma * (dy - dx),
          dx * (rho - dz) - dy,
          dx * dy - beta * dz
        ).multiplyScalar(strength * 0.01);
        break;
      }
    }
    return force;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const key = `${cellX},${cellY},${cellZ}`;
      if (!this.spatialHash.has(key)) {
        this.spatialHash.set(key, []);
      }
      this.spatialHash.get(key).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(dt) {
    const config = this.config.flocking;
    if (!config?.enabled) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const cellSize = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const offset = i * PARTICLE_STRIDE;
      const lifetime = buffer[offset + 7];
      if (lifetime <= 0) continue;
      const px = buffer[offset + 0];
      const py = buffer[offset + 1];
      const pz = buffer[offset + 2];
      const cellX = Math.floor(px / cellSize);
      const cellY = Math.floor(py / cellSize);
      const cellZ = Math.floor(pz / cellSize);
      const separation = new Vector3();
      const alignment = new Vector3();
      const cohesion = new Vector3();
      let separationCount = 0;
      let alignmentCount = 0;
      let cohesionCount = 0;
      for (let cx = cellX - 1; cx <= cellX + 1; cx++) {
        for (let cy = cellY - 1; cy <= cellY + 1; cy++) {
          for (let cz = cellZ - 1; cz <= cellZ + 1; cz++) {
            const neighbors = this.spatialHash.get(`${cx},${cy},${cz}`);
            if (!neighbors) continue;
            for (const j of neighbors) {
              if (j === i) continue;
              const jOffset = j * PARTICLE_STRIDE;
              const jx = buffer[jOffset + 0];
              const jy = buffer[jOffset + 1];
              const jz = buffer[jOffset + 2];
              const dx = px - jx;
              const dy = py - jy;
              const dz = pz - jz;
              const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (dist < config.separationRadius && dist > 0) {
                separation.add(new Vector3(dx, dy, dz).divideScalar(dist));
                separationCount++;
              }
              if (dist < config.alignmentRadius) {
                alignment.add(new Vector3(
                  buffer[jOffset + 3],
                  buffer[jOffset + 4],
                  buffer[jOffset + 5]
                ));
                alignmentCount++;
              }
              if (dist < config.cohesionRadius) {
                cohesion.add(new Vector3(jx, jy, jz));
                cohesionCount++;
              }
            }
          }
        }
      }
      if (separationCount > 0) {
        separation.divideScalar(separationCount).normalize().multiplyScalar(config.separationWeight);
      }
      if (alignmentCount > 0) {
        alignment.divideScalar(alignmentCount).normalize().multiplyScalar(config.alignmentWeight);
      }
      if (cohesionCount > 0) {
        cohesion.divideScalar(cohesionCount);
        cohesion.sub(new Vector3(px, py, pz)).normalize().multiplyScalar(config.cohesionWeight);
      }
      const steering = separation.add(alignment).add(cohesion);
      if (steering.length() > config.maxForce) {
        steering.normalize().multiplyScalar(config.maxForce);
      }
      buffer[offset + 3] += steering.x * dt;
      buffer[offset + 4] += steering.y * dt;
      buffer[offset + 5] += steering.z * dt;
      const speed = Math.sqrt(
        buffer[offset + 3] ** 2 + buffer[offset + 4] ** 2 + buffer[offset + 5] ** 2
      );
      if (speed > config.maxSpeed) {
        const scale = config.maxSpeed / speed;
        buffer[offset + 3] *= scale;
        buffer[offset + 4] *= scale;
        buffer[offset + 5] *= scale;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const binding of this.config.audioBindings) {
      const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
      const smoothed = featureValue;
      const t = (smoothed - binding.min) / (binding.max - binding.min);
      let output = binding.outputMin + t * (binding.outputMax - binding.outputMin);
      if (binding.curve === "exponential") {
        output = binding.outputMin + Math.pow(t, 2) * (binding.outputMax - binding.outputMin);
      } else if (binding.curve === "logarithmic") {
        output = binding.outputMin + Math.sqrt(t) * (binding.outputMax - binding.outputMin);
      }
      if (binding.target === "emitter") {
        const emitter = this.emitters.get(binding.targetId);
        if (emitter) {
          emitter[binding.parameter] = output;
        }
      } else if (binding.target === "forceField") {
        const field = this.forceFields.get(binding.targetId);
        if (field) {
          field[binding.parameter] = output;
        }
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(target, targetId, parameter) {
    for (const binding of this.config.audioBindings) {
      if (binding.target === target && binding.targetId === targetId && binding.parameter === parameter) {
        const featureValue = this.audioFeatures.get(binding.feature) ?? 0;
        const t = (featureValue - binding.min) / (binding.max - binding.min);
        return binding.outputMin + t * (binding.outputMax - binding.outputMin);
      }
    }
    return void 0;
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const buffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    const posAttr = this.instancedGeometry.getAttribute("i_position");
    const velAttr = this.instancedGeometry.getAttribute("i_velocity");
    const lifeAttr = this.instancedGeometry.getAttribute("i_life");
    const physAttr = this.instancedGeometry.getAttribute("i_physical");
    const rotAttr = this.instancedGeometry.getAttribute("i_rotation");
    const colAttr = this.instancedGeometry.getAttribute("i_color");
    for (let i = 0; i < this.config.maxParticles; i++) {
      const src = i * PARTICLE_STRIDE;
      posAttr.setXYZ(i, buffer[src + 0], buffer[src + 1], buffer[src + 2]);
      velAttr.setXYZ(i, buffer[src + 3], buffer[src + 4], buffer[src + 5]);
      lifeAttr.setXY(i, buffer[src + 6], buffer[src + 7]);
      physAttr.setXY(i, buffer[src + 8], buffer[src + 9]);
      rotAttr.setXY(i, buffer[src + 10], buffer[src + 11]);
      colAttr.setXYZW(i, buffer[src + 12], buffer[src + 13], buffer[src + 14], buffer[src + 15]);
    }
    posAttr.needsUpdate = true;
    velAttr.needsUpdate = true;
    lifeAttr.needsUpdate = true;
    physAttr.needsUpdate = true;
    rotAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(feature, value) {
    this.audioFeatures.set(feature, value);
    this.state.currentAudioFeatures.set(feature, value);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1);
    requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(emitterId) {
    if (emitterId) {
      const emitter = this.emitters.get(emitterId);
      if (emitter) {
        for (let i = 0; i < emitter.burstCount; i++) {
          this.spawnParticle(emitter);
        }
      }
    } else {
      for (const emitter of this.emitters.values()) {
        if (emitter.burstOnBeat && emitter.enabled) {
          for (let i = 0; i < emitter.burstCount; i++) {
            this.spawnParticle(emitter);
          }
        }
      }
    }
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return AdditiveBlending;
      case "multiply":
        return MultiplyBlending;
      case "screen":
        return CustomBlending;
      default:
        return NormalBlending;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(event, handler) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(event).add(handler);
  }
  off(event, handler) {
    this.eventHandlers.get(event)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => handler(event));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   * State is tracked externally via currentRngState for save/restore
   */
  createSeededRandom(seed) {
    this.currentRngState = seed;
    return () => {
      this.currentRngState = this.currentRngState * 1103515245 + 12345 & 2147483647;
      return this.currentRngState / 2147483647;
    };
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    const emitters = Array.from(this.emitters.values()).map((e) => {
      const { accumulator, velocity, ...config } = e;
      return config;
    });
    return {
      emitters,
      forceFields: Array.from(this.forceFields.values())
    };
  }
  // ============================================================================
  // FRAME CACHING METHODS
  // ============================================================================
  /**
   * Cache the current particle state for a specific frame
   * Called automatically every cacheInterval frames during step()
   */
  cacheCurrentState(frame) {
    if (this.frameCache.size >= this.maxCacheSize) {
      const oldestFrame = Math.min(...this.frameCache.keys());
      this.frameCache.delete(oldestFrame);
    }
    const emitterAccumulators = /* @__PURE__ */ new Map();
    for (const [id, emitter] of this.emitters) {
      emitterAccumulators.set(id, emitter.accumulator);
    }
    const currentBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    this.frameCache.set(frame, {
      frame,
      version: this.cacheVersion,
      particleBuffer: new Float32Array(currentBuffer),
      // Deep copy
      freeIndices: [...this.freeIndices],
      // Copy array
      particleCount: this.state.particleCount,
      simulationTime: this.state.simulationTime,
      rngState: this.currentRngState,
      emitterAccumulators
    });
  }
  /**
   * Restore particle state from a cached frame
   * @returns true if restore succeeded, false if cache miss or version mismatch
   */
  restoreFromCache(frame) {
    const cached = this.frameCache.get(frame);
    if (!cached || cached.version !== this.cacheVersion) {
      return false;
    }
    const targetBuffer = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    targetBuffer.set(cached.particleBuffer);
    this.freeIndices = [...cached.freeIndices];
    this.state.particleCount = cached.particleCount;
    this.state.simulationTime = cached.simulationTime;
    this.state.frameCount = frame;
    this.currentSimulatedFrame = frame;
    this.currentRngState = cached.rngState;
    for (const [id, accumulator] of cached.emitterAccumulators) {
      const emitter = this.emitters.get(id);
      if (emitter) {
        emitter.accumulator = accumulator;
      }
    }
    this.updateInstanceBuffers();
    return true;
  }
  /**
   * Find the nearest cached frame at or before the target frame
   * @returns The nearest cached frame number, or -1 if no cache exists
   */
  findNearestCache(targetFrame) {
    let nearestFrame = -1;
    for (const frame of this.frameCache.keys()) {
      const cached = this.frameCache.get(frame);
      if (cached && cached.version === this.cacheVersion && frame <= targetFrame && frame > nearestFrame) {
        nearestFrame = frame;
      }
    }
    return nearestFrame;
  }
  /**
   * Clear all cached frames
   */
  clearCache() {
    this.frameCache.clear();
    this.currentSimulatedFrame = -1;
  }
  /**
   * Invalidate the cache by incrementing version
   * Called when particle parameters change (emitter config, force fields, etc.)
   */
  invalidateCache() {
    this.cacheVersion++;
    this.currentSimulatedFrame = -1;
  }
  /**
   * Simulate particles to a specific frame, using cache when available
   * This is the main entry point for timeline scrubbing
   *
   * @param targetFrame The frame number to simulate to
   * @param fps Frames per second for deltaTime calculation
   * @returns The number of simulation steps performed
   */
  simulateToFrame(targetFrame, fps = 30) {
    const deltaTime = 1 / fps;
    if (this.currentSimulatedFrame === targetFrame) {
      return 0;
    }
    if (this.currentSimulatedFrame >= 0 && this.currentSimulatedFrame < targetFrame && targetFrame - this.currentSimulatedFrame <= this.cacheInterval * 2) {
      let steps2 = 0;
      for (let f = this.currentSimulatedFrame + 1; f <= targetFrame; f++) {
        this.step(deltaTime);
        this.currentSimulatedFrame = f;
        if (f % this.cacheInterval === 0) {
          this.cacheCurrentState(f);
        }
        steps2++;
      }
      return steps2;
    }
    const nearestCache = this.findNearestCache(targetFrame);
    let startFrame = 0;
    if (nearestCache >= 0) {
      if (this.restoreFromCache(nearestCache)) {
        startFrame = nearestCache;
      }
    }
    if (startFrame === 0) {
      this.reset();
      this.currentSimulatedFrame = 0;
      this.cacheCurrentState(0);
    }
    let steps = 0;
    for (let f = startFrame + 1; f <= targetFrame; f++) {
      this.step(deltaTime);
      this.currentSimulatedFrame = f;
      if (f % this.cacheInterval === 0) {
        this.cacheCurrentState(f);
      }
      steps++;
    }
    return steps;
  }
  /**
   * Get cache statistics for debugging/UI
   */
  getCacheStats() {
    let validCount = 0;
    for (const cached of this.frameCache.values()) {
      if (cached.version === this.cacheVersion) {
        validCount++;
      }
    }
    return {
      cachedFrames: validCount,
      version: this.cacheVersion,
      currentFrame: this.currentSimulatedFrame,
      cacheInterval: this.cacheInterval,
      maxCacheSize: this.maxCacheSize
    };
  }
  /**
   * Set the cache interval (how often to cache frames)
   */
  setCacheInterval(interval) {
    this.cacheInterval = Math.max(1, interval);
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets RNG to initial seed for reproducible simulation
   */
  reset() {
    this.particleBufferA.fill(0);
    this.particleBufferB.fill(0);
    this.freeIndices = [];
    for (let i = this.config.maxParticles - 1; i >= 0; i--) {
      this.freeIndices.push(i);
    }
    this.state.particleCount = 0;
    this.state.simulationTime = 0;
    this.state.frameCount = 0;
    this.spatialHash.clear();
    for (const emitter of this.emitters.values()) {
      emitter.accumulator = 0;
    }
    this.currentSimulatedFrame = -1;
    this.rng = this.createSeededRandom(this.config.randomSeed ?? 12345);
  }
  /**
   * Get the current seed
   */
  getSeed() {
    return this.config.randomSeed ?? 12345;
  }
  /**
   * Set a new seed and reset the system
   * DETERMINISM: Used to ensure layer-specific reproducible seeds
   */
  setSeed(seed) {
    this.config.randomSeed = seed;
    this.initialRngSeed = seed;
    this.clearCache();
    this.reset();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.instancedGeometry?.dispose();
    this.material?.dispose();
    this.sizeOverLifetimeTexture?.dispose();
    this.opacityOverLifetimeTexture?.dispose();
    this.colorOverLifetimeTexture?.dispose();
    this.cleanupGPUPhysics();
    this.emitters.clear();
    this.forceFields.clear();
    this.subEmitters.clear();
    this.eventHandlers.clear();
  }
}

class ParticleLayer extends BaseLayer {
  /** The GPU particle system instance */
  particleSystem;
  /** Particle system configuration */
  systemConfig;
  /** Whether the system has been initialized with a renderer */
  initialized = false;
  /** Stored renderer reference for reinitialization */
  rendererRef = null;
  /** Composition FPS for time calculation */
  fps = 60;
  /** Deterministic seed derived from layer ID */
  layerSeed;
  /** Last evaluated frame (for scrub detection) */
  lastEvaluatedFrame = -1;
  /** Performance stats */
  stats = {
    particleCount: 0,
    updateTimeMs: 0,
    renderTimeMs: 0
  };
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /** Emitter visualization icons */
  emitterGizmos = /* @__PURE__ */ new Map();
  /** Force field visualization icons */
  forceFieldGizmos = /* @__PURE__ */ new Map();
  /** Whether emitter gizmos are visible */
  showEmitterGizmos = true;
  /** Whether force field gizmos are visible */
  showForceFieldGizmos = true;
  constructor(layerData) {
    super(layerData);
    this.layerSeed = this.generateSeedFromId(layerData.id);
    this.systemConfig = this.buildSystemConfig(layerData);
    this.systemConfig.randomSeed = this.layerSeed;
    this.particleSystem = new GPUParticleSystem(this.systemConfig);
    this.initializeBlendMode();
  }
  /**
   * Generate deterministic seed from layer ID
   * DETERMINISM: Same layer ID always produces identical seed
   */
  generateSeedFromId(layerId) {
    let hash = 0;
    for (let i = 0; i < layerId.length; i++) {
      const char = layerId.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash) || 12345;
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(layerData) {
    const data = layerData.data;
    const config = createDefaultConfig();
    if (!data) {
      config.emitters = [createDefaultEmitter("default")];
      return config;
    }
    if (data.systemConfig) {
      config.maxParticles = data.systemConfig.maxParticles ?? 1e5;
      config.timeScale = 1;
      if (data.systemConfig.gravity !== 0) {
        config.forceFields.push({
          id: "global_gravity",
          name: "Gravity",
          type: "gravity",
          enabled: true,
          strength: data.systemConfig.gravity * 10,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          direction: { x: 0, y: 1, z: 0 }
        });
      }
      if (data.systemConfig.windStrength !== 0) {
        const windAngle = (data.systemConfig.windDirection ?? 0) * Math.PI / 180;
        config.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: true,
          strength: data.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(windAngle),
            y: Math.sin(windAngle),
            z: 0
          },
          gustStrength: data.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (data.systemConfig.friction > 0) {
        config.forceFields.push({
          id: "global_drag",
          name: "Friction",
          type: "drag",
          enabled: true,
          strength: 1,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          linearDrag: data.systemConfig.friction,
          quadraticDrag: data.systemConfig.friction * 0.1
        });
      }
      if (data.systemConfig.turbulenceFields) {
        for (const turbField of data.systemConfig.turbulenceFields) {
          if (turbField.enabled) {
            config.forceFields.push({
              id: turbField.id,
              name: "Turbulence",
              type: "turbulence",
              enabled: true,
              strength: turbField.strength,
              position: { x: 0, y: 0, z: 0 },
              falloffStart: 0,
              falloffEnd: 1e4,
              falloffType: "none",
              noiseScale: turbField.scale,
              noiseSpeed: turbField.evolutionSpeed,
              noiseOctaves: 3,
              noiseLacunarity: 2,
              noiseGain: 0.5
            });
          }
        }
      }
    }
    if (data.emitters) {
      for (const emitter of data.emitters) {
        if (!emitter.enabled) continue;
        const dirRad = (emitter.direction ?? 0) * Math.PI / 180;
        const gpuEmitter = {
          id: emitter.id,
          name: emitter.name,
          enabled: true,
          position: { x: emitter.x, y: emitter.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: emitter.emissionRate,
          emissionRateVariance: 0,
          burstCount: emitter.burstCount,
          burstInterval: 0,
          initialSpeed: emitter.speed,
          speedVariance: emitter.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: emitter.size,
          sizeVariance: emitter.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: emitter.particleLifetime,
          lifetimeVariance: emitter.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            1
          ],
          colorEnd: [
            emitter.color[0] / 255,
            emitter.color[1] / 255,
            emitter.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(dirRad),
            y: Math.sin(dirRad),
            z: 0
          },
          emissionSpread: emitter.spread,
          burstOnBeat: emitter.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        config.emitters.push(gpuEmitter);
      }
    }
    if (data.gravityWells) {
      for (const well of data.gravityWells) {
        if (!well.enabled) continue;
        config.forceFields.push({
          id: well.id,
          name: well.name,
          type: "point",
          enabled: true,
          strength: well.strength,
          position: { x: well.x, y: well.y, z: 0 },
          falloffStart: 0,
          falloffEnd: well.radius,
          falloffType: well.falloff === "linear" ? "linear" : well.falloff === "quadratic" ? "quadratic" : "none"
        });
      }
    }
    if (data.vortices) {
      for (const vortex of data.vortices) {
        if (!vortex.enabled) continue;
        config.forceFields.push({
          id: vortex.id,
          name: vortex.name,
          type: "vortex",
          enabled: true,
          strength: vortex.strength * vortex.rotationSpeed,
          position: { x: vortex.x, y: vortex.y, z: 0 },
          falloffStart: 0,
          falloffEnd: vortex.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: vortex.inwardPull
        });
      }
    }
    if (data.modulations) {
      const sizeModulations = data.modulations.filter((m) => m.property === "size");
      if (sizeModulations.length > 0) {
        const mod = sizeModulations[0];
        config.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
      const opacityModulations = data.modulations.filter((m) => m.property === "opacity");
      if (opacityModulations.length > 0) {
        const mod = opacityModulations[0];
        config.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: mod.startValue / 100,
          end: mod.endValue / 100
        };
      }
    }
    if (data.renderOptions) {
      config.render.blendMode = data.renderOptions.blendMode ?? "normal";
      config.render.motionBlur = data.renderOptions.motionBlur ?? false;
      config.render.motionBlurStrength = data.renderOptions.motionBlurStrength ?? 0.5;
      config.render.motionBlurSamples = data.renderOptions.motionBlurSamples ?? 4;
      if (data.renderOptions.renderTrails) {
        config.render.mode = "trail";
        config.render.trailLength = data.renderOptions.trailLength;
        config.render.trailWidthEnd = 1 - (data.renderOptions.trailOpacityFalloff ?? 0.8);
      }
      config.render.texture.proceduralType = data.renderOptions.particleShape === "star" ? "star" : data.renderOptions.particleShape === "square" ? "square" : "circle";
    }
    return config;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(renderer) {
    if (this.initialized) return;
    this.rendererRef = renderer;
    this.particleSystem.initialize(renderer);
    this.initialized = true;
    const mesh = this.particleSystem.getMesh();
    if (mesh) {
      this.group.add(mesh);
    }
    this.createGizmos();
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    if (!this.initialized) {
      this.initializeWithRenderer(renderer);
    }
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(config) {
    const emitter = createDefaultEmitter();
    if (config) {
      Object.assign(emitter, config);
    }
    this.particleSystem.addEmitter(emitter);
    return emitter.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(id, updates) {
    this.particleSystem.updateEmitter(id, updates);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(id) {
    this.particleSystem.removeEmitter(id);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(type, config) {
    const field = createDefaultForceField(type);
    if (config) {
      Object.assign(field, config);
    }
    this.particleSystem.addForceField(field);
    return field.id;
  }
  /**
   * Update a force field
   */
  updateForceField(id, updates) {
    this.particleSystem.updateForceField(id, updates);
  }
  /**
   * Remove a force field
   */
  removeForceField(id) {
    this.particleSystem.removeForceField(id);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(feature, value) {
    this.particleSystem.setAudioFeature(feature, value);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(emitterId) {
    this.particleSystem.triggerBurst(emitterId);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(deltaTime) {
    if (!this.initialized) return;
    this.particleSystem.step(deltaTime);
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets to initial state with original seed
   */
  reset() {
    this.particleSystem.reset();
    this.lastEvaluatedFrame = -1;
  }
  /**
   * Clear the particle cache (used when user wants to free memory)
   */
  clearCache() {
    this.particleSystem.clearCache();
  }
  /**
   * Get cache statistics for UI display
   */
  getCacheStats() {
    return this.particleSystem.getCacheStats();
  }
  /**
   * Pre-cache frames from startFrame to endFrame
   * Used by Preview panel to build cache before playback
   * @returns Progress callback will be called with (current, total)
   */
  async preCacheFrames(startFrame, endFrame, onProgress) {
    const totalFrames = endFrame - startFrame + 1;
    for (let frame = startFrame; frame <= endFrame; frame++) {
      this.particleSystem.simulateToFrame(frame, this.fps);
      if (onProgress) {
        onProgress(frame - startFrame + 1, totalFrames);
      }
      if ((frame - startFrame) % 10 === 0) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
  }
  /**
   * Set the cache interval (frames between cached snapshots)
   */
  setCacheInterval(interval) {
    this.particleSystem.setCacheInterval(interval);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const stepsPerformed = this.particleSystem.simulateToFrame(frame, this.fps);
    this.lastEvaluatedFrame = frame;
    this.applyAudioReactivity();
    const state = this.particleSystem.getState();
    this.stats.particleCount = state.particleCount;
    this.stats.updateTimeMs = state.updateTimeMs;
    this.stats.renderTimeMs = state.renderTimeMs;
    if (stepsPerformed > 10) {
      const cacheStats = this.particleSystem.getCacheStats();
      console.debug(
        `ParticleLayer: Simulated ${stepsPerformed} frames to reach frame ${frame}. Cache: ${cacheStats.cachedFrames} frames cached`
      );
    }
  }
  onApplyEvaluatedState(state) {
    const frame = state.frame ?? 0;
    this.onEvaluateFrame(frame);
  }
  /**
   * Evaluate particles at a specific frame (scrub-safe)
   * DETERMINISM: Returns identical results regardless of evaluation order
   * Uses frame caching for performance
   */
  evaluateAtFrame(frame) {
    this.particleSystem.simulateToFrame(frame, this.fps);
    this.lastEvaluatedFrame = frame;
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const emissionRate = this.getAudioReactiveValue("particle.emissionRate");
    const speed = this.getAudioReactiveValue("particle.speed");
    const size = this.getAudioReactiveValue("particle.size");
    const gravity = this.getAudioReactiveValue("particle.gravity");
    const windStrength = this.getAudioReactiveValue("particle.windStrength");
    if (emissionRate !== 0) {
      this.particleSystem.setAudioFeature("amplitude", emissionRate);
    }
    if (speed !== 0 || size !== 0 || emissionRate !== 0) {
      const emitters = this.particleSystem.getConfig().emitters;
      for (const emitter of emitters) {
        if (speed !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSpeed: emitter.initialSpeed * (0.5 + speed)
          });
        }
        if (size !== 0) {
          this.particleSystem.updateEmitter(emitter.id, {
            initialSize: emitter.initialSize * (0.5 + size)
          });
        }
      }
    }
    if (gravity !== 0 || windStrength !== 0) {
      const forceFields = this.particleSystem.getConfig().forceFields;
      for (const field of forceFields) {
        if (field.type === "gravity" && gravity !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + gravity)
          });
        }
        if (field.type === "wind" && windStrength !== 0) {
          this.particleSystem.updateForceField(field.id, {
            strength: field.strength * (0.5 + windStrength)
          });
        }
      }
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      const oldMesh = this.particleSystem.getMesh();
      if (oldMesh) {
        this.group.remove(oldMesh);
      }
      this.systemConfig = this.buildSystemConfig({
        ...properties,
        id: this.id,
        type: "particles"
      });
      this.systemConfig.randomSeed = this.layerSeed;
      this.particleSystem.dispose();
      this.particleSystem = new GPUParticleSystem(this.systemConfig);
      this.lastEvaluatedFrame = -1;
      if (this.rendererRef) {
        this.initialized = false;
        this.initializeWithRenderer(this.rendererRef);
      }
    }
  }
  onDispose() {
    this.particleSystem.dispose();
    this.disposeGizmos();
  }
  // ============================================================================
  // EMITTER GIZMO VISUALIZATION
  // ============================================================================
  /**
   * Create visual gizmos for all emitters and force fields
   */
  createGizmos() {
    this.disposeGizmos();
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      this.createEmitterGizmo(emitter);
    }
    for (const field of config.forceFields) {
      this.createForceFieldGizmo(field);
    }
  }
  /**
   * Create a visual gizmo for an emitter
   */
  createEmitterGizmo(emitter) {
    const gizmo = new Group();
    gizmo.name = `emitter_gizmo_${emitter.id}`;
    const size = 30;
    switch (emitter.shape.type) {
      case "point": {
        const coneGeom = new ConeGeometry(8, 20, 8);
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.7,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        cone.rotation.x = Math.PI;
        gizmo.add(cone);
        const sphereGeom = new SphereGeometry(5, 8, 8);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.9,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "circle": {
        const ringGeom = new RingGeometry(
          (emitter.shape.radius ?? 50) * 0.8,
          emitter.shape.radius ?? 50,
          32
        );
        const ringMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.5,
          side: DoubleSide,
          depthTest: false
        });
        const ring = new Mesh(ringGeom, ringMat);
        gizmo.add(ring);
        break;
      }
      case "sphere": {
        const sphereGeom = new SphereGeometry(emitter.shape.radius ?? 50, 16, 16);
        const sphereMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        break;
      }
      case "box": {
        const boxGeom = new BoxGeometry(
          emitter.shape.boxSize?.x ?? 100,
          emitter.shape.boxSize?.y ?? 100,
          emitter.shape.boxSize?.z ?? 100
        );
        const boxMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const box = new Mesh(boxGeom, boxMat);
        gizmo.add(box);
        break;
      }
      case "cone": {
        const coneGeom = new ConeGeometry(
          emitter.shape.coneRadius ?? 30,
          emitter.shape.coneLength ?? 100,
          16,
          1,
          true
        );
        const coneMat = new MeshBasicMaterial({
          color: 65416,
          transparent: true,
          opacity: 0.3,
          wireframe: true,
          depthTest: false
        });
        const cone = new Mesh(coneGeom, coneMat);
        gizmo.add(cone);
        break;
      }
      default: {
        const lineMat = new LineBasicMaterial({
          color: 65416,
          depthTest: false
        });
        const hPoints = [new Vector3(-size, 0, 0), new Vector3(size, 0, 0)];
        const vPoints = [new Vector3(0, -size, 0), new Vector3(0, size, 0)];
        const hLine = new Line(
          new BufferGeometry().setFromPoints(hPoints),
          lineMat
        );
        const vLine = new Line(
          new BufferGeometry().setFromPoints(vPoints),
          lineMat.clone()
        );
        gizmo.add(hLine, vLine);
      }
    }
    const dir = emitter.emissionDirection;
    if (dir) {
      const arrowLength = 40;
      const arrowGeom = new BufferGeometry().setFromPoints([
        new Vector3(0, 0, 0),
        new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
      ]);
      const arrowMat = new LineBasicMaterial({
        color: 16776960,
        depthTest: false
      });
      const arrow = new Line(arrowGeom, arrowMat);
      gizmo.add(arrow);
    }
    const pos = emitter.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showEmitterGizmos;
    gizmo.renderOrder = 997;
    this.emitterGizmos.set(emitter.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Create a visual gizmo for a force field
   */
  createForceFieldGizmo(field) {
    const gizmo = new Group();
    gizmo.name = `forcefield_gizmo_${field.id}`;
    const radius = field.falloffEnd || 100;
    switch (field.type) {
      case "gravity":
      case "wind": {
        const dir = field.type === "wind" && field.windDirection ? field.windDirection : field.direction ?? { x: 0, y: 1, z: 0 };
        const arrowLength = 60;
        const arrowPoints = [
          new Vector3(0, 0, 0),
          new Vector3(dir.x * arrowLength, -dir.y * arrowLength, dir.z * arrowLength)
        ];
        const arrowGeom = new BufferGeometry().setFromPoints(arrowPoints);
        const arrowMat = new LineBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          linewidth: 2,
          depthTest: false
        });
        const arrow = new Line(arrowGeom, arrowMat);
        gizmo.add(arrow);
        const headGeom = new ConeGeometry(5, 15, 6);
        const headMat = new MeshBasicMaterial({
          color: field.type === "gravity" ? 16746496 : 43775,
          depthTest: false
        });
        const head = new Mesh(headGeom, headMat);
        head.position.set(
          dir.x * arrowLength,
          -dir.y * arrowLength,
          dir.z * arrowLength
        );
        head.lookAt(0, 0, 0);
        gizmo.add(head);
        break;
      }
      case "vortex": {
        const spiralPoints = [];
        for (let t = 0; t < Math.PI * 4; t += 0.2) {
          const r = t / (Math.PI * 4) * radius * 0.5;
          spiralPoints.push(new Vector3(
            Math.cos(t) * r,
            Math.sin(t) * r,
            t * 2
          ));
        }
        const spiralGeom = new BufferGeometry().setFromPoints(spiralPoints);
        const spiralMat = new LineBasicMaterial({
          color: 16711935,
          depthTest: false
        });
        const spiral = new Line(spiralGeom, spiralMat);
        gizmo.add(spiral);
        break;
      }
      case "turbulence": {
        const waveMat = new LineBasicMaterial({
          color: 16755200,
          depthTest: false
        });
        for (let i = 0; i < 3; i++) {
          const wavePoints = [];
          for (let t = 0; t < Math.PI * 2; t += 0.3) {
            wavePoints.push(new Vector3(
              t * 10,
              Math.sin(t * 3 + i) * 10,
              (i - 1) * 15
            ));
          }
          const waveGeom = new BufferGeometry().setFromPoints(wavePoints);
          const wave = new Line(waveGeom, waveMat.clone());
          wave.position.x = -30;
          gizmo.add(wave);
        }
        break;
      }
      case "point": {
        const sphereGeom = new SphereGeometry(15, 12, 12);
        const sphereMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.5,
          wireframe: true,
          depthTest: false
        });
        const sphere = new Mesh(sphereGeom, sphereMat);
        gizmo.add(sphere);
        const rangeGeom = new RingGeometry(radius * 0.9, radius, 32);
        const rangeMat = new MeshBasicMaterial({
          color: field.strength > 0 ? 16711680 : 255,
          transparent: true,
          opacity: 0.2,
          side: DoubleSide,
          depthTest: false
        });
        const range = new Mesh(rangeGeom, rangeMat);
        gizmo.add(range);
        break;
      }
      case "drag": {
        const lineMat = new LineBasicMaterial({
          color: 8947848,
          depthTest: false
        });
        for (let i = -2; i <= 2; i++) {
          const linePoints = [
            new Vector3(-20, i * 8, 0),
            new Vector3(20, i * 8, 0)
          ];
          const lineGeom = new BufferGeometry().setFromPoints(linePoints);
          const line = new Line(lineGeom, lineMat.clone());
          gizmo.add(line);
        }
        break;
      }
    }
    const pos = field.position;
    gizmo.position.set(pos.x, -pos.y, pos.z);
    gizmo.visible = this.showForceFieldGizmos;
    gizmo.renderOrder = 996;
    this.forceFieldGizmos.set(field.id, gizmo);
    this.group.add(gizmo);
  }
  /**
   * Update gizmo positions from current config
   */
  updateGizmoPositions() {
    const config = this.particleSystem.getConfig();
    for (const emitter of config.emitters) {
      const gizmo = this.emitterGizmos.get(emitter.id);
      if (gizmo) {
        gizmo.position.set(emitter.position.x, -emitter.position.y, emitter.position.z);
      }
    }
    for (const field of config.forceFields) {
      const gizmo = this.forceFieldGizmos.get(field.id);
      if (gizmo) {
        gizmo.position.set(field.position.x, -field.position.y, field.position.z);
      }
    }
  }
  /**
   * Set emitter gizmo visibility
   */
  setEmitterGizmosVisible(visible) {
    this.showEmitterGizmos = visible;
    for (const gizmo of this.emitterGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Set force field gizmo visibility
   */
  setForceFieldGizmosVisible(visible) {
    this.showForceFieldGizmos = visible;
    for (const gizmo of this.forceFieldGizmos.values()) {
      gizmo.visible = visible;
    }
  }
  /**
   * Dispose all gizmos
   */
  disposeGizmos() {
    for (const gizmo of this.emitterGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.emitterGizmos.clear();
    for (const gizmo of this.forceFieldGizmos.values()) {
      this.group.remove(gizmo);
      gizmo.traverse((child) => {
        if (child instanceof Mesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
        if (child instanceof Line) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
    this.forceFieldGizmos.clear();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}

class NestedCompLayer extends BaseLayer {
  // Nested comp data
  nestedCompData;
  // Render context (provided by LayerManager)
  renderContext = null;
  // Display mesh
  mesh = null;
  material = null;
  // Cached render texture
  renderTexture = null;
  // Animation evaluator for time remap
  nestedCompEvaluator;
  // Cached composition reference
  cachedComposition = null;
  // Parent composition FPS for frame rate conversion
  parentFPS = 30;
  // Flatten transform state
  isCollapsed = false;
  collapsedLayerIds = [];
  constructor(layerData) {
    super(layerData);
    this.nestedCompEvaluator = new KeyframeEvaluator();
    this.nestedCompData = this.extractNestedCompData(layerData);
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract nested comp data with defaults
   */
  extractNestedCompData(layerData) {
    const data = layerData.data;
    return {
      compositionId: data?.compositionId ?? "",
      timeRemapEnabled: data?.timeRemapEnabled ?? false,
      timeRemap: data?.timeRemap,
      flattenTransform: data?.flattenTransform ?? false,
      overrideFrameRate: data?.overrideFrameRate ?? false,
      frameRate: data?.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(1, 1);
    this.material = new MeshBasicMaterial({
      color: 4473924,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `nestedComp_${this.id}`;
    this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for nested comp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(context) {
    this.renderContext = context;
    this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(fps) {
    this.parentFPS = fps;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    if (!this.renderContext || !this.nestedCompData.compositionId) {
      return;
    }
    this.cachedComposition = this.renderContext.getComposition(
      this.nestedCompData.compositionId
    );
    if (this.cachedComposition) {
      this.resizeMesh(
        this.cachedComposition.settings.width,
        this.cachedComposition.settings.height
      );
    }
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(width, height) {
    if (!this.mesh) return;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(parentFrame) {
    if (!this.cachedComposition) return 0;
    if (this.nestedCompData.timeRemapEnabled && this.nestedCompData.timeRemap) {
      const remappedTime = this.nestedCompData.timeRemap.animated ? this.nestedCompEvaluator.evaluate(this.nestedCompData.timeRemap, parentFrame) : this.nestedCompData.timeRemap.value;
      const fps = this.nestedCompData.overrideFrameRate && this.nestedCompData.frameRate ? this.nestedCompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(remappedTime * fps);
    }
    if (this.nestedCompData.overrideFrameRate && this.nestedCompData.frameRate) {
      const parentFps = this.parentFPS;
      const childFps = this.nestedCompData.frameRate;
      return Math.floor(parentFrame * (childFps / parentFps));
    }
    return parentFrame;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (!this.renderContext || !this.cachedComposition) {
      return;
    }
    const nestedFrame = this.calculateNestedFrame(frame);
    const clampedFrame = Math.max(
      0,
      Math.min(nestedFrame, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.nestedCompData.compositionId,
      clampedFrame
    );
    if (this.material) {
      if (this.renderTexture) {
        this.material.map = this.renderTexture;
        this.material.color.setHex(16777215);
      } else {
        this.material.map = null;
        this.material.color.setHex(4473924);
      }
      this.material.needsUpdate = true;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["timeRemap"] !== void 0 && this.nestedCompData.timeRemapEnabled && this.nestedCompData.timeRemap) {
      this.nestedCompData.timeRemap.value = props["timeRemap"];
    }
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(compositionId) {
    this.nestedCompData.compositionId = compositionId;
    this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(enabled) {
    this.nestedCompData.timeRemapEnabled = enabled;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(timeRemap) {
    this.nestedCompData.timeRemap = timeRemap;
  }
  /**
   * Enable/disable flatten transform
   */
  setFlattenTransform(flatten) {
    this.nestedCompData.flattenTransform = flatten;
    this.isCollapsed = flatten;
    if (this.mesh) {
      this.mesh.visible = !flatten;
    }
  }
  /** @deprecated Use setFlattenTransform instead */
  setCollapseTransformations(collapse) {
    this.setFlattenTransform(collapse);
  }
  /**
   * Check if flatten transform is enabled
   */
  isFlattenEnabled() {
    return this.nestedCompData.flattenTransform;
  }
  /** @deprecated Use isFlattenEnabled instead */
  isCollapseEnabled() {
    return this.isFlattenEnabled();
  }
  /**
   * Get the current transform values of this nested comp layer
   * Used when combining transforms for collapsed nested layers
   */
  getParentTransform() {
    return {
      position: {
        x: this.group.position.x,
        y: -this.group.position.y,
        // Convert back to screen coords
        z: this.group.position.z
      },
      rotation: {
        x: MathUtils.radToDeg(this.group.rotation.x),
        y: MathUtils.radToDeg(this.group.rotation.y),
        z: MathUtils.radToDeg(-this.group.rotation.z)
        // Convert back
      },
      scale: {
        x: this.group.scale.x * 100,
        y: this.group.scale.y * 100,
        z: this.group.scale.z * 100
      },
      opacity: this.getOpacity()
    };
  }
  /**
   * Get opacity value (for collapsed layer opacity combination)
   */
  getOpacity() {
    if (this.material) {
      return this.material.opacity * 100;
    }
    return 100;
  }
  /**
   * Combine parent (this nested comp) and nested layer transforms
   * Used when flatten transform is enabled
   *
   * @param nestedTransform - The transform of a nested layer
   * @returns Combined transform for rendering in parent scene
   */
  combineTransforms(nestedTransform) {
    const parent = this.getParentTransform();
    const combinedPosition = {
      x: parent.position.x + nestedTransform.position.x * parent.scale.x / 100,
      y: parent.position.y + nestedTransform.position.y * parent.scale.y / 100,
      z: parent.position.z + nestedTransform.position.z * parent.scale.z / 100
    };
    const combinedRotation = {
      x: parent.rotation.x + nestedTransform.rotation.x,
      y: parent.rotation.y + nestedTransform.rotation.y,
      z: parent.rotation.z + nestedTransform.rotation.z
    };
    const combinedScale = {
      x: parent.scale.x * nestedTransform.scale.x / 100,
      y: parent.scale.y * nestedTransform.scale.y / 100,
      z: parent.scale.z * nestedTransform.scale.z / 100
    };
    const combinedOpacity = parent.opacity / 100 * (nestedTransform.opacity / 100) * 100;
    return {
      position: combinedPosition,
      rotation: combinedRotation,
      scale: combinedScale,
      opacity: combinedOpacity
    };
  }
  /**
   * Get the IDs of layers in the nested composition
   * Used for managing collapsed layers in the parent scene
   */
  getNestedLayerIds() {
    if (!this.cachedComposition) {
      return [];
    }
    return this.cachedComposition.layers.map((l) => l.id);
  }
  /**
   * Check if this nested comp contains 3D layers
   * Flatten transform is most useful when nested comp has 3D layers
   */
  hasNested3DLayers() {
    if (!this.cachedComposition) {
      return false;
    }
    return this.cachedComposition.layers.some((l) => l.threeD);
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(override, fps) {
    this.nestedCompData.overrideFrameRate = override;
    this.nestedCompData.frameRate = fps;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.compositionId !== void 0) {
        this.setComposition(data.compositionId);
      }
      if (data.timeRemapEnabled !== void 0) {
        this.setTimeRemapEnabled(data.timeRemapEnabled);
      }
      if (data.timeRemap !== void 0) {
        this.setTimeRemap(data.timeRemap);
      }
      if (data.flattenTransform !== void 0) {
        this.setFlattenTransform(data.flattenTransform);
      }
      if (data.overrideFrameRate !== void 0 || data.frameRate !== void 0) {
        this.setFrameRateOverride(
          data.overrideFrameRate ?? this.nestedCompData.overrideFrameRate,
          data.frameRate ?? this.nestedCompData.frameRate
        );
      }
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get nested comp data
   */
  getNestedCompData() {
    return { ...this.nestedCompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.nestedCompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.material) {
      this.material.dispose();
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.group.remove(this.mesh);
    }
    this.renderTexture = null;
    this.cachedComposition = null;
  }
}

class CameraLayer extends BaseLayer {
  // Camera data reference
  cameraData;
  // Callbacks to store
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Track current frame for interpolation
  currentFrame = 0;
  // Visual wireframe (shown in editor)
  wireframe = null;
  wireframeVisible = true;
  // Frustum visualization
  frustumHelper = null;
  showFrustum = true;
  // Track last camera state for frustum updates
  lastFrustumState = null;
  // Spline provider for path following
  splineProvider = null;
  // Auto-advance parameter (for autoAdvance mode)
  autoAdvanceT = 0;
  constructor(layerData) {
    super(layerData);
    this.threeD = true;
    this.cameraData = this.extractCameraData(layerData);
    this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(layerData) {
    const data = layerData.data;
    return {
      cameraId: data?.cameraId ?? "",
      isActiveCamera: data?.isActiveCamera ?? false,
      pathFollowing: data?.pathFollowing
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
  }
  /**
   * Set the spline provider for path following
   */
  setSplineProvider(provider) {
    this.splineProvider = provider;
  }
  /**
   * Get path following configuration
   */
  getPathFollowing() {
    return this.cameraData.pathFollowing;
  }
  /**
   * Check if path following is active
   */
  isFollowingPath() {
    return this.cameraData.pathFollowing?.enabled ?? false;
  }
  /**
   * Reset auto-advance parameter (for deterministic scrubbing)
   */
  resetAutoAdvance() {
    this.autoAdvanceT = 0;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Group();
    this.wireframe.name = `camera_wireframe_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const bodySize = 40;
    const bodyGeometry = new BoxGeometry(bodySize, bodySize * 0.6, bodySize * 0.8);
    const bodyMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const body = new Mesh(bodyGeometry, bodyMaterial);
    this.wireframe.add(body);
    const coneGeometry = new ConeGeometry(bodySize * 0.3, bodySize * 0.6, 8);
    const coneMaterial = new MeshBasicMaterial({
      color,
      wireframe: true,
      transparent: true,
      opacity: 0.6,
      depthTest: false
    });
    const cone = new Mesh(coneGeometry, coneMaterial);
    cone.rotation.x = Math.PI / 2;
    cone.position.z = bodySize * 0.7;
    this.wireframe.add(cone);
    const planeGeometry = new PlaneGeometry(bodySize * 0.8, bodySize * 0.5);
    const planeMaterial = new MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.2,
      side: DoubleSide,
      depthTest: false
    });
    const plane = new Mesh(planeGeometry, planeMaterial);
    plane.position.z = -bodySize * 0.4;
    this.wireframe.add(plane);
    const upPoints = [
      new Vector3(0, bodySize * 0.4, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(-bodySize * 0.1, bodySize * 0.55, 0),
      new Vector3(0, bodySize * 0.7, 0),
      new Vector3(bodySize * 0.1, bodySize * 0.55, 0)
    ];
    const upGeometry = new BufferGeometry().setFromPoints(upPoints);
    const upMaterial = new LineBasicMaterial({
      color: 65280,
      transparent: true,
      opacity: 0.8,
      depthTest: false
    });
    const upLine = new Line(upGeometry, upMaterial);
    this.wireframe.add(upLine);
    this.group.add(this.wireframe);
    this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const camera = this.getCamera();
    if (!camera) return;
    this.frustumHelper = new Group();
    this.frustumHelper.name = `camera_frustum_${this.id}`;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    const near = camera.nearClip;
    const far = Math.min(camera.farClip, 2e3);
    const fov = camera.angleOfView * (Math.PI / 180);
    const aspect = 16 / 9;
    const nearHeight = 2 * Math.tan(fov / 2) * near;
    const nearWidth = nearHeight * aspect;
    const farHeight = 2 * Math.tan(fov / 2) * far;
    const farWidth = farHeight * aspect;
    const frustumMaterial = new LineBasicMaterial({
      color,
      transparent: true,
      opacity: 0.3,
      depthTest: false
    });
    const nearTL = new Vector3(-nearWidth / 2, nearHeight / 2, near);
    const nearTR = new Vector3(nearWidth / 2, nearHeight / 2, near);
    const nearBL = new Vector3(-nearWidth / 2, -nearHeight / 2, near);
    const nearBR = new Vector3(nearWidth / 2, -nearHeight / 2, near);
    const farTL = new Vector3(-farWidth / 2, farHeight / 2, far);
    const farTR = new Vector3(farWidth / 2, farHeight / 2, far);
    const farBL = new Vector3(-farWidth / 2, -farHeight / 2, far);
    const farBR = new Vector3(farWidth / 2, -farHeight / 2, far);
    const nearPlane = new BufferGeometry().setFromPoints([
      nearTL,
      nearTR,
      nearBR,
      nearBL,
      nearTL
    ]);
    this.frustumHelper.add(new Line(nearPlane, frustumMaterial));
    const farPlane = new BufferGeometry().setFromPoints([
      farTL,
      farTR,
      farBR,
      farBL,
      farTL
    ]);
    this.frustumHelper.add(new Line(farPlane, frustumMaterial));
    const edges = [
      [nearTL, farTL],
      [nearTR, farTR],
      [nearBL, farBL],
      [nearBR, farBR]
    ];
    for (const [start, end] of edges) {
      const edgeGeom = new BufferGeometry().setFromPoints([start, end]);
      this.frustumHelper.add(new Line(edgeGeom, frustumMaterial));
    }
    this.group.add(this.frustumHelper);
    this.frustumHelper.renderOrder = 997;
    this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const color = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        const material = child.material;
        if (material.color.getHex() === 65280) return;
        material.color.setHex(color);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    if (!this.cameraGetter || !this.cameraData.cameraId) return null;
    return this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    if (!this.cameraData.cameraId) return null;
    if (this.cameraAtFrameGetter) {
      return this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame);
    }
    return this.getCamera();
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(active) {
    this.cameraData.isActiveCamera = active;
    this.updateWireframeColor();
    if (this.frustumHelper) {
      this.group.remove(this.frustumHelper);
      this.disposeFrustum();
      this.createFrustum();
    }
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(visible) {
    this.wireframeVisible = visible;
    if (this.wireframe) {
      this.wireframe.visible = visible;
    }
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(visible) {
    this.showFrustum = visible;
    if (this.frustumHelper) {
      this.frustumHelper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return;
    const degToRad = Math.PI / 180;
    const pathFollowing = this.cameraData.pathFollowing;
    const usePathFollowing = pathFollowing?.enabled && pathFollowing.pathLayerId && this.splineProvider;
    if (usePathFollowing && pathFollowing) {
      this.applyPathFollowing(frame, pathFollowing, camera);
    } else {
      this.group.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
      );
      if (camera.type === "two-node" && camera.pointOfInterest) {
        const poi = new Vector3(
          camera.pointOfInterest.x,
          camera.pointOfInterest.y,
          camera.pointOfInterest.z
        );
        this.group.lookAt(poi);
        this.group.rotation.z += camera.zRotation * degToRad;
      } else {
        this.group.rotation.set(
          (camera.orientation.x + camera.xRotation) * degToRad,
          (camera.orientation.y + camera.yRotation) * degToRad,
          (camera.orientation.z + camera.zRotation) * degToRad,
          "YXZ"
          // Standard 3D rotation order (heading-pitch-roll)
        );
      }
    }
    const currentState = {
      fov: camera.angleOfView,
      near: camera.nearClip,
      far: camera.farClip
    };
    const needsFrustumUpdate = !this.lastFrustumState || this.lastFrustumState.fov !== currentState.fov || this.lastFrustumState.near !== currentState.near || this.lastFrustumState.far !== currentState.far;
    if (needsFrustumUpdate) {
      if (this.frustumHelper) {
        this.group.remove(this.frustumHelper);
        this.disposeFrustum();
      }
      this.createFrustum();
      this.lastFrustumState = currentState;
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pathParameter"] !== void 0 && this.cameraData.pathFollowing?.enabled) {
      this.cameraData.pathFollowing.parameter.value = props["pathParameter"];
    }
  }
  /**
   * Apply path following to camera position and orientation
   * DETERMINISM: Uses interpolateProperty for animated parameter
   */
  applyPathFollowing(frame, pathFollowing, camera) {
    if (!this.splineProvider) return;
    let t;
    if (pathFollowing.autoAdvance) {
      t = frame * pathFollowing.autoAdvanceSpeed % 1;
    } else {
      t = interpolateProperty(pathFollowing.parameter, frame);
    }
    t = Math.max(0, Math.min(1, t));
    const pathResult = this.splineProvider(pathFollowing.pathLayerId, t, frame);
    if (!pathResult) {
      this.group.position.set(camera.position.x, camera.position.y, camera.position.z);
      return;
    }
    let lookTarget = null;
    if (pathFollowing.alignToPath && pathFollowing.lookAhead > 0) {
      const lookAheadT = Math.min(1, t + pathFollowing.lookAhead);
      lookTarget = this.splineProvider(pathFollowing.pathLayerId, lookAheadT, frame);
    }
    const position = new Vector3(
      pathResult.point.x,
      pathResult.point.y + pathFollowing.offsetY,
      pathResult.point.z
    );
    this.group.position.copy(position);
    if (pathFollowing.alignToPath) {
      if (lookTarget) {
        const target = new Vector3(
          lookTarget.point.x,
          lookTarget.point.y + pathFollowing.offsetY,
          lookTarget.point.z
        );
        this.group.lookAt(target);
      } else {
        const tangent = new Vector3(
          pathResult.tangent.x,
          pathResult.tangent.y,
          0
        ).normalize();
        const forward = new Vector3(0, 0, 1);
        const quaternion = new Quaternion();
        quaternion.setFromUnitVectors(forward, tangent);
        this.group.quaternion.copy(quaternion);
      }
      if (pathFollowing.bankingStrength > 0) {
        const epsilon = 0.01;
        const tBefore = Math.max(0, t - epsilon);
        const tAfter = Math.min(1, t + epsilon);
        const before = this.splineProvider(pathFollowing.pathLayerId, tBefore, frame);
        const after = this.splineProvider(pathFollowing.pathLayerId, tAfter, frame);
        if (before && after) {
          const tangent1 = new Vector2(before.tangent.x, before.tangent.y).normalize();
          const tangent2 = new Vector2(after.tangent.x, after.tangent.y).normalize();
          const cross = tangent1.x * tangent2.y - tangent1.y * tangent2.x;
          const bankAngle = cross * pathFollowing.bankingStrength * Math.PI / 4;
          this.group.rotateZ(bankAngle);
        }
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.cameraId !== void 0) {
        this.cameraData.cameraId = data.cameraId;
        if (this.frustumHelper) {
          this.group.remove(this.frustumHelper);
          this.disposeFrustum();
        }
        this.createFrustum();
      }
      if (data.isActiveCamera !== void 0) {
        this.setActiveCamera(data.isActiveCamera);
      }
      if (data.pathFollowing !== void 0) {
        this.cameraData.pathFollowing = data.pathFollowing;
        if (data.pathFollowing?.autoAdvance) {
          this.autoAdvanceT = 0;
        }
      }
    }
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const camera = this.getCameraAtCurrentFrame();
    if (!camera) return null;
    return {
      position: { ...camera.position },
      rotation: {
        x: camera.orientation.x + camera.xRotation,
        y: camera.orientation.y + camera.yRotation,
        z: camera.orientation.z + camera.zRotation
      },
      fov: camera.angleOfView,
      focalLength: camera.focalLength,
      nearClip: camera.nearClip,
      farClip: camera.farClip
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    if (!this.wireframe) return;
    this.wireframe.traverse((child) => {
      if (child instanceof Mesh || child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.wireframe.clear();
    this.wireframe = null;
  }
  disposeFrustum() {
    if (!this.frustumHelper) return;
    this.frustumHelper.traverse((child) => {
      if (child instanceof Line) {
        child.geometry.dispose();
        child.material.dispose();
      }
    });
    this.frustumHelper.clear();
    this.frustumHelper = null;
  }
  onDispose() {
    this.disposeWireframe();
    this.disposeFrustum();
  }
}

let rectAreaLightInitialized = false;
function initRectAreaLight() {
  if (!rectAreaLightInitialized) {
    RectAreaLightUniformsLib.init();
    rectAreaLightInitialized = true;
  }
}
function kelvinToRGB(kelvin) {
  const temp = kelvin / 100;
  let r, g, b;
  if (temp <= 66) {
    r = 255;
  } else {
    r = temp - 60;
    r = 329.698727446 * Math.pow(r, -0.1332047592);
    r = Math.max(0, Math.min(255, r));
  }
  if (temp <= 66) {
    g = temp;
    g = 99.4708025861 * Math.log(g) - 161.1195681661;
  } else {
    g = temp - 60;
    g = 288.1221695283 * Math.pow(g, -0.0755148492);
  }
  g = Math.max(0, Math.min(255, g));
  if (temp >= 66) {
    b = 255;
  } else if (temp <= 19) {
    b = 0;
  } else {
    b = temp - 10;
    b = 138.5177312231 * Math.log(b) - 305.0447927307;
    b = Math.max(0, Math.min(255, b));
  }
  return { r: r / 255, g: g / 255, b: b / 255 };
}
class LightLayer extends BaseLayer {
  light;
  helper = null;
  lightData;
  // Point of Interest
  poiTarget = new Vector3();
  smoothedPOI = new Vector3();
  // Path following callback (set by LayerManager)
  pathProvider = null;
  // Layer position getter for POI layer tracking
  layerPositionGetter = null;
  constructor(layerData) {
    super(layerData);
    this.lightData = this.extractLightData(layerData);
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(0);
    }
    this.initializeBlendMode();
  }
  // ============================================================================
  // DATA EXTRACTION
  // ============================================================================
  extractLightData(layerData) {
    const data = layerData.data;
    return {
      lightType: data?.lightType ?? "point",
      color: data?.color ?? "#ffffff",
      colorTemperature: data?.colorTemperature,
      useColorTemperature: data?.useColorTemperature ?? false,
      intensity: data?.intensity ?? 100,
      physicalIntensity: data?.physicalIntensity,
      usePhysicalIntensity: data?.usePhysicalIntensity ?? false,
      radius: data?.radius ?? 500,
      falloff: data?.falloff ?? "none",
      falloffDistance: data?.falloffDistance ?? 500,
      coneAngle: data?.coneAngle ?? 90,
      coneFeather: data?.coneFeather ?? 50,
      areaWidth: data?.areaWidth ?? 100,
      areaHeight: data?.areaHeight ?? 100,
      pointOfInterest: {
        enabled: data?.pointOfInterest?.enabled ?? false,
        targetType: data?.pointOfInterest?.targetType ?? "position",
        position: data?.pointOfInterest?.position ?? {
          id: "poi_pos",
          name: "POI Position",
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: false,
          keyframes: []
        },
        targetLayerId: data?.pointOfInterest?.targetLayerId,
        offset: data?.pointOfInterest?.offset ?? { x: 0, y: 0, z: 0 },
        smoothing: data?.pointOfInterest?.smoothing ?? 0
      },
      pathFollowing: {
        enabled: data?.pathFollowing?.enabled ?? false,
        splineLayerId: data?.pathFollowing?.splineLayerId,
        progress: data?.pathFollowing?.progress ?? {
          id: "path_progress",
          name: "Path Progress",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        autoOrient: data?.pathFollowing?.autoOrient ?? true,
        bankAngle: data?.pathFollowing?.bankAngle ?? {
          id: "bank_angle",
          name: "Bank Angle",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        }
      },
      shadow: {
        enabled: data?.shadow?.enabled ?? data?.castShadows ?? false,
        type: data?.shadow?.type ?? "pcf",
        mapSize: data?.shadow?.mapSize ?? 1024,
        darkness: data?.shadow?.darkness ?? data?.shadowDarkness ?? 100,
        radius: data?.shadow?.radius ?? data?.shadowDiffusion ?? 1,
        bias: data?.shadow?.bias ?? -1e-4,
        normalBias: data?.shadow?.normalBias ?? 0,
        cameraNear: data?.shadow?.cameraNear ?? 1,
        cameraFar: data?.shadow?.cameraFar ?? 1e3,
        cameraSize: data?.shadow?.cameraSize ?? 500
      },
      lightLinking: {
        mode: data?.lightLinking?.mode ?? "include",
        layers: data?.lightLinking?.layers ?? []
      },
      animatedIntensity: data?.animatedIntensity,
      animatedConeAngle: data?.animatedConeAngle,
      animatedColor: data?.animatedColor,
      animatedColorTemperature: data?.animatedColorTemperature
    };
  }
  // ============================================================================
  // LIGHT CREATION
  // ============================================================================
  createLight() {
    const color = this.getEffectiveColor();
    const intensity = this.getEffectiveIntensity();
    switch (this.lightData.lightType) {
      case "point": {
        const light = new PointLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        this.configureShadows(light);
        return light;
      }
      case "spot": {
        const light = new SpotLight(color, intensity);
        light.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance;
        light.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1;
        light.angle = MathUtils.degToRad((this.lightData.coneAngle ?? 90) / 2);
        light.penumbra = (this.lightData.coneFeather ?? 50) / 100;
        this.configureShadows(light);
        return light;
      }
      case "parallel": {
        const light = new DirectionalLight(color, intensity);
        this.configureShadows(light);
        return light;
      }
      case "ambient": {
        return new AmbientLight(color, intensity);
      }
      case "area": {
        initRectAreaLight();
        const light = new RectAreaLight(
          color,
          intensity,
          this.lightData.areaWidth ?? 100,
          this.lightData.areaHeight ?? 100
        );
        return light;
      }
      default:
        layerLogger.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`);
        return new PointLight(color, intensity);
    }
  }
  getEffectiveColor() {
    if (this.lightData.useColorTemperature && this.lightData.colorTemperature) {
      const rgb = kelvinToRGB(this.lightData.colorTemperature);
      return new Color(rgb.r, rgb.g, rgb.b);
    }
    return new Color(this.lightData.color);
  }
  getEffectiveIntensity() {
    if (this.lightData.usePhysicalIntensity && this.lightData.physicalIntensity) {
      return this.lightData.physicalIntensity / 100;
    }
    return this.lightData.intensity / 100;
  }
  // ============================================================================
  // SHADOW CONFIGURATION
  // ============================================================================
  configureShadows(light) {
    const shadowConfig = this.lightData.shadow;
    light.castShadow = shadowConfig.enabled;
    if (!light.castShadow) return;
    light.shadow.mapSize.width = shadowConfig.mapSize;
    light.shadow.mapSize.height = shadowConfig.mapSize;
    switch (shadowConfig.type) {
      case "basic":
        break;
      case "pcf":
        light.shadow.radius = 1;
        break;
      case "pcfSoft":
        light.shadow.radius = shadowConfig.radius;
        break;
      case "vsm":
        light.shadow.radius = shadowConfig.radius;
        break;
    }
    light.shadow.bias = shadowConfig.bias;
    light.shadow.normalBias = shadowConfig.normalBias;
    if (light instanceof DirectionalLight) {
      const camera = light.shadow.camera;
      camera.near = shadowConfig.cameraNear;
      camera.far = shadowConfig.cameraFar;
      camera.left = -shadowConfig.cameraSize / 2;
      camera.right = shadowConfig.cameraSize / 2;
      camera.top = shadowConfig.cameraSize / 2;
      camera.bottom = -shadowConfig.cameraSize / 2;
      camera.updateProjectionMatrix();
    } else if (light instanceof SpotLight) {
      light.shadow.camera.near = shadowConfig.cameraNear;
      light.shadow.camera.far = shadowConfig.cameraFar;
      light.shadow.camera.updateProjectionMatrix();
    }
  }
  // ============================================================================
  // HELPER VISUALIZATION
  // ============================================================================
  createHelper() {
    if (this.helper) {
      this.group.remove(this.helper);
      if (this.helper.dispose) {
        this.helper.dispose();
      }
    }
    switch (this.lightData.lightType) {
      case "point": {
        const helper = new PointLightHelper(this.light, this.lightData.radius / 10);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "spot": {
        const helper = new SpotLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "parallel": {
        const helper = new DirectionalLightHelper(this.light, 50);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
      case "area": {
        const helper = new RectAreaLightHelper(this.light);
        this.helper = helper;
        this.group.add(helper);
        break;
      }
    }
  }
  // ============================================================================
  // POINT OF INTEREST
  // ============================================================================
  /**
   * Set callback for getting layer positions (for POI layer tracking)
   */
  setLayerPositionGetter(getter) {
    this.layerPositionGetter = getter;
  }
  /**
   * Update point of interest target
   */
  updatePointOfInterest(frame) {
    const poi = this.lightData.pointOfInterest;
    if (!poi.enabled) return;
    if (this.lightData.lightType !== "spot" && this.lightData.lightType !== "parallel") {
      return;
    }
    if (poi.targetType === "layer" && poi.targetLayerId && this.layerPositionGetter) {
      const layerPos = this.layerPositionGetter(poi.targetLayerId);
      if (layerPos) {
        this.poiTarget.copy(layerPos);
        this.poiTarget.x += poi.offset.x;
        this.poiTarget.y += poi.offset.y;
        this.poiTarget.z += poi.offset.z;
      }
    } else {
      const pos = this.evaluator.evaluate(poi.position, frame);
      this.poiTarget.set(pos.x, pos.y, pos.z);
    }
    if (poi.smoothing > 0) {
      this.smoothedPOI.lerp(this.poiTarget, 1 - poi.smoothing);
    } else {
      this.smoothedPOI.copy(this.poiTarget);
    }
    if (this.light instanceof SpotLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    } else if (this.light instanceof DirectionalLight) {
      this.light.target.position.copy(this.smoothedPOI);
      this.light.target.updateMatrixWorld();
    }
  }
  // ============================================================================
  // PATH FOLLOWING
  // ============================================================================
  /**
   * Set path provider callback (from LayerManager's spline provider)
   */
  setPathProvider(provider) {
    this.pathProvider = provider;
  }
  /**
   * Update position and orientation from path
   */
  updatePathFollowing(frame) {
    const path = this.lightData.pathFollowing;
    if (!path.enabled || !path.splineLayerId || !this.pathProvider) return;
    const progress = this.evaluator.evaluate(path.progress, frame);
    const result = this.pathProvider(path.splineLayerId, progress, frame);
    if (!result) return;
    this.group.position.set(result.point.x, -result.point.y, result.point.z);
    if (path.autoOrient) {
      const angle = Math.atan2(result.tangent.y, result.tangent.x);
      this.group.rotation.z = -angle;
      const bankAngle = this.evaluator.evaluate(path.bankAngle, frame);
      this.group.rotation.x = MathUtils.degToRad(bankAngle);
    }
  }
  // ============================================================================
  // PUBLIC SETTERS
  // ============================================================================
  setLightType(type) {
    if (type === this.lightData.lightType) return;
    this.lightData.lightType = type;
    this.group.remove(this.light);
    if (this.light.dispose) {
      this.light.dispose();
    }
    this.light = this.createLight();
    this.group.add(this.light);
    this.createHelper();
  }
  setColor(color) {
    this.lightData.color = color;
    this.lightData.useColorTemperature = false;
    this.light.color.set(color);
  }
  setColorTemperature(kelvin) {
    this.lightData.colorTemperature = kelvin;
    this.lightData.useColorTemperature = true;
    const rgb = kelvinToRGB(kelvin);
    this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
  }
  setIntensity(intensity) {
    this.lightData.intensity = intensity;
    this.lightData.usePhysicalIntensity = false;
    this.light.intensity = intensity / 100;
  }
  setFalloffDistance(distance) {
    this.lightData.falloffDistance = distance;
    if (this.light instanceof PointLight || this.light instanceof SpotLight) {
      this.light.distance = this.lightData.falloff === "none" ? 0 : distance;
    }
  }
  setConeAngle(angle) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneAngle = angle;
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
  }
  setConeFeather(feather) {
    if (this.light instanceof SpotLight) {
      this.lightData.coneFeather = feather;
      this.light.penumbra = feather / 100;
    }
  }
  setAreaSize(width, height) {
    if (this.light instanceof RectAreaLight) {
      this.lightData.areaWidth = width;
      this.lightData.areaHeight = height;
      this.light.width = width;
      this.light.height = height;
    }
  }
  setShadowEnabled(enabled) {
    this.lightData.shadow.enabled = enabled;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.light.castShadow = enabled;
    }
  }
  setShadowType(type) {
    this.lightData.shadow.type = type;
    if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
      this.configureShadows(this.light);
    }
  }
  setPointOfInterestEnabled(enabled) {
    this.lightData.pointOfInterest.enabled = enabled;
  }
  setPointOfInterestTarget(layerId) {
    if (layerId) {
      this.lightData.pointOfInterest.targetType = "layer";
      this.lightData.pointOfInterest.targetLayerId = layerId;
    } else {
      this.lightData.pointOfInterest.targetType = "position";
      this.lightData.pointOfInterest.targetLayerId = void 0;
    }
  }
  setPathFollowingEnabled(enabled) {
    this.lightData.pathFollowing.enabled = enabled;
  }
  setPathSpline(splineLayerId) {
    this.lightData.pathFollowing.splineLayerId = splineLayerId ?? void 0;
  }
  // ============================================================================
  // DRIVER PROPERTY ACCESS
  // ============================================================================
  /**
   * Get a light property value by driver property path
   * Used by PropertyDriverSystem for property-to-property linking
   */
  getDriverPropertyValue(path) {
    switch (path) {
      case "light.intensity":
        return this.lightData.intensity;
      case "light.color.r":
        return this.light.color.r * 255;
      case "light.color.g":
        return this.light.color.g * 255;
      case "light.color.b":
        return this.light.color.b * 255;
      case "light.colorTemperature":
        return this.lightData.colorTemperature ?? 6500;
      case "light.coneAngle":
        return this.lightData.coneAngle ?? 90;
      case "light.penumbra":
        return this.lightData.coneFeather ?? 50;
      case "light.falloff":
        return this.lightData.falloffDistance;
      case "light.shadow.intensity":
        return this.lightData.shadow.darkness;
      case "light.shadow.softness":
        return this.lightData.shadow.radius;
      case "light.shadow.bias":
        return this.lightData.shadow.bias * 1e4;
      case "light.poi.x":
        return this.poiTarget.x;
      case "light.poi.y":
        return this.poiTarget.y;
      case "light.poi.z":
        return this.poiTarget.z;
      case "light.areaSize.width":
        return this.lightData.areaWidth ?? 100;
      case "light.areaSize.height":
        return this.lightData.areaHeight ?? 100;
      case "light.physicalIntensity":
        return this.lightData.physicalIntensity ?? this.lightData.intensity * 100;
      default:
        return null;
    }
  }
  /**
   * Set a light property value by driver property path
   * Used by PropertyDriverSystem for driven values
   */
  setDriverPropertyValue(path, value) {
    switch (path) {
      case "light.intensity":
        this.light.intensity = value / 100;
        this.lightData.intensity = value;
        break;
      case "light.color.r":
        this.light.color.r = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.g":
        this.light.color.g = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.color.b":
        this.light.color.b = Math.max(0, Math.min(1, value / 255));
        break;
      case "light.colorTemperature":
        this.setColorTemperature(value);
        break;
      case "light.coneAngle":
        this.setConeAngle(value);
        break;
      case "light.penumbra":
        this.setConeFeather(value);
        break;
      case "light.falloff":
        this.setFalloffDistance(value);
        break;
      case "light.shadow.intensity":
        this.lightData.shadow.darkness = value;
        break;
      case "light.shadow.softness":
        this.lightData.shadow.radius = value;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.radius = value;
        }
        break;
      case "light.shadow.bias":
        this.lightData.shadow.bias = value / 1e4;
        if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
          this.light.shadow.bias = value / 1e4;
        }
        break;
      case "light.poi.x":
        this.poiTarget.x = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.y":
        this.poiTarget.y = value;
        this.updatePointOfInterest(0);
        break;
      case "light.poi.z":
        this.poiTarget.z = value;
        this.updatePointOfInterest(0);
        break;
      case "light.areaSize.width":
        this.setAreaSize(value, this.lightData.areaHeight ?? 100);
        break;
      case "light.areaSize.height":
        this.setAreaSize(this.lightData.areaWidth ?? 100, value);
        break;
      case "light.physicalIntensity":
        this.lightData.physicalIntensity = value;
        if (this.lightData.usePhysicalIntensity) {
          this.light.intensity = value / 100;
        }
        break;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getLight() {
    return this.light;
  }
  getLightData() {
    return { ...this.lightData };
  }
  getLightLinking() {
    return { ...this.lightData.lightLinking };
  }
  /**
   * Check if this light should affect a given layer
   */
  shouldAffectLayer(layerId) {
    const linking = this.lightData.lightLinking;
    if (linking.layers.length === 0) {
      return true;
    }
    const isInList = linking.layers.includes(layerId);
    if (linking.mode === "include") {
      return isInList;
    } else {
      return !isInList;
    }
  }
  setHelperVisible(visible) {
    if (this.helper) {
      this.helper.visible = visible;
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    if (this.lightData.pathFollowing.enabled) {
      this.updatePathFollowing(frame);
    }
    if (this.lightData.pointOfInterest.enabled) {
      this.updatePointOfInterest(frame);
    }
    if (this.lightData.animatedIntensity?.animated) {
      const intensity = this.evaluator.evaluate(this.lightData.animatedIntensity, frame);
      this.light.intensity = intensity / 100;
    }
    if (this.lightData.animatedConeAngle?.animated && this.light instanceof SpotLight) {
      const angle = this.evaluator.evaluate(this.lightData.animatedConeAngle, frame);
      this.light.angle = MathUtils.degToRad(angle / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (this.lightData.animatedColor?.animated) {
      const color = this.evaluator.evaluate(this.lightData.animatedColor, frame);
      this.light.color.set(color);
    }
    if (this.lightData.animatedColorTemperature?.animated && this.lightData.useColorTemperature) {
      const kelvin = this.evaluator.evaluate(this.lightData.animatedColorTemperature, frame);
      const rgb = kelvinToRGB(kelvin);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (this.helper) {
      if (this.helper instanceof PointLightHelper || this.helper instanceof SpotLightHelper || this.helper instanceof DirectionalLightHelper) {
        this.helper.update();
      }
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["intensity"] !== void 0) {
      this.light.intensity = props["intensity"] / 100;
    }
    if (props["coneAngle"] !== void 0 && this.light instanceof SpotLight) {
      this.light.angle = MathUtils.degToRad(props["coneAngle"] / 2);
      if (this.helper instanceof SpotLightHelper) {
        this.helper.update();
      }
    }
    if (props["color"] !== void 0) {
      this.light.color.set(props["color"]);
    }
    if (props["colorTemperature"] !== void 0 && this.lightData.useColorTemperature) {
      const rgb = kelvinToRGB(props["colorTemperature"]);
      this.light.color.setRGB(rgb.r, rgb.g, rgb.b);
    }
    if (props["falloffDistance"] !== void 0) {
      if (this.light instanceof PointLight || this.light instanceof SpotLight) {
        this.light.distance = this.lightData.falloff === "none" ? 0 : props["falloffDistance"];
      }
    }
    if (props["poi.x"] !== void 0 || props["poi.y"] !== void 0 || props["poi.z"] !== void 0) {
      this.poiTarget.set(
        props["poi.x"] ?? this.poiTarget.x,
        props["poi.y"] ?? this.poiTarget.y,
        props["poi.z"] ?? this.poiTarget.z
      );
      this.updatePointOfInterest(0);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.lightType !== void 0 && data.lightType !== this.lightData.lightType) {
      this.setLightType(data.lightType);
    }
    if (data.color !== void 0) {
      this.setColor(data.color);
    }
    if (data.colorTemperature !== void 0) {
      this.setColorTemperature(data.colorTemperature);
    }
    if (data.intensity !== void 0) {
      this.setIntensity(data.intensity);
    }
    if (data.falloffDistance !== void 0) {
      this.setFalloffDistance(data.falloffDistance);
    }
    if (data.falloff !== void 0) {
      this.lightData.falloff = data.falloff;
      this.setFalloffDistance(this.lightData.falloffDistance);
    }
    if (data.coneAngle !== void 0) {
      this.setConeAngle(data.coneAngle);
    }
    if (data.coneFeather !== void 0) {
      this.setConeFeather(data.coneFeather);
    }
    if (data.areaWidth !== void 0 || data.areaHeight !== void 0) {
      this.setAreaSize(
        data.areaWidth ?? this.lightData.areaWidth ?? 100,
        data.areaHeight ?? this.lightData.areaHeight ?? 100
      );
    }
    if (data.shadow !== void 0) {
      Object.assign(this.lightData.shadow, data.shadow);
      if (this.light instanceof PointLight || this.light instanceof SpotLight || this.light instanceof DirectionalLight) {
        this.configureShadows(this.light);
      }
    }
    if (data.pointOfInterest !== void 0) {
      Object.assign(this.lightData.pointOfInterest, data.pointOfInterest);
    }
    if (data.pathFollowing !== void 0) {
      Object.assign(this.lightData.pathFollowing, data.pathFollowing);
    }
    if (data.lightLinking !== void 0) {
      Object.assign(this.lightData.lightLinking, data.lightLinking);
    }
    if (data.animatedIntensity !== void 0) {
      this.lightData.animatedIntensity = data.animatedIntensity;
    }
    if (data.animatedConeAngle !== void 0) {
      this.lightData.animatedConeAngle = data.animatedConeAngle;
    }
    if (data.animatedColor !== void 0) {
      this.lightData.animatedColor = data.animatedColor;
    }
    if (data.animatedColorTemperature !== void 0) {
      this.lightData.animatedColorTemperature = data.animatedColorTemperature;
    }
  }
  onDispose() {
    if (this.light.dispose) {
      this.light.dispose();
    }
    if (this.helper && this.helper.dispose) {
      this.helper.dispose();
    }
  }
}

const depthflowVertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const depthflowFragmentShader = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class DepthflowLayer extends BaseLayer {
  resources;
  // Textures
  sourceTexture = null;
  depthTexture = null;
  // Mesh and material
  mesh;
  geometry;
  material;
  // Layer data
  depthflowData;
  // Dimensions
  width = 1920;
  height = 1080;
  // Animation state
  animationTime = 0;
  constructor(layerData, resources) {
    super(layerData);
    this.resources = resources;
    this.depthflowData = this.extractDepthflowData(layerData);
    this.geometry = new PlaneGeometry(this.width, this.height);
    this.material = new ShaderMaterial({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new Vector2(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: depthflowVertexShader,
      fragmentShader: depthflowFragmentShader,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    });
    this.mesh = new Mesh(this.geometry, this.material);
    this.mesh.name = `depthflow_${this.id}`;
    this.group.add(this.mesh);
    this.loadTextures();
    this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(layerData) {
    const data = layerData.data;
    return {
      sourceLayerId: data?.sourceLayerId ?? "",
      depthLayerId: data?.depthLayerId ?? "",
      config: {
        preset: data?.config?.preset ?? "static",
        zoom: data?.config?.zoom ?? 1,
        offsetX: data?.config?.offsetX ?? 0,
        offsetY: data?.config?.offsetY ?? 0,
        rotation: data?.config?.rotation ?? 0,
        depthScale: data?.config?.depthScale ?? 0.1,
        focusDepth: data?.config?.focusDepth ?? 0.5,
        dollyZoom: data?.config?.dollyZoom ?? 0,
        orbitRadius: data?.config?.orbitRadius ?? 0.1,
        orbitSpeed: data?.config?.orbitSpeed ?? 1,
        swingAmplitude: data?.config?.swingAmplitude ?? 0.05,
        swingFrequency: data?.config?.swingFrequency ?? 1,
        edgeDilation: data?.config?.edgeDilation ?? 0,
        inpaintEdges: data?.config?.inpaintEdges ?? false
      },
      animatedZoom: data?.animatedZoom,
      animatedOffsetX: data?.animatedOffsetX,
      animatedOffsetY: data?.animatedOffsetY,
      animatedRotation: data?.animatedRotation,
      animatedDepthScale: data?.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const sourceTexture = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      if (sourceTexture) {
        this.sourceTexture = sourceTexture;
        this.material.uniforms.sourceTexture.value = sourceTexture;
        if (sourceTexture.image) {
          this.setDimensions(sourceTexture.image.width, sourceTexture.image.height);
        }
      }
    }
    if (this.depthflowData.depthLayerId) {
      const depthTexture = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      if (depthTexture) {
        this.depthTexture = depthTexture;
        this.material.uniforms.depthTexture.value = depthTexture;
      }
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(layerId) {
    const texture = this.resources.getLayerTexture(layerId);
    if (texture) return texture;
    layerLogger.warn(`DepthflowLayer: Could not load texture for layer ${layerId}`);
    return null;
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(width, height) {
    if (width === this.width && height === this.height) return;
    this.width = width;
    this.height = height;
    this.geometry.dispose();
    this.geometry = new PlaneGeometry(width, height);
    this.mesh.geometry = this.geometry;
  }
  /**
   * Set source layer
   */
  async setSourceLayer(layerId) {
    this.depthflowData.sourceLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.sourceTexture?.dispose();
      this.sourceTexture = texture;
      this.material.uniforms.sourceTexture.value = texture;
    }
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(layerId) {
    this.depthflowData.depthLayerId = layerId;
    const texture = await this.loadTextureFromLayer(layerId);
    if (texture) {
      this.depthTexture?.dispose();
      this.depthTexture = texture;
      this.material.uniforms.depthTexture.value = texture;
    }
  }
  /**
   * Update config values
   */
  updateConfig(config) {
    Object.assign(this.depthflowData.config, config);
    if (config.depthScale !== void 0) {
      this.material.uniforms.depthScale.value = config.depthScale;
    }
    if (config.focusDepth !== void 0) {
      this.material.uniforms.focusDepth.value = config.focusDepth;
    }
    if (config.zoom !== void 0) {
      this.material.uniforms.zoom.value = config.zoom;
    }
    if (config.rotation !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(config.rotation);
    }
    if (config.edgeDilation !== void 0) {
      this.material.uniforms.edgeDilation.value = config.edgeDilation;
    }
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(frame, fps = 30) {
    const config = this.depthflowData.config;
    const duration = this.outPoint - this.inPoint;
    const progress = duration > 0 ? (frame - this.inPoint) / duration : 0;
    const time = frame / fps;
    let zoom = config.zoom;
    let offsetX = config.offsetX;
    let offsetY = config.offsetY;
    let rotation = config.rotation;
    switch (config.preset) {
      case "static":
        break;
      case "zoom_in":
        zoom = 1 + progress * 0.5;
        break;
      case "zoom_out":
        zoom = 1.5 - progress * 0.5;
        break;
      case "dolly_zoom_in":
        zoom = 1 + progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * progress);
        break;
      case "dolly_zoom_out":
        zoom = 1.5 - progress * 0.5;
        this.material.uniforms.depthScale.value = config.depthScale * (1 + config.dollyZoom * (1 - progress));
        break;
      case "pan_left":
        offsetX = progress * 0.2;
        break;
      case "pan_right":
        offsetX = -progress * 0.2;
        break;
      case "pan_up":
        offsetY = progress * 0.2;
        break;
      case "pan_down":
        offsetY = -progress * 0.2;
        break;
      case "circle_cw":
        offsetX = Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "circle_ccw":
        offsetX = -Math.sin(progress * Math.PI * 2) * config.orbitRadius;
        offsetY = Math.cos(progress * Math.PI * 2) * config.orbitRadius;
        break;
      case "horizontal_swing":
        offsetX = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
      case "vertical_swing":
        offsetY = Math.sin(time * config.swingFrequency * Math.PI * 2) * config.swingAmplitude;
        break;
    }
    return { zoom, offsetX, offsetY, rotation };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const presetValues = this.calculatePresetValues(frame);
    let zoom = presetValues.zoom;
    let offsetX = presetValues.offsetX;
    let offsetY = presetValues.offsetY;
    let rotation = presetValues.rotation;
    if (this.depthflowData.animatedZoom) {
      zoom = this.evaluator.evaluate(this.depthflowData.animatedZoom, frame);
    }
    if (this.depthflowData.animatedOffsetX) {
      offsetX = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, frame);
    }
    if (this.depthflowData.animatedOffsetY) {
      offsetY = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, frame);
    }
    if (this.depthflowData.animatedRotation) {
      rotation = this.evaluator.evaluate(this.depthflowData.animatedRotation, frame);
    }
    if (this.depthflowData.animatedDepthScale) {
      this.material.uniforms.depthScale.value = this.evaluator.evaluate(
        this.depthflowData.animatedDepthScale,
        frame
      );
    }
    zoom = this.getDrivenOrBase("depthflow.zoom", zoom);
    offsetX = this.getDrivenOrBase("depthflow.offsetX", offsetX);
    offsetY = this.getDrivenOrBase("depthflow.offsetY", offsetY);
    rotation = this.getDrivenOrBase("depthflow.rotation", rotation);
    this.material.uniforms.zoom.value = zoom;
    this.material.uniforms.offset.value.set(offsetX, offsetY);
    this.material.uniforms.rotation.value = MathUtils.degToRad(rotation);
    this.material.uniforms.time.value = frame / 30;
    this.material.needsUpdate = true;
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["zoom"] !== void 0) {
      this.material.uniforms.zoom.value = props["zoom"];
    }
    if (props["offsetX"] !== void 0 || props["offsetY"] !== void 0) {
      const offsetX = props["offsetX"] ?? this.material.uniforms.offset.value.x;
      const offsetY = props["offsetY"] ?? this.material.uniforms.offset.value.y;
      this.material.uniforms.offset.value.set(offsetX, offsetY);
    }
    if (props["rotation"] !== void 0) {
      this.material.uniforms.rotation.value = MathUtils.degToRad(props["rotation"]);
    }
    if (props["depthScale"] !== void 0) {
      this.material.uniforms.depthScale.value = props["depthScale"];
    }
    this.material.needsUpdate = true;
  }
  onUpdate(properties) {
    const data = properties.data;
    if (!data) return;
    if (data.sourceLayerId !== void 0 && data.sourceLayerId !== this.depthflowData.sourceLayerId) {
      this.setSourceLayer(data.sourceLayerId);
    }
    if (data.depthLayerId !== void 0 && data.depthLayerId !== this.depthflowData.depthLayerId) {
      this.setDepthLayer(data.depthLayerId);
    }
    if (data.config) {
      this.updateConfig(data.config);
    }
    if (data.animatedZoom !== void 0) {
      this.depthflowData.animatedZoom = data.animatedZoom;
    }
    if (data.animatedOffsetX !== void 0) {
      this.depthflowData.animatedOffsetX = data.animatedOffsetX;
    }
    if (data.animatedOffsetY !== void 0) {
      this.depthflowData.animatedOffsetY = data.animatedOffsetY;
    }
    if (data.animatedRotation !== void 0) {
      this.depthflowData.animatedRotation = data.animatedRotation;
    }
    if (data.animatedDepthScale !== void 0) {
      this.depthflowData.animatedDepthScale = data.animatedDepthScale;
    }
  }
  onDispose() {
    this.sourceTexture?.dispose();
    this.depthTexture?.dispose();
    this.geometry.dispose();
    this.material.dispose();
  }
}

class ProceduralMatteLayer extends BaseLayer {
  // Matte data
  matteData;
  // Display mesh
  mesh = null;
  material = null;
  texture = null;
  // Rendering canvas (grayscale output)
  renderCanvas;
  renderCtx;
  // Animation evaluator
  matteEvaluator;
  // Dimensions
  width = 512;
  height = 512;
  // Noise seed for deterministic noise
  noiseSeed;
  constructor(layerData) {
    super(layerData);
    this.matteEvaluator = new KeyframeEvaluator();
    this.matteData = this.extractMatteData(layerData);
    this.noiseSeed = this.matteData.parameters.seed ?? Math.random() * 65536;
    this.renderCanvas = document.createElement("canvas");
    this.renderCanvas.width = this.width;
    this.renderCanvas.height = this.height;
    this.renderCtx = this.renderCanvas.getContext("2d");
    this.createMesh();
    this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract matte data with defaults
   */
  extractMatteData(layerData) {
    const data = layerData.data;
    if (!data) {
      return {
        patternType: "linear_gradient",
        parameters: {},
        animation: {
          enabled: false,
          speed: { id: "speed", name: "Speed", type: "number", value: 1, animated: false, keyframes: [] },
          phase: { id: "phase", name: "Phase", type: "number", value: 0, animated: false, keyframes: [] },
          direction: { id: "dir", name: "Direction", type: "number", value: 0, animated: false, keyframes: [] }
        },
        inverted: false,
        levels: {
          inputBlack: { id: "ib", name: "Input Black", type: "number", value: 0, animated: false, keyframes: [] },
          inputWhite: { id: "iw", name: "Input White", type: "number", value: 255, animated: false, keyframes: [] },
          gamma: { id: "g", name: "Gamma", type: "number", value: 1, animated: false, keyframes: [] },
          outputBlack: { id: "ob", name: "Output Black", type: "number", value: 0, animated: false, keyframes: [] },
          outputWhite: { id: "ow", name: "Output White", type: "number", value: 255, animated: false, keyframes: [] }
        }
      };
    }
    return data;
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const geometry = new PlaneGeometry(this.width, this.height);
    this.texture = new CanvasTexture(this.renderCanvas);
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    this.material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, this.material);
    this.mesh.name = `matte_${this.id}`;
    this.group.add(this.mesh);
  }
  /**
   * Set dimensions
   */
  setDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.renderCanvas.width = width;
    this.renderCanvas.height = height;
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh.geometry = new PlaneGeometry(width, height);
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(frame) {
    this.renderPattern(frame);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  onUpdate(properties) {
    if (properties.data) {
      this.matteData = this.extractMatteData({ ...properties, data: properties.data });
    }
  }
  // ============================================================================
  // PATTERN RENDERING
  // ============================================================================
  /**
   * Render the pattern to the canvas
   */
  renderPattern(frame) {
    const ctx = this.renderCtx;
    const w = this.width;
    const h = this.height;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, w, h);
    const speed = this.matteEvaluator.evaluate(this.matteData.animation.speed, frame);
    const phase = this.matteEvaluator.evaluate(this.matteData.animation.phase, frame);
    const time = this.matteData.animation.enabled ? frame * speed / 60 + phase : 0;
    switch (this.matteData.patternType) {
      case "linear_gradient":
        this.renderLinearGradient(ctx, w, h, frame, time);
        break;
      case "radial_gradient":
        this.renderRadialGradient(ctx, w, h, frame, time);
        break;
      case "angular_gradient":
        this.renderAngularGradient(ctx, w, h, frame, time);
        break;
      case "ramp":
        this.renderRamp(ctx, w, h, frame, time);
        break;
      case "noise":
        this.renderNoise(ctx, w, h, frame, time);
        break;
      case "checkerboard":
        this.renderCheckerboard(ctx, w, h, frame, time);
        break;
      case "circle":
        this.renderCircle(ctx, w, h, frame, time);
        break;
      case "rectangle":
        this.renderRectangle(ctx, w, h, frame, time);
        break;
      case "iris":
        this.renderIris(ctx, w, h, frame, time);
        break;
      case "radial_wipe":
        this.renderRadialWipe(ctx, w, h, frame, time);
        break;
      case "venetian_blinds":
        this.renderVenetianBlinds(ctx, w, h, frame, time);
        break;
      case "dissolve":
        this.renderDissolve(ctx, w, h, frame, time);
        break;
      case "wave":
        this.renderWave(ctx, w, h, frame, time);
        break;
      default:
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, w, h);
    }
    this.applyLevels(frame);
    if (this.matteData.inverted) {
      this.invertCanvas();
    }
  }
  // ============================================================================
  // PATTERN IMPLEMENTATIONS
  // ============================================================================
  renderLinearGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const angle = this.matteEvaluator.evaluate(params.angle, frame) + time * 360;
    const blend = this.matteEvaluator.evaluate(params.blend, frame);
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const blendHalf = Math.max(1e-3, blend / 2);
    gradient.addColorStop(Math.max(0, 0.5 - blendHalf), "black");
    gradient.addColorStop(Math.min(1, 0.5 + blendHalf), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = this.matteEvaluator.evaluate(params.centerX, frame);
    const centerY = this.matteEvaluator.evaluate(params.centerY, frame);
    const radius = this.matteEvaluator.evaluate(params.radius, frame) + time * 0.5;
    const blend = params.blend ? this.matteEvaluator.evaluate(params.blend, frame) : 0.3;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = radius * Math.max(w, h) / 2;
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    gradient.addColorStop(Math.max(0, 1 - blend), "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderAngularGradient(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rotation = (params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0) + time * 360;
    const cx = centerX * w;
    const cy = centerY * h;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI + rotation;
        angle = (angle % 360 + 360) % 360;
        const value = Math.round(angle / 360 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderRamp(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = this.matteEvaluator.evaluate(params.progress, frame);
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.1;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const len = Math.max(w, h) * 1.5;
    const cx = w / 2;
    const cy = h / 2;
    const x1 = cx - cos * len / 2;
    const y1 = cy - sin * len / 2;
    const x2 = cx + cos * len / 2;
    const y2 = cy + sin * len / 2;
    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
    const soft = Math.max(1e-3, softness / 2);
    gradient.addColorStop(Math.max(0, animProgress - soft), "black");
    gradient.addColorStop(Math.min(1, animProgress + soft), "white");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderNoise(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const scale = params.scale ? this.matteEvaluator.evaluate(params.scale, frame) : 50;
    const octaves = params.octaves ?? 4;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const timeOffset = time * 10;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let noise = 0;
        let amp = 1;
        let freq = 1 / scale;
        for (let o = 0; o < octaves; o++) {
          noise += this.perlinNoise(x * freq + timeOffset, y * freq) * amp;
          amp *= 0.5;
          freq *= 2;
        }
        const value = Math.round((noise + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderCheckerboard(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const tilesX = params.tilesX ? this.matteEvaluator.evaluate(params.tilesX, frame) : 8;
    const tilesY = params.tilesY ? this.matteEvaluator.evaluate(params.tilesY, frame) : 8;
    const rotation = params.rotation ? this.matteEvaluator.evaluate(params.rotation, frame) : 0;
    const tileW = w / tilesX;
    const tileH = h / tilesY;
    const offset = time * tileW;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.translate(-w / 2 - offset, -h / 2);
    for (let y = -1; y <= tilesY + 1; y++) {
      for (let x = -1; x <= tilesX + 1; x++) {
        const isWhite = (x + y) % 2 === 0;
        ctx.fillStyle = isWhite ? "white" : "black";
        ctx.fillRect(x * tileW, y * tileH, tileW, tileH);
      }
    }
    ctx.restore();
  }
  renderCircle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const radius = params.radius ? this.matteEvaluator.evaluate(params.radius, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const r = (radius + time * 0.5) * Math.min(w, h) / 2;
    if (feather > 0) {
      const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 50), cx, cy, r);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, "black");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  renderRectangle(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const rectWidth = params.width ? this.matteEvaluator.evaluate(params.width, frame) : 0.5;
    const rectHeight = params.height ? this.matteEvaluator.evaluate(params.height, frame) : 0.5;
    const cornerRadius = params.cornerRadius ? this.matteEvaluator.evaluate(params.cornerRadius, frame) : 0;
    const cx = centerX * w;
    const cy = centerY * h;
    const rw = (rectWidth + time * 0.2) * w;
    const rh = (rectHeight + time * 0.2) * h;
    const cr = cornerRadius * Math.min(rw, rh) / 2;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.roundRect(cx - rw / 2, cy - rh / 2, rw, rh, cr);
    ctx.fill();
  }
  renderIris(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const feather = params.feather ? this.matteEvaluator.evaluate(params.feather, frame) : 0.1;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const maxRadius = Math.sqrt(w * w + h * h) / 2;
    const r = animProgress * maxRadius;
    const gradient = ctx.createRadialGradient(cx, cy, Math.max(0, r - feather * 100), cx, cy, r);
    gradient.addColorStop(0, "white");
    gradient.addColorStop(1, "black");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }
  renderRadialWipe(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const centerX = params.centerX ? this.matteEvaluator.evaluate(params.centerX, frame) : 0.5;
    const centerY = params.centerY ? this.matteEvaluator.evaluate(params.centerY, frame) : 0.5;
    const softness = params.softness ? this.matteEvaluator.evaluate(params.softness, frame) : 0.05;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const cx = centerX * w;
    const cy = centerY * h;
    const angle = animProgress * Math.PI * 2;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const dx = x - cx;
        const dy = y - cy;
        let pixelAngle = Math.atan2(dy, dx) + Math.PI;
        const diff = pixelAngle - angle;
        const dist = Math.abs((diff + Math.PI * 3) % (Math.PI * 2) - Math.PI) / Math.PI;
        let value = dist < 0.5 ? 255 : 0;
        if (softness > 0) {
          const soft = softness * Math.PI;
          if (Math.abs(dist - 0.5) < soft) {
            value = Math.round(255 * (1 - (dist - 0.5 + soft) / (soft * 2)));
          }
        }
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderVenetianBlinds(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const slats = params.slats ? this.matteEvaluator.evaluate(params.slats, frame) : 10;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const slatHeight = h / slats;
    const openAmount = animProgress * slatHeight;
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle * Math.PI / 180);
    ctx.translate(-w / 2, -h / 2);
    for (let i = 0; i < slats; i++) {
      ctx.fillStyle = "white";
      ctx.fillRect(0, i * slatHeight, w, openAmount);
    }
    ctx.restore();
  }
  renderDissolve(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const progress = params.progress ? this.matteEvaluator.evaluate(params.progress, frame) : 0.5;
    const blockSize = params.blockSize ? this.matteEvaluator.evaluate(params.blockSize, frame) : 4;
    const animProgress = this.matteData.animation.enabled ? (progress + time) % 1 : progress;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const blocksX = Math.ceil(w / blockSize);
    const blocksY = Math.ceil(h / blockSize);
    for (let by = 0; by < blocksY; by++) {
      for (let bx = 0; bx < blocksX; bx++) {
        const random = this.hash(bx + by * blocksX + this.noiseSeed);
        const isVisible = random < animProgress;
        const value = isVisible ? 255 : 0;
        for (let dy = 0; dy < blockSize && by * blockSize + dy < h; dy++) {
          for (let dx = 0; dx < blockSize && bx * blockSize + dx < w; dx++) {
            const x = bx * blockSize + dx;
            const y = by * blockSize + dy;
            const idx = (y * w + x) * 4;
            data[idx] = data[idx + 1] = data[idx + 2] = value;
            data[idx + 3] = 255;
          }
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  renderWave(ctx, w, h, frame, time) {
    const params = this.matteData.parameters;
    const frequency = params.frequency ? this.matteEvaluator.evaluate(params.frequency, frame) : 4;
    const amplitude = params.amplitude ? this.matteEvaluator.evaluate(params.amplitude, frame) : 0.5;
    const angle = params.angle ? this.matteEvaluator.evaluate(params.angle, frame) : 0;
    const waveType = params.waveType ?? "sine";
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const rad = angle * Math.PI / 180;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const rx = (x - w / 2) * Math.cos(rad) - (y - h / 2) * Math.sin(rad);
        const phase = (rx / w * frequency + time) * Math.PI * 2;
        let wave;
        switch (waveType) {
          case "triangle":
            wave = Math.abs(phase / Math.PI % 2 - 1) * 2 - 1;
            break;
          case "square":
            wave = Math.sin(phase) >= 0 ? 1 : -1;
            break;
          case "sawtooth":
            wave = phase / Math.PI % 2 - 1;
            break;
          default:
            wave = Math.sin(phase);
        }
        const value = Math.round((wave * amplitude + 1) / 2 * 255);
        const idx = (y * w + x) * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = value;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  /**
   * Apply levels adjustment
   */
  applyLevels(frame) {
    const levels = this.matteData.levels;
    const inputBlack = this.matteEvaluator.evaluate(levels.inputBlack, frame);
    const inputWhite = this.matteEvaluator.evaluate(levels.inputWhite, frame);
    const gamma = this.matteEvaluator.evaluate(levels.gamma, frame);
    const outputBlack = this.matteEvaluator.evaluate(levels.outputBlack, frame);
    const outputWhite = this.matteEvaluator.evaluate(levels.outputWhite, frame);
    if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
      return;
    }
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    const inputRange = inputWhite - inputBlack;
    const outputRange = outputWhite - outputBlack;
    for (let i = 0; i < data.length; i += 4) {
      let value = data[i];
      value = Math.max(0, Math.min(255, (value - inputBlack) / inputRange * 255));
      value = Math.pow(value / 255, 1 / gamma) * 255;
      value = outputBlack + value / 255 * outputRange;
      data[i] = data[i + 1] = data[i + 2] = Math.round(value);
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  /**
   * Invert the canvas
   */
  invertCanvas() {
    const imageData = this.renderCtx.getImageData(0, 0, this.width, this.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];
      data[i + 1] = 255 - data[i + 1];
      data[i + 2] = 255 - data[i + 2];
    }
    this.renderCtx.putImageData(imageData, 0, 0);
  }
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  /**
   * Simple deterministic hash function
   */
  hash(n) {
    const x = Math.sin(n) * 43758.5453123;
    return x - Math.floor(x);
  }
  /**
   * Simple 2D Perlin noise approximation
   */
  perlinNoise(x, y) {
    const xi = Math.floor(x);
    const yi = Math.floor(y);
    const xf = x - xi;
    const yf = y - yi;
    const tl = this.hash(xi + yi * 57 + this.noiseSeed);
    const tr = this.hash(xi + 1 + yi * 57 + this.noiseSeed);
    const bl = this.hash(xi + (yi + 1) * 57 + this.noiseSeed);
    const br = this.hash(xi + 1 + (yi + 1) * 57 + this.noiseSeed);
    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);
    return (tl + u * (tr - tl) + v * (bl - tl) + u * v * (tl - tr - bl + br)) * 2 - 1;
  }
  // ============================================================================
  // SOURCE CANVAS (for effects and track mattes)
  // ============================================================================
  getSourceCanvas() {
    return this.renderCanvas;
  }
  applyProcessedEffects(processedCanvas) {
    this.renderCtx.clearRect(0, 0, this.width, this.height);
    this.renderCtx.drawImage(processedCanvas, 0, 0);
    if (this.texture) {
      this.texture.needsUpdate = true;
    }
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.mesh) {
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
  }
}

class ShapeLayer extends BaseLayer {
  type = "shape";
  // Shape data
  shapeData;
  // Rendering
  canvas;
  ctx;
  texture;
  mesh;
  // Canvas size (matches composition)
  canvasWidth = 1920;
  canvasHeight = 1080;
  // 3D extrusion (if any)
  extrudedMeshes = [];
  extrudeGroup;
  // Current frame for animation
  currentFrame = 0;
  constructor(layerData) {
    super(layerData);
    this.shapeData = layerData.data || {
      contents: [],
      blendMode: "normal",
      quality: "normal",
      gpuAccelerated: true
    };
    this.canvas = new OffscreenCanvas(this.canvasWidth, this.canvasHeight);
    this.ctx = this.canvas.getContext("2d");
    this.texture = new CanvasTexture(this.canvas);
    this.texture.colorSpace = SRGBColorSpace;
    this.texture.minFilter = LinearFilter;
    this.texture.magFilter = LinearFilter;
    const geometry = new PlaneGeometry(this.canvasWidth, this.canvasHeight);
    const material = new MeshBasicMaterial({
      map: this.texture,
      transparent: true,
      side: DoubleSide
    });
    this.mesh = new Mesh(geometry, material);
    this.mesh.position.set(this.canvasWidth / 2, this.canvasHeight / 2, 0);
    this.group.add(this.mesh);
    this.extrudeGroup = new Group();
    this.group.add(this.extrudeGroup);
    this.renderShape();
  }
  // ============================================================================
  // SIZE MANAGEMENT
  // ============================================================================
  /**
   * Set canvas size (should match composition)
   */
  setSize(width, height) {
    if (width === this.canvasWidth && height === this.canvasHeight) return;
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.canvas = new OffscreenCanvas(width, height);
    this.ctx = this.canvas.getContext("2d");
    this.texture.image = this.canvas;
    this.texture.needsUpdate = true;
    this.mesh.geometry.dispose();
    this.mesh.geometry = new PlaneGeometry(width, height);
    this.mesh.position.set(width / 2, height / 2, 0);
    this.renderShape();
  }
  // ============================================================================
  // SHAPE DATA ACCESS
  // ============================================================================
  getShapeData() {
    return this.shapeData;
  }
  setShapeData(data) {
    this.shapeData = data;
    this.renderShape();
  }
  addContent(content) {
    this.shapeData.contents.push(content);
    this.renderShape();
  }
  removeContent(index) {
    this.shapeData.contents.splice(index, 1);
    this.renderShape();
  }
  updateContent(index, content) {
    if (index >= 0 && index < this.shapeData.contents.length) {
      this.shapeData.contents[index] = content;
      this.renderShape();
    }
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  evaluateFrame(frame) {
    this.currentFrame = frame;
    super.evaluateFrame(frame);
    this.renderShape();
  }
  /**
   * Called during frame evaluation to update shape-specific properties
   */
  onEvaluateFrame(frame) {
    this.currentFrame = frame;
  }
  /**
   * Called when layer properties are updated
   */
  onUpdate(properties) {
    if (properties.data) {
      this.shapeData = properties.data;
      this.renderShape();
    }
  }
  onApplyEvaluatedState(state) {
    if (state.shapeData) {
      this.shapeData = state.shapeData;
    }
    this.renderShape();
  }
  // ============================================================================
  // SHAPE RENDERING
  // ============================================================================
  /**
   * Main render function
   */
  renderShape() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    const evaluatedPaths = this.evaluateContents(this.shapeData.contents);
    for (const evalPath of evaluatedPaths) {
      this.renderPath(evalPath);
    }
    this.texture.needsUpdate = true;
  }
  /**
   * Evaluate all shape contents into renderable paths
   */
  evaluateContents(contents) {
    const generators = [];
    const operators = [];
    const modifiers = [];
    const repeaters = [];
    const transforms = [];
    const groups = [];
    const illustratorOps = [];
    for (const content of contents) {
      switch (content.type) {
        case "rectangle":
        case "ellipse":
        case "polygon":
        case "star":
        case "path":
          generators.push(content);
          break;
        case "fill":
        case "stroke":
        case "gradientFill":
        case "gradientStroke":
          modifiers.push(content);
          break;
        case "trimPaths":
        case "mergePaths":
        case "offsetPaths":
        case "puckerBloat":
        case "wigglePaths":
        case "zigZag":
        case "twist":
        case "roundedCorners":
          operators.push(content);
          break;
        case "repeater":
          repeaters.push(content);
          break;
        case "transform":
          transforms.push(content);
          break;
        case "group":
          groups.push(content);
          break;
        case "simplifyPath":
        case "smoothPath":
        case "extrude":
        case "trace":
          illustratorOps.push(content);
          break;
      }
    }
    let paths = generators.map((gen) => this.generatePath(gen));
    for (const op of operators) {
      paths = this.applyOperator(paths, op);
    }
    for (const op of illustratorOps) {
      paths = this.applyIllustratorOperator(paths, op);
    }
    for (const transform of transforms) {
      paths = paths.map((p) => this.applyShapeTransform(p, transform));
    }
    for (const repeater of repeaters) {
      paths = this.applyRepeater(paths, repeater);
    }
    const result = [];
    for (const path of paths) {
      const evalPath = { path };
      for (const mod of modifiers) {
        this.applyModifier(evalPath, mod);
      }
      result.push(evalPath);
    }
    for (const group of groups) {
      const groupPaths = this.evaluateContents(group.contents);
      result.push(...groupPaths);
    }
    return result;
  }
  /**
   * Generate a path from a shape generator
   */
  generatePath(generator) {
    switch (generator.type) {
      case "rectangle": {
        const rect = generator;
        const pos = this.getAnimatedValue(rect.position);
        const size = this.getAnimatedValue(rect.size);
        const roundness = this.getAnimatedValue(rect.roundness);
        return generateRectangle(pos, size, roundness, rect.direction);
      }
      case "ellipse": {
        const ellipse = generator;
        const pos = this.getAnimatedValue(ellipse.position);
        const size = this.getAnimatedValue(ellipse.size);
        return generateEllipse(pos, size, ellipse.direction);
      }
      case "polygon": {
        const poly = generator;
        const pos = this.getAnimatedValue(poly.position);
        const points = this.getAnimatedValue(poly.points);
        const radius = this.getAnimatedValue(poly.outerRadius);
        const roundness = this.getAnimatedValue(poly.outerRoundness);
        const rotation = this.getAnimatedValue(poly.rotation);
        return generatePolygon(pos, points, radius, roundness, rotation, poly.direction);
      }
      case "star": {
        const star = generator;
        const pos = this.getAnimatedValue(star.position);
        const points = this.getAnimatedValue(star.points);
        const outerR = this.getAnimatedValue(star.outerRadius);
        const innerR = this.getAnimatedValue(star.innerRadius);
        const outerRound = this.getAnimatedValue(star.outerRoundness);
        const innerRound = this.getAnimatedValue(star.innerRoundness);
        const rotation = this.getAnimatedValue(star.rotation);
        return generateStar(pos, points, outerR, innerR, outerRound, innerRound, rotation, star.direction);
      }
      case "path": {
        const pathShape = generator;
        return clonePath(this.getAnimatedValue(pathShape.path));
      }
      default:
        return { vertices: [], closed: false };
    }
  }
  /**
   * Apply a path operator to paths
   */
  applyOperator(paths, operator) {
    switch (operator.type) {
      case "trimPaths": {
        const trim = operator;
        const start = this.getAnimatedValue(trim.start);
        const end = this.getAnimatedValue(trim.end);
        const offset = this.getAnimatedValue(trim.offset);
        if (trim.mode === "simultaneously") {
          return paths.map((p) => trimPath(p, start, end, offset));
        } else {
          return paths.map((p, i) => {
            const pathStart = (start + 100 / paths.length * i) % 100;
            const pathEnd = (end + 100 / paths.length * i) % 100;
            return trimPath(p, pathStart, pathEnd, offset);
          });
        }
      }
      case "mergePaths": {
        const merge = operator;
        return mergePaths(paths, merge.mode);
      }
      case "offsetPaths": {
        const offset = operator;
        const amount = this.getAnimatedValue(offset.amount);
        const copies = this.getAnimatedValue(offset.copies);
        const copyOff = this.getAnimatedValue(offset.copyOffset);
        const miter = this.getAnimatedValue(offset.miterLimit);
        if (copies <= 1) {
          return paths.map((p) => offsetPath(p, amount, offset.lineJoin, miter));
        } else {
          return paths.flatMap(
            (p) => ShapeOperations.offsetPathMultiple(p, amount, copies, copyOff, offset.lineJoin, miter)
          );
        }
      }
      case "puckerBloat": {
        const pb = operator;
        const amount = this.getAnimatedValue(pb.amount);
        return paths.map((p) => puckerBloat(p, amount));
      }
      case "wigglePaths": {
        const wiggle = operator;
        const size = this.getAnimatedValue(wiggle.size);
        const detail = this.getAnimatedValue(wiggle.detail);
        const correlation = this.getAnimatedValue(wiggle.correlation);
        const temporal = this.getAnimatedValue(wiggle.temporalPhase) + this.currentFrame * 0.1;
        const spatial = this.getAnimatedValue(wiggle.spatialPhase);
        return paths.map(
          (p, i) => wigglePath(p, size, detail, wiggle.points, correlation, temporal, spatial, wiggle.randomSeed + i)
        );
      }
      case "zigZag": {
        const zz = operator;
        const size = this.getAnimatedValue(zz.size);
        const ridges = this.getAnimatedValue(zz.ridgesPerSegment);
        return paths.map((p) => zigZagPath(p, size, ridges, zz.points));
      }
      case "twist": {
        const twist = operator;
        const angle = this.getAnimatedValue(twist.angle);
        const center = this.getAnimatedValue(twist.center);
        return paths.map((p) => twistPath(p, angle, center));
      }
      case "roundedCorners": {
        const rc = operator;
        const radius = this.getAnimatedValue(rc.radius);
        return paths.map((p) => roundCorners(p, radius));
      }
      default:
        return paths;
    }
  }
  /**
   * Apply Illustrator-specific operators
   */
  applyIllustratorOperator(paths, operator) {
    switch (operator.type) {
      case "simplifyPath": {
        const simp = operator;
        const tolerance = this.getAnimatedValue(simp.tolerance);
        return paths.map((p) => simplifyPath(p, tolerance, simp.straightLines));
      }
      case "smoothPath": {
        const smooth = operator;
        const amount = this.getAnimatedValue(smooth.amount);
        return paths.map((p) => smoothPath(p, amount));
      }
      case "extrude": {
        this.createExtrudedGeometry(paths, operator);
        return paths;
      }
      case "trace": {
        return paths;
      }
      default:
        return paths;
    }
  }
  /**
   * Apply a shape transform
   */
  applyShapeTransform(path, transform) {
    const anchor = this.getAnimatedValue(transform.anchorPoint);
    const position = this.getAnimatedValue(transform.position);
    const scale = this.getAnimatedValue(transform.scale);
    const rotation = this.getAnimatedValue(transform.rotation);
    return transformPath(path, anchor, position, scale, rotation);
  }
  /**
   * Apply repeater operator
   */
  applyRepeater(paths, repeater) {
    const copies = Math.floor(this.getAnimatedValue(repeater.copies));
    if (copies <= 1) return paths;
    const offset = this.getAnimatedValue(repeater.offset);
    const anchor = this.getAnimatedValue(repeater.transform.anchorPoint);
    const position = this.getAnimatedValue(repeater.transform.position);
    const scale = this.getAnimatedValue(repeater.transform.scale);
    const rotation = this.getAnimatedValue(repeater.transform.rotation);
    const startOp = this.getAnimatedValue(repeater.transform.startOpacity);
    const endOp = this.getAnimatedValue(repeater.transform.endOpacity);
    const repeated = applyRepeater(
      paths,
      copies,
      offset,
      anchor,
      position,
      scale,
      rotation,
      startOp,
      endOp
    );
    const result = [];
    if (repeater.composite === "below") {
      result.push(...paths);
      for (const rep of repeated.slice(1)) {
        result.push(...rep.paths);
      }
    } else {
      for (let i = repeated.length - 1; i >= 1; i--) {
        result.push(...repeated[i].paths);
      }
      result.push(...paths);
    }
    return result;
  }
  /**
   * Apply a modifier (fill/stroke) to an evaluated path
   */
  applyModifier(evalPath, modifier) {
    switch (modifier.type) {
      case "fill": {
        const fill = modifier;
        evalPath.fill = {
          color: this.getAnimatedValue(fill.color),
          opacity: this.getAnimatedValue(fill.opacity),
          rule: fill.fillRule
        };
        break;
      }
      case "stroke": {
        const stroke = modifier;
        evalPath.stroke = {
          color: this.getAnimatedValue(stroke.color),
          opacity: this.getAnimatedValue(stroke.opacity),
          width: this.getAnimatedValue(stroke.width),
          lineCap: stroke.lineCap,
          lineJoin: stroke.lineJoin,
          dashPattern: this.getAnimatedValue(stroke.dashPattern),
          dashOffset: this.getAnimatedValue(stroke.dashOffset)
        };
        break;
      }
      case "gradientFill": {
        const grad = modifier;
        const gradDef = this.getAnimatedValue(grad.gradient);
        evalPath.gradientFill = {
          type: gradDef.type,
          stops: gradDef.stops,
          startPoint: gradDef.startPoint,
          endPoint: gradDef.endPoint,
          opacity: this.getAnimatedValue(grad.opacity)
        };
        break;
      }
    }
  }
  /**
   * Get animated value at current frame
   */
  getAnimatedValue(prop) {
    return prop.value;
  }
  /**
   * Render a single evaluated path to canvas
   */
  renderPath(evalPath) {
    const { path, fill, stroke, gradientFill } = evalPath;
    if (path.vertices.length < 2) return;
    this.ctx.save();
    const path2d = this.buildPath2D(path);
    if (gradientFill) {
      const gradient = this.createGradient(gradientFill);
      this.ctx.globalAlpha = gradientFill.opacity / 100;
      this.ctx.fillStyle = gradient;
      this.ctx.fill(path2d, "nonzero");
    } else if (fill) {
      this.ctx.globalAlpha = fill.opacity / 100;
      this.ctx.fillStyle = this.colorToCSS(fill.color);
      this.ctx.fill(path2d, fill.rule);
    }
    if (stroke && stroke.width > 0) {
      this.ctx.globalAlpha = stroke.opacity / 100;
      this.ctx.strokeStyle = this.colorToCSS(stroke.color);
      this.ctx.lineWidth = stroke.width;
      this.ctx.lineCap = stroke.lineCap;
      this.ctx.lineJoin = stroke.lineJoin;
      if (stroke.dashPattern.length > 0) {
        this.ctx.setLineDash(stroke.dashPattern);
        this.ctx.lineDashOffset = stroke.dashOffset;
      }
      this.ctx.stroke(path2d);
    }
    this.ctx.restore();
  }
  /**
   * Build a Path2D from a BezierPath
   */
  buildPath2D(path) {
    const p = new Path2D();
    if (path.vertices.length === 0) return p;
    const v0 = path.vertices[0];
    p.moveTo(v0.point.x, v0.point.y);
    for (let i = 0; i < path.vertices.length; i++) {
      const curr = path.vertices[i];
      const next = path.vertices[(i + 1) % path.vertices.length];
      if (!path.closed && i === path.vertices.length - 1) break;
      const cp1x = curr.point.x + curr.outHandle.x;
      const cp1y = curr.point.y + curr.outHandle.y;
      const cp2x = next.point.x + next.inHandle.x;
      const cp2y = next.point.y + next.inHandle.y;
      p.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
    }
    if (path.closed) {
      p.closePath();
    }
    return p;
  }
  /**
   * Convert ShapeColor to CSS color string
   */
  colorToCSS(color) {
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
  }
  /**
   * Create canvas gradient
   */
  createGradient(gradDef) {
    if (!gradDef) {
      return this.ctx.createLinearGradient(0, 0, 0, 0);
    }
    const startX = gradDef.startPoint.x * this.canvasWidth;
    const startY = gradDef.startPoint.y * this.canvasHeight;
    const endX = gradDef.endPoint.x * this.canvasWidth;
    const endY = gradDef.endPoint.y * this.canvasHeight;
    let gradient;
    if (gradDef.type === "linear") {
      gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
    } else {
      const radius = Math.sqrt(
        Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
      );
      gradient = this.ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
    }
    for (const stop of gradDef.stops) {
      gradient.addColorStop(stop.position, this.colorToCSS(stop.color));
    }
    return gradient;
  }
  /**
   * Create extruded 3D geometry from paths
   */
  createExtrudedGeometry(paths, extrude) {
    for (const mesh of this.extrudedMeshes) {
      this.extrudeGroup.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    this.extrudedMeshes = [];
    const depth = this.getAnimatedValue(extrude.depth);
    const bevelDepth = this.getAnimatedValue(extrude.bevelDepth);
    const frontColor = this.getAnimatedValue(extrude.material.frontColor);
    this.getAnimatedValue(extrude.material.sideColor);
    for (const path of paths) {
      if (path.vertices.length < 3 || !path.closed) continue;
      const shape = new Shape();
      const v0 = path.vertices[0];
      shape.moveTo(v0.point.x, v0.point.y);
      for (let i = 0; i < path.vertices.length; i++) {
        const curr = path.vertices[i];
        const next = path.vertices[(i + 1) % path.vertices.length];
        const cp1x = curr.point.x + curr.outHandle.x;
        const cp1y = curr.point.y + curr.outHandle.y;
        const cp2x = next.point.x + next.inHandle.x;
        const cp2y = next.point.y + next.inHandle.y;
        shape.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.point.x, next.point.y);
      }
      const geometry = new ExtrudeGeometry(shape, {
        depth,
        bevelEnabled: bevelDepth > 0,
        bevelThickness: bevelDepth,
        bevelSize: bevelDepth,
        bevelSegments: extrude.bevelSegments
      });
      const material = new MeshStandardMaterial({
        color: new Color(frontColor.r / 255, frontColor.g / 255, frontColor.b / 255),
        metalness: 0.1,
        roughness: 0.8
      });
      const mesh = new Mesh(geometry, material);
      this.extrudeGroup.add(mesh);
      this.extrudedMeshes.push(mesh);
    }
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  dispose() {
    this.texture.dispose();
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    for (const mesh of this.extrudedMeshes) {
      mesh.geometry.dispose();
      mesh.material.dispose();
    }
    super.dispose();
  }
}

class ModelLayer extends BaseLayer {
  /** The loaded 3D model */
  model = null;
  /** Original materials (for restoring after override) */
  originalMaterials = /* @__PURE__ */ new Map();
  /** Animation mixer for animated models */
  mixer = null;
  /** Available animation clips */
  animationClips = [];
  /** Currently playing animation action */
  currentAction = null;
  /** Skeleton helper for bone visualization */
  skeletonHelper = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  modelData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders (static for efficiency) */
  static gltfLoader = null;
  static objLoader = null;
  static fbxLoader = null;
  static colladaLoader = null;
  static dracoLoader = null;
  /** Composition FPS for animation sync */
  fps = 30;
  constructor(layerData) {
    super(layerData);
    this.modelData = this.extractModelData(layerData);
    this.initializeLoaders();
    this.loadModel();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!ModelLayer.gltfLoader) {
      ModelLayer.gltfLoader = new GLTFLoader();
      ModelLayer.dracoLoader = new DRACOLoader();
      ModelLayer.dracoLoader.setDecoderPath("/draco/");
      ModelLayer.gltfLoader.setDRACOLoader(ModelLayer.dracoLoader);
      ModelLayer.gltfLoader.setMeshoptDecoder(MeshoptDecoder);
    }
    if (!ModelLayer.objLoader) {
      ModelLayer.objLoader = new OBJLoader();
    }
    if (!ModelLayer.fbxLoader) {
      ModelLayer.fbxLoader = new FBXLoader();
    }
    if (!ModelLayer.colladaLoader) {
      ModelLayer.colladaLoader = new ColladaLoader();
    }
  }
  /**
   * Extract model data from layer
   */
  extractModelData(layerData) {
    const data = layerData.data;
    const defaultScale = {
      id: `${layerData.id}_scale`,
      name: "Scale",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "gltf",
      scale: data?.scale ?? defaultScale,
      uniformScale: data?.uniformScale ?? true,
      materialOverride: data?.materialOverride,
      animation: data?.animation,
      boundingBox: data?.boundingBox,
      castShadow: data?.castShadow ?? true,
      receiveShadow: data?.receiveShadow ?? true,
      frustumCulled: data?.frustumCulled ?? true,
      renderOrder: data?.renderOrder ?? 0,
      showBoundingBox: data?.showBoundingBox ?? false,
      showSkeleton: data?.showSkeleton ?? false,
      envMapIntensity: data?.envMapIntensity ?? 1,
      lod: data?.lod
    };
  }
  /**
   * Load the 3D model from asset
   */
  async loadModel() {
    if (!this.modelData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.modelData.assetId);
      let loadedObject;
      switch (this.modelData.format) {
        case "gltf":
        case "glb":
          loadedObject = await this.loadGLTF(url);
          break;
        case "obj":
          loadedObject = await this.loadOBJ(url);
          break;
        case "fbx":
          loadedObject = await this.loadFBX(url);
          break;
        case "dae":
          loadedObject = await this.loadCollada(url);
          break;
        case "usd":
        case "usda":
        case "usdc":
        case "usdz":
          loadedObject = await this.loadUSD(url);
          break;
        default:
          throw new Error(`Unsupported model format: ${this.modelData.format}`);
      }
      this.setModel(loadedObject);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[ModelLayer] Failed to load model: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load GLTF/GLB model
   */
  loadGLTF(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.gltfLoader.load(
        url,
        (gltf) => {
          if (gltf.animations && gltf.animations.length > 0) {
            this.animationClips = gltf.animations;
            this.setupAnimations(gltf.scene);
          }
          resolve(gltf.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load OBJ model
   */
  loadOBJ(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.objLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load FBX model
   */
  loadFBX(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.fbxLoader.load(
        url,
        (object) => {
          if (object.animations && object.animations.length > 0) {
            this.animationClips = object.animations;
            this.setupAnimations(object);
          }
          resolve(object);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load Collada (DAE) model
   */
  loadCollada(url) {
    return new Promise((resolve, reject) => {
      ModelLayer.colladaLoader.load(
        url,
        (collada) => {
          if (collada.scene.animations && collada.scene.animations.length > 0) {
            this.animationClips = collada.scene.animations;
            this.setupAnimations(collada.scene);
          }
          resolve(collada.scene);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load USD/USDZ model
   * Note: USD support in Three.js is limited. This is a placeholder for future implementation.
   */
  async loadUSD(url) {
    try {
      const { USDZLoader } = await import('./weyl-three-vendor.js').then(n => n.bj);
      const loader = new USDZLoader();
      return new Promise((resolve, reject) => {
        loader.load(url, resolve, void 0, reject);
      });
    } catch {
      console.warn("[ModelLayer] USD/USDZ loader not available. Creating placeholder.");
      return this.createUSDPlaceholder();
    }
  }
  /**
   * Create placeholder for USD when loader unavailable
   */
  createUSDPlaceholder() {
    const group = new Group();
    group.name = "usd_placeholder";
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshStandardMaterial({
      color: 4886745,
      wireframe: true
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    return group;
  }
  /**
   * Create placeholder model when loading fails or no asset
   */
  createPlaceholder() {
    const group = new Group();
    group.name = `model_placeholder_${this.id}`;
    const geometry = new BoxGeometry(100, 100, 100);
    const material = new MeshBasicMaterial({
      color: 16737792,
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });
    const mesh = new Mesh(geometry, material);
    group.add(mesh);
    const axisHelper = new AxesHelper(75);
    group.add(axisHelper);
    this.setModel(group);
  }
  /**
   * Set the loaded model
   */
  setModel(object) {
    if (this.model) {
      this.group.remove(this.model);
      this.disposeModel();
    }
    this.model = object;
    this.model.name = `model_${this.id}`;
    this.storeOriginalMaterials();
    this.applyShadowSettings();
    if (this.modelData.materialOverride) {
      this.applyMaterialOverride(this.modelData.materialOverride);
    }
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.updateSkeletonHelper();
    this.group.add(this.model);
  }
  /**
   * Store original materials for later restoration
   */
  storeOriginalMaterials() {
    this.originalMaterials.clear();
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        this.originalMaterials.set(child, child.material);
      }
    });
  }
  /**
   * Apply shadow settings to model
   */
  applyShadowSettings() {
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.castShadow = this.modelData.castShadow;
        child.receiveShadow = this.modelData.receiveShadow;
        child.frustumCulled = this.modelData.frustumCulled;
        child.renderOrder = this.modelData.renderOrder;
      }
    });
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.model) return;
    const box = new Box3().setFromObject(this.model);
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.modelData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Setup animation mixer and actions
   */
  setupAnimations(object) {
    this.mixer = new AnimationMixer(object);
    if (!this.modelData.animation) {
      this.modelData.animation = {
        clips: [],
        time: {
          id: `${this.id}_anim_time`,
          name: "Animation Time",
          type: "number",
          value: 0,
          animated: false,
          keyframes: []
        },
        speed: 1,
        loop: true,
        autoPlay: false
      };
    }
    this.modelData.animation.clips = this.animationClips.map((clip) => ({
      name: clip.name,
      duration: clip.duration,
      frameCount: Math.round(clip.duration * this.fps)
    }));
    if (this.modelData.animation.autoPlay && this.animationClips.length > 0) {
      this.playAnimation(this.animationClips[0].name);
    }
  }
  /**
   * Play an animation clip by name
   */
  playAnimation(clipName) {
    if (!this.mixer) return;
    const clip = this.animationClips.find((c) => c.name === clipName);
    if (!clip) return;
    if (this.currentAction) {
      this.currentAction.stop();
    }
    this.currentAction = this.mixer.clipAction(clip);
    this.currentAction.setLoop(
      this.modelData.animation?.loop ? LoopRepeat : LoopOnce,
      Infinity
    );
    this.currentAction.play();
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = clipName;
    }
  }
  /**
   * Stop current animation
   */
  stopAnimation() {
    if (this.currentAction) {
      this.currentAction.stop();
      this.currentAction = null;
    }
    if (this.modelData.animation) {
      this.modelData.animation.activeClip = void 0;
    }
  }
  /**
   * Set animation time directly (for scrubbing)
   */
  setAnimationTime(time) {
    if (!this.mixer || !this.currentAction) return;
    this.currentAction.time = time;
    this.mixer.update(0);
  }
  /**
   * Update animation mixer
   */
  updateAnimation(deltaTime) {
    if (!this.mixer) return;
    const speed = this.modelData.animation?.speed ?? 1;
    this.mixer.update(deltaTime * speed);
  }
  // ============================================================================
  // MATERIAL OVERRIDES
  // ============================================================================
  /**
   * Apply material override to all meshes
   */
  applyMaterialOverride(override) {
    if (!this.model) return;
    this.model.traverse((child) => {
      if (child instanceof Mesh) {
        this.applyMaterialOverrideToMesh(child, override);
      }
    });
  }
  /**
   * Apply material override to a single mesh
   */
  applyMaterialOverrideToMesh(mesh, override) {
    if (override.useDepthMaterial) {
      mesh.material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
      });
      return;
    }
    if (override.useNormalMaterial) {
      mesh.material = new MeshNormalMaterial();
      return;
    }
    let material = Array.isArray(mesh.material) ? mesh.material[0].clone() : mesh.material.clone();
    if (override.wireframe !== void 0) {
      material.wireframe = override.wireframe;
    }
    if (override.wireframeColor && override.wireframe) {
      material = new MeshBasicMaterial({
        color: override.wireframeColor,
        wireframe: true
      });
    } else if (override.colorOverride) {
      material.color = new Color(override.colorOverride);
    }
    if (override.opacityOverride !== void 0) {
      material.transparent = override.opacityOverride < 1;
      material.opacity = override.opacityOverride;
    }
    if (override.flatShading !== void 0 && "flatShading" in material) {
      material.flatShading = override.flatShading;
      material.needsUpdate = true;
    }
    if (material instanceof MeshStandardMaterial) {
      if (override.metalness !== void 0) {
        material.metalness = override.metalness;
      }
      if (override.roughness !== void 0) {
        material.roughness = override.roughness;
      }
      if (override.emissive) {
        material.emissive = new Color(override.emissive);
      }
      if (override.emissiveIntensity !== void 0) {
        material.emissiveIntensity = override.emissiveIntensity;
      }
    }
    mesh.material = material;
  }
  /**
   * Restore original materials
   */
  restoreOriginalMaterials() {
    this.originalMaterials.forEach((material, mesh) => {
      mesh.material = material;
    });
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper visibility
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.modelData.showBoundingBox && this.model) {
      this.boundingBoxHelper = new BoxHelper(this.model, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  /**
   * Update skeleton helper visibility
   */
  updateSkeletonHelper() {
    if (this.skeletonHelper) {
      this.group.remove(this.skeletonHelper);
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    if (this.modelData.showSkeleton && this.model) {
      let skeleton = null;
      this.model.traverse((child) => {
        if (child instanceof SkinnedMesh && child.skeleton) {
          skeleton = child.skeleton;
        }
      });
      if (skeleton) {
        this.skeletonHelper = new SkeletonHelper(this.model);
        this.skeletonHelper.name = `skeleton_helper_${this.id}`;
        this.skeletonHelper.material.linewidth = 2;
        this.group.add(this.skeletonHelper);
      }
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set model scale
   */
  setScale(scale) {
    if (!this.model) return;
    if (typeof scale === "number") {
      this.model.scale.setScalar(scale);
    } else {
      this.model.scale.set(scale.x, scale.y, scale.z);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.modelData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  /**
   * Set skeleton visibility
   */
  setShowSkeleton(show) {
    this.modelData.showSkeleton = show;
    this.updateSkeletonHelper();
  }
  /**
   * Set FPS for animation sync
   */
  setFPS(fps) {
    this.fps = fps;
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the loaded model object
   */
  getModel() {
    return this.model;
  }
  /**
   * Get available animation clips
   */
  getAnimationClips() {
    return this.modelData.animation?.clips ?? [];
  }
  /**
   * Get model-specific bounding box data
   */
  getModelBoundingBox() {
    return this.modelData.boundingBox;
  }
  /**
   * Check if model is loading
   */
  isModelLoading() {
    return this.isLoading;
  }
  /**
   * Get load error if any
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    let scale;
    if (typeof this.modelData.scale === "object" && "value" in this.modelData.scale) {
      scale = interpolateProperty(this.modelData.scale, frame);
      this.setScale(scale);
    }
    if (this.modelData.animation?.time) {
      const time = interpolateProperty(this.modelData.animation.time, frame);
      this.setAnimationTime(time);
    }
    if (this.mixer && this.modelData.animation?.autoPlay) {
      const deltaTime = 1 / this.fps;
      this.updateAnimation(deltaTime);
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["scale"] !== void 0) {
      this.setScale(props["scale"]);
    }
    if (props["animationTime"] !== void 0) {
      this.setAnimationTime(props["animationTime"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.modelData.assetId) {
        this.modelData.assetId = data.assetId;
        if (data.format) {
          this.modelData.format = data.format;
        }
        this.loadModel();
      }
      if (data.materialOverride !== void 0) {
        this.modelData.materialOverride = data.materialOverride;
        if (data.materialOverride) {
          this.applyMaterialOverride(data.materialOverride);
        } else {
          this.restoreOriginalMaterials();
        }
      }
      if (data.castShadow !== void 0 || data.receiveShadow !== void 0) {
        if (data.castShadow !== void 0) {
          this.modelData.castShadow = data.castShadow;
        }
        if (data.receiveShadow !== void 0) {
          this.modelData.receiveShadow = data.receiveShadow;
        }
        this.applyShadowSettings();
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.showSkeleton !== void 0) {
        this.setShowSkeleton(data.showSkeleton);
      }
      if (data.animation !== void 0) {
        Object.assign(this.modelData.animation ?? {}, data.animation);
        if (data.animation.activeClip) {
          this.playAnimation(data.animation.activeClip);
        }
      }
    }
  }
  onDispose() {
    this.disposeModel();
  }
  /**
   * Dispose model resources
   */
  disposeModel() {
    if (this.mixer) {
      this.mixer.stopAllAction();
      this.mixer = null;
    }
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.skeletonHelper) {
      this.skeletonHelper.dispose();
      this.skeletonHelper = null;
    }
    this.model?.traverse((child) => {
      if (child instanceof Mesh) {
        child.geometry.dispose();
        if (Array.isArray(child.material)) {
          child.material.forEach((m) => m.dispose());
        } else {
          child.material.dispose();
        }
      }
    });
    this.originalMaterials.clear();
    this.animationClips = [];
    this.currentAction = null;
    this.model = null;
  }
}

class PointCloudLayer extends BaseLayer {
  /** The point cloud mesh */
  pointCloud = null;
  /** Point cloud geometry */
  geometry = null;
  /** Point cloud material */
  material = null;
  /** Original point data (for color mode switching) */
  originalAttributes = null;
  /** Bounding box helper */
  boundingBoxHelper = null;
  /** Layer data */
  cloudData;
  /** Loading state */
  isLoading = false;
  loadError = null;
  /** Shared loaders */
  static plyLoader = null;
  static pcdLoader = null;
  constructor(layerData) {
    super(layerData);
    this.cloudData = this.extractCloudData(layerData);
    this.initializeLoaders();
    this.loadPointCloud();
    this.initializeBlendMode();
  }
  /**
   * Initialize shared loaders
   */
  initializeLoaders() {
    if (!PointCloudLayer.plyLoader) {
      PointCloudLayer.plyLoader = new PLYLoader();
    }
    if (!PointCloudLayer.pcdLoader) {
      PointCloudLayer.pcdLoader = new PCDLoader();
    }
  }
  /**
   * Extract point cloud data from layer
   */
  extractCloudData(layerData) {
    const data = layerData.data;
    const defaultPointSize = {
      id: `${layerData.id}_pointSize`,
      name: "Point Size",
      type: "number",
      value: 2,
      animated: false,
      keyframes: []
    };
    const defaultOpacity = {
      id: `${layerData.id}_opacity`,
      name: "Opacity",
      type: "number",
      value: 1,
      animated: false,
      keyframes: []
    };
    return {
      assetId: data?.assetId ?? "",
      format: data?.format ?? "ply",
      pointCount: data?.pointCount ?? 0,
      pointSize: data?.pointSize ?? defaultPointSize,
      sizeAttenuation: data?.sizeAttenuation ?? true,
      minPointSize: data?.minPointSize ?? 1,
      maxPointSize: data?.maxPointSize ?? 64,
      colorMode: data?.colorMode ?? "rgb",
      uniformColor: data?.uniformColor ?? "#ffffff",
      colorGradient: data?.colorGradient,
      renderMode: data?.renderMode ?? "circles",
      opacity: data?.opacity ?? defaultOpacity,
      depthTest: data?.depthTest ?? true,
      depthWrite: data?.depthWrite ?? true,
      boundingBox: data?.boundingBox,
      showBoundingBox: data?.showBoundingBox ?? false,
      lod: data?.lod,
      octree: data?.octree,
      pointBudget: data?.pointBudget ?? 1e6,
      edl: data?.edl,
      clipPlanes: data?.clipPlanes,
      classificationFilter: data?.classificationFilter,
      intensityRange: data?.intensityRange
    };
  }
  /**
   * Load the point cloud from asset
   */
  async loadPointCloud() {
    if (!this.cloudData.assetId) {
      this.createPlaceholder();
      return;
    }
    this.isLoading = true;
    this.loadError = null;
    try {
      const url = await this.resolveAssetUrl(this.cloudData.assetId);
      let geometry;
      switch (this.cloudData.format) {
        case "ply":
          geometry = await this.loadPLY(url);
          break;
        case "pcd":
          geometry = await this.loadPCD(url);
          break;
        case "xyz":
        case "pts":
          geometry = await this.loadXYZ(url);
          break;
        case "las":
        case "laz":
          geometry = await this.loadLAS(url);
          break;
        default:
          throw new Error(`Unsupported point cloud format: ${this.cloudData.format}`);
      }
      this.setGeometry(geometry);
    } catch (error) {
      this.loadError = error instanceof Error ? error.message : "Unknown error";
      console.error(`[PointCloudLayer] Failed to load point cloud: ${this.loadError}`);
      this.createPlaceholder();
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Resolve asset ID to URL
   */
  async resolveAssetUrl(assetId) {
    return assetId;
  }
  /**
   * Load PLY point cloud
   */
  loadPLY(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.plyLoader.load(url, resolve, void 0, reject);
    });
  }
  /**
   * Load PCD point cloud
   */
  loadPCD(url) {
    return new Promise((resolve, reject) => {
      PointCloudLayer.pcdLoader.load(
        url,
        (points) => {
          resolve(points.geometry);
        },
        void 0,
        reject
      );
    });
  }
  /**
   * Load XYZ/PTS point cloud (ASCII format)
   */
  async loadXYZ(url) {
    const response = await fetch(url);
    const text = await response.text();
    const lines = text.trim().split("\n");
    const positions = [];
    const colors = [];
    for (const line of lines) {
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        positions.push(
          parseFloat(parts[0]),
          parseFloat(parts[1]),
          parseFloat(parts[2])
        );
        if (parts.length >= 6) {
          colors.push(
            parseFloat(parts[3]) / 255,
            parseFloat(parts[4]) / 255,
            parseFloat(parts[5]) / 255
          );
        } else {
          colors.push(1, 1, 1);
        }
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Load LAS/LAZ point cloud
   * Implements basic LAS 1.2-1.4 format parsing
   */
  async loadLAS(url) {
    const response = await fetch(url);
    const buffer = await response.arrayBuffer();
    const view = new DataView(buffer);
    const signature = String.fromCharCode(
      view.getUint8(0),
      view.getUint8(1),
      view.getUint8(2),
      view.getUint8(3)
    );
    if (signature !== "LASF") {
      throw new Error("Invalid LAS file: missing LASF signature");
    }
    const versionMajor = view.getUint8(24);
    const versionMinor = view.getUint8(25);
    view.getUint16(94, true);
    const offsetToPointData = view.getUint32(96, true);
    const pointDataFormat = view.getUint8(104);
    const pointDataLength = view.getUint16(105, true);
    let pointCount;
    if (versionMajor === 1 && versionMinor >= 4) {
      pointCount = Number(view.getBigUint64(247, true));
    } else {
      pointCount = view.getUint32(107, true);
    }
    const scaleX = view.getFloat64(131, true);
    const scaleY = view.getFloat64(139, true);
    const scaleZ = view.getFloat64(147, true);
    const offsetX = view.getFloat64(155, true);
    const offsetY = view.getFloat64(163, true);
    const offsetZ = view.getFloat64(171, true);
    const maxPoints = Math.min(pointCount, this.cloudData.pointBudget);
    const skipRate = Math.max(1, Math.floor(pointCount / maxPoints));
    const positions = [];
    const colors = [];
    const intensities = [];
    const classifications = [];
    const hasRGB = pointDataFormat === 2 || pointDataFormat === 3 || pointDataFormat === 7 || pointDataFormat === 8;
    let offset = offsetToPointData;
    let loadedPoints = 0;
    for (let i = 0; i < pointCount && loadedPoints < maxPoints; i++) {
      if (i % skipRate !== 0) {
        offset += pointDataLength;
        continue;
      }
      const x = view.getInt32(offset, true) * scaleX + offsetX;
      const y = view.getInt32(offset + 4, true) * scaleY + offsetY;
      const z = view.getInt32(offset + 8, true) * scaleZ + offsetZ;
      const intensity = view.getUint16(offset + 12, true);
      const classification = view.getUint8(offset + 15);
      positions.push(x, z, -y);
      intensities.push(intensity / 65535);
      classifications.push(classification);
      if (hasRGB) {
        const rgbOffset = pointDataFormat === 2 ? 20 : pointDataFormat === 3 ? 28 : pointDataFormat === 7 ? 30 : pointDataFormat === 8 ? 30 : 20;
        if (offset + rgbOffset + 6 <= buffer.byteLength) {
          const r = view.getUint16(offset + rgbOffset, true) / 65535;
          const g = view.getUint16(offset + rgbOffset + 2, true) / 65535;
          const b = view.getUint16(offset + rgbOffset + 4, true) / 65535;
          colors.push(r, g, b);
        } else {
          colors.push(1, 1, 1);
        }
      } else {
        const gray = intensity / 65535;
        colors.push(gray, gray, gray);
      }
      offset += pointDataLength;
      loadedPoints++;
    }
    console.log(`[PointCloudLayer] Loaded ${loadedPoints} points from LAS v${versionMajor}.${versionMinor} (format ${pointDataFormat})`);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.originalAttributes = {
      positions: new Float32Array(positions),
      colors: new Float32Array(colors),
      intensities: new Float32Array(intensities),
      classifications: new Uint8Array(classifications)
    };
    return geometry;
  }
  /**
   * Create placeholder geometry
   */
  createPlaceholderGeometry() {
    const positions = [];
    const colors = [];
    const size = 100;
    const count = 1e3;
    for (let i = 0; i < count; i++) {
      positions.push(
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size,
        (Math.random() - 0.5) * size
      );
      colors.push(Math.random(), Math.random(), Math.random());
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    return geometry;
  }
  /**
   * Create placeholder point cloud
   */
  createPlaceholder() {
    const geometry = this.createPlaceholderGeometry();
    this.setGeometry(geometry);
  }
  /**
   * Set the point cloud geometry
   */
  setGeometry(geometry) {
    if (this.pointCloud) {
      this.group.remove(this.pointCloud);
      this.disposePointCloud();
    }
    this.geometry = geometry;
    this.storeOriginalAttributes();
    const positionAttr = geometry.getAttribute("position");
    this.cloudData.pointCount = positionAttr ? positionAttr.count : 0;
    this.createMaterial();
    this.pointCloud = new Points(this.geometry, this.material);
    this.pointCloud.name = `pointcloud_${this.id}`;
    this.calculateBoundingBox();
    this.updateBoundingBoxHelper();
    this.applyColorMode(this.cloudData.colorMode);
    this.group.add(this.pointCloud);
  }
  /**
   * Store original point attributes
   */
  storeOriginalAttributes() {
    if (!this.geometry) return;
    const position = this.geometry.getAttribute("position");
    const color = this.geometry.getAttribute("color");
    const normal = this.geometry.getAttribute("normal");
    this.originalAttributes = {
      positions: position ? new Float32Array(position.array) : new Float32Array(),
      colors: color ? new Float32Array(color.array) : void 0,
      normals: normal ? new Float32Array(normal.array) : void 0
    };
  }
  /**
   * Create point cloud material
   */
  createMaterial() {
    this.material = new ShaderMaterial({
      uniforms: {
        pointSize: { value: 2 },
        minPointSize: { value: this.cloudData.minPointSize },
        maxPointSize: { value: this.cloudData.maxPointSize },
        opacity: { value: 1 },
        sizeAttenuation: { value: this.cloudData.sizeAttenuation ? 1 : 0 },
        uniformColor: { value: new Color(this.cloudData.uniformColor) },
        useUniformColor: { value: 0 },
        heightMin: { value: 0 },
        heightMax: { value: 100 },
        gradientColors: { value: this.getGradientTexture() },
        renderMode: { value: this.getRenderModeValue() }
      },
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      transparent: true,
      depthTest: this.cloudData.depthTest,
      depthWrite: this.cloudData.depthWrite,
      vertexColors: true
    });
  }
  /**
   * Get vertex shader for point cloud rendering
   */
  getVertexShader() {
    return `
      uniform float pointSize;
      uniform float minPointSize;
      uniform float maxPointSize;
      uniform float sizeAttenuation;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vColor = color;
        vPosition = position;
        vNormal = normal;

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        // Size attenuation
        float size = pointSize;
        if (sizeAttenuation > 0.5) {
          size = pointSize * (300.0 / -mvPosition.z);
        }

        // Clamp size
        gl_PointSize = clamp(size, minPointSize, maxPointSize);
      }
    `;
  }
  /**
   * Get fragment shader for point cloud rendering
   */
  getFragmentShader() {
    return `
      uniform float opacity;
      uniform vec3 uniformColor;
      uniform float useUniformColor;
      uniform float renderMode;

      varying vec3 vColor;
      varying vec3 vPosition;
      varying vec3 vNormal;

      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);

        // Render mode: 0 = points, 1 = circles, 2 = squares, 3 = splats
        if (renderMode > 0.5 && renderMode < 1.5) {
          // Circle
          float dist = length(coord);
          if (dist > 0.5) discard;
        } else if (renderMode > 2.5) {
          // Gaussian splat
          float dist = length(coord);
          float alpha = exp(-dist * dist * 8.0);
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(mix(vColor, uniformColor, useUniformColor), alpha * opacity);
          return;
        }
        // Squares (mode 2) use full point

        vec3 color = mix(vColor, uniformColor, useUniformColor);
        gl_FragColor = vec4(color, opacity);
      }
    `;
  }
  /**
   * Get render mode value for shader
   */
  getRenderModeValue() {
    switch (this.cloudData.renderMode) {
      case "points":
        return 0;
      case "circles":
        return 1;
      case "squares":
        return 2;
      case "splats":
        return 3;
      default:
        return 1;
    }
  }
  /**
   * Create gradient texture for color mapping
   */
  getGradientTexture() {
    const size = 256;
    const data = new Uint8Array(size * 4);
    const stops = this.cloudData.colorGradient?.stops ?? [
      { position: 0, color: "#0000ff" },
      { position: 0.5, color: "#00ff00" },
      { position: 1, color: "#ff0000" }
    ];
    for (let i = 0; i < size; i++) {
      const t = i / (size - 1);
      let stop1 = stops[0];
      let stop2 = stops[stops.length - 1];
      for (let j = 0; j < stops.length - 1; j++) {
        if (t >= stops[j].position && t <= stops[j + 1].position) {
          stop1 = stops[j];
          stop2 = stops[j + 1];
          break;
        }
      }
      const localT = (t - stop1.position) / (stop2.position - stop1.position);
      const color1 = new Color(stop1.color);
      const color2 = new Color(stop2.color);
      const color = color1.lerp(color2, localT);
      data[i * 4] = Math.floor(color.r * 255);
      data[i * 4 + 1] = Math.floor(color.g * 255);
      data[i * 4 + 2] = Math.floor(color.b * 255);
      data[i * 4 + 3] = 255;
    }
    const texture = new DataTexture(data, size, 1, RGBAFormat);
    texture.needsUpdate = true;
    return texture;
  }
  /**
   * Calculate and store bounding box
   */
  calculateBoundingBox() {
    if (!this.geometry) return;
    this.geometry.computeBoundingBox();
    const box = this.geometry.boundingBox;
    if (!box) return;
    const center = box.getCenter(new Vector3());
    const size = box.getSize(new Vector3());
    this.cloudData.boundingBox = {
      min: { x: box.min.x, y: box.min.y, z: box.min.z },
      max: { x: box.max.x, y: box.max.y, z: box.max.z },
      center: { x: center.x, y: center.y, z: center.z },
      size: { x: size.x, y: size.y, z: size.z }
    };
    if (this.material) {
      this.material.uniforms.heightMin.value = box.min.y;
      this.material.uniforms.heightMax.value = box.max.y;
    }
  }
  // ============================================================================
  // COLOR MODES
  // ============================================================================
  /**
   * Apply color mode to point cloud
   */
  applyColorMode(mode) {
    if (!this.geometry || !this.material || !this.originalAttributes) return;
    this.cloudData.colorMode = mode;
    switch (mode) {
      case "rgb":
        if (this.originalAttributes.colors) {
          this.geometry.setAttribute(
            "color",
            new Float32BufferAttribute(this.originalAttributes.colors, 3)
          );
        }
        this.material.uniforms.useUniformColor.value = 0;
        break;
      case "uniform":
        this.material.uniforms.useUniformColor.value = 1;
        this.material.uniforms.uniformColor.value.set(this.cloudData.uniformColor);
        break;
      case "height":
        this.applyHeightColoring();
        break;
      case "depth":
        this.applyDepthColoring();
        break;
      case "normal":
        this.applyNormalColoring();
        break;
      case "intensity":
        this.applyIntensityColoring();
        break;
      case "classification":
        this.applyClassificationColoring();
        break;
    }
    this.geometry.attributes.color.needsUpdate = true;
  }
  /**
   * Apply height-based coloring
   */
  applyHeightColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minY = this.cloudData.boundingBox.min.y;
    const maxY = this.cloudData.boundingBox.max.y;
    const range = maxY - minY || 1;
    for (let i = 0; i < count; i++) {
      const y = positions[i * 3 + 1];
      const t = (y - minY) / range;
      const color = new Color();
      color.setHSL((1 - t) * 0.7, 1, 0.5);
      colors[i * 3] = color.r;
      colors[i * 3 + 1] = color.g;
      colors[i * 3 + 2] = color.b;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply depth-based coloring (distance from camera)
   */
  applyDepthColoring() {
    if (!this.geometry || !this.originalAttributes || !this.cloudData.boundingBox) return;
    const positions = this.originalAttributes.positions;
    const count = positions.length / 3;
    const colors = new Float32Array(count * 3);
    const minZ = this.cloudData.boundingBox.min.z;
    const maxZ = this.cloudData.boundingBox.max.z;
    const range = maxZ - minZ || 1;
    for (let i = 0; i < count; i++) {
      const z = positions[i * 3 + 2];
      const t = (z - minZ) / range;
      const value = 1 - t;
      colors[i * 3] = value;
      colors[i * 3 + 1] = value;
      colors[i * 3 + 2] = value;
    }
    this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply normal-based coloring
   */
  applyNormalColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.normals) {
      const normals = this.originalAttributes.normals;
      const count = normals.length / 3;
      const colors = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        colors[i * 3] = normals[i * 3] * 0.5 + 0.5;
        colors[i * 3 + 1] = normals[i * 3 + 1] * 0.5 + 0.5;
        colors[i * 3 + 2] = normals[i * 3 + 2] * 0.5 + 0.5;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    } else {
      console.warn("[PointCloudLayer] No normals available for normal coloring");
      this.material.uniforms.useUniformColor.value = 1;
      this.material.uniforms.uniformColor.value.set("#8080ff");
    }
    this.material.uniforms.useUniformColor.value = 0;
  }
  /**
   * Apply intensity-based coloring
   */
  applyIntensityColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.intensities) {
      const intensities = this.originalAttributes.intensities;
      const count = intensities.length;
      const colors = new Float32Array(count * 3);
      let min = Infinity, max = -Infinity;
      for (let i = 0; i < count; i++) {
        min = Math.min(min, intensities[i]);
        max = Math.max(max, intensities[i]);
      }
      if (this.cloudData.intensityRange) {
        min = Math.max(min, this.cloudData.intensityRange.min);
        max = Math.min(max, this.cloudData.intensityRange.max);
      }
      const range = max - min || 1;
      for (let i = 0; i < count; i++) {
        const t = (intensities[i] - min) / range;
        colors[i * 3] = t;
        colors[i * 3 + 1] = t;
        colors[i * 3 + 2] = t;
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No intensity data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  /**
   * Apply classification-based coloring (for LAS files)
   */
  applyClassificationColoring() {
    if (!this.geometry || !this.originalAttributes) return;
    if (this.originalAttributes.classifications) {
      const classifications = this.originalAttributes.classifications;
      const count = classifications.length;
      const colors = new Float32Array(count * 3);
      const classColors = {
        0: [0.5, 0.5, 0.5],
        // Never classified
        1: [0.5, 0.5, 0.5],
        // Unclassified
        2: [0.6, 0.4, 0.2],
        // Ground
        3: [0.2, 0.8, 0.2],
        // Low vegetation
        4: [0.1, 0.6, 0.1],
        // Medium vegetation
        5: [0, 0.4, 0],
        // High vegetation
        6: [0.9, 0.2, 0.2],
        // Building
        7: [0.5, 0.5, 0.5],
        // Low point (noise)
        8: [0.5, 0.5, 0.5],
        // Reserved
        9: [0.2, 0.4, 0.8],
        // Water
        10: [0.8, 0.6, 0.4],
        // Rail
        11: [0.3, 0.3, 0.3],
        // Road surface
        12: [0.5, 0.5, 0.5],
        // Reserved
        13: [0.8, 0.8, 0.2],
        // Wire - Guard
        14: [0.8, 0.6, 0.2],
        // Wire - Conductor
        15: [0.9, 0.9, 0.9],
        // Transmission Tower
        16: [0.6, 0.6, 0.8],
        // Wire - Connector
        17: [0.4, 0.4, 0.6],
        // Bridge Deck
        18: [0.9, 0.1, 0.1]
        // High Noise
      };
      for (let i = 0; i < count; i++) {
        const classId = classifications[i];
        const color = classColors[classId] ?? [0.5, 0.5, 0.5];
        colors[i * 3] = color[0];
        colors[i * 3 + 1] = color[1];
        colors[i * 3 + 2] = color[2];
      }
      this.geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      this.material.uniforms.useUniformColor.value = 0;
    } else {
      console.warn("[PointCloudLayer] No classification data available");
      this.material.uniforms.useUniformColor.value = 1;
    }
  }
  // ============================================================================
  // HELPERS
  // ============================================================================
  /**
   * Update bounding box helper
   */
  updateBoundingBoxHelper() {
    if (this.boundingBoxHelper) {
      this.group.remove(this.boundingBoxHelper);
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.cloudData.showBoundingBox && this.pointCloud) {
      this.boundingBoxHelper = new BoxHelper(this.pointCloud, 65280);
      this.boundingBoxHelper.name = `bbox_helper_${this.id}`;
      this.group.add(this.boundingBoxHelper);
    }
  }
  // ============================================================================
  // SETTERS
  // ============================================================================
  /**
   * Set point size
   */
  setPointSize(size) {
    if (this.material) {
      this.material.uniforms.pointSize.value = size;
    }
  }
  /**
   * Set opacity
   */
  setOpacity(opacity) {
    if (this.material) {
      this.material.uniforms.opacity.value = opacity;
    }
  }
  /**
   * Set uniform color
   */
  setUniformColor(color) {
    this.cloudData.uniformColor = color;
    if (this.material) {
      this.material.uniforms.uniformColor.value.set(color);
    }
  }
  /**
   * Set render mode
   */
  setRenderMode(mode) {
    this.cloudData.renderMode = mode;
    if (this.material) {
      this.material.uniforms.renderMode.value = this.getRenderModeValue();
    }
  }
  /**
   * Set bounding box visibility
   */
  setShowBoundingBox(show) {
    this.cloudData.showBoundingBox = show;
    this.updateBoundingBoxHelper();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get point count
   */
  getPointCount() {
    return this.cloudData.pointCount;
  }
  /**
   * Get point cloud-specific bounding box data
   */
  getPointCloudBoundingBox() {
    return this.cloudData.boundingBox;
  }
  /**
   * Check if loading
   */
  isPointCloudLoading() {
    return this.isLoading;
  }
  /**
   * Get load error
   */
  getLoadError() {
    return this.loadError;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(frame) {
    const size = interpolateProperty(this.cloudData.pointSize, frame);
    this.setPointSize(size);
    const opacity = interpolateProperty(this.cloudData.opacity, frame);
    this.setOpacity(opacity);
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.update();
    }
  }
  onApplyEvaluatedState(state) {
    const props = state.properties;
    if (props["pointSize"] !== void 0) {
      this.setPointSize(props["pointSize"]);
    }
    if (props["opacity"] !== void 0) {
      this.setOpacity(props["opacity"]);
    }
  }
  onUpdate(properties) {
    const data = properties.data;
    if (data) {
      if (data.assetId !== void 0 && data.assetId !== this.cloudData.assetId) {
        this.cloudData.assetId = data.assetId;
        if (data.format) {
          this.cloudData.format = data.format;
        }
        this.loadPointCloud();
      }
      if (data.colorMode !== void 0) {
        this.applyColorMode(data.colorMode);
      }
      if (data.uniformColor !== void 0) {
        this.setUniformColor(data.uniformColor);
      }
      if (data.renderMode !== void 0) {
        this.setRenderMode(data.renderMode);
      }
      if (data.showBoundingBox !== void 0) {
        this.setShowBoundingBox(data.showBoundingBox);
      }
      if (data.depthTest !== void 0 || data.depthWrite !== void 0) {
        if (this.material) {
          if (data.depthTest !== void 0) {
            this.material.depthTest = data.depthTest;
            this.cloudData.depthTest = data.depthTest;
          }
          if (data.depthWrite !== void 0) {
            this.material.depthWrite = data.depthWrite;
            this.cloudData.depthWrite = data.depthWrite;
          }
        }
      }
    }
  }
  onDispose() {
    this.disposePointCloud();
  }
  /**
   * Dispose point cloud resources
   */
  disposePointCloud() {
    if (this.boundingBoxHelper) {
      this.boundingBoxHelper.dispose();
      this.boundingBoxHelper = null;
    }
    if (this.material) {
      this.material.dispose();
      this.material = null;
    }
    if (this.geometry) {
      this.geometry.dispose();
      this.geometry = null;
    }
    this.originalAttributes = null;
    this.pointCloud = null;
  }
}

class LayerManager {
  scene;
  resources;
  layers;
  // Callbacks
  onVideoMetadataLoaded;
  nestedCompRenderContext = null;
  effectLayerRenderContext = null;
  cameraGetter;
  cameraAtFrameGetter;
  cameraUpdater;
  // Renderer reference for particle systems
  rendererRef = null;
  // Composition FPS for particle timing
  compositionFPS = 60;
  // Camera reference for particles
  cameraRef = null;
  // Audio reactive callback
  audioReactiveGetter = null;
  // Matte canvas cache - stores rendered canvases for layers used as matte sources
  matteCanvases = /* @__PURE__ */ new Map();
  // Ordered layer list for render order (respects track matte dependencies)
  renderOrder = [];
  // Callback to get cross-composition matte canvas
  crossCompMatteGetter = null;
  constructor(scene, resources) {
    this.scene = scene;
    this.resources = resources;
    this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(callback) {
    this.onVideoMetadataLoaded = callback;
  }
  /**
   * Set the nested comp render context
   * This allows nested comp layers to render nested compositions
   */
  setNestedCompRenderContext(context) {
    this.nestedCompRenderContext = context;
    for (const layer of this.layers.values()) {
      if (layer.type === "nestedComp") {
        layer.setRenderContext(context);
      }
    }
  }
  /**
   * Set the effect layer render context
   * This allows effect layers to render layers below them
   */
  setEffectLayerRenderContext(context) {
    this.effectLayerRenderContext = context;
    for (const layer of this.layers.values()) {
      const layerData = layer.layerData;
      if (layer.type === "solid" && (layerData?.effectLayer || layerData?.adjustmentLayer)) {
        layer.setRenderContext(context);
      }
    }
  }
  /** @deprecated Use setEffectLayerRenderContext instead */
  setAdjustmentRenderContext(context) {
    this.setEffectLayerRenderContext(context);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.cameraGetter = getter;
    this.cameraUpdater = updater;
    this.cameraAtFrameGetter = atFrameGetter;
    for (const layer of this.layers.values()) {
      if (layer.type === "camera") {
        layer.setCameraCallbacks(getter, updater, atFrameGetter);
      }
    }
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(renderer) {
    this.rendererRef = renderer;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setRenderer(renderer);
      }
    }
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(fps) {
    this.compositionFPS = fps;
    for (const layer of this.layers.values()) {
      if (layer.type === "particles") {
        layer.setFPS(fps);
      }
      if (layer.type === "video") {
        layer.setFPS(fps);
      }
      if (layer.type === "nestedComp") {
        layer.setFPS(fps);
      }
    }
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(camera) {
    this.cameraRef = camera;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(layerData) {
    if (this.layers.has(layerData.id)) {
      layerLogger.warn(`LayerManager: Layer ${layerData.id} already exists, updating instead`);
      this.update(layerData.id, layerData);
      return this.layers.get(layerData.id);
    }
    const layer = this.createLayerInstance(layerData);
    this.layers.set(layerData.id, layer);
    this.setupLayerCallbacks(layer, layerData);
    if (layerData.parentId) {
      const parentLayer = this.layers.get(layerData.parentId);
      if (parentLayer) {
        layer.setParent(parentLayer);
      }
    }
    if (!layer.hasParent()) {
      this.scene.addToComposition(layer.getObject());
    }
    return layer;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(layer, layerData) {
    if (layer.type === "video" && this.onVideoMetadataLoaded) {
      const videoLayer = layer;
      videoLayer.setMetadataCallback((metadata) => {
        this.onVideoMetadataLoaded(layerData.id, metadata);
      });
    }
    if (layer.type === "nestedComp" && this.nestedCompRenderContext) {
      const nestedCompLayer = layer;
      nestedCompLayer.setRenderContext(this.nestedCompRenderContext);
    }
    if (layer.type === "camera" && this.cameraGetter && this.cameraUpdater) {
      const cameraLayer = layer;
      cameraLayer.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter);
      cameraLayer.setSplineProvider(this.createSplineProvider());
    }
    if (layer.type === "particles") {
      const particleLayer = layer;
      if (this.rendererRef) {
        particleLayer.setRenderer(this.rendererRef);
      }
      particleLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "video") {
      const videoLayer = layer;
      videoLayer.setFPS(this.compositionFPS);
    }
    if (layer.type === "nestedComp") {
      const nestedCompLayer = layer;
      nestedCompLayer.setFPS(this.compositionFPS);
    }
    if ((layerData.effectLayer || layerData.adjustmentLayer) && this.effectLayerRenderContext) {
      if ("setRenderContext" in layer) {
        layer.setRenderContext(this.effectLayerRenderContext);
      }
    }
    if (layer.type === "light") {
      const lightLayer = layer;
      lightLayer.setLayerPositionGetter((layerId) => {
        const targetLayer = this.layers.get(layerId);
        if (targetLayer) {
          const obj = targetLayer.getObject();
          return new Vector3(obj.position.x, obj.position.y, obj.position.z);
        }
        return null;
      });
      lightLayer.setPathProvider(this.createSplineProvider());
    }
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(layerData) {
    switch (layerData.type) {
      case "image":
        return new ImageLayer(layerData, this.resources);
      case "solid":
        return new SolidLayer(layerData);
      case "control":
      case "null":
        return new ControlLayer(layerData);
      case "text":
        return new TextLayer(layerData, this.resources);
      case "spline":
        return new SplineLayer(layerData);
      case "particles":
        return new ParticleLayer(layerData);
      case "video":
        return new VideoLayer(layerData, this.resources);
      case "nestedComp":
        return new NestedCompLayer(layerData);
      case "camera":
        return new CameraLayer(layerData);
      case "light":
        return new LightLayer(layerData);
      case "depthflow":
        return new DepthflowLayer(layerData, this.resources);
      case "matte":
        return new ProceduralMatteLayer(layerData);
      case "shape":
        return new ShapeLayer(layerData);
      case "model":
        return new ModelLayer(layerData);
      case "pointcloud":
        return new PointCloudLayer(layerData);
      default:
        layerLogger.warn(`LayerManager: Unknown layer type: ${layerData.type}, creating ControlLayer`);
        return new ControlLayer(layerData);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(layerId, properties) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for update`);
      return;
    }
    layer.update(properties);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(updates) {
    for (const { id, properties } of updates) {
      this.update(id, properties);
    }
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(layerId) {
    const layer = this.layers.get(layerId);
    if (!layer) {
      layerLogger.warn(`LayerManager: Layer ${layerId} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(layer.getObject());
    layer.dispose();
    this.layers.delete(layerId);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(layerIds) {
    for (const id of layerIds) {
      this.remove(id);
    }
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [id, layer] of this.layers) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer state.
   * Layers receive already-computed values and only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * Rendering order:
   * 1. Spline layers (for text-on-path dependencies)
   * 2. Text-on-path connections
   * 3. Track matte source layers (render to canvas)
   * 4. All other layers (with track mattes applied)
   *
   * @param evaluatedLayers - Pre-evaluated layer states from MotionEngine
   * @param frame - Optional frame number for animated spline/mask evaluation
   */
  applyEvaluatedState(evaluatedLayers, frame) {
    const currentFrame = frame ?? 0;
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type === "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.updateTextPathConnections(frame);
    this.processTrackMattes(currentFrame);
    for (const evalLayer of evaluatedLayers) {
      const layer = this.layers.get(evalLayer.id);
      if (layer && layer.type !== "spline") {
        layer.applyEvaluatedState(evalLayer);
      }
    }
    this.scene.sortByZ();
  }
  /**
   * Evaluate all layers at a given frame
   *
   * @deprecated Use applyEvaluatedState() with pre-evaluated state from MotionEngine.
   * This method causes layers to internally call interpolateProperty(), violating
   * the single-source-of-truth principle.
   *
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(frame, audioReactiveGetter) {
    this.updateTextPathConnections(frame);
    this.processTrackMattes(frame);
    const getter = audioReactiveGetter ?? this.audioReactiveGetter;
    for (const layer of this.layers.values()) {
      if (getter) {
        const audioValues = getter(layer.id, frame);
        if (audioValues.size > 0) {
          layer.setAudioReactiveValues(audioValues);
        }
      }
      layer.evaluateFrame(frame);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setDrivenValues(values);
    }
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const layer of this.layers.values()) {
      layer.clearDrivenValues();
    }
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   *
   * For animated splines, this must be called with the current frame
   * to get properly evaluated control points.
   *
   * @param frame - Optional frame number for animated spline evaluation
   */
  updateTextPathConnections(frame) {
    for (const layer of this.layers.values()) {
      if (layer.type === "text") {
        const textLayer = layer;
        const textData = textLayer.getTextData();
        if (textData.pathLayerId) {
          const splineLayer = this.layers.get(textData.pathLayerId);
          if (splineLayer && splineLayer.type === "spline") {
            if (splineLayer.isAnimated() && frame !== void 0) {
              const evaluatedPoints = splineLayer.getEvaluatedControlPoints(frame);
              const controlPoints = evaluatedPoints.map((ep) => ({
                id: ep.id,
                x: ep.x,
                y: ep.y,
                depth: ep.depth,
                handleIn: ep.handleIn,
                handleOut: ep.handleOut,
                type: ep.type
              }));
              textLayer.setPathFromControlPoints(controlPoints, splineLayer.isClosed());
            } else {
              const curve = splineLayer.getCurve();
              if (curve) {
                textLayer.setPathFromCurve(curve);
              }
            }
          }
        }
      }
    }
  }
  // ============================================================================
  // SPLINE PATH PROVIDER (for Particle Systems)
  // ============================================================================
  /**
   * Create a SplinePathProvider that can be used by particle systems
   * to query spline positions for path-based emission
   *
   * USAGE:
   * ```typescript
   * const provider = layerManager.createSplineProvider();
   * particleSystem.setSplineProvider(provider);
   * ```
   */
  createSplineProvider() {
    return (layerId, t, frame) => {
      return this.querySplinePath(layerId, t, frame);
    };
  }
  /**
   * Query a spline layer for position and tangent at parameter t
   *
   * @param layerId - ID of the spline layer
   * @param t - Parameter along the path (0-1)
   * @param frame - Current frame for animated splines
   * @returns Position, tangent, and length or null if spline not found
   */
  querySplinePath(layerId, t, frame) {
    const layer = this.layers.get(layerId);
    if (!layer || layer.type !== "spline") {
      return null;
    }
    const splineLayer = layer;
    if (splineLayer.isAnimated()) {
      splineLayer.getEvaluatedControlPoints(frame);
    }
    const point = splineLayer.getPointAt(t);
    const tangent = splineLayer.getTangentAt(t);
    const length = splineLayer.getLength();
    if (!point || !tangent) {
      return null;
    }
    return {
      point: {
        x: point.x,
        y: -point.y,
        // Negate back from Three.js coordinate system
        z: point.z
      },
      tangent: {
        x: tangent.x,
        y: -tangent.y
        // Negate back
      },
      length
    };
  }
  /**
   * Get all spline layer IDs (useful for UI to list available paths)
   */
  getSplineLayerIds() {
    const ids = [];
    for (const [id, layer] of this.layers) {
      if (layer.type === "spline") {
        ids.push(id);
      }
    }
    return ids;
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(textLayerId, splineLayerId) {
    const textLayer = this.layers.get(textLayerId);
    if (!textLayer || textLayer.type !== "text") {
      layerLogger.warn(`LayerManager: Text layer ${textLayerId} not found`);
      return;
    }
    if (!splineLayerId) {
      textLayer.clearPath();
      return;
    }
    const splineLayer = this.layers.get(splineLayerId);
    if (!splineLayer || splineLayer.type !== "spline") {
      layerLogger.warn(`LayerManager: Spline layer ${splineLayerId} not found`);
      return;
    }
    const curve = splineLayer.getCurve();
    if (curve) {
      textLayer.setPathFromCurve(curve);
    }
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(layerId) {
    return this.layers.get(layerId)?.getObject() ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(layerId) {
    return this.layers.get(layerId) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(type) {
    return Array.from(this.layers.values()).filter(
      (layer) => layer.type === type
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(layerId) {
    return this.layers.has(layerId);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  /**
   * Get all layers as an array
   */
  getAllLayers() {
    return Array.from(this.layers.values());
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const layer of this.layers.values()) {
      if (layer.hasParent()) {
        const parent = layer.getParent();
        if (parent) {
          parent.getObject().remove(layer.getObject());
        }
      }
    }
    for (const layer of this.layers.values()) {
      const parentId = layer.getParentId();
      if (parentId) {
        const parentLayer = this.layers.get(parentId);
        if (parentLayer) {
          layer.setParent(parentLayer);
        } else {
          layer.setParent(null);
          this.scene.addToComposition(layer.getObject());
        }
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(layerId, parentId) {
    const layer = this.layers.get(layerId);
    if (!layer) return;
    if (layer.hasParent()) {
      const oldParent = layer.getParent();
      if (oldParent) {
        oldParent.getObject().remove(layer.getObject());
      }
    } else {
      this.scene.removeFromComposition(layer.getObject());
    }
    if (parentId) {
      const newParent = this.layers.get(parentId);
      if (newParent) {
        layer.setParent(newParent);
      } else {
        layer.setParent(null);
        this.scene.addToComposition(layer.getObject());
      }
    } else {
      layer.setParent(null);
      this.scene.addToComposition(layer.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(layerId, z) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.getObject().position.z = z;
      this.scene.sortByZ();
    }
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(layerId, visible) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setVisible(visible);
    }
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      const newVisible = !layer.getObject().visible;
      layer.setVisible(newVisible);
      return newVisible;
    }
    return false;
  }
  /**
   * Isolate a layer (hide all others)
   */
  isolateLayer(layerId) {
    for (const [id, layer] of this.layers) {
      layer.setVisible(id === layerId);
    }
  }
  /** @deprecated Use isolateLayer instead */
  soloLayer(layerId) {
    this.isolateLayer(layerId);
  }
  /**
   * Unisolate all layers (show all)
   */
  unisolateAll() {
    for (const layer of this.layers.values()) {
      layer.setVisible(true);
    }
  }
  /** @deprecated Use unisolateAll instead */
  unsoloAll() {
    this.unisolateAll();
  }
  // ============================================================================
  // TRACK MATTE PROCESSING
  // ============================================================================
  /**
   * Set callback for retrieving cross-composition matte canvases
   *
   * This enables track mattes from other compositions (nested comps)
   * to be used as matte sources.
   */
  setCrossCompMatteGetter(getter) {
    this.crossCompMatteGetter = getter;
  }
  /**
   * Process track mattes for all layers
   *
   * Track mattes use one layer's rendered output to control
   * another layer's visibility (alpha or luma).
   *
   * This method:
   * 1. Identifies layers that are used as track mattes
   * 2. Collects their rendered canvases (from same comp or cross-comp)
   * 3. Passes the canvas to layers that use them as mattes
   *
   * @param frame - Current frame number for animated evaluation
   */
  processTrackMattes(frame) {
    this.matteCanvases.clear();
    for (const layer of this.layers.values()) {
      const matteLayerId = layer.getTrackMatteLayerId();
      const matteType = layer.getTrackMatteType();
      if (!matteLayerId || matteType === "none") {
        continue;
      }
      let matteCanvas = null;
      if (layer.hasCrossCompMatte() && this.crossCompMatteGetter) {
        const compositionId = layer.getTrackMatteCompositionId();
        matteCanvas = this.crossCompMatteGetter(compositionId, matteLayerId, frame);
        if (!matteCanvas) {
          layerLogger.warn(
            `Cross-comp track matte not found: composition=${compositionId}, layer=${matteLayerId}`
          );
        }
      } else {
        const matteLayer = this.layers.get(matteLayerId);
        if (matteLayer) {
          if (this.matteCanvases.has(matteLayerId)) {
            matteCanvas = this.matteCanvases.get(matteLayerId);
          } else {
            matteCanvas = this.getLayerRenderedCanvas(matteLayer, frame);
            if (matteCanvas) {
              this.matteCanvases.set(matteLayerId, matteCanvas);
            }
          }
        } else {
          layerLogger.warn(`Matte source layer ${matteLayerId} not found`);
        }
      }
      layer.setTrackMatteCanvas(matteCanvas);
    }
  }
  /**
   * Get the rendered canvas from a layer (for use as track matte)
   *
   * This gets the layer's visual output as a canvas that can be used
   * for track matte operations.
   *
   * @param layer - The layer to get canvas from
   * @param frame - Current frame for animated content
   * @returns Canvas with layer's rendered content, or null if unavailable
   */
  getLayerRenderedCanvas(layer, frame) {
    const sourceCanvas = layer.getSourceCanvas?.();
    if (sourceCanvas) {
      const canvas = document.createElement("canvas");
      canvas.width = sourceCanvas.width;
      canvas.height = sourceCanvas.height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.drawImage(sourceCanvas, 0, 0);
        return canvas;
      }
    }
    return null;
  }
  /**
   * Update masks for a specific layer
   */
  setLayerMasks(layerId, masks) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setMasks(masks);
    }
  }
  /**
   * Clear track matte assignment for a layer
   */
  clearTrackMatte(layerId) {
    const layer = this.layers.get(layerId);
    if (layer) {
      layer.setTrackMatteCanvas(null);
    }
  }
  /**
   * Compute render order respecting track matte dependencies
   *
   * Matte layers must be rendered before the layers that use them.
   * This returns a topologically sorted list of layer IDs.
   */
  computeRenderOrder() {
    const order = [];
    const visited = /* @__PURE__ */ new Set();
    const visiting = /* @__PURE__ */ new Set();
    const visit = (layerId) => {
      if (visited.has(layerId)) return;
      if (visiting.has(layerId)) {
        layerLogger.warn(`Circular track matte dependency detected involving layer ${layerId}`);
        return;
      }
      visiting.add(layerId);
      const layer = this.layers.get(layerId);
      if (layer) {
        const matteLayerId = layer.getTrackMatteLayerId();
        if (matteLayerId && this.layers.has(matteLayerId)) {
          visit(matteLayerId);
        }
        const parentId = layer.getParentId();
        if (parentId && this.layers.has(parentId)) {
          visit(parentId);
        }
      }
      visiting.delete(layerId);
      visited.add(layerId);
      order.push(layerId);
    };
    for (const layerId of this.layers.keys()) {
      visit(layerId);
    }
    this.renderOrder = order;
    return order;
  }
  /**
   * Get the computed render order
   */
  getRenderOrder() {
    return this.renderOrder;
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(x, y, camera) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, camera);
    const intersects = this.scene.raycastComposition(raycaster);
    const layerIds = /* @__PURE__ */ new Set();
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          layerIds.add(obj.userData.layerId);
          break;
        }
        obj = obj.parent;
      }
    }
    return Array.from(layerIds).map((id) => this.layers.get(id)).filter((layer) => layer !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const layer of this.layers.values()) {
      this.scene.removeFromComposition(layer.getObject());
      layer.dispose();
    }
    this.layers.clear();
  }
}

/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
const ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
const DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI / 2;
const EPSILON = 1e-5;
const DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
  return approxZero(a - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;
  let output = target + (change + temp) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
class EventDispatcher {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
}
var _a;
const VERSION = "2.10.1";
const TOUCH_DOLLY_FACTOR = 1 / 8;
const isMac = /Mac/.test((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform);
let THREE;
let _ORIGIN;
let _AXIS_Y;
let _AXIS_Z;
let _v2;
let _v3A;
let _v3B;
let _v3C;
let _cameraDirection;
let _xColumn;
let _yColumn;
let _zColumn;
let _deltaTarget;
let _deltaOffset;
let _sphericalA;
let _sphericalB;
let _box3A;
let _box3B;
let _sphere;
let _quaternionA;
let _quaternionB;
let _rotationMatrix;
let _raycaster;
class CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(_) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset, screenSpacePanning) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = this.truckSpeed * deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = this.truckSpeed * deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (screenSpacePanning) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onPointerUp = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 || event.ctrlKey ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.SCREEN_PAN: {
          this._truckInternal(event.deltaX, event.deltaY, false, true);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true, false);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2);
      lastDragPosition.copy(_v2);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2);
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;
      lastDragPosition.copy(_v2);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.SCREEN_PAN) === ACTION.SCREEN_PAN || (this._state & ACTION.TOUCH_SCREEN_PAN) === ACTION.TOUCH_SCREEN_PAN || (this._state & ACTION.TOUCH_DOLLY_SCREEN_PAN) === ACTION.TOUCH_DOLLY_SCREEN_PAN || (this._state & ACTION.TOUCH_ZOOM_SCREEN_PAN) === ACTION.TOUCH_ZOOM_SCREEN_PAN) {
        this._truckInternal(deltaX, deltaY, false, true);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true, false);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2);
      lastDragPosition.copy(_v2);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      startDragging();
    };
    this.unlockPointer = () => {
      var _a2, _b, _c;
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      (_a2 = this._domElement) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument.exitPointerLock();
      (_b = this._domElement) === null || _b === void 0 ? void 0 : _b.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      (_c = this._domElement) === null || _c === void 0 ? void 0 : _c.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
      this.cancel();
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown);
      this._domElement.addEventListener("pointercancel", onPointerUp);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isObject3D = "isObject3D" in sphereOrMesh;
    const boundingSphere = isObject3D ? CameraControls.createBoundingSphere(sphereOrMesh, _sphere) : _sphere.copy(sphereOrMesh);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = out || new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd);
    this._target.copy(this._targetEnd);
    this._spherical.copy(this._sphericalEnd);
    this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
      this._camera.updateMatrixWorld();
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin, rayDirection);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      if (!mesh.geometry)
        return;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l = position.count; i < l; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
}

CameraControls.install({ THREE: THREE$1 });
class CameraController {
  /** The main camera */
  camera;
  /** Camera controls for 3D navigation (camera-controls library) */
  cameraControls = null;
  /** Clock for camera-controls delta time */
  clock = new Clock();
  /** Keyframe evaluator for animations */
  evaluator;
  /** Composition dimensions */
  width;
  height;
  /** Default camera state for reset */
  defaultPosition;
  defaultTarget;
  defaultFov = 50;
  /** Animation properties */
  positionProp;
  targetProp;
  fovProp;
  /** Current target position (for lookAt) */
  target;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.evaluator = new KeyframeEvaluator();
    console.log(`[CameraController] constructor: comp=${width}x${height}`);
    this.camera = new PerspectiveCamera(
      this.defaultFov,
      // Field of view
      width / height,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = height / 2 / Math.tan(fovRad / 2);
    this.defaultPosition = new Vector3(width / 2, -height / 2, distance);
    this.defaultTarget = new Vector3(width / 2, -height / 2, 0);
    this.camera.position.copy(this.defaultPosition);
    this.target = this.defaultTarget.clone();
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // CAMERA CONTROLS (3D Navigation)
  // ============================================================================
  /**
   * Enable camera controls for 3D navigation
   * Uses camera-controls library for smooth transitions
   * @param domElement The canvas element to attach controls to
   */
  enableOrbitControls(domElement) {
    if (this.cameraControls) {
      this.cameraControls.dispose();
    }
    this.cameraControls = new CameraControls(this.camera, domElement);
    this.cameraControls.mouseButtons.left = CameraControls.ACTION.NONE;
    this.cameraControls.mouseButtons.middle = CameraControls.ACTION.TRUCK;
    this.cameraControls.mouseButtons.right = CameraControls.ACTION.ROTATE;
    this.cameraControls.mouseButtons.wheel = CameraControls.ACTION.NONE;
    this.cameraControls.setTarget(this.target.x, this.target.y, this.target.z, false);
    this.cameraControls.smoothTime = 0.15;
    this.cameraControls.draggingSmoothTime = 0.1;
    this.cameraControls.minDistance = 10;
    this.cameraControls.maxDistance = 5e4;
    this.cameraControls.minPolarAngle = 0.01;
    this.cameraControls.maxPolarAngle = Math.PI - 0.01;
    this.cameraControls.azimuthRotateSpeed = 0.5;
    this.cameraControls.polarRotateSpeed = 0.5;
    this.cameraControls.truckSpeed = 2;
    this.resetToDefault();
    console.log("[CameraController] Camera controls enabled (camera-controls library, smooth transitions)");
  }
  /**
   * Disable camera controls
   */
  disableOrbitControls() {
    if (this.cameraControls) {
      this.cameraControls.dispose();
      this.cameraControls = null;
    }
  }
  /**
   * Update camera controls (call in animation loop)
   * Returns true if camera is still moving (for render optimization)
   */
  updateOrbitControls() {
    if (this.cameraControls) {
      const delta = this.clock.getDelta();
      const hasUpdated = this.cameraControls.update(delta);
      const target = this.cameraControls.getTarget(new Vector3());
      this.target.copy(target);
      return hasUpdated;
    }
    return false;
  }
  /**
   * Reset camera to default viewing position - PERFECT 2D FRONT VIEW
   * Camera looks straight at composition center, no rotation/tilt
   * This is the "Sync to Home" state - as if there's no 3D at all
   */
  resetToDefault() {
    const fovRad = MathUtils.degToRad(this.defaultFov);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    const centerX = this.width / 2;
    const centerY = -this.height / 2;
    this.camera.position.set(centerX, centerY, distance);
    this.target.set(centerX, centerY, 0);
    this.camera.fov = this.defaultFov;
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
    if (this.cameraControls) {
      this.cameraControls.setLookAt(
        this.camera.position.x,
        this.camera.position.y,
        this.camera.position.z,
        this.target.x,
        this.target.y,
        this.target.z,
        false
        // No animation
      );
    }
    this.zoomLevel = 1;
    this.panOffset.set(0, 0);
    console.log(`[CameraController] resetToDefault: comp=${this.width}x${this.height}, center=(${centerX}, ${centerY}), cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${distance.toFixed(1)}), fov=${this.defaultFov}, aspect=${this.camera.aspect.toFixed(3)}`);
  }
  /**
   * Check if camera controls are enabled
   */
  hasOrbitControls() {
    return this.cameraControls !== null;
  }
  /**
   * Set the camera controls target point (the point camera orbits around)
   * This updates the orbit pivot without moving the camera
   * @param x - X position (screen coordinates)
   * @param y - Y position (screen coordinates - will be negated)
   * @param z - Z position
   * @param animate - Whether to animate the transition (default: false)
   */
  setOrbitTarget(x, y, z, animate = false) {
    this.target.set(x, -y, z);
    if (this.cameraControls) {
      this.cameraControls.setTarget(this.target.x, this.target.y, this.target.z, animate);
    }
  }
  /**
   * Reset orbit target to composition center
   */
  resetOrbitTargetToCenter() {
    const centerX = this.width / 2;
    const centerY = this.height / 2;
    this.setOrbitTarget(centerX, centerY, 0);
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera position directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setPositionDirect(x, y, z) {
    this.camera.position.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera target directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setTargetDirect(x, y, z) {
    this.target.set(x, -y, z);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(x, y, z) {
    this.camera.rotation.set(
      MathUtils.degToRad(x),
      MathUtils.degToRad(y),
      MathUtils.degToRad(z)
    );
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(fov) {
    this.camera.fov = MathUtils.clamp(fov, 1, 179);
    this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(near, far) {
    this.camera.near = Math.max(1e-3, near);
    this.camera.far = Math.max(this.camera.near + 1, far);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEWPORT ZOOM/PAN
  // ============================================================================
  /** Pan offset for viewport navigation */
  panOffset = new Vector2(0, 0);
  zoomLevel = 1;
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(zoom) {
    this.zoomLevel = Math.max(0.1, Math.min(10, zoom));
    this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation (in WORLD units, not screen pixels)
   * Positive X pans right (camera moves left), positive Y pans down (camera moves up)
   */
  setPan(x, y) {
    this.panOffset.set(x, y);
    this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   * When camera controls are active and user has rotated, preserve the rotation.
   * Otherwise, use straight-on 2D view.
   */
  updateCameraForViewport() {
    if (this.cameraControls && this.orbitEnabled) {
      const fovRad2 = MathUtils.degToRad(this.camera.fov);
      const baseDistance2 = this.height / 2 / Math.tan(fovRad2 / 2);
      this.spherical.radius = baseDistance2 / this.zoomLevel;
      this.updateCameraFromSpherical();
      return;
    }
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const baseDistance = this.height / 2 / Math.tan(fovRad / 2);
    const distance = baseDistance / this.zoomLevel;
    const compositionCenterX = this.width / 2;
    const compositionCenterY = -this.height / 2;
    const cameraPosX = compositionCenterX + this.panOffset.x;
    const cameraPosY = compositionCenterY - this.panOffset.y;
    this.camera.position.set(cameraPosX, cameraPosY, distance);
    this.target.set(cameraPosX, cameraPosY, 0);
    this.camera.up.set(0, 1, 0);
    this.camera.lookAt(this.target);
    this.camera.rotation.z = 0;
    this.camera.updateProjectionMatrix();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the primary method for centering - calculates the right zoom to fit
   * @param viewportWidth - The viewport width in pixels
   * @param viewportHeight - The viewport height in pixels
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitToViewport(viewportWidth, viewportHeight, padding = 40) {
    const availableWidth = viewportWidth - padding * 2;
    const availableHeight = viewportHeight - padding * 2;
    const scaleX = availableWidth / this.width;
    const scaleY = availableHeight / this.height;
    const fitZoom = Math.min(scaleX, scaleY, 1);
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
    this.zoomLevel = fitZoom;
    this.panOffset.set(0, 0);
    this.updateCameraForViewport();
    console.log(`[CameraController] fitToViewport: viewport=${viewportWidth}x${viewportHeight}, comp=${this.width}x${this.height}, zoom=${fitZoom.toFixed(3)}, cam=(${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)})`);
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(props) {
    this.positionProp = props.position;
    this.targetProp = props.target;
    this.fovProp = props.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0;
    this.targetProp = void 0;
    this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(frame) {
    if (this.positionProp) {
      const pos = this.evaluator.evaluate(this.positionProp, frame);
      this.setPosition(pos.x, pos.y, pos.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const target = this.evaluator.evaluate(this.targetProp, frame);
      this.setTarget(target.x, target.y, target.z ?? 0);
    }
    if (this.fovProp) {
      const fov = this.evaluator.evaluate(this.fovProp, frame);
      this.setFOV(fov);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new COMPOSITION dimensions
   * Note: The aspect ratio should be set separately using setViewportAspect()
   */
  resize(width, height) {
    console.log(`[CameraController] resize: NEW comp=${width}x${height} (was ${this.width}x${this.height})`);
    this.width = width;
    this.height = height;
    this.resetToDefault();
  }
  /**
   * Set camera aspect ratio to match viewport dimensions
   * This should be called with VIEWPORT dimensions, not composition
   */
  setViewportAspect(viewportWidth, viewportHeight) {
    this.camera.aspect = viewportWidth / viewportHeight;
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(screenX, screenY, z = 0) {
    const ndcX = screenX / this.width * 2 - 1;
    const ndcY = -(screenY / this.height) * 2 + 1;
    const vector = new Vector3(ndcX, ndcY, 0.5);
    vector.unproject(this.camera);
    const dir = vector.sub(this.camera.position).normalize();
    const distance = (z - this.camera.position.z) / dir.z;
    return this.camera.position.clone().add(dir.multiplyScalar(distance));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(worldX, worldY, worldZ = 0) {
    const vector = new Vector3(worldX, -worldY, worldZ);
    vector.project(this.camera);
    return {
      x: (vector.x + 1) / 2 * this.width,
      y: (-vector.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(state) {
    if (state.position) {
      this.setPosition(state.position.x, state.position.y, state.position.z);
    }
    if (state.target) {
      this.setTarget(state.target.x, state.target.y, state.target.z);
    }
    if (state.fov !== void 0) {
      this.setFOV(state.fov);
    }
    if (state.near !== void 0 || state.far !== void 0) {
      this.setClipPlanes(
        state.near ?? this.camera.near,
        state.far ?? this.camera.far
      );
    }
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const fovRad = MathUtils.degToRad(50);
    const distance = this.height / 2 / Math.tan(fovRad / 2);
    this.camera.fov = 50;
    this.camera.position.set(this.width / 2, -this.height / 2, distance);
    this.target.set(this.width / 2, -this.height / 2, 0);
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const ortho = new OrthographicCamera(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    ortho.position.set(0, 0, 1e3);
    ortho.lookAt(0, 0, 0);
    return ortho;
  }
  // ============================================================================
  // 3D ORBIT CONTROLS
  // ============================================================================
  /** Current spherical coordinates for orbit mode */
  spherical = { radius: 1e3, theta: 0, phi: Math.PI / 2 };
  /** Whether orbit mode is enabled */
  orbitEnabled = false;
  /**
   * Enable orbit mode for 3D navigation
   * In orbit mode, the camera orbits around the target point
   */
  enableOrbitMode() {
    this.orbitEnabled = true;
    const offset = new Vector3().subVectors(this.camera.position, this.target);
    this.spherical.radius = offset.length();
    this.spherical.theta = Math.atan2(offset.x - this.target.x, offset.z);
    this.spherical.phi = Math.acos(MathUtils.clamp(offset.y / this.spherical.radius, -1, 1));
  }
  /**
   * Disable orbit mode (return to pan/zoom mode)
   */
  disableOrbitMode() {
    this.orbitEnabled = false;
  }
  /**
   * Check if orbit mode is active
   */
  isOrbitMode() {
    return this.orbitEnabled;
  }
  /**
   * Orbit camera around target point
   * @param deltaTheta - Horizontal rotation in radians (around Y axis)
   * @param deltaPhi - Vertical rotation in radians (around X axis)
   */
  orbit(deltaTheta, deltaPhi) {
    if (!this.orbitEnabled) return;
    this.spherical.theta -= deltaTheta;
    this.spherical.phi = MathUtils.clamp(
      this.spherical.phi - deltaPhi,
      0.01,
      // Prevent flipping at poles
      Math.PI - 0.01
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Dolly (zoom in/out) in orbit mode
   * @param delta - Positive to zoom in, negative to zoom out
   */
  dolly(delta) {
    if (!this.orbitEnabled) {
      this.setZoom(this.zoomLevel * (1 + delta * 0.1));
      return;
    }
    this.spherical.radius = MathUtils.clamp(
      this.spherical.radius * (1 - delta * 0.1),
      10,
      // Minimum distance
      5e4
      // Maximum distance
    );
    this.updateCameraFromSpherical();
  }
  /**
   * Pan camera in orbit mode (move target point)
   * @param deltaX - Horizontal pan in screen pixels
   * @param deltaY - Vertical pan in screen pixels
   */
  orbitPan(deltaX, deltaY) {
    if (!this.orbitEnabled) {
      this.setPan(this.panOffset.x + deltaX, this.panOffset.y + deltaY);
      return;
    }
    const panSpeed = this.spherical.radius * 1e-3;
    const right = new Vector3();
    const up = new Vector3();
    right.setFromMatrixColumn(this.camera.matrix, 0);
    up.setFromMatrixColumn(this.camera.matrix, 1);
    const panOffset = new Vector3();
    panOffset.addScaledVector(right, -deltaX * panSpeed);
    panOffset.addScaledVector(up, deltaY * panSpeed);
    this.target.add(panOffset);
    this.updateCameraFromSpherical();
  }
  /**
   * Update camera position from spherical coordinates
   */
  updateCameraFromSpherical() {
    const x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
    const y = this.spherical.radius * Math.cos(this.spherical.phi);
    const z = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
    this.camera.position.set(
      this.target.x + x,
      this.target.y + y,
      this.target.z + z
    );
    this.camera.lookAt(this.target);
    this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // VIEW PRESETS
  // ============================================================================
  /**
   * Available orthographic view presets
   */
  static VIEW_PRESETS = {
    front: { theta: 0, phi: Math.PI / 2, name: "Front" },
    back: { theta: Math.PI, phi: Math.PI / 2, name: "Back" },
    left: { theta: -Math.PI / 2, phi: Math.PI / 2, name: "Left" },
    right: { theta: Math.PI / 2, phi: Math.PI / 2, name: "Right" },
    top: { theta: 0, phi: 0.01, name: "Top" },
    bottom: { theta: 0, phi: Math.PI - 0.01, name: "Bottom" },
    perspective: { theta: Math.PI / 4, phi: Math.PI / 3, name: "Perspective" }
  };
  /**
   * Switch to a predefined view preset
   * @param preset - Name of the view preset
   * @param animate - Whether to animate the transition (default: false)
   */
  setViewPreset(preset, animate = false) {
    const view = CameraController.VIEW_PRESETS[preset];
    if (!view) return;
    if (!this.orbitEnabled) {
      this.enableOrbitMode();
    }
    if (animate) {
      const startTheta = this.spherical.theta;
      const startPhi = this.spherical.phi;
      const targetTheta = view.theta;
      const targetPhi = view.phi;
      const duration = 300;
      const startTime = performance.now();
      const animateView = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.spherical.theta = startTheta + (targetTheta - startTheta) * eased;
        this.spherical.phi = startPhi + (targetPhi - startPhi) * eased;
        this.updateCameraFromSpherical();
        if (t < 1) {
          requestAnimationFrame(animateView);
        }
      };
      requestAnimationFrame(animateView);
    } else {
      this.spherical.theta = view.theta;
      this.spherical.phi = view.phi;
      this.updateCameraFromSpherical();
    }
  }
  /**
   * Reset camera to default 2D view (centered on composition)
   */
  resetTo2DView() {
    this.disableOrbitMode();
    this.panOffset.set(0, 0);
    this.zoomLevel = 1;
    this.reset();
  }
  /**
   * Reset orbit to center on composition
   */
  resetOrbit() {
    this.target.set(this.width / 2, -this.height / 2, 0);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    this.spherical.radius = this.height / 2 / Math.tan(fovRad / 2);
    this.spherical.theta = 0;
    this.spherical.phi = Math.PI / 2;
    if (this.orbitEnabled) {
      this.updateCameraFromSpherical();
    } else {
      this.reset();
    }
  }
  // ============================================================================
  // FOCUS & FRAMING
  // ============================================================================
  /**
   * Focus camera on a bounding box, framing it in view
   * @param bounds - { min: {x, y, z}, max: {x, y, z} }
   */
  focusOnBounds(bounds) {
    const center = new Vector3(
      (bounds.min.x + bounds.max.x) / 2,
      -(bounds.min.y + bounds.max.y) / 2,
      // Negate for screen coords
      (bounds.min.z + bounds.max.z) / 2
    );
    const size = new Vector3(
      bounds.max.x - bounds.min.x,
      bounds.max.y - bounds.min.y,
      bounds.max.z - bounds.min.z
    );
    const maxDim = Math.max(size.x, size.y, size.z);
    const fovRad = MathUtils.degToRad(this.camera.fov);
    const distance = maxDim / 2 / Math.tan(fovRad / 2) * 1.5;
    this.target.copy(center);
    if (this.orbitEnabled) {
      this.spherical.radius = distance;
      this.updateCameraFromSpherical();
    } else {
      this.camera.position.set(center.x, center.y, center.z + distance);
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
  }
  /**
   * Focus on a layer by its bounding rect
   * @param x - Layer X position
   * @param y - Layer Y position
   * @param width - Layer width
   * @param height - Layer height
   * @param z - Layer Z position (default 0)
   */
  focusOnLayer(x, y, width, height, z = 0) {
    this.focusOnBounds({
      min: { x, y, z: z - 10 },
      max: { x: x + width, y: y + height, z: z + 10 }
    });
  }
  // ============================================================================
  // CAMERA BOOKMARKS
  // ============================================================================
  /** Stored camera bookmarks */
  bookmarks = /* @__PURE__ */ new Map();
  /**
   * Save current camera state as a bookmark
   * @param name - Name for the bookmark
   */
  saveBookmark(name) {
    this.bookmarks.set(name, {
      position: this.camera.position.clone(),
      target: this.target.clone(),
      spherical: { ...this.spherical },
      fov: this.camera.fov,
      orbitEnabled: this.orbitEnabled
    });
  }
  /**
   * Load a saved camera bookmark
   * @param name - Name of the bookmark
   * @param animate - Whether to animate transition
   */
  loadBookmark(name, animate = false) {
    const bookmark = this.bookmarks.get(name);
    if (!bookmark) return false;
    if (animate) {
      const startPos = this.camera.position.clone();
      const startTarget = this.target.clone();
      const startFov = this.camera.fov;
      const duration = 500;
      const startTime = performance.now();
      const animateBookmark = (currentTime) => {
        const elapsed = currentTime - startTime;
        const t = Math.min(elapsed / duration, 1);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        this.camera.position.lerpVectors(startPos, bookmark.position, eased);
        this.target.lerpVectors(startTarget, bookmark.target, eased);
        this.camera.fov = startFov + (bookmark.fov - startFov) * eased;
        this.camera.lookAt(this.target);
        this.camera.updateProjectionMatrix();
        if (t < 1) {
          requestAnimationFrame(animateBookmark);
        } else {
          this.spherical = { ...bookmark.spherical };
          this.orbitEnabled = bookmark.orbitEnabled;
        }
      };
      requestAnimationFrame(animateBookmark);
    } else {
      this.camera.position.copy(bookmark.position);
      this.target.copy(bookmark.target);
      this.camera.fov = bookmark.fov;
      this.spherical = { ...bookmark.spherical };
      this.orbitEnabled = bookmark.orbitEnabled;
      this.camera.lookAt(this.target);
      this.camera.updateProjectionMatrix();
    }
    return true;
  }
  /**
   * Delete a bookmark
   * @param name - Name of the bookmark
   */
  deleteBookmark(name) {
    return this.bookmarks.delete(name);
  }
  /**
   * Get list of bookmark names
   */
  getBookmarkNames() {
    return Array.from(this.bookmarks.keys());
  }
  /**
   * Export all bookmarks as JSON-serializable data
   */
  exportBookmarks() {
    const result = {};
    this.bookmarks.forEach((value, key) => {
      result[key] = {
        position: { x: value.position.x, y: value.position.y, z: value.position.z },
        target: { x: value.target.x, y: value.target.y, z: value.target.z },
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      };
    });
    return result;
  }
  /**
   * Import bookmarks from JSON data
   */
  importBookmarks(data) {
    Object.entries(data).forEach(([name, value]) => {
      this.bookmarks.set(name, {
        position: new Vector3(value.position.x, value.position.y, value.position.z),
        target: new Vector3(value.target.x, value.target.y, value.target.z),
        spherical: value.spherical,
        fov: value.fov,
        orbitEnabled: value.orbitEnabled
      });
    });
  }
}

class ResourceManager {
  // Texture cache (keyed by URL or ID)
  textures;
  // Geometry cache (keyed by type and parameters)
  geometries;
  // Material cache (keyed by configuration hash)
  materials;
  // Texture loader
  textureLoader;
  // Asset getter callback (set by WeylEngine)
  assetGetter;
  // Statistics
  stats = {
    texturesLoaded: 0,
    texturesFromCache: 0,
    geometriesCreated: 0,
    geometriesFromCache: 0
  };
  constructor() {
    this.textures = /* @__PURE__ */ new Map();
    this.geometries = /* @__PURE__ */ new Map();
    this.materials = /* @__PURE__ */ new Map();
    this.textureLoader = new TextureLoader();
    this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(getter) {
    this.assetGetter = getter;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(assetId) {
    return this.assetGetter?.(assetId);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const plane = new PlaneGeometry(1, 1, 1, 1);
    this.geometries.set("plane:1:1", plane);
    const quad = new PlaneGeometry(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", quad);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(url, options) {
    const cacheKey = this.getTextureCacheKey(url, options);
    const cached = this.textures.get(cacheKey);
    if (cached) {
      this.stats.texturesFromCache++;
      return cached;
    }
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.applyTextureOptions(texture, options);
          this.textures.set(cacheKey, texture);
          this.stats.texturesLoaded++;
          resolve(texture);
        },
        void 0,
        // Progress callback
        (error) => {
          renderLogger.error("ResourceManager: Failed to load texture:", url, error);
          reject(error);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(imageData, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof DataTexture) {
      cached.image = imageData;
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new DataTexture(
      imageData.data,
      imageData.width,
      imageData.height,
      RGBAFormat,
      UnsignedByteType
    );
    this.applyTextureOptions(texture, options);
    texture.needsUpdate = true;
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(canvas, id, options) {
    const cached = this.textures.get(id);
    if (cached instanceof CanvasTexture) {
      cached.needsUpdate = true;
      return cached;
    }
    const texture = new CanvasTexture(canvas);
    this.applyTextureOptions(texture, options);
    this.textures.set(id, texture);
    this.stats.texturesLoaded++;
    return texture;
  }
  /**
   * Get a cached texture
   */
  getTexture(key) {
    return this.textures.get(key);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(texture, options) {
    if (!options) {
      texture.minFilter = LinearFilter;
      texture.magFilter = LinearFilter;
      texture.generateMipmaps = false;
      texture.colorSpace = SRGBColorSpace;
      return;
    }
    if (options.wrapS !== void 0) texture.wrapS = options.wrapS;
    if (options.wrapT !== void 0) texture.wrapT = options.wrapT;
    if (options.minFilter !== void 0) texture.minFilter = options.minFilter;
    if (options.magFilter !== void 0) texture.magFilter = options.magFilter;
    if (options.generateMipmaps !== void 0) texture.generateMipmaps = options.generateMipmaps;
    if (options.flipY !== void 0) texture.flipY = options.flipY;
    if (options.colorSpace !== void 0) texture.colorSpace = options.colorSpace;
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(url, options) {
    if (!options) return url;
    return `${url}:${JSON.stringify(options)}`;
  }
  /**
   * Release a texture
   */
  releaseTexture(key) {
    const texture = this.textures.get(key);
    if (texture) {
      texture.dispose();
      this.textures.delete(key);
    }
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(layerId) {
    const layerKey = `layer:${layerId}`;
    const layerTexture = this.textures.get(layerKey);
    if (layerTexture) {
      return layerTexture;
    }
    return null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(layerId, texture) {
    const key = `layer:${layerId}`;
    this.textures.set(key, texture);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(width = 1, height = 1) {
    const key = `plane:${width}:${height}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new PlaneGeometry(width, height, 1, 1);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(radius = 1, segments = 32) {
    const key = `circle:${radius}:${segments}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new CircleGeometry(radius, segments);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(width = 1, height = 1, depth = 1) {
    const key = `box:${width}:${height}:${depth}`;
    let geometry = this.geometries.get(key);
    if (geometry) {
      this.stats.geometriesFromCache++;
      return geometry;
    }
    geometry = new BoxGeometry(width, height, depth);
    this.geometries.set(key, geometry);
    this.stats.geometriesCreated++;
    return geometry;
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(options) {
    const key = `basic:${JSON.stringify(options)}`;
    let material = this.materials.get(key);
    if (material) {
      return material;
    }
    material = new MeshBasicMaterial({
      color: options.color ?? 16777215,
      transparent: options.transparent ?? true,
      opacity: options.opacity ?? 1,
      map: options.map,
      side: options.side ?? DoubleSide
    });
    this.materials.set(key, material);
    return material;
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(type) {
    switch (type) {
      case "basic":
        return new MeshBasicMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "standard":
        return new MeshStandardMaterial({
          transparent: true,
          side: DoubleSide
        });
      case "shader":
        return new ShaderMaterial();
      default:
        return new MeshBasicMaterial();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const texture of this.textures.values()) {
      texture.dispose();
    }
    this.textures.clear();
    for (const geometry of this.geometries.values()) {
      geometry.dispose();
    }
    this.geometries.clear();
    for (const material of this.materials.values()) {
      material.dispose();
    }
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    renderLogger.debug("ResourceManager: Resource stats:", this.getStats());
  }
}

class PerformanceMonitor {
  // Frame timing
  frameCount = 0;
  lastTime = 0;
  frameTimes = [];
  maxFrameTimes = 60;
  // FPS calculation
  fps = 0;
  fpsUpdateInterval = 500;
  // ms
  lastFpsUpdate = 0;
  framesInInterval = 0;
  // Frame start time (for measuring frame duration)
  frameStartTime = 0;
  // Last captured stats
  lastStats = {
    fps: 0,
    frameTime: 0,
    drawCalls: 0,
    triangles: 0,
    textures: 0,
    geometries: 0,
    memoryUsed: 0
  };
  constructor() {
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(renderer) {
    const now = performance.now();
    const frameTime = now - this.frameStartTime;
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxFrameTimes) {
      this.frameTimes.shift();
    }
    this.frameCount++;
    this.framesInInterval++;
    const timeSinceUpdate = now - this.lastFpsUpdate;
    if (timeSinceUpdate >= this.fpsUpdateInterval) {
      this.fps = Math.round(this.framesInInterval * 1e3 / timeSinceUpdate);
      this.framesInInterval = 0;
      this.lastFpsUpdate = now;
    }
    const info = renderer.info;
    const memory = performance.memory;
    const memoryUsed = memory?.usedJSHeapSize ?? 0;
    const avgFrameTime = this.frameTimes.length > 0 ? this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length : 0;
    this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(avgFrameTime * 100) / 100,
      drawCalls: info.render.calls,
      triangles: info.render.triangles,
      textures: info.memory.textures,
      geometries: info.memory.geometries,
      memoryUsed
    };
    this.lastTime = now;
    return this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    if (this.frameTimes.length === 0) return 0;
    return this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    if (this.frameTimes.length === 0) {
      return { min: 0, max: 0 };
    }
    return {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0;
    this.frameTimes = [];
    this.fps = 0;
    this.framesInInterval = 0;
    this.lastTime = performance.now();
    this.lastFpsUpdate = this.lastTime;
    this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(targetFps = 30) {
    return this.fps > 0 && this.fps < targetFps;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const stats = this.lastStats;
    const range = this.getFrameTimeRange();
    return [
      `FPS: ${stats.fps}`,
      `Frame Time: ${stats.frameTime.toFixed(2)}ms (min: ${range.min.toFixed(2)}, max: ${range.max.toFixed(2)})`,
      `Draw Calls: ${stats.drawCalls}`,
      `Triangles: ${stats.triangles.toLocaleString()}`,
      `Textures: ${stats.textures}`,
      `Geometries: ${stats.geometries}`,
      `Memory: ${(stats.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join("\n");
  }
}

class WeylEngine {
  // Core subsystems
  scene;
  renderer;
  layers;
  camera;
  resources;
  performance;
  // State
  state;
  animationFrameId = null;
  // Background and overlay images
  backgroundImage = null;
  depthMapMesh = null;
  depthMapSettings = { colormap: "viridis", opacity: 0.5, visible: false };
  // Viewport transform for pan/zoom
  viewportTransform = [1, 0, 0, 1, 0, 0];
  // Render mode
  renderMode = "color";
  // Audio reactivity
  audioReactiveGetter = null;
  // Transform controls for layer manipulation
  transformControls = null;
  selectedLayerId = null;
  transformMode = "translate";
  // Transform change callback
  onTransformChange = null;
  // Event system
  eventHandlers;
  // WebGL context event handlers (stored for cleanup)
  contextLostHandler = null;
  contextRestoredHandler = null;
  // Configuration
  config;
  constructor(config) {
    this.validateConfig(config);
    this.config = {
      canvas: config.canvas,
      width: config.width,
      height: config.height,
      compositionWidth: config.compositionWidth ?? config.width,
      compositionHeight: config.compositionHeight ?? config.height,
      pixelRatio: config.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: config.antialias ?? true,
      alpha: config.alpha ?? true,
      backgroundColor: config.backgroundColor ?? null,
      debug: config.debug ?? false,
      powerPreference: config.powerPreference ?? "high-performance"
    };
    this.state = {
      currentFrame: 0,
      // DEPRECATED: Use MotionEngine as time authority
      isRendering: false,
      isDisposed: false,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    };
    this.eventHandlers = /* @__PURE__ */ new Map();
    this.resources = new ResourceManager();
    this.scene = new SceneManager(this.config.backgroundColor);
    this.camera = new CameraController(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.camera.setViewportAspect(this.config.width, this.config.height);
    this.renderer = new RenderPipeline({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera);
    this.layers = new LayerManager(this.scene, this.resources);
    this.performance = new PerformanceMonitor();
    this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    );
    this.setupContextLossHandling();
    if (this.config.debug) {
      engineLogger.debug("Initialized", this.config);
    }
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(config) {
    if (!(config.canvas instanceof HTMLCanvasElement)) {
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    }
    if (config.width <= 0 || config.height <= 0) {
      throw new Error("WeylEngine requires positive width and height");
    }
    if (config.width > 8192 || config.height > 8192) {
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
    }
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(layerData) {
    this.assertNotDisposed();
    this.layers.create(layerData);
    this.emit("layerAdded", { layerId: layerData.id });
    if (this.config.debug) {
      engineLogger.debug("Layer added:", layerData.id, layerData.type);
    }
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(layerId, properties) {
    this.assertNotDisposed();
    this.layers.update(layerId, properties);
    this.emit("layerUpdated", { layerId, properties });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(layerId) {
    this.assertNotDisposed();
    this.layers.remove(layerId);
    this.emit("layerRemoved", { layerId });
    if (this.config.debug) {
      engineLogger.debug("Layer removed:", layerId);
    }
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(layerId) {
    return this.layers.getObject(layerId);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(layers) {
    this.assertNotDisposed();
    const existingIds = new Set(this.layers.getLayerIds());
    const newIds = new Set(layers.map((l) => l.id));
    for (const id of existingIds) {
      if (!newIds.has(id)) {
        this.layers.remove(id);
      }
    }
    for (const layer of layers) {
      if (existingIds.has(layer.id)) {
        this.layers.update(layer.id, layer);
      } else {
        this.layers.create(layer);
      }
    }
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(getter) {
    this.resources.setAssetGetter(getter);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(callback) {
    this.layers.setVideoMetadataCallback(callback);
  }
  /**
   * Set the nested comp render context for LayerManager
   * Allows nested comp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setNestedCompRenderContext(context) {
    this.layers.setNestedCompRenderContext(context);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(getter, updater, atFrameGetter) {
    this.layers.setCameraCallbacks(getter, updater, atFrameGetter);
    this.activeCameraGetter = getter;
  }
  // Active camera tracking
  activeCameraGetter;
  activeCameraId = null;
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(cameraLayerId) {
    this.activeCameraId = cameraLayerId;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter) {
      return;
    }
    const cameraLayer = this.layers.getLayer(this.activeCameraId);
    if (!cameraLayer || cameraLayer.type !== "camera") {
      return;
    }
    const typedLayer = cameraLayer;
    const exportData = typedLayer.getExportData();
    if (!exportData) {
      return;
    }
    this.camera.setPosition(exportData.position.x, exportData.position.y, exportData.position.z);
    this.camera.setRotation(exportData.rotation.x, exportData.rotation.y, exportData.rotation.z);
    this.camera.setFOV(exportData.fov);
    this.camera.setClipPlanes(exportData.nearClip, exportData.farClip);
    const camera3d = typedLayer.getCameraAtCurrentFrame();
    if (camera3d && camera3d.depthOfField) {
      this.setDOFFromCamera(camera3d.depthOfField);
    }
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(fps) {
    this.layers.setCompositionFPS(fps);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer());
    this.layers.setCamera(this.camera.camera);
  }
  /**
   * Initialize all 3D services with WebGL renderer
   * This enables:
   * - Material system PMREM for environment map prefiltering
   * - Environment map support in SceneManager
   * Call this after engine construction for full 3D pipeline support
   */
  initialize3DServices() {
    const renderer = this.renderer.getWebGLRenderer();
    materialSystem.initialize(renderer);
    this.scene.initializeEnvironmentSupport(renderer);
    if (this.config.debug) {
      engineLogger.debug("3D services initialized");
    }
  }
  // ============================================================================
  // 3D SERVICE ACCESS
  // ============================================================================
  /**
   * Get the material system for PBR material management
   */
  getMaterialSystem() {
    return materialSystem;
  }
  /**
   * Get the SVG extrusion service for logo workflows
   */
  getSVGExtrusionService() {
    return svgExtrusionService;
  }
  /**
   * Get the mesh particle manager for custom particle shapes
   */
  getMeshParticleManager() {
    return meshParticleManager;
  }
  /**
   * Get the sprite sheet service for particle animations
   */
  getSpriteSheetService() {
    return spriteSheetService;
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const cam = this.camera.camera;
    return {
      projectionMatrix: cam.projectionMatrix.clone(),
      viewMatrix: cam.matrixWorldInverse.clone(),
      projectionMatrixInverse: cam.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(layerId, values) {
    this.layers.setLayerDrivenValues(layerId, values);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(layerId) {
    this.layers.clearLayerDrivenValues(layerId);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Apply a pre-evaluated FrameState from MotionEngine
   *
   * This is the CANONICAL way to update the rendering state.
   * FrameState is computed by MotionEngine.evaluate() which is PURE.
   *
   * ARCHITECTURAL RULE:
   * - Layers receive already-evaluated values via applyEvaluatedState()
   * - NO interpolation or time sampling happens here
   * - Single source of truth: MotionEngine
   *
   * @param frameState - Pre-evaluated state from MotionEngine.evaluate()
   */
  applyFrameState(frameState) {
    this.assertNotDisposed();
    this.state.currentFrame = frameState.frame;
    this.layers.applyEvaluatedState(frameState.layers, frameState.frame);
    if (frameState.camera) {
      this.applyCameraState(frameState.camera);
    } else {
      this.syncActiveCamera();
      if (!this.activeCameraId) {
        this.camera.evaluateFrame(frameState.frame);
      }
    }
  }
  /**
   * Apply evaluated camera state directly
   */
  applyCameraState(cameraState) {
    if (!cameraState) return;
    this.camera.setPositionDirect(
      cameraState.position.x,
      cameraState.position.y,
      cameraState.position.z
    );
    this.camera.setTargetDirect(
      cameraState.target.x,
      cameraState.target.y,
      cameraState.target.z
    );
    this.camera.setFOV(cameraState.fov);
  }
  /**
   * Set the current frame for animation evaluation
   *
   * @deprecated Use applyFrameState() with MotionEngine.evaluate() instead.
   * This method evaluates frames directly, bypassing the single time authority.
   * It is kept for backwards compatibility but should be phased out.
   *
   * @param frame - The frame number (0-indexed)
   */
  setFrame(frame) {
    this.assertNotDisposed();
    this.state.currentFrame = frame;
    this.layers.evaluateFrame(frame, this.audioReactiveGetter);
    this.syncActiveCamera();
    if (!this.activeCameraId) {
      this.camera.evaluateFrame(frame);
    }
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(getter) {
    this.audioReactiveGetter = getter;
    this.layers.setAudioReactiveCallback(getter);
  }
  /**
   * Get the current frame
   * @deprecated Frame authority is now MotionEngine. This returns cached value.
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed();
    this.performance.beginFrame();
    this.emit("frameStart", { frame: this.state.currentFrame });
    this.camera.updateOrbitControls();
    this.renderer.render();
    this.emit("frameEnd", { frame: this.state.currentFrame });
    this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    this.assertNotDisposed();
    if (this.animationFrameId !== null) {
      return;
    }
    this.state.isRendering = true;
    const loop = () => {
      if (!this.state.isRendering || this.state.isDisposed) {
        this.animationFrameId = null;
        return;
      }
      this.render();
      this.animationFrameId = requestAnimationFrame(loop);
    };
    this.animationFrameId = requestAnimationFrame(loop);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = false;
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(width, height, compositionWidth, compositionHeight) {
    this.assertNotDisposed();
    if (width <= 0 || height <= 0) {
      engineLogger.warn("Invalid resize dimensions:", width, height);
      return;
    }
    console.log(`[WeylEngine] resize: viewport=${width}x${height}, comp=${compositionWidth ?? "undefined"}x${compositionHeight ?? "undefined"}`);
    this.state.viewport = { width, height };
    this.renderer.resize(width, height);
    if (compositionWidth !== void 0 && compositionHeight !== void 0) {
      this.camera.resize(compositionWidth, compositionHeight);
    }
    this.camera.setViewportAspect(width, height);
    this.updateSplineResolutions(width, height);
    this.emit("resize", { width, height, compositionWidth, compositionHeight });
  }
  /**
   * Update all SplineLayer resolutions for Line2 materials
   */
  updateSplineResolutions(width, height) {
    const layers = this.layers.getAllLayers();
    for (const layer of layers) {
      if ("setResolution" in layer && typeof layer.setResolution === "function") {
        layer.setResolution(width, height);
      }
    }
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Enable 3D orbit controls for camera navigation
   * Right-click = orbit, middle-click = pan, scroll = dolly
   */
  enableOrbitControls() {
    const domElement = this.renderer.getDomElement();
    this.camera.enableOrbitControls(domElement);
  }
  /**
   * Disable 3D orbit controls
   */
  disableOrbitControls() {
    this.camera.disableOrbitControls();
  }
  /**
   * Reset camera to default viewing position
   */
  resetCameraToDefault() {
    this.camera.resetToDefault();
  }
  /**
   * Fit the composition to the viewport with optional padding
   * This is the canonical method for centering the view on initial load
   * @param padding - Padding in pixels around the composition (default 40)
   */
  fitCompositionToViewport(padding = 40) {
    const { width, height } = this.state.viewport;
    this.camera.fitToViewport(width, height, padding);
  }
  /**
   * Check if orbit controls are enabled
   */
  hasOrbitControls() {
    return this.camera.hasOrbitControls();
  }
  /**
   * Set camera position
   */
  setCameraPosition(x, y, z) {
    this.camera.setPosition(x, y, z);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(x, y, z) {
    this.camera.setTarget(x, y, z);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(fov) {
    this.camera.setFOV(fov);
  }
  /**
   * Set the orbit pivot point (the point the camera orbits around)
   * @param x - X position in screen coordinates
   * @param y - Y position in screen coordinates
   * @param z - Z position
   */
  setOrbitTarget(x, y, z) {
    this.camera.setOrbitTarget(x, y, z);
  }
  /**
   * Reset orbit target to composition center
   */
  resetOrbitTargetToCenter() {
    this.camera.resetOrbitTargetToCenter();
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(dof) {
    this.renderer.setDOF({
      enabled: dof.enabled,
      focusDistance: dof.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: dof.aperture * 1e-4,
      maxBlur: dof.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(enabled) {
    this.renderer.setDOFEnabled(enabled);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(distance) {
    this.renderer.setFocusDistance(distance);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(aperture) {
    this.renderer.setAperture(aperture * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   * @param config - SSAO configuration options
   */
  setSSAO(config) {
    this.renderer.setSSAO(config);
  }
  /**
   * Enable or disable SSAO
   */
  setSSAOEnabled(enabled) {
    this.renderer.setSSAOEnabled(enabled);
  }
  /**
   * Set SSAO intensity
   * @param intensity - Occlusion intensity multiplier
   */
  setSSAOIntensity(intensity) {
    this.renderer.setSSAOIntensity(intensity);
  }
  /**
   * Set SSAO sampling radius
   * @param radius - Kernel radius for occlusion sampling
   */
  setSSAORadius(radius) {
    this.renderer.setSSAORadius(radius);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return this.renderer.getSSAO();
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, bright particles) glow
   * @param config - Bloom configuration options
   */
  setBloom(config) {
    this.renderer.setBloom(config);
  }
  /**
   * Enable or disable bloom
   */
  setBloomEnabled(enabled) {
    this.renderer.setBloomEnabled(enabled);
  }
  /**
   * Set bloom intensity
   * @param strength - Bloom strength multiplier
   */
  setBloomStrength(strength) {
    this.renderer.setBloomStrength(strength);
  }
  /**
   * Set bloom threshold
   * @param threshold - Brightness threshold for bloom (0-1)
   */
  setBloomThreshold(threshold) {
    this.renderer.setBloomThreshold(threshold);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return this.renderer.getBloom();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(transform) {
    this.viewportTransform = [...transform];
    const scale = transform[0];
    const tx = transform[4];
    const ty = transform[5];
    this.camera.setZoom(scale);
    this.camera.setPan(tx, ty);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(image) {
    this.assertNotDisposed();
    if (this.backgroundImage) {
      this.scene.removeFromComposition(this.backgroundImage);
      this.backgroundImage.geometry.dispose();
      this.backgroundImage.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    texture.colorSpace = SRGBColorSpace;
    const geometry = new PlaneGeometry(image.width, image.height);
    const material = new MeshBasicMaterial({
      map: texture,
      transparent: true,
      depthWrite: false
    });
    this.backgroundImage = new Mesh(geometry, material);
    this.backgroundImage.position.set(image.width / 2, image.height / 2, -1e3);
    this.backgroundImage.userData.isBackground = true;
    this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(image, options) {
    this.assertNotDisposed();
    this.depthMapSettings = {
      colormap: options.colormap ?? this.depthMapSettings.colormap,
      opacity: options.opacity ?? this.depthMapSettings.opacity,
      visible: options.visible ?? this.depthMapSettings.visible
    };
    if (this.depthMapMesh) {
      this.scene.removeFromComposition(this.depthMapMesh);
      this.depthMapMesh.geometry.dispose();
      this.depthMapMesh.material.dispose();
    }
    const texture = new Texture(image);
    texture.needsUpdate = true;
    const material = this.createColormapMaterial(texture, this.depthMapSettings);
    const geometry = new PlaneGeometry(image.width, image.height);
    this.depthMapMesh = new Mesh(geometry, material);
    this.depthMapMesh.position.set(image.width / 2, image.height / 2, -999);
    this.depthMapMesh.visible = this.depthMapSettings.visible;
    this.depthMapMesh.userData.isDepthOverlay = true;
    this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(texture, settings) {
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `;
    const colormapIndex = settings.colormap === "viridis" ? 0 : settings.colormap === "plasma" ? 1 : 2;
    return new ShaderMaterial({
      uniforms: {
        depthMap: { value: texture },
        opacity: { value: settings.opacity },
        colormap: { value: colormapIndex }
      },
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(visible) {
    this.depthMapSettings.visible = visible;
    if (this.depthMapMesh) {
      this.depthMapMesh.visible = visible;
    }
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(colormap) {
    this.depthMapSettings.colormap = colormap;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      const colormapIndex = colormap === "viridis" ? 0 : colormap === "plasma" ? 1 : 2;
      material.uniforms.colormap.value = colormapIndex;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(opacity) {
    this.depthMapSettings.opacity = opacity;
    if (this.depthMapMesh) {
      const material = this.depthMapMesh.material;
      material.uniforms.opacity.value = opacity;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(mode) {
    this.renderMode = mode;
    this.renderer.setRenderMode(mode);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // ENVIRONMENT MAP (HDRI)
  // ============================================================================
  /**
   * Initialize environment map support
   * Must be called before loading environment maps
   */
  initializeEnvironmentSupport() {
    this.scene.initializeEnvironmentSupport(this.renderer.getWebGLRenderer());
  }
  /**
   * Load and set an environment map from URL
   * Supports HDR, EXR, and standard image formats
   * @param url - URL to the environment map file
   * @param config - Optional environment configuration
   */
  async loadEnvironmentMap(url, config) {
    this.initializeEnvironmentSupport();
    return this.scene.loadEnvironmentMap(url, config);
  }
  /**
   * Set environment map configuration
   * @param config - Partial configuration to update
   */
  setEnvironmentConfig(config) {
    this.scene.setEnvironmentConfig(config);
  }
  /**
   * Get current environment map configuration
   */
  getEnvironmentConfig() {
    return this.scene.getEnvironmentConfig();
  }
  /**
   * Enable or disable environment map
   */
  setEnvironmentEnabled(enabled) {
    this.scene.setEnvironmentEnabled(enabled);
  }
  /**
   * Set environment map intensity
   * @param intensity - Intensity multiplier (0-2 typical range)
   */
  setEnvironmentIntensity(intensity) {
    this.scene.setEnvironmentIntensity(intensity);
  }
  /**
   * Set environment map rotation
   * @param degrees - Y-axis rotation in degrees
   */
  setEnvironmentRotation(degrees) {
    this.scene.setEnvironmentRotation(degrees);
  }
  /**
   * Set background blur amount for HDRI background
   * @param blur - Blur amount (0-1)
   */
  setEnvironmentBackgroundBlur(blur) {
    this.scene.setBackgroundBlur(blur);
  }
  /**
   * Toggle whether to use HDRI as scene background
   */
  setEnvironmentAsBackground(use) {
    this.scene.setUseAsBackground(use);
  }
  /**
   * Get the current environment map texture
   */
  getEnvironmentMap() {
    return this.scene.getEnvironmentMap();
  }
  // ============================================================================
  // COMPOSITION GUIDES
  // ============================================================================
  /**
   * Show/hide composition grid
   */
  setCompositionGridVisible(visible) {
    this.scene.setCompositionGridVisible(visible);
  }
  /**
   * Show/hide dark overlay outside composition
   */
  setOutsideOverlayVisible(visible) {
    this.scene.setOutsideOverlayVisible(visible);
  }
  /**
   * Show/hide composition bounds frame
   */
  setCompositionBoundsVisible(visible) {
    this.scene.setCompositionBoundsVisible(visible);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(x, y) {
    const raycaster = new Raycaster();
    const pointer = new Vector2(x, y);
    raycaster.setFromCamera(pointer, this.camera.getCamera());
    const intersects = this.scene.raycastComposition(raycaster);
    for (const intersection of intersects) {
      let obj = intersection.object;
      while (obj) {
        if (obj.userData.layerId) {
          return obj.userData.layerId;
        }
        if (obj.userData.isBackground || obj.userData.isDepthOverlay) {
          break;
        }
        obj = obj.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    this.assertNotDisposed();
    if (this.transformControls) {
      return;
    }
    const camera = this.camera.getCamera();
    const domElement = this.renderer.getDomElement();
    this.transformControls = new TransformControls(camera, domElement);
    this.transformControls.setMode(this.transformMode);
    this.transformControls.setSpace("world");
    this.transformControls.setSize(1);
    this.scene.addUIElement(this.transformControls);
    let isDragging = false;
    this.transformControls.addEventListener("dragging-changed", (event) => {
      isDragging = event.value;
      this.emit("transform-dragging", { dragging: event.value });
    });
    this.transformControls.addEventListener("change", () => {
      if (!isDragging) return;
      if (!this.transformControls || !this.selectedLayerId) return;
      const object = this.transformControls.object;
      if (!object) return;
      const layer = this.layers.getLayer(this.selectedLayerId);
      const layerData = layer?.getLayerData?.();
      const anchorX = layerData?.transform?.anchorPoint?.value?.x ?? 0;
      const anchorY = layerData?.transform?.anchorPoint?.value?.y ?? 0;
      const anchorZ = layerData?.transform?.anchorPoint?.value?.z ?? 0;
      const transform = {
        position: {
          x: object.position.x + anchorX,
          y: -object.position.y + anchorY,
          // Y is negated in 3D space
          z: object.position.z + anchorZ
        },
        rotationX: MathUtils.radToDeg(object.rotation.x),
        rotationY: MathUtils.radToDeg(object.rotation.y),
        rotationZ: MathUtils.radToDeg(object.rotation.z),
        scale: {
          x: object.scale.x * 100,
          // Convert back to percentage
          y: object.scale.y * 100,
          z: object.scale.z * 100
        }
      };
      transform.rotation = transform.rotationZ;
      if (this.onTransformChange) {
        this.onTransformChange(this.selectedLayerId, transform);
      }
    });
    this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(callback) {
    this.onTransformChange = callback;
  }
  /**
   * Select a layer and attach transform controls
   * Also updates orbit target to the selected layer's position for right-click orbiting
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(layerId) {
    this.assertNotDisposed();
    if (!this.transformControls) {
      this.initializeTransformControls();
    }
    if (this.selectedLayerId && this.transformControls) {
      this.transformControls.detach();
    }
    this.selectedLayerId = layerId;
    if (!layerId || !this.transformControls) {
      this.resetOrbitTargetToCenter();
      return;
    }
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      this.transformControls.attach(layerObject);
    }
  }
  /**
   * Focus the camera on the selected layer's position
   * This moves the orbit target to the layer without changing camera rotation
   */
  focusOnLayer(layerId) {
    const layerObject = this.getLayerObject(layerId);
    if (layerObject) {
      const worldPos = new Vector3();
      layerObject.getWorldPosition(worldPos);
      this.setOrbitTarget(worldPos.x, -worldPos.y, worldPos.z);
    }
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(mode) {
    this.transformMode = mode;
    if (this.transformControls) {
      this.transformControls.setMode(mode);
    }
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(visible) {
    if (this.transformControls) {
      this.transformControls.visible = visible;
      this.transformControls.enabled = visible;
    }
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    return this.transformControls?.dragging ?? false;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const imageData = this.renderer.captureFrame();
    return {
      imageData,
      width: imageData.width,
      height: imageData.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(format = "png", quality = 0.95) {
    this.assertNotDisposed();
    const { imageData, width, height } = this.captureFrame();
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.convertToBlob({
      type: `image/${format}`,
      quality
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const depthBuffer = this.renderer.captureDepth();
    const cameraState = this.camera.getState();
    return {
      depthBuffer,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: cameraState.near,
      far: cameraState.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(type, handler) {
    if (!this.eventHandlers.has(type)) {
      this.eventHandlers.set(type, /* @__PURE__ */ new Set());
    }
    this.eventHandlers.get(type).add(handler);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(type, handler) {
    this.eventHandlers.get(type)?.delete(handler);
  }
  emit(type, data) {
    const event = {
      type,
      timestamp: performance.now(),
      data
    };
    this.eventHandlers.get(type)?.forEach((handler) => {
      try {
        handler(event);
      } catch (error) {
        engineLogger.error(`Event handler error for ${type}:`, error);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const canvas = this.config.canvas;
    this.contextLostHandler = (event) => {
      event.preventDefault();
      this.stopRenderLoop();
      this.emit("contextLost", null);
      engineLogger.warn("WebGL context lost");
    };
    this.contextRestoredHandler = () => {
      this.emit("contextRestored", null);
      engineLogger.info("WebGL context restored");
    };
    canvas.addEventListener("webglcontextlost", this.contextLostHandler);
    canvas.addEventListener("webglcontextrestored", this.contextRestoredHandler);
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed) {
      throw new Error("WeylEngine has been disposed");
    }
  }
  // ============================================================================
  // NESTED COMP RENDER-TO-TEXTURE
  // ============================================================================
  /** Cache of layer managers for nested compositions */
  nestedCompLayerManagers = /* @__PURE__ */ new Map();
  /** Cache of scenes for nested compositions */
  nestedCompScenes = /* @__PURE__ */ new Map();
  /** Cache of last rendered frame per composition (for texture caching) */
  nestedCompLastFrame = /* @__PURE__ */ new Map();
  /**
   * Render a composition to a texture
   * Used by NestedCompLayer to render nested compositions
   *
   * @param compositionId - The composition ID to render
   * @param layers - The layers in that composition
   * @param settings - Composition settings (width, height, fps)
   * @param frame - The frame to render
   * @returns The rendered texture, or null if rendering fails
   */
  renderCompositionToTexture(compositionId, layers, settings, frame) {
    this.assertNotDisposed();
    try {
      const lastFrame = this.nestedCompLastFrame.get(compositionId);
      const target = this.renderer.getNestedCompRenderTarget(
        compositionId,
        settings.width,
        settings.height
      );
      if (lastFrame === frame) {
        return target.texture;
      }
      let nestedCompScene = this.nestedCompScenes.get(compositionId);
      if (!nestedCompScene) {
        nestedCompScene = new SceneManager(null);
        nestedCompScene.setCompositionSize(settings.width, settings.height);
        this.nestedCompScenes.set(compositionId, nestedCompScene);
      }
      let nestedCompLayers = this.nestedCompLayerManagers.get(compositionId);
      if (!nestedCompLayers) {
        nestedCompLayers = new LayerManager(nestedCompScene, this.resources);
        nestedCompLayers.setRenderer(this.renderer.getWebGLRenderer());
        nestedCompLayers.setCompositionFPS(settings.fps);
        nestedCompLayers.setCamera(this.camera.camera);
        this.nestedCompLayerManagers.set(compositionId, nestedCompLayers);
      }
      const currentLayerIds = new Set(nestedCompLayers.getLayerIds());
      const targetLayerIds = new Set(layers.map((l) => l.id));
      for (const id of currentLayerIds) {
        if (!targetLayerIds.has(id)) {
          nestedCompLayers.remove(id);
        }
      }
      for (const layerData of layers) {
        if (currentLayerIds.has(layerData.id)) {
          nestedCompLayers.update(layerData.id, layerData);
        } else {
          nestedCompLayers.create(layerData);
        }
      }
      nestedCompLayers.evaluateFrame(frame, this.audioReactiveGetter);
      const nestedCompCamera = new OrthographicCamera(
        -settings.width / 2,
        settings.width / 2,
        settings.height / 2,
        -settings.height / 2,
        0.1,
        1e4
      );
      nestedCompCamera.position.set(0, 0, 1e3);
      nestedCompCamera.lookAt(0, 0, 0);
      const texture = this.renderer.renderSceneToTexture(
        nestedCompScene.scene,
        nestedCompCamera,
        target
      );
      this.nestedCompLastFrame.set(compositionId, frame);
      return texture;
    } catch (error) {
      engineLogger.error("Failed to render composition to texture:", compositionId, error);
      return null;
    }
  }
  /**
   * Clear nested composition cache for a specific composition
   * Call when a composition is deleted or significantly changed
   */
  clearNestedCompCache(compositionId) {
    const nestedCompLayers = this.nestedCompLayerManagers.get(compositionId);
    if (nestedCompLayers) {
      nestedCompLayers.dispose();
      this.nestedCompLayerManagers.delete(compositionId);
    }
    const nestedCompScene = this.nestedCompScenes.get(compositionId);
    if (nestedCompScene) {
      nestedCompScene.dispose();
      this.nestedCompScenes.delete(compositionId);
    }
    this.nestedCompLastFrame.delete(compositionId);
    this.renderer.disposeNestedCompTarget(compositionId);
  }
  /**
   * Clear all nested composition caches
   */
  clearAllNestedCompCaches() {
    for (const [id] of this.nestedCompLayerManagers) {
      this.clearNestedCompCache(id);
    }
    this.renderer.disposeAllNestedCompTargets();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    if (this.state.isDisposed) {
      return;
    }
    this.stopRenderLoop();
    this.clearAllNestedCompCaches();
    const canvas = this.config.canvas;
    if (this.contextLostHandler) {
      canvas.removeEventListener("webglcontextlost", this.contextLostHandler);
      this.contextLostHandler = null;
    }
    if (this.contextRestoredHandler) {
      canvas.removeEventListener("webglcontextrestored", this.contextRestoredHandler);
      this.contextRestoredHandler = null;
    }
    if (this.transformControls) {
      this.transformControls.dispose();
      this.transformControls = null;
    }
    this.layers.dispose();
    this.renderer.dispose();
    this.scene.dispose();
    this.resources.dispose();
    this.eventHandlers.clear();
    this.state.isDisposed = true;
    this.emit("dispose", null);
    if (this.config.debug) {
      engineLogger.debug("Disposed");
    }
  }
}

const _hoisted_1$e = { class: "spline-editor" };
const _hoisted_2$e = {
  key: 0,
  class: "tool-tip-popup"
};
const _hoisted_3$e = {
  key: 2,
  class: "spline-toolbar"
};
const _hoisted_4$e = { class: "toolbar-group pen-tools" };
const _hoisted_5$e = {
  key: 0,
  class: "toolbar-group"
};
const _hoisted_6$e = ["title"];
const _hoisted_7$e = {
  key: 1,
  class: "toolbar-group"
};
const _hoisted_8$e = { class: "tolerance-label" };
const _hoisted_9$e = { class: "tolerance-value" };
const _hoisted_10$e = {
  key: 2,
  class: "toolbar-info"
};
const _hoisted_11$d = {
  key: 3,
  class: "toolbar-group z-depth-controls"
};
const _hoisted_12$c = { class: "z-depth-label" };
const _hoisted_13$c = ["value"];
const _hoisted_14$b = ["viewBox"];
const _hoisted_15$a = ["x1", "y1", "x2", "y2"];
const _hoisted_16$9 = ["x1", "y1", "x2", "y2"];
const _hoisted_17$9 = ["cx", "cy", "onMousedown"];
const _hoisted_18$9 = ["cx", "cy", "onMousedown"];
const _hoisted_19$9 = ["cx", "cy"];
const _hoisted_20$9 = ["cx", "cy", "onMousedown", "onMouseenter"];
const _hoisted_21$9 = {
  key: 1,
  class: "axis-handles"
};
const _hoisted_22$9 = ["cx", "cy"];
const _hoisted_23$9 = { class: "axis-x-group" };
const _hoisted_24$7 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$6 = ["points"];
const _hoisted_26$6 = ["x", "y", "onMousedown"];
const _hoisted_27$6 = { class: "axis-y-group" };
const _hoisted_28$6 = ["x1", "y1", "x2", "y2"];
const _hoisted_29$6 = ["points"];
const _hoisted_30$5 = ["x", "y", "onMousedown"];
const _hoisted_31$4 = {
  key: 2,
  class: "z-handle-group"
};
const _hoisted_32$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_33$4 = ["points"];
const _hoisted_34$4 = ["points"];
const _hoisted_35$3 = ["points", "onMousedown"];
const _hoisted_36$3 = ["x", "y"];
const _hoisted_37$3 = ["d"];
const _hoisted_38$3 = ["cx", "cy"];
const _hoisted_39$3 = ["cx", "cy"];
const _hoisted_40$2 = ["cx", "cy"];
const CLOSE_THRESHOLD = 15;
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "SplineEditor",
  props: {
    layerId: {},
    currentFrame: {},
    canvasWidth: {},
    canvasHeight: {},
    containerWidth: {},
    containerHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated", "pathClosed", "togglePenMode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const selectedPointId = ref(null);
    const selectedPointIds = ref([]);
    const hoveredPointId = ref(null);
    const hoverFeedback = ref(null);
    const hoverFeedbackPos = ref(null);
    const previewPoint = ref(null);
    const closePathPreview = ref(false);
    const previewCurve = ref(null);
    const insertPreviewPoint = ref(null);
    const penSubMode = ref("add");
    const dragTarget = ref(null);
    const activeToolTip = computed(() => {
      switch (penSubMode.value) {
        case "add":
          return "Click to add points. Drag after clicking to create curved handles. Right-click to finish drawing.";
        case "insert":
          return "Click on the path to insert a new point on that segment.";
        case "delete":
          return "Click on any point to delete it from the path.";
        case "convert":
          return "Click on a point to toggle between smooth (curved) and corner (sharp) type.";
        default:
          return "";
      }
    });
    const hoverFeedbackStyle = computed(() => {
      if (!hoverFeedbackPos.value) return { display: "none" };
      const svgStyle = overlayStyle.value;
      const svgWidth = parseFloat(svgStyle.width);
      const svgHeight = parseFloat(svgStyle.height);
      const left = parseFloat(svgStyle.left) + hoverFeedbackPos.value.x / props.canvasWidth * svgWidth;
      const top = parseFloat(svgStyle.top) + hoverFeedbackPos.value.y / props.canvasHeight * svgHeight - 25;
      return {
        position: "absolute",
        left: `${left}px`,
        top: `${top}px`,
        transform: "translateX(-50%)"
      };
    });
    const selectedPointDepth = computed(() => {
      if (!selectedPointId.value) return 0;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      return point?.depth ?? 0;
    });
    function updateSelectedPointDepth(event) {
      if (!selectedPointId.value || !props.layerId) return;
      const input = event.target;
      const newDepth = Math.max(0, parseFloat(input.value) || 0);
      store.updateSplineControlPoint(props.layerId, selectedPointId.value, { depth: newDepth });
      emit("pathUpdated");
    }
    function adjustSelectedPointDepth(delta) {
      if (!selectedPointId.value || !props.layerId) return;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      const currentDepth = point?.depth ?? 0;
      const newDepth = Math.max(0, currentDepth + delta);
      store.updateSplineControlPoint(props.layerId, selectedPointId.value, { depth: newDepth });
      emit("pathUpdated");
    }
    const is3DLayer = computed(() => {
      if (!props.layerId) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      return layer?.threeD ?? false;
    });
    const layerTransform = computed(() => {
      if (!props.layerId) {
        return { position: { x: 0, y: 0 }, rotation: 0, scale: { x: 100, y: 100 }, anchorPoint: { x: 0, y: 0 } };
      }
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer) {
        return { position: { x: 0, y: 0 }, rotation: 0, scale: { x: 100, y: 100 }, anchorPoint: { x: 0, y: 0 } };
      }
      const t = layer.transform;
      const getVal = (prop, defaultVal) => {
        if (!prop) return defaultVal;
        if (prop.animated && prop.keyframes?.length > 0) {
          return interpolateProperty(prop, props.currentFrame) ?? defaultVal;
        }
        return prop.value ?? defaultVal;
      };
      const position = getVal(t.position, { x: props.canvasWidth / 2, y: props.canvasHeight / 2 });
      const anchorPoint = getVal(t.anchorPoint, { x: 0, y: 0 });
      const scale = getVal(t.scale, { x: 100, y: 100 });
      let rotation = 0;
      if (layer.threeD && t.rotationZ) {
        rotation = getVal(t.rotationZ, 0);
      } else if (t.rotation) {
        rotation = getVal(t.rotation, 0);
      }
      return { position, rotation, scale, anchorPoint };
    });
    function transformPoint(p) {
      const { position, rotation, scale, anchorPoint } = layerTransform.value;
      let x = p.x - anchorPoint.x;
      let y = p.y - anchorPoint.y;
      x *= scale.x / 100;
      y *= scale.y / 100;
      const rad = rotation * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      return {
        x: rx + position.x,
        y: ry + position.y
      };
    }
    function inverseTransformPoint(p) {
      const { position, rotation, scale, anchorPoint } = layerTransform.value;
      let x = p.x - position.x;
      let y = p.y - position.y;
      const rad = -rotation * Math.PI / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      x = rx / (scale.x / 100);
      y = ry / (scale.y / 100);
      return {
        x: x + anchorPoint.x,
        y: y + anchorPoint.y
      };
    }
    const isClosed = computed(() => {
      if (!props.layerId) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline") return false;
      return layer.data?.closed ?? false;
    });
    const smoothTolerance = ref(10);
    const hasControlPoints = computed(() => visibleControlPoints.value.length > 0);
    computed(() => {
      if (!selectedPointId.value) return null;
      const point = visibleControlPoints.value.find((p) => p.id === selectedPointId.value);
      return point?.type ?? null;
    });
    function setPenSubMode(mode) {
      if (props.isPenMode && penSubMode.value === mode) {
        emit("togglePenMode");
        return;
      }
      penSubMode.value = mode;
      if (!props.isPenMode) {
        emit("togglePenMode");
      }
    }
    function toggleClosePath() {
      if (!props.layerId) return;
      store.updateLayerData(props.layerId, { closed: !isClosed.value });
      emit("pathUpdated");
    }
    function smoothSelectedPoints() {
      if (!props.layerId) return;
      if (selectedPointIds.value.length > 0) {
        smoothSpecificPoints(selectedPointIds.value);
      } else if (selectedPointId.value) {
        smoothSpecificPoints([selectedPointId.value]);
      } else {
        store.smoothSplineHandles(props.layerId, smoothTolerance.value * 2);
      }
      emit("pathUpdated");
    }
    function smoothSpecificPoints(pointIds) {
      if (!props.layerId) return;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return;
      const splineData = layer.data;
      const controlPoints = splineData.controlPoints;
      if (!controlPoints || controlPoints.length < 2) return;
      const factor = Math.max(0, Math.min(100, smoothTolerance.value * 2)) / 100;
      for (const pointId of pointIds) {
        const i = controlPoints.findIndex((cp2) => cp2.id === pointId);
        if (i < 0) continue;
        const cp = controlPoints[i];
        const prev = controlPoints[(i - 1 + controlPoints.length) % controlPoints.length];
        const next = controlPoints[(i + 1) % controlPoints.length];
        if (!splineData.closed && (i === 0 || i === controlPoints.length - 1)) continue;
        const toPrev = { x: prev.x - cp.x, y: prev.y - cp.y };
        const toNext = { x: next.x - cp.x, y: next.y - cp.y };
        const avgDir = { x: toNext.x - toPrev.x, y: toNext.y - toPrev.y };
        const avgLength = Math.sqrt(avgDir.x * avgDir.x + avgDir.y * avgDir.y);
        if (avgLength < 0.01) continue;
        const normalized = { x: avgDir.x / avgLength, y: avgDir.y / avgLength };
        const distPrev = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
        const distNext = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);
        const handleLength = (distPrev + distNext) / 6;
        const idealIn = { x: cp.x - normalized.x * handleLength, y: cp.y - normalized.y * handleLength };
        const idealOut = { x: cp.x + normalized.x * handleLength, y: cp.y + normalized.y * handleLength };
        store.updateSplineControlPoint(props.layerId, pointId, {
          type: "smooth",
          handleIn: {
            x: cp.handleIn ? cp.handleIn.x + (idealIn.x - cp.handleIn.x) * factor : idealIn.x * factor + cp.x * (1 - factor),
            y: cp.handleIn ? cp.handleIn.y + (idealIn.y - cp.handleIn.y) * factor : idealIn.y * factor + cp.y * (1 - factor)
          },
          handleOut: {
            x: cp.handleOut ? cp.handleOut.x + (idealOut.x - cp.handleOut.x) * factor : idealOut.x * factor + cp.x * (1 - factor),
            y: cp.handleOut ? cp.handleOut.y + (idealOut.y - cp.handleOut.y) * factor : idealOut.y * factor + cp.y * (1 - factor)
          }
        });
      }
    }
    function simplifySpline() {
      if (!props.layerId) return;
      store.simplifySpline(props.layerId, smoothTolerance.value);
      emit("pathUpdated");
    }
    const rawControlPoints = computed(() => {
      if (!props.layerId) return [];
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return [];
      const splineData = layer.data;
      if (splineData.animated && splineData.animatedControlPoints) {
        return store.getEvaluatedSplinePoints(props.layerId, props.currentFrame);
      }
      return splineData.controlPoints || [];
    });
    const visibleControlPoints = computed(() => {
      return rawControlPoints.value.map((cp) => {
        const transformed = transformPoint({ x: cp.x, y: cp.y });
        const transformedHandleIn = cp.handleIn ? transformPoint(cp.handleIn) : null;
        const transformedHandleOut = cp.handleOut ? transformPoint(cp.handleOut) : null;
        return {
          id: cp.id,
          rawX: cp.x,
          rawY: cp.y,
          x: transformed.x,
          y: transformed.y,
          depth: cp.depth,
          handleIn: transformedHandleIn,
          handleOut: transformedHandleOut,
          rawHandleIn: cp.handleIn ? { ...cp.handleIn } : null,
          rawHandleOut: cp.handleOut ? { ...cp.handleOut } : null,
          type: cp.type
        };
      });
    });
    function pointHasKeyframes(pointId) {
      if (!props.layerId) return false;
      return store.hasSplinePointKeyframes(props.layerId, pointId);
    }
    function getPointDepth(point) {
      return point.depth ?? 0;
    }
    function getDepthOffset(point) {
      const depth = getPointDepth(point);
      return Math.max(-30, Math.min(30, -depth / 16.67));
    }
    function getZHandlePoints(point) {
      const x = point.x + 15;
      const y = point.y + getDepthOffset(point);
      const size = 5;
      return `${x},${y - size} ${x + size},${y} ${x},${y + size} ${x - size},${y}`;
    }
    function startDragDepth(pointId, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      const pos = getMousePos(event);
      dragTarget.value = {
        type: "depth",
        pointId,
        startX: pos.x,
        startY: pos.y,
        startDepth: getPointDepth(point),
        // Store screen coordinates for zoom-independent movement
        screenStartX: event.clientX,
        screenStartY: event.clientY
      };
      selectedPointId.value = pointId;
    }
    const canClosePath = computed(() => {
      if (!props.layerId || visibleControlPoints.value.length < 3) return false;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return false;
      const splineData = layer.data;
      return !splineData.closed;
    });
    const strokeColor = computed(() => {
      if (!props.layerId) return "#00ff66";
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline" || !layer.data) return "#00ff66";
      const splineData = layer.data;
      return splineData.stroke || splineData.strokeColor || "#00ff66";
    });
    const overlayStyle = computed(() => {
      const containerAspect = props.containerWidth / props.containerHeight;
      const compAspect = props.canvasWidth / props.canvasHeight;
      let fitWidth;
      let fitHeight;
      if (containerAspect > compAspect) {
        fitHeight = props.containerHeight;
        fitWidth = props.canvasWidth * (props.containerHeight / props.canvasHeight);
      } else {
        fitWidth = props.containerWidth;
        fitHeight = props.canvasHeight * (props.containerWidth / props.canvasWidth);
      }
      const zoomFactor = props.zoom || 1;
      const width = fitWidth * zoomFactor;
      const height = fitHeight * zoomFactor;
      const left = (props.containerWidth - width) / 2;
      const top = (props.containerHeight - height) / 2;
      return {
        position: "absolute",
        left: `${left}px`,
        top: `${top}px`,
        width: `${width}px`,
        height: `${height}px`,
        pointerEvents: "all"
      };
    });
    function screenToCanvas(screenX, screenY) {
      const svgRect = overlayStyle.value;
      const svgWidth = parseFloat(svgRect.width);
      const svgHeight = parseFloat(svgRect.height);
      const x = screenX / svgWidth * props.canvasWidth;
      const y = screenY / svgHeight * props.canvasHeight;
      return { x, y };
    }
    function getMousePos(event) {
      const svg = event.currentTarget;
      const rect = svg.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;
      return screenToCanvas(screenX, screenY);
    }
    function evaluateBezier(p0, h0, h1, p1, t) {
      const cp0 = p0;
      const cp1 = h0 || p0;
      const cp2 = h1 || p1;
      const cp3 = p1;
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;
      return {
        x: mt3 * cp0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * cp3.x,
        y: mt3 * cp0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * cp3.y
      };
    }
    function findClosestPointOnPath(pos) {
      const points = visibleControlPoints.value;
      if (points.length < 2) return null;
      let closest = null;
      const numSegments = isClosed.value ? points.length : points.length - 1;
      for (let i = 0; i < numSegments; i++) {
        const p0 = points[i];
        const p1 = points[(i + 1) % points.length];
        const h0 = p0.handleOut;
        const h1 = p1.handleIn;
        for (let t = 0; t <= 1; t += 0.02) {
          const pt = evaluateBezier(p0, h0, h1, p1, t);
          const dist = Math.sqrt((pos.x - pt.x) ** 2 + (pos.y - pt.y) ** 2);
          if (!closest || dist < closest.dist) {
            closest = { x: pt.x, y: pt.y, segmentIndex: i, t, dist };
          }
        }
      }
      if (closest && closest.dist < 20) {
        return { x: closest.x, y: closest.y, segmentIndex: closest.segmentIndex, t: closest.t };
      }
      return null;
    }
    function handleMouseDown(event) {
      if (!props.isPenMode) return;
      const pos = getMousePos(event);
      const layerPos = inverseTransformPoint(pos);
      if (!props.layerId) return;
      const layer = store.layers.find((l) => l.id === props.layerId);
      if (!layer || layer.type !== "spline") return;
      if (penSubMode.value === "add") {
        const newPoint = {
          id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          x: layerPos.x,
          y: layerPos.y,
          handleIn: null,
          handleOut: null,
          type: "corner"
        };
        store.addSplineControlPoint(props.layerId, newPoint);
        selectedPointId.value = newPoint.id;
        dragTarget.value = {
          type: "newPoint",
          pointId: newPoint.id,
          startX: pos.x,
          startY: pos.y,
          newPointX: pos.x,
          newPointY: pos.y
        };
        emit("pointAdded", newPoint);
        emit("pathUpdated");
      } else if (penSubMode.value === "insert") {
        const closest = findClosestPointOnPath(pos);
        if (closest) {
          const closestLayerPos = inverseTransformPoint({ x: closest.x, y: closest.y });
          const newPoint = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: closestLayerPos.x,
            y: closestLayerPos.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          store.insertSplineControlPoint(props.layerId, newPoint, closest.segmentIndex + 1);
          selectedPointId.value = newPoint.id;
          emit("pointAdded", newPoint);
          emit("pathUpdated");
        }
      } else if (penSubMode.value === "delete") {
        const clickedPoint = findClickedPoint(pos);
        if (clickedPoint) {
          store.deleteSplineControlPoint(props.layerId, clickedPoint.id);
          emit("pointDeleted", clickedPoint.id);
          emit("pathUpdated");
          selectedPointId.value = null;
        }
      } else if (penSubMode.value === "convert") {
        const clickedPoint = findClickedPoint(pos);
        if (clickedPoint) {
          const newType = clickedPoint.type === "smooth" ? "corner" : "smooth";
          if (newType === "corner") {
            store.updateSplineControlPoint(props.layerId, clickedPoint.id, {
              type: "corner",
              handleIn: null,
              handleOut: null
            });
          } else {
            const handleOffset = 30;
            store.updateSplineControlPoint(props.layerId, clickedPoint.id, {
              type: "smooth",
              handleIn: { x: clickedPoint.x - handleOffset, y: clickedPoint.y },
              handleOut: { x: clickedPoint.x + handleOffset, y: clickedPoint.y }
            });
          }
          selectedPointId.value = clickedPoint.id;
          emit("pathUpdated");
        }
      }
    }
    function findClickedPoint(pos) {
      const threshold = 10;
      for (const point of visibleControlPoints.value) {
        const dist = Math.sqrt((pos.x - point.x) ** 2 + (pos.y - point.y) ** 2);
        if (dist < threshold) {
          return point;
        }
      }
      return null;
    }
    function generateCurvePreview(prevPoint, newPoint, dragPos) {
      const dx = dragPos.x - newPoint.x;
      const dy = dragPos.y - newPoint.y;
      let h1x, h1y;
      if (prevPoint.handleOut) {
        h1x = prevPoint.handleOut.x;
        h1y = prevPoint.handleOut.y;
      } else {
        const dirX = newPoint.x - prevPoint.x;
        const dirY = newPoint.y - prevPoint.y;
        h1x = prevPoint.x + dirX * 0.33;
        h1y = prevPoint.y + dirY * 0.33;
      }
      const h2x = newPoint.x - dx;
      const h2y = newPoint.y - dy;
      return `M ${prevPoint.x},${prevPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${newPoint.x},${newPoint.y}`;
    }
    function handleMouseMove(event) {
      const pos = getMousePos(event);
      if (props.isPenMode) {
        previewPoint.value = pos;
        if (penSubMode.value === "insert") {
          const closest = findClosestPointOnPath(pos);
          insertPreviewPoint.value = closest;
          if (closest) {
            hoverFeedbackPos.value = { x: closest.x, y: closest.y };
            hoverFeedback.value = "Click to add point to spline";
          } else if (!hoveredPointId.value) {
            hoverFeedback.value = null;
          }
        } else {
          insertPreviewPoint.value = null;
          if (!hoveredPointId.value) {
            hoverFeedback.value = null;
          }
        }
        if (penSubMode.value === "add" && !dragTarget.value) {
          const points = visibleControlPoints.value;
          if (points.length > 0) {
            const lastPoint = points[points.length - 1];
            if (lastPoint.handleOut) {
              const h1x = lastPoint.handleOut.x;
              const h1y = lastPoint.handleOut.y;
              const dx = pos.x - lastPoint.x;
              const dy = pos.y - lastPoint.y;
              const h2x = pos.x - dx * 0.3;
              const h2y = pos.y - dy * 0.3;
              previewCurve.value = `M ${lastPoint.x},${lastPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${pos.x},${pos.y}`;
            } else {
              const dx = pos.x - lastPoint.x;
              const dy = pos.y - lastPoint.y;
              const h1x = lastPoint.x + dx * 0.3;
              const h1y = lastPoint.y + dy * 0.3;
              const h2x = pos.x - dx * 0.3;
              const h2y = pos.y - dy * 0.3;
              previewCurve.value = `M ${lastPoint.x},${lastPoint.y} C ${h1x},${h1y} ${h2x},${h2y} ${pos.x},${pos.y}`;
            }
          }
        }
      }
      if (dragTarget.value?.type === "newPoint") {
        const points = visibleControlPoints.value;
        if (points.length >= 1) {
          const newPoint = points.find((p) => p.id === dragTarget.value.pointId);
          const newPointIndex = points.indexOf(newPoint);
          const prevPointIndex = newPointIndex - 1;
          const layerPos = inverseTransformPoint(pos);
          const rawNewPointX = newPoint?.rawX ?? newPoint?.x ?? 0;
          const rawNewPointY = newPoint?.rawY ?? newPoint?.y ?? 0;
          if (newPoint && prevPointIndex >= 0) {
            const prevPoint = points[prevPointIndex];
            previewCurve.value = generateCurvePreview(prevPoint, newPoint, pos);
            if (props.layerId) {
              const dx = layerPos.x - rawNewPointX;
              const dy = layerPos.y - rawNewPointY;
              if (Math.sqrt(dx * dx + dy * dy) > 5) {
                store.updateSplineControlPoint(props.layerId, newPoint.id, {
                  handleOut: { x: layerPos.x, y: layerPos.y },
                  handleIn: { x: rawNewPointX - dx, y: rawNewPointY - dy },
                  type: "smooth"
                });
              }
            }
          } else if (newPoint && prevPointIndex < 0) {
            if (props.layerId) {
              const dx = layerPos.x - rawNewPointX;
              const dy = layerPos.y - rawNewPointY;
              if (Math.sqrt(dx * dx + dy * dy) > 5) {
                store.updateSplineControlPoint(props.layerId, newPoint.id, {
                  handleOut: { x: layerPos.x, y: layerPos.y },
                  handleIn: { x: rawNewPointX - dx, y: rawNewPointY - dy },
                  type: "smooth"
                });
              }
            }
          }
        }
      } else if (!props.isPenMode || penSubMode.value !== "add") {
        previewCurve.value = null;
      }
      if (canClosePath.value && visibleControlPoints.value.length > 0) {
        const firstPoint = visibleControlPoints.value[0];
        const dx = pos.x - firstPoint.x;
        const dy = pos.y - firstPoint.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        closePathPreview.value = dist < CLOSE_THRESHOLD;
      } else {
        closePathPreview.value = false;
      }
      if (dragTarget.value && props.layerId) {
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (!layer || layer.type !== "spline") return;
        const splineData = layer.data;
        const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
        if (!point) return;
        const layerPos = inverseTransformPoint(pos);
        if (dragTarget.value.type === "point") {
          const dx = layerPos.x - point.x;
          const dy = layerPos.y - point.y;
          const updates = { x: layerPos.x, y: layerPos.y };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + dx, y: point.handleIn.y + dy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + dx, y: point.handleOut.y + dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "handleIn") {
          const updates = { handleIn: { x: layerPos.x, y: layerPos.y } };
          if (point.type === "smooth") {
            const dx = layerPos.x - point.x;
            const dy = layerPos.y - point.y;
            updates.handleOut = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "in", layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "handleOut") {
          const updates = { handleOut: { x: layerPos.x, y: layerPos.y } };
          if (point.type === "smooth") {
            const dx = layerPos.x - point.x;
            const dy = layerPos.y - point.y;
            updates.handleIn = { x: point.x - dx, y: point.y - dy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("handleMoved", point.id, "out", layerPos.x, layerPos.y);
        } else if (dragTarget.value.type === "depth") {
          const screenDy = event.clientY - (dragTarget.value.screenStartY ?? event.clientY);
          const depthScale = 2;
          const newDepth = Math.max(0, (dragTarget.value.startDepth ?? 0) - screenDy * depthScale);
          store.updateSplineControlPoint(props.layerId, point.id, { depth: newDepth });
        } else if (dragTarget.value.type === "axisX") {
          const screenDx = event.clientX - (dragTarget.value.screenStartX ?? event.clientX);
          const dx = screenDx;
          const newX = (dragTarget.value.originalX ?? point.x) + dx;
          const handleDx = newX - point.x;
          const updates = { x: newX };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x + handleDx, y: point.handleIn.y };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x + handleDx, y: point.handleOut.y };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, newX, point.y);
        } else if (dragTarget.value.type === "axisY") {
          const screenDy = event.clientY - (dragTarget.value.screenStartY ?? event.clientY);
          const dy = screenDy;
          const newY = (dragTarget.value.originalY ?? point.y) + dy;
          const handleDy = newY - point.y;
          const updates = { y: newY };
          if (point.handleIn) {
            updates.handleIn = { x: point.handleIn.x, y: point.handleIn.y + handleDy };
          }
          if (point.handleOut) {
            updates.handleOut = { x: point.handleOut.x, y: point.handleOut.y + handleDy };
          }
          store.updateSplineControlPoint(props.layerId, point.id, updates);
          emit("pointMoved", point.id, point.x, newY);
        }
        emit("pathUpdated");
      }
    }
    function handleMouseUp() {
      previewCurve.value = null;
      if (dragTarget.value && props.layerId) {
        if (dragTarget.value.type === "newPoint") {
          dragTarget.value = null;
          emit("pathUpdated");
          return;
        }
        const layer = store.layers.find((l) => l.id === props.layerId);
        if (layer && layer.type === "spline") {
          const splineData = layer.data;
          const point = splineData.controlPoints?.find((p) => p.id === dragTarget.value.pointId);
          if (point && point.handleOut && dragTarget.value.type === "handleOut") {
            const dx = point.handleOut.x - point.x;
            const dy = point.handleOut.y - point.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 5) {
              store.updateSplineControlPoint(props.layerId, point.id, {
                type: "smooth",
                handleIn: { x: point.x - dx, y: point.y - dy }
              });
            } else {
              store.updateSplineControlPoint(props.layerId, point.id, {
                handleOut: null
              });
            }
          }
        }
        dragTarget.value = null;
        emit("pathUpdated");
      }
    }
    function handleRightClick(event) {
      event.preventDefault();
      event.stopPropagation();
      if (!props.layerId) return;
      if (props.isPenMode) {
        emit("togglePenMode");
        previewCurve.value = null;
        previewPoint.value = null;
        insertPreviewPoint.value = null;
        closePathPreview.value = false;
        hoverFeedback.value = null;
        hoveredPointId.value = null;
      }
    }
    function handlePointClick(pointId, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      if (props.isPenMode) {
        if (penSubMode.value === "delete") {
          if (props.layerId) {
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
            hoveredPointId.value = null;
            hoverFeedback.value = null;
          }
          return;
        } else if (penSubMode.value === "convert") {
          if (props.layerId) {
            const newType = point.type === "smooth" ? "corner" : "smooth";
            if (newType === "corner") {
              store.updateSplineControlPoint(props.layerId, pointId, {
                type: "corner",
                handleIn: null,
                handleOut: null
              });
            } else {
              const handleOffset = 30;
              store.updateSplineControlPoint(props.layerId, pointId, {
                type: "smooth",
                handleIn: { x: point.x - handleOffset, y: point.y },
                handleOut: { x: point.x + handleOffset, y: point.y }
              });
            }
            selectedPointId.value = pointId;
            emit("pathUpdated");
          }
          return;
        }
      }
      if (event.shiftKey) {
        if (selectedPointIds.value.includes(pointId)) {
          selectedPointIds.value = selectedPointIds.value.filter((id) => id !== pointId);
        } else {
          selectedPointIds.value = [...selectedPointIds.value, pointId];
        }
        selectedPointId.value = pointId;
      } else {
        selectedPointId.value = pointId;
        selectedPointIds.value = [pointId];
      }
      if (!props.isPenMode) {
        const pos = getMousePos(event);
        dragTarget.value = {
          type: "point",
          pointId,
          startX: pos.x,
          startY: pos.y
        };
      }
    }
    function handlePointHover(pointId) {
      hoveredPointId.value = pointId;
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (props.isPenMode && point) {
        hoverFeedbackPos.value = { x: point.x, y: point.y };
        if (penSubMode.value === "delete") {
          hoverFeedback.value = "Click to delete point";
        } else if (penSubMode.value === "convert") {
          const currentType = point.type === "smooth" ? "smooth" : "corner";
          const newType = currentType === "smooth" ? "corner" : "smooth";
          hoverFeedback.value = `Click to convert to ${newType}`;
        } else {
          hoverFeedback.value = null;
        }
      } else {
        hoverFeedback.value = null;
      }
    }
    function handlePointLeave() {
      hoveredPointId.value = null;
      hoverFeedback.value = null;
      hoverFeedbackPos.value = null;
    }
    function startDragHandle(pointId, handleType, event) {
      const pos = getMousePos(event);
      dragTarget.value = {
        type: handleType === "in" ? "handleIn" : "handleOut",
        pointId,
        startX: pos.x,
        startY: pos.y
      };
    }
    function startDragAxis(pointId, axis, event) {
      const point = visibleControlPoints.value.find((p) => p.id === pointId);
      if (!point) return;
      const pos = getMousePos(event);
      selectedPointId.value = pointId;
      dragTarget.value = {
        type: axis === "X" ? "axisX" : "axisY",
        pointId,
        startX: pos.x,
        startY: pos.y,
        originalX: point.x,
        originalY: point.y,
        // Store screen coordinates for zoom-independent movement
        screenStartX: event.clientX,
        screenStartY: event.clientY
      };
    }
    function handleKeyDown(event) {
      if (event.key === "Delete" || event.key === "Backspace") {
        if (selectedPointId.value && props.layerId) {
          const layer = store.layers.find((l) => l.id === props.layerId);
          if (layer && layer.type === "spline") {
            const pointId = selectedPointId.value;
            store.deleteSplineControlPoint(props.layerId, pointId);
            emit("pointDeleted", pointId);
            emit("pathUpdated");
            selectedPointId.value = null;
            selectedPointIds.value = [];
          }
        }
      }
      if (event.key === "ArrowUp" && selectedPointId.value) {
        event.preventDefault();
        const delta = event.shiftKey ? 100 : 10;
        adjustSelectedPointDepth(delta);
      }
      if (event.key === "ArrowDown" && selectedPointId.value) {
        event.preventDefault();
        const delta = event.shiftKey ? -100 : -10;
        adjustSelectedPointDepth(delta);
      }
      if (event.key === "Escape") {
        selectedPointId.value = null;
        selectedPointIds.value = [];
        hoverFeedback.value = null;
        if (props.isPenMode) {
          emit("togglePenMode");
        }
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeyDown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeyDown);
    });
    __expose({
      selectedPointId,
      selectedPointIds,
      clearSelection: () => {
        selectedPointId.value = null;
        selectedPointIds.value = [];
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        __props.layerId && __props.isPenMode ? (openBlock(), createElementBlock("div", _hoisted_2$e, toDisplayString(activeToolTip.value), 1)) : createCommentVNode("", true),
        hoverFeedback.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "hover-feedback",
          style: normalizeStyle(hoverFeedbackStyle.value)
        }, toDisplayString(hoverFeedback.value), 5)) : createCommentVNode("", true),
        __props.layerId ? (openBlock(), createElementBlock("div", _hoisted_3$e, [
          createBaseVNode("div", _hoisted_4$e, [
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "add" }]),
              onClick: _cache[0] || (_cache[0] = ($event) => setPenSubMode("add")),
              title: "Pen Tool (P) - Add points at end of path"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("svg", {
                viewBox: "0 0 24 24",
                width: "14",
                height: "14"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"
                })
              ], -1),
              createBaseVNode("span", { class: "tool-label" }, "Pen", -1)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "insert" }]),
              onClick: _cache[1] || (_cache[1] = ($event) => setPenSubMode("insert")),
              title: "Add Point (+) - Click on path to insert point"
            }, [..._cache[6] || (_cache[6] = [
              createStaticVNode('<svg viewBox="0 0 24 24" width="14" height="14" data-v-9ec6a2eb><path fill="currentColor" d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" data-v-9ec6a2eb></path><circle cx="18" cy="18" r="5" fill="#1e1e1e" data-v-9ec6a2eb></circle><path fill="currentColor" d="M18,15v6M15,18h6" stroke="currentColor" stroke-width="1.5" data-v-9ec6a2eb></path></svg><span class="tool-label" data-v-9ec6a2eb>Pen+</span>', 2)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "delete" }]),
              onClick: _cache[2] || (_cache[2] = ($event) => setPenSubMode("delete")),
              title: "Delete Point (-) - Click point to remove"
            }, [..._cache[7] || (_cache[7] = [
              createStaticVNode('<svg viewBox="0 0 24 24" width="14" height="14" data-v-9ec6a2eb><path fill="currentColor" d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87L20.71,7.04Z M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" data-v-9ec6a2eb></path><circle cx="18" cy="18" r="5" fill="#1e1e1e" data-v-9ec6a2eb></circle><path fill="currentColor" d="M15,18h6" stroke="currentColor" stroke-width="1.5" data-v-9ec6a2eb></path></svg><span class="tool-label" data-v-9ec6a2eb>Pen-</span>', 2)
            ])], 2),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn icon-btn", { active: __props.isPenMode && penSubMode.value === "convert" }]),
              onClick: _cache[3] || (_cache[3] = ($event) => setPenSubMode("convert")),
              title: "Convert Point (^) - Click to toggle smooth/corner"
            }, [..._cache[8] || (_cache[8] = [
              createBaseVNode("svg", {
                viewBox: "0 0 24 24",
                width: "14",
                height: "14"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M12,2L6,8H9V14H6L12,20L18,14H15V8H18L12,2Z",
                  transform: "rotate(180 12 11)"
                })
              ], -1),
              createBaseVNode("span", { class: "tool-label" }, "Convert", -1)
            ])], 2)
          ]),
          _cache[12] || (_cache[12] = createBaseVNode("div", { class: "toolbar-separator" }, null, -1)),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_5$e, [
            createBaseVNode("button", {
              class: "toolbar-btn",
              onClick: smoothSelectedPoints,
              title: selectedPointIds.value.length > 0 ? "Smooth selected points" : "Smooth all path handles"
            }, " Smooth" + toDisplayString(selectedPointIds.value.length > 0 ? ` (${selectedPointIds.value.length})` : ""), 9, _hoisted_6$e),
            createBaseVNode("button", {
              class: "toolbar-btn",
              onClick: simplifySpline,
              title: "Simplify path (reduce control points)"
            }, " Simplify "),
            createBaseVNode("button", {
              class: normalizeClass(["toolbar-btn", { active: isClosed.value }]),
              onClick: toggleClosePath,
              title: "Toggle closed path"
            }, toDisplayString(isClosed.value ? "Open" : "Close"), 3)
          ])) : createCommentVNode("", true),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_7$e, [
            createBaseVNode("label", _hoisted_8$e, [
              _cache[9] || (_cache[9] = createTextVNode(" Tolerance: ", -1)),
              withDirectives(createBaseVNode("input", {
                type: "range",
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => smoothTolerance.value = $event),
                min: "1",
                max: "50",
                step: "1",
                class: "tolerance-slider"
              }, null, 512), [
                [
                  vModelText,
                  smoothTolerance.value,
                  void 0,
                  { number: true }
                ]
              ]),
              createBaseVNode("span", _hoisted_9$e, toDisplayString(smoothTolerance.value) + "px", 1)
            ])
          ])) : createCommentVNode("", true),
          hasControlPoints.value ? (openBlock(), createElementBlock("div", _hoisted_10$e, toDisplayString(visibleControlPoints.value.length) + " points" + toDisplayString(selectedPointIds.value.length > 0 ? ` (${selectedPointIds.value.length} selected)` : ""), 1)) : createCommentVNode("", true),
          selectedPointId.value ? (openBlock(), createElementBlock("div", _hoisted_11$d, [
            createBaseVNode("label", _hoisted_12$c, [
              _cache[10] || (_cache[10] = createTextVNode(" Z: ", -1)),
              createBaseVNode("input", {
                type: "number",
                value: selectedPointDepth.value,
                onInput: updateSelectedPointDepth,
                class: "z-depth-input",
                step: "10"
              }, null, 40, _hoisted_13$c)
            ]),
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "z-depth-hint" }, "(/ keys)", -1))
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(), createElementBlock("svg", {
          class: "control-overlay",
          viewBox: `0 0 ${__props.canvasWidth} ${__props.canvasHeight}`,
          style: normalizeStyle(overlayStyle.value),
          onMousedown: handleMouseDown,
          onMousemove: handleMouseMove,
          onMouseup: handleMouseUp,
          onMouseleave: handleMouseUp,
          onContextmenu: handleRightClick
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handles-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 0,
                x1: point.x,
                y1: point.y,
                x2: point.handleIn.x,
                y2: point.handleIn.y,
                class: "handle-line",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_15$a)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("line", {
                key: 1,
                x1: point.x,
                y1: point.y,
                x2: point.handleOut.x,
                y2: point.handleOut.y,
                class: "handle-line",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_16$9)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock(Fragment, {
              key: `handle-points-${point.id}`
            }, [
              point.handleIn && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.handleIn.x,
                cy: point.handleIn.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleIn" && dragTarget.value.pointId === point.id }]),
                style: normalizeStyle({ fill: strokeColor.value }),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "in", $event), ["stop"])
              }, null, 46, _hoisted_17$9)) : createCommentVNode("", true),
              point.handleOut && selectedPointId.value === point.id ? (openBlock(), createElementBlock("circle", {
                key: 1,
                cx: point.handleOut.x,
                cy: point.handleOut.y,
                r: "4",
                class: normalizeClass(["handle-point", { active: dragTarget.value?.type === "handleOut" && dragTarget.value.pointId === point.id }]),
                style: normalizeStyle({ fill: strokeColor.value }),
                onMousedown: withModifiers(($event) => startDragHandle(point.id, "out", $event), ["stop"])
              }, null, 46, _hoisted_18$9)) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleControlPoints.value, (point) => {
            return openBlock(), createElementBlock("g", {
              key: `point-${point.id}`
            }, [
              pointHasKeyframes(point.id) ? (openBlock(), createElementBlock("circle", {
                key: 0,
                cx: point.x,
                cy: point.y,
                r: "8",
                class: "keyframe-indicator",
                style: normalizeStyle({ stroke: strokeColor.value })
              }, null, 12, _hoisted_19$9)) : createCommentVNode("", true),
              createBaseVNode("circle", {
                cx: point.x,
                cy: point.y,
                r: "5",
                class: normalizeClass(["control-point", {
                  selected: selectedPointId.value === point.id || selectedPointIds.value.includes(point.id),
                  corner: point.type === "corner",
                  smooth: point.type === "smooth",
                  keyframed: pointHasKeyframes(point.id),
                  "will-delete": __props.isPenMode && penSubMode.value === "delete" && hoveredPointId.value === point.id,
                  "will-convert": __props.isPenMode && penSubMode.value === "convert" && hoveredPointId.value === point.id
                }]),
                style: normalizeStyle({ fill: strokeColor.value, stroke: "#ffffff" }),
                onMousedown: withModifiers(($event) => handlePointClick(point.id, $event), ["stop"]),
                onMouseenter: ($event) => handlePointHover(point.id),
                onMouseleave: handlePointLeave
              }, null, 46, _hoisted_20$9),
              selectedPointId.value === point.id && !props.isPenMode ? (openBlock(), createElementBlock("g", _hoisted_21$9, [
                createBaseVNode("circle", {
                  cx: point.x,
                  cy: point.y,
                  r: "10",
                  class: "selection-ring",
                  style: normalizeStyle({ stroke: strokeColor.value })
                }, null, 12, _hoisted_22$9),
                createBaseVNode("g", _hoisted_23$9, [
                  createBaseVNode("line", {
                    x1: point.x + 12,
                    y1: point.y,
                    x2: point.x + 35,
                    y2: point.y,
                    class: "axis-line axis-x"
                  }, null, 8, _hoisted_24$7),
                  createBaseVNode("polygon", {
                    points: `${point.x + 40},${point.y} ${point.x + 33},${point.y - 4} ${point.x + 33},${point.y + 4}`,
                    class: "axis-arrow axis-x"
                  }, null, 8, _hoisted_25$6),
                  createBaseVNode("rect", {
                    x: point.x + 12,
                    y: point.y - 8,
                    width: "30",
                    height: "16",
                    class: "axis-hit-area",
                    onMousedown: withModifiers(($event) => startDragAxis(point.id, "X", $event), ["stop"])
                  }, null, 40, _hoisted_26$6)
                ]),
                createBaseVNode("g", _hoisted_27$6, [
                  createBaseVNode("line", {
                    x1: point.x,
                    y1: point.y + 12,
                    x2: point.x,
                    y2: point.y + 35,
                    class: "axis-line axis-y"
                  }, null, 8, _hoisted_28$6),
                  createBaseVNode("polygon", {
                    points: `${point.x},${point.y + 40} ${point.x - 4},${point.y + 33} ${point.x + 4},${point.y + 33}`,
                    class: "axis-arrow axis-y"
                  }, null, 8, _hoisted_29$6),
                  createBaseVNode("rect", {
                    x: point.x - 8,
                    y: point.y + 12,
                    width: "16",
                    height: "30",
                    class: "axis-hit-area",
                    onMousedown: withModifiers(($event) => startDragAxis(point.id, "Y", $event), ["stop"])
                  }, null, 40, _hoisted_30$5)
                ])
              ])) : createCommentVNode("", true),
              selectedPointId.value === point.id && is3DLayer.value ? (openBlock(), createElementBlock("g", _hoisted_31$4, [
                createBaseVNode("line", {
                  x1: point.x + 15,
                  y1: point.y - 30,
                  x2: point.x + 15,
                  y2: point.y + 30,
                  class: "z-axis-line"
                }, null, 8, _hoisted_32$4),
                createBaseVNode("polygon", {
                  points: `${point.x + 15},${point.y - 35} ${point.x + 12},${point.y - 28} ${point.x + 18},${point.y - 28}`,
                  class: "z-arrow"
                }, null, 8, _hoisted_33$4),
                createBaseVNode("polygon", {
                  points: `${point.x + 15},${point.y + 35} ${point.x + 12},${point.y + 28} ${point.x + 18},${point.y + 28}`,
                  class: "z-arrow"
                }, null, 8, _hoisted_34$4),
                createBaseVNode("polygon", {
                  points: getZHandlePoints(point),
                  class: normalizeClass(["z-handle", { active: dragTarget.value?.type === "depth" && dragTarget.value.pointId === point.id }]),
                  onMousedown: withModifiers(($event) => startDragDepth(point.id, $event), ["stop"])
                }, null, 42, _hoisted_35$3),
                createBaseVNode("text", {
                  x: point.x + 25,
                  y: point.y + getDepthOffset(point),
                  class: "z-label"
                }, " Z: " + toDisplayString(getPointDepth(point).toFixed(0)), 9, _hoisted_36$3)
              ])) : createCommentVNode("", true)
            ]);
          }), 128)),
          previewCurve.value ? (openBlock(), createElementBlock("path", {
            key: 0,
            d: previewCurve.value,
            class: "preview-curve",
            fill: "none"
          }, null, 8, _hoisted_37$3)) : createCommentVNode("", true),
          previewPoint.value && __props.isPenMode ? (openBlock(), createElementBlock("circle", {
            key: 1,
            cx: previewPoint.value.x,
            cy: previewPoint.value.y,
            r: "4",
            class: "preview-point"
          }, null, 8, _hoisted_38$3)) : createCommentVNode("", true),
          insertPreviewPoint.value && penSubMode.value === "insert" ? (openBlock(), createElementBlock("circle", {
            key: 2,
            cx: insertPreviewPoint.value.x,
            cy: insertPreviewPoint.value.y,
            r: "5",
            class: "insert-preview-point"
          }, null, 8, _hoisted_39$3)) : createCommentVNode("", true),
          canClosePath.value && closePathPreview.value ? (openBlock(), createElementBlock("circle", {
            key: 3,
            cx: visibleControlPoints.value[0].x,
            cy: visibleControlPoints.value[0].y,
            r: "10",
            class: "close-indicator"
          }, null, 8, _hoisted_40$2)) : createCommentVNode("", true)
        ], 44, _hoisted_14$b))
      ]);
    };
  }
});

const SplineEditor = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-9ec6a2eb"]]);

const _hoisted_1$d = {
  key: 1,
  class: "overlay-controls"
};
const _hoisted_2$d = { class: "render-mode-controls" };
const _hoisted_3$d = {
  key: 2,
  class: "transform-mode-controls"
};
const _hoisted_4$d = {
  key: 3,
  class: "performance-overlay"
};
const _hoisted_5$d = { class: "viewer-controls" };
const _hoisted_6$d = { class: "zoom-display" };
const _hoisted_7$d = {
  key: 4,
  class: "loading-overlay"
};
const _hoisted_8$d = ["src"];
const _hoisted_9$d = {
  key: 7,
  class: "segment-loading"
};
const _hoisted_10$d = {
  key: 9,
  class: "safe-frame-container"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "ThreeCanvas",
  setup(__props, { expose: __expose }) {
    const store = useCompositorStore();
    const containerRef = ref(null);
    const canvasRef = ref(null);
    const splineEditorRef = ref(null);
    const engine = shallowRef(null);
    const loading = ref(false);
    const zoom = ref(1);
    const canvasWidth = ref(800);
    const canvasHeight = ref(600);
    const compositionWidth = computed(() => store.width || 832);
    const compositionHeight = computed(() => store.height || 480);
    const showDepthOverlay = ref(false);
    const depthColormap = ref("viridis");
    const depthOpacity = ref(50);
    const renderMode = ref("color");
    const showPerformance = ref(false);
    const performanceStats = ref({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    const viewportTransform = ref([1, 0, 0, 1, 0, 0]);
    const cameraUpdateTrigger = ref(0);
    const zoomLevel = ref("fit");
    const resolution = ref("full");
    const zoomDisplayPercent = computed(() => Math.round(zoom.value * 100));
    const transformMode = ref("translate");
    const showGrid = ref(true);
    const showOutsideOverlay = ref(false);
    const showSafeFrameGuides = ref(false);
    const isDrawingSegmentBox = ref(false);
    const segmentBoxEnd = ref(null);
    const maskOverlayStyle = computed(() => {
      const mask = store.segmentPendingMask;
      if (!mask) return {};
      const vpt = viewportTransform.value;
      const screenX = mask.bounds.x * vpt[0] + vpt[4];
      const screenY = mask.bounds.y * vpt[3] + vpt[5];
      const screenWidth = mask.bounds.width * vpt[0];
      const screenHeight = mask.bounds.height * vpt[3];
      return {
        left: `${screenX}px`,
        top: `${screenY}px`,
        width: `${screenWidth}px`,
        height: `${screenHeight}px`
      };
    });
    const segmentBoxStyle = computed(() => {
      const start = store.segmentBoxStart;
      const end = segmentBoxEnd.value;
      if (!start || !end) return {};
      const vpt = viewportTransform.value;
      const x1 = start.x * vpt[0] + vpt[4];
      const y1 = start.y * vpt[3] + vpt[5];
      const x2 = end.x * vpt[0] + vpt[4];
      const y2 = end.y * vpt[3] + vpt[5];
      return {
        left: `${Math.min(x1, x2)}px`,
        top: `${Math.min(y1, y2)}px`,
        width: `${Math.abs(x2 - x1)}px`,
        height: `${Math.abs(y2 - y1)}px`
      };
    });
    const safeFrameBounds = computed(() => {
      if (!containerRef.value || !engine.value) {
        return { left: 0, top: 0, right: 0, bottom: 0 };
      }
      const viewportWidth = canvasWidth.value;
      const viewportHeight = canvasHeight.value;
      const compWidth = store.width || 1920;
      const compHeight = store.height || 1080;
      const camera = engine.value.getCameraController().camera;
      const topLeft = new Vector3(0, 0, 0);
      const bottomRight = new Vector3(compWidth, -compHeight, 0);
      topLeft.project(camera);
      bottomRight.project(camera);
      const left = (topLeft.x + 1) / 2 * viewportWidth;
      const top = (-topLeft.y + 1) / 2 * viewportHeight;
      const right = (bottomRight.x + 1) / 2 * viewportWidth;
      const bottom = (-bottomRight.y + 1) / 2 * viewportHeight;
      return { left, top, right, bottom };
    });
    const safeFrameLeftStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: "0",
        top: "0",
        width: `${Math.max(0, bounds.left)}px`,
        height: "100%"
      };
    });
    const safeFrameRightStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${bounds.right}px`,
        top: "0",
        width: `calc(100% - ${bounds.right}px)`,
        height: "100%"
      };
    });
    const safeFrameTopStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: "0",
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `${Math.max(0, bounds.top)}px`
      };
    });
    const safeFrameBottomStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      return {
        left: `${Math.max(0, bounds.left)}px`,
        top: `${bounds.bottom}px`,
        width: `${bounds.right - Math.max(0, bounds.left)}px`,
        height: `calc(100% - ${bounds.bottom}px)`
      };
    });
    const compositionBoundaryStyle = computed(() => {
      const bounds = safeFrameBounds.value;
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      if (width <= 0 || height <= 0) {
        return { display: "none" };
      }
      return {
        left: `${bounds.left}px`,
        top: `${bounds.top}px`,
        width: `${width}px`,
        height: `${height}px`
      };
    });
    const hasDepthMap = computed(() => store.depthMap !== null);
    const isPenMode = computed(() => store.currentTool === "pen");
    const activeSplineLayerId = computed(() => {
      const selectedLayer = store.selectedLayer;
      if (selectedLayer?.type === "spline") {
        return selectedLayer.id;
      }
      if (isPenMode.value) {
        const splines = store.layers.filter((l) => l.type === "spline");
        return splines.length > 0 ? splines[splines.length - 1].id : null;
      }
      return null;
    });
    const viewportTransformArray = computed(() => viewportTransform.value);
    onMounted(async () => {
      if (!canvasRef.value || !containerRef.value) return;
      const container = containerRef.value;
      const rect = container.getBoundingClientRect();
      canvasWidth.value = rect.width;
      canvasHeight.value = rect.height;
      const config = {
        canvas: canvasRef.value,
        width: rect.width,
        height: rect.height,
        compositionWidth: store.width || 1920,
        compositionHeight: store.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      };
      try {
        loading.value = true;
        engine.value = new WeylEngine(config);
        engine.value.setAssetGetter((assetId) => store.assets[assetId]);
        engine.value.setVideoMetadataCallback((layerId, metadata) => {
          store.onVideoMetadataLoaded(layerId, metadata);
        });
        engine.value.setCameraCallbacks(
          (cameraId) => store.getCamera(cameraId),
          (cameraId, updates) => store.updateCamera(cameraId, updates),
          (cameraId, frame) => store.getCameraAtFrame(cameraId, frame)
        );
        engine.value.setNestedCompRenderContext({
          renderComposition: (compositionId, frame) => {
            const comp = store.getComposition(compositionId);
            if (!comp) {
              console.warn("[ThreeCanvas] Nested comp not found:", compositionId);
              return null;
            }
            if (!comp.layers || comp.layers.length === 0) {
              return null;
            }
            return engine.value.renderCompositionToTexture(
              compositionId,
              comp.layers,
              {
                width: comp.settings.width,
                height: comp.settings.height,
                fps: comp.settings.fps
              },
              frame
            );
          },
          getComposition: (compositionId) => store.getComposition(compositionId)
        });
        engine.value.setAudioReactiveCallback(
          (layerId, frame) => store.getAudioReactiveValuesForLayer(layerId, frame)
        );
        engine.value.initializeTransformControls();
        engine.value.setTransformChangeCallback((layerId, transform) => {
          handleTransformChange(layerId, transform);
        });
        engine.value.initializeParticleSystems();
        engine.value.setCompositionFPS(store.fps || 60);
        engine.value.initialize3DServices();
        engine.value.enableOrbitControls();
        engine.value.resetCameraToDefault();
        engine.value.start();
        await nextTick();
        syncLayersToEngine();
        store.initializePropertyDriverSystem();
        const initialFrameState = store.getFrameState(store.currentFrame);
        engine.value.applyFrameState(initialFrameState);
        setupInputHandlers();
        const resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(container);
        centerOnComposition();
      } catch (err) {
        console.error("[ThreeCanvas] Failed to initialize engine:", err);
      } finally {
        loading.value = false;
      }
      setupWatchers();
    });
    onUnmounted(() => {
      if (engine.value) {
        engine.value.stop();
        engine.value.dispose();
        engine.value = null;
      }
    });
    function setupWatchers() {
      watch(
        () => store.layers,
        () => {
          syncLayersToEngine();
          if (engine.value) {
            const frameState = store.getFrameState(store.currentFrame);
            engine.value.applyFrameState(frameState);
          }
        },
        { deep: true }
      );
      watch(
        () => store.currentFrame,
        (frame) => {
          if (engine.value) {
            applyPropertyDrivers();
            const frameState = store.getFrameState(frame);
            engine.value.applyFrameState(frameState);
          }
        }
      );
      watch(
        () => [store.width, store.height],
        ([width, height]) => {
          if (engine.value) {
            engine.value.resize(canvasWidth.value, canvasHeight.value, width, height);
            centerOnComposition();
          }
        }
      );
      watch(
        () => store.sourceImage,
        async (imageData) => {
          if (engine.value && imageData) {
            await loadSourceImage(imageData);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.depthMap,
        async (depthData) => {
          if (engine.value && depthData) {
            await loadDepthMap(depthData);
          }
        },
        { immediate: true }
      );
      watch(
        () => engine.value?.getPerformanceStats(),
        (stats) => {
          if (stats) {
            performanceStats.value = stats;
          }
        }
      );
      watch(
        () => store.activeCameraId,
        (activeCameraId) => {
          if (!engine.value) return;
          if (!activeCameraId) {
            engine.value.setActiveCameraLayer(null);
            return;
          }
          const cameraLayer = store.layers.find(
            (l) => l.type === "camera" && l.data?.cameraId === activeCameraId
          );
          if (cameraLayer) {
            engine.value.setActiveCameraLayer(cameraLayer.id);
          }
        },
        { immediate: true }
      );
      watch(
        () => store.selectedLayerIds,
        (selectedIds) => {
          if (!engine.value) return;
          const selectedId = selectedIds.length > 0 ? selectedIds[0] : null;
          engine.value.selectLayer(selectedId);
        },
        { deep: true }
      );
      watch(
        () => store.viewOptions.showGrid,
        (showGridVisible) => {
          if (!engine.value) return;
          showGrid.value = showGridVisible;
          engine.value.setCompositionGridVisible(showGridVisible);
        },
        { immediate: true }
      );
      watch(
        () => store.viewOptions.showCompositionBounds,
        (_showBounds) => {
          if (!engine.value) return;
          engine.value.setCompositionBoundsVisible(false);
        },
        { immediate: true }
      );
    }
    function syncLayersToEngine() {
      if (!engine.value) return;
      const engineLayerIds = new Set(engine.value.getLayerIds());
      const storeLayerIds = new Set(store.layers.map((l) => l.id));
      for (const id of engineLayerIds) {
        if (!storeLayerIds.has(id)) {
          engine.value.removeLayer(id);
        }
      }
      for (const layer of store.layers) {
        if (engineLayerIds.has(layer.id)) {
          engine.value.updateLayer(layer.id, layer);
        } else {
          engine.value.addLayer(layer);
        }
      }
    }
    function applyPropertyDrivers() {
      if (!engine.value) return;
      engine.value.clearAllDrivenValues();
      for (const layer of store.layers) {
        const drivenValues = store.getDrivenValuesForLayer(layer.id);
        if (drivenValues.size > 0) {
          engine.value.setLayerDrivenValues(layer.id, drivenValues);
        }
      }
    }
    async function loadSourceImage(imageData) {
      if (!engine.value) return;
      try {
        loading.value = true;
        const img = await loadImage(imageData);
        engine.value.setBackgroundImage(img);
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load source image:", err);
      } finally {
        loading.value = false;
      }
    }
    async function loadDepthMap(depthData) {
      if (!engine.value) return;
      try {
        const img = await loadImage(depthData);
        engine.value.setDepthMap(img, {
          colormap: depthColormap.value,
          opacity: depthOpacity.value / 100,
          visible: showDepthOverlay.value
        });
      } catch (err) {
        console.error("[ThreeCanvas] Failed to load depth map:", err);
      }
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
      });
    }
    function setupInputHandlers() {
      const container = containerRef.value;
      const canvas = canvasRef.value;
      if (!container || !canvas) return;
      let isPanning = false;
      let isZooming = false;
      let lastPosX = 0;
      let lastPosY = 0;
      let zoomStartY = 0;
      let zoomStartLevel = 1;
      container.addEventListener("mousedown", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("auxclick", (e) => {
        if (e.button === 1) {
          e.preventDefault();
        }
      });
      container.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        let newZoom = zoom.value * (delta > 0 ? 0.9 : 1.1);
        newZoom = Math.min(Math.max(newZoom, 0.1), 10);
        zoom.value = newZoom;
        viewportTransform.value[0] = newZoom;
        viewportTransform.value[3] = newZoom;
        if (engine.value) {
          engine.value.getCameraController().setZoom(newZoom);
          cameraUpdateTrigger.value++;
        }
      }, { passive: false });
      canvas.addEventListener("mousedown", (e) => {
        const currentTool = store.currentTool;
        if (e.button === 1 || currentTool === "hand" || e.button === 0 && e.altKey) {
          isPanning = true;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          canvas.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }
        if (currentTool === "zoom") {
          if (e.shiftKey) {
            const newZoom = Math.max(zoom.value * 0.7, 0.1);
            zoom.value = newZoom;
            viewportTransform.value[0] = newZoom;
            viewportTransform.value[3] = newZoom;
            if (engine.value) {
              engine.value.setViewportTransform(viewportTransform.value);
            }
          } else {
            isZooming = true;
            zoomStartY = e.clientY;
            zoomStartLevel = zoom.value;
          }
          return;
        }
        if (currentTool === "text") {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          const newLayer = store.createLayer("text");
          if (newLayer.transform?.position) {
            newLayer.transform.position.value = { x: scenePos.x, y: scenePos.y, z: 0 };
          }
          store.updateLayer(newLayer.id, {
            transform: {
              ...newLayer.transform,
              position: {
                ...newLayer.transform.position,
                value: { x: scenePos.x, y: scenePos.y, z: 0 }
              }
            }
          });
          store.selectLayer(newLayer.id);
          store.setTool("select");
          return;
        }
        if (currentTool === "segment" && e.button === 0) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          if (store.segmentMode === "point") {
            handleSegmentPoint(scenePos.x, scenePos.y);
          } else {
            store.setSegmentBoxStart({ x: scenePos.x, y: scenePos.y });
            segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
            isDrawingSegmentBox.value = true;
          }
          return;
        }
        if (currentTool === "select" && e.button === 0) {
          if (engine.value?.isTransformDragging()) {
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 2 - 1;
          const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
          if (engine.value) {
            const hitLayer = engine.value.raycastLayers(x, y);
            if (hitLayer) {
              store.selectLayer(hitLayer);
              engine.value.selectLayer(hitLayer);
            } else {
              store.clearSelection();
              engine.value.selectLayer(null);
            }
          }
        }
      });
      canvas.addEventListener("mousemove", (e) => {
        if (isPanning && engine.value) {
          const dx = e.clientX - lastPosX;
          const dy = e.clientY - lastPosY;
          lastPosX = e.clientX;
          lastPosY = e.clientY;
          const camera = engine.value.getCameraController();
          const currentPan = camera.getPan();
          const compHeight = store.height || 1080;
          const fovRad = Math.PI * camera.getFOV() / 180;
          const distance = compHeight / 2 / Math.tan(fovRad / 2) / zoom.value;
          const viewHeight = 2 * distance * Math.tan(fovRad / 2);
          const container2 = containerRef.value;
          if (container2) {
            const rect = container2.getBoundingClientRect();
            const worldPerPixel = viewHeight / rect.height;
            camera.setPan(
              currentPan.x - dx * worldPerPixel,
              currentPan.y - dy * worldPerPixel
              // Positive dy should move camera up (view shifts down)
            );
            cameraUpdateTrigger.value++;
          }
          return;
        }
        if (isZooming && engine.value) {
          const dy = zoomStartY - e.clientY;
          const zoomFactor = 1 + dy * 0.01;
          const newZoom = Math.max(0.1, Math.min(10, zoomStartLevel * zoomFactor));
          zoom.value = newZoom;
          viewportTransform.value[0] = newZoom;
          viewportTransform.value[3] = newZoom;
          engine.value.getCameraController().setZoom(newZoom);
          cameraUpdateTrigger.value++;
          return;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart) {
          const rect = canvas.getBoundingClientRect();
          const scenePos = screenToScene(e.clientX - rect.left, e.clientY - rect.top);
          segmentBoxEnd.value = { x: scenePos.x, y: scenePos.y };
          return;
        }
        const currentTool = store.currentTool;
        if (currentTool === "hand") canvas.style.cursor = "grab";
        else if (currentTool === "zoom") canvas.style.cursor = "zoom-in";
        else if (currentTool === "text") canvas.style.cursor = "text";
        else if (currentTool === "pen") canvas.style.cursor = "crosshair";
        else if (currentTool === "segment") canvas.style.cursor = "crosshair";
        else canvas.style.cursor = "default";
      });
      canvas.addEventListener("mouseup", (e) => {
        if (isPanning) {
          isPanning = false;
          canvas.style.cursor = store.currentTool === "hand" ? "grab" : "default";
        }
        if (isZooming) {
          isZooming = false;
        }
        if (isDrawingSegmentBox.value && store.segmentBoxStart && segmentBoxEnd.value) {
          isDrawingSegmentBox.value = false;
          handleSegmentBox(
            store.segmentBoxStart.x,
            store.segmentBoxStart.y,
            segmentBoxEnd.value.x,
            segmentBoxEnd.value.y
          );
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
      canvas.addEventListener("mouseleave", () => {
        isPanning = false;
        isZooming = false;
        if (isDrawingSegmentBox.value) {
          isDrawingSegmentBox.value = false;
          store.setSegmentBoxStart(null);
          segmentBoxEnd.value = null;
        }
      });
    }
    function screenToScene(screenX, screenY) {
      const vpt = viewportTransform.value;
      return {
        x: (screenX - vpt[4]) / vpt[0],
        y: (screenY - vpt[5]) / vpt[3]
      };
    }
    async function handleSegmentPoint(x, y) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      store.setSegmentLoading(true);
      try {
        const result = await segmentByPoint(store.sourceImage, { x, y });
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    async function handleSegmentBox(x1, y1, x2, y2) {
      if (!store.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      const box = [
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.max(x1, x2),
        Math.max(y1, y2)
      ];
      store.setSegmentLoading(true);
      try {
        const result = await segmentByBox(store.sourceImage, box);
        if (result.status === "success" && result.masks && result.masks.length > 0) {
          const mask = result.masks[0];
          store.setSegmentPendingMask({
            mask: mask.mask,
            bounds: mask.bounds,
            area: mask.area,
            score: mask.score
          });
          console.log("[ThreeCanvas] Box segmentation successful, mask area:", mask.area);
        } else {
          console.warn("[ThreeCanvas] Box segmentation returned no masks:", result.message);
        }
      } catch (err) {
        console.error("[ThreeCanvas] Box segmentation failed:", err);
      } finally {
        store.setSegmentLoading(false);
      }
    }
    function handleTransformChange(layerId, transform) {
      const layer = store.layers.find((l) => l.id === layerId);
      if (!layer) return;
      const updates = {};
      if (transform.position && layer.transform) {
        updates.transform = {
          ...layer.transform,
          position: {
            ...layer.transform.position,
            value: {
              x: transform.position.x,
              y: transform.position.y,
              z: transform.position.z ?? layer.transform.position?.value?.z ?? 0
            }
          }
        };
      }
      if (layer.threeD) {
        if (transform.rotationX !== void 0 || transform.rotationY !== void 0 || transform.rotationZ !== void 0) {
          if (!updates.transform && layer.transform) {
            updates.transform = { ...layer.transform };
          }
          if (updates.transform) {
            if (transform.rotationX !== void 0) {
              updates.transform.rotationX = { ...layer.transform.rotationX, value: transform.rotationX };
            }
            if (transform.rotationY !== void 0) {
              updates.transform.rotationY = { ...layer.transform.rotationY, value: transform.rotationY };
            }
            if (transform.rotationZ !== void 0) {
              updates.transform.rotationZ = { ...layer.transform.rotationZ, value: transform.rotationZ };
            }
          }
        }
      } else {
        if (transform.rotation !== void 0 && layer.transform) {
          if (!updates.transform) {
            updates.transform = { ...layer.transform };
          }
          updates.transform.rotation = { ...layer.transform.rotation, value: transform.rotation };
        }
      }
      if (transform.scale && layer.transform) {
        if (!updates.transform) {
          updates.transform = { ...layer.transform };
        }
        updates.transform.scale = {
          ...layer.transform.scale,
          value: {
            x: transform.scale.x,
            y: transform.scale.y,
            z: transform.scale.z ?? layer.transform.scale?.value?.z ?? 100
          }
        };
      }
      if (Object.keys(updates).length > 0) {
        store.updateLayer(layerId, updates);
      }
    }
    function setTransformModeTo(mode) {
      transformMode.value = mode;
      if (engine.value) {
        engine.value.setTransformMode(mode);
      }
    }
    function handleResize(entries) {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          canvasWidth.value = width;
          canvasHeight.value = height;
          if (engine.value) {
            engine.value.resize(width, height);
            centerOnComposition();
          }
        }
      }
    }
    function centerOnComposition() {
      const container = containerRef.value;
      if (!container || !engine.value) return;
      const padding = 40;
      engine.value.fitCompositionToViewport(padding);
      const camera = engine.value.getCameraController();
      const calculatedZoom = camera.getZoom();
      zoom.value = calculatedZoom;
      viewportTransform.value = [calculatedZoom, 0, 0, calculatedZoom, 0, 0];
      requestAnimationFrame(() => {
        cameraUpdateTrigger.value++;
      });
    }
    function setRenderMode(mode) {
      renderMode.value = mode;
      if (engine.value) {
        engine.value.setRenderMode(mode);
      }
    }
    function onPointAdded(_point) {
      if (!activeSplineLayerId.value) {
        const newLayer = store.createLayer("spline");
        store.selectLayer(newLayer.id);
      }
    }
    function onPathUpdated() {
      syncLayersToEngine();
    }
    function togglePenMode() {
      if (store.currentTool === "pen") {
        store.setTool("select");
      } else {
        store.setTool("pen");
      }
    }
    function zoomIn() {
      const newZoom = Math.min(zoom.value * 1.2, 10);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function zoomOut() {
      const newZoom = Math.max(zoom.value * 0.8, 0.1);
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function fitToView() {
      centerOnComposition();
    }
    function resetCamera() {
      if (engine.value) {
        engine.value.resetCameraToDefault();
        centerOnComposition();
      }
    }
    function toggleGrid() {
      store.updateViewOptions({ showGrid: !store.viewOptions.showGrid });
    }
    function toggleOutsideOverlay() {
      showOutsideOverlay.value = !showOutsideOverlay.value;
      showSafeFrameGuides.value = showOutsideOverlay.value;
    }
    function setZoom(newZoom) {
      newZoom = Math.max(0.1, Math.min(10, newZoom));
      zoom.value = newZoom;
      viewportTransform.value[0] = newZoom;
      viewportTransform.value[3] = newZoom;
      if (engine.value) {
        engine.value.setViewportTransform(viewportTransform.value);
      }
    }
    function onZoomSelect() {
      if (zoomLevel.value === "fit") {
        fitToView();
      } else {
        const newZoom = parseFloat(zoomLevel.value);
        if (!isNaN(newZoom)) {
          setZoom(newZoom);
          if (engine.value) {
            engine.value.getCameraController().setZoom(newZoom);
          }
        }
      }
    }
    function onResolutionChange() {
      if (!engine.value) return;
      const comp = store.getActiveComp();
      if (!comp) return;
      const fullWidth = comp.settings.width;
      const fullHeight = comp.settings.height;
      let factor = 1;
      switch (resolution.value) {
        case "half":
          factor = 0.5;
          break;
        case "third":
          factor = 1 / 3;
          break;
        case "quarter":
          factor = 0.25;
          break;
        default:
          factor = 1;
      }
      const newWidth = Math.round(fullWidth * factor);
      const newHeight = Math.round(fullHeight * factor);
      engine.value.setResolution(newWidth, newHeight);
      console.log(`[ThreeCanvas] Resolution changed to ${resolution.value}: ${newWidth}x${newHeight}`);
    }
    async function captureFrame() {
      if (!engine.value) return null;
      const result = engine.value.captureFrame();
      if (!result?.imageData) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      ctx.putImageData(result.imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    async function captureDepth() {
      if (!engine.value) return null;
      const result = engine.value.captureDepth();
      if (!result?.depthBuffer) return null;
      const canvas = document.createElement("canvas");
      canvas.width = result.width;
      canvas.height = result.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const imageData = ctx.createImageData(result.width, result.height);
      for (let i = 0; i < result.depthBuffer.length; i++) {
        const value = Math.floor(result.depthBuffer[i] * 255);
        const idx = i * 4;
        imageData.data[idx] = value;
        imageData.data[idx + 1] = value;
        imageData.data[idx + 2] = value;
        imageData.data[idx + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }
    watch(showDepthOverlay, (visible) => {
      if (engine.value) {
        engine.value.setDepthOverlayVisible(visible);
      }
    });
    watch(depthColormap, (colormap) => {
      if (engine.value) {
        engine.value.setDepthColormap(colormap);
      }
    });
    watch(depthOpacity, (opacity) => {
      if (engine.value) {
        engine.value.setDepthOpacity(opacity / 100);
      }
    });
    __expose({
      engine,
      fitToView,
      zoomIn,
      zoomOut,
      zoom,
      setZoom,
      captureFrame,
      captureDepth,
      showPerformance,
      performanceStats,
      renderMode,
      setRenderMode,
      transformMode,
      setTransformModeTo,
      resetCamera
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "three-canvas",
        ref_key: "containerRef",
        ref: containerRef
      }, [
        createBaseVNode("canvas", {
          ref_key: "canvasRef",
          ref: canvasRef
        }, null, 512),
        activeSplineLayerId.value || isPenMode.value ? (openBlock(), createBlock(SplineEditor, {
          key: 0,
          layerId: activeSplineLayerId.value,
          currentFrame: unref(store).currentFrame,
          canvasWidth: compositionWidth.value,
          canvasHeight: compositionHeight.value,
          containerWidth: canvasWidth.value,
          containerHeight: canvasHeight.value,
          zoom: zoom.value,
          viewportTransform: viewportTransformArray.value,
          isPenMode: isPenMode.value,
          onPointAdded,
          onPathUpdated,
          onTogglePenMode: togglePenMode,
          ref_key: "splineEditorRef",
          ref: splineEditorRef
        }, null, 8, ["layerId", "currentFrame", "canvasWidth", "canvasHeight", "containerWidth", "containerHeight", "zoom", "viewportTransform", "isPenMode"])) : createCommentVNode("", true),
        hasDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
          createBaseVNode("label", null, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showDepthOverlay.value = $event)
            }, null, 512), [
              [vModelCheckbox, showDepthOverlay.value]
            ]),
            _cache[11] || (_cache[11] = createTextVNode(" Depth Overlay ", -1))
          ]),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => depthColormap.value = $event),
            class: "colormap-select"
          }, [..._cache[12] || (_cache[12] = [
            createBaseVNode("option", { value: "viridis" }, "Viridis", -1),
            createBaseVNode("option", { value: "plasma" }, "Plasma", -1),
            createBaseVNode("option", { value: "grayscale" }, "Grayscale", -1)
          ])], 512), [
            [vModelSelect, depthColormap.value]
          ]),
          withDirectives(createBaseVNode("input", {
            type: "range",
            min: "0",
            max: "100",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => depthOpacity.value = $event),
            class: "opacity-slider"
          }, null, 512), [
            [
              vModelText,
              depthOpacity.value,
              void 0,
              { number: true }
            ]
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$d, [
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "color" }),
            onClick: _cache[3] || (_cache[3] = ($event) => setRenderMode("color")),
            title: "Color View"
          }, [..._cache[13] || (_cache[13] = [
            createBaseVNode("i", { class: "pi pi-image" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "depth" }),
            onClick: _cache[4] || (_cache[4] = ($event) => setRenderMode("depth")),
            title: "Depth View"
          }, [..._cache[14] || (_cache[14] = [
            createBaseVNode("i", { class: "pi pi-box" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: renderMode.value === "normal" }),
            onClick: _cache[5] || (_cache[5] = ($event) => setRenderMode("normal")),
            title: "Normal View"
          }, [..._cache[15] || (_cache[15] = [
            createBaseVNode("i", { class: "pi pi-compass" }, null, -1)
          ])], 2),
          _cache[19] || (_cache[19] = createBaseVNode("div", { class: "controls-divider" }, null, -1)),
          createBaseVNode("button", {
            onClick: resetCamera,
            title: "Reset Camera (Home)"
          }, [..._cache[16] || (_cache[16] = [
            createBaseVNode("i", { class: "pi pi-home" }, null, -1)
          ])]),
          _cache[20] || (_cache[20] = createBaseVNode("div", { class: "controls-divider" }, null, -1)),
          createBaseVNode("button", {
            class: normalizeClass({ active: showGrid.value }),
            onClick: toggleGrid,
            title: "Toggle Grid"
          }, [..._cache[17] || (_cache[17] = [
            createBaseVNode("i", { class: "pi pi-th-large" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: showOutsideOverlay.value }),
            onClick: toggleOutsideOverlay,
            title: "Toggle Safe Area Overlay"
          }, [..._cache[18] || (_cache[18] = [
            createBaseVNode("i", { class: "pi pi-stop" }, null, -1)
          ])], 2)
        ]),
        unref(store).selectedLayerIds.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$d, [
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "translate" }),
            onClick: _cache[6] || (_cache[6] = ($event) => setTransformModeTo("translate")),
            title: "Move (V)"
          }, [..._cache[21] || (_cache[21] = [
            createBaseVNode("i", { class: "pi pi-arrows-alt" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "rotate" }),
            onClick: _cache[7] || (_cache[7] = ($event) => setTransformModeTo("rotate")),
            title: "Rotate (R)"
          }, [..._cache[22] || (_cache[22] = [
            createBaseVNode("i", { class: "pi pi-sync" }, null, -1)
          ])], 2),
          createBaseVNode("button", {
            class: normalizeClass({ active: transformMode.value === "scale" }),
            onClick: _cache[8] || (_cache[8] = ($event) => setTransformModeTo("scale")),
            title: "Scale (S)"
          }, [..._cache[23] || (_cache[23] = [
            createBaseVNode("i", { class: "pi pi-expand" }, null, -1)
          ])], 2)
        ])) : createCommentVNode("", true),
        showPerformance.value ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
          createBaseVNode("span", null, "FPS: " + toDisplayString(performanceStats.value.fps), 1),
          createBaseVNode("span", null, "Draw: " + toDisplayString(performanceStats.value.drawCalls), 1),
          createBaseVNode("span", null, "Tris: " + toDisplayString(performanceStats.value.triangles), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_5$d, [
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => zoomLevel.value = $event),
            class: "zoom-dropdown",
            onChange: onZoomSelect
          }, [..._cache[24] || (_cache[24] = [
            createStaticVNode('<option value="fit" data-v-133a9bf5>Fit</option><option value="0.25" data-v-133a9bf5>25%</option><option value="0.33" data-v-133a9bf5>33%</option><option value="0.5" data-v-133a9bf5>50%</option><option value="0.75" data-v-133a9bf5>75%</option><option value="1" data-v-133a9bf5>100%</option><option value="2" data-v-133a9bf5>200%</option><option value="4" data-v-133a9bf5>400%</option>', 8)
          ])], 544), [
            [vModelSelect, zoomLevel.value]
          ]),
          createBaseVNode("span", _hoisted_6$d, toDisplayString(zoomDisplayPercent.value) + "%", 1),
          _cache[26] || (_cache[26] = createBaseVNode("div", { class: "viewer-divider" }, null, -1)),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => resolution.value = $event),
            class: "resolution-dropdown",
            onChange: onResolutionChange
          }, [..._cache[25] || (_cache[25] = [
            createStaticVNode('<option value="full" data-v-133a9bf5>Full</option><option value="half" data-v-133a9bf5>Half</option><option value="third" data-v-133a9bf5>Third</option><option value="quarter" data-v-133a9bf5>Quarter</option><option value="custom" data-v-133a9bf5>Custom</option>', 5)
          ])], 544), [
            [vModelSelect, resolution.value]
          ])
        ]),
        loading.value ? (openBlock(), createElementBlock("div", _hoisted_7$d, [..._cache[27] || (_cache[27] = [
          createBaseVNode("div", { class: "loading-spinner" }, null, -1),
          createBaseVNode("span", null, "Loading...", -1)
        ])])) : createCommentVNode("", true),
        unref(store).segmentPendingMask ? (openBlock(), createElementBlock("div", {
          key: 5,
          class: "segment-mask-overlay",
          style: normalizeStyle(maskOverlayStyle.value)
        }, [
          createBaseVNode("img", {
            src: "data:image/png;base64," + unref(store).segmentPendingMask.mask,
            class: "mask-preview",
            alt: "Segmentation mask"
          }, null, 8, _hoisted_8$d)
        ], 4)) : createCommentVNode("", true),
        isDrawingSegmentBox.value && unref(store).segmentBoxStart && segmentBoxEnd.value ? (openBlock(), createElementBlock("div", {
          key: 6,
          class: "segment-box-preview",
          style: normalizeStyle(segmentBoxStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        unref(store).segmentIsLoading ? (openBlock(), createElementBlock("div", _hoisted_9$d, [..._cache[28] || (_cache[28] = [
          createBaseVNode("div", { class: "segment-spinner" }, null, -1),
          createBaseVNode("span", null, "Segmenting...", -1)
        ])])) : createCommentVNode("", true),
        unref(store).viewOptions.showCompositionBounds !== false ? (openBlock(), createElementBlock("div", {
          key: 8,
          class: "composition-boundary",
          style: normalizeStyle(compositionBoundaryStyle.value)
        }, null, 4)) : createCommentVNode("", true),
        showSafeFrameGuides.value ? (openBlock(), createElementBlock("div", _hoisted_10$d, [
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-left",
            style: normalizeStyle(safeFrameLeftStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-right",
            style: normalizeStyle(safeFrameRightStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-top",
            style: normalizeStyle(safeFrameTopStyle.value)
          }, null, 4),
          createBaseVNode("div", {
            class: "safe-frame-overlay safe-frame-bottom",
            style: normalizeStyle(safeFrameBottomStyle.value)
          }, null, 4)
        ])) : createCommentVNode("", true)
      ], 512);
    };
  }
});

const ThreeCanvas = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-133a9bf5"]]);

const KEYFRAME_SHAPES = {
  // ========================================
  // BAR SHAPES (for holds/markers)
  // ========================================
  /** Mini - Short vertical bar for subtle keyframes */
  mini: {
    path: "M1,8 L1,16",
    width: 2,
    height: 24,
    stroke: true
  },
  /** Extend - Taller bar for extended holds */
  extend: {
    path: "M2,4 L2,20",
    width: 4,
    height: 24,
    stroke: true
  },
  /** Long - Full height bar for long duration markers */
  long: {
    path: "M2,0 L2,24",
    width: 4,
    height: 24,
    stroke: true
  },
  // ========================================
  // ROUND HEAD SHAPES (for smooth starts)
  // ========================================
  /** Round Head - Circle top for smooth interpolation start */
  roundHead: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,20",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Extend - Circle with extended bar */
  rhExtend: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,16 L8,16 L8,20 L0,20 L0,16 L4,16",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Long - Circle with long bar */
  rhLong: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,24",
    width: 8,
    height: 24,
    stroke: true
  },
  /** RH Outline - Outline circle variant */
  rhOutline: {
    path: "M4,4 a4,4 0 1,1 0.01,0 M4,8 L4,24",
    width: 8,
    height: 24,
    stroke: true,
    fill: "none"
  },
  // ========================================
  // WIDE SHAPES (for timing windows)
  // ========================================
  /** Wide - Horizontal bar for wide timing window */
  wide: {
    path: "M0,10 L12,10 L12,14 L0,14 Z",
    width: 12,
    height: 24
  },
  /** Wide Hammer - Bar with hard stop end */
  wideHammer: {
    path: "M0,10 L10,10 L10,6 L12,6 L12,18 L10,18 L10,14 L0,14 Z",
    width: 12,
    height: 24
  },
  // ========================================
  // EASE SHAPES (for interpolation types)
  // ========================================
  /** Pill - Rounded rectangle for eased transitions */
  pill: {
    path: "M3,8 L9,8 A3,3 0 0,1 9,16 L3,16 A3,3 0 0,1 3,8 Z",
    width: 12,
    height: 24
  },
  /** Watch - Hourglass shape for ease in-out */
  watch: {
    path: "M2,6 L10,6 L10,8 L7,12 L10,16 L10,18 L2,18 L2,16 L5,12 L2,8 Z",
    width: 12,
    height: 24
  },
  /** Triangle - Directional ramp (ease in or out) */
  triangle: {
    path: "M0,20 L6,4 L12,20 Z",
    width: 12,
    height: 24
  },
  /** Diamond - Standard keyframe (linear) */
  diamond: {
    path: "M6,2 L11,12 L6,22 L1,12 Z",
    width: 12,
    height: 24
  },
  /** Martini - Inverted triangle (ease out with hold) */
  martini: {
    path: "M1,4 L11,4 L6,18 L6,22 L6,18 Z",
    width: 12,
    height: 24
  },
  // ========================================
  // POINT SHAPES (for discrete keyframes)
  // ========================================
  /** Radio - Filled circle point */
  radio: {
    path: "M6,6 a6,6 0 1,1 0.01,0 Z",
    width: 12,
    height: 24
  },
  /** Radio Long - Circle with extension bar */
  radioLong: {
    path: "M6,6 a6,6 0 1,1 0.01,0 Z M6,12 L6,24",
    width: 12,
    height: 24
  }
};
function getShapeForEasing(easing) {
  const easingLower = easing.toLowerCase();
  if (easingLower === "hold" || easingLower === "step") {
    return "extend";
  }
  if (easingLower === "linear") {
    return "diamond";
  }
  if (easingLower.startsWith("easein") && !easingLower.includes("out")) {
    return "triangle";
  }
  if (easingLower.startsWith("easeout") || easingLower === "easeout") {
    return "martini";
  }
  if (easingLower.includes("inout") || easingLower === "easeinout") {
    return "pill";
  }
  if (easingLower === "bezier" || easingLower === "cubic-bezier") {
    return "watch";
  }
  if (easingLower.includes("elastic")) {
    return "radioLong";
  }
  if (easingLower.includes("bounce")) {
    return "radio";
  }
  if (easingLower.includes("spring")) {
    return "roundHead";
  }
  return "diamond";
}

const _hoisted_1$c = { class: "prop-wrapper" };
const _hoisted_2$c = { class: "prop-content" };
const _hoisted_3$c = { class: "prop-name" };
const _hoisted_4$c = { class: "prop-inputs" };
const _hoisted_5$c = {
  key: 0,
  class: "vec-item"
};
const _hoisted_6$c = {
  key: 1,
  class: "checkbox-wrapper"
};
const _hoisted_7$c = ["checked"];
const _hoisted_8$c = ["value", "title"];
const _hoisted_9$c = ["value"];
const _hoisted_10$c = {
  key: 0,
  value: "off"
};
const _hoisted_11$c = {
  key: 1,
  value: "on"
};
const _hoisted_12$b = {
  key: 2,
  value: "only"
};
const _hoisted_13$b = {
  key: 3,
  value: "Classic 3D"
};
const _hoisted_14$a = {
  key: 4,
  value: "CINEMA 4D"
};
const _hoisted_15$9 = {
  key: 5,
  value: "Ray-traced 3D"
};
const _hoisted_16$8 = ["value", "placeholder", "title"];
const _hoisted_17$8 = {
  key: 5,
  class: "color-input-wrapper"
};
const _hoisted_18$8 = ["value"];
const _hoisted_19$8 = { class: "color-hex" };
const _hoisted_20$8 = { class: "vec-item" };
const _hoisted_21$8 = { class: "vec-item" };
const _hoisted_22$8 = ["onMousedown", "onDblclick", "onContextmenu"];
const _hoisted_23$8 = ["viewBox"];
const _hoisted_24$6 = ["d", "fill", "stroke"];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(__props, { emit: __emit }) {
    function getKeyframeShapePath(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      return KEYFRAME_SHAPES[shapeKey]?.path || KEYFRAME_SHAPES.diamond.path;
    }
    function getKeyframeShapeViewBox(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      const shape = KEYFRAME_SHAPES[shapeKey] || KEYFRAME_SHAPES.diamond;
      return `0 0 ${shape.width} ${shape.height}`;
    }
    function isStrokeShape(interpolation = "linear") {
      const shapeKey = getShapeForEasing(interpolation);
      return KEYFRAME_SHAPES[shapeKey]?.stroke || false;
    }
    const props = __props;
    const store = useCompositorStore();
    const selectedKeyframeIds = ref(/* @__PURE__ */ new Set());
    const trackRef = ref(null);
    const isBoxSelecting = ref(false);
    const boxStartX = ref(0);
    const boxCurrentX = ref(0);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      keyframe: null
    });
    const contextMenuStyle = computed(() => ({
      left: `${contextMenu.value.x}px`,
      top: `${contextMenu.value.y}px`
    }));
    const selectionBoxStyle = computed(() => {
      const left = Math.min(boxStartX.value, boxCurrentX.value);
      const width = Math.abs(boxCurrentX.value - boxStartX.value);
      return {
        left: `${left}px`,
        width: `${width}px`
      };
    });
    const hasKeyframeAtCurrent = computed(() => props.property.keyframes?.some((k) => k.frame === store.currentFrame));
    const isSelected = computed(() => store.selectedPropertyPath === props.propertyPath);
    function toggleAnim() {
      store.setPropertyAnimated(props.layerId, props.propertyPath, !props.property.animated);
    }
    function addKeyframeAtCurrent() {
      store.addKeyframe(props.layerId, props.propertyPath, props.property.value);
    }
    function updateValDirect(v) {
      if (props.propertyPath.startsWith("data.")) {
        const dataKey = props.propertyPath.replace("data.", "");
        store.updateLayerData(props.layerId, { [dataKey]: v });
      } else {
        store.setPropertyValue(props.layerId, props.propertyPath, v);
      }
    }
    function updateValByIndex(axis, v) {
      const newVal = { ...props.property.value, [axis]: v };
      store.setPropertyValue(props.layerId, props.propertyPath, newVal);
    }
    function selectProp() {
      store.selectProperty(props.propertyPath);
    }
    function formatOptionLabel(opt) {
      return opt.charAt(0).toUpperCase() + opt.slice(1);
    }
    function getDropdownTitle() {
      switch (props.name) {
        case "Line Cap":
          return "Butt: flat end, Round: rounded end, Square: extends end";
        case "Line Join":
          return "Miter: sharp corner, Round: rounded corner, Bevel: flat corner";
        default:
          return "";
      }
    }
    function getStringTitle() {
      switch (props.name) {
        case "Dashes":
          return "Dash pattern: comma-separated values (e.g., 10, 5 for 10px dash, 5px gap)";
        default:
          return "";
      }
    }
    function handleTrackMouseDown(e) {
      const rect = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - rect.left;
      isBoxSelecting.value = true;
      boxStartX.value = x;
      boxCurrentX.value = x;
      if (!e.shiftKey) {
        selectedKeyframeIds.value.clear();
      }
      const onMove = (ev) => {
        const currentX = ev.clientX - rect.left;
        boxCurrentX.value = Math.max(0, currentX);
        const minFrame = Math.min(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        const maxFrame = Math.max(boxStartX.value, boxCurrentX.value) / props.pixelsPerFrame;
        if (!ev.shiftKey) {
          selectedKeyframeIds.value.clear();
        }
        for (const kf of props.property.keyframes || []) {
          if (kf.frame >= minFrame && kf.frame <= maxFrame) {
            selectedKeyframeIds.value.add(kf.id);
          }
        }
      };
      const onUp = (ev) => {
        isBoxSelecting.value = false;
        const dragDistance = Math.abs(boxCurrentX.value - boxStartX.value);
        if (dragDistance < 5) {
          const frame = Math.round(boxStartX.value / props.pixelsPerFrame);
          store.setFrame(Math.max(0, Math.min(store.frameCount - 1, frame)));
        }
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function startKeyframeDrag(e, kf) {
      if (e.shiftKey) {
        if (selectedKeyframeIds.value.has(kf.id)) {
          selectedKeyframeIds.value.delete(kf.id);
        } else {
          selectedKeyframeIds.value.add(kf.id);
        }
      } else {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const startX = e.clientX;
      const startFrame = kf.frame;
      const onMove = (ev) => {
        const dx = ev.clientX - startX;
        const frameDelta = Math.round(dx / props.pixelsPerFrame);
        let newFrame = Math.max(0, Math.min(store.frameCount - 1, startFrame + frameDelta));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(newFrame, store.snapConfig, props.pixelsPerFrame, {
            layers: store.layers,
            selectedLayerId: props.layerId,
            currentFrame: store.currentFrame,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            newFrame = snap.frame;
          }
        }
        if (newFrame !== kf.frame) {
          store.moveKeyframe(props.layerId, props.propertyPath, kf.id, newFrame);
        }
      };
      const onUp = () => {
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }
    function deleteKeyframe(kfId) {
      store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      selectedKeyframeIds.value.delete(kfId);
    }
    function showContextMenu(e, kf) {
      if (!selectedKeyframeIds.value.has(kf.id)) {
        selectedKeyframeIds.value.clear();
        selectedKeyframeIds.value.add(kf.id);
      }
      const trackRect = trackRef.value?.getBoundingClientRect();
      if (trackRect) {
        contextMenu.value = {
          visible: true,
          x: e.clientX - trackRect.left,
          y: e.clientY - trackRect.top,
          keyframe: kf
        };
      }
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.keyframe = null;
    }
    function setInterpolation(type) {
      for (const kfId of selectedKeyframeIds.value) {
        store.setKeyframeInterpolation(props.layerId, props.propertyPath, kfId, type);
      }
      hideContextMenu();
    }
    function goToKeyframe() {
      if (contextMenu.value.keyframe) {
        store.setFrame(contextMenu.value.keyframe.frame);
      }
      hideContextMenu();
    }
    function deleteSelectedKeyframes() {
      for (const kfId of selectedKeyframeIds.value) {
        store.removeKeyframe(props.layerId, props.propertyPath, kfId);
      }
      selectedKeyframeIds.value.clear();
      hideContextMenu();
    }
    function handleGlobalClick(e) {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleGlobalClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleGlobalClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["prop-sidebar", { selected: isSelected.value }]),
          style: normalizeStyle(__props.gridStyle),
          onClick: selectProp
        }, [
          _cache[15] || (_cache[15] = createBaseVNode("div", { class: "indent-spacer" }, null, -1)),
          __props.property.animatable !== false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", {
              class: "icon-box",
              onClick: withModifiers(toggleAnim, ["stop"])
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["keyframe-toggle", { active: __props.property.animated }])
              }, "", 2)
            ]),
            createBaseVNode("div", {
              class: "icon-box",
              onClick: withModifiers(addKeyframeAtCurrent, ["stop"])
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["kf-btn", { active: hasKeyframeAtCurrent.value }])
              }, "", 2)
            ])
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _cache[10] || (_cache[10] = createBaseVNode("div", { class: "icon-box disabled" }, null, -1)),
            _cache[11] || (_cache[11] = createBaseVNode("div", { class: "icon-box disabled" }, null, -1))
          ], 64)),
          createBaseVNode("div", _hoisted_2$c, [
            createBaseVNode("span", _hoisted_3$c, toDisplayString(__props.name), 1),
            createBaseVNode("div", _hoisted_4$c, [
              __props.name === "Z Position" ? (openBlock(), createElementBlock("div", _hoisted_5$c, [
                _cache[12] || (_cache[12] = createBaseVNode("span", { class: "label z-label" }, "Z", -1)),
                createVNode(ScrubableNumber, {
                  modelValue: __props.property.value?.z ?? 0,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = (v) => updateValByIndex("z", v))
                }, null, 8, ["modelValue"])
              ])) : __props.property.type === "boolean" ? (openBlock(), createElementBlock("div", _hoisted_6$c, [
                createBaseVNode("input", {
                  type: "checkbox",
                  checked: __props.property.value,
                  onChange: _cache[1] || (_cache[1] = (e) => updateValDirect(e.target.checked))
                }, null, 40, _hoisted_7$c)
              ])) : __props.property.type === "dropdown" ? (openBlock(), createElementBlock("select", {
                key: 2,
                class: "prop-dropdown",
                value: __props.property.value,
                onChange: _cache[2] || (_cache[2] = (e) => updateValDirect(e.target.value)),
                title: getDropdownTitle()
              }, [
                __props.property.options && Array.isArray(__props.property.options) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.property.options, (opt) => {
                  return openBlock(), createElementBlock("option", {
                    key: opt,
                    value: opt
                  }, toDisplayString(formatOptionLabel(opt)), 9, _hoisted_9$c);
                }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_10$c, "Off")) : createCommentVNode("", true),
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_11$c, "On")) : createCommentVNode("", true),
                  __props.name === "Casts Shadows" ? (openBlock(), createElementBlock("option", _hoisted_12$b, "Only")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_13$b, "Classic 3D")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_14$a, "CINEMA 4D")) : createCommentVNode("", true),
                  __props.name === "Renderer" ? (openBlock(), createElementBlock("option", _hoisted_15$9, "Ray-traced 3D")) : createCommentVNode("", true)
                ], 64))
              ], 40, _hoisted_8$c)) : __props.property.type === "string" ? (openBlock(), createElementBlock("input", {
                key: 3,
                type: "text",
                class: "prop-string-input",
                value: __props.property.value,
                placeholder: __props.property.placeholder || "",
                title: getStringTitle(),
                onChange: _cache[3] || (_cache[3] = (e) => updateValDirect(e.target.value))
              }, null, 40, _hoisted_16$8)) : __props.property.type === "percent" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 4,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 0,
                min: 0,
                max: 100,
                suffix: "%"
              }, null, 8, ["modelValue"])) : __props.property.type === "color" ? (openBlock(), createElementBlock("div", _hoisted_17$8, [
                createBaseVNode("input", {
                  type: "color",
                  value: __props.property.value,
                  onInput: _cache[4] || (_cache[4] = (e) => updateValDirect(e.target.value))
                }, null, 40, _hoisted_18$8),
                createBaseVNode("span", _hoisted_19$8, toDisplayString(__props.property.value), 1)
              ])) : typeof __props.property.value === "object" ? (openBlock(), createElementBlock(Fragment, { key: 6 }, [
                createBaseVNode("div", _hoisted_20$8, [
                  _cache[13] || (_cache[13] = createBaseVNode("span", { class: "label x-label" }, "X", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.x,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = (v) => updateValByIndex("x", v))
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$8, [
                  _cache[14] || (_cache[14] = createBaseVNode("span", { class: "label y-label" }, "Y", -1)),
                  createVNode(ScrubableNumber, {
                    modelValue: __props.property.value.y,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = (v) => updateValByIndex("y", v))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof __props.property.value === "number" ? (openBlock(), createBlock(ScrubableNumber, {
                key: 7,
                modelValue: __props.property.value,
                "onUpdate:modelValue": updateValDirect,
                precision: 1
              }, null, 8, ["modelValue"])) : createCommentVNode("", true)
            ])
          ])
        ], 6)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "prop-track",
          onMousedown: handleTrackMouseDown,
          ref_key: "trackRef",
          ref: trackRef
        }, [
          isBoxSelecting.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "selection-box",
            style: normalizeStyle(selectionBoxStyle.value)
          }, null, 4)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.property.keyframes, (kf) => {
            return openBlock(), createElementBlock("div", {
              key: kf.id,
              class: normalizeClass(["keyframe", { selected: selectedKeyframeIds.value.has(kf.id), [kf.interpolation || "linear"]: true }]),
              style: normalizeStyle({ left: `${kf.frame * __props.pixelsPerFrame}px` }),
              onMousedown: withModifiers(($event) => startKeyframeDrag($event, kf), ["stop"]),
              onDblclick: withModifiers(($event) => deleteKeyframe(kf.id), ["stop"]),
              onContextmenu: withModifiers(($event) => showContextMenu($event, kf), ["prevent", "stop"])
            }, [
              (openBlock(), createElementBlock("svg", {
                class: "keyframe-shape",
                viewBox: getKeyframeShapeViewBox(kf.interpolation),
                preserveAspectRatio: "xMidYMid meet"
              }, [
                createBaseVNode("path", {
                  d: getKeyframeShapePath(kf.interpolation),
                  fill: isStrokeShape(kf.interpolation) ? "none" : "currentColor",
                  stroke: isStrokeShape(kf.interpolation) ? "currentColor" : "none",
                  "stroke-width": "1.5"
                }, null, 8, _hoisted_24$6)
              ], 8, _hoisted_23$8))
            ], 46, _hoisted_22$8);
          }), 128)),
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: normalizeStyle(contextMenuStyle.value)
          }, [
            _cache[21] || (_cache[21] = createBaseVNode("div", { class: "menu-header" }, "Interpolation", -1)),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "linear" }]),
              onClick: _cache[7] || (_cache[7] = ($event) => setInterpolation("linear"))
            }, [..._cache[16] || (_cache[16] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Linear ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "bezier" }]),
              onClick: _cache[8] || (_cache[8] = ($event) => setInterpolation("bezier"))
            }, [..._cache[17] || (_cache[17] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Bezier ", -1)
            ])], 2),
            createBaseVNode("div", {
              class: normalizeClass(["menu-item", { active: contextMenu.value.keyframe?.interpolation === "hold" }]),
              onClick: _cache[9] || (_cache[9] = ($event) => setInterpolation("hold"))
            }, [..._cache[18] || (_cache[18] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Hold ", -1)
            ])], 2),
            _cache[22] || (_cache[22] = createBaseVNode("div", { class: "menu-divider" }, null, -1)),
            createBaseVNode("div", {
              class: "menu-item",
              onClick: goToKeyframe
            }, [..._cache[19] || (_cache[19] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Go to Frame ", -1)
            ])]),
            createBaseVNode("div", {
              class: "menu-item delete",
              onClick: deleteSelectedKeyframes
            }, [..._cache[20] || (_cache[20] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Delete ", -1)
            ])])
          ], 4)) : createCommentVNode("", true)
        ], 544))
      ]);
    };
  }
});

const PropertyTrack = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-537bc3fe"]]);

const _hoisted_1$b = {
  key: 0,
  class: "track-wrapper"
};
const _hoisted_2$b = { class: "av-features" };
const _hoisted_3$b = ["title"];
const _hoisted_4$b = ["title"];
const _hoisted_5$b = {
  key: 1,
  class: "icon-col placeholder"
};
const _hoisted_6$b = ["title"];
const _hoisted_7$b = ["title"];
const _hoisted_8$b = { class: "layer-info" };
const _hoisted_9$b = { class: "layer-id" };
const _hoisted_10$b = { class: "arrow" };
const _hoisted_11$b = { class: "type-icon" };
const _hoisted_12$a = {
  key: 0,
  class: "name-text"
};
const _hoisted_13$a = { class: "layer-switches" };
const _hoisted_14$9 = ["title"];
const _hoisted_15$8 = ["title"];
const _hoisted_16$7 = ["title"];
const _hoisted_17$7 = ["title"];
const _hoisted_18$7 = ["title"];
const _hoisted_19$7 = ["title"];
const _hoisted_20$7 = ["title"];
const _hoisted_21$7 = ["title"];
const _hoisted_22$7 = { class: "col-parent" };
const _hoisted_23$7 = ["value"];
const _hoisted_24$5 = ["value"];
const _hoisted_25$5 = {
  key: 0,
  class: "children-container"
};
const _hoisted_26$5 = ["onMousedown"];
const _hoisted_27$5 = { class: "arrow-col" };
const _hoisted_28$5 = { class: "arrow" };
const _hoisted_29$5 = { class: "group-label" };
const _hoisted_30$4 = { key: 0 };
const _hoisted_31$3 = {
  key: 0,
  class: "children-container"
};
const _hoisted_32$3 = { key: 0 };
const _hoisted_33$3 = { class: "color-grid" };
const _hoisted_34$3 = ["onClick"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const localExpanded = ref(false);
    const isExpanded = computed(() => props.isExpandedExternal ?? localExpanded.value);
    const isSelected = computed(() => store.selectedLayerIds.includes(props.layer.id));
    const hasAudioCapability = computed(() => ["video", "audio", "nestedComp"].includes(props.layer.type));
    const expandedGroups = ref(["Transform", "Text", "More Options", "Stroke", "Fill", "Trim Paths", "Path Options"]);
    const isRenaming = ref(false);
    const renameVal = ref("");
    const renameInput = ref(null);
    const contextMenuVisible = ref(false);
    const contextMenuX = ref(0);
    const contextMenuY = ref(0);
    const showColorPicker = ref(false);
    const colorPickerX = ref(0);
    const colorPickerY = ref(0);
    const labelColors = [
      "#999999",
      // None (gray)
      "#e24b4b",
      // Red
      "#f5c343",
      // Yellow
      "#c8e04d",
      // Lime
      "#4be08e",
      // Sea Green
      "#4bcde0",
      // Aqua
      "#5b8ef0",
      // Blue
      "#9d70e8",
      // Purple
      "#e070d0",
      // Pink
      "#e0a070",
      // Peach
      "#e07070",
      // Light Red
      "#70e0a0",
      // Mint
      "#7090e0",
      // Sky Blue
      "#a070e0",
      // Violet
      "#e07090",
      // Rose
      "#90c8e0"
      // Pale Blue
    ];
    const availableParents = computed(() => props.allLayers?.filter((l) => l.id !== props.layer.id) || []);
    const groupedProperties = computed(() => {
      const groups = {};
      const t = props.layer.transform;
      const transformProps = [];
      const add = (path, name, prop) => {
        if (prop) transformProps.push({ path, name, property: prop });
      };
      add("transform.anchorPoint", "Anchor Point", t.anchorPoint);
      add("transform.position", "Position", t.position);
      if (props.layer.threeD && t.position) {
        transformProps.push({
          path: "transform.position",
          name: "Z Position",
          property: t.position
          // Pass full position property, PropertyTrack handles .z
        });
      }
      add("transform.scale", "Scale", t.scale);
      if (props.layer.threeD) {
        if (t.orientation) transformProps.push({ path: "transform.orientation", name: "Orientation", property: t.orientation });
        if (t.rotationX) transformProps.push({ path: "transform.rotationX", name: "X Rotation", property: t.rotationX });
        if (t.rotationY) transformProps.push({ path: "transform.rotationY", name: "Y Rotation", property: t.rotationY });
        if (t.rotationZ) transformProps.push({ path: "transform.rotationZ", name: "Z Rotation", property: t.rotationZ });
      } else {
        if (t.rotation) transformProps.push({ path: "transform.rotation", name: "Rotation", property: t.rotation });
      }
      if (props.layer.opacity) transformProps.push({ path: "opacity", name: "Opacity", property: props.layer.opacity });
      groups["Transform"] = transformProps;
      if (props.layer.threeD) {
        groups["Geometry Options"] = [
          { path: "geometry.renderer", name: "Renderer", property: { value: "Classic 3D", type: "dropdown" } }
        ];
      }
      if (props.layer.threeD) {
        const mat = props.layer.materialOptions || {
          castsShadows: "off",
          lightTransmission: 0,
          acceptsShadows: true,
          acceptsLights: true,
          ambient: 100,
          diffuse: 50,
          specularIntensity: 50,
          specularShininess: 5,
          metal: 100
        };
        groups["Material Options"] = [
          { path: "materialOptions.castsShadows", name: "Casts Shadows", property: { value: mat.castsShadows, type: "dropdown" } },
          { path: "materialOptions.lightTransmission", name: "Light Transmission", property: { value: mat.lightTransmission, type: "percent" } },
          { path: "materialOptions.acceptsShadows", name: "Accepts Shadows", property: { value: mat.acceptsShadows, type: "boolean" } },
          { path: "materialOptions.acceptsLights", name: "Accepts Lights", property: { value: mat.acceptsLights, type: "boolean" } },
          { path: "materialOptions.ambient", name: "Ambient", property: { value: mat.ambient, type: "percent" } },
          { path: "materialOptions.diffuse", name: "Diffuse", property: { value: mat.diffuse, type: "percent" } },
          { path: "materialOptions.specularIntensity", name: "Specular Intensity", property: { value: mat.specularIntensity, type: "percent" } },
          { path: "materialOptions.specularShininess", name: "Specular Shininess", property: { value: mat.specularShininess, type: "percent" } },
          { path: "materialOptions.metal", name: "Metal", property: { value: mat.metal, type: "percent" } }
        ];
      }
      if (props.layer.type === "spline" && props.layer.data) {
        const splineData = props.layer.data;
        groups["Path Options"] = [
          { path: "data.closed", name: "Closed", property: { value: splineData.closed ?? false, type: "boolean", animatable: false } }
        ];
        groups["More Options"] = [
          { path: "data.lineCap", name: "Line Cap", property: { value: splineData.lineCap ?? "round", type: "dropdown", options: ["butt", "round", "square"], animatable: false } },
          { path: "data.lineJoin", name: "Line Join", property: { value: splineData.lineJoin ?? "round", type: "dropdown", options: ["miter", "round", "bevel"], animatable: false } },
          { path: "data.dashArray", name: "Dashes", property: { value: splineData.dashArray ?? "", type: "string", placeholder: "10, 5", animatable: false } },
          { path: "data.dashOffset", name: "Dash Offset", property: { value: splineData.dashOffset ?? 0, type: "number", animatable: false } }
        ];
      }
      if (props.layer.properties) {
        props.layer.properties.forEach((p) => {
          const g = p.group || "Properties";
          if (!groups[g]) groups[g] = [];
          groups[g].push({ path: p.name, name: p.name, property: p });
        });
      }
      return groups;
    });
    const barStyle = computed(() => {
      const frameCount = props.frameCount || 81;
      const inPoint = props.layer.inPoint ?? 0;
      const outPoint = props.layer.outPoint ?? frameCount - 1;
      const leftPct = Math.max(0, inPoint / frameCount * 100);
      const widthPct = Math.max(1, (outPoint - inPoint + 1) / frameCount * 100);
      return {
        left: `${leftPct}%`,
        width: `${widthPct}%`
      };
    });
    function selectLayer() {
      emit("select", props.layer.id);
    }
    function toggleExpand() {
      emit("toggleExpand", props.layer.id, !isExpanded.value);
    }
    function toggleGroup(g) {
      if (expandedGroups.value.includes(g)) expandedGroups.value = expandedGroups.value.filter((x) => x !== g);
      else expandedGroups.value.push(g);
    }
    function getLayerIcon(t) {
      return { text: "T", solid: "", camera: "", nestedComp: "", image: "", video: "" }[t] || "";
    }
    function handleDoubleClick() {
      if (props.layer.type === "nestedComp" && props.layer.data?.compositionId) {
        store.enterNestedComp(props.layer.data.compositionId);
      } else {
        startRename();
      }
    }
    function startRename() {
      isRenaming.value = true;
      renameVal.value = props.layer.name;
      nextTick(() => renameInput.value?.focus());
    }
    function saveRename() {
      emit("updateLayer", props.layer.id, { name: renameVal.value });
      isRenaming.value = false;
    }
    function setParent(e) {
      emit("updateLayer", props.layer.id, { parentId: e.target.value || null });
    }
    const isDragging = ref(false);
    const isResizingLeft = ref(false);
    const isResizingRight = ref(false);
    const dragStartX = ref(0);
    const dragStartInPoint = ref(0);
    const dragStartOutPoint = ref(0);
    function startDrag(e) {
      isDragging.value = true;
      dragStartX.value = e.clientX;
      dragStartInPoint.value = props.layer.inPoint ?? 0;
      dragStartOutPoint.value = props.layer.outPoint ?? props.frameCount - 1;
      document.addEventListener("mousemove", onDrag);
      document.addEventListener("mouseup", stopDrag);
    }
    function startResizeLeft(e) {
      isResizingLeft.value = true;
      dragStartX.value = e.clientX;
      dragStartInPoint.value = props.layer.inPoint ?? 0;
      document.addEventListener("mousemove", onResizeLeft);
      document.addEventListener("mouseup", stopDrag);
    }
    function startResizeRight(e) {
      isResizingRight.value = true;
      dragStartX.value = e.clientX;
      dragStartOutPoint.value = props.layer.outPoint ?? props.frameCount - 1;
      document.addEventListener("mousemove", onResizeRight);
      document.addEventListener("mouseup", stopDrag);
    }
    function onDrag(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      const duration = dragStartOutPoint.value - dragStartInPoint.value;
      let newInPoint = dragStartInPoint.value + framesDelta;
      let newOutPoint = newInPoint + duration;
      if (newInPoint < 0) {
        newInPoint = 0;
        newOutPoint = duration;
      }
      if (newOutPoint >= props.frameCount) {
        newOutPoint = props.frameCount - 1;
        newInPoint = newOutPoint - duration;
      }
      emit("updateLayer", props.layer.id, { inPoint: newInPoint, outPoint: newOutPoint });
    }
    function onResizeLeft(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      let newInPoint = dragStartInPoint.value + framesDelta;
      const outPoint = props.layer.outPoint ?? props.frameCount - 1;
      newInPoint = Math.max(0, Math.min(newInPoint, outPoint - 1));
      emit("updateLayer", props.layer.id, { inPoint: newInPoint });
    }
    function onResizeRight(e) {
      const dx = e.clientX - dragStartX.value;
      const framesDelta = Math.round(dx / props.pixelsPerFrame);
      let newOutPoint = dragStartOutPoint.value + framesDelta;
      const inPoint = props.layer.inPoint ?? 0;
      newOutPoint = Math.max(inPoint + 1, Math.min(newOutPoint, props.frameCount - 1));
      emit("updateLayer", props.layer.id, { outPoint: newOutPoint });
    }
    function stopDrag() {
      isDragging.value = false;
      isResizingLeft.value = false;
      isResizingRight.value = false;
      document.removeEventListener("mousemove", onDrag);
      document.removeEventListener("mousemove", onResizeLeft);
      document.removeEventListener("mousemove", onResizeRight);
      document.removeEventListener("mouseup", stopDrag);
    }
    function toggleVis() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
    }
    function toggleLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
    }
    function toggleAudio() {
      emit("updateLayer", props.layer.id, { audioEnabled: props.layer.audioEnabled === false ? true : false });
    }
    function toggleIsolate() {
      emit("updateLayer", props.layer.id, { isolate: !props.layer.isolate });
    }
    function toggleMinimized() {
      emit("updateLayer", props.layer.id, { minimized: !props.layer.minimized });
    }
    function toggleFlattenTransform() {
      emit("updateLayer", props.layer.id, { flattenTransform: !props.layer.flattenTransform });
    }
    function toggleQuality() {
      emit("updateLayer", props.layer.id, { quality: props.layer.quality === "best" ? "draft" : "best" });
    }
    function toggleEffects() {
      emit("updateLayer", props.layer.id, { effectsEnabled: props.layer.effectsEnabled === false ? true : false });
    }
    function toggleFrameBlend() {
      emit("updateLayer", props.layer.id, { frameBlending: !props.layer.frameBlending });
    }
    function toggleMotionBlur() {
      emit("updateLayer", props.layer.id, { motionBlur: !props.layer.motionBlur });
    }
    function toggleEffectLayer() {
      const currentState = props.layer.effectLayer || props.layer.adjustmentLayer;
      emit("updateLayer", props.layer.id, { effectLayer: !currentState, adjustmentLayer: !currentState });
    }
    function toggleColorPicker(e) {
      const rect = e.target.getBoundingClientRect();
      colorPickerX.value = rect.left;
      colorPickerY.value = rect.bottom + 4;
      showColorPicker.value = !showColorPicker.value;
    }
    function setLabelColor(color) {
      emit("updateLayer", props.layer.id, { labelColor: color });
      showColorPicker.value = false;
    }
    function closeColorPicker() {
      showColorPicker.value = false;
    }
    function resetTransform() {
      const comp = store.getActiveComp();
      if (!comp) return;
      const defaultTransform = {
        anchorPoint: { x: comp.settings.width / 2, y: comp.settings.height / 2 },
        position: { x: comp.settings.width / 2, y: comp.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100},
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      };
      const t = props.layer.transform;
      if (t.anchorPoint) t.anchorPoint.value = { ...defaultTransform.anchorPoint };
      if (t.position) t.position.value = props.layer.threeD ? { ...defaultTransform.position } : { x: defaultTransform.position.x, y: defaultTransform.position.y };
      if (t.scale) t.scale.value = { x: defaultTransform.scale.x, y: defaultTransform.scale.y };
      if (t.rotation) t.rotation.value = defaultTransform.rotation;
      if (t.rotationX) t.rotationX.value = defaultTransform.rotationX;
      if (t.rotationY) t.rotationY.value = defaultTransform.rotationY;
      if (t.rotationZ) t.rotationZ.value = defaultTransform.rotationZ;
      if (t.orientation) t.orientation.value = { ...defaultTransform.orientation };
      if (props.layer.opacity) props.layer.opacity.value = defaultTransform.opacity;
      store.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      console.log("[EnhancedLayerTrack] Reset transform for layer:", props.layer.name);
    }
    function showContextMenu(e) {
      contextMenuX.value = e.clientX;
      contextMenuY.value = e.clientY;
      contextMenuVisible.value = true;
      if (!isSelected.value) {
        emit("select", props.layer.id);
      }
    }
    function hideContextMenu() {
      contextMenuVisible.value = false;
    }
    function duplicateLayer() {
      store.duplicateLayer(props.layer.id);
      hideContextMenu();
    }
    function renameFromMenu() {
      hideContextMenu();
      nextTick(() => {
        isRenaming.value = true;
        renameVal.value = props.layer.name;
        nextTick(() => renameInput.value?.focus());
      });
    }
    function toggleLayerVisibility() {
      emit("updateLayer", props.layer.id, { visible: !props.layer.visible });
      hideContextMenu();
    }
    function toggleLayerLock() {
      emit("updateLayer", props.layer.id, { locked: !props.layer.locked });
      hideContextMenu();
    }
    function toggleLayer3D() {
      store.toggleLayer3D(props.layer.id);
      hideContextMenu();
    }
    function nestLayer() {
      store.selectLayer(props.layer.id);
      store.nestSelectedLayers(props.layer.name + " Nested");
      hideContextMenu();
    }
    function deleteLayer() {
      store.deleteLayer(props.layer.id);
      hideContextMenu();
    }
    function handleOutsideClick(e) {
      if (contextMenuVisible.value) {
        hideContextMenu();
      }
      if (showColorPicker.value) {
        closeColorPicker();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return __props.layer ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
        __props.layoutMode === "sidebar" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(["sidebar-row", { selected: isSelected.value }]),
            onMousedown: selectLayer,
            onContextmenu: withModifiers(showContextMenu, ["prevent"])
          }, [
            createBaseVNode("div", _hoisted_2$b, [
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleVis, ["stop"]),
                title: __props.layer.visible ? "Hide" : "Show"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ inactive: !__props.layer.visible })
                }, "", 2)
              ], 40, _hoisted_3$b),
              hasAudioCapability.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "icon-col",
                onMousedown: withModifiers(toggleAudio, ["stop"]),
                title: __props.layer.audioEnabled !== false ? "Mute Audio" : "Enable Audio"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ inactive: __props.layer.audioEnabled === false })
                }, "", 2)
              ], 40, _hoisted_4$b)) : (openBlock(), createElementBlock("div", _hoisted_5$b)),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleIsolate, ["stop"]),
                title: __props.layer.isolate ? "Unisolate" : "Isolate"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.isolate })
                }, "", 2)
              ], 40, _hoisted_6$b),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleLock, ["stop"]),
                title: __props.layer.locked ? "Unlock" : "Lock"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.locked })
                }, "", 2)
              ], 40, _hoisted_7$b)
            ]),
            createBaseVNode("div", _hoisted_8$b, [
              createBaseVNode("div", {
                class: "label-box",
                onMousedown: withModifiers(toggleColorPicker, ["stop"]),
                style: normalizeStyle({ background: __props.layer.labelColor || "#999" })
              }, null, 36),
              createBaseVNode("div", _hoisted_9$b, toDisplayString(__props.index), 1),
              createBaseVNode("div", {
                class: "arrow-col",
                onMousedown: withModifiers(toggleExpand, ["stop"])
              }, [
                createBaseVNode("span", _hoisted_10$b, toDisplayString(isExpanded.value ? "" : ""), 1)
              ], 32),
              createBaseVNode("div", {
                class: "layer-name-col",
                onDblclick: withModifiers(handleDoubleClick, ["stop"])
              }, [
                createBaseVNode("span", _hoisted_11$b, toDisplayString(getLayerIcon(__props.layer.type)), 1),
                !isRenaming.value ? (openBlock(), createElementBlock("span", _hoisted_12$a, toDisplayString(__props.layer.name), 1)) : withDirectives((openBlock(), createElementBlock("input", {
                  key: 1,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => renameVal.value = $event),
                  onBlur: saveRename,
                  onKeydown: withKeys(saveRename, ["enter"]),
                  class: "rename-input",
                  ref_key: "renameInput",
                  ref: renameInput
                }, null, 544)), [
                  [vModelText, renameVal.value]
                ])
              ], 32)
            ]),
            createBaseVNode("div", _hoisted_13$a, [
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleMinimized, ["stop"]),
                title: __props.layer.minimized ? "Unminimize" : "Minimize (hide when filter enabled)"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.minimized })
                }, "", 2)
              ], 40, _hoisted_14$9),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleFlattenTransform, ["stop"]),
                title: __props.layer.flattenTransform ? "Disable Flatten Transform" : "Flatten Transform"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.flattenTransform })
                }, "", 2)
              ], 40, _hoisted_15$8),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleQuality, ["stop"]),
                title: __props.layer.quality === "best" ? "Draft Quality" : "Best Quality"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.quality === "best" })
                }, "", 2)
              ], 40, _hoisted_16$7),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleEffects, ["stop"]),
                title: __props.layer.effectsEnabled !== false ? "Disable Effects" : "Enable Effects"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.effectsEnabled !== false, inactive: __props.layer.effectsEnabled === false })
                }, "fx", 2)
              ], 40, _hoisted_17$7),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleFrameBlend, ["stop"]),
                title: __props.layer.frameBlending ? "Disable Frame Blending" : "Enable Frame Blending"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.frameBlending })
                }, "", 2)
              ], 40, _hoisted_18$7),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleMotionBlur, ["stop"]),
                title: __props.layer.motionBlur ? "Disable Motion Blur" : "Enable Motion Blur"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.motionBlur })
                }, "", 2)
              ], 40, _hoisted_19$7),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: withModifiers(toggleEffectLayer, ["stop"]),
                title: __props.layer.effectLayer || __props.layer.adjustmentLayer ? "Disable Effect Layer" : "Make Effect Layer"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.effectLayer || __props.layer.adjustmentLayer })
                }, "", 2)
              ], 40, _hoisted_20$7),
              createBaseVNode("div", {
                class: "icon-col",
                onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => unref(store).toggleLayer3D(__props.layer.id), ["stop"])),
                title: __props.layer.threeD ? "Make 2D Layer" : "Make 3D Layer"
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({ active: __props.layer.threeD })
                }, "", 2)
              ], 40, _hoisted_21$7)
            ]),
            createBaseVNode("div", _hoisted_22$7, [
              createBaseVNode("select", {
                value: __props.layer.parentId || "",
                class: "mini-select",
                onChange: setParent,
                onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"]))
              }, [
                _cache[5] || (_cache[5] = createBaseVNode("option", { value: "" }, "None", -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(availableParents.value, (p) => {
                  return openBlock(), createElementBlock("option", {
                    key: p.id,
                    value: p.id
                  }, toDisplayString(p.index) + ". " + toDisplayString(p.name), 9, _hoisted_24$5);
                }), 128))
              ], 40, _hoisted_23$7)
            ])
          ], 34),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                createBaseVNode("div", {
                  class: "group-header sidebar-row",
                  style: normalizeStyle(__props.gridStyle),
                  onMousedown: withModifiers(($event) => toggleGroup(groupName), ["stop"])
                }, [
                  createBaseVNode("div", _hoisted_27$5, [
                    createBaseVNode("span", _hoisted_28$5, toDisplayString(expandedGroups.value.includes(groupName) ? "" : ""), 1)
                  ]),
                  createBaseVNode("div", _hoisted_29$5, [
                    createTextVNode(toDisplayString(groupName) + " ", 1),
                    groupName === "Transform" ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: "reset-link",
                      onClick: withModifiers(resetTransform, ["stop"])
                    }, "Reset")) : createCommentVNode("", true)
                  ])
                ], 44, _hoisted_26$5),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_30$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "sidebar",
                      gridStyle: __props.gridStyle,
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "layer-row track-bg",
            onMousedown: selectLayer
          }, [
            createBaseVNode("div", {
              class: "duration-bar",
              style: normalizeStyle(barStyle.value),
              onMousedown: withModifiers(startDrag, ["stop"])
            }, [
              createBaseVNode("div", {
                class: "bar-handle bar-handle-left",
                onMousedown: withModifiers(startResizeLeft, ["stop"])
              }, null, 32),
              createBaseVNode("div", {
                class: "bar-fill",
                style: normalizeStyle({ background: __props.layer.labelColor || "#777" })
              }, null, 4),
              createBaseVNode("div", {
                class: "bar-handle bar-handle-right",
                onMousedown: withModifiers(startResizeRight, ["stop"])
              }, null, 32)
            ], 36)
          ], 32),
          isExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_31$3, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(groupedProperties.value, (groupProps, groupName) => {
              return openBlock(), createElementBlock("div", {
                key: groupName,
                class: "property-group"
              }, [
                _cache[6] || (_cache[6] = createBaseVNode("div", { class: "group-header track-bg" }, null, -1)),
                expandedGroups.value.includes(groupName) ? (openBlock(), createElementBlock("div", _hoisted_32$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(groupProps, (prop) => {
                    return openBlock(), createBlock(PropertyTrack, {
                      key: prop.path,
                      layerId: __props.layer.id,
                      propertyPath: prop.path,
                      name: prop.name,
                      property: prop.property,
                      layoutMode: "track",
                      pixelsPerFrame: __props.pixelsPerFrame
                    }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]);
                  }), 128))
                ])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : createCommentVNode("", true)
        ], 64)),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenuVisible.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-context-menu",
            style: normalizeStyle({ left: contextMenuX.value + "px", top: contextMenuY.value + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: duplicateLayer }, "Duplicate Layer"),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            _cache[7] || (_cache[7] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: toggleLayerVisibility }, toDisplayString(__props.layer.visible ? "Hide" : "Show") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayerLock }, toDisplayString(__props.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
            createBaseVNode("button", { onClick: toggleLayer3D }, toDisplayString(__props.layer.threeD ? "Make 2D" : "Make 3D"), 1),
            _cache[8] || (_cache[8] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", { onClick: nestLayer }, "Nest Layers..."),
            _cache[9] || (_cache[9] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteLayer,
              class: "danger"
            }, "Delete Layer")
          ], 4)) : createCommentVNode("", true)
        ])),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          showColorPicker.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "layer-color-picker",
            style: normalizeStyle({ left: colorPickerX.value + "px", top: colorPickerY.value + "px" }),
            onClick: _cache[4] || (_cache[4] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("div", _hoisted_33$3, [
              (openBlock(), createElementBlock(Fragment, null, renderList(labelColors, (color) => {
                return createBaseVNode("button", {
                  key: color,
                  class: normalizeClass(["color-swatch", { active: __props.layer.labelColor === color }]),
                  style: normalizeStyle({ backgroundColor: color }),
                  onClick: ($event) => setLabelColor(color)
                }, null, 14, _hoisted_34$3);
              }), 64))
            ])
          ], 4)) : createCommentVNode("", true)
        ]))
      ])) : createCommentVNode("", true);
    };
  }
});

const EnhancedLayerTrack = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-95394625"]]);

const _hoisted_1$a = { class: "composition-tabs" };
const _hoisted_2$a = {
  key: 0,
  class: "breadcrumb-nav"
};
const _hoisted_3$a = ["onClick"];
const _hoisted_4$a = {
  key: 0,
  class: "breadcrumb-sep"
};
const _hoisted_5$a = { class: "tabs-container" };
const _hoisted_6$a = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_7$a = {
  key: 0,
  class: "nested-comp-icon",
  title: "Nested Composition"
};
const _hoisted_8$a = {
  key: 1,
  class: "tab-name"
};
const _hoisted_9$a = {
  key: 2,
  class: "tab-name"
};
const _hoisted_10$a = { class: "tab-info" };
const _hoisted_11$a = ["onClick"];
const _hoisted_12$9 = ["disabled"];
const _hoisted_13$9 = ["disabled"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "CompositionTabs",
  emits: ["newComposition", "openCompositionSettings"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const breadcrumbPath = computed(() => store.breadcrumbPath);
    const editingId = ref(null);
    const editingName = ref("");
    const renameInput = ref(null);
    const contextMenu = ref({
      visible: false,
      x: 0,
      y: 0,
      comp: null
    });
    const openCompositions = computed(() => store.openCompositions);
    const activeCompositionId = computed(() => store.activeCompositionId);
    const mainCompositionId = computed(() => store.project.mainCompositionId);
    function switchToComposition(compId) {
      store.switchComposition(compId);
    }
    function closeTab(compId) {
      store.closeCompositionTab(compId);
    }
    function navigateToBreadcrumb(idx) {
      store.navigateToBreadcrumb(idx);
    }
    function navigateBack() {
      store.navigateBack();
    }
    function formatCompInfo(comp) {
      const s = comp.settings;
      return `${s.width}x${s.height} ${s.fps}fps`;
    }
    function startRename(comp) {
      editingId.value = comp.id;
      editingName.value = comp.name;
      nextTick(() => {
        renameInput.value?.focus();
        renameInput.value?.select();
      });
    }
    function finishRename() {
      if (editingId.value && editingName.value.trim()) {
        store.renameComposition(editingId.value, editingName.value.trim());
      }
      editingId.value = null;
      editingName.value = "";
    }
    function cancelRename() {
      editingId.value = null;
      editingName.value = "";
    }
    function showContextMenu(event, comp) {
      contextMenu.value = {
        visible: true,
        x: event.clientX,
        y: event.clientY,
        comp
      };
    }
    function hideContextMenu() {
      contextMenu.value.visible = false;
      contextMenu.value.comp = null;
    }
    function openCompSettings() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== activeCompositionId.value) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      emit("openCompositionSettings");
      hideContextMenu();
    }
    function renameFromMenu() {
      if (contextMenu.value.comp) {
        startRename(contextMenu.value.comp);
      }
      hideContextMenu();
    }
    function duplicateComposition() {
      if (contextMenu.value.comp) {
        const original = contextMenu.value.comp;
        const newComp = store.createComposition(
          `${original.name} Copy`,
          original.settings,
          original.isNestedComp
        );
        console.log("[CompositionTabs] Duplicated:", newComp.name);
      }
      hideContextMenu();
    }
    function openInNewTab() {
      if (contextMenu.value.comp) {
        store.switchComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function setAsMainComp() {
      if (contextMenu.value.comp) {
        store.project.mainCompositionId = contextMenu.value.comp.id;
        console.log("[CompositionTabs] Set main composition:", contextMenu.value.comp.name);
      }
      hideContextMenu();
    }
    function deleteComposition() {
      if (contextMenu.value.comp && contextMenu.value.comp.id !== mainCompositionId.value) {
        store.deleteComposition(contextMenu.value.comp.id);
      }
      hideContextMenu();
    }
    function handleOutsideClick() {
      if (contextMenu.value.visible) {
        hideContextMenu();
      }
    }
    onMounted(() => {
      document.addEventListener("click", handleOutsideClick);
    });
    onUnmounted(() => {
      document.removeEventListener("click", handleOutsideClick);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        breadcrumbPath.value.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_2$a, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(breadcrumbPath.value, (crumb, idx) => {
            return openBlock(), createElementBlock(Fragment, {
              key: crumb.id
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["breadcrumb-item", { current: idx === breadcrumbPath.value.length - 1 }]),
                onClick: ($event) => navigateToBreadcrumb(idx)
              }, toDisplayString(crumb.name), 11, _hoisted_3$a),
              idx < breadcrumbPath.value.length - 1 ? (openBlock(), createElementBlock("span", _hoisted_4$a, "")) : createCommentVNode("", true)
            ], 64);
          }), 128)),
          createBaseVNode("button", {
            class: "back-btn",
            onClick: navigateBack,
            title: "Go back (Backspace)"
          }, "")
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_5$a, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(openCompositions.value, (comp) => {
            return openBlock(), createElementBlock("div", {
              key: comp.id,
              class: normalizeClass(["tab", {
                active: comp.id === activeCompositionId.value,
                nestedComp: comp.isNestedComp
              }]),
              onClick: ($event) => switchToComposition(comp.id),
              onDblclick: ($event) => startRename(comp),
              onContextmenu: withModifiers(($event) => showContextMenu($event, comp), ["prevent"])
            }, [
              comp.isNestedComp ? (openBlock(), createElementBlock("span", _hoisted_7$a, "")) : createCommentVNode("", true),
              editingId.value === comp.id ? (openBlock(), createElementBlock("span", _hoisted_8$a, [
                withDirectives(createBaseVNode("input", {
                  ref_for: true,
                  ref_key: "renameInput",
                  ref: renameInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => editingName.value = $event),
                  type: "text",
                  class: "rename-input",
                  onBlur: finishRename,
                  onKeydown: [
                    withKeys(finishRename, ["enter"]),
                    withKeys(cancelRename, ["escape"])
                  ],
                  onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                }, null, 544), [
                  [vModelText, editingName.value]
                ])
              ])) : (openBlock(), createElementBlock("span", _hoisted_9$a, toDisplayString(comp.name), 1)),
              createBaseVNode("span", _hoisted_10$a, toDisplayString(formatCompInfo(comp)), 1),
              openCompositions.value.length > 1 ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "close-btn",
                onClick: withModifiers(($event) => closeTab(comp.id), ["stop"]),
                title: "Close tab"
              }, "  ", 8, _hoisted_11$a)) : createCommentVNode("", true)
            ], 42, _hoisted_6$a);
          }), 128)),
          createBaseVNode("button", {
            class: "new-comp-btn",
            onClick: _cache[2] || (_cache[2] = ($event) => emit("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          contextMenu.value.visible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "context-menu",
            style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("button", { onClick: openCompSettings }, "Composition Settings..."),
            createBaseVNode("button", { onClick: renameFromMenu }, "Rename"),
            createBaseVNode("button", { onClick: duplicateComposition }, "Duplicate"),
            createBaseVNode("button", { onClick: openInNewTab }, "Open in New Tab"),
            _cache[4] || (_cache[4] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: setAsMainComp,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value
            }, " Set as Main Composition ", 8, _hoisted_12$9),
            _cache[5] || (_cache[5] = createBaseVNode("hr", null, null, -1)),
            createBaseVNode("button", {
              onClick: deleteComposition,
              disabled: contextMenu.value.comp?.id === mainCompositionId.value,
              class: "danger"
            }, " Delete Composition ", 8, _hoisted_13$9)
          ], 4)) : createCommentVNode("", true)
        ]))
      ]);
    };
  }
});

const CompositionTabs = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-15eeaa84"]]);

const _hoisted_1$9 = { class: "timeline-header" };
const _hoisted_2$9 = { class: "header-left" };
const _hoisted_3$9 = { class: "timecode" };
const _hoisted_4$9 = { class: "frame-display" };
const _hoisted_5$9 = ["value"];
const _hoisted_6$9 = { class: "fps-label" };
const _hoisted_7$9 = { class: "header-center" };
const _hoisted_8$9 = ["aria-expanded"];
const _hoisted_9$9 = { class: "tool-group" };
const _hoisted_10$9 = ["disabled"];
const _hoisted_11$9 = { class: "tool-group" };
const _hoisted_12$8 = { class: "header-right" };
const _hoisted_13$8 = { class: "timeline-content" };
const _hoisted_14$8 = { class: "sidebar-header-row" };
const _hoisted_15$7 = { class: "col-header col-switches" };
const MAX_PPF = 80;
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings", "openPathSuggestion"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const zoomPercent = ref(0);
    const sidebarWidth = ref(450);
    const expandedLayers = ref({});
    const showAddLayerMenu = ref(false);
    const addLayerContainer = ref(null);
    const trackViewportRef = ref(null);
    const rulerCanvas = ref(null);
    const sidebarScrollRef = ref(null);
    const trackScrollRef = ref(null);
    const rulerScrollRef = ref(null);
    let isScrollingSidebar = false;
    let isScrollingTrack = false;
    const viewportWidth = ref(1e3);
    const filteredLayers = computed(() => store.displayedLayers || []);
    const playheadPositionPct = computed(() => store.currentFrame / store.frameCount * 100);
    const effectivePpf = computed(() => {
      const minPpf = viewportWidth.value / store.frameCount;
      return minPpf + zoomPercent.value / 100 * (MAX_PPF - minPpf);
    });
    const timelineWidth = computed(() => {
      if (zoomPercent.value === 0) {
        return viewportWidth.value;
      }
      return store.frameCount * effectivePpf.value;
    });
    const computedWidthStyle = computed(() => timelineWidth.value + "px");
    const sidebarGridStyle = computed(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function toggleAddLayerMenu() {
      showAddLayerMenu.value = !showAddLayerMenu.value;
    }
    const addLayerMenuStyle = computed(() => {
      if (!showAddLayerMenu.value || !addLayerContainer.value) {
        return {};
      }
      const rect = addLayerContainer.value.getBoundingClientRect();
      return {
        position: "fixed",
        left: `${rect.left}px`,
        bottom: `${window.innerHeight - rect.top + 8}px`
      };
    });
    function addLayer(type) {
      let newLayer;
      if (type === "text") newLayer = store.createTextLayer();
      else if (type === "video") newLayer = store.createLayer("video");
      else if (type === "camera") newLayer = store.createCameraLayer();
      else if (type === "particles") newLayer = store.createParticleLayer();
      else newLayer = store.createLayer(type);
      showAddLayerMenu.value = false;
      if (newLayer) {
        store.selectLayer(newLayer.id);
        if (type === "spline" || type === "shape") {
          store.setTool("pen");
        } else if (type === "text") {
          store.setTool("text");
        } else {
          store.setTool("select");
        }
      }
    }
    function selectLayer(id) {
      store.selectLayer(id);
    }
    function updateLayer(id, u) {
      store.updateLayer(id, u);
    }
    function deleteSelectedLayers() {
      store.selectedLayerIds.forEach((id) => store.deleteLayer(id));
    }
    function setFrame(e) {
      store.setFrame(parseInt(e.target.value) || 0);
    }
    function togglePlayback() {
      store.togglePlayback();
    }
    function handleToggleExpand(id, val) {
      expandedLayers.value[id] = val;
    }
    function formatTimecode(frame) {
      const fps = store.fps;
      const totalSeconds = Math.floor(frame / fps);
      const frames = Math.floor(frame % fps);
      const seconds = totalSeconds % 60;
      const minutes = Math.floor(totalSeconds / 60) % 60;
      const hours = Math.floor(totalSeconds / 3600);
      const pad = (n, len = 2) => String(n).padStart(len, "0");
      return `${pad(hours)};${pad(minutes)};${pad(seconds)};${pad(frames)}`;
    }
    function drawRuler() {
      const cvs = rulerCanvas.value;
      if (!cvs) return;
      const ctx = cvs.getContext("2d");
      if (!ctx) return;
      const width = timelineWidth.value;
      cvs.width = width;
      cvs.height = 30;
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, cvs.width, cvs.height);
      ctx.strokeStyle = "#666";
      ctx.fillStyle = "#aaa";
      ctx.font = "11px sans-serif";
      const labelMinWidth = 40;
      const maxLabels = Math.max(1, Math.floor(width / labelMinWidth));
      const idealStep = Math.ceil(store.frameCount / maxLabels);
      const niceSteps = [1, 2, 5, 10, 20, 25, 50, 100, 200];
      const majorStep = niceSteps.find((s) => s >= idealStep) || 200;
      const minorStep = majorStep > 1 ? Math.floor(majorStep / 2) : 0;
      const frameCount = store.frameCount;
      for (let f = 0; f <= frameCount; f++) {
        const x = f / frameCount * width;
        if (f % majorStep === 0) {
          ctx.strokeStyle = "#888";
          ctx.beginPath();
          ctx.moveTo(x, 12);
          ctx.lineTo(x, 30);
          ctx.stroke();
          ctx.fillStyle = "#ccc";
          ctx.fillText(String(f), x + 3, 10);
        } else if (minorStep > 0 && f % minorStep === 0) {
          ctx.strokeStyle = "#555";
          ctx.beginPath();
          ctx.moveTo(x, 22);
          ctx.lineTo(x, 30);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = "#444";
      ctx.beginPath();
      ctx.moveTo(0, 29.5);
      ctx.lineTo(cvs.width, 29.5);
      ctx.stroke();
    }
    function startRulerScrub(e) {
      const rect = rulerCanvas.value.getBoundingClientRect();
      const update = (ev) => {
        const currentScrollX = rulerScrollRef.value?.scrollLeft || trackScrollRef.value?.scrollLeft || 0;
        const x = ev.clientX - rect.left + currentScrollX;
        let f = Math.max(0, Math.min(store.frameCount - 1, x / timelineWidth.value * store.frameCount));
        if (!ev.altKey && store.snapConfig.enabled) {
          const snap = findNearestSnap(Math.round(f), store.snapConfig, effectivePpf.value, {
            layers: store.layers,
            audioAnalysis: store.audioAnalysis,
            peakData: store.peakData
          });
          if (snap) {
            f = snap.frame;
          }
        }
        store.setFrame(Math.round(f));
      };
      update(e);
      window.addEventListener("mousemove", update);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", update), { once: true });
    }
    function startResize(e) {
      const startX = e.clientX;
      const startW = sidebarWidth.value;
      const onMove = (ev) => {
        sidebarWidth.value = Math.max(450, startW + (ev.clientX - startX));
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", () => window.removeEventListener("mousemove", onMove), { once: true });
    }
    function syncSidebarScroll(e) {
      if (isScrollingTrack) return;
      isScrollingSidebar = true;
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollTop = target.scrollTop;
      }
      requestAnimationFrame(() => {
        isScrollingSidebar = false;
      });
    }
    function handleTrackScroll(e) {
      const target = e.target;
      if (!isScrollingSidebar) {
        isScrollingTrack = true;
        if (sidebarScrollRef.value) {
          sidebarScrollRef.value.scrollTop = target.scrollTop;
        }
        requestAnimationFrame(() => {
          isScrollingTrack = false;
        });
      }
      if (rulerScrollRef.value) {
        rulerScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function syncRulerScroll(e) {
      const target = e.target;
      if (trackScrollRef.value) {
        trackScrollRef.value.scrollLeft = target.scrollLeft;
      }
    }
    function handleKeydown(e) {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      if (e.code === "Space") {
        e.preventDefault();
        togglePlayback();
      }
      if (e.code === "Delete" || e.code === "Backspace") {
        e.preventDefault();
        deleteSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyC") {
        e.preventDefault();
        store.copySelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyX") {
        e.preventDefault();
        store.cutSelectedLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyV") {
        e.preventDefault();
        store.pasteLayers();
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyA") {
        e.preventDefault();
        store.selectedLayerIds = store.layers.map((l) => l.id);
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyD") {
        e.preventDefault();
        for (const id of store.selectedLayerIds) {
          store.duplicateLayer(id);
        }
      }
    }
    let resizeObserver = null;
    onMounted(() => {
      window.addEventListener("mousedown", (e) => {
        if (addLayerContainer.value && !addLayerContainer.value.contains(e.target)) {
          showAddLayerMenu.value = false;
        }
      });
      const elementToObserve = trackScrollRef.value || trackViewportRef.value;
      if (elementToObserve) {
        viewportWidth.value = elementToObserve.clientWidth || 1e3;
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            viewportWidth.value = entry.contentRect.width || elementToObserve.clientWidth || 1e3;
            drawRuler();
          }
        });
        resizeObserver.observe(elementToObserve);
      }
      setTimeout(() => {
        if (trackScrollRef.value) {
          viewportWidth.value = trackScrollRef.value.clientWidth || viewportWidth.value;
        }
        drawRuler();
      }, 50);
    });
    onUnmounted(() => {
      if (resizeObserver) resizeObserver.disconnect();
    });
    watch(() => [computedWidthStyle.value, zoomPercent.value, store.frameCount], () => nextTick(drawRuler));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "timeline-panel",
        tabindex: "0",
        onKeydown: handleKeydown,
        role: "region",
        "aria-label": "Timeline"
      }, [
        createVNode(CompositionTabs, {
          onNewComposition: _cache[0] || (_cache[0] = ($event) => emit("openCompositionSettings")),
          onOpenCompositionSettings: _cache[1] || (_cache[1] = ($event) => emit("openCompositionSettings"))
        }),
        createBaseVNode("div", _hoisted_1$9, [
          createBaseVNode("div", _hoisted_2$9, [
            createBaseVNode("span", _hoisted_3$9, toDisplayString(formatTimecode(unref(store).currentFrame)), 1),
            createBaseVNode("div", _hoisted_4$9, [
              createBaseVNode("input", {
                type: "number",
                value: unref(store).currentFrame,
                onChange: setFrame,
                class: "frame-input"
              }, null, 40, _hoisted_5$9),
              createBaseVNode("span", _hoisted_6$9, toDisplayString(unref(store).fps) + " fps", 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$9, [
            createBaseVNode("div", {
              class: "tool-group add-layer-wrapper",
              ref_key: "addLayerContainer",
              ref: addLayerContainer
            }, [
              createBaseVNode("button", {
                class: normalizeClass(["add-layer-btn", { active: showAddLayerMenu.value }]),
                onMousedown: withModifiers(toggleAddLayerMenu, ["stop", "prevent"]),
                "aria-label": "Add Layer",
                "aria-haspopup": "menu",
                "aria-expanded": showAddLayerMenu.value
              }, [..._cache[15] || (_cache[15] = [
                createBaseVNode("span", {
                  class: "icon",
                  "aria-hidden": "true"
                }, "+", -1),
                createTextVNode(" Layer ", -1)
              ])], 42, _hoisted_8$9),
              showAddLayerMenu.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "add-layer-menu",
                role: "menu",
                "aria-label": "Layer types",
                style: normalizeStyle(addLayerMenuStyle.value)
              }, [
                createBaseVNode("button", {
                  onMousedown: _cache[2] || (_cache[2] = ($event) => addLayer("solid")),
                  role: "menuitem"
                }, [..._cache[16] || (_cache[16] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Solid", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[3] || (_cache[3] = ($event) => addLayer("text")),
                  role: "menuitem"
                }, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "T", -1),
                  createTextVNode(" Text", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[4] || (_cache[4] = ($event) => addLayer("shape")),
                  role: "menuitem"
                }, [..._cache[18] || (_cache[18] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Shape", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[5] || (_cache[5] = ($event) => addLayer("spline")),
                  role: "menuitem"
                }, [..._cache[19] || (_cache[19] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Spline/Path", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[6] || (_cache[6] = ($event) => addLayer("particles")),
                  role: "menuitem"
                }, [..._cache[20] || (_cache[20] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Particles", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[7] || (_cache[7] = ($event) => addLayer("control")),
                  role: "menuitem"
                }, [..._cache[21] || (_cache[21] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Control", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[8] || (_cache[8] = ($event) => addLayer("camera")),
                  role: "menuitem"
                }, [..._cache[22] || (_cache[22] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Camera", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[9] || (_cache[9] = ($event) => addLayer("light")),
                  role: "menuitem"
                }, [..._cache[23] || (_cache[23] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Light", -1)
                ])], 32),
                createBaseVNode("button", {
                  onMousedown: _cache[10] || (_cache[10] = ($event) => addLayer("video")),
                  role: "menuitem"
                }, [..._cache[24] || (_cache[24] = [
                  createBaseVNode("span", {
                    class: "icon",
                    "aria-hidden": "true"
                  }, "", -1),
                  createTextVNode(" Video", -1)
                ])], 32)
              ], 4)) : createCommentVNode("", true)
            ], 512),
            createBaseVNode("div", _hoisted_9$9, [
              createBaseVNode("button", {
                class: "delete-btn",
                onClick: deleteSelectedLayers,
                disabled: unref(store).selectedLayerIds.length === 0,
                "aria-label": "Delete selected layers"
              }, "", 8, _hoisted_10$9)
            ]),
            createBaseVNode("div", _hoisted_11$9, [
              createBaseVNode("button", {
                class: "comp-settings-btn",
                onClick: _cache[11] || (_cache[11] = ($event) => emit("openCompositionSettings")),
                title: "Composition Settings (Ctrl+K)"
              }, "  Comp Settings "),
              createBaseVNode("button", {
                class: "ai-btn",
                onClick: _cache[12] || (_cache[12] = ($event) => emit("openPathSuggestion")),
                title: "AI Path Suggestion"
              }, "  AI ")
            ])
          ]),
          createBaseVNode("div", _hoisted_12$8, [
            withDirectives(createBaseVNode("input", {
              type: "range",
              min: "0",
              max: "100",
              step: "1",
              "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => zoomPercent.value = $event),
              class: "zoom-slider",
              title: "Zoom Timeline",
              "aria-label": "Timeline zoom level"
            }, null, 512), [
              [
                vModelText,
                zoomPercent.value,
                void 0,
                { number: true }
              ]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_13$8, [
          createBaseVNode("div", {
            class: "timeline-sidebar",
            style: normalizeStyle({ width: sidebarWidth.value + "px" })
          }, [
            createBaseVNode("div", _hoisted_14$8, [
              _cache[26] || (_cache[26] = createStaticVNode('<div class="col-header col-av-features" data-v-64eb9c24><span class="header-icon" title="Video" data-v-64eb9c24></span><span class="header-icon" title="Audio" data-v-64eb9c24></span><span class="header-icon" title="Isolate" data-v-64eb9c24></span><span class="header-icon" title="Lock" data-v-64eb9c24></span></div><div class="col-header col-number" data-v-64eb9c24>#</div><div class="col-header col-name" data-v-64eb9c24>Source Name</div>', 3)),
              createBaseVNode("div", _hoisted_15$7, [
                createBaseVNode("span", {
                  class: normalizeClass(["header-icon clickable", { active: unref(store).hideMinimizedLayers }]),
                  title: "Hide Minimized Layers",
                  onClick: _cache[14] || (_cache[14] = ($event) => unref(store).toggleHideMinimizedLayers())
                }, "", 2),
                _cache[25] || (_cache[25] = createStaticVNode('<span class="header-icon" title="Flatten Transform" data-v-64eb9c24></span><span class="header-icon" title="Quality" data-v-64eb9c24></span><span class="header-icon" title="Effects" data-v-64eb9c24>fx</span><span class="header-icon" title="Frame Blending" data-v-64eb9c24></span><span class="header-icon" title="Motion Blur" data-v-64eb9c24></span><span class="header-icon" title="Adjustment Layer" data-v-64eb9c24></span><span class="header-icon" title="3D Layer" data-v-64eb9c24></span>', 7))
              ]),
              _cache[27] || (_cache[27] = createBaseVNode("div", { class: "col-header col-parent" }, "Parent & Link", -1))
            ]),
            createBaseVNode("div", {
              class: "sidebar-scroll-area",
              ref_key: "sidebarScrollRef",
              ref: sidebarScrollRef,
              onScroll: syncSidebarScroll
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer, idx) => {
                return openBlock(), createBlock(EnhancedLayerTrack, {
                  key: layer.id,
                  layer,
                  index: idx + 1,
                  layoutMode: "sidebar",
                  isExpandedExternal: expandedLayers.value[layer.id],
                  allLayers: unref(store).layers,
                  gridStyle: sidebarGridStyle.value,
                  onToggleExpand: handleToggleExpand,
                  onSelect: selectLayer,
                  onUpdateLayer: updateLayer
                }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]);
              }), 128))
            ], 544)
          ], 4),
          createBaseVNode("div", {
            class: "sidebar-resizer",
            onMousedown: startResize
          }, null, 32),
          createBaseVNode("div", {
            class: "track-viewport",
            ref_key: "trackViewportRef",
            ref: trackViewportRef
          }, [
            createBaseVNode("div", {
              class: "ruler-scroll-wrapper",
              onScroll: syncRulerScroll,
              ref_key: "rulerScrollRef",
              ref: rulerScrollRef
            }, [
              createBaseVNode("div", {
                class: "time-ruler",
                style: normalizeStyle({ width: computedWidthStyle.value }),
                onMousedown: startRulerScrub
              }, [
                createBaseVNode("canvas", {
                  ref_key: "rulerCanvas",
                  ref: rulerCanvas,
                  height: "30"
                }, null, 512),
                createBaseVNode("div", {
                  class: "playhead-head",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4),
                createBaseVNode("div", {
                  class: "playhead-hit-area",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" }),
                  onMousedown: withModifiers(startRulerScrub, ["stop"])
                }, null, 36)
              ], 36)
            ], 544),
            createBaseVNode("div", {
              class: "track-scroll-area",
              ref_key: "trackScrollRef",
              ref: trackScrollRef,
              onScroll: handleTrackScroll
            }, [
              createBaseVNode("div", {
                class: "layer-bars-container",
                style: normalizeStyle({ width: computedWidthStyle.value })
              }, [
                _cache[28] || (_cache[28] = createBaseVNode("div", { class: "grid-background" }, null, -1)),
                (openBlock(true), createElementBlock(Fragment, null, renderList(filteredLayers.value, (layer) => {
                  return openBlock(), createBlock(EnhancedLayerTrack, {
                    key: layer.id,
                    layer,
                    layoutMode: "track",
                    frameCount: unref(store).frameCount,
                    pixelsPerFrame: effectivePpf.value,
                    isExpandedExternal: expandedLayers.value[layer.id],
                    onSelect: selectLayer,
                    onUpdateLayer: updateLayer
                  }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]);
                }), 128)),
                createBaseVNode("div", {
                  class: "playhead-line",
                  style: normalizeStyle({ left: playheadPositionPct.value + "%" })
                }, null, 4)
              ], 4)
            ], 544)
          ], 512)
        ])
      ], 32);
    };
  }
});

const TimelinePanel = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-64eb9c24"]]);

const _hoisted_1$8 = { class: "graph-editor" };
const _hoisted_2$8 = { class: "graph-header" };
const _hoisted_3$8 = { class: "mode-toggle" };
const _hoisted_4$8 = { class: "preset-buttons" };
const _hoisted_5$8 = ["onClick", "title"];
const _hoisted_6$8 = { class: "toolbar" };
const _hoisted_7$8 = { class: "graph-content" };
const _hoisted_8$8 = { class: "property-list" };
const _hoisted_9$8 = { class: "property-list-header" };
const _hoisted_10$8 = ["title"];
const _hoisted_11$8 = ["onClick"];
const _hoisted_12$7 = ["onClick"];
const _hoisted_13$7 = { class: "property-name" };
const _hoisted_14$7 = {
  key: 0,
  class: "keyframe-count"
};
const _hoisted_15$6 = {
  key: 0,
  class: "dimension-toggles"
};
const _hoisted_16$6 = ["onClick"];
const _hoisted_17$6 = {
  key: 0,
  class: "no-properties"
};
const _hoisted_18$6 = { class: "graph-main" };
const _hoisted_19$6 = ["viewBox"];
const _hoisted_20$6 = ["onMousedown"];
const _hoisted_21$6 = ["x", "y", "fill", "transform"];
const _hoisted_22$6 = {
  key: 1,
  class: "bezier-handles"
};
const _hoisted_23$6 = {
  key: 0,
  class: "handle out-handle"
};
const _hoisted_24$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_25$4 = ["cx", "cy", "onMousedown"];
const _hoisted_26$4 = {
  key: 1,
  class: "handle in-handle"
};
const _hoisted_27$4 = ["x1", "y1", "x2", "y2"];
const _hoisted_28$4 = ["cx", "cy", "onMousedown"];
const _hoisted_29$4 = ["x1", "x2", "y2"];
const _hoisted_30$3 = {
  key: 0,
  class: "keyframe-info-panel"
};
const _hoisted_31$2 = { class: "info-row" };
const _hoisted_32$2 = ["value"];
const _hoisted_33$2 = { class: "info-row" };
const _hoisted_34$2 = ["value"];
const _hoisted_35$2 = { class: "info-row" };
const _hoisted_36$2 = ["value"];
const _hoisted_37$2 = ["disabled"];
const _hoisted_38$2 = ["disabled"];
const _hoisted_39$2 = ["disabled"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "GraphEditor",
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const canvasRef = ref(null);
    const canvasContainerRef = ref(null);
    const timeRulerRef = ref(null);
    const timeRulerCanvas = ref(null);
    const valueAxisRef = ref(null);
    const valueAxisCanvas = ref(null);
    const canvasWidth = ref(400);
    const canvasHeight = ref(200);
    const mode = ref("value");
    const viewState = reactive({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    });
    const selectedPropertyIds = ref([]);
    const visiblePropertyIds = ref([]);
    const visibleDimensions = ref({});
    const selectedKeyframes = ref([]);
    const hoveredKeyframe = ref(null);
    const dragTarget = ref(null);
    const selectionBox = ref(null);
    const contextMenu = ref(null);
    const clipboard = ref(null);
    const snapEnabled = ref(false);
    const autoSelectNearby = ref(true);
    const margin = { top: 10, right: 10, bottom: 10, left: 10 };
    const propertyColors = {
      "Position": "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      "Scale": "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      "Rotation": "#bb8fce",
      "Opacity": "#f8b739",
      "default": "#7c9cff"
    };
    const presetList = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ];
    const animatableProperties = computed(() => {
      const layer = store.selectedLayer;
      if (!layer) return [];
      const props = [];
      props.push(layer.transform.position);
      props.push(layer.transform.scale);
      props.push(layer.transform.rotation);
      props.push(layer.opacity);
      props.push(...layer.properties);
      return props;
    });
    const visibleProperties = computed(() => {
      return animatableProperties.value.filter(
        (p) => visiblePropertyIds.value.includes(p.id) && p.animated
      );
    });
    const allPropertiesVisible = computed(() => {
      return animatableProperties.value.every((p) => visiblePropertyIds.value.includes(p.id));
    });
    const currentFrameScreenX = computed(() => {
      return frameToScreenX(store.currentFrame);
    });
    function frameToScreenX(frame) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (frame - viewState.frameStart) / (viewState.frameEnd - viewState.frameStart);
      return margin.left + t * graphWidth;
    }
    function screenXToFrame(screenX) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const t = (screenX - margin.left) / graphWidth;
      return viewState.frameStart + t * (viewState.frameEnd - viewState.frameStart);
    }
    function valueToScreenY(value) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (value - viewState.valueMin) / (viewState.valueMax - viewState.valueMin);
      return canvasHeight.value - margin.bottom - t * graphHeight;
    }
    function screenYToValue(screenY) {
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      const t = (canvasHeight.value - margin.bottom - screenY) / graphHeight;
      return viewState.valueMin + t * (viewState.valueMax - viewState.valueMin);
    }
    function getKeyframeScreenX(kf) {
      return frameToScreenX(kf.frame);
    }
    function getKeyframeScreenY(prop, kf) {
      const value = typeof kf.value === "number" ? kf.value : typeof kf.value === "object" ? kf.value.x ?? kf.value : 0;
      return valueToScreenY(value);
    }
    function getKeyframeDisplayValue(selection) {
      if (!selection) return 0;
      const value = selection.keyframe.value;
      return typeof value === "number" ? value : typeof value === "object" ? value.x ?? 0 : 0;
    }
    function getOutHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.outHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getOutHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.outHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.outHandle.value;
      return valueToScreenY(handleValue);
    }
    function getInHandleX(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return frameToScreenX(kf.frame);
      const handleFrame = kf.frame + kf.inHandle.frame;
      return frameToScreenX(handleFrame);
    }
    function getInHandleY(prop, kfIndex) {
      const kf = prop.keyframes[kfIndex];
      if (!kf || !kf.inHandle.enabled) return valueToScreenY(getNumericValue(kf.value));
      const handleValue = getNumericValue(kf.value) + kf.inHandle.value;
      return valueToScreenY(handleValue);
    }
    function getNumericValue(value) {
      if (typeof value === "number") return value;
      if (typeof value === "object") return value.x ?? value.y ?? value.z ?? 0;
      return 0;
    }
    function getPropertyColor(propId) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return propertyColors.default;
      return propertyColors[prop.name] ?? propertyColors.default;
    }
    function isKeyframeInView(kf) {
      return kf.frame >= viewState.frameStart && kf.frame <= viewState.frameEnd;
    }
    function isKeyframeSelected(propId, index) {
      return selectedKeyframes.value.some((sk) => sk.propId === propId && sk.index === index);
    }
    function hasDimension(prop, dim) {
      if (!prop.animated || prop.keyframes.length === 0) return false;
      const value = prop.keyframes[0].value;
      return typeof value === "object" && dim in value;
    }
    function toggleProperty(propId) {
      const index = selectedPropertyIds.value.indexOf(propId);
      if (index === -1) {
        selectedPropertyIds.value.push(propId);
      } else {
        selectedPropertyIds.value.splice(index, 1);
      }
    }
    function togglePropertyVisibility(propId) {
      const index = visiblePropertyIds.value.indexOf(propId);
      if (index === -1) {
        visiblePropertyIds.value.push(propId);
      } else {
        visiblePropertyIds.value.splice(index, 1);
      }
      updateViewBounds();
    }
    function toggleAllProperties() {
      if (allPropertiesVisible.value) {
        visiblePropertyIds.value = [];
      } else {
        visiblePropertyIds.value = animatableProperties.value.map((p) => p.id);
      }
      updateViewBounds();
    }
    function toggleDimension(propId, dim) {
      if (!visibleDimensions.value[propId]) {
        visibleDimensions.value[propId] = [];
      }
      const dims = visibleDimensions.value[propId];
      const index = dims.indexOf(dim);
      if (index === -1) {
        dims.push(dim);
      } else {
        dims.splice(index, 1);
      }
    }
    function fitToView() {
      const visible = visibleProperties.value;
      if (visible.length === 0) return;
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const prop of visible) {
        for (const kf of prop.keyframes) {
          minFrame = Math.min(minFrame, kf.frame);
          maxFrame = Math.max(maxFrame, kf.frame);
          const value = getNumericValue(kf.value);
          minValue = Math.min(minValue, value);
          maxValue = Math.max(maxValue, value);
        }
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
    }
    function updateViewBounds() {
      fitToView();
    }
    function toggleAutoSelect() {
      autoSelectNearby.value = !autoSelectNearby.value;
    }
    function isPresetActive(presetKey) {
      if (selectedKeyframes.value.length === 0) return false;
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return false;
      if (presetKey === "linear") {
        return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "linear");
      }
      return selectedKeyframes.value.every((sk) => sk.keyframe.interpolation === "bezier");
    }
    function applyPreset(presetKey) {
      const preset = EASING_PRESETS[presetKey];
      if (!preset) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const propertyPath = getPropertyPath(prop);
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? sk.keyframe.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - sk.keyframe.frame : 10;
        if (presetKey === "linear") {
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "linear");
          sk.keyframe.interpolation = "linear";
          sk.keyframe.outHandle = { frame: outDuration * 0.33, value: 0, enabled: false };
          sk.keyframe.inHandle = { frame: -inDuration * 0.33, value: 0, enabled: false };
        } else {
          const outHandle = {
            frame: preset.outHandle.x * outDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          const inHandle = {
            frame: -preset.inHandle.x * inDuration,
            value: 0,
            // Would need value delta for proper curve
            enabled: true
          };
          store.setKeyframeInterpolation(layer.id, propertyPath, sk.keyframe.id, "bezier");
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "out", outHandle);
          store.setKeyframeHandle(layer.id, propertyPath, sk.keyframe.id, "in", inHandle);
          sk.keyframe.interpolation = "bezier";
          sk.keyframe.outHandle = outHandle;
          sk.keyframe.inHandle = inHandle;
        }
      }
      drawGraph();
    }
    function handleMouseDown(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 1 || event.button === 0 && event.altKey) {
        dragTarget.value = { type: "pan", startX: x, startY: y };
      } else if (event.button === 0) {
        if (!event.shiftKey) {
          selectedKeyframes.value = [];
        }
        selectionBox.value = { x, y, width: 0, height: 0 };
        dragTarget.value = { type: "select", startX: x, startY: y };
      }
    }
    function handleMouseMove(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      updateHoveredKeyframe(x, y);
      if (!dragTarget.value) return;
      if (dragTarget.value.type === "pan") {
        const dx = x - (dragTarget.value.startX ?? 0);
        const dy = y - (dragTarget.value.startY ?? 0);
        const graphWidth = canvasWidth.value - margin.left - margin.right;
        const graphHeight = canvasHeight.value - margin.top - margin.bottom;
        const frameShift = -dx / graphWidth * (viewState.frameEnd - viewState.frameStart);
        const valueShift = dy / graphHeight * (viewState.valueMax - viewState.valueMin);
        viewState.frameStart += frameShift;
        viewState.frameEnd += frameShift;
        viewState.valueMin += valueShift;
        viewState.valueMax += valueShift;
        dragTarget.value.startX = x;
        dragTarget.value.startY = y;
        drawGraph();
      } else if (dragTarget.value.type === "select" && selectionBox.value) {
        const startX = dragTarget.value.startX ?? 0;
        const startY = dragTarget.value.startY ?? 0;
        selectionBox.value = {
          x: Math.min(x, startX),
          y: Math.min(y, startY),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY)
        };
      } else if (dragTarget.value.type === "keyframe") {
        moveSelectedKeyframes(x, y);
      } else if (dragTarget.value.type === "outHandle" || dragTarget.value.type === "inHandle") {
        moveHandle(x, y);
      }
    }
    function handleMouseUp() {
      if (dragTarget.value?.type === "select" && selectionBox.value) {
        selectKeyframesInBox();
      }
      dragTarget.value = null;
      selectionBox.value = null;
    }
    function handleWheel(event) {
      event.preventDefault();
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
      const frameAtCursor = screenXToFrame(x);
      const newFrameStart = frameAtCursor - (frameAtCursor - viewState.frameStart) * zoomFactor;
      const newFrameEnd = frameAtCursor + (viewState.frameEnd - frameAtCursor) * zoomFactor;
      if (event.shiftKey) {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
      } else {
        viewState.frameStart = newFrameStart;
        viewState.frameEnd = newFrameEnd;
        const y = event.clientY - rect.top;
        const valueAtCursor = screenYToValue(y);
        viewState.valueMin = valueAtCursor - (valueAtCursor - viewState.valueMin) * zoomFactor;
        viewState.valueMax = valueAtCursor + (viewState.valueMax - valueAtCursor) * zoomFactor;
      }
      drawGraph();
    }
    function updateHoveredKeyframe(x, y) {
      hoveredKeyframe.value = null;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const kfX = getKeyframeScreenX(kf);
          const kfY = getKeyframeScreenY(prop, kf);
          const dist = Math.sqrt((x - kfX) ** 2 + (y - kfY) ** 2);
          if (dist < 10) {
            hoveredKeyframe.value = { propId: prop.id, index: i };
            return;
          }
        }
      }
    }
    function onKeyframeMouseDown(propId, index, event) {
      const prop = animatableProperties.value.find((p) => p.id === propId);
      if (!prop) return;
      const kf = prop.keyframes[index];
      if (!event.shiftKey) {
        selectedKeyframes.value = [];
      }
      if (!isKeyframeSelected(propId, index)) {
        selectedKeyframes.value.push({ propId, index, keyframe: kf });
      }
      dragTarget.value = { type: "keyframe", propId, index };
    }
    function selectKeyframesInBox() {
      if (!selectionBox.value) return;
      const box = selectionBox.value;
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          const kf = prop.keyframes[i];
          const x = getKeyframeScreenX(kf);
          const y = getKeyframeScreenY(prop, kf);
          if (x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height) {
            if (!isKeyframeSelected(prop.id, i)) {
              selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: kf });
            }
          }
        }
      }
    }
    function moveSelectedKeyframes(screenX, screenY) {
      const newFrame = Math.round(screenXToFrame(screenX));
      const newValue = screenYToValue(screenY);
      const layer = store.selectedLayer;
      if (!layer) return;
      if (selectedKeyframes.value.length > 0) {
        const sk = selectedKeyframes.value[0];
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) return;
        const frame = snapEnabled.value ? Math.round(newFrame / 5) * 5 : newFrame;
        const propertyPath = getPropertyPath(prop);
        store.updateKeyframe(layer.id, propertyPath, sk.keyframe.id, {
          frame,
          value: typeof sk.keyframe.value === "number" ? newValue : void 0
        });
        sk.keyframe.frame = frame;
        if (typeof sk.keyframe.value === "number") {
          sk.keyframe.value = newValue;
        }
      }
      drawGraph();
    }
    function getPropertyPath(prop) {
      const name = prop.name.toLowerCase();
      if (name === "position") return "transform.position";
      if (name === "scale") return "transform.scale";
      if (name === "rotation") return "transform.rotation";
      if (name === "opacity") return "opacity";
      if (name === "anchor point") return "transform.anchorPoint";
      return prop.id;
    }
    function startDragHandle(type, propId, index, event) {
      dragTarget.value = { type, propId, index };
      document.addEventListener("mousemove", onDragHandle);
      document.addEventListener("mouseup", stopDragHandle);
    }
    function onDragHandle(event) {
      const rect = canvasRef.value?.getBoundingClientRect();
      if (!rect || !dragTarget.value) return;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      moveHandle(x, y);
    }
    function moveHandle(screenX, screenY) {
      if (!dragTarget.value || !dragTarget.value.propId) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = animatableProperties.value.find((p) => p.id === dragTarget.value.propId);
      if (!prop) return;
      const kfIndex = dragTarget.value.index;
      const kf = prop.keyframes[kfIndex];
      if (!kf) return;
      const handleFrame = screenXToFrame(screenX);
      const handleValue = screenYToValue(screenY);
      const propertyPath = getPropertyPath(prop);
      if (dragTarget.value.type === "outHandle") {
        const nextKf = prop.keyframes[kfIndex + 1];
        let frameOffset = handleFrame - kf.frame;
        if (nextKf) {
          frameOffset = Math.max(0, Math.min(nextKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.max(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", newHandle);
        kf.outHandle = newHandle;
        kf.interpolation = "bezier";
        applyControlModeConstraints(kf, "out", propertyPath);
      } else if (dragTarget.value.type === "inHandle") {
        const prevKf = prop.keyframes[kfIndex - 1];
        let frameOffset = handleFrame - kf.frame;
        if (prevKf) {
          frameOffset = Math.min(0, Math.max(prevKf.frame - kf.frame, frameOffset));
        } else {
          frameOffset = Math.min(0, frameOffset);
        }
        const valueOffset = handleValue - getNumericValue(kf.value);
        const newHandle = {
          frame: frameOffset,
          value: valueOffset,
          enabled: true
        };
        store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", newHandle);
        kf.inHandle = newHandle;
        applyControlModeConstraints(kf, "in", propertyPath);
      }
      drawGraph();
    }
    function applyControlModeConstraints(kf, changedHandle, propertyPath) {
      if (!kf.controlMode || kf.controlMode === "corner") {
        return;
      }
      const layer = store.selectedLayer;
      if (!layer) return;
      if (kf.controlMode === "symmetric") {
        if (changedHandle === "in") {
          kf.outHandle.frame = -kf.inHandle.frame;
          kf.outHandle.value = -kf.inHandle.value;
          kf.outHandle.enabled = kf.inHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "out", { ...kf.outHandle });
        } else {
          kf.inHandle.frame = -kf.outHandle.frame;
          kf.inHandle.value = -kf.outHandle.value;
          kf.inHandle.enabled = kf.outHandle.enabled;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, "in", { ...kf.inHandle });
        }
      }
      if (kf.controlMode === "smooth") {
        const changed = changedHandle === "in" ? kf.inHandle : kf.outHandle;
        const other = changedHandle === "in" ? kf.outHandle : kf.inHandle;
        const otherType = changedHandle === "in" ? "out" : "in";
        if (changed.frame !== 0 || changed.value !== 0) {
          const angle = Math.atan2(changed.value, changed.frame);
          const oppositeAngle = angle + Math.PI;
          const otherLength = Math.hypot(other.frame, other.value);
          other.frame = Math.cos(oppositeAngle) * otherLength;
          other.value = Math.sin(oppositeAngle) * otherLength;
          store.setKeyframeHandle(layer.id, propertyPath, kf.id, otherType, { ...other });
        }
      }
    }
    function stopDragHandle() {
      dragTarget.value = null;
      document.removeEventListener("mousemove", onDragHandle);
      document.removeEventListener("mouseup", stopDragHandle);
    }
    function showContextMenu(event) {
      contextMenu.value = { x: event.offsetX, y: event.offsetY };
    }
    function addKeyframeAtPosition() {
      if (!contextMenu.value) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const frame = Math.round(screenXToFrame(contextMenu.value.x));
      const value = screenYToValue(contextMenu.value.y);
      if (visibleProperties.value.length > 0) {
        const prop = visibleProperties.value[0];
        const propertyPath = getPropertyPath(prop);
        const keyframeValue = typeof prop.value === "number" ? value : { x: value, y: value };
        store.addKeyframe(layer.id, propertyPath, keyframeValue, frame);
        drawGraph();
      }
      contextMenu.value = null;
    }
    function deleteSelectedKeyframes() {
      const layer = store.selectedLayer;
      if (!layer) return;
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (prop) {
          const propertyPath = getPropertyPath(prop);
          store.removeKeyframe(layer.id, propertyPath, sk.keyframe.id);
        }
      }
      selectedKeyframes.value = [];
      drawGraph();
    }
    function copyKeyframes() {
      clipboard.value = selectedKeyframes.value.map((sk) => ({ ...sk.keyframe }));
    }
    function pasteKeyframes() {
      if (!clipboard.value || visibleProperties.value.length === 0) return;
      const layer = store.selectedLayer;
      if (!layer) return;
      const prop = visibleProperties.value[0];
      const propertyPath = getPropertyPath(prop);
      const offset = store.currentFrame - clipboard.value[0].frame;
      for (const kf of clipboard.value) {
        const newFrame = kf.frame + offset;
        const newKeyframe = store.addKeyframe(layer.id, propertyPath, kf.value, newFrame);
        if (newKeyframe) {
          if (kf.interpolation !== "linear") {
            store.setKeyframeInterpolation(layer.id, propertyPath, newKeyframe.id, kf.interpolation);
          }
          if (kf.inHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "in", kf.inHandle);
          }
          if (kf.outHandle?.enabled) {
            store.setKeyframeHandle(layer.id, propertyPath, newKeyframe.id, "out", kf.outHandle);
          }
        }
      }
      drawGraph();
    }
    function selectAllKeyframes() {
      selectedKeyframes.value = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          selectedKeyframes.value.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
        }
      }
    }
    function invertSelection() {
      const newSelection = [];
      for (const prop of visibleProperties.value) {
        for (let i = 0; i < prop.keyframes.length; i++) {
          if (!isKeyframeSelected(prop.id, i)) {
            newSelection.push({ propId: prop.id, index: i, keyframe: prop.keyframes[i] });
          }
        }
      }
      selectedKeyframes.value = newSelection;
    }
    function updateSelectedKeyframeFrame(event) {
      const value = parseInt(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        selectedKeyframes.value[0].keyframe.frame = value;
        drawGraph();
      }
    }
    function updateSelectedKeyframeValue(event) {
      const value = parseFloat(event.target.value);
      if (selectedKeyframes.value.length > 0 && !isNaN(value)) {
        const kf = selectedKeyframes.value[0].keyframe;
        if (typeof kf.value === "number") {
          kf.value = value;
        } else if (typeof kf.value === "object") {
          kf.value.x = value;
        }
        drawGraph();
      }
    }
    function updateSelectedKeyframeInterpolation(event) {
      const value = event.target.value;
      if (selectedKeyframes.value.length > 0) {
        selectedKeyframes.value[0].keyframe.interpolation = value;
        drawGraph();
      }
    }
    function onTimeRulerClick(event) {
      const rect = timeRulerCanvas.value?.getBoundingClientRect();
      if (!rect) return;
      const x = event.clientX - rect.left;
      const frame = Math.round(screenXToFrame(x));
      store.setFrame(frame);
    }
    function drawGraph() {
      drawMainCanvas();
      drawTimeRuler();
      drawValueAxis();
    }
    function drawMainCanvas() {
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = canvasWidth.value;
      canvas.height = canvasHeight.value;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
      drawGrid(ctx);
      for (const prop of visibleProperties.value) {
        drawPropertyCurve(ctx, prop);
      }
    }
    function drawGrid(ctx) {
      const graphWidth = canvasWidth.value - margin.left - margin.right;
      const graphHeight = canvasHeight.value - margin.top - margin.bottom;
      ctx.strokeStyle = "#2a2a2a";
      ctx.lineWidth = 1;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, graphWidth, 50);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, graphHeight, 30);
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
      ctx.strokeStyle = "#3a3a3a";
      ctx.lineWidth = 1;
      if (viewState.frameStart <= 0 && viewState.frameEnd >= 0) {
        const x = frameToScreenX(0);
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, canvasHeight.value - margin.bottom);
        ctx.stroke();
      }
      if (viewState.valueMin <= 0 && viewState.valueMax >= 0) {
        const y = valueToScreenY(0);
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(canvasWidth.value - margin.right, y);
        ctx.stroke();
      }
    }
    function calculateGridStep(range, pixelSize, targetSpacing) {
      const rawStep = range * targetSpacing / pixelSize;
      const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
      const normalized = rawStep / magnitude;
      if (normalized <= 1) return magnitude;
      if (normalized <= 2) return 2 * magnitude;
      if (normalized <= 5) return 5 * magnitude;
      return 10 * magnitude;
    }
    function drawPropertyCurve(ctx, prop) {
      if (prop.keyframes.length < 2) return;
      const color = getPropertyColor(prop.id);
      for (let pass = 0; pass < 2; pass++) {
        if (pass === 0) {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < prop.keyframes.length - 1; i++) {
          const kf1 = prop.keyframes[i];
          const kf2 = prop.keyframes[i + 1];
          if (kf2.frame < viewState.frameStart || kf1.frame > viewState.frameEnd) continue;
          const x1 = getKeyframeScreenX(kf1);
          const y1 = getKeyframeScreenY(prop, kf1);
          const x2 = getKeyframeScreenX(kf2);
          const y2 = getKeyframeScreenY(prop, kf2);
          if (!started) {
            ctx.moveTo(x1, y1);
            started = true;
          }
          if (kf1.interpolation === "hold") {
            ctx.lineTo(x2, y1);
            ctx.lineTo(x2, y2);
          } else if (kf1.interpolation === "linear" || !kf1.outHandle.enabled && !kf2.inHandle.enabled) {
            ctx.lineTo(x2, y2);
          } else {
            const cp1x = frameToScreenX(kf1.frame + kf1.outHandle.frame);
            const cp1y = valueToScreenY(getNumericValue(kf1.value) + kf1.outHandle.value);
            const cp2x = frameToScreenX(kf2.frame + kf2.inHandle.frame);
            const cp2y = valueToScreenY(getNumericValue(kf2.value) + kf2.inHandle.value);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
          }
        }
        ctx.stroke();
      }
    }
    function drawTimeRuler() {
      const canvas = timeRulerCanvas.value;
      if (!canvas) return;
      const rect = timeRulerRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = rect.width;
      canvas.height = 24;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const frameRange = viewState.frameEnd - viewState.frameStart;
      const frameStep = calculateGridStep(frameRange, canvas.width, 60);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      const firstFrame = Math.ceil(viewState.frameStart / frameStep) * frameStep;
      for (let frame = firstFrame; frame <= viewState.frameEnd; frame += frameStep) {
        const x = frameToScreenX(frame);
        ctx.fillText(frame.toString(), x, 16);
        ctx.strokeStyle = "#444";
        ctx.beginPath();
        ctx.moveTo(x, 20);
        ctx.lineTo(x, 24);
        ctx.stroke();
      }
      const ctfX = frameToScreenX(store.currentFrame);
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.moveTo(ctfX - 5, 0);
      ctx.lineTo(ctfX + 5, 0);
      ctx.lineTo(ctfX, 8);
      ctx.closePath();
      ctx.fill();
    }
    function drawValueAxis() {
      const canvas = valueAxisCanvas.value;
      if (!canvas) return;
      const rect = valueAxisRef.value?.getBoundingClientRect();
      if (!rect) return;
      canvas.width = 40;
      canvas.height = rect.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.fillStyle = "#252525";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const valueRange = viewState.valueMax - viewState.valueMin;
      const valueStep = calculateGridStep(valueRange, canvas.height, 30);
      ctx.fillStyle = "#888";
      ctx.font = "10px system-ui";
      ctx.textAlign = "right";
      const firstValue = Math.ceil(viewState.valueMin / valueStep) * valueStep;
      for (let value = firstValue; value <= viewState.valueMax; value += valueStep) {
        const y = valueToScreenY(value);
        ctx.fillText(value.toFixed(0), 36, y + 4);
      }
    }
    function applyEasyEase(direction = "both") {
      for (const sk of selectedKeyframes.value) {
        const prop = animatableProperties.value.find((p) => p.id === sk.propId);
        if (!prop) continue;
        const kf = sk.keyframe;
        const kfIndex = sk.index;
        const prevKf = kfIndex > 0 ? prop.keyframes[kfIndex - 1] : null;
        const nextKf = kfIndex < prop.keyframes.length - 1 ? prop.keyframes[kfIndex + 1] : null;
        const inDuration = prevKf ? kf.frame - prevKf.frame : 10;
        const outDuration = nextKf ? nextKf.frame - kf.frame : 10;
        const influence = 0.3333;
        if (direction === "both" || direction === "in") {
          kf.inHandle = {
            frame: -inDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        if (direction === "both" || direction === "out") {
          kf.outHandle = {
            frame: outDuration * influence,
            value: 0,
            // 0 velocity at keyframe
            enabled: true
          };
        }
        kf.interpolation = "bezier";
        kf.controlMode = "smooth";
      }
      drawGraph();
    }
    function goToPreviousKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const prev = [...allKeyframes].reverse().find((f) => f < currentFrame);
      if (prev !== void 0) {
        store.setFrame(prev);
      }
    }
    function goToNextKeyframe() {
      const currentFrame = store.currentFrame;
      const allKeyframes = [];
      for (const prop of visibleProperties.value) {
        for (const kf of prop.keyframes) {
          if (!allKeyframes.includes(kf.frame)) {
            allKeyframes.push(kf.frame);
          }
        }
      }
      allKeyframes.sort((a, b) => a - b);
      const next = allKeyframes.find((f) => f > currentFrame);
      if (next !== void 0) {
        store.setFrame(next);
      }
    }
    function handleKeyDown(event) {
      if (event.key === "F9") {
        event.preventDefault();
        if (event.ctrlKey && event.shiftKey) {
          applyEasyEase("out");
        } else if (event.shiftKey) {
          applyEasyEase("in");
        } else {
          applyEasyEase("both");
        }
        return;
      }
      if (event.key.toLowerCase() === "j") {
        event.preventDefault();
        goToPreviousKeyframe();
        return;
      }
      if (event.key.toLowerCase() === "k") {
        event.preventDefault();
        goToNextKeyframe();
        return;
      }
      if (event.key === "Delete" || event.key === "Backspace") {
        event.preventDefault();
        deleteSelectedKeyframes();
        return;
      }
      if (event.key.toLowerCase() === "f" && !event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          fitToView();
        } else if (selectedKeyframes.value.length > 0) {
          fitSelectionToView();
        } else {
          fitToView();
        }
        return;
      }
      if (event.key === "=" || event.key === "+") {
        event.preventDefault();
        zoomIn();
        return;
      }
      if (event.key === "-" || event.key === "_") {
        event.preventDefault();
        zoomOut();
        return;
      }
    }
    function fitSelectionToView() {
      if (selectedKeyframes.value.length === 0) {
        fitToView();
        return;
      }
      let minFrame = Infinity;
      let maxFrame = -Infinity;
      let minValue = Infinity;
      let maxValue = -Infinity;
      for (const sk of selectedKeyframes.value) {
        minFrame = Math.min(minFrame, sk.keyframe.frame);
        maxFrame = Math.max(maxFrame, sk.keyframe.frame);
        const value = getNumericValue(sk.keyframe.value);
        minValue = Math.min(minValue, value);
        maxValue = Math.max(maxValue, value);
      }
      const frameMargin = (maxFrame - minFrame) * 0.1 || 10;
      const valueMargin = (maxValue - minValue) * 0.1 || 10;
      viewState.frameStart = minFrame - frameMargin;
      viewState.frameEnd = maxFrame + frameMargin;
      viewState.valueMin = minValue - valueMargin;
      viewState.valueMax = maxValue + valueMargin;
      drawGraph();
    }
    function zoomIn() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.4;
      viewState.frameEnd = centerFrame + frameRange * 0.4;
      drawGraph();
    }
    function zoomOut() {
      const centerFrame = (viewState.frameStart + viewState.frameEnd) / 2;
      const frameRange = viewState.frameEnd - viewState.frameStart;
      viewState.frameStart = centerFrame - frameRange * 0.6;
      viewState.frameEnd = centerFrame + frameRange * 0.6;
      drawGraph();
    }
    let resizeObserver = null;
    onMounted(() => {
      if (canvasContainerRef.value) {
        resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            canvasWidth.value = entry.contentRect.width;
            canvasHeight.value = entry.contentRect.height;
            drawGraph();
          }
        });
        resizeObserver.observe(canvasContainerRef.value);
      }
      visiblePropertyIds.value = animatableProperties.value.filter((p) => p.animated).map((p) => p.id);
      window.addEventListener("keydown", handleKeyDown);
      fitToView();
      drawGraph();
    });
    onUnmounted(() => {
      resizeObserver?.disconnect();
      window.removeEventListener("keydown", handleKeyDown);
    });
    watch([() => store.currentFrame, visiblePropertyIds, mode], () => {
      drawGraph();
    });
    watch(animatableProperties, () => {
      fitToView();
      drawGraph();
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createBaseVNode("div", _hoisted_2$8, [
          _cache[9] || (_cache[9] = createBaseVNode("span", { class: "graph-title" }, "Graph Editor", -1)),
          createBaseVNode("div", _hoisted_3$8, [
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "value" }),
              onClick: _cache[0] || (_cache[0] = ($event) => mode.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: mode.value === "speed" }),
              onClick: _cache[1] || (_cache[1] = ($event) => mode.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          createBaseVNode("div", _hoisted_4$8, [
            (openBlock(), createElementBlock(Fragment, null, renderList(presetList, (preset) => {
              return createBaseVNode("button", {
                key: preset.key,
                class: normalizeClass(["preset-btn", { active: isPresetActive(preset.key) }]),
                onClick: ($event) => applyPreset(preset.key),
                title: preset.label
              }, toDisplayString(preset.shortLabel), 11, _hoisted_5$8);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_6$8, [
            createBaseVNode("button", {
              onClick: fitToView,
              title: "Fit to View"
            }, [..._cache[5] || (_cache[5] = [
              createBaseVNode("span", { class: "icon" }, "[ ]", -1)
            ])]),
            createBaseVNode("button", {
              onClick: toggleAutoSelect,
              class: normalizeClass({ active: autoSelectNearby.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._cache[6] || (_cache[6] = [
              createBaseVNode("span", { class: "icon" }, "A", -1)
            ])], 2),
            createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => snapEnabled.value = !snapEnabled.value),
              class: normalizeClass({ active: snapEnabled.value }),
              title: "Snap to Grid"
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          createBaseVNode("button", {
            class: "close-btn",
            onClick: _cache[3] || (_cache[3] = ($event) => emit("close"))
          }, [..._cache[8] || (_cache[8] = [
            createBaseVNode("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        createBaseVNode("div", _hoisted_7$8, [
          createBaseVNode("div", _hoisted_8$8, [
            createBaseVNode("div", _hoisted_9$8, [
              _cache[10] || (_cache[10] = createTextVNode(" Properties ", -1)),
              createBaseVNode("button", {
                class: "toggle-all-btn",
                onClick: toggleAllProperties,
                title: allPropertiesVisible.value ? "Hide All" : "Show All"
              }, toDisplayString(allPropertiesVisible.value ? "Hide" : "Show"), 9, _hoisted_10$8)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(animatableProperties.value, (prop) => {
              return openBlock(), createElementBlock("div", {
                key: prop.id,
                class: normalizeClass(["property-item", {
                  selected: selectedPropertyIds.value.includes(prop.id),
                  animated: prop.animated
                }])
              }, [
                createBaseVNode("div", {
                  class: "property-row",
                  onClick: ($event) => toggleProperty(prop.id)
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(["visibility-toggle", { visible: visiblePropertyIds.value.includes(prop.id) }]),
                    onClick: withModifiers(($event) => togglePropertyVisibility(prop.id), ["stop"])
                  }, null, 10, _hoisted_12$7),
                  createBaseVNode("span", {
                    class: "property-color",
                    style: normalizeStyle({ background: getPropertyColor(prop.id) })
                  }, null, 4),
                  createBaseVNode("span", _hoisted_13$7, toDisplayString(prop.name), 1),
                  prop.animated ? (openBlock(), createElementBlock("span", _hoisted_14$7, toDisplayString(prop.keyframes.length), 1)) : createCommentVNode("", true)
                ], 8, _hoisted_11$8),
                prop.name === "Position" || prop.name === "Scale" ? (openBlock(), createElementBlock("div", _hoisted_15$6, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(["x", "y", "z"], (dim) => {
                    return createBaseVNode("button", {
                      key: dim,
                      class: normalizeClass({
                        active: visibleDimensions.value[prop.id]?.includes(dim),
                        hasValue: hasDimension(prop, dim)
                      }),
                      onClick: ($event) => toggleDimension(prop.id, dim)
                    }, toDisplayString(dim.toUpperCase()), 11, _hoisted_16$6);
                  }), 64))
                ])) : createCommentVNode("", true)
              ], 2);
            }), 128)),
            animatableProperties.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_17$6, " No animated properties ")) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_18$6, [
            createBaseVNode("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: timeRulerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "timeRulerCanvas",
                ref: timeRulerCanvas,
                onClick: onTimeRulerClick
              }, null, 512)
            ], 512),
            createBaseVNode("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "canvasRef",
                ref: canvasRef,
                onMousedown: handleMouseDown,
                onMousemove: handleMouseMove,
                onMouseup: handleMouseUp,
                onMouseleave: handleMouseUp,
                onWheel: handleWheel,
                onContextmenu: withModifiers(showContextMenu, ["prevent"])
              }, null, 544),
              selectionBox.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "selection-box",
                style: normalizeStyle({
                  left: selectionBox.value.x + "px",
                  top: selectionBox.value.y + "px",
                  width: selectionBox.value.width + "px",
                  height: selectionBox.value.height + "px"
                })
              }, null, 4)) : createCommentVNode("", true),
              (openBlock(), createElementBlock("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${canvasWidth.value} ${canvasHeight.value}`
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleProperties.value, (prop) => {
                  return openBlock(), createElementBlock("g", {
                    key: prop.id,
                    class: "property-handles"
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(prop.keyframes, (kf, kfIndex) => {
                      return openBlock(), createElementBlock(Fragment, { key: kfIndex }, [
                        isKeyframeInView(kf) ? (openBlock(), createElementBlock("g", {
                          key: 0,
                          class: normalizeClass(["keyframe-marker", {
                            selected: isKeyframeSelected(prop.id, kfIndex),
                            hovered: hoveredKeyframe.value?.propId === prop.id && hoveredKeyframe.value?.index === kfIndex
                          }]),
                          onMousedown: withModifiers(($event) => onKeyframeMouseDown(prop.id, kfIndex, $event), ["stop"])
                        }, [
                          createBaseVNode("rect", {
                            x: getKeyframeScreenX(kf) - 5,
                            y: getKeyframeScreenY(prop, kf) - 5,
                            width: "10",
                            height: "10",
                            fill: getPropertyColor(prop.id),
                            "transform-origin": "center",
                            transform: `rotate(45, ${getKeyframeScreenX(kf)}, ${getKeyframeScreenY(prop, kf)})`
                          }, null, 8, _hoisted_21$6)
                        ], 42, _hoisted_20$6)) : createCommentVNode("", true),
                        isKeyframeSelected(prop.id, kfIndex) && kf.interpolation !== "hold" ? (openBlock(), createElementBlock("g", _hoisted_22$6, [
                          prop.keyframes[kfIndex + 1] && (kf.outHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_23$6, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getOutHandleX(prop, kfIndex),
                              y2: getOutHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_24$4),
                            createBaseVNode("circle", {
                              cx: getOutHandleX(prop, kfIndex),
                              cy: getOutHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "outHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("outHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_25$4)
                          ])) : createCommentVNode("", true),
                          kfIndex > 0 && (kf.inHandle.enabled || kf.interpolation === "bezier") ? (openBlock(), createElementBlock("g", _hoisted_26$4, [
                            createBaseVNode("line", {
                              x1: getKeyframeScreenX(kf),
                              y1: getKeyframeScreenY(prop, kf),
                              x2: getInHandleX(prop, kfIndex),
                              y2: getInHandleY(prop, kfIndex),
                              class: "handle-line"
                            }, null, 8, _hoisted_27$4),
                            createBaseVNode("circle", {
                              cx: getInHandleX(prop, kfIndex),
                              cy: getInHandleY(prop, kfIndex),
                              r: "5",
                              class: normalizeClass(["handle-point", { dragging: dragTarget.value?.type === "inHandle" && dragTarget.value?.propId === prop.id && dragTarget.value?.index === kfIndex }]),
                              onMousedown: withModifiers(($event) => startDragHandle("inHandle", prop.id, kfIndex), ["stop"])
                            }, null, 42, _hoisted_28$4)
                          ])) : createCommentVNode("", true)
                        ])) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]);
                }), 128)),
                createBaseVNode("line", {
                  x1: currentFrameScreenX.value,
                  y1: 0,
                  x2: currentFrameScreenX.value,
                  y2: canvasHeight.value,
                  class: "current-time-line"
                }, null, 8, _hoisted_29$4)
              ], 8, _hoisted_19$6))
            ], 512),
            createBaseVNode("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: valueAxisRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "valueAxisCanvas",
                ref: valueAxisCanvas
              }, null, 512)
            ], 512)
          ])
        ]),
        selectedKeyframes.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$3, [
          createBaseVNode("div", _hoisted_31$2, [
            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "info-label" }, "Frame:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: selectedKeyframes.value[0]?.keyframe.frame,
              onChange: updateSelectedKeyframeFrame,
              class: "info-input"
            }, null, 40, _hoisted_32$2)
          ]),
          createBaseVNode("div", _hoisted_33$2, [
            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "info-label" }, "Value:", -1)),
            createBaseVNode("input", {
              type: "number",
              value: getKeyframeDisplayValue(selectedKeyframes.value[0]),
              onChange: updateSelectedKeyframeValue,
              class: "info-input",
              step: "0.1"
            }, null, 40, _hoisted_34$2)
          ]),
          createBaseVNode("div", _hoisted_35$2, [
            _cache[14] || (_cache[14] = createBaseVNode("span", { class: "info-label" }, "Interpolation:", -1)),
            createBaseVNode("select", {
              value: selectedKeyframes.value[0]?.keyframe.interpolation,
              onChange: updateSelectedKeyframeInterpolation,
              class: "info-select"
            }, [..._cache[13] || (_cache[13] = [
              createBaseVNode("option", { value: "linear" }, "Linear", -1),
              createBaseVNode("option", { value: "bezier" }, "Bezier", -1),
              createBaseVNode("option", { value: "hold" }, "Hold", -1)
            ])], 40, _hoisted_36$2)
          ])
        ])) : createCommentVNode("", true),
        contextMenu.value ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "context-menu",
          style: normalizeStyle({ left: contextMenu.value.x + "px", top: contextMenu.value.y + "px" }),
          onClick: _cache[4] || (_cache[4] = ($event) => contextMenu.value = null)
        }, [
          createBaseVNode("button", { onClick: addKeyframeAtPosition }, "Add Keyframe"),
          createBaseVNode("button", {
            onClick: deleteSelectedKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Delete Keyframe(s)", 8, _hoisted_37$2),
          _cache[15] || (_cache[15] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", {
            onClick: copyKeyframes,
            disabled: selectedKeyframes.value.length === 0
          }, "Copy", 8, _hoisted_38$2),
          createBaseVNode("button", {
            onClick: pasteKeyframes,
            disabled: !clipboard.value
          }, "Paste", 8, _hoisted_39$2),
          _cache[16] || (_cache[16] = createBaseVNode("hr", null, null, -1)),
          createBaseVNode("button", { onClick: selectAllKeyframes }, "Select All"),
          createBaseVNode("button", { onClick: invertSelection }, "Invert Selection")
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
});

const GraphEditor = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-00d965b0"]]);

class ArcLengthParameterizer {
  curve;
  totalLength;
  /**
   * @param curve - Three.js curve instance (CubicBezierCurve, CubicBezierCurve3, etc.)
   * @param arcLengthDivisions - Number of divisions for arc-length calculation (higher = more accurate)
   */
  constructor(curve, arcLengthDivisions = 200) {
    this.curve = curve;
    this.curve.updateArcLengths();
    this.totalLength = this.curve.getLength();
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(distance) {
    if (distance <= 0) return 0;
    if (distance >= this.totalLength) return 1;
    const u = distance / this.totalLength;
    return this.curve.getUtoTmapping(u, distance);
  }
  /**
   * Get point and tangent at arc length distance (2D)
   */
  getPointAtDistance(distance) {
    const u = Math.max(0, Math.min(1, distance / this.totalLength));
    const point = this.curve.getPointAt(u);
    const tangent = this.curve.getTangentAt(u);
    return {
      point: { x: point.x, y: point.y },
      tangent: { x: tangent.x, y: tangent.y },
      t: this.distanceToT(distance)
    };
  }
  /**
   * Get point and tangent at arc length distance (3D)
   */
  getPointAtDistance3D(distance) {
    const u = Math.max(0, Math.min(1, distance / this.totalLength));
    const point = this.curve.getPointAt(u);
    const tangent = this.curve.getTangentAt(u);
    return {
      point: { x: point.x, y: point.y, z: point.z || 0 },
      tangent: { x: tangent.x, y: tangent.y, z: tangent.z || 0 },
      t: this.distanceToT(distance)
    };
  }
  /**
   * Get evenly spaced points along the curve (2D)
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(count) {
    const points = [];
    for (let i = 0; i < count; i++) {
      const u = i / (count - 1);
      const distance = u * this.totalLength;
      points.push(this.getPointAtDistance(distance));
    }
    return points;
  }
  /**
   * Get evenly spaced points along the curve (3D)
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints3D(count) {
    const points = [];
    for (let i = 0; i < count; i++) {
      const u = i / (count - 1);
      const distance = u * this.totalLength;
      points.push(this.getPointAtDistance3D(distance));
    }
    return points;
  }
  /**
   * Get the underlying Three.js curve
   */
  getCurve() {
    return this.curve;
  }
}
function pathCommandsToBezier(pathCommands) {
  if (!pathCommands || pathCommands.length < 2) {
    return null;
  }
  let startPoint = null;
  for (const cmd of pathCommands) {
    const [command, ...coords] = cmd;
    if (command === "M") {
      startPoint = { x: coords[0], y: coords[1], z: coords[2] || 0 };
    } else if (command === "C" && startPoint) {
      return new CubicBezierCurve3(
        new Vector3(startPoint.x, startPoint.y, startPoint.z),
        new Vector3(coords[0], coords[1], coords[2] || 0),
        new Vector3(coords[3] || coords[2], coords[4] || coords[3], coords[5] || 0),
        new Vector3(coords[6] || coords[4], coords[7] || coords[5], coords[8] || 0)
      );
    } else if (command === "Q" && startPoint) {
      const qcp = { x: coords[0], y: coords[1], z: coords[2] || 0 };
      const end = { x: coords[3] || coords[2], y: coords[4] || coords[3], z: coords[5] || 0 };
      const cp1 = {
        x: (startPoint.x + 2 * qcp.x) / 3,
        y: (startPoint.y + 2 * qcp.y) / 3,
        z: (startPoint.z + 2 * qcp.z) / 3
      };
      const cp2 = {
        x: (2 * qcp.x + end.x) / 3,
        y: (2 * qcp.y + end.y) / 3,
        z: (2 * qcp.z + end.z) / 3
      };
      return new CubicBezierCurve3(
        new Vector3(startPoint.x, startPoint.y, startPoint.z),
        new Vector3(cp1.x, cp1.y, cp1.z),
        new Vector3(cp2.x, cp2.y, cp2.z),
        new Vector3(end.x, end.y, end.z)
      );
    }
  }
  return null;
}

class MatteExporter {
  offscreenCanvas = null;
  ctx = null;
  particleSystems = /* @__PURE__ */ new Map();
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(width, height) {
    const correctedWidth = Math.round(width / 8) * 8;
    const correctedHeight = Math.round(height / 8) * 8;
    const finalWidth = Math.max(256, correctedWidth);
    const finalHeight = Math.max(256, correctedHeight);
    const valid = width === finalWidth && height === finalHeight;
    return {
      valid,
      correctedWidth: finalWidth,
      correctedHeight: finalHeight,
      message: valid ? void 0 : `Adjusted to ${finalWidth}x${finalHeight} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(project, options, onProgress) {
    const { frameCount } = project.composition;
    const { width, height } = options;
    this.offscreenCanvas = new OffscreenCanvas(width, height);
    this.ctx = this.offscreenCanvas.getContext("2d");
    this.initializeParticleSystems(project);
    const frames = [];
    for (let frame = 0; frame < frameCount; frame++) {
      if (onProgress) {
        onProgress({
          frame,
          total: frameCount,
          percent: Math.round(frame / frameCount * 100)
        });
      }
      this.stepParticleSystemsToFrame(project, frame);
      const frameBlob = await this.generateFrame(project, frame, options);
      frames.push(frameBlob);
    }
    this.particleSystems.clear();
    if (onProgress) {
      onProgress({
        frame: frameCount,
        total: frameCount,
        percent: 100
      });
    }
    return frames;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(project, frame, options) {
    const ctx = this.ctx;
    const { width, height } = options;
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, width, height);
    if (options.matteMode === "include_all") {
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    }
    ctx.fillStyle = "#000000";
    const scaleX = width / project.composition.width;
    const scaleY = height / project.composition.height;
    const textLayers = project.layers.filter(
      (layer) => layer.type === "text" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of textLayers) {
      await this.renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY);
    }
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles" && layer.visible && frame >= layer.inPoint && frame <= layer.outPoint
    );
    for (const layer of particleLayers) {
      this.renderParticleLayerToMatte(ctx, layer, width, height);
    }
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(project, frame, options) {
    if (!this.offscreenCanvas || this.offscreenCanvas.width !== options.width || this.offscreenCanvas.height !== options.height) {
      this.offscreenCanvas = new OffscreenCanvas(options.width, options.height);
      this.ctx = this.offscreenCanvas.getContext("2d");
    }
    const blob = await this.generateFrame(project, frame, options);
    return URL.createObjectURL(blob);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(ctx, layer, project, frame, scaleX, scaleY) {
    const textData = layer.data;
    if (!textData) return;
    const fontSizeProp = layer.properties.find((p) => p.name === "fontSize");
    const fontSize = fontSizeProp ? interpolateProperty(fontSizeProp, frame) : textData.fontSize;
    const scaledFontSize = fontSize * Math.min(scaleX, scaleY);
    ctx.font = `${textData.fontWeight} ${scaledFontSize}px "${textData.fontFamily}"`;
    if (textData.pathLayerId) {
      await this.renderTextOnPathToMatte(ctx, layer, textData, project, frame, scaledFontSize, scaleX, scaleY);
    } else {
      this.renderTextBlockToMatte(ctx, layer, textData, frame, scaledFontSize, scaleX, scaleY);
    }
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(ctx, layer, textData, project, frame, fontSize, scaleX, scaleY) {
    const pathLayer = project.layers.find((l) => l.id === textData.pathLayerId);
    if (!pathLayer || pathLayer.type !== "spline") return;
    const splineData = pathLayer.data;
    if (!splineData?.controlPoints || splineData.controlPoints.length < 2) return;
    const pathCommands = this.buildPathCommands(splineData);
    if (!pathCommands || pathCommands.length < 2) return;
    const bezierCurve = pathCommandsToBezier(pathCommands);
    if (!bezierCurve) return;
    const parameterizer = new ArcLengthParameterizer(bezierCurve);
    const offsetProp = layer.properties.find((p) => p.name === "pathOffset");
    const pathOffset = offsetProp ? interpolateProperty(offsetProp, frame) : textData.pathOffset;
    const totalLength = parameterizer.totalLength;
    let currentDistance = pathOffset * totalLength;
    const padding = 4 * Math.min(scaleX, scaleY);
    for (const char of textData.text) {
      if (char === " ") {
        const spaceWidth = ctx.measureText(" ").width;
        currentDistance += spaceWidth + textData.letterSpacing;
        continue;
      }
      const charWidth = ctx.measureText(char).width;
      const clampedDistance = Math.max(0, Math.min(currentDistance, totalLength));
      const { point, tangent } = parameterizer.getPointAtDistance(clampedDistance);
      const angle = Math.atan2(tangent.y, tangent.x);
      const scaledX = point.x * scaleX;
      const scaledY = point.y * scaleY;
      ctx.save();
      ctx.translate(scaledX, scaledY);
      ctx.rotate(angle);
      ctx.fillRect(
        -padding,
        -fontSize - padding,
        charWidth + padding * 2,
        fontSize + padding * 2
      );
      ctx.restore();
      currentDistance += charWidth + textData.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(splineData) {
    const cp = splineData.controlPoints;
    if (!cp || cp.length < 2) return null;
    const pathCommands = [];
    pathCommands.push(["M", cp[0].x, cp[0].y]);
    for (let i = 0; i < cp.length - 1; i++) {
      const p1 = cp[i];
      const p2 = cp[i + 1];
      const h1 = p1.handleOut || { x: p1.x, y: p1.y };
      const h2 = p2.handleIn || { x: p2.x, y: p2.y };
      pathCommands.push([
        "C",
        h1.x,
        h1.y,
        h2.x,
        h2.y,
        p2.x,
        p2.y
      ]);
    }
    return pathCommands;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(ctx, layer, textData, frame, fontSize, scaleX, scaleY) {
    const positionProp = layer.transform.position;
    const position = interpolateProperty(positionProp, frame);
    const rotationProp = layer.transform.rotation;
    const rotation = interpolateProperty(rotationProp, frame);
    const scaleProp = layer.transform.scale;
    const scale = interpolateProperty(scaleProp, frame);
    ctx.save();
    ctx.translate(position.x * scaleX, position.y * scaleY);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scale.x, scale.y);
    const metrics = ctx.measureText(textData.text);
    const textWidth = metrics.width;
    const textHeight = fontSize;
    const padding = 4;
    ctx.fillRect(
      -padding,
      -textHeight - padding,
      textWidth + padding * 2,
      textHeight + padding * 2
    );
    ctx.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(frames, filename = "matte_sequence", onProgress) {
    const JSZip = (await import('./weyl-export-vendor.js').then(n => n.j)).default;
    const zip = new JSZip();
    frames.forEach((blob, index) => {
      const frameName = `${filename}_${String(index).padStart(4, "0")}.png`;
      zip.file(frameName, blob);
    });
    const content = await zip.generateAsync(
      { type: "blob" },
      (metadata) => {
        if (onProgress) {
          onProgress(Math.round(metadata.percent));
        }
      }
    );
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${filename}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(project) {
    this.particleSystems.clear();
    const particleLayers = project.layers.filter(
      (layer) => layer.type === "particles"
    );
    for (const layer of particleLayers) {
      const data = layer.data;
      if (!data) continue;
      const system = new ParticleSystem(data.systemConfig);
      for (const emitter of data.emitters) {
        system.addEmitter(emitter);
      }
      for (const well of data.gravityWells) {
        system.addGravityWell(well);
      }
      for (const vortex of data.vortices) {
        system.addVortex(vortex);
      }
      for (const mod of data.modulations) {
        system.addModulation(mod);
      }
      const warmupFrames = data.systemConfig.warmupPeriod || 0;
      for (let i = 0; i < warmupFrames; i++) {
        system.step();
      }
      this.particleSystems.set(layer.id, system);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(project, frame) {
    if (frame === 0) return;
    for (const layer of project.layers) {
      if (layer.type !== "particles") continue;
      const system = this.particleSystems.get(layer.id);
      if (!system) continue;
      if (layer.visible && frame >= layer.inPoint && frame <= layer.outPoint) {
        system.step();
      }
    }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(ctx, layer, width, height) {
    const system = this.particleSystems.get(layer.id);
    if (!system) return;
    const maskData = system.renderToMask(width, height);
    const tempCanvas = new OffscreenCanvas(width, height);
    const tempCtx = tempCanvas.getContext("2d");
    tempCtx.putImageData(maskData, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null;
    this.ctx = null;
    this.particleSystems.clear();
  }
}
const matteExporter = new MatteExporter();

const _hoisted_1$7 = { class: "export-dialog" };
const _hoisted_2$7 = { class: "dialog-header" };
const _hoisted_3$7 = { class: "dialog-content" };
const _hoisted_4$7 = { class: "form-group" };
const _hoisted_5$7 = { class: "resolution-presets" };
const _hoisted_6$7 = ["onClick"];
const _hoisted_7$7 = { class: "custom-resolution" };
const _hoisted_8$7 = { class: "dimension-input" };
const _hoisted_9$7 = { class: "dimension-input" };
const _hoisted_10$7 = {
  key: 0,
  class: "dimension-warning"
};
const _hoisted_11$7 = { class: "form-group" };
const _hoisted_12$6 = { class: "matte-mode-options" };
const _hoisted_13$6 = { class: "form-group" };
const _hoisted_14$6 = { class: "preview-container" };
const _hoisted_15$5 = ["src"];
const _hoisted_16$5 = {
  key: 1,
  class: "preview-placeholder"
};
const _hoisted_17$5 = {
  key: 0,
  class: "progress-section"
};
const _hoisted_18$5 = { class: "progress-bar" };
const _hoisted_19$5 = { class: "progress-text" };
const _hoisted_20$5 = { class: "dialog-footer" };
const _hoisted_21$5 = { class: "export-info" };
const _hoisted_22$5 = ["disabled"];
const _hoisted_23$5 = ["disabled"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const resolutionPresets = matteExporter.getResolutionPresets();
    const selectedPreset = ref("720p (1280x720)");
    const customWidth = ref(1280);
    const customHeight = ref(720);
    const dimensionWarning = ref();
    const matteMode = ref("exclude_text");
    const previewUrl = ref(null);
    const isExporting = ref(false);
    const exportProgress = ref(0);
    const progressMessage = ref("");
    const exportWidth = computed(() => customWidth.value);
    const exportHeight = computed(() => customHeight.value);
    function selectPreset(preset) {
      selectedPreset.value = preset.label;
      customWidth.value = preset.width;
      customHeight.value = preset.height;
      dimensionWarning.value = void 0;
    }
    function validateCustomDimensions() {
      const validation = matteExporter.validateDimensions(customWidth.value, customHeight.value);
      if (!validation.valid) {
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        dimensionWarning.value = validation.message;
        selectedPreset.value = "";
      } else {
        dimensionWarning.value = void 0;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
      }
    }
    async function generatePreview() {
      if (!store.hasProject) return;
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
        previewUrl.value = null;
      }
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      previewUrl.value = await matteExporter.generatePreviewFrame(
        store.project,
        0,
        options
      );
    }
    async function startExport() {
      if (isExporting.value || !store.hasProject) return;
      isExporting.value = true;
      exportProgress.value = 0;
      progressMessage.value = "Generating frames...";
      const options = {
        width: exportWidth.value,
        height: exportHeight.value,
        matteMode: matteMode.value
      };
      try {
        const frames = await matteExporter.generateMatteSequence(
          store.project,
          options,
          (progress) => {
            exportProgress.value = progress.percent;
            progressMessage.value = `Generating frame ${progress.frame + 1} of ${progress.total}...`;
          }
        );
        progressMessage.value = "Creating ZIP archive...";
        await matteExporter.downloadAsZip(
          frames,
          `matte_${Date.now()}`,
          (percent) => {
            progressMessage.value = `Compressing... ${percent}%`;
          }
        );
        progressMessage.value = "Export complete!";
        emit("exported");
        setTimeout(() => {
          emit("close");
        }, 1e3);
      } catch (err) {
        console.error("[ExportDialog] Export failed:", err);
        progressMessage.value = `Export failed: ${err instanceof Error ? err.message : "Unknown error"}`;
      } finally {
        isExporting.value = false;
      }
    }
    watch(
      [exportWidth, exportHeight, matteMode],
      () => {
        generatePreview();
      },
      { immediate: false }
    );
    onMounted(() => {
      if (store.hasProject) {
        const validation = matteExporter.validateDimensions(store.width, store.height);
        customWidth.value = validation.correctedWidth;
        customHeight.value = validation.correctedHeight;
        const matchingPreset = resolutionPresets.find(
          (p) => p.width === customWidth.value && p.height === customHeight.value
        );
        selectedPreset.value = matchingPreset?.label || "";
        if (!validation.valid) {
          dimensionWarning.value = validation.message;
        }
      }
      generatePreview();
    });
    onUnmounted(() => {
      if (previewUrl.value) {
        URL.revokeObjectURL(previewUrl.value);
      }
      matteExporter.dispose();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: _cache[6] || (_cache[6] = withModifiers(($event) => emit("close"), ["self"]))
      }, [
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("div", _hoisted_2$7, [
            _cache[8] || (_cache[8] = createBaseVNode("h3", null, "Export Matte Sequence", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: _cache[0] || (_cache[0] = ($event) => emit("close"))
            }, [..._cache[7] || (_cache[7] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_3$7, [
            createBaseVNode("div", _hoisted_4$7, [
              _cache[13] || (_cache[13] = createBaseVNode("label", null, "Resolution", -1)),
              createBaseVNode("div", _hoisted_5$7, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(resolutionPresets), (preset) => {
                  return openBlock(), createElementBlock("button", {
                    key: preset.label,
                    class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.label }]),
                    onClick: ($event) => selectPreset(preset)
                  }, toDisplayString(preset.label), 11, _hoisted_6$7);
                }), 128))
              ]),
              createBaseVNode("div", _hoisted_7$7, [
                createBaseVNode("div", _hoisted_8$7, [
                  _cache[9] || (_cache[9] = createBaseVNode("label", null, "Width", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => customWidth.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customWidth.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ]),
                _cache[11] || (_cache[11] = createBaseVNode("span", { class: "dimension-x" }, "", -1)),
                createBaseVNode("div", _hoisted_9$7, [
                  _cache[10] || (_cache[10] = createBaseVNode("label", null, "Height", -1)),
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => customHeight.value = $event),
                    type: "number",
                    min: "256",
                    step: "8",
                    onChange: validateCustomDimensions
                  }, null, 544), [
                    [
                      vModelText,
                      customHeight.value,
                      void 0,
                      { number: true }
                    ]
                  ])
                ])
              ]),
              dimensionWarning.value ? (openBlock(), createElementBlock("p", _hoisted_10$7, [
                _cache[12] || (_cache[12] = createBaseVNode("i", { class: "pi pi-info-circle" }, null, -1)),
                createTextVNode(" " + toDisplayString(dimensionWarning.value), 1)
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_11$7, [
              _cache[16] || (_cache[16] = createBaseVNode("label", null, "Matte Mode", -1)),
              createBaseVNode("div", _hoisted_12$6, [
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "exclude_text" }]),
                  onClick: _cache[3] || (_cache[3] = ($event) => matteMode.value = "exclude_text")
                }, [..._cache[14] || (_cache[14] = [
                  createBaseVNode("i", { class: "pi pi-ban" }, null, -1),
                  createBaseVNode("span", null, "Exclude Text", -1),
                  createBaseVNode("small", null, "Text regions are BLACK (excluded from generation)", -1)
                ])], 2),
                createBaseVNode("button", {
                  class: normalizeClass(["mode-btn", { active: matteMode.value === "include_all" }]),
                  onClick: _cache[4] || (_cache[4] = ($event) => matteMode.value = "include_all")
                }, [..._cache[15] || (_cache[15] = [
                  createBaseVNode("i", { class: "pi pi-check-circle" }, null, -1),
                  createBaseVNode("span", null, "Include All", -1),
                  createBaseVNode("small", null, "Entire frame is WHITE (generate everything)", -1)
                ])], 2)
              ])
            ]),
            createBaseVNode("div", _hoisted_13$6, [
              _cache[18] || (_cache[18] = createBaseVNode("label", null, "Preview (Frame 0)", -1)),
              createBaseVNode("div", _hoisted_14$6, [
                previewUrl.value ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: previewUrl.value,
                  alt: "Matte preview",
                  class: "preview-image"
                }, null, 8, _hoisted_15$5)) : (openBlock(), createElementBlock("div", _hoisted_16$5, [..._cache[17] || (_cache[17] = [
                  createBaseVNode("i", { class: "pi pi-image" }, null, -1),
                  createBaseVNode("span", null, "Generating preview...", -1)
                ])]))
              ]),
              _cache[19] || (_cache[19] = createBaseVNode("p", { class: "preview-info" }, [
                createTextVNode(" White = Keep original / generate content"),
                createBaseVNode("br"),
                createTextVNode(" Black = Exclude from generation ")
              ], -1))
            ]),
            isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_17$5, [
              createBaseVNode("div", _hoisted_18$5, [
                createBaseVNode("div", {
                  class: "progress-fill",
                  style: normalizeStyle({ width: `${exportProgress.value}%` })
                }, null, 4)
              ]),
              createBaseVNode("p", _hoisted_19$5, toDisplayString(progressMessage.value), 1)
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_20$5, [
            createBaseVNode("div", _hoisted_21$5, [
              createBaseVNode("span", null, toDisplayString(unref(store).frameCount) + " frames @ " + toDisplayString(exportWidth.value) + "" + toDisplayString(exportHeight.value), 1)
            ]),
            createBaseVNode("button", {
              class: "cancel-btn",
              onClick: _cache[5] || (_cache[5] = ($event) => emit("close")),
              disabled: isExporting.value
            }, " Cancel ", 8, _hoisted_22$5),
            createBaseVNode("button", {
              class: "export-btn",
              onClick: startExport,
              disabled: isExporting.value || !unref(store).hasProject
            }, [
              _cache[20] || (_cache[20] = createBaseVNode("i", { class: "pi pi-download" }, null, -1)),
              createTextVNode(" " + toDisplayString(isExporting.value ? "Exporting..." : "Export ZIP"), 1)
            ], 8, _hoisted_23$5)
          ])
        ])
      ]);
    };
  }
});

const ExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-5e0349d2"]]);

const EXPORT_PRESETS = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: false,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "motionctrl": {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 3
  },
  "cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: true,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: true,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ati": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  },
  "ttm": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-wan": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 30,
    cfgScale: 5
  },
  "ttm-cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: true,
    steps: 50,
    cfgScale: 6
  },
  "ttm-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 8,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: false,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 25,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: false,
    exportControlImages: false,
    exportCameraData: true,
    exportReferenceFrame: true,
    exportLastFrame: false,
    steps: 30,
    cfgScale: 5
  }
};
const DEPTH_FORMAT_SPECS = {
  "midas": {
    format: "midas",
    bitDepth: 8,
    invert: true,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "zoe": {
    format: "zoe",
    bitDepth: 16,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: false,
    normalize: false,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  "normalized": {
    format: "normalized",
    bitDepth: 8,
    invert: false,
    normalize: true,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
};
const RESOLUTION_PRESETS = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
];
const FRAME_COUNT_PRESETS = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
];
const EXPORT_TARGET_INFO = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  "motionctrl": {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  "cogvideox": {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  "ati": {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  "ttm": {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "ttm-wan": {
    name: "TTM (Wan 2.1 Backend)",
    description: "Time-to-Move with Wan 2.1 model for high-quality generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControl", "TTM_TrajectoryFromPoints", "WanImageToVideo"]
  },
  "ttm-cogvideox": {
    name: "TTM (CogVideoX Backend)",
    description: "Time-to-Move with CogVideoX model for longer sequences",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlCogVideo", "TTM_TrajectoryFromPoints", "CogVideoImageToVideo"]
  },
  "ttm-svd": {
    name: "TTM (SVD Backend)",
    description: "Time-to-Move with Stable Video Diffusion for fast generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlSVD", "TTM_TrajectoryFromPoints", "SVDEncode"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};

function renderDepthFrame(options) {
  const { width, height, nearClip, farClip, camera, layers, frame } = options;
  const depthBuffer = new Float32Array(width * height);
  depthBuffer.fill(farClip);
  let minDepth = farClip;
  let maxDepth = nearClip;
  const sortedLayers = [...layers].filter((l) => l.visible).sort((a, b) => {
    const aZ = getLayerDepth(a, frame);
    const bZ = getLayerDepth(b, frame);
    return aZ - bZ;
  });
  for (const layer of sortedLayers) {
    const layerDepth = getLayerDepth(layer, frame);
    const layerOpacity = getLayerOpacity(layer, frame);
    if (layerOpacity < 0.01) continue;
    const bounds = getLayerScreenBounds(layer, frame, camera, width, height);
    if (!bounds) continue;
    const cameraZ = camera.position.z;
    const relativeDepth = Math.abs(layerDepth - cameraZ);
    const clampedDepth = Math.max(nearClip, Math.min(farClip, relativeDepth));
    minDepth = Math.min(minDepth, clampedDepth);
    maxDepth = Math.max(maxDepth, clampedDepth);
    if (layer.type === "depthflow" && hasDepthData(layer)) {
      fillDepthFromDepthflow(depthBuffer, layer, bounds, width, height, nearClip, farClip);
    } else {
      fillUniformDepth(depthBuffer, bounds, clampedDepth, layerOpacity, width, height);
    }
  }
  return {
    depthBuffer,
    width,
    height,
    minDepth,
    maxDepth
  };
}
function getLayerDepth(layer, frame) {
  const position = layer.transform?.position;
  if (!position) return 0;
  if (position.keyframes && position.keyframes.length > 0) {
    return interpolateValue(position.keyframes, frame, 2) || 0;
  }
  if (position.value) {
    const value = position.value;
    if (typeof value === "object" && "z" in value) {
      return value.z ?? 0;
    }
  }
  return 0;
}
function getLayerOpacity(layer, frame) {
  if (layer.opacity && "keyframes" in layer.opacity && layer.opacity.keyframes?.length > 0) {
    return (interpolateValue(layer.opacity.keyframes, frame) || 100) / 100;
  }
  if (layer.opacity && "value" in layer.opacity) {
    return (layer.opacity.value || 100) / 100;
  }
  return 1;
}
function getLayerScreenBounds(layer, frame, camera, screenWidth, screenHeight) {
  let x = 0, y = 0;
  const position = layer.transform?.position;
  if (position && "value" in position) {
    const value = position.value;
    if (Array.isArray(value)) {
      x = value[0] || 0;
      y = value[1] || 0;
    }
  }
  const layerWidth = layer.width || screenWidth;
  const layerHeight = layer.height || screenHeight;
  let scaleX = 1, scaleY = 1;
  const scale = layer.transform?.scale;
  if (scale && "value" in scale) {
    const value = scale.value;
    if (Array.isArray(value)) {
      scaleX = (value[0] || 100) / 100;
      scaleY = (value[1] || 100) / 100;
    }
  }
  const finalWidth = layerWidth * scaleX;
  const finalHeight = layerHeight * scaleY;
  let anchorX = 0.5, anchorY = 0.5;
  const anchorPoint = layer.transform?.anchorPoint;
  if (anchorPoint && "value" in anchorPoint) {
    const value = anchorPoint.value;
    if (Array.isArray(value)) {
      anchorX = (value[0] || 0) / layerWidth + 0.5;
      anchorY = (value[1] || 0) / layerHeight + 0.5;
    }
  }
  const screenX = x - finalWidth * anchorX + screenWidth / 2;
  const screenY = y - finalHeight * anchorY + screenHeight / 2;
  const clippedX = Math.max(0, Math.min(screenWidth, screenX));
  const clippedY = Math.max(0, Math.min(screenHeight, screenY));
  const clippedWidth = Math.max(0, Math.min(screenWidth - clippedX, finalWidth - (clippedX - screenX)));
  const clippedHeight = Math.max(0, Math.min(screenHeight - clippedY, finalHeight - (clippedY - screenY)));
  if (clippedWidth <= 0 || clippedHeight <= 0) return null;
  return {
    x: clippedX,
    y: clippedY,
    width: clippedWidth,
    height: clippedHeight
  };
}
function hasDepthData(layer) {
  return layer.type === "depthflow" && !!layer.depthMapData;
}
function fillDepthFromDepthflow(depthBuffer, layer, bounds, screenWidth, screenHeight, nearClip, farClip) {
  const depthData = layer.depthMapData;
  const depthWidth = layer.depthWidth || bounds.width;
  const depthHeight = layer.depthHeight || bounds.height;
  for (let y = 0; y < bounds.height; y++) {
    for (let x = 0; x < bounds.width; x++) {
      const screenX = Math.floor(bounds.x + x);
      const screenY = Math.floor(bounds.y + y);
      if (screenX < 0 || screenX >= screenWidth || screenY < 0 || screenY >= screenHeight) continue;
      const sampleX = Math.floor(x / bounds.width * depthWidth);
      const sampleY = Math.floor(y / bounds.height * depthHeight);
      const sampleIdx = sampleY * depthWidth + sampleX;
      let depthValue;
      if (depthData instanceof Float32Array) {
        depthValue = depthData[sampleIdx];
      } else {
        depthValue = depthData[sampleIdx] / 255;
      }
      const worldDepth = nearClip + depthValue * (farClip - nearClip);
      const bufferIdx = screenY * screenWidth + screenX;
      if (worldDepth < depthBuffer[bufferIdx]) {
        depthBuffer[bufferIdx] = worldDepth;
      }
    }
  }
}
function fillUniformDepth(depthBuffer, bounds, depth, opacity, screenWidth, screenHeight) {
  const startX = Math.floor(bounds.x);
  const startY = Math.floor(bounds.y);
  const endX = Math.min(screenWidth, Math.ceil(bounds.x + bounds.width));
  const endY = Math.min(screenHeight, Math.ceil(bounds.y + bounds.height));
  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      const idx = y * screenWidth + x;
      if (opacity > 0.5 && depth < depthBuffer[idx]) {
        depthBuffer[idx] = depth;
      }
    }
  }
}
function interpolateValue(keyframes, frame, index) {
  if (!keyframes || keyframes.length === 0) return null;
  let prev = keyframes[0];
  let next = keyframes[keyframes.length - 1];
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i].frame <= frame) {
      prev = keyframes[i];
    }
    if (keyframes[i].frame >= frame && i < keyframes.length) {
      next = keyframes[i];
      break;
    }
  }
  if (prev.frame === next.frame) {
    const value = prev.value;
    return index !== void 0 && Array.isArray(value) ? value[index] : value;
  }
  const t = (frame - prev.frame) / (next.frame - prev.frame);
  const prevValue = index !== void 0 && Array.isArray(prev.value) ? prev.value[index] : prev.value;
  const nextValue = index !== void 0 && Array.isArray(next.value) ? next.value[index] : next.value;
  return prevValue + (nextValue - prevValue) * t;
}
function convertDepthToFormat(result, format) {
  const spec = DEPTH_FORMAT_SPECS[format];
  const { depthBuffer, width, height, minDepth, maxDepth } = result;
  const pixelCount = width * height;
  if (spec.bitDepth === 16) {
    const output = new Uint16Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized;
      if (spec.normalize) {
        normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      } else {
        normalized = depthBuffer[i] / spec.farClip;
      }
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(65535, Math.round(normalized * 65535)));
    }
    return output;
  } else {
    const output = new Uint8Array(pixelCount);
    for (let i = 0; i < pixelCount; i++) {
      let normalized = (depthBuffer[i] - minDepth) / (maxDepth - minDepth);
      if (spec.invert) {
        normalized = 1 - normalized;
      }
      output[i] = Math.max(0, Math.min(255, Math.round(normalized * 255)));
    }
    return output;
  }
}
function depthToImageData(depthData, width, height) {
  const imageData = new ImageData(width, height);
  const is16bit = depthData instanceof Uint16Array;
  for (let i = 0; i < width * height; i++) {
    const value = is16bit ? Math.floor(depthData[i] / 256) : depthData[i];
    const pixelIdx = i * 4;
    imageData.data[pixelIdx] = value;
    imageData.data[pixelIdx + 1] = value;
    imageData.data[pixelIdx + 2] = value;
    imageData.data[pixelIdx + 3] = 255;
  }
  return imageData;
}

let nodeIdCounter = 1;
function resetNodeIds() {
  nodeIdCounter = 1;
}
function nextNodeId() {
  return String(nodeIdCounter++);
}
function createNode(classType, inputs, title) {
  const node = {
    class_type: classType,
    inputs
  };
  if (title) {
    node._meta = { title };
  }
  return node;
}
function conn(nodeId, outputIndex = 0) {
  return [nodeId, outputIndex];
}
function addCheckpointLoader(workflow, checkpoint) {
  const id = nextNodeId();
  workflow[id] = createNode("CheckpointLoaderSimple", {
    ckpt_name: checkpoint
  }, "Load Checkpoint");
  return id;
}
function addCLIPTextEncode(workflow, clipConnection, text, title) {
  const id = nextNodeId();
  workflow[id] = createNode("CLIPTextEncode", {
    clip: clipConnection,
    text
  }, title);
  return id;
}
function addLoadImage(workflow, imageName, title) {
  const id = nextNodeId();
  workflow[id] = createNode("LoadImage", {
    image: imageName
  }, title || "Load Image");
  return id;
}
function addImageResize(workflow, imageConnection, width, height) {
  const id = nextNodeId();
  workflow[id] = createNode("ImageResize", {
    image: imageConnection,
    width,
    height,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image");
  return id;
}
function addVAEEncode(workflow, imageConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEEncode", {
    pixels: imageConnection,
    vae: vaeConnection
  }, "VAE Encode");
  return id;
}
function addVAEDecode(workflow, samplesConnection, vaeConnection) {
  const id = nextNodeId();
  workflow[id] = createNode("VAEDecode", {
    samples: samplesConnection,
    vae: vaeConnection
  }, "VAE Decode");
  return id;
}
function addKSampler(workflow, modelConnection, positiveConnection, negativeConnection, latentConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("KSampler", {
    model: modelConnection,
    positive: positiveConnection,
    negative: negativeConnection,
    latent_image: latentConnection,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    steps: params.steps ?? 20,
    cfg: params.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: params.denoise ?? 1
  }, "KSampler");
  return id;
}
function addVideoOutput(workflow, imagesConnection, params) {
  const id = nextNodeId();
  workflow[id] = createNode("VHS_VideoCombine", {
    images: imagesConnection,
    frame_rate: params.fps,
    loop_count: 0,
    filename_prefix: params.filename || "weyl_output",
    format: params.format || "video/h264-mp4",
    pingpong: false,
    save_output: true,
    audio: null,
    meta_batch: null
  }, "Video Output");
  return id;
}
function generateWan22I2VWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const isHD = params.width > 640 || params.height > 640;
  const wanModel = params.wanModel || (isHD ? "i2v_720p" : "i2v_480p");
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${wanModel}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanImageToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: params.denoise || 1
  }, "I2V Generation");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_i2v"
  });
  return workflow;
}
function generateWan22FunCameraWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("WanFunCameraMotion", {
    motion_type: params.cameraMotion || "Static",
    length: params.frameCount
  }, "Camera Motion");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFunCameraI2V", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    image: conn(resizeId),
    camera_motion: conn(cameraCtrlId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_fun_camera"
  });
  return workflow;
}
function generateWan22FirstLastWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const wanLoaderId = nextNodeId();
  workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const vaeLoaderId = nextNodeId();
  workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const clipLoaderId = nextNodeId();
  workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const firstImageId = addLoadImage(workflow, params.referenceImage || "first.png", "First Frame");
  const lastImageId = addLoadImage(workflow, params.lastFrameImage || "last.png", "Last Frame");
  const resizeFirstId = addImageResize(workflow, conn(firstImageId), params.width, params.height);
  const resizeLastId = addImageResize(workflow, conn(lastImageId), params.width, params.height);
  const positiveId = nextNodeId();
  workflow[positiveId] = createNode("WanTextEncode", {
    text_encoder: conn(clipLoaderId),
    prompt: params.prompt,
    force_offload: true
  }, "Positive Prompt");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("WanFirstLastFrameToVideo", {
    wan_model: conn(wanLoaderId),
    positive: conn(positiveId),
    first_frame: conn(resizeFirstId),
    last_frame: conn(resizeLastId),
    vae: conn(vaeLoaderId),
    width: params.width,
    height: params.height,
    length: params.frameCount,
    steps: params.steps || 30,
    cfg: params.cfgScale || 5,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("WanVAEDecode", {
    vae: conn(vaeLoaderId),
    samples: conn(latentId),
    enable_vae_tiling: true
  }, "VAE Decode");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "wan22_flf"
  });
  return workflow;
}
function generateUni3CWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const uni3cLoaderId = nextNodeId();
  workflow[uni3cLoaderId] = createNode("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const trajId = nextNodeId();
  if (params.trajType === "custom" && params.cameraData?.trajectory) {
    workflow[trajId] = createNode("Uni3CCustomTrajectory", {
      trajectory_data: JSON.stringify(params.cameraData.trajectory),
      length: params.frameCount
    }, "Custom Trajectory");
  } else {
    workflow[trajId] = createNode("Uni3CPresetTrajectory", {
      traj_type: params.trajType || "orbit",
      length: params.frameCount
    }, "Preset Trajectory");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyUni3CCameraControl", {
    model: conn(baseModelId),
    uni3c: conn(uni3cLoaderId),
    trajectory: conn(trajId),
    image: conn(resizeId),
    control_strength: 1
  }, "Apply Camera Control");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "uni3c_output"
  });
  return workflow;
}
function generateMotionCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const motionCtrlId = nextNodeId();
  workflow[motionCtrlId] = createNode("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const baseModelId = nextNodeId();
  workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
    ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("MotionCtrlCameraPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("MotionCtrlPresetPoses", {
      preset: params.motionPreset || "static",
      length: params.frameCount
    }, "Preset Poses");
  }
  const controlId = nextNodeId();
  workflow[controlId] = createNode("ApplyMotionCtrl", {
    model: conn(baseModelId),
    motion_ctrl: conn(motionCtrlId),
    camera_poses: conn(posesId),
    control_strength: 1
  }, "Apply MotionCtrl");
  const encodeId = nextNodeId();
  workflow[encodeId] = createNode("SVDEncode", {
    model: conn(controlId),
    image: conn(resizeId),
    vae: conn(baseModelId, 2),
    width: params.width,
    height: params.height,
    video_frames: params.frameCount,
    motion_bucket_id: 127,
    fps: params.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const sampleId = addKSampler(
    workflow,
    conn(controlId),
    conn(encodeId, 1),
    conn(encodeId, 2),
    conn(encodeId),
    { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "motionctrl_output"
  });
  return workflow;
}
function generateControlNetDepthWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "sd_xl_base_1.0.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const depthLoaderId = nextNodeId();
  workflow[depthLoaderId] = createNode("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const refImageId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeRefId = addImageResize(workflow, conn(refImageId), params.width, params.height);
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(depthLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const encodeRefId = addVAEEncode(workflow, conn(resizeRefId), conn(checkpointId, 2));
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(encodeRefId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7, denoise: params.denoise || 0.75 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "controlnet_depth"
  });
  return workflow;
}
function generateAnimateDiffCameraCtrlWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "dreamshaper_8.safetensors");
  const animateDiffId = nextNodeId();
  workflow[animateDiffId] = createNode("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const cameraCtrlId = nextNodeId();
  workflow[cameraCtrlId] = createNode("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const posesId = nextNodeId();
  if (params.cameraPoses) {
    workflow[posesId] = createNode("ADE_CameraCtrlPoses", {
      poses: JSON.stringify(params.cameraPoses)
    }, "Camera Poses");
  } else {
    workflow[posesId] = createNode("ADE_CameraCtrlPreset", {
      motion_type: params.cameraMotion || "Static",
      speed: 1,
      frame_length: params.frameCount
    }, "Camera Preset");
  }
  const applyADId = nextNodeId();
  workflow[applyADId] = createNode("ADE_ApplyAnimateDiffModel", {
    model: conn(checkpointId),
    motion_model: conn(animateDiffId)
  }, "Apply AnimateDiff");
  const applyCamId = nextNodeId();
  workflow[applyCamId] = createNode("ADE_ApplyCameraCtrl", {
    model: conn(applyADId),
    cameractrl: conn(cameraCtrlId),
    poses: conn(posesId)
  }, "Apply CameraCtrl");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(applyCamId),
    conn(positiveId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "animatediff_cameractrl"
  });
  return workflow;
}
function generateCogVideoXWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const cogVideoId = nextNodeId();
  workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const t5Id = nextNodeId();
  workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const vaeId = nextNodeId();
  workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "input.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const encodePromptId = nextNodeId();
  workflow[encodePromptId] = createNode("CogVideoTextEncode", {
    text_encoder: conn(t5Id),
    prompt: params.prompt,
    force_offload: true
  }, "Encode Prompt");
  const generateId = nextNodeId();
  workflow[generateId] = createNode("CogVideoImageToVideo", {
    model: conn(cogVideoId),
    positive: conn(encodePromptId),
    image: conn(resizeId),
    vae: conn(vaeId),
    width: params.width,
    height: params.height,
    num_frames: params.frameCount,
    steps: params.steps || 50,
    cfg: params.cfgScale || 6,
    seed: params.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const decodeId = nextNodeId();
  workflow[decodeId] = createNode("CogVideoDecode", {
    vae: conn(vaeId),
    samples: conn(generateId),
    enable_vae_tiling: true
  }, "Decode Video");
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || "cogvideox_output"
  });
  return workflow;
}
function generateTTMWorkflow(params) {
  resetNodeIds();
  const workflow = {};
  const ttmModel = params.ttmModel || "wan";
  const layers = params.ttmLayers || [];
  const imageLoaderId = addLoadImage(workflow, params.referenceImage || "reference.png", "Reference Image");
  const resizeId = addImageResize(workflow, conn(imageLoaderId), params.width, params.height);
  const combinedMaskId = nextNodeId();
  workflow[combinedMaskId] = createNode("LoadImage", {
    image: params.ttmCombinedMask || "combined_motion_mask.png"
  }, "Combined Motion Mask");
  const layerMaskIds = [];
  const trajectoryIds = [];
  for (let i = 0; i < layers.length; i++) {
    const layer = layers[i];
    const maskId = nextNodeId();
    workflow[maskId] = createNode("LoadImage", {
      image: layer.motionMask
    }, `Layer ${i + 1} Mask: ${layer.layerName}`);
    layerMaskIds.push(maskId);
    const trajId = nextNodeId();
    workflow[trajId] = createNode("TTM_TrajectoryFromPoints", {
      points: JSON.stringify(layer.trajectory.map((t) => [t.x, t.y])),
      frames: JSON.stringify(layer.trajectory.map((t) => t.frame)),
      total_frames: params.frameCount,
      interpolation: "linear"
    }, `Trajectory: ${layer.layerName}`);
    trajectoryIds.push(trajId);
  }
  let combinedLayerDataId = null;
  if (layers.length > 0) {
    combinedLayerDataId = nextNodeId();
    workflow[combinedLayerDataId] = createNode("TTM_CombineLayers", {
      masks: layerMaskIds.map((id) => conn(id)),
      trajectories: trajectoryIds.map((id) => conn(id)),
      blend_mode: "additive"
    }, "Combine Layer Data");
  }
  if (ttmModel === "wan") {
    const wanLoaderId = nextNodeId();
    workflow[wanLoaderId] = createNode("DownloadAndLoadWan2_1Model", {
      model: "wan2.1_i2v_480p_bf16.safetensors",
      base_precision: "bf16",
      quantization: "disabled"
    }, "Load Wan Model");
    const vaeLoaderId = nextNodeId();
    workflow[vaeLoaderId] = createNode("DownloadAndLoadWanVAE", {
      vae: "wan_2.1_vae.safetensors",
      precision: "bf16"
    }, "Load Wan VAE");
    const clipLoaderId = nextNodeId();
    workflow[clipLoaderId] = createNode("DownloadAndLoadWanTextEncoder", {
      text_encoder: "umt5-xxl-enc-bf16.safetensors",
      precision: "bf16"
    }, "Load Text Encoder");
    const positiveId = nextNodeId();
    workflow[positiveId] = createNode("WanTextEncode", {
      text_encoder: conn(clipLoaderId),
      prompt: params.prompt,
      force_offload: true
    }, "Positive Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControl", {
      wan_model: conn(wanLoaderId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const latentId = nextNodeId();
    workflow[latentId] = createNode("WanImageToVideo", {
      wan_model: conn(ttmControlId),
      positive: conn(positiveId),
      image: conn(resizeId),
      vae: conn(vaeLoaderId),
      width: params.width,
      height: params.height,
      length: params.frameCount,
      steps: params.steps || 30,
      cfg: params.cfgScale || 5,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "DPM++ 2M SDE",
      denoise_strength: params.denoise || 1
    }, "TTM I2V Generation");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("WanVAEDecode", {
      vae: conn(vaeLoaderId),
      samples: conn(latentId),
      enable_vae_tiling: true,
      tile_sample_min_height: 240,
      tile_sample_min_width: 240,
      tile_overlap_factor_height: 0.2,
      tile_overlap_factor_width: 0.2
    }, "VAE Decode");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_output"
    });
  } else if (ttmModel === "cogvideox") {
    const cogVideoId = nextNodeId();
    workflow[cogVideoId] = createNode("DownloadAndLoadCogVideoModel", {
      model: "CogVideoX-5b-I2V",
      precision: "bf16"
    }, "Load CogVideoX");
    const t5Id = nextNodeId();
    workflow[t5Id] = createNode("DownloadAndLoadCogVideoTextEncoder", {
      model: "t5-v1_1-xxl-encoder-bf16",
      precision: "bf16"
    }, "Load T5 Encoder");
    const vaeId = nextNodeId();
    workflow[vaeId] = createNode("DownloadAndLoadCogVideoVAE", {
      model: "cogvideox_vae",
      precision: "bf16"
    }, "Load CogVideo VAE");
    const encodePromptId = nextNodeId();
    workflow[encodePromptId] = createNode("CogVideoTextEncode", {
      text_encoder: conn(t5Id),
      prompt: params.prompt,
      force_offload: true
    }, "Encode Prompt");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlCogVideo", {
      model: conn(cogVideoId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const generateId = nextNodeId();
    workflow[generateId] = createNode("CogVideoImageToVideo", {
      model: conn(ttmControlId),
      positive: conn(encodePromptId),
      image: conn(resizeId),
      vae: conn(vaeId),
      width: params.width,
      height: params.height,
      num_frames: params.frameCount,
      steps: params.steps || 50,
      cfg: params.cfgScale || 6,
      seed: params.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "CogVideoX DDIM"
    }, "CogVideoX I2V");
    const decodeId = nextNodeId();
    workflow[decodeId] = createNode("CogVideoDecode", {
      vae: conn(vaeId),
      samples: conn(generateId),
      enable_vae_tiling: true
    }, "Decode Video");
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_cogvideo_output"
    });
  } else {
    const baseModelId = nextNodeId();
    workflow[baseModelId] = createNode("ImageOnlyCheckpointLoader", {
      ckpt_name: params.checkpoint || "svd_xt_1_1.safetensors"
    }, "Load SVD");
    const ttmControlId = nextNodeId();
    workflow[ttmControlId] = createNode("TTM_ApplyMotionControlSVD", {
      model: conn(baseModelId),
      image: conn(resizeId),
      motion_mask: conn(combinedMaskId),
      layer_data: combinedLayerDataId ? conn(combinedLayerDataId) : null,
      tweak_index: params.ttmTweakIndex ?? 0,
      tstrong_index: params.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const encodeId = nextNodeId();
    workflow[encodeId] = createNode("SVDEncode", {
      model: conn(ttmControlId),
      image: conn(resizeId),
      vae: conn(baseModelId, 2),
      width: params.width,
      height: params.height,
      video_frames: params.frameCount,
      motion_bucket_id: 127,
      fps: params.fps,
      augmentation_level: 0
    }, "SVD Encode");
    const sampleId = addKSampler(
      workflow,
      conn(ttmControlId),
      conn(encodeId, 1),
      conn(encodeId, 2),
      conn(encodeId),
      { seed: params.seed, steps: params.steps || 25, cfg: params.cfgScale || 2.5, denoise: 1 }
    );
    const decodeId = addVAEDecode(workflow, conn(sampleId), conn(baseModelId, 2));
    addVideoOutput(workflow, conn(decodeId), {
      fps: params.fps,
      filename: params.outputFilename || "ttm_svd_output"
    });
  }
  return workflow;
}
function generateControlNetWorkflow(params, controlType) {
  resetNodeIds();
  const workflow = {};
  const controlnetModels = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  };
  const checkpointId = addCheckpointLoader(workflow, params.checkpoint || "v1-5-pruned-emaonly.safetensors");
  const controlnetId = nextNodeId();
  workflow[controlnetId] = createNode("ControlNetLoader", {
    control_net_name: params.controlnetModel || controlnetModels[controlType]
  }, `Load ControlNet ${controlType}`);
  const controlLoaderId = nextNodeId();
  workflow[controlLoaderId] = createNode("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: params.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const positiveId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.prompt, "Positive");
  const negativeId = addCLIPTextEncode(workflow, conn(checkpointId, 1), params.negativePrompt, "Negative");
  const applyControlId = nextNodeId();
  workflow[applyControlId] = createNode("ControlNetApply", {
    conditioning: conn(positiveId),
    control_net: conn(controlnetId),
    image: conn(controlLoaderId),
    strength: 1
  }, "Apply ControlNet");
  const latentId = nextNodeId();
  workflow[latentId] = createNode("EmptyLatentImage", {
    width: params.width,
    height: params.height,
    batch_size: params.frameCount
  }, "Empty Latent");
  const sampleId = addKSampler(
    workflow,
    conn(checkpointId),
    conn(applyControlId),
    conn(negativeId),
    conn(latentId),
    { seed: params.seed, steps: params.steps || 20, cfg: params.cfgScale || 7 }
  );
  const decodeId = addVAEDecode(workflow, conn(sampleId), conn(checkpointId, 2));
  addVideoOutput(workflow, conn(decodeId), {
    fps: params.fps,
    filename: params.outputFilename || `controlnet_${controlType}`
  });
  return workflow;
}
function generateWorkflowForTarget(target, params) {
  switch (target) {
    case "wan22-i2v":
      return generateWan22I2VWorkflow(params);
    case "wan22-t2v":
      return generateWan22I2VWorkflow({ ...params, referenceImage: void 0 });
    case "wan22-fun-camera":
      return generateWan22FunCameraWorkflow(params);
    case "wan22-first-last":
      return generateWan22FirstLastWorkflow(params);
    case "uni3c-camera":
    case "uni3c-motion":
      return generateUni3CWorkflow(params);
    case "motionctrl":
    case "motionctrl-svd":
      return generateMotionCtrlWorkflow(params);
    case "cogvideox":
      return generateCogVideoXWorkflow(params);
    case "controlnet-depth":
      return generateControlNetDepthWorkflow(params);
    case "controlnet-canny":
      return generateControlNetWorkflow(params, "canny");
    case "controlnet-lineart":
      return generateControlNetWorkflow(params, "lineart");
    case "animatediff-cameractrl":
      return generateAnimateDiffCameraCtrlWorkflow(params);
    case "ttm":
    case "ttm-wan":
    case "ttm-cogvideox":
    case "ttm-svd":
      return generateTTMWorkflow(params);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${target}`);
  }
}
function validateWorkflow(workflow) {
  const errors = [];
  const warnings = [];
  const nodeIds = Object.keys(workflow);
  for (const [nodeId, node] of Object.entries(workflow)) {
    if (!node.class_type) {
      errors.push(`Node ${nodeId}: missing class_type`);
    }
    for (const [inputName, inputValue] of Object.entries(node.inputs)) {
      if (Array.isArray(inputValue) && inputValue.length === 2) {
        const [refNodeId] = inputValue;
        if (typeof refNodeId === "string" && !nodeIds.includes(refNodeId)) {
          errors.push(`Node ${nodeId}.${inputName}: references non-existent node ${refNodeId}`);
        }
      }
    }
  }
  const hasOutput = Object.values(workflow).some(
    (node) => node.class_type.includes("Save") || node.class_type.includes("Output") || node.class_type.includes("Preview")
  );
  if (!hasOutput) {
    warnings.push("Workflow has no output/save nodes");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

class ExportPipeline {
  layers;
  cameraKeyframes;
  config;
  onProgress;
  abortSignal;
  aborted = false;
  constructor(options) {
    this.layers = options.layers;
    this.cameraKeyframes = options.cameraKeyframes;
    this.config = options.config;
    this.onProgress = options.onProgress || (() => {
    });
    this.abortSignal = options.abortSignal;
    if (this.abortSignal) {
      this.abortSignal.addEventListener("abort", () => {
        this.aborted = true;
      });
    }
  }
  checkAborted() {
    if (this.aborted) {
      throw new Error("Export aborted");
    }
  }
  updateProgress(progress) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...progress
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const startTime = Date.now();
    const result = {
      success: false,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const configErrors = this.validateConfig();
      if (configErrors.length > 0) {
        result.errors = configErrors;
        return result;
      }
      if (this.config.exportReferenceFrame) {
        this.checkAborted();
        await this.renderReferenceFrame(result);
      }
      if (this.config.exportLastFrame) {
        this.checkAborted();
        await this.renderLastFrame(result);
      }
      if (this.config.exportDepthMap) {
        this.checkAborted();
        await this.renderDepthSequence(result);
      }
      if (this.config.exportControlImages) {
        this.checkAborted();
        await this.renderControlSequence(result);
      }
      if (this.config.exportCameraData) {
        this.checkAborted();
        await this.exportCameraData(result);
      }
      this.checkAborted();
      await this.generateWorkflow(result);
      if (this.config.autoQueueWorkflow && this.config.comfyuiServer) {
        this.checkAborted();
        await this.queueWorkflow(result);
      }
      result.success = result.errors.length === 0;
    } catch (error) {
      if (error instanceof Error && error.message === "Export aborted") {
        result.errors.push("Export was cancelled");
      } else {
        result.errors.push(error instanceof Error ? error.message : "Unknown error");
      }
    }
    result.duration = Date.now() - startTime;
    return result;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const errors = [];
    if (this.config.width < 64 || this.config.width > 4096) {
      errors.push("Width must be between 64 and 4096");
    }
    if (this.config.height < 64 || this.config.height > 4096) {
      errors.push("Height must be between 64 and 4096");
    }
    if (this.config.frameCount < 1 || this.config.frameCount > 1e3) {
      errors.push("Frame count must be between 1 and 1000");
    }
    if (this.config.fps < 1 || this.config.fps > 120) {
      errors.push("FPS must be between 1 and 120");
    }
    if (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) {
      errors.push("Invalid start frame");
    }
    if (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) {
      errors.push("Invalid end frame");
    }
    if (!this.config.prompt && this.needsPrompt()) {
      errors.push("Prompt is required for this export target");
    }
    return errors;
  }
  needsPrompt() {
    const noPromptTargets = ["controlnet-depth", "controlnet-canny", "controlnet-lineart"];
    return !noPromptTargets.includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.startFrame);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.referenceImage = uploadResult.name;
    } else {
      result.outputFiles.referenceImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(result) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const canvas = new OffscreenCanvas(this.config.width, this.config.height);
    const ctx = canvas.getContext("2d");
    await this.renderFrameToCanvas(ctx, this.config.endFrame - 1);
    const blob = await canvas.convertToBlob({ type: "image/png" });
    const filename = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const client = getComfyUIClient(this.config.comfyuiServer);
      const uploadResult = await client.uploadImage(blob, filename);
      result.outputFiles.lastImage = uploadResult.name;
    } else {
      result.outputFiles.lastImage = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(ctx, frameIndex) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    const sortedLayers = [...this.layers].filter((layer) => layer.visible).sort((a, b) => {
      const az = a.transform?.position?.value?.z ?? 0;
      const bz = b.transform?.position?.value?.z ?? 0;
      return az - bz;
    });
    for (const layer of sortedLayers) {
      await this.renderLayerToCanvas(ctx, layer, frameIndex);
    }
  }
  async renderLayerToCanvas(ctx, layer, _frameIndex) {
    const pos = layer.transform?.position?.value ?? { x: 0, y: 0 };
    const scaleVal = layer.transform?.scale?.value ?? { x: 100, y: 100 };
    const rotation = layer.transform?.rotation?.value ?? 0;
    const opacity = typeof layer.opacity?.value === "number" ? layer.opacity.value : 100;
    ctx.save();
    ctx.globalAlpha = opacity / 100;
    ctx.translate(pos.x, pos.y);
    ctx.rotate(rotation * Math.PI / 180);
    ctx.scale(scaleVal.x / 100, scaleVal.y / 100);
    const layerData = layer.data;
    if (layer.type === "image" && layerData?.src) {
      const img = await this.loadImage(layerData.src);
      ctx.drawImage(img, -img.width / 2, -img.height / 2);
    } else if (layer.type === "solid" && layerData?.color) {
      ctx.fillStyle = layerData.color || "#000000";
      const width = layerData.width ?? 100;
      const height = layerData.height ?? 100;
      ctx.fillRect(-width / 2, -height / 2, width, height);
    }
    ctx.restore();
  }
  loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const depthFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: progress,
        overallProgress: 15 + progress * 0.25,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering depth frame ${i + 1}/${frameCount}`
      });
      const defaultCamera = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: false,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: false
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      };
      const depthResult = renderDepthFrame({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: defaultCamera,
        layers: this.layers,
        frame: frameIndex
      });
      const convertedDepth = convertDepthToFormat(
        depthResult,
        this.config.depthFormat
      );
      const imageData = depthToImageData(
        convertedDepth,
        this.config.width,
        this.config.height
      );
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      const blob = await canvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_depth_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "depth_sequence");
        depthFiles.push(uploadResult.name);
      } else {
        depthFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.depthSequence = depthFiles;
    this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(result) {
    const frameCount = this.config.endFrame - this.config.startFrame;
    const controlFiles = [];
    for (let i = 0; i < frameCount; i++) {
      this.checkAborted();
      const frameIndex = this.config.startFrame + i;
      const progress = i / frameCount * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: progress,
        overallProgress: 40 + progress * 0.2,
        currentFrame: i + 1,
        totalFrames: frameCount,
        message: `Rendering control frame ${i + 1}/${frameCount}`
      });
      const canvas = new OffscreenCanvas(this.config.width, this.config.height);
      const ctx = canvas.getContext("2d");
      await this.renderFrameToCanvas(ctx, frameIndex);
      const controlCanvas = await this.applyControlPreprocessing(canvas, this.config.controlType || "depth");
      const blob = await controlCanvas.convertToBlob({ type: "image/png" });
      const filename = `${this.config.filenamePrefix}_control_${String(i).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const client = getComfyUIClient(this.config.comfyuiServer);
        const uploadResult = await client.uploadImage(blob, filename, "input", "control_sequence");
        controlFiles.push(uploadResult.name);
      } else {
        controlFiles.push(await this.saveBlobLocally(blob, filename));
      }
    }
    result.outputFiles.controlSequence = controlFiles;
    this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(input, controlType) {
    const output = new OffscreenCanvas(input.width, input.height);
    const ctx = output.getContext("2d");
    const inputCtx = input.getContext("2d");
    const imageData = inputCtx.getImageData(0, 0, input.width, input.height);
    const data = imageData.data;
    switch (controlType) {
      case "canny":
        this.applyEdgeDetection(data, input.width, input.height);
        break;
      case "lineart":
        this.applyLineart(data);
        break;
      case "softedge":
        this.applySoftEdge(data, input.width, input.height);
        break;
    }
    ctx.putImageData(imageData, 0, 0);
    return output;
  }
  applyEdgeDetection(data, width, height) {
    const grayscale = new Float32Array(width * height);
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      grayscale[i] = (data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114) / 255;
    }
    const edges = new Float32Array(width * height);
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = y * width + x;
        const gx = -grayscale[idx - width - 1] + grayscale[idx - width + 1] + -2 * grayscale[idx - 1] + 2 * grayscale[idx + 1] + -grayscale[idx + width - 1] + grayscale[idx + width + 1];
        const gy = -grayscale[idx - width - 1] - 2 * grayscale[idx - width] - grayscale[idx - width + 1] + grayscale[idx + width - 1] + 2 * grayscale[idx + width] + grayscale[idx + width + 1];
        edges[idx] = Math.min(1, Math.sqrt(gx * gx + gy * gy) * 2);
      }
    }
    for (let i = 0; i < width * height; i++) {
      const idx = i * 4;
      const val = Math.floor(edges[i] * 255);
      data[idx] = val;
      data[idx + 1] = val;
      data[idx + 2] = val;
    }
  }
  applyLineart(data) {
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      const val = gray > 128 ? 255 : 0;
      data[i] = val;
      data[i + 1] = val;
      data[i + 2] = val;
    }
  }
  applySoftEdge(data, width, height) {
    this.applyEdgeDetection(data, width, height);
    const temp = new Uint8ClampedArray(data);
    const kernel = 2;
    for (let y = kernel; y < height - kernel; y++) {
      for (let x = kernel; x < width - kernel; x++) {
        let sum = 0;
        let count = 0;
        for (let ky = -kernel; ky <= kernel; ky++) {
          for (let kx = -kernel; kx <= kernel; kx++) {
            const idx2 = ((y + ky) * width + (x + kx)) * 4;
            sum += temp[idx2];
            count++;
          }
        }
        const idx = (y * width + x) * 4;
        const val = Math.floor(sum / count);
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
    }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(result) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const exportCamera = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: false,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: false
      }};
    const cameraData = exportCameraForTarget(
      this.config.target,
      exportCamera,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    );
    const filename = `${this.config.filenamePrefix}_camera.json`;
    const blob = new Blob([JSON.stringify(cameraData, null, 2)], { type: "application/json" });
    if (this.config.comfyuiServer) {
      result.outputFiles.cameraData = filename;
    } else {
      result.outputFiles.cameraData = await this.saveBlobLocally(blob, filename);
    }
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(result) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const params = {
      referenceImage: result.outputFiles.referenceImage,
      lastFrameImage: result.outputFiles.lastImage,
      depthSequence: result.outputFiles.depthSequence,
      controlImages: result.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    if (result.outputFiles.cameraData) {
      params.cameraData = result.outputFiles.cameraData;
    }
    const workflow = generateWorkflowForTarget(this.config.target, params);
    const validation = validateWorkflow(workflow);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
    }
    result.warnings.push(...validation.warnings);
    const filename = `${this.config.filenamePrefix}_workflow.json`;
    const blob = new Blob([JSON.stringify(workflow, null, 2)], { type: "application/json" });
    result.outputFiles.workflowJson = await this.saveBlobLocally(blob, filename);
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(result) {
    if (!this.config.comfyuiServer || !result.outputFiles.workflowJson) {
      return;
    }
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const client = getComfyUIClient(this.config.comfyuiServer);
    const connected = await client.checkConnection();
    if (!connected) {
      result.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const response = await fetch(result.outputFiles.workflowJson);
    const workflow = await response.json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const promptResult = await client.queuePrompt(workflow);
    result.outputFiles.promptId = promptResult.prompt_id;
    if (promptResult.node_errors && Object.keys(promptResult.node_errors).length > 0) {
      result.errors.push("Workflow has node errors: " + JSON.stringify(promptResult.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await client.waitForPrompt(promptResult.prompt_id, (progress) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: progress.percentage,
          overallProgress: 80 + progress.percentage * 0.15,
          message: `Generating: ${progress.percentage.toFixed(0)}%`,
          preview: progress.preview
        });
      });
      this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return url;
  }
}
async function exportToComfyUI(layers, cameraKeyframes, config, onProgress) {
  const pipeline = new ExportPipeline({
    layers,
    cameraKeyframes,
    config,
    onProgress
  });
  return pipeline.execute();
}

const _hoisted_1$6 = { class: "export-dialog" };
const _hoisted_2$6 = { class: "dialog-tabs" };
const _hoisted_3$6 = { class: "dialog-content" };
const _hoisted_4$6 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_5$6 = { class: "target-grid" };
const _hoisted_6$6 = { class: "target-buttons" };
const _hoisted_7$6 = ["onClick"];
const _hoisted_8$6 = {
  key: 0,
  class: "target-info"
};
const _hoisted_9$6 = { class: "info-row" };
const _hoisted_10$6 = { class: "info-row" };
const _hoisted_11$6 = { class: "info-row" };
const _hoisted_12$5 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_13$5 = { class: "settings-section" };
const _hoisted_14$5 = { class: "preset-buttons" };
const _hoisted_15$4 = ["onClick"];
const _hoisted_16$4 = { class: "input-row" };
const _hoisted_17$4 = { class: "settings-section" };
const _hoisted_18$4 = { class: "preset-buttons" };
const _hoisted_19$4 = ["onClick"];
const _hoisted_20$4 = { class: "input-row" };
const _hoisted_21$4 = { class: "input-row" };
const _hoisted_22$4 = { class: "settings-section" };
const _hoisted_23$4 = { class: "checkbox-grid" };
const _hoisted_24$3 = {
  key: 0,
  class: "settings-section"
};
const _hoisted_25$3 = ["value"];
const _hoisted_26$3 = {
  key: 1,
  class: "settings-section"
};
const _hoisted_27$3 = ["value"];
const _hoisted_28$3 = {
  key: 2,
  class: "tab-content"
};
const _hoisted_29$3 = { class: "settings-section" };
const _hoisted_30$2 = { class: "settings-section" };
const _hoisted_31$1 = { class: "settings-section" };
const _hoisted_32$1 = { class: "input-row" };
const _hoisted_33$1 = { class: "input-row seed-row" };
const _hoisted_34$1 = {
  key: 3,
  class: "tab-content"
};
const _hoisted_35$1 = { class: "settings-section" };
const _hoisted_36$1 = { class: "server-row" };
const _hoisted_37$1 = { key: 0 };
const _hoisted_38$1 = { key: 1 };
const _hoisted_39$1 = { key: 2 };
const _hoisted_40$1 = { key: 3 };
const _hoisted_41$1 = { class: "settings-section" };
const _hoisted_42$1 = { class: "checkbox-large" };
const _hoisted_43$1 = {
  key: 0,
  class: "export-progress"
};
const _hoisted_44$1 = { class: "progress-header" };
const _hoisted_45$1 = { class: "progress-bar" };
const _hoisted_46$1 = {
  key: 0,
  class: "progress-details"
};
const _hoisted_47$1 = {
  key: 1,
  class: "export-error"
};
const _hoisted_48$1 = { class: "dialog-footer" };
const _hoisted_49$1 = ["disabled"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const activeTab = ref("target");
    const selectedTarget = ref("wan22-i2v");
    const width = ref(832);
    const height = ref(480);
    const frameCount = ref(81);
    const fps = ref(24);
    const startFrame = ref(0);
    const endFrame = ref(81);
    const exportDepthMap = ref(true);
    const exportControlImages = ref(false);
    const exportCameraData = ref(true);
    const exportReferenceFrame = ref(true);
    const exportLastFrame = ref(false);
    const depthFormat = ref("midas");
    const controlType = ref("depth");
    const prompt = ref("");
    const negativePrompt = ref("blurry, low quality, distorted");
    const seed = ref(void 0);
    const steps = ref(30);
    const cfgScale = ref(5);
    const comfyuiServer = ref("127.0.0.1:8188");
    const autoQueueWorkflow = ref(false);
    const connectionStatus = ref("disconnected");
    const isExporting = ref(false);
    const exportProgress = ref(null);
    const exportError = ref(null);
    const abortController = ref(null);
    const targetInfo = computed(() => EXPORT_TARGET_INFO[selectedTarget.value]);
    const targetCategories = computed(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      "Uni3C": ["uni3c-camera", "uni3c-motion"],
      "MotionCtrl": ["motionctrl", "motionctrl-svd"],
      "Camera": ["animatediff-cameractrl", "camera-comfyui", "ati"],
      "Advanced": ["light-x", "ttm", "cogvideox"],
      "ControlNet": ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      "Custom": ["custom-workflow"]
    }));
    const targetDisplayName = computed(() => {
      const names = {
        "wan22-i2v": "Image to Video",
        "wan22-t2v": "Text to Video",
        "wan22-fun-camera": "Fun Camera",
        "wan22-first-last": "First + Last Frame",
        "wan-move": "Point Trajectories",
        "uni3c-camera": "Camera Control",
        "uni3c-motion": "Motion + Camera",
        "motionctrl": "MotionCtrl",
        "motionctrl-svd": "MotionCtrl SVD",
        "cogvideox": "CogVideoX I2V",
        "animatediff-cameractrl": "CameraCtrl",
        "camera-comfyui": "4x4 Matrices",
        "ati": "Any Trajectory",
        "light-x": "Relighting",
        "ttm": "Cut & Drag",
        "controlnet-depth": "Depth",
        "controlnet-canny": "Canny Edge",
        "controlnet-lineart": "Line Art",
        "custom-workflow": "Custom Workflow"
      };
      return names;
    });
    const depthFormats = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ];
    const controlTypes = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function selectTarget(target) {
      selectedTarget.value = target;
      const preset = EXPORT_PRESETS[target];
      if (preset) {
        width.value = preset.width ?? 832;
        height.value = preset.height ?? 480;
        frameCount.value = preset.frameCount ?? 81;
        fps.value = preset.fps ?? 24;
        endFrame.value = frameCount.value;
      }
      const info = EXPORT_TARGET_INFO[target];
      if (info) {
        exportDepthMap.value = info.requiredInputs.includes("depth_sequence") || info.requiredInputs.includes("depth_map");
        exportCameraData.value = info.requiredInputs.includes("camera_data") || info.requiredInputs.includes("camera_trajectory") || info.requiredInputs.includes("camera_poses");
        exportReferenceFrame.value = info.requiredInputs.includes("reference_image") || info.requiredInputs.includes("first_frame");
        exportLastFrame.value = info.requiredInputs.includes("last_frame");
        exportControlImages.value = target.startsWith("controlnet-");
      }
    }
    async function checkConnection() {
      connectionStatus.value = "connecting";
      try {
        const client = getComfyUIClient(comfyuiServer.value);
        const connected = await client.checkConnection();
        connectionStatus.value = connected ? "connected" : "error";
      } catch {
        connectionStatus.value = "error";
      }
    }
    function applyResolutionPreset(preset) {
      width.value = preset.width;
      height.value = preset.height;
    }
    function applyFrameCountPreset(count) {
      frameCount.value = count;
      endFrame.value = Math.min(endFrame.value, count);
    }
    function randomizeSeed() {
      seed.value = Math.floor(Math.random() * 2147483647);
    }
    async function startExport() {
      isExporting.value = true;
      exportError.value = null;
      abortController.value = new AbortController();
      const config = {
        target: selectedTarget.value,
        width: width.value,
        height: height.value,
        frameCount: frameCount.value,
        fps: fps.value,
        startFrame: startFrame.value,
        endFrame: endFrame.value,
        outputDir: "",
        filenamePrefix: `weyl_${selectedTarget.value}_${Date.now()}`,
        exportDepthMap: exportDepthMap.value,
        exportControlImages: exportControlImages.value,
        exportCameraData: exportCameraData.value,
        exportReferenceFrame: exportReferenceFrame.value,
        exportLastFrame: exportLastFrame.value,
        depthFormat: depthFormat.value,
        controlType: controlType.value,
        prompt: prompt.value,
        negativePrompt: negativePrompt.value,
        seed: seed.value,
        steps: steps.value,
        cfgScale: cfgScale.value,
        comfyuiServer: comfyuiServer.value,
        autoQueueWorkflow: autoQueueWorkflow.value
      };
      try {
        const result = await exportToComfyUI(
          props.layers,
          props.cameraKeyframes,
          config,
          (progress) => {
            exportProgress.value = progress;
          }
        );
        if (result.success) {
          emit("exported", result);
        } else {
          exportError.value = result.errors.join("\n");
        }
      } catch (error) {
        exportError.value = error instanceof Error ? error.message : "Export failed";
      } finally {
        isExporting.value = false;
        abortController.value = null;
      }
    }
    function cancelExport() {
      if (abortController.value) {
        abortController.value.abort();
      }
    }
    function close() {
      if (isExporting.value) {
        cancelExport();
      }
      emit("close");
    }
    onMounted(() => {
      endFrame.value = Math.min(frameCount.value, props.totalFrames);
      checkConnection();
    });
    watch(selectedTarget, () => {
      selectTarget(selectedTarget.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "export-dialog-overlay",
        onClick: withModifiers(close, ["self"])
      }, [
        createBaseVNode("div", _hoisted_1$6, [
          createBaseVNode("header", { class: "dialog-header" }, [
            _cache[24] || (_cache[24] = createBaseVNode("h2", null, "Export to ComfyUI", -1)),
            createBaseVNode("button", {
              class: "close-btn",
              onClick: close
            }, "")
          ]),
          createBaseVNode("nav", _hoisted_2$6, [
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "target" }),
              onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "target")
            }, " Target ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "output" }),
              onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "output")
            }, " Output ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "generation" }),
              onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "generation")
            }, " Generation ", 2),
            createBaseVNode("button", {
              class: normalizeClass({ active: activeTab.value === "comfyui" }),
              onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          createBaseVNode("div", _hoisted_3$6, [
            activeTab.value === "target" ? (openBlock(), createElementBlock("div", _hoisted_4$6, [
              createBaseVNode("div", _hoisted_5$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(targetCategories.value, (targets, category) => {
                  return openBlock(), createElementBlock("div", {
                    key: category,
                    class: "target-category"
                  }, [
                    createBaseVNode("h3", null, toDisplayString(category), 1),
                    createBaseVNode("div", _hoisted_6$6, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(targets, (target) => {
                        return openBlock(), createElementBlock("button", {
                          key: target,
                          class: normalizeClass({ selected: selectedTarget.value === target }),
                          onClick: ($event) => selectTarget(target)
                        }, toDisplayString(targetDisplayName.value[target]), 11, _hoisted_7$6);
                      }), 128))
                    ])
                  ]);
                }), 128))
              ]),
              targetInfo.value ? (openBlock(), createElementBlock("div", _hoisted_8$6, [
                createBaseVNode("h4", null, toDisplayString(targetDisplayName.value[selectedTarget.value]), 1),
                createBaseVNode("div", _hoisted_9$6, [
                  _cache[25] || (_cache[25] = createBaseVNode("span", { class: "label" }, "Required:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_10$6, [
                  _cache[26] || (_cache[26] = createBaseVNode("span", { class: "label" }, "Optional:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                createBaseVNode("div", _hoisted_11$6, [
                  _cache[27] || (_cache[27] = createBaseVNode("span", { class: "label" }, "Outputs:", -1)),
                  createBaseVNode("span", null, toDisplayString(targetInfo.value.outputTypes.join(", ")), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "output" ? (openBlock(), createElementBlock("div", _hoisted_12$5, [
              createBaseVNode("div", _hoisted_13$5, [
                _cache[28] || (_cache[28] = createBaseVNode("h3", null, "Resolution", -1)),
                createBaseVNode("div", _hoisted_14$5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(RESOLUTION_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyResolutionPreset(preset)
                    }, toDisplayString(preset.name), 9, _hoisted_15$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_16$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: width.value,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => width.value = $event),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: height.value,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => height.value = $event),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              createBaseVNode("div", _hoisted_17$4, [
                _cache[29] || (_cache[29] = createBaseVNode("h3", null, "Frames", -1)),
                createBaseVNode("div", _hoisted_18$4, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(FRAME_COUNT_PRESETS), (preset) => {
                    return openBlock(), createElementBlock("button", {
                      key: preset.name,
                      onClick: ($event) => applyFrameCountPreset(preset.frameCount)
                    }, toDisplayString(preset.name), 9, _hoisted_19$4);
                  }), 128))
                ]),
                createBaseVNode("div", _hoisted_20$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: frameCount.value,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => frameCount.value = $event),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: fps.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => fps.value = $event),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_21$4, [
                  createVNode(ScrubableNumber, {
                    modelValue: startFrame.value,
                    "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => startFrame.value = $event),
                    label: "Start",
                    min: 0,
                    max: endFrame.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  createVNode(ScrubableNumber, {
                    modelValue: endFrame.value,
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => endFrame.value = $event),
                    label: "End",
                    min: startFrame.value + 1,
                    max: frameCount.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              createBaseVNode("div", _hoisted_22$4, [
                _cache[35] || (_cache[35] = createBaseVNode("h3", null, "Export Options", -1)),
                createBaseVNode("div", _hoisted_23$4, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => exportReferenceFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportReferenceFrame.value]
                    ]),
                    _cache[30] || (_cache[30] = createTextVNode(" Reference Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => exportLastFrame.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportLastFrame.value]
                    ]),
                    _cache[31] || (_cache[31] = createTextVNode(" Last Frame ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => exportDepthMap.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportDepthMap.value]
                    ]),
                    _cache[32] || (_cache[32] = createTextVNode(" Depth Maps ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => exportControlImages.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportControlImages.value]
                    ]),
                    _cache[33] || (_cache[33] = createTextVNode(" Control Images ", -1))
                  ]),
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => exportCameraData.value = $event)
                    }, null, 512), [
                      [vModelCheckbox, exportCameraData.value]
                    ]),
                    _cache[34] || (_cache[34] = createTextVNode(" Camera Data ", -1))
                  ])
                ])
              ]),
              exportDepthMap.value ? (openBlock(), createElementBlock("div", _hoisted_24$3, [
                _cache[36] || (_cache[36] = createBaseVNode("h3", null, "Depth Format", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => depthFormat.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(depthFormats, (fmt) => {
                    return createBaseVNode("option", {
                      key: fmt.value,
                      value: fmt.value
                    }, toDisplayString(fmt.label), 9, _hoisted_25$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, depthFormat.value]
                ])
              ])) : createCommentVNode("", true),
              exportControlImages.value ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                _cache[37] || (_cache[37] = createBaseVNode("h3", null, "Control Type", -1)),
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => controlType.value = $event)
                }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(controlTypes, (ct) => {
                    return createBaseVNode("option", {
                      key: ct.value,
                      value: ct.value
                    }, toDisplayString(ct.label), 9, _hoisted_27$3);
                  }), 64))
                ], 512), [
                  [vModelSelect, controlType.value]
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            activeTab.value === "generation" ? (openBlock(), createElementBlock("div", _hoisted_28$3, [
              createBaseVNode("div", _hoisted_29$3, [
                _cache[38] || (_cache[38] = createBaseVNode("h3", null, "Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => prompt.value = $event),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_30$2, [
                _cache[39] || (_cache[39] = createBaseVNode("h3", null, "Negative Prompt", -1)),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => negativePrompt.value = $event),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [vModelText, negativePrompt.value]
                ])
              ]),
              createBaseVNode("div", _hoisted_31$1, [
                _cache[40] || (_cache[40] = createBaseVNode("h3", null, "Parameters", -1)),
                createBaseVNode("div", _hoisted_32$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: steps.value,
                    "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => steps.value = $event),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  createVNode(ScrubableNumber, {
                    modelValue: cfgScale.value,
                    "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => cfgScale.value = $event),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_33$1, [
                  createVNode(ScrubableNumber, {
                    modelValue: seed.value ?? 0,
                    "onUpdate:modelValue": _cache[21] || (_cache[21] = (v) => seed.value = v),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("button", {
                    class: "randomize-btn",
                    onClick: randomizeSeed
                  }, "Random")
                ])
              ])
            ])) : createCommentVNode("", true),
            activeTab.value === "comfyui" ? (openBlock(), createElementBlock("div", _hoisted_34$1, [
              createBaseVNode("div", _hoisted_35$1, [
                _cache[41] || (_cache[41] = createBaseVNode("h3", null, "Server", -1)),
                createBaseVNode("div", _hoisted_36$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => comfyuiServer.value = $event),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [vModelText, comfyuiServer.value]
                  ]),
                  createBaseVNode("button", { onClick: checkConnection }, toDisplayString(connectionStatus.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["connection-status", connectionStatus.value])
                }, [
                  connectionStatus.value === "connected" ? (openBlock(), createElementBlock("span", _hoisted_37$1, "Connected")) : connectionStatus.value === "error" ? (openBlock(), createElementBlock("span", _hoisted_38$1, "Connection failed")) : connectionStatus.value === "connecting" ? (openBlock(), createElementBlock("span", _hoisted_39$1, "Connecting...")) : (openBlock(), createElementBlock("span", _hoisted_40$1, "Not connected"))
                ], 2)
              ]),
              createBaseVNode("div", _hoisted_41$1, [
                _cache[43] || (_cache[43] = createBaseVNode("h3", null, "Workflow", -1)),
                createBaseVNode("label", _hoisted_42$1, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => autoQueueWorkflow.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, autoQueueWorkflow.value]
                  ]),
                  _cache[42] || (_cache[42] = createBaseVNode("span", null, [
                    createBaseVNode("strong", null, "Auto-queue workflow"),
                    createBaseVNode("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : createCommentVNode("", true)
          ]),
          isExporting.value ? (openBlock(), createElementBlock("div", _hoisted_43$1, [
            createBaseVNode("div", _hoisted_44$1, [
              createBaseVNode("span", null, toDisplayString(exportProgress.value?.message || "Exporting..."), 1),
              createBaseVNode("button", { onClick: cancelExport }, "Cancel")
            ]),
            createBaseVNode("div", _hoisted_45$1, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${exportProgress.value?.overallProgress || 0}%` })
              }, null, 4)
            ]),
            exportProgress.value?.currentFrame ? (openBlock(), createElementBlock("div", _hoisted_46$1, " Frame " + toDisplayString(exportProgress.value.currentFrame) + " / " + toDisplayString(exportProgress.value.totalFrames), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          exportError.value ? (openBlock(), createElementBlock("div", _hoisted_47$1, toDisplayString(exportError.value), 1)) : createCommentVNode("", true),
          createBaseVNode("footer", _hoisted_48$1, [
            createBaseVNode("button", {
              class: "secondary",
              onClick: close
            }, "Cancel"),
            createBaseVNode("button", {
              class: "primary",
              disabled: isExporting.value,
              onClick: startExport
            }, toDisplayString(isExporting.value ? "Exporting..." : "Export"), 9, _hoisted_49$1)
          ])
        ])
      ]);
    };
  }
});

const ComfyUIExportDialog = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-a8c65cb8"]]);

const _hoisted_1$5 = { class: "dialog-container" };
const _hoisted_2$5 = { class: "dialog-content" };
const _hoisted_3$5 = { class: "form-row" };
const _hoisted_4$5 = { class: "tabs" };
const _hoisted_5$5 = {
  key: 0,
  class: "tab-content"
};
const _hoisted_6$5 = { class: "form-row" };
const _hoisted_7$5 = { class: "form-row dimensions-row" };
const _hoisted_8$5 = { class: "dimension-group" };
const _hoisted_9$5 = { class: "dimension-group" };
const _hoisted_10$5 = { class: "form-row" };
const _hoisted_11$5 = { class: "aspect-info" };
const _hoisted_12$4 = { class: "form-row" };
const _hoisted_13$4 = { class: "form-row" };
const _hoisted_14$4 = { class: "resolution-info" };
const _hoisted_15$3 = { class: "form-row" };
const _hoisted_16$3 = { class: "duration-inputs" };
const _hoisted_17$3 = { class: "duration-helper" };
const _hoisted_18$3 = { class: "form-row" };
const _hoisted_19$3 = { class: "color-picker-row" };
const _hoisted_20$3 = { class: "color-label" };
const _hoisted_21$3 = {
  key: 1,
  class: "tab-content"
};
const _hoisted_22$3 = { class: "form-row" };
const _hoisted_23$3 = { class: "form-row" };
const _hoisted_24$2 = { class: "form-row" };
const _hoisted_25$2 = { class: "motion-blur-settings" };
const _hoisted_26$2 = {
  key: 0,
  class: "motion-blur-params"
};
const _hoisted_27$2 = { class: "param-row" };
const _hoisted_28$2 = { class: "param-row" };
const _hoisted_29$2 = { class: "dialog-footer" };
const _hoisted_30$1 = { class: "preview-toggle" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const store = useCompositorStore();
    const activeTab = ref("basic");
    const selectedPreset = ref("custom");
    const lockAspectRatio = ref(false);
    const aspectRatio = ref(16 / 9);
    const previewChanges = ref(false);
    const settings = ref({
      name: "Main Comp",
      width: 832,
      height: 480,
      pixelAspectRatio: 1,
      fps: 16,
      frameCount: 81,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: true,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: false,
      shutterAngle: 180,
      shutterPhase: -90
    });
    const frameAspectRatio = computed(() => {
      const ratio = settings.value.width / settings.value.height * settings.value.pixelAspectRatio;
      if (Math.abs(ratio - 16 / 9) < 0.01) return "16:9 (1.78)";
      if (Math.abs(ratio - 4 / 3) < 0.01) return "4:3 (1.33)";
      if (Math.abs(ratio - 1) < 0.01) return "1:1 (1.0)";
      if (Math.abs(ratio - 9 / 16) < 0.01) return "9:16 (0.56)";
      if (Math.abs(ratio - 21 / 9) < 0.01) return "21:9 (2.33)";
      return `${ratio.toFixed(2)}`;
    });
    const durationSeconds = computed(() => {
      return settings.value.frameCount / settings.value.fps;
    });
    const durationTimecode = ref("00:00:10:00");
    const resolutionInfo = computed(() => {
      const divisors = { full: 1, half: 2, third: 3, quarter: 4 };
      const d = divisors[settings.value.resolution];
      const w = Math.floor(settings.value.width / d);
      const h = Math.floor(settings.value.height / d);
      const mb = (w * h * 4 / (1024 * 1024)).toFixed(1);
      return `${w} x ${h}, ${mb} MB per 8bpc frame`;
    });
    const presets = {
      "1080p30": { width: 1920, height: 1080, fps: 30, frameCount: 300 },
      "1080p60": { width: 1920, height: 1080, fps: 60, frameCount: 600 },
      "720p30": { width: 1280, height: 720, fps: 30, frameCount: 300 },
      "4k30": { width: 3840, height: 2160, fps: 30, frameCount: 300 },
      "instagram_square": { width: 1080, height: 1080, fps: 30, frameCount: 300 },
      "instagram_story": { width: 1080, height: 1920, fps: 30, frameCount: 300 },
      "tiktok": { width: 1080, height: 1920, fps: 30, frameCount: 300 },
      "youtube_short": { width: 1080, height: 1920, fps: 60, frameCount: 600 },
      "sd15_512": { width: 512, height: 512, fps: 8, frameCount: 16 },
      "sd15_768": { width: 768, height: 512, fps: 8, frameCount: 16 },
      "sdxl_1024": { width: 1024, height: 1024, fps: 8, frameCount: 16 },
      "wan_480p": { width: 832, height: 480, fps: 16, frameCount: 81 },
      "wan_720p": { width: 1280, height: 720, fps: 16, frameCount: 81 },
      "wan22_480p": { width: 832, height: 480, fps: 16, frameCount: 81 },
      "wan22_720p": { width: 1280, height: 720, fps: 16, frameCount: 81 },
      "hunyuan_720p": { width: 1280, height: 720, fps: 24, frameCount: 96 },
      "hunyuan_540p": { width: 960, height: 540, fps: 24, frameCount: 96 }
    };
    function applyPreset() {
      const preset = presets[selectedPreset.value];
      if (preset) {
        if (preset.width) settings.value.width = preset.width;
        if (preset.height) settings.value.height = preset.height;
        if (preset.fps) settings.value.fps = preset.fps;
        if (preset.frameCount) settings.value.frameCount = preset.frameCount;
        aspectRatio.value = settings.value.width / settings.value.height;
        updateDurationTimecode();
      }
    }
    function onDimensionChange(changed) {
      settings.value.width = Math.round(settings.value.width / 8) * 8;
      settings.value.height = Math.round(settings.value.height / 8) * 8;
      if (lockAspectRatio.value) {
        if (changed === "width") {
          settings.value.height = Math.round(settings.value.width / aspectRatio.value / 8) * 8;
        } else {
          settings.value.width = Math.round(settings.value.height * aspectRatio.value / 8) * 8;
        }
      } else {
        aspectRatio.value = settings.value.width / settings.value.height;
      }
      selectedPreset.value = "custom";
    }
    function parseDuration() {
      const parts = durationTimecode.value.split(":").map((p) => parseInt(p) || 0);
      if (parts.length === 4) {
        const [hours, minutes, seconds, frames] = parts;
        const totalSeconds = hours * 3600 + minutes * 60 + seconds;
        settings.value.frameCount = Math.round(totalSeconds * settings.value.fps) + frames;
      } else if (parts.length === 1) {
        settings.value.frameCount = parts[0];
      }
    }
    function updateDurationTimecode() {
      const totalFrames = settings.value.frameCount;
      const fps = settings.value.fps;
      const totalSeconds = Math.floor(totalFrames / fps);
      const frames = totalFrames % Math.round(fps);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor(totalSeconds % 3600 / 60);
      const seconds = totalSeconds % 60;
      durationTimecode.value = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}:${pad(frames)}`;
    }
    function pad(n) {
      return n.toString().padStart(2, "0");
    }
    function loadCurrentSettings() {
      const activeComp = store.activeComposition;
      settings.value = {
        name: activeComp?.name || "Main Comp",
        width: store.width,
        height: store.height,
        pixelAspectRatio: 1,
        fps: store.fps,
        frameCount: store.frameCount,
        resolution: "full",
        backgroundColor: activeComp?.backgroundColor || "#000000",
        autoResizeToContent: activeComp?.autoResizeToContent ?? true,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: false,
        shutterAngle: 180,
        shutterPhase: -90
      };
      aspectRatio.value = settings.value.width / settings.value.height;
      updateDurationTimecode();
    }
    function cancel() {
      emit("close");
    }
    function confirm() {
      emit("confirm", { ...settings.value });
      emit("close");
    }
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && !e.shiftKey) {
        confirm();
      }
    }
    watch(() => props.visible, (visible) => {
      if (visible) {
        loadCurrentSettings();
      }
    });
    watch(settings, () => {
      if (previewChanges.value && props.visible) {
        store.resizeComposition(settings.value.width, settings.value.height, settings.value.frameCount);
      }
    }, { deep: true });
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[19] || (_cache[19] = createBaseVNode("span", { class: "dialog-title" }, "Composition Settings", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$5, [
              createBaseVNode("div", _hoisted_3$5, [
                _cache[20] || (_cache[20] = createBaseVNode("label", null, "Composition Name:", -1)),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => settings.value.name = $event),
                  class: "text-input full-width"
                }, null, 512), [
                  [vModelText, settings.value.name]
                ])
              ]),
              createBaseVNode("div", _hoisted_4$5, [
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "basic" }),
                  onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "basic")
                }, "Basic", 2),
                createBaseVNode("button", {
                  class: normalizeClass({ active: activeTab.value === "advanced" }),
                  onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "advanced")
                }, "Advanced", 2)
              ]),
              activeTab.value === "basic" ? (openBlock(), createElementBlock("div", _hoisted_5$5, [
                createBaseVNode("div", _hoisted_6$5, [
                  _cache[22] || (_cache[22] = createBaseVNode("label", null, "Preset:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => selectedPreset.value = $event),
                    onChange: applyPreset,
                    class: "select-input"
                  }, [..._cache[21] || (_cache[21] = [
                    createBaseVNode("option", { value: "custom" }, "Custom", -1),
                    createBaseVNode("optgroup", { label: "Video" }, [
                      createBaseVNode("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                      createBaseVNode("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                      createBaseVNode("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                      createBaseVNode("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Social Media" }, [
                      createBaseVNode("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                      createBaseVNode("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                      createBaseVNode("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                      createBaseVNode("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                    ], -1),
                    createBaseVNode("optgroup", { label: "AI Video (ComfyUI)" }, [
                      createBaseVNode("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                      createBaseVNode("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                      createBaseVNode("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                      createBaseVNode("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                      createBaseVNode("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)"),
                      createBaseVNode("option", { value: "wan22_480p" }, "Wan 2.2 480p (832x480)"),
                      createBaseVNode("option", { value: "wan22_720p" }, "Wan 2.2 720p (1280x720)"),
                      createBaseVNode("option", { value: "hunyuan_720p" }, "Hunyuan 720p (1280x720)"),
                      createBaseVNode("option", { value: "hunyuan_540p" }, "Hunyuan 540p (960x540)")
                    ], -1)
                  ])], 544), [
                    [vModelSelect, selectedPreset.value]
                  ])
                ]),
                createBaseVNode("div", _hoisted_7$5, [
                  createBaseVNode("div", _hoisted_8$5, [
                    _cache[23] || (_cache[23] = createBaseVNode("label", null, "Width:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => settings.value.width = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[5] || (_cache[5] = ($event) => onDimensionChange("width"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.width,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[24] || (_cache[24] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ]),
                  createBaseVNode("button", {
                    class: normalizeClass(["lock-btn", { locked: lockAspectRatio.value }]),
                    onClick: _cache[6] || (_cache[6] = ($event) => lockAspectRatio.value = !lockAspectRatio.value),
                    title: "Lock Aspect Ratio"
                  }, toDisplayString(lockAspectRatio.value ? "" : ""), 3),
                  createBaseVNode("div", _hoisted_9$5, [
                    _cache[25] || (_cache[25] = createBaseVNode("label", null, "Height:", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "number",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => settings.value.height = $event),
                      step: 8,
                      min: "64",
                      max: "8192",
                      class: "number-input",
                      onChange: _cache[8] || (_cache[8] = ($event) => onDimensionChange("height"))
                    }, null, 544), [
                      [
                        vModelText,
                        settings.value.height,
                        void 0,
                        { number: true }
                      ]
                    ]),
                    _cache[26] || (_cache[26] = createBaseVNode("span", { class: "unit" }, "px", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_10$5, [
                  _cache[27] || (_cache[27] = createBaseVNode("label", null, "Pixel Aspect Ratio:", -1)),
                  _cache[28] || (_cache[28] = createBaseVNode("span", { class: "fixed-value" }, "Square Pixels (1:1)", -1)),
                  createBaseVNode("span", _hoisted_11$5, "Frame Aspect Ratio: " + toDisplayString(frameAspectRatio.value), 1)
                ]),
                createBaseVNode("div", _hoisted_12$4, [
                  _cache[30] || (_cache[30] = createBaseVNode("label", null, "Frame Rate:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => settings.value.fps = $event),
                    class: "select-input short"
                  }, [..._cache[29] || (_cache[29] = [
                    createBaseVNode("option", { value: 8 }, "8", -1),
                    createBaseVNode("option", { value: 12 }, "12", -1),
                    createBaseVNode("option", { value: 15 }, "15", -1),
                    createBaseVNode("option", { value: 16 }, "16", -1),
                    createBaseVNode("option", { value: 23.976 }, "23.976", -1),
                    createBaseVNode("option", { value: 24 }, "24", -1),
                    createBaseVNode("option", { value: 25 }, "25", -1),
                    createBaseVNode("option", { value: 29.97 }, "29.97", -1),
                    createBaseVNode("option", { value: 30 }, "30", -1),
                    createBaseVNode("option", { value: 50 }, "50", -1),
                    createBaseVNode("option", { value: 59.94 }, "59.94", -1),
                    createBaseVNode("option", { value: 60 }, "60", -1)
                  ])], 512), [
                    [
                      vModelSelect,
                      settings.value.fps,
                      void 0,
                      { number: true }
                    ]
                  ]),
                  _cache[31] || (_cache[31] = createBaseVNode("span", { class: "unit" }, "frames per second", -1))
                ]),
                createBaseVNode("div", _hoisted_13$4, [
                  _cache[33] || (_cache[33] = createBaseVNode("label", null, "Resolution:", -1)),
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => settings.value.resolution = $event),
                    class: "select-input short"
                  }, [..._cache[32] || (_cache[32] = [
                    createBaseVNode("option", { value: "full" }, "Full", -1),
                    createBaseVNode("option", { value: "half" }, "Half", -1),
                    createBaseVNode("option", { value: "third" }, "Third", -1),
                    createBaseVNode("option", { value: "quarter" }, "Quarter", -1)
                  ])], 512), [
                    [vModelSelect, settings.value.resolution]
                  ]),
                  createBaseVNode("span", _hoisted_14$4, toDisplayString(resolutionInfo.value), 1)
                ]),
                createBaseVNode("div", _hoisted_15$3, [
                  _cache[34] || (_cache[34] = createBaseVNode("label", null, "Duration:", -1)),
                  createBaseVNode("div", _hoisted_16$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => durationTimecode.value = $event),
                      class: "timecode-input",
                      placeholder: "00:00:00:00",
                      onBlur: parseDuration
                    }, null, 544), [
                      [vModelText, durationTimecode.value]
                    ]),
                    createBaseVNode("span", _hoisted_17$3, toDisplayString(settings.value.frameCount) + " frames = " + toDisplayString(durationSeconds.value.toFixed(2)) + "s ", 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_18$3, [
                  _cache[35] || (_cache[35] = createBaseVNode("label", null, "Background Color:", -1)),
                  createBaseVNode("div", _hoisted_19$3, [
                    withDirectives(createBaseVNode("input", {
                      type: "color",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => settings.value.backgroundColor = $event),
                      class: "color-input"
                    }, null, 512), [
                      [vModelText, settings.value.backgroundColor]
                    ]),
                    createBaseVNode("span", _hoisted_20$3, toDisplayString(settings.value.backgroundColor), 1)
                  ])
                ])
              ])) : createCommentVNode("", true),
              activeTab.value === "advanced" ? (openBlock(), createElementBlock("div", _hoisted_21$3, [
                createBaseVNode("div", _hoisted_22$3, [
                  createBaseVNode("label", null, [
                    withDirectives(createBaseVNode("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => settings.value.autoResizeToContent = $event)
                    }, null, 512), [
                      [vModelCheckbox, settings.value.autoResizeToContent]
                    ]),
                    _cache[36] || (_cache[36] = createTextVNode(" Auto-resize composition when importing video ", -1))
                  ])
                ]),
                createBaseVNode("div", _hoisted_23$3, [
                  _cache[37] || (_cache[37] = createBaseVNode("label", null, "Start Timecode:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => settings.value.startTimecode = $event),
                    class: "timecode-input",
                    placeholder: "00:00:00:00"
                  }, null, 512), [
                    [vModelText, settings.value.startTimecode]
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$2, [
                  _cache[43] || (_cache[43] = createBaseVNode("label", null, "Motion Blur:", -1)),
                  createBaseVNode("div", _hoisted_25$2, [
                    createBaseVNode("label", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => settings.value.motionBlurEnabled = $event)
                      }, null, 512), [
                        [vModelCheckbox, settings.value.motionBlurEnabled]
                      ]),
                      _cache[38] || (_cache[38] = createTextVNode(" Enable Motion Blur ", -1))
                    ]),
                    settings.value.motionBlurEnabled ? (openBlock(), createElementBlock("div", _hoisted_26$2, [
                      createBaseVNode("div", _hoisted_27$2, [
                        _cache[39] || (_cache[39] = createBaseVNode("label", null, "Shutter Angle:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => settings.value.shutterAngle = $event),
                          min: "0",
                          max: "720",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterAngle,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[40] || (_cache[40] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ]),
                      createBaseVNode("div", _hoisted_28$2, [
                        _cache[41] || (_cache[41] = createBaseVNode("label", null, "Shutter Phase:", -1)),
                        withDirectives(createBaseVNode("input", {
                          type: "number",
                          "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => settings.value.shutterPhase = $event),
                          min: "-360",
                          max: "360",
                          class: "number-input short"
                        }, null, 512), [
                          [
                            vModelText,
                            settings.value.shutterPhase,
                            void 0,
                            { number: true }
                          ]
                        ]),
                        _cache[42] || (_cache[42] = createBaseVNode("span", { class: "unit" }, "", -1))
                      ])
                    ])) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_29$2, [
              createBaseVNode("div", _hoisted_30$1, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => previewChanges.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, previewChanges.value]
                  ]),
                  _cache[44] || (_cache[44] = createTextVNode(" Preview ", -1))
                ])
              ]),
              createBaseVNode("div", { class: "dialog-actions" }, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: confirm
                }, "OK")
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const CompositionSettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-6dd35a7f"]]);

const logger$1 = createLogger("MotionIntentResolver");
const SYSTEM_PROMPT = `You are a motion graphics expert analyzing images for camera movements and animation paths.

Given an image, suggest motion paths and camera trajectories that would create compelling visual effects.

ALWAYS respond in valid JSON format with this structure:
{
  "description": "Brief description of suggested motion",
  "confidence": 0.0-1.0,
  "cameraIntents": [...],
  "splineIntents": [...],
  "particleIntents": [...],
  "layerIntents": [...]
}

For spline/path suggestions, provide control points as:
{
  "suggestedPoints": [
    { "id": "p1", "x": 100, "y": 200, "depth": 0.5, "handleIn": null, "handleOut": null, "type": "smooth" }
  ]
}

Consider:
- Depth information if available (closer = lower depth values)
- Subject positions and focal points
- Natural motion paths that follow scene geometry
- Parallax opportunities based on depth layers
`;
const PATH_SUGGESTION_PROMPT = `Analyze this image and suggest camera/motion paths.

Consider:
1. Main subjects and their positions
2. Depth layers (foreground, midground, background)
3. Natural movement paths that would be visually interesting
4. Points of interest to orbit around or move between

Suggest 2-3 different trajectory options with varying complexity.`;
class MotionIntentResolver {
  config;
  lastResult = null;
  constructor(config) {
    this.config = {
      modelId: config?.modelId ?? "rule-based",
      apiEndpoint: config?.apiEndpoint,
      apiKey: config?.apiKey,
      maxTokens: config?.maxTokens ?? 2048,
      temperature: config?.temperature ?? 0.7
    };
  }
  /**
   * Resolve a user prompt into structured motion intents
   */
  async resolve(prompt, context, modelOverride) {
    const modelId = modelOverride ?? this.config.modelId;
    logger$1.info(`Resolving motion intent with ${modelId}:`, prompt);
    try {
      let result;
      switch (modelId) {
        case "rule-based":
          result = await this.resolveWithRules(prompt, context);
          break;
        case "gpt-4v":
        case "gpt-4o":
          result = await this.resolveWithOpenAI(prompt, context, modelId);
          break;
        case "claude-vision":
          result = await this.resolveWithClaude(prompt, context);
          break;
        case "qwen-vl":
        case "qwen2-vl":
        case "llava":
        case "local-vlm":
          result = await this.resolveWithLocalVLM(prompt, context, modelId);
          break;
        default:
          result = await this.resolveWithRules(prompt, context);
      }
      this.lastResult = result;
      return result;
    } catch (error) {
      logger$1.error("Motion intent resolution failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  /**
   * Suggest paths based on image analysis
   * This is the main entry point for "suggest trajectories across image"
   */
  async suggestPaths(context, modelOverride) {
    return this.resolve(PATH_SUGGESTION_PROMPT, context, modelOverride);
  }
  // ============================================================================
  // RULE-BASED FALLBACK
  // ============================================================================
  async resolveWithRules(prompt, context) {
    const lowerPrompt = prompt.toLowerCase();
    const intents = {
      description: "Rule-based motion suggestion",
      confidence: 0.6,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: []
    };
    const cameraIntents = [];
    if (lowerPrompt.includes("dolly") || lowerPrompt.includes("push in") || lowerPrompt.includes("pull out")) {
      cameraIntents.push({
        type: "dolly",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "z",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("pan") || lowerPrompt.includes("sweep")) {
      cameraIntents.push({
        type: "pan",
        intensity: this.extractIntensity(lowerPrompt),
        axis: "y",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("orbit") || lowerPrompt.includes("around")) {
      cameraIntents.push({
        type: "orbit",
        intensity: this.extractIntensity(lowerPrompt),
        durationFrames: context.frameCount,
        orbitCenter: { x: context.width / 2, y: context.height / 2, z: 0 },
        suggestedEasing: "linear"
      });
    }
    if (lowerPrompt.includes("drift") || lowerPrompt.includes("float") || lowerPrompt.includes("subtle")) {
      cameraIntents.push({
        type: "drift",
        intensity: "very_subtle",
        durationFrames: context.frameCount,
        suggestedEasing: "easeInOut"
      });
    }
    if (lowerPrompt.includes("handheld") || lowerPrompt.includes("shake")) {
      cameraIntents.push({
        type: "handheld",
        intensity: this.extractIntensity(lowerPrompt),
        noiseAmount: lowerPrompt.includes("light") ? 0.3 : 0.6,
        durationFrames: context.frameCount
      });
    }
    const splineIntents = [];
    if (context.depthMap || lowerPrompt.includes("path") || lowerPrompt.includes("trajectory")) {
      const defaultPath = this.generateDefaultPath(context);
      splineIntents.push({
        usage: "camera_path",
        smoothness: 0.8,
        complexity: defaultPath.length,
        worldSpace: true,
        suggestedPoints: defaultPath,
        closed: false
      });
      if (context.depthMap) {
        const depthPath = this.generateDepthBasedPath(context);
        splineIntents.push({
          usage: "camera_path",
          smoothness: 0.9,
          complexity: depthPath.length,
          worldSpace: true,
          suggestedPoints: depthPath,
          closed: false
        });
      }
    }
    const particleIntents = [];
    if (lowerPrompt.includes("particle") || lowerPrompt.includes("dust") || lowerPrompt.includes("snow")) {
      particleIntents.push({
        behavior: lowerPrompt.includes("snow") ? "snow" : lowerPrompt.includes("dust") ? "dust" : "drift",
        intensity: 0.5,
        spread: 45,
        lifetime: 120
      });
    }
    return {
      ...intents,
      cameraIntents,
      splineIntents,
      particleIntents
    };
  }
  extractIntensity(prompt) {
    if (prompt.includes("very subtle") || prompt.includes("barely")) return "very_subtle";
    if (prompt.includes("subtle") || prompt.includes("gentle") || prompt.includes("soft")) return "subtle";
    if (prompt.includes("dramatic") || prompt.includes("intense") || prompt.includes("strong")) return "dramatic";
    if (prompt.includes("bold") || prompt.includes("dynamic")) return "strong";
    return "medium";
  }
  generateDefaultPath(context) {
    const { width, height } = context;
    const padding = Math.min(width, height) * 0.1;
    return [
      this.createControlPoint("p1", padding, height / 2, 0),
      this.createControlPoint("p2", width * 0.33, height * 0.3, 0.3),
      this.createControlPoint("p3", width * 0.66, height * 0.7, 0.6),
      this.createControlPoint("p4", width - padding, height / 2, 1)
    ];
  }
  generateDepthBasedPath(context) {
    const { width, height, depthMap } = context;
    if (!depthMap) {
      return this.generateDefaultPath(context);
    }
    const points = [];
    const numPoints = 5;
    for (let i = 0; i < numPoints; i++) {
      const t = i / (numPoints - 1);
      const x = width * (0.2 + t * 0.6);
      const y = height * (0.3 + Math.sin(t * Math.PI) * 0.4);
      const pixelIndex = Math.floor(y) * width + Math.floor(x);
      const depth = depthMap[pixelIndex] ?? 0.5;
      points.push(this.createControlPoint(`dp${i}`, x, y, depth));
    }
    return points;
  }
  createControlPoint(id, x, y, depth) {
    return {
      id,
      x,
      y,
      depth,
      handleIn: null,
      handleOut: null,
      type: "smooth"
    };
  }
  // ============================================================================
  // OPENAI GPT-4V / GPT-4o
  // ============================================================================
  async resolveWithOpenAI(prompt, context, model) {
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: imageBase64 ? [
          { type: "text", text: prompt },
          { type: "image_url", image_url: { url: `data:image/png;base64,${imageBase64}` } }
        ] : prompt
      }
    ];
    try {
      const response = await fetch("/weyl/api/vision/openai", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: model === "gpt-4o" ? "gpt-4o" : "gpt-4-vision-preview",
          messages,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature
        })
      });
      const result = await response.json();
      if (result.status !== "success") {
        throw new Error(result.message || `OpenAI API error: ${response.status}`);
      }
      const content = result.data.choices[0]?.message?.content;
      return this.parseAIResponse(content, prompt);
    } catch (error) {
      logger$1.error("OpenAI API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // CLAUDE VISION
  // ============================================================================
  async resolveWithClaude(prompt, context) {
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    const content = imageBase64 ? [
      { type: "image", source: { type: "base64", media_type: "image/png", data: imageBase64 } },
      { type: "text", text: prompt }
    ] : [{ type: "text", text: prompt }];
    try {
      const response = await fetch("/weyl/api/vision/anthropic", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: this.config.maxTokens,
          messages: [
            { role: "user", content: SYSTEM_PROMPT + "\n\nUser request: " + (typeof content === "string" ? content : JSON.stringify(content)) }
          ]
        })
      });
      const result = await response.json();
      if (result.status !== "success") {
        throw new Error(result.message || `Anthropic API error: ${response.status}`);
      }
      const responseContent = result.data.content[0]?.text;
      return this.parseAIResponse(responseContent, prompt);
    } catch (error) {
      logger$1.error("Anthropic API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // LOCAL VLM (via ComfyUI or local endpoint)
  // ============================================================================
  async resolveWithLocalVLM(prompt, context, model) {
    const endpoint = this.config.apiEndpoint ?? "/weyl/vlm";
    const imageBase64 = context.frameImage ? this.imageDataToBase64(context.frameImage) : null;
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model,
          prompt: `${SYSTEM_PROMPT}

User request: ${prompt}`,
          image: imageBase64,
          max_tokens: this.config.maxTokens
        })
      });
      if (!response.ok) {
        throw new Error(`Local VLM API error: ${response.status}`);
      }
      const data = await response.json();
      return this.parseAIResponse(data.response ?? data.text ?? data.content, prompt);
    } catch (error) {
      logger$1.error("Local VLM API call failed:", error);
      return this.resolveWithRules(prompt, context);
    }
  }
  // ============================================================================
  // RESPONSE PARSING
  // ============================================================================
  parseAIResponse(content, originalPrompt) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          description: parsed.description ?? "AI-generated motion suggestion",
          confidence: parsed.confidence ?? 0.8,
          cameraIntents: parsed.cameraIntents ?? [],
          splineIntents: parsed.splineIntents ?? [],
          particleIntents: parsed.particleIntents ?? [],
          layerIntents: parsed.layerIntents ?? [],
          rawResponse: content
        };
      }
    } catch (error) {
      logger$1.warn("Failed to parse AI response as JSON:", error);
    }
    return {
      description: content.slice(0, 200),
      confidence: 0.5,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: [],
      rawResponse: content
    };
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  imageDataToBase64(imageData) {
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d");
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL("image/png").split(",")[1];
  }
  /**
   * Get last resolution result
   */
  getLastResult() {
    return this.lastResult;
  }
  /**
   * Update configuration
   */
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}
const motionIntentResolver = new MotionIntentResolver();

const logger = createLogger("MotionIntentTranslator");
const INTENSITY_TO_DISTANCE = {
  very_subtle: 10,
  subtle: 30,
  medium: 80,
  strong: 200,
  dramatic: 500
};
const INTENSITY_TO_ROTATION = {
  very_subtle: 2,
  subtle: 5,
  medium: 15,
  strong: 45,
  dramatic: 90
};
function getEasingHandles(easing, duration) {
  const third = duration / 3;
  switch (easing) {
    case "linear":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeIn":
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "easeOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
    case "easeInOut":
      return {
        inHandle: { frame: -third, value: 0, enabled: true },
        outHandle: { frame: third, value: 0, enabled: true }
      };
    case "bounce":
      return {
        inHandle: { frame: -third * 0.5, value: 0, enabled: true },
        outHandle: { frame: third * 0.5, value: 0, enabled: true }
      };
    case "elastic":
      return {
        inHandle: { frame: -third * 0.3, value: 0, enabled: true },
        outHandle: { frame: third * 0.3, value: 0, enabled: true }
      };
    default:
      return {
        inHandle: { frame: 0, value: 0, enabled: false },
        outHandle: { frame: 0, value: 0, enabled: false }
      };
  }
}
class MotionIntentTranslator {
  /**
   * Translate a camera motion intent to keyframes
   */
  translateCameraIntent(intent, cameraLayerId, currentPosition, compositionFrameCount) {
    const duration = intent.durationFrames ?? compositionFrameCount;
    const distance = INTENSITY_TO_DISTANCE[intent.intensity];
    const rotation = INTENSITY_TO_ROTATION[intent.intensity];
    const easing = intent.suggestedEasing ?? "easeInOut";
    const batches = [];
    switch (intent.type) {
      case "dolly":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.z",
            currentPosition.z,
            currentPosition.z + (intent.axis === "z" ? distance : 0),
            0,
            duration,
            easing
          )
        );
        break;
      case "truck":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.x",
            currentPosition.x,
            currentPosition.x + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pedestal":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "transform.position.y",
            currentPosition.y,
            currentPosition.y + distance,
            0,
            duration,
            easing
          )
        );
        break;
      case "pan":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.y",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "tilt":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.x",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "roll":
        batches.push(
          this.createRotationKeyframes(
            cameraLayerId,
            "transform.rotation.z",
            0,
            rotation,
            0,
            duration,
            easing
          )
        );
        break;
      case "zoom":
        batches.push(
          this.createPositionKeyframes(
            cameraLayerId,
            "camera.fov",
            60,
            60 - distance * 0.5,
            // Narrower FOV = zoom in
            0,
            duration,
            easing
          )
        );
        break;
      case "drift":
        batches.push(
          ...this.createDriftKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "handheld":
        batches.push(
          ...this.createHandheldKeyframes(
            cameraLayerId,
            currentPosition,
            duration,
            intent.noiseAmount ?? 0.5
          )
        );
        break;
      case "orbit":
        if (intent.orbitCenter) {
          batches.push(
            ...this.createOrbitKeyframes(
              cameraLayerId,
              currentPosition,
              intent.orbitCenter,
              duration,
              intent.intensity
            )
          );
        }
        break;
      case "crane":
        batches.push(
          ...this.createCraneKeyframes(cameraLayerId, currentPosition, duration, intent.intensity)
        );
        break;
      case "follow_path":
        if (intent.suggestedPath) {
          logger.info("Camera path following requires spline layer creation");
        }
        break;
    }
    return batches;
  }
  /**
   * Translate a spline intent to a spline layer configuration
   */
  translateSplineIntent(intent, compositionWidth, compositionHeight) {
    const controlPoints = intent.suggestedPoints.map((p, i) => ({
      id: p.id ?? `sp_${i}`,
      x: p.x,
      y: p.y,
      depth: p.depth ?? 0,
      handleIn: this.generateHandle(intent.suggestedPoints, i, -1, intent.smoothness),
      handleOut: this.generateHandle(intent.suggestedPoints, i, 1, intent.smoothness),
      type: p.type ?? "smooth"
    }));
    return {
      keyframeBatches: [],
      newSplines: [
        {
          name: `AI Path - ${intent.usage}`,
          points: controlPoints,
          closed: intent.closed
        }
      ]
    };
  }
  /**
   * Translate a particle intent to emitter configuration
   */
  translateParticleIntent(intent, compositionWidth, compositionHeight) {
    const baseConfig = {
      emissionRate: intent.intensity * 20,
      particleLifetime: intent.lifetime ?? 60,
      spread: intent.spread ?? 30
    };
    switch (intent.behavior) {
      case "snow":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 50,
          speedVariance: 20,
          gravity: 0.1
        });
        break;
      case "rain":
        Object.assign(baseConfig, {
          direction: 270,
          speed: 200,
          speedVariance: 30,
          gravity: 0.5
        });
        break;
      case "dust":
        Object.assign(baseConfig, {
          direction: 0,
          speed: 20,
          speedVariance: 15,
          gravity: 0
        });
        break;
      case "fireflies":
        Object.assign(baseConfig, {
          direction: 90,
          speed: 30,
          speedVariance: 20,
          gravity: -0.05
        });
        break;
      case "explosion":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 300,
          speedVariance: 100,
          initialBurst: 50,
          emissionRate: 0
        });
        break;
      case "vortex":
        Object.assign(baseConfig, {
          direction: 0,
          spread: 360,
          speed: 100
          // Would need vortex force field
        });
        break;
    }
    return {
      keyframeBatches: [],
      newLayers: [
        {
          type: "particles",
          name: `AI Particles - ${intent.behavior}`,
          config: baseConfig
        }
      ]
    };
  }
  /**
   * Translate a layer motion intent to keyframes
   */
  translateLayerIntent(intent, layer, compositionFrameCount) {
    const duration = compositionFrameCount;
    const amplitude = intent.amplitude;
    const frequency = intent.frequency ?? 1;
    const batches = [];
    switch (intent.motionType) {
      case "parallax":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 50,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "float":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.y",
            0,
            amplitude * 30,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "sway":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.position.x",
            0,
            amplitude * 40,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "breathe":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.x",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          ),
          this.createOscillatingKeyframes(
            layer.id,
            "transform.scale.y",
            100,
            100 + amplitude * 10,
            duration,
            frequency,
            intent.phase ?? 0
          )
        );
        break;
      case "pulse":
        batches.push(
          this.createOscillatingKeyframes(
            layer.id,
            "opacity",
            100,
            100 - amplitude * 30,
            duration,
            frequency * 2,
            intent.phase ?? 0
          )
        );
        break;
      case "rotate":
        batches.push(
          this.createPositionKeyframes(
            layer.id,
            "transform.rotation.z",
            0,
            360 * frequency,
            0,
            duration,
            "linear"
          )
        );
        break;
    }
    return batches;
  }
  // ============================================================================
  // KEYFRAME GENERATORS
  // ============================================================================
  createPositionKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    const handles = getEasingHandles(easing, endFrame - startFrame);
    return {
      layerId,
      propertyPath,
      keyframes: [
        {
          id: `kf_${layerId}_${propertyPath}_0`,
          frame: startFrame,
          value: startValue,
          interpolation: easing === "linear" ? "linear" : "bezier",
          ...handles,
          controlMode: "smooth"
        },
        {
          id: `kf_${layerId}_${propertyPath}_1`,
          frame: endFrame,
          value: endValue,
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: false },
          outHandle: { frame: 0, value: 0, enabled: false },
          controlMode: "smooth"
        }
      ]
    };
  }
  createRotationKeyframes(layerId, propertyPath, startValue, endValue, startFrame, endFrame, easing) {
    return this.createPositionKeyframes(
      layerId,
      propertyPath,
      startValue,
      endValue,
      startFrame,
      endFrame,
      easing
    );
  }
  createOscillatingKeyframes(layerId, propertyPath, centerValue, amplitude, duration, cycles, phase) {
    const keyframes = [];
    const framesPerCycle = duration / cycles;
    const quarterCycle = framesPerCycle / 4;
    for (let i = 0; i <= cycles * 4; i++) {
      const frame = Math.round(i * quarterCycle);
      if (frame > duration) break;
      const sinePhase = (i + phase * 4) % 4;
      let value;
      switch (sinePhase) {
        case 0:
          value = centerValue;
          break;
        case 1:
          value = centerValue + amplitude;
          break;
        case 2:
          value = centerValue;
          break;
        case 3:
          value = centerValue - amplitude;
          break;
        default:
          value = centerValue;
      }
      keyframes.push({
        id: `kf_${layerId}_${propertyPath}_${i}`,
        frame,
        value,
        interpolation: "bezier",
        inHandle: { frame: -quarterCycle * 0.5, value: 0, enabled: true },
        outHandle: { frame: quarterCycle * 0.5, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return { layerId, propertyPath, keyframes };
  }
  createDriftKeyframes(layerId, startPosition, duration, intensity) {
    const distance = INTENSITY_TO_DISTANCE[intensity] * 0.3;
    return [
      this.createOscillatingKeyframes(layerId, "transform.position.x", startPosition.x, distance, duration, 0.5, 0),
      this.createOscillatingKeyframes(layerId, "transform.position.y", startPosition.y, distance * 0.7, duration, 0.3, 0.25),
      this.createOscillatingKeyframes(layerId, "transform.position.z", startPosition.z, distance * 0.5, duration, 0.4, 0.5)
    ];
  }
  createHandheldKeyframes(layerId, startPosition, duration, noiseAmount) {
    const seed = this.hashString(layerId);
    const amplitude = noiseAmount * 5;
    const keyframes = [];
    for (const axis of ["x", "y", "z"]) {
      const axisKeyframes = [];
      const baseValue = startPosition[axis];
      const numKeyframes = Math.floor(duration / 4);
      for (let i = 0; i <= numKeyframes; i++) {
        const frame = Math.min(i * 4, duration);
        const noise = this.deterministicNoise(seed, axis, frame) * amplitude;
        axisKeyframes.push({
          id: `kf_${layerId}_handheld_${axis}_${i}`,
          frame,
          value: baseValue + noise,
          interpolation: "bezier",
          inHandle: { frame: -1, value: 0, enabled: true },
          outHandle: { frame: 1, value: 0, enabled: true },
          controlMode: "smooth"
        });
      }
      keyframes.push({
        layerId,
        propertyPath: `transform.position.${axis}`,
        keyframes: axisKeyframes
      });
    }
    return keyframes;
  }
  createOrbitKeyframes(layerId, startPosition, center, duration, intensity) {
    const radius = Math.sqrt(
      Math.pow(startPosition.x - center.x, 2) + Math.pow(startPosition.z - center.z, 2)
    ) || INTENSITY_TO_DISTANCE[intensity];
    const numKeyframes = 8;
    const xKeyframes = [];
    const zKeyframes = [];
    for (let i = 0; i <= numKeyframes; i++) {
      const frame = Math.round(i / numKeyframes * duration);
      const angle = i / numKeyframes * Math.PI * 2;
      xKeyframes.push({
        id: `kf_${layerId}_orbit_x_${i}`,
        frame,
        value: center.x + Math.cos(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
      zKeyframes.push({
        id: `kf_${layerId}_orbit_z_${i}`,
        frame,
        value: center.z + Math.sin(angle) * radius,
        interpolation: "bezier",
        inHandle: { frame: -duration / numKeyframes * 0.3, value: 0, enabled: true },
        outHandle: { frame: duration / numKeyframes * 0.3, value: 0, enabled: true },
        controlMode: "smooth"
      });
    }
    return [
      { layerId, propertyPath: "transform.position.x", keyframes: xKeyframes },
      { layerId, propertyPath: "transform.position.z", keyframes: zKeyframes }
    ];
  }
  createCraneKeyframes(layerId, startPosition, duration, intensity) {
    const height = INTENSITY_TO_DISTANCE[intensity];
    return [
      this.createPositionKeyframes(
        layerId,
        "transform.position.y",
        startPosition.y,
        startPosition.y + height,
        0,
        duration / 2,
        "easeOut"
      ),
      this.createPositionKeyframes(
        layerId,
        "transform.position.z",
        startPosition.z,
        startPosition.z + height * 0.5,
        0,
        duration,
        "easeInOut"
      )
    ];
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  generateHandle(points, index, direction, smoothness) {
    const prevPoint = points[index - 1];
    const nextPoint = points[index + 1];
    const currentPoint = points[index];
    if (!currentPoint) return null;
    let tangentX = 0;
    let tangentY = 0;
    if (prevPoint && nextPoint) {
      tangentX = (nextPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else if (nextPoint) {
      tangentX = (nextPoint.x - currentPoint.x) * 0.25 * smoothness;
      tangentY = (nextPoint.y - currentPoint.y) * 0.25 * smoothness;
    } else if (prevPoint) {
      tangentX = (currentPoint.x - prevPoint.x) * 0.25 * smoothness;
      tangentY = (currentPoint.y - prevPoint.y) * 0.25 * smoothness;
    } else {
      return null;
    }
    return {
      x: tangentX * direction,
      y: tangentY * direction
    };
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  deterministicNoise(seed, axis, frame) {
    const axisOffset = axis === "x" ? 0 : axis === "y" ? 1e3 : 2e3;
    const combined = seed + axisOffset + frame * 13;
    const x = Math.sin(combined) * 1e4;
    return x - Math.floor(x) - 0.5;
  }
}
const motionIntentTranslator = new MotionIntentTranslator();

const _hoisted_1$4 = { class: "dialog-container" };
const _hoisted_2$4 = { class: "dialog-content" };
const _hoisted_3$4 = { class: "form-section" };
const _hoisted_4$4 = { class: "form-row" };
const _hoisted_5$4 = {
  key: 0,
  class: "form-row api-status-row"
};
const _hoisted_6$4 = {
  key: 1,
  class: "form-row"
};
const _hoisted_7$4 = { class: "form-section" };
const _hoisted_8$4 = { class: "prompt-presets" };
const _hoisted_9$4 = ["onClick"];
const _hoisted_10$4 = {
  key: 0,
  class: "form-section"
};
const _hoisted_11$4 = {
  key: 0,
  class: "spinner"
};
const _hoisted_12$3 = { class: "status-text" };
const _hoisted_13$3 = {
  key: 1,
  class: "form-section"
};
const _hoisted_14$3 = { class: "suggestions-list" };
const _hoisted_15$2 = ["onClick"];
const _hoisted_16$2 = { class: "suggestion-header" };
const _hoisted_17$2 = { class: "suggestion-type" };
const _hoisted_18$2 = { class: "suggestion-confidence" };
const _hoisted_19$2 = { class: "suggestion-description" };
const _hoisted_20$2 = { class: "suggestion-details" };
const _hoisted_21$2 = { key: 0 };
const _hoisted_22$2 = { key: 1 };
const _hoisted_23$2 = { class: "form-section preview-section" };
const _hoisted_24$1 = { class: "dialog-footer" };
const _hoisted_25$1 = { class: "footer-left" };
const _hoisted_26$1 = ["disabled"];
const _hoisted_27$1 = {
  key: 0,
  class: "spinner-small"
};
const _hoisted_28$1 = { class: "dialog-actions" };
const _hoisted_29$1 = ["disabled"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "PathSuggestionDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "accept", "preview"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const store = useCompositorStore();
    const selectedModel = ref("rule-based");
    const localEndpoint = ref("http://localhost:8188/api/vlm");
    const apiKeyStatus = ref({ openai: false, anthropic: false });
    const prompt = ref("");
    const selectedPreset = ref(null);
    const status = ref("idle");
    const statusMessage = ref("");
    const suggestions = ref([]);
    const selectedSuggestion = ref(null);
    const showPreview = ref(true);
    const promptPresets = [
      { id: "dolly", label: "Dolly", prompt: "Gentle dolly in towards the subject" },
      { id: "orbit", label: "Orbit", prompt: "Slow orbit around the center point" },
      { id: "drift", label: "Drift", prompt: "Subtle floating drift movement" },
      { id: "handheld", label: "Handheld", prompt: "Organic handheld camera shake" },
      { id: "pan", label: "Pan", prompt: "Smooth horizontal pan across the scene" },
      { id: "crane", label: "Crane", prompt: "Vertical crane movement" }
    ];
    const isCloudModel = computed(() => {
      return ["gpt-4v", "gpt-4o", "claude-vision"].includes(selectedModel.value);
    });
    const isLocalModel = computed(() => {
      return ["qwen-vl", "qwen2-vl", "llava", "local-vlm"].includes(selectedModel.value);
    });
    const selectedProvider = computed(() => {
      if (selectedModel.value.startsWith("gpt-")) return "openai";
      if (selectedModel.value === "claude-vision") return "anthropic";
      return "openai";
    });
    async function checkApiStatus() {
      try {
        const response = await fetch("/weyl/api/status");
        const result = await response.json();
        if (result.status === "success") {
          apiKeyStatus.value = result.providers;
        }
      } catch (error) {
        console.warn("Failed to check API status:", error);
      }
    }
    onMounted(() => {
      checkApiStatus();
    });
    function selectPreset(preset) {
      selectedPreset.value = preset.id;
      prompt.value = preset.prompt;
    }
    async function loadDepthMapAsFloat32Array(depthMapUrl) {
      if (!depthMapUrl) return void 0;
      if (!isValidExternalURL(depthMapUrl, { allowData: true, allowBlob: true, allowHttp: true })) {
        console.warn("[Security] Blocked depth map URL:", depthMapUrl.substring(0, 50));
        return void 0;
      }
      try {
        const img = new Image();
        img.crossOrigin = "anonymous";
        await new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = reject;
          img.src = depthMapUrl;
        });
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) return void 0;
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const depthArray = new Float32Array(img.width * img.height);
        for (let i = 0; i < depthArray.length; i++) {
          const r = imageData.data[i * 4];
          const g = imageData.data[i * 4 + 1];
          const b = imageData.data[i * 4 + 2];
          depthArray[i] = (r + g + b) / (3 * 255);
        }
        return depthArray;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to load depth map:", error);
        return void 0;
      }
    }
    async function captureCurrentFrameImage() {
      try {
        const canvas = document.querySelector(".viewport-content canvas");
        if (!canvas) return void 0;
        const ctx = canvas.getContext("2d") || canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!ctx) return void 0;
        if (ctx instanceof WebGLRenderingContext || ctx instanceof WebGL2RenderingContext) {
          const width = canvas.width;
          const height = canvas.height;
          const pixels = new Uint8Array(width * height * 4);
          ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
          const imageData = new ImageData(width, height);
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const srcIdx = ((height - 1 - y) * width + x) * 4;
              const dstIdx = (y * width + x) * 4;
              imageData.data[dstIdx] = pixels[srcIdx];
              imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
              imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
              imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
          }
          return imageData;
        }
        if (ctx instanceof CanvasRenderingContext2D) {
          return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        return void 0;
      } catch (error) {
        console.warn("[PathSuggestionDialog] Failed to capture frame:", error);
        return void 0;
      }
    }
    async function suggestPaths() {
      if (!prompt.value.trim()) {
        status.value = "error";
        statusMessage.value = "Please enter a motion description";
        return;
      }
      status.value = "loading";
      statusMessage.value = "Analyzing scene and generating suggestions...";
      suggestions.value = [];
      selectedSuggestion.value = null;
      try {
        motionIntentResolver.setConfig({
          modelId: selectedModel.value,
          apiEndpoint: isLocalModel.value ? localEndpoint.value : void 0
        });
        const depthMap = await loadDepthMapAsFloat32Array(store.depthMap);
        const frameImage = await captureCurrentFrameImage();
        const context = {
          compositionId: store.activeCompositionId,
          width: store.width,
          height: store.height,
          frameCount: store.frameCount,
          fps: store.fps,
          selectedLayerIds: store.selectedLayerIds,
          currentFrame: store.currentFrame,
          depthMap,
          frameImage
        };
        const result = await motionIntentResolver.resolve(prompt.value, context, selectedModel.value);
        const items = [];
        if (result.cameraIntents) {
          for (const intent of result.cameraIntents) {
            items.push({
              type: "camera",
              description: `${intent.type} motion - ${intent.intensity}`,
              confidence: 0.8,
              duration: intent.durationFrames,
              intent
            });
          }
        }
        if (result.splineIntents) {
          for (const intent of result.splineIntents) {
            items.push({
              type: "spline",
              description: `${intent.usage} - ${intent.suggestedPoints.length} point path`,
              confidence: 0.9,
              points: intent.suggestedPoints.map((p) => ({ x: p.x, y: p.y, depth: p.depth })),
              intent
            });
          }
        }
        suggestions.value = items;
        status.value = "success";
        statusMessage.value = `Found ${items.length} suggestion${items.length !== 1 ? "s" : ""}`;
        if (items.length > 0) {
          selectedSuggestion.value = 0;
        }
        if (showPreview.value) {
          emit("preview", suggestions.value);
        }
      } catch (error) {
        status.value = "error";
        statusMessage.value = `Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`;
      }
    }
    function acceptSuggestion() {
      if (selectedSuggestion.value === null) return;
      const suggestion = suggestions.value[selectedSuggestion.value];
      const result = {
        keyframes: [],
        splines: []
      };
      if (suggestion.type === "camera") {
        const translation = motionIntentTranslator.translateCameraIntent(
          suggestion.intent,
          store.width,
          store.height,
          store.frameCount
        );
        result.keyframes = translation.keyframeBatches;
      } else if (suggestion.type === "spline") {
        const translation = motionIntentTranslator.translateSplineIntent(
          suggestion.intent,
          store.width,
          store.height
        );
        result.splines = translation.newSplines || [];
      }
      emit("accept", result);
      emit("close");
    }
    function cancel() {
      emit("close");
    }
    watch(showPreview, (show) => {
      if (show && suggestions.value.length > 0) {
        emit("preview", suggestions.value);
      } else {
        emit("preview", []);
      }
    });
    function handleKeydown(e) {
      if (e.key === "Escape") {
        cancel();
      } else if (e.key === "Enter" && e.ctrlKey) {
        suggestPaths();
      }
    }
    onMounted(() => {
      window.addEventListener("keydown", handleKeydown);
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dialog-overlay",
          onClick: withModifiers(cancel, ["self"])
        }, [
          createBaseVNode("div", _hoisted_1$4, [
            createBaseVNode("div", { class: "dialog-header" }, [
              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "dialog-title" }, "AI Path Suggestion", -1)),
              createBaseVNode("button", {
                class: "close-btn",
                onClick: cancel
              }, "")
            ]),
            createBaseVNode("div", _hoisted_2$4, [
              createBaseVNode("div", _hoisted_3$4, [
                _cache[8] || (_cache[8] = createBaseVNode("label", { class: "section-label" }, "Vision Model", -1)),
                createBaseVNode("div", _hoisted_4$4, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedModel.value = $event),
                    class: "select-input"
                  }, [..._cache[5] || (_cache[5] = [
                    createBaseVNode("option", { value: "rule-based" }, "Rule-Based (Offline)", -1),
                    createBaseVNode("optgroup", { label: "Cloud Models" }, [
                      createBaseVNode("option", { value: "gpt-4o" }, "OpenAI GPT-4o"),
                      createBaseVNode("option", { value: "gpt-4v" }, "OpenAI GPT-4V"),
                      createBaseVNode("option", { value: "claude-vision" }, "Claude Vision")
                    ], -1),
                    createBaseVNode("optgroup", { label: "Local Models" }, [
                      createBaseVNode("option", { value: "qwen2-vl" }, "Qwen2-VL"),
                      createBaseVNode("option", { value: "qwen-vl" }, "Qwen-VL"),
                      createBaseVNode("option", { value: "llava" }, "LLaVA"),
                      createBaseVNode("option", { value: "local-vlm" }, "Custom Local VLM")
                    ], -1)
                  ])], 512), [
                    [vModelSelect, selectedModel.value]
                  ])
                ]),
                isCloudModel.value ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
                  createBaseVNode("span", {
                    class: normalizeClass(["api-status", { available: apiKeyStatus.value[selectedProvider.value], unavailable: !apiKeyStatus.value[selectedProvider.value] }])
                  }, [
                    _cache[6] || (_cache[6] = createBaseVNode("span", { class: "status-dot" }, null, -1)),
                    createTextVNode(" " + toDisplayString(apiKeyStatus.value[selectedProvider.value] ? "API key configured on server" : "API key not configured"), 1)
                  ], 2),
                  createBaseVNode("button", {
                    class: "btn btn-small",
                    onClick: checkApiStatus
                  }, "Refresh")
                ])) : createCommentVNode("", true),
                isLocalModel.value ? (openBlock(), createElementBlock("div", _hoisted_6$4, [
                  _cache[7] || (_cache[7] = createBaseVNode("label", null, "Endpoint:", -1)),
                  withDirectives(createBaseVNode("input", {
                    type: "text",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => localEndpoint.value = $event),
                    class: "text-input",
                    placeholder: "http://localhost:8188/api/vlm"
                  }, null, 512), [
                    [vModelText, localEndpoint.value]
                  ])
                ])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_7$4, [
                _cache[9] || (_cache[9] = createBaseVNode("label", { class: "section-label" }, "Motion Description", -1)),
                createBaseVNode("div", _hoisted_8$4, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(promptPresets, (preset) => {
                    return createBaseVNode("button", {
                      key: preset.id,
                      class: normalizeClass(["preset-btn", { active: selectedPreset.value === preset.id }]),
                      onClick: ($event) => selectPreset(preset)
                    }, toDisplayString(preset.label), 11, _hoisted_9$4);
                  }), 64))
                ]),
                withDirectives(createBaseVNode("textarea", {
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => prompt.value = $event),
                  class: "prompt-input",
                  rows: "3",
                  placeholder: "Describe the motion you want, e.g., 'dolly in slowly' or 'orbit around the subject'"
                }, null, 512), [
                  [vModelText, prompt.value]
                ])
              ]),
              status.value !== "idle" ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
                createBaseVNode("div", {
                  class: normalizeClass(["status-bar", status.value])
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_11$4)) : createCommentVNode("", true),
                  createBaseVNode("span", _hoisted_12$3, toDisplayString(statusMessage.value), 1)
                ], 2)
              ])) : createCommentVNode("", true),
              suggestions.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_13$3, [
                _cache[10] || (_cache[10] = createBaseVNode("label", { class: "section-label" }, "Suggested Paths", -1)),
                createBaseVNode("div", _hoisted_14$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(suggestions.value, (suggestion, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["suggestion-item", { selected: selectedSuggestion.value === index }]),
                      onClick: ($event) => selectedSuggestion.value = index
                    }, [
                      createBaseVNode("div", _hoisted_16$2, [
                        createBaseVNode("span", _hoisted_17$2, toDisplayString(suggestion.type), 1),
                        createBaseVNode("span", _hoisted_18$2, toDisplayString(Math.round(suggestion.confidence * 100)) + "% ", 1)
                      ]),
                      createBaseVNode("div", _hoisted_19$2, toDisplayString(suggestion.description), 1),
                      createBaseVNode("div", _hoisted_20$2, [
                        suggestion.points ? (openBlock(), createElementBlock("span", _hoisted_21$2, toDisplayString(suggestion.points.length) + " points", 1)) : createCommentVNode("", true),
                        suggestion.duration ? (openBlock(), createElementBlock("span", _hoisted_22$2, toDisplayString(suggestion.duration) + " frames", 1)) : createCommentVNode("", true)
                      ])
                    ], 10, _hoisted_15$2);
                  }), 128))
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_23$2, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showPreview.value = $event)
                  }, null, 512), [
                    [vModelCheckbox, showPreview.value]
                  ]),
                  _cache[11] || (_cache[11] = createTextVNode(" Show preview on canvas ", -1))
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_24$1, [
              createBaseVNode("div", _hoisted_25$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: suggestPaths,
                  disabled: status.value === "loading"
                }, [
                  status.value === "loading" ? (openBlock(), createElementBlock("span", _hoisted_27$1)) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(status.value === "loading" ? "Analyzing..." : "Suggest Paths"), 1)
                ], 8, _hoisted_26$1)
              ]),
              createBaseVNode("div", _hoisted_28$1, [
                createBaseVNode("button", {
                  class: "btn btn-secondary",
                  onClick: cancel
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "btn btn-primary",
                  onClick: acceptSuggestion,
                  disabled: selectedSuggestion.value === null
                }, " Accept ", 8, _hoisted_29$1)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const PathSuggestionDialog = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-2082f292"]]);

const _hoisted_1$3 = ["viewBox"];
const _hoisted_2$3 = ["width", "height"];
const _hoisted_3$3 = ["d"];
const _hoisted_4$3 = {
  key: 0,
  width: "100%",
  height: "100%",
  fill: "url(#preview-grid)"
};
const _hoisted_5$3 = ["onClick"];
const _hoisted_6$3 = ["d", "stroke"];
const _hoisted_7$3 = ["d", "stroke", "stroke-dasharray"];
const _hoisted_8$3 = { key: 2 };
const _hoisted_9$3 = ["cx", "cy", "stroke"];
const _hoisted_10$3 = ["cx", "cy", "fill"];
const _hoisted_11$3 = ["x", "y", "fill"];
const _hoisted_12$2 = ["x", "y"];
const _hoisted_13$2 = ["x", "y", "fill"];
const _hoisted_14$2 = ["cx", "cy", "stroke"];
const _hoisted_15$1 = ["x1", "y1", "x2", "y2", "stroke"];
const _hoisted_16$1 = ["x", "y", "fill"];
const _hoisted_17$1 = { key: 1 };
const _hoisted_18$1 = ["cx", "cy"];
const _hoisted_19$1 = ["cx", "cy"];
const _hoisted_20$1 = {
  key: 0,
  class: "legend"
};
const _hoisted_21$1 = ["onClick"];
const _hoisted_22$1 = { class: "legend-text" };
const _hoisted_23$1 = {
  key: 1,
  class: "instructions"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "PathPreviewOverlay",
  props: {
    width: {},
    height: {},
    suggestions: {},
    selectedIndex: {},
    showGrid: { type: Boolean, default: true },
    showPoints: { type: Boolean, default: true },
    showLabels: { type: Boolean, default: true },
    showDepth: { type: Boolean, default: true },
    showLegend: { type: Boolean, default: true },
    showAnimation: { type: Boolean, default: true },
    gridSize: { default: 50 }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const overlayRef = ref(null);
    const animatedPosition = ref(null);
    let animationFrame = 0;
    let animationId = null;
    const pathColors = [
      "#4a90d9",
      // Blue
      "#d94a4a",
      // Red
      "#4ad94a",
      // Green
      "#d9d94a",
      // Yellow
      "#d94ad9",
      // Magenta
      "#4ad9d9"
      // Cyan
    ];
    const overlayStyle = computed(() => ({
      width: `${props.width}px`,
      height: `${props.height}px`
    }));
    const cameraSuggestions = computed(() => {
      return props.suggestions.filter((s) => s.type === "camera" && s.points && s.points.length >= 2).map((s) => ({
        type: s.description?.split(" ")[0] || "Camera",
        startX: s.points[0].x,
        startY: s.points[0].y,
        endX: s.points[s.points.length - 1].x,
        endY: s.points[s.points.length - 1].y
      }));
    });
    function getPathColor(index, opacity) {
      const baseColor = pathColors[index % pathColors.length];
      if (opacity === 1) return baseColor;
      const r = parseInt(baseColor.slice(1, 3), 16);
      const g = parseInt(baseColor.slice(3, 5), 16);
      const b = parseInt(baseColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    function pointsToPathData(points) {
      if (points.length < 2) return "";
      let d = `M ${points[0].x} ${points[0].y}`;
      if (points.length === 2) {
        d += ` L ${points[1].x} ${points[1].y}`;
      } else {
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[Math.max(0, i - 1)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(points.length - 1, i + 2)];
          const tension = 0.3;
          const cp1x = p1.x + (p2.x - p0.x) * tension;
          const cp1y = p1.y + (p2.y - p0.y) * tension;
          const cp2x = p2.x - (p3.x - p1.x) * tension;
          const cp2y = p2.y - (p3.y - p1.y) * tension;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
        }
      }
      return d;
    }
    function startAnimation() {
      if (props.selectedIndex === null) {
        animatedPosition.value = null;
        return;
      }
      const suggestion = props.suggestions[props.selectedIndex];
      if (!suggestion.points || suggestion.points.length < 2) {
        animatedPosition.value = null;
        return;
      }
      const points = suggestion.points;
      const totalLength = points.length - 1;
      function animate() {
        animationFrame = (animationFrame + 0.5) % (totalLength * 60);
        const t = animationFrame / (totalLength * 60);
        const segmentIndex = Math.min(Math.floor(t * totalLength), totalLength - 1);
        const segmentT = t * totalLength - segmentIndex;
        const p1 = points[segmentIndex];
        const p2 = points[segmentIndex + 1];
        animatedPosition.value = {
          x: p1.x + (p2.x - p1.x) * segmentT,
          y: p1.y + (p2.y - p1.y) * segmentT
        };
        animationId = requestAnimationFrame(animate);
      }
      animate();
    }
    function stopAnimation() {
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      animatedPosition.value = null;
    }
    watch(() => props.suggestions, (newSuggestions) => {
      for (const suggestion of newSuggestions) {
        if (suggestion.points && !suggestion.pathData) {
          suggestion.pathData = pointsToPathData(suggestion.points);
        }
      }
    }, { immediate: true, deep: true });
    watch(() => props.selectedIndex, () => {
      stopAnimation();
      if (props.showAnimation) {
        startAnimation();
      }
    });
    onMounted(() => {
      if (props.showAnimation && props.selectedIndex !== null) {
        startAnimation();
      }
    });
    onUnmounted(() => {
      stopAnimation();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "overlayRef",
        ref: overlayRef,
        class: "path-preview-overlay",
        style: normalizeStyle(overlayStyle.value)
      }, [
        (openBlock(), createElementBlock("svg", {
          class: "preview-svg",
          viewBox: `0 0 ${__props.width} ${__props.height}`,
          preserveAspectRatio: "xMidYMid meet"
        }, [
          createBaseVNode("defs", null, [
            createBaseVNode("pattern", {
              id: "preview-grid",
              width: __props.gridSize,
              height: __props.gridSize,
              patternUnits: "userSpaceOnUse"
            }, [
              createBaseVNode("path", {
                d: `M ${__props.gridSize} 0 L 0 0 0 ${__props.gridSize}`,
                fill: "none",
                stroke: "rgba(255,255,255,0.05)",
                "stroke-width": "1"
              }, null, 8, _hoisted_3$3)
            ], 8, _hoisted_2$3),
            _cache[0] || (_cache[0] = createStaticVNode('<filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%" data-v-23dc1ec0><feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" data-v-23dc1ec0></feGaussianBlur><feMerge data-v-23dc1ec0><feMergeNode in="blur" data-v-23dc1ec0></feMergeNode><feMergeNode in="SourceGraphic" data-v-23dc1ec0></feMergeNode></feMerge></filter><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse" data-v-23dc1ec0><path d="M 0 0 L 10 5 L 0 10 z" fill="#4a90d9" data-v-23dc1ec0></path></marker>', 2))
          ]),
          __props.showGrid ? (openBlock(), createElementBlock("rect", _hoisted_4$3)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: index,
              class: normalizeClass(["path-group", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 0,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 0.3),
                "stroke-width": "8",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                filter: "url(#path-glow)"
              }, null, 8, _hoisted_6$3)) : createCommentVNode("", true),
              suggestion.pathData ? (openBlock(), createElementBlock("path", {
                key: 1,
                d: suggestion.pathData,
                fill: "none",
                stroke: getPathColor(index, 1),
                "stroke-width": "2",
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-dasharray": __props.selectedIndex === index ? "none" : "8,4",
                "marker-end": "url(#arrow)"
              }, null, 8, _hoisted_7$3)) : createCommentVNode("", true),
              suggestion.points && __props.showPoints ? (openBlock(), createElementBlock("g", _hoisted_8$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(suggestion.points, (point, pIndex) => {
                  return openBlock(), createElementBlock("g", {
                    key: pIndex,
                    class: "control-point"
                  }, [
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "8",
                      fill: "none",
                      stroke: getPathColor(index, 0.5),
                      "stroke-width": "2"
                    }, null, 8, _hoisted_9$3),
                    createBaseVNode("circle", {
                      cx: point.x,
                      cy: point.y,
                      r: "4",
                      fill: getPathColor(index, 1)
                    }, null, 8, _hoisted_10$3),
                    __props.showLabels ? (openBlock(), createElementBlock("text", {
                      key: 0,
                      x: point.x + 12,
                      y: point.y + 4,
                      class: "point-label",
                      fill: getPathColor(index, 0.8)
                    }, toDisplayString(pIndex + 1), 9, _hoisted_11$3)) : createCommentVNode("", true),
                    point.depth !== void 0 && __props.showDepth ? (openBlock(), createElementBlock("text", {
                      key: 1,
                      x: point.x + 12,
                      y: point.y + 16,
                      class: "depth-label"
                    }, " z: " + toDisplayString(point.depth.toFixed(2)), 9, _hoisted_12$2)) : createCommentVNode("", true)
                  ]);
                }), 128))
              ])) : createCommentVNode("", true)
            ], 10, _hoisted_5$3);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(cameraSuggestions.value, (suggestion, index) => {
            return openBlock(), createElementBlock("g", {
              key: `cam-${index}`
            }, [
              createBaseVNode("g", {
                class: normalizeClass(["camera-indicator", { selected: __props.selectedIndex === index }])
              }, [
                createBaseVNode("rect", {
                  x: suggestion.startX - 12,
                  y: suggestion.startY - 8,
                  width: "24",
                  height: "16",
                  rx: "2",
                  fill: getPathColor(index, 0.8)
                }, null, 8, _hoisted_13$2),
                createBaseVNode("circle", {
                  cx: suggestion.startX + 8,
                  cy: suggestion.startY,
                  r: "4",
                  fill: "none",
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2"
                }, null, 8, _hoisted_14$2),
                createBaseVNode("line", {
                  x1: suggestion.startX,
                  y1: suggestion.startY,
                  x2: suggestion.endX,
                  y2: suggestion.endY,
                  stroke: getPathColor(index, 1),
                  "stroke-width": "2",
                  "stroke-dasharray": "4,2",
                  "marker-end": "url(#arrow)"
                }, null, 8, _hoisted_15$1),
                createBaseVNode("text", {
                  x: (suggestion.startX + suggestion.endX) / 2,
                  y: (suggestion.startY + suggestion.endY) / 2 - 10,
                  class: "motion-label",
                  fill: getPathColor(index, 1)
                }, toDisplayString(suggestion.type), 9, _hoisted_16$1)
              ], 2)
            ]);
          }), 128)),
          animatedPosition.value && __props.showAnimation ? (openBlock(), createElementBlock("g", _hoisted_17$1, [
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "6",
              fill: "#fff",
              class: "animated-dot"
            }, null, 8, _hoisted_18$1),
            createBaseVNode("circle", {
              cx: animatedPosition.value.x,
              cy: animatedPosition.value.y,
              r: "12",
              fill: "none",
              stroke: "#fff",
              "stroke-width": "2",
              opacity: "0.5",
              class: "animated-ring"
            }, null, 8, _hoisted_19$1)
          ])) : createCommentVNode("", true)
        ], 8, _hoisted_1$3)),
        __props.suggestions.length > 0 && __props.showLegend ? (openBlock(), createElementBlock("div", _hoisted_20$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.suggestions, (suggestion, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass(["legend-item", { selected: __props.selectedIndex === index }]),
              onClick: ($event) => emit("select", index)
            }, [
              createBaseVNode("span", {
                class: "legend-color",
                style: normalizeStyle({ backgroundColor: getPathColor(index, 1) })
              }, null, 4),
              createBaseVNode("span", _hoisted_22$1, toDisplayString(suggestion.description || `Path ${index + 1}`), 1)
            ], 10, _hoisted_21$1);
          }), 128))
        ])) : createCommentVNode("", true),
        __props.suggestions.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_23$1, " Click a path to select it. Press Enter to accept. ")) : createCommentVNode("", true)
      ], 4);
    };
  }
});

const PathPreviewOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-23dc1ec0"]]);

const _hoisted_1$2 = { class: "preview-header" };
const _hoisted_2$2 = { class: "header-left" };
const _hoisted_3$2 = { class: "resolution-badge" };
const _hoisted_4$2 = { class: "header-center" };
const _hoisted_5$2 = { class: "playback-controls" };
const _hoisted_6$2 = { class: "timecode" };
const _hoisted_7$2 = { class: "header-right" };
const _hoisted_8$2 = ["title"];
const _hoisted_9$2 = ["width", "height"];
const _hoisted_10$2 = {
  key: 0,
  class: "rendering-overlay"
};
const _hoisted_11$2 = { class: "frame-info-overlay" };
const _hoisted_12$1 = { key: 0 };
const _hoisted_13$1 = { class: "progress-bar" };
const _hoisted_14$1 = ["max", "value"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "HDPreviewWindow",
  props: {
    visible: { type: Boolean },
    engine: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const store = useCompositorStore();
    const { currentFrame, frameCount, fps, isPlaying } = storeToRefs(store);
    const overlayRef = ref(null);
    const canvasContainerRef = ref(null);
    const previewCanvas = ref(null);
    const previewScale = ref("fit");
    const isFullscreen = ref(false);
    const isRendering = ref(false);
    const renderTime = ref(null);
    const containerWidth = ref(1280);
    const containerHeight = ref(720);
    const compWidth = computed(() => store.getActiveComp()?.settings.width || 1024);
    const compHeight = computed(() => store.getActiveComp()?.settings.height || 576);
    const canvasWidth = computed(() => {
      if (previewScale.value === "fit") {
        const aspect = compWidth.value / compHeight.value;
        const maxWidth = containerWidth.value - 48;
        const maxHeight = containerHeight.value - 140;
        if (maxWidth / maxHeight > aspect) {
          return Math.round(maxHeight * aspect);
        }
        return maxWidth;
      }
      return Math.round(compWidth.value * Number(previewScale.value));
    });
    const canvasHeight = computed(() => {
      if (previewScale.value === "fit") {
        const aspect = compWidth.value / compHeight.value;
        const maxWidth = containerWidth.value - 48;
        const maxHeight = containerHeight.value - 140;
        if (maxWidth / maxHeight > aspect) {
          return maxHeight;
        }
        return Math.round(maxWidth / aspect);
      }
      return Math.round(compHeight.value * Number(previewScale.value));
    });
    const resolutionLabel = computed(() => {
      return `${compWidth.value}x${compHeight.value}`;
    });
    const formattedTimecode = computed(() => {
      const seconds = currentFrame.value / fps.value;
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const frames = currentFrame.value % fps.value;
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    const containerStyle = computed(() => ({
      width: isFullscreen.value ? "100vw" : "90vw",
      height: isFullscreen.value ? "100vh" : "90vh",
      maxWidth: isFullscreen.value ? "none" : "1600px",
      maxHeight: isFullscreen.value ? "none" : "900px"
    }));
    const canvasStyle = computed(() => ({
      width: `${canvasWidth.value}px`,
      height: `${canvasHeight.value}px`
    }));
    function togglePlayback() {
      store.togglePlayback();
    }
    function goToStart() {
      store.setCurrentFrame(0);
    }
    function goToEnd() {
      store.setCurrentFrame(frameCount.value - 1);
    }
    function stepForward() {
      store.setCurrentFrame(Math.min(currentFrame.value + 1, frameCount.value - 1));
    }
    function stepBackward() {
      store.setCurrentFrame(Math.max(currentFrame.value - 1, 0));
    }
    function onScrub(e) {
      const target = e.target;
      store.setCurrentFrame(parseInt(target.value, 10));
    }
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        overlayRef.value?.requestFullscreen();
        isFullscreen.value = true;
      } else {
        document.exitFullscreen();
        isFullscreen.value = false;
      }
    }
    async function renderFrame() {
      if (!previewCanvas.value || !props.engine) return;
      const start = performance.now();
      isRendering.value = true;
      try {
        const ctx = previewCanvas.value.getContext("2d");
        if (!ctx) return;
        const sourceCanvas = props.engine.getCanvas?.() || props.engine.renderer?.domElement;
        if (sourceCanvas) {
          ctx.clearRect(0, 0, canvasWidth.value, canvasHeight.value);
          ctx.drawImage(
            sourceCanvas,
            0,
            0,
            sourceCanvas.width,
            sourceCanvas.height,
            0,
            0,
            canvasWidth.value,
            canvasHeight.value
          );
        }
        renderTime.value = performance.now() - start;
      } finally {
        isRendering.value = false;
      }
    }
    function updateContainerSize() {
      if (canvasContainerRef.value) {
        const rect = canvasContainerRef.value.getBoundingClientRect();
        containerWidth.value = rect.width;
        containerHeight.value = rect.height;
      }
    }
    watch(() => props.visible, async (visible) => {
      if (visible) {
        await nextTick();
        overlayRef.value?.focus();
        updateContainerSize();
        renderFrame();
      }
    });
    watch(currentFrame, () => {
      if (props.visible) {
        renderFrame();
      }
    });
    onMounted(() => {
      window.addEventListener("resize", updateContainerSize);
      document.addEventListener("fullscreenchange", () => {
        isFullscreen.value = !!document.fullscreenElement;
      });
    });
    onUnmounted(() => {
      window.removeEventListener("resize", updateContainerSize);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        __props.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "hd-preview-overlay",
          onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.$emit("close"), ["escape"])),
          tabindex: "0",
          ref_key: "overlayRef",
          ref: overlayRef
        }, [
          createBaseVNode("div", {
            class: "hd-preview-container",
            style: normalizeStyle(containerStyle.value)
          }, [
            createBaseVNode("div", _hoisted_1$2, [
              createBaseVNode("div", _hoisted_2$2, [
                _cache[3] || (_cache[3] = createBaseVNode("span", { class: "preview-title" }, "HD Preview", -1)),
                createBaseVNode("span", _hoisted_3$2, toDisplayString(resolutionLabel.value), 1)
              ]),
              createBaseVNode("div", _hoisted_4$2, [
                createBaseVNode("div", _hoisted_5$2, [
                  createBaseVNode("button", {
                    onClick: goToStart,
                    title: "Go to Start"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: stepBackward,
                    title: "Step Back"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: togglePlayback,
                    class: normalizeClass({ playing: unref(isPlaying) })
                  }, toDisplayString(unref(isPlaying) ? "" : ""), 3),
                  createBaseVNode("button", {
                    onClick: stepForward,
                    title: "Step Forward"
                  }, ""),
                  createBaseVNode("button", {
                    onClick: goToEnd,
                    title: "Go to End"
                  }, "")
                ]),
                createBaseVNode("div", _hoisted_6$2, toDisplayString(formattedTimecode.value), 1)
              ]),
              createBaseVNode("div", _hoisted_7$2, [
                withDirectives(createBaseVNode("select", {
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => previewScale.value = $event),
                  class: "scale-select"
                }, [..._cache[4] || (_cache[4] = [
                  createBaseVNode("option", { value: "0.5" }, "50%", -1),
                  createBaseVNode("option", { value: "0.75" }, "75%", -1),
                  createBaseVNode("option", { value: "1" }, "100%", -1),
                  createBaseVNode("option", { value: "1.5" }, "150%", -1),
                  createBaseVNode("option", { value: "2" }, "200%", -1),
                  createBaseVNode("option", { value: "fit" }, "Fit", -1)
                ])], 512), [
                  [vModelSelect, previewScale.value]
                ]),
                createBaseVNode("button", {
                  onClick: toggleFullscreen,
                  title: isFullscreen.value ? "Exit Fullscreen" : "Enter Fullscreen"
                }, toDisplayString(isFullscreen.value ? "" : ""), 9, _hoisted_8$2),
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close")),
                  title: "Close Preview (Esc)"
                }, "")
              ])
            ]),
            createBaseVNode("div", {
              class: "canvas-container",
              ref_key: "canvasContainerRef",
              ref: canvasContainerRef
            }, [
              createBaseVNode("canvas", {
                ref_key: "previewCanvas",
                ref: previewCanvas,
                width: canvasWidth.value,
                height: canvasHeight.value,
                style: normalizeStyle(canvasStyle.value)
              }, null, 12, _hoisted_9$2),
              isRendering.value ? (openBlock(), createElementBlock("div", _hoisted_10$2, [
                _cache[5] || (_cache[5] = createBaseVNode("div", { class: "spinner" }, null, -1)),
                createBaseVNode("span", null, "Rendering frame " + toDisplayString(unref(currentFrame)) + "...", 1)
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_11$2, [
                createBaseVNode("span", null, "Frame " + toDisplayString(unref(currentFrame)) + " / " + toDisplayString(unref(frameCount)), 1),
                renderTime.value ? (openBlock(), createElementBlock("span", _hoisted_12$1, toDisplayString(renderTime.value.toFixed(1)) + "ms", 1)) : createCommentVNode("", true)
              ])
            ], 512),
            createBaseVNode("div", _hoisted_13$1, [
              createBaseVNode("div", {
                class: "progress-fill",
                style: normalizeStyle({ width: `${unref(currentFrame) / (unref(frameCount) - 1) * 100}%` })
              }, null, 4),
              createBaseVNode("input", {
                type: "range",
                min: 0,
                max: unref(frameCount) - 1,
                value: unref(currentFrame),
                onInput: onScrub,
                class: "scrubber"
              }, null, 40, _hoisted_14$1)
            ])
          ], 4)
        ], 544)) : createCommentVNode("", true)
      ]);
    };
  }
});

const HDPreviewWindow = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-6ea007fd"]]);

const _hoisted_1$1 = ["title"];
const _hoisted_2$1 = { class: "memory-bar" };
const _hoisted_3$1 = { class: "memory-text" };
const _hoisted_4$1 = { class: "details-header" };
const _hoisted_5$1 = {
  key: 0,
  class: "gpu-info"
};
const _hoisted_6$1 = { class: "category-breakdown" };
const _hoisted_7$1 = { class: "category-name" };
const _hoisted_8$1 = { class: "category-value" };
const _hoisted_9$1 = { key: 0 };
const _hoisted_10$1 = {
  key: 2,
  class: "details-footer"
};
const _hoisted_11$1 = ["disabled"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "MemoryIndicator",
  setup(__props) {
    const showDetails = ref(false);
    const isCleaningUp = ref(false);
    const usagePercent = computed(() => Math.round(memoryState.usagePercent.value * 100));
    const totalUsage = computed(() => memoryState.totalUsageMB.value);
    const available = computed(() => memoryState.availableVRAM.value);
    const warningLevel = computed(() => memoryState.warningLevel.value);
    const gpuInfo = computed(() => memoryState.gpuInfo.value);
    const usageByCategory = computed(() => memoryState.usageByCategory.value);
    const warning = computed(() => getWarning());
    const unloadableCount = computed(() => unloadableItems.value.length);
    const warningClass = computed(() => ({
      "level-none": warningLevel.value === "none",
      "level-info": warningLevel.value === "info",
      "level-warning": warningLevel.value === "warning",
      "level-critical": warningLevel.value === "critical"
    }));
    const usageText = computed(() => {
      return `${formatMB(totalUsage.value)} / ${formatMB(available.value)}`;
    });
    const tooltipText = computed(() => {
      const percent = usagePercent.value;
      if (warningLevel.value === "critical") {
        return `CRITICAL: ${percent}% GPU memory used - cleanup needed!`;
      }
      if (warningLevel.value === "warning") {
        return `Warning: ${percent}% GPU memory used - consider cleanup`;
      }
      return `GPU Memory: ${percent}% used`;
    });
    function formatMB(mb) {
      if (mb >= 1e3) {
        return `${(mb / 1e3).toFixed(1)}GB`;
      }
      return `${Math.round(mb)}MB`;
    }
    function formatCategory(category) {
      const labels = {
        model: "AI Models",
        texture: "Textures",
        framebuffer: "Frame Cache",
        particles: "Particles",
        geometry: "3D Geometry",
        audio: "Audio",
        other: "Other"
      };
      return labels[category] || category;
    }
    async function performCleanup() {
      isCleaningUp.value = true;
      try {
        const target = totalUsage.value * 0.3;
        await freeMemory(target);
      } finally {
        isCleaningUp.value = false;
      }
    }
    onMounted(() => {
      initializeGPUDetection();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["memory-indicator", warningClass.value]),
        onClick: _cache[2] || (_cache[2] = ($event) => showDetails.value = !showDetails.value),
        title: tooltipText.value
      }, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("div", {
            class: "memory-fill",
            style: normalizeStyle({ width: `${usagePercent.value}%` })
          }, null, 4)
        ]),
        createBaseVNode("span", _hoisted_3$1, toDisplayString(usageText.value), 1),
        showDetails.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "memory-details",
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_4$1, [
            _cache[4] || (_cache[4] = createBaseVNode("span", null, "GPU Memory Usage", -1)),
            createBaseVNode("button", {
              class: "close-details",
              onClick: _cache[0] || (_cache[0] = ($event) => showDetails.value = false)
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("i", { class: "pi pi-times" }, null, -1)
            ])])
          ]),
          gpuInfo.value ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
            createBaseVNode("small", null, toDisplayString(gpuInfo.value.renderer), 1),
            createBaseVNode("small", null, "~" + toDisplayString(formatMB(gpuInfo.value.estimatedVRAM)) + " VRAM (" + toDisplayString(gpuInfo.value.tier) + ")", 1)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_6$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(usageByCategory.value, (value, category) => {
              return withDirectives((openBlock(), createElementBlock("div", {
                key: category,
                class: "category-row"
              }, [
                createBaseVNode("span", _hoisted_7$1, toDisplayString(formatCategory(category)), 1),
                createBaseVNode("span", _hoisted_8$1, toDisplayString(formatMB(value)), 1)
              ])), [
                [vShow, value > 0]
              ]);
            }), 128))
          ]),
          warning.value ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(["warning-box", warning.value.level])
          }, [
            createBaseVNode("p", null, toDisplayString(warning.value.message), 1),
            warning.value.suggestions.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_9$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(warning.value.suggestions.slice(0, 3), (suggestion, i) => {
                return openBlock(), createElementBlock("li", { key: i }, toDisplayString(suggestion), 1);
              }), 128))
            ])) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          unloadableCount.value > 0 ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
            createBaseVNode("button", {
              class: "cleanup-btn",
              onClick: performCleanup,
              disabled: isCleaningUp.value
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("i", { class: "pi pi-trash" }, null, -1)),
              createTextVNode(" " + toDisplayString(isCleaningUp.value ? "Cleaning..." : `Free Memory (${unloadableCount.value} items)`), 1)
            ], 8, _hoisted_11$1)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$1);
    };
  }
});

const MemoryIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-75722aa1"]]);

const useThemeStore = defineStore("theme", {
  state: () => ({
    currentTheme: "violet"
  }),
  getters: {
    themeGradient: (state) => `var(--weyl-theme-${state.currentTheme}-gradient)`,
    themePrimary: (state) => `var(--weyl-theme-${state.currentTheme}-primary)`,
    themeSecondary: (state) => `var(--weyl-theme-${state.currentTheme}-secondary)`
  },
  actions: {
    setTheme(theme) {
      this.currentTheme = theme;
      const root = document.documentElement;
      root.style.setProperty("--weyl-accent", `var(--weyl-theme-${theme}-primary)`);
      root.style.setProperty("--weyl-accent-secondary", `var(--weyl-theme-${theme}-secondary)`);
      root.style.setProperty("--weyl-accent-gradient", `var(--weyl-theme-${theme}-gradient)`);
      const glowColors = {
        violet: "rgba(139, 92, 246, 0.3)",
        ocean: "rgba(6, 182, 212, 0.3)",
        sunset: "rgba(245, 158, 11, 0.3)",
        forest: "rgba(16, 185, 129, 0.3)",
        ember: "rgba(239, 68, 68, 0.3)",
        mono: "rgba(107, 114, 128, 0.3)"
      };
      root.style.setProperty("--weyl-accent-glow", glowColors[theme]);
      localStorage.setItem("weyl-theme", theme);
    },
    loadSavedTheme() {
      const saved = localStorage.getItem("weyl-theme");
      if (saved && ["violet", "ocean", "sunset", "forest", "ember", "mono"].includes(saved)) {
        this.setTheme(saved);
      }
    }
  }
});

const _hoisted_1 = { class: "workspace-layout" };
const _hoisted_2 = {
  class: "toolbar",
  role: "toolbar",
  "aria-label": "Drawing tools"
};
const _hoisted_3 = {
  class: "tool-group labeled-tools",
  role: "group",
  "aria-label": "Selection and drawing tools"
};
const _hoisted_4 = ["aria-pressed"];
const _hoisted_5 = ["aria-pressed"];
const _hoisted_6 = ["aria-pressed"];
const _hoisted_7 = ["aria-pressed"];
const _hoisted_8 = ["aria-pressed"];
const _hoisted_9 = ["aria-pressed"];
const _hoisted_10 = { class: "tool-group segment-options" };
const _hoisted_11 = {
  key: 1,
  class: "loading-indicator"
};
const _hoisted_12 = { class: "tool-group" };
const _hoisted_13 = ["title"];
const _hoisted_14 = { class: "icon" };
const _hoisted_15 = { class: "timecode-display" };
const _hoisted_16 = { class: "tool-group" };
const _hoisted_17 = { class: "tool-group theme-selector-group" };
const _hoisted_18 = {
  key: 0,
  class: "theme-dropdown"
};
const _hoisted_19 = { class: "theme-options" };
const _hoisted_20 = ["title", "onClick"];
const _hoisted_21 = { class: "tool-group" };
const _hoisted_22 = ["disabled"];
const _hoisted_23 = ["disabled"];
const _hoisted_24 = { class: "workspace-content" };
const _hoisted_25 = { class: "panel left-panel" };
const _hoisted_26 = {
  class: "panel-tabs",
  role: "tablist",
  "aria-label": "Left panel tabs"
};
const _hoisted_27 = ["aria-selected"];
const _hoisted_28 = ["aria-selected"];
const _hoisted_29 = ["aria-selected"];
const _hoisted_30 = ["id"];
const _hoisted_31 = { class: "panel viewport-panel" };
const _hoisted_32 = { class: "viewport-header" };
const _hoisted_33 = {
  class: "viewport-tabs",
  role: "tablist",
  "aria-label": "Viewport tabs"
};
const _hoisted_34 = ["aria-selected"];
const _hoisted_35 = ["aria-selected"];
const _hoisted_36 = ["aria-selected"];
const _hoisted_37 = { class: "viewport-controls" };
const _hoisted_38 = ["aria-pressed"];
const _hoisted_39 = ["aria-pressed"];
const _hoisted_40 = { class: "viewport-content" };
const _hoisted_41 = {
  key: 0,
  class: "rulers-overlay"
};
const _hoisted_42 = { class: "ruler ruler-horizontal" };
const _hoisted_43 = { class: "ruler ruler-vertical" };
const _hoisted_44 = { class: "panel timeline-panel" };
const _hoisted_45 = { class: "panel graph-editor-panel" };
const _hoisted_46 = {
  key: 1,
  class: "panel timeline-panel"
};
const _hoisted_47 = { class: "panel right-panel" };
const _hoisted_48 = {
  class: "panel-tabs",
  role: "tablist",
  "aria-label": "Right panel tabs"
};
const _hoisted_49 = ["aria-selected"];
const _hoisted_50 = ["aria-selected"];
const _hoisted_51 = ["aria-selected"];
const _hoisted_52 = ["aria-selected"];
const _hoisted_53 = ["aria-selected"];
const _hoisted_54 = ["aria-selected"];
const _hoisted_55 = ["aria-selected"];
const _hoisted_56 = ["id"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "WorkspaceLayout",
  setup(__props) {
    const store = useCompositorStore();
    const assetStore = useAssetStore();
    const themeStore = useThemeStore();
    const showThemeSelector = ref(false);
    const currentTheme = computed(() => themeStore.currentTheme);
    const themeGradient = computed(() => themeStore.themeGradient);
    const themes = [
      { name: "violet", label: "Violet", gradient: "linear-gradient(135deg, #8B5CF6, #EC4899)" },
      { name: "ocean", label: "Ocean", gradient: "linear-gradient(135deg, #06B6D4, #3B82F6)" },
      { name: "sunset", label: "Sunset", gradient: "linear-gradient(135deg, #F59E0B, #EF4444)" },
      { name: "forest", label: "Forest", gradient: "linear-gradient(135deg, #10B981, #06B6D4)" },
      { name: "ember", label: "Ember", gradient: "linear-gradient(135deg, #EF4444, #F97316)" },
      { name: "mono", label: "Mono", gradient: "linear-gradient(135deg, #4B5563, #6B7280)" }
    ];
    function selectTheme(theme) {
      themeStore.setTheme(theme);
      showThemeSelector.value = false;
    }
    const currentTool = computed({
      get: () => store.currentTool,
      set: (tool) => store.setTool(tool)
    });
    const segmentMode = computed(() => store.segmentMode);
    const segmentPendingMask = computed(() => store.segmentPendingMask);
    const segmentIsLoading = computed(() => store.segmentIsLoading);
    function setSegmentMode(mode) {
      store.setSegmentMode(mode);
    }
    async function confirmSegmentMask() {
      await store.confirmSegmentMask();
    }
    function clearSegmentMask() {
      store.clearSegmentPendingMask();
    }
    const activeWorkspace = ref("standard");
    const leftTab = ref("project");
    const rightTab = ref("properties");
    const viewportTab = ref("composition");
    const viewZoom = ref("fit");
    const showGraphEditor = ref(false);
    const showExportDialog = ref(false);
    const showComfyUIExportDialog = ref(false);
    const showCompositionSettingsDialog = ref(false);
    const showPathSuggestionDialog = ref(false);
    const showHDPreview = ref(false);
    const pathSuggestions = ref([]);
    const selectedPathIndex = ref(null);
    const isPlaying = ref(false);
    const gpuTier = ref("cpu");
    const threeCanvasRef = ref(null);
    const canvasEngine = computed(() => threeCanvasRef.value?.engine ?? null);
    const activeCamera = computed(() => {
      const cam = store.getActiveCameraAtFrame();
      if (cam) return cam;
      return createDefaultCamera("default", compWidth.value, compHeight.value);
    });
    const viewportState = ref(createDefaultViewportState());
    const viewOptions = ref({
      showGrid: true,
      showRulers: false,
      showAxes: true,
      showCameraFrustum: true,
      showCompositionBounds: true,
      showFocalPlane: false,
      showLayerOutlines: true,
      showSafeZones: false,
      gridSize: 100,
      gridDivisions: 10
    });
    const compWidth = computed(() => store.project?.composition?.width || 1920);
    const compHeight = computed(() => store.project?.composition?.height || 1080);
    ref(60);
    const memoryUsage = ref("0 MB");
    ref(0);
    const formattedTimecode = computed(() => {
      const frame = store.currentFrame;
      const fpsVal = store.project?.composition?.fps || 30;
      const totalSeconds = frame / fpsVal;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const frames = frame % fpsVal;
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}:${String(frames).padStart(2, "0")}`;
    });
    computed(() => {
      return store.project?.meta?.name || "Untitled Project";
    });
    computed(() => {
      const comp = store.project?.composition;
      if (!comp) return "No Composition";
      return `${comp.width}${comp.height} @ ${comp.fps}fps`;
    });
    const canUndo = computed(() => store.canUndo);
    const canRedo = computed(() => store.canRedo);
    function togglePlay() {
      isPlaying.value = !isPlaying.value;
      if (isPlaying.value) {
        store.play();
      } else {
        store.pause();
      }
    }
    function goToStart() {
      store.goToStart();
    }
    function goToEnd() {
      store.goToEnd();
    }
    function stepForward() {
      store.setFrame(store.currentFrame + 1);
    }
    function stepBackward() {
      store.setFrame(Math.max(0, store.currentFrame - 1));
    }
    function undo() {
      store.undo();
    }
    function redo() {
      store.redo();
    }
    function updateCamera(camera) {
      if (store.activeCameraId) {
        store.updateCamera(camera.id, camera);
      }
    }
    function onExportComplete() {
      console.log("[Weyl] Matte export completed");
    }
    function onComfyUIExportComplete(result) {
      console.log("[Weyl] ComfyUI export completed", result);
      showComfyUIExportDialog.value = false;
    }
    function onCompositionSettingsConfirm(settings) {
      console.log("[Weyl] Composition settings updated:", settings);
      store.updateCompositionSettings(store.activeCompositionId, {
        width: settings.width,
        height: settings.height,
        fps: settings.fps,
        frameCount: settings.frameCount,
        backgroundColor: settings.backgroundColor,
        autoResizeToContent: settings.autoResizeToContent
      });
      store.renameComposition(store.activeCompositionId, settings.name);
      showCompositionSettingsDialog.value = false;
    }
    function generatePathDataFromPoints(points, closed) {
      if (points.length === 0) return "";
      if (points.length === 1) return `M ${points[0].x} ${points[0].y}`;
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i + 1];
        if (p0.handleOut && p1.handleIn) {
          const cp1x = p0.x + p0.handleOut.x;
          const cp1y = p0.y + p0.handleOut.y;
          const cp2x = p1.x + p1.handleIn.x;
          const cp2y = p1.y + p1.handleIn.y;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
        } else if (p0.handleOut) {
          const cpx = p0.x + p0.handleOut.x;
          const cpy = p0.y + p0.handleOut.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else if (p1.handleIn) {
          const cpx = p1.x + p1.handleIn.x;
          const cpy = p1.y + p1.handleIn.y;
          d += ` Q ${cpx} ${cpy}, ${p1.x} ${p1.y}`;
        } else {
          d += ` L ${p1.x} ${p1.y}`;
        }
      }
      if (closed && points.length > 2) {
        d += " Z";
      }
      return d;
    }
    function onPathSuggestionClose() {
      showPathSuggestionDialog.value = false;
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
    }
    function onPathSuggestionPreview(suggestions) {
      pathSuggestions.value = suggestions;
      selectedPathIndex.value = suggestions.length > 0 ? 0 : null;
    }
    function onPathSuggestionAccept(result) {
      console.log("[Weyl] Path suggestion accepted:", result);
      if (result.keyframes && result.keyframes.length > 0) {
        for (const batch of result.keyframes) {
          for (const keyframe of batch.keyframes) {
            store.addKeyframe(batch.layerId, batch.propertyPath, keyframe.frame, keyframe.value, keyframe.easing);
          }
        }
      }
      if (result.splines && result.splines.length > 0) {
        for (const spline of result.splines) {
          const layer = store.createSplineLayer();
          if (spline.name) {
            store.renameLayer(layer.id, spline.name);
          }
          const controlPoints = (spline.points || []).map((p, i) => ({
            id: p.id || `cp_${Date.now()}_${i}`,
            x: p.x,
            y: p.y,
            depth: p.depth ?? 0,
            // Preserve z-space depth
            handleIn: p.handleIn || null,
            // Preserve bezier handles from translator
            handleOut: p.handleOut || null,
            type: p.type || "smooth"
          }));
          const pathData = generatePathDataFromPoints(controlPoints, spline.closed || false);
          store.updateLayerData(layer.id, {
            controlPoints,
            pathData,
            closed: spline.closed || false
          });
        }
      }
      pathSuggestions.value = [];
      selectedPathIndex.value = null;
      showPathSuggestionDialog.value = false;
    }
    const activeCameraKeyframes = computed(() => {
      const activeCam = store.getActiveCameraAtFrame();
      if (!activeCam) return [];
      return store.getCameraKeyframes(activeCam.id);
    });
    function handleZoomChange() {
      if (!threeCanvasRef.value) return;
      if (viewZoom.value === "fit") {
        threeCanvasRef.value.fitToView();
      } else {
        const zoomLevel = parseInt(viewZoom.value) / 100;
        threeCanvasRef.value.setZoom(zoomLevel);
      }
    }
    function onCreateLayersFromSvg(svgId) {
      const storedSvg = assetStore.svgDocuments.get(svgId);
      if (!storedSvg) return;
      storedSvg.document.paths.forEach((path, index) => {
        const config = storedSvg.layerConfigs[index];
        const layer = store.createShapeLayer();
        store.renameLayer(layer.id, `${storedSvg.name}_${path.id}`);
        store.updateLayerData(layer.id, {
          svgDocumentId: svgId,
          svgPathId: path.id,
          svgPathIndex: index,
          extrusionConfig: config,
          // Set Z position based on layer depth
          transform: {
            ...layer.transform,
            position: {
              ...layer.transform.position,
              value: {
                ...layer.transform.position.value,
                z: config?.depth || 0
              }
            }
          }
        });
      });
      console.log(`[Weyl] Created ${storedSvg.document.paths.length} layers from SVG: ${storedSvg.name}`);
    }
    function onUseMeshAsEmitter(meshId) {
      const emitterConfig = assetStore.getMeshEmitterConfig(meshId);
      if (!emitterConfig) return;
      const selectedLayerIds = store.selectedLayerIds;
      if (selectedLayerIds.length === 0) {
        console.warn("[Weyl] No layer selected for mesh emitter");
        return;
      }
      const layer = store.layers.find((l) => l.id === selectedLayerIds[0]);
      if (!layer || layer.type !== "particle") {
        console.warn("[Weyl] Selected layer is not a particle layer");
        return;
      }
      store.updateLayerData(layer.id, {
        emitter: {
          ...layer.data.emitter,
          shape: "mesh",
          meshVertices: emitterConfig.meshVertices,
          meshNormals: emitterConfig.meshNormals
        }
      });
      console.log(`[Weyl] Set mesh emitter for layer: ${layer.name}`);
    }
    function onEnvironmentUpdate(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentConfig(settings);
    }
    async function onEnvironmentLoad(settings) {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      if (settings.url) {
        try {
          await engine.loadEnvironmentMap(settings.url, {
            intensity: settings.intensity,
            rotation: settings.rotation,
            backgroundBlur: settings.backgroundBlur,
            useAsBackground: settings.useAsBackground
          });
          console.log("[Weyl] Environment map loaded");
        } catch (error) {
          console.error("[Weyl] Failed to load environment map:", error);
        }
      }
    }
    function onEnvironmentClear() {
      if (!threeCanvasRef.value) return;
      const engine = threeCanvasRef.value.getEngine?.();
      if (!engine) return;
      engine.setEnvironmentEnabled(false);
    }
    function handleKeydown(e) {
      if (document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA") {
        return;
      }
      switch (e.key.toLowerCase()) {
        case " ":
          e.preventDefault();
          togglePlay();
          break;
        case "p":
          currentTool.value = "pen";
          break;
        case "t":
          currentTool.value = "text";
          break;
        case "h":
          currentTool.value = "hand";
          break;
        case "z":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
          } else {
            currentTool.value = "zoom";
          }
          break;
        case "home":
          e.preventDefault();
          goToStart();
          break;
        case "end":
          e.preventDefault();
          goToEnd();
          break;
        case "arrowleft":
          e.preventDefault();
          stepBackward();
          break;
        case "arrowright":
          e.preventDefault();
          stepForward();
          break;
        case "g":
          if (e.shiftKey) {
            showGraphEditor.value = !showGraphEditor.value;
          }
          break;
        case "k":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            showCompositionSettingsDialog.value = true;
          }
          break;
        case "i":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            triggerAssetImport();
          }
          break;
        case "a":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.selectAllLayers();
          } else {
            leftTab.value = "assets";
          }
          break;
        case "delete":
        case "backspace":
          if (store.selectedLayerIds.length > 0) {
            e.preventDefault();
            store.deleteSelectedLayers();
          }
          break;
        case "c":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.copySelectedLayers();
          }
          break;
        case "d":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.duplicateSelectedLayers();
          }
          break;
        case "v":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.pasteLayers();
          } else if (!e.shiftKey) {
            currentTool.value = "select";
          }
          break;
        case "x":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.cutSelectedLayers();
          }
          break;
      }
    }
    ref(null);
    function triggerAssetImport() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".svg,.gltf,.glb,.obj,.fbx,.hdr,.exr,.png,.jpg";
      input.multiple = true;
      input.onchange = async (e) => {
        const files = e.target.files;
        if (!files) return;
        for (const file of files) {
          const ext = file.name.split(".").pop()?.toLowerCase();
          if (ext === "svg") {
            await assetStore.importSvgFromFile(file);
          } else if (["hdr", "exr"].includes(ext || "")) {
            await assetStore.loadEnvironment(file);
          }
        }
        leftTab.value = "assets";
      };
      input.click();
    }
    let perfInterval;
    function updatePerformanceStats() {
      if ("memory" in performance) {
        const mem = performance.memory;
        const usedMB = Math.round(mem.usedJSHeapSize / 1024 / 1024);
        memoryUsage.value = `${usedMB} MB`;
      }
    }
    onMounted(async () => {
      const tierInfo = await detectGPUTier();
      gpuTier.value = tierInfo.tier;
      window.addEventListener("keydown", handleKeydown);
      perfInterval = window.setInterval(updatePerformanceStats, 1e3);
      if (store.autosaveEnabled) {
        store.startAutosaveTimer();
      }
    });
    onUnmounted(() => {
      window.removeEventListener("keydown", handleKeydown);
      clearInterval(perfInterval);
      store.stopAutosaveTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "select" }),
              "aria-pressed": currentTool.value === "select",
              onClick: _cache[0] || (_cache[0] = ($event) => currentTool.value = "select"),
              title: "Select Tool (V) - Select and move layers",
              "aria-label": "Select tool"
            }, [..._cache[40] || (_cache[40] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Select", -1)
            ])], 10, _hoisted_4),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "pen" }),
              "aria-pressed": currentTool.value === "pen",
              onClick: _cache[1] || (_cache[1] = ($event) => currentTool.value = "pen"),
              title: "Pen Tool (P) - Draw paths and shapes",
              "aria-label": "Pen tool"
            }, [..._cache[41] || (_cache[41] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Pen", -1)
            ])], 10, _hoisted_5),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "text" }),
              "aria-pressed": currentTool.value === "text",
              onClick: _cache[2] || (_cache[2] = ($event) => currentTool.value = "text"),
              title: "Text Tool (T) - Add text layers",
              "aria-label": "Text tool"
            }, [..._cache[42] || (_cache[42] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "T", -1),
              createBaseVNode("span", { class: "tool-label" }, "Text", -1)
            ])], 10, _hoisted_6),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "hand" }),
              "aria-pressed": currentTool.value === "hand",
              onClick: _cache[3] || (_cache[3] = ($event) => currentTool.value = "hand"),
              title: "Hand Tool (H) - Pan the viewport",
              "aria-label": "Pan tool"
            }, [..._cache[43] || (_cache[43] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Pan", -1)
            ])], 10, _hoisted_7),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "zoom" }),
              "aria-pressed": currentTool.value === "zoom",
              onClick: _cache[4] || (_cache[4] = ($event) => currentTool.value = "zoom"),
              title: "Zoom Tool (Z) - Zoom in/out the viewport",
              "aria-label": "Zoom tool"
            }, [..._cache[44] || (_cache[44] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "Zoom", -1)
            ])], 10, _hoisted_8),
            createBaseVNode("button", {
              class: normalizeClass({ active: currentTool.value === "segment" }),
              "aria-pressed": currentTool.value === "segment",
              onClick: _cache[5] || (_cache[5] = ($event) => currentTool.value = "segment"),
              title: "AI Segment (S) - Auto-select objects using AI",
              "aria-label": "AI Segment tool"
            }, [..._cache[45] || (_cache[45] = [
              createBaseVNode("span", {
                class: "icon",
                "aria-hidden": "true"
              }, "", -1),
              createBaseVNode("span", { class: "tool-label" }, "AI Seg", -1)
            ])], 10, _hoisted_9)
          ]),
          _cache[65] || (_cache[65] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", { class: "tool-group" }, [
            createBaseVNode("button", {
              onClick: triggerAssetImport,
              title: "Import Asset (Ctrl+I)",
              class: "import-btn"
            }, [..._cache[46] || (_cache[46] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createBaseVNode("span", { class: "btn-label" }, "Import", -1)
            ])])
          ]),
          currentTool.value === "segment" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _cache[52] || (_cache[52] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("div", _hoisted_10, [
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "point" }),
                onClick: _cache[6] || (_cache[6] = ($event) => setSegmentMode("point")),
                title: "Point Mode - Click to segment"
              }, [..._cache[47] || (_cache[47] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Point ", -1)
              ])], 2),
              createBaseVNode("button", {
                class: normalizeClass({ active: segmentMode.value === "box" }),
                onClick: _cache[7] || (_cache[7] = ($event) => setSegmentMode("box")),
                title: "Box Mode - Draw rectangle to segment"
              }, [..._cache[48] || (_cache[48] = [
                createBaseVNode("span", { class: "icon" }, "", -1),
                createTextVNode(" Box ", -1)
              ])], 2),
              segmentPendingMask.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _cache[51] || (_cache[51] = createBaseVNode("div", { class: "divider" }, null, -1)),
                createBaseVNode("button", {
                  onClick: confirmSegmentMask,
                  class: "confirm-btn",
                  title: "Create Layer from Selection"
                }, [..._cache[49] || (_cache[49] = [
                  createBaseVNode("span", { class: "icon" }, "", -1),
                  createTextVNode(" Create Layer ", -1)
                ])]),
                createBaseVNode("button", {
                  onClick: clearSegmentMask,
                  class: "cancel-btn",
                  title: "Cancel Selection"
                }, [..._cache[50] || (_cache[50] = [
                  createBaseVNode("span", { class: "icon" }, "", -1)
                ])])
              ], 64)) : createCommentVNode("", true),
              segmentIsLoading.value ? (openBlock(), createElementBlock("span", _hoisted_11, "Segmenting...")) : createCommentVNode("", true)
            ])
          ], 64)) : createCommentVNode("", true),
          _cache[66] || (_cache[66] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_12, [
            createBaseVNode("button", {
              onClick: goToStart,
              title: "Go to Start (Home)"
            }, [..._cache[53] || (_cache[53] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: stepBackward,
              title: "Step Backward"
            }, [..._cache[54] || (_cache[54] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: togglePlay,
              title: isPlaying.value ? "Pause (Space)" : "Play (Space)"
            }, [
              createBaseVNode("span", _hoisted_14, toDisplayString(isPlaying.value ? "" : ""), 1)
            ], 8, _hoisted_13),
            createBaseVNode("button", {
              onClick: stepForward,
              title: "Step Forward"
            }, [..._cache[55] || (_cache[55] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])]),
            createBaseVNode("button", {
              onClick: goToEnd,
              title: "Go to End (End)"
            }, [..._cache[56] || (_cache[56] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])])
          ]),
          createBaseVNode("div", _hoisted_15, toDisplayString(formattedTimecode.value), 1),
          _cache[67] || (_cache[67] = createBaseVNode("div", { class: "divider" }, null, -1)),
          createBaseVNode("div", _hoisted_16, [
            withDirectives(createBaseVNode("select", {
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => activeWorkspace.value = $event),
              class: "workspace-selector"
            }, [..._cache[57] || (_cache[57] = [
              createBaseVNode("option", { value: "standard" }, "Standard", -1),
              createBaseVNode("option", { value: "animation" }, "Animation", -1),
              createBaseVNode("option", { value: "effects" }, "Effects", -1),
              createBaseVNode("option", { value: "minimal" }, "Minimal", -1)
            ])], 512), [
              [vModelSelect, activeWorkspace.value]
            ])
          ]),
          createBaseVNode("div", _hoisted_17, [
            createBaseVNode("button", {
              class: normalizeClass(["theme-btn", { active: showThemeSelector.value }]),
              onClick: _cache[9] || (_cache[9] = ($event) => showThemeSelector.value = !showThemeSelector.value),
              title: "Change Theme"
            }, [
              createBaseVNode("span", {
                class: "theme-indicator",
                style: normalizeStyle({ background: themeGradient.value })
              }, null, 4)
            ], 2),
            showThemeSelector.value ? (openBlock(), createElementBlock("div", _hoisted_18, [
              _cache[58] || (_cache[58] = createBaseVNode("div", { class: "theme-dropdown-header" }, "Theme", -1)),
              createBaseVNode("div", _hoisted_19, [
                (openBlock(), createElementBlock(Fragment, null, renderList(themes, (theme) => {
                  return createBaseVNode("button", {
                    key: theme.name,
                    class: normalizeClass(["theme-option", { active: currentTheme.value === theme.name }]),
                    style: normalizeStyle({ background: theme.gradient }),
                    title: theme.label,
                    onClick: ($event) => selectTheme(theme.name)
                  }, null, 14, _hoisted_20);
                }), 64))
              ])
            ])) : createCommentVNode("", true)
          ]),
          _cache[68] || (_cache[68] = createBaseVNode("div", { class: "spacer" }, null, -1)),
          createBaseVNode("div", _hoisted_21, [
            createBaseVNode("span", {
              class: normalizeClass(["gpu-badge", gpuTier.value])
            }, toDisplayString(gpuTier.value.toUpperCase()), 3),
            createVNode(MemoryIndicator),
            createBaseVNode("button", {
              onClick: undo,
              disabled: !canUndo.value,
              title: "Undo (Ctrl+Z)"
            }, [..._cache[59] || (_cache[59] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_22),
            createBaseVNode("button", {
              onClick: redo,
              disabled: !canRedo.value,
              title: "Redo (Ctrl+Shift+Z)"
            }, [..._cache[60] || (_cache[60] = [
              createBaseVNode("span", { class: "icon" }, "", -1)
            ])], 8, _hoisted_23),
            _cache[64] || (_cache[64] = createBaseVNode("div", { class: "divider" }, null, -1)),
            createBaseVNode("button", {
              onClick: _cache[10] || (_cache[10] = ($event) => showHDPreview.value = true),
              title: "HD Preview (`)"
            }, [..._cache[61] || (_cache[61] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" HD ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[11] || (_cache[11] = ($event) => showExportDialog.value = true),
              title: "Export Matte"
            }, [..._cache[62] || (_cache[62] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" Matte ", -1)
            ])]),
            createBaseVNode("button", {
              onClick: _cache[12] || (_cache[12] = ($event) => showComfyUIExportDialog.value = true),
              title: "Export to ComfyUI"
            }, [..._cache[63] || (_cache[63] = [
              createBaseVNode("span", { class: "icon" }, "", -1),
              createTextVNode(" ComfyUI ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_24, [
          createVNode(unref(Pe), { class: "default-theme horizontal-split" }, {
            default: withCtx(() => [
              createVNode(unref(ge), {
                size: 14,
                "min-size": 10,
                "max-size": 25
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_25, [
                    createBaseVNode("div", _hoisted_26, [
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "project",
                        "aria-controls": "left-panel-project",
                        class: normalizeClass({ active: leftTab.value === "project" }),
                        onClick: _cache[13] || (_cache[13] = ($event) => leftTab.value = "project")
                      }, " Project ", 10, _hoisted_27),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "effects",
                        "aria-controls": "left-panel-effects",
                        class: normalizeClass({ active: leftTab.value === "effects" }),
                        onClick: _cache[14] || (_cache[14] = ($event) => leftTab.value = "effects")
                      }, " Effects ", 10, _hoisted_28),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": leftTab.value === "assets",
                        "aria-controls": "left-panel-assets",
                        class: normalizeClass({ active: leftTab.value === "assets" }),
                        onClick: _cache[15] || (_cache[15] = ($event) => leftTab.value = "assets")
                      }, " Assets ", 10, _hoisted_29)
                    ]),
                    createBaseVNode("div", {
                      class: "panel-content",
                      role: "tabpanel",
                      id: `left-panel-${leftTab.value}`
                    }, [
                      leftTab.value === "project" ? (openBlock(), createBlock(ProjectPanel, {
                        key: 0,
                        onOpenCompositionSettings: _cache[16] || (_cache[16] = ($event) => showCompositionSettingsDialog.value = true)
                      })) : leftTab.value === "effects" ? (openBlock(), createBlock(EffectsPanel, { key: 1 })) : leftTab.value === "assets" ? (openBlock(), createBlock(AssetsPanel, {
                        key: 2,
                        onCreateLayersFromSvg,
                        onUseMeshAsEmitter,
                        onEnvironmentUpdate,
                        onEnvironmentLoad,
                        onEnvironmentClear
                      })) : createCommentVNode("", true)
                    ], 8, _hoisted_30)
                  ])
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 62,
                "min-size": 35
              }, {
                default: withCtx(() => [
                  createVNode(unref(Pe), {
                    horizontal: "",
                    class: "default-theme"
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(ge), {
                        size: 65,
                        "min-size": 20
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_31, [
                            createBaseVNode("div", _hoisted_32, [
                              createBaseVNode("div", _hoisted_33, [
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "composition",
                                  class: normalizeClass({ active: viewportTab.value === "composition" }),
                                  onClick: _cache[17] || (_cache[17] = ($event) => viewportTab.value = "composition")
                                }, " Composition ", 10, _hoisted_34),
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "layer",
                                  class: normalizeClass({ active: viewportTab.value === "layer" }),
                                  onClick: _cache[18] || (_cache[18] = ($event) => viewportTab.value = "layer")
                                }, " Layer ", 10, _hoisted_35),
                                createBaseVNode("button", {
                                  role: "tab",
                                  "aria-selected": viewportTab.value === "footage",
                                  class: normalizeClass({ active: viewportTab.value === "footage" }),
                                  onClick: _cache[19] || (_cache[19] = ($event) => viewportTab.value = "footage")
                                }, " Footage ", 10, _hoisted_36)
                              ]),
                              createBaseVNode("div", _hoisted_37, [
                                withDirectives(createBaseVNode("select", {
                                  "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => viewZoom.value = $event),
                                  onChange: handleZoomChange,
                                  class: "zoom-select",
                                  "aria-label": "Zoom level"
                                }, [..._cache[69] || (_cache[69] = [
                                  createBaseVNode("option", { value: "fit" }, "Fit", -1),
                                  createBaseVNode("option", { value: "25" }, "25%", -1),
                                  createBaseVNode("option", { value: "50" }, "50%", -1),
                                  createBaseVNode("option", { value: "75" }, "75%", -1),
                                  createBaseVNode("option", { value: "100" }, "100%", -1),
                                  createBaseVNode("option", { value: "150" }, "150%", -1),
                                  createBaseVNode("option", { value: "200" }, "200%", -1)
                                ])], 544), [
                                  [vModelSelect, viewZoom.value]
                                ]),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showRulers }),
                                  onClick: _cache[21] || (_cache[21] = ($event) => viewOptions.value.showRulers = !viewOptions.value.showRulers),
                                  title: "Toggle Rulers/Guides",
                                  "aria-label": "Toggle rulers and guides",
                                  "aria-pressed": viewOptions.value.showRulers
                                }, [..._cache[70] || (_cache[70] = [
                                  createBaseVNode("span", {
                                    class: "icon",
                                    "aria-hidden": "true"
                                  }, "", -1)
                                ])], 10, _hoisted_38),
                                createBaseVNode("button", {
                                  class: normalizeClass({ active: viewOptions.value.showGrid }),
                                  onClick: _cache[22] || (_cache[22] = ($event) => viewOptions.value.showGrid = !viewOptions.value.showGrid),
                                  title: "Toggle Grid",
                                  "aria-label": "Toggle grid",
                                  "aria-pressed": viewOptions.value.showGrid
                                }, [..._cache[71] || (_cache[71] = [
                                  createBaseVNode("span", { class: "icon" }, "", -1)
                                ])], 10, _hoisted_39)
                              ])
                            ]),
                            createBaseVNode("div", _hoisted_40, [
                              viewOptions.value.showRulers ? (openBlock(), createElementBlock("div", _hoisted_41, [
                                createBaseVNode("div", _hoisted_42, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "h" + i,
                                      class: "tick",
                                      style: normalizeStyle({ left: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compWidth.value)), 5);
                                  }), 64))
                                ]),
                                createBaseVNode("div", _hoisted_43, [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(20, (i) => {
                                    return createBaseVNode("span", {
                                      key: "v" + i,
                                      class: "tick",
                                      style: normalizeStyle({ top: i * 5 + "%" })
                                    }, toDisplayString(Math.round(i * 5 / 100 * compHeight.value)), 5);
                                  }), 64))
                                ])
                              ])) : createCommentVNode("", true),
                              viewportTab.value === "composition" ? (openBlock(), createBlock(ThreeCanvas, {
                                key: 1,
                                ref_key: "threeCanvasRef",
                                ref: threeCanvasRef
                              }, null, 512)) : (openBlock(), createBlock(ViewportRenderer, {
                                key: 2,
                                camera: activeCamera.value,
                                viewportState: viewportState.value,
                                viewOptions: viewOptions.value,
                                compWidth: compWidth.value,
                                compHeight: compHeight.value
                              }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                            ])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ge), {
                        size: 35,
                        "min-size": 15
                      }, {
                        default: withCtx(() => [
                          showGraphEditor.value ? (openBlock(), createBlock(unref(Pe), {
                            key: 0,
                            horizontal: "",
                            class: "default-theme"
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_44, [
                                    createVNode(TimelinePanel, {
                                      onOpenCompositionSettings: _cache[23] || (_cache[23] = ($event) => showCompositionSettingsDialog.value = true),
                                      onOpenPathSuggestion: _cache[24] || (_cache[24] = ($event) => showPathSuggestionDialog.value = true)
                                    })
                                  ])
                                ]),
                                _: 1
                              }),
                              createVNode(unref(ge), {
                                size: 50,
                                "min-size": 20
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_45, [
                                    createVNode(GraphEditor, {
                                      onClose: _cache[25] || (_cache[25] = ($event) => showGraphEditor.value = false)
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })) : (openBlock(), createElementBlock("div", _hoisted_46, [
                            createVNode(TimelinePanel, {
                              onOpenCompositionSettings: _cache[26] || (_cache[26] = ($event) => showCompositionSettingsDialog.value = true),
                              onOpenPathSuggestion: _cache[27] || (_cache[27] = ($event) => showPathSuggestionDialog.value = true)
                            })
                          ]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(unref(ge), {
                size: 24,
                "min-size": 15,
                "max-size": 35
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_47, [
                    createBaseVNode("div", _hoisted_48, [
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "properties",
                        "aria-controls": "right-panel-properties",
                        class: normalizeClass({ active: rightTab.value === "properties" }),
                        onClick: _cache[28] || (_cache[28] = ($event) => rightTab.value = "properties")
                      }, " Properties ", 10, _hoisted_49),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "effects",
                        "aria-controls": "right-panel-effects",
                        class: normalizeClass({ active: rightTab.value === "effects" }),
                        onClick: _cache[29] || (_cache[29] = ($event) => rightTab.value = "effects")
                      }, " Effects ", 10, _hoisted_50),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "camera",
                        "aria-controls": "right-panel-camera",
                        class: normalizeClass({ active: rightTab.value === "camera" }),
                        onClick: _cache[30] || (_cache[30] = ($event) => rightTab.value = "camera")
                      }, " Cam ", 10, _hoisted_51),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "audio",
                        "aria-controls": "right-panel-audio",
                        class: normalizeClass({ active: rightTab.value === "audio" }),
                        onClick: _cache[31] || (_cache[31] = ($event) => rightTab.value = "audio")
                      }, " Audio ", 10, _hoisted_52),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "export",
                        "aria-controls": "right-panel-export",
                        class: normalizeClass({ active: rightTab.value === "export" }),
                        onClick: _cache[32] || (_cache[32] = ($event) => rightTab.value = "export")
                      }, " Export ", 10, _hoisted_53),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "preview",
                        "aria-controls": "right-panel-preview",
                        class: normalizeClass({ active: rightTab.value === "preview" }),
                        onClick: _cache[33] || (_cache[33] = ($event) => rightTab.value = "preview")
                      }, " Preview ", 10, _hoisted_54),
                      createBaseVNode("button", {
                        role: "tab",
                        "aria-selected": rightTab.value === "ai",
                        "aria-controls": "right-panel-ai",
                        class: normalizeClass({ active: rightTab.value === "ai" }),
                        onClick: _cache[34] || (_cache[34] = ($event) => rightTab.value = "ai"),
                        title: "AI Compositor Agent"
                      }, " AI ", 10, _hoisted_55)
                    ]),
                    createBaseVNode("div", {
                      class: "panel-content",
                      role: "tabpanel",
                      id: `right-panel-${rightTab.value}`
                    }, [
                      rightTab.value === "effects" ? (openBlock(), createBlock(EffectControlsPanel, { key: 0 })) : rightTab.value === "properties" ? (openBlock(), createBlock(PropertiesPanel, { key: 1 })) : rightTab.value === "camera" ? (openBlock(), createBlock(CameraProperties, {
                        key: 2,
                        camera: activeCamera.value,
                        "onUpdate:camera": updateCamera
                      }, null, 8, ["camera"])) : rightTab.value === "audio" ? (openBlock(), createBlock(AudioPanel, { key: 3 })) : rightTab.value === "export" ? (openBlock(), createBlock(ExportPanel, { key: 4 })) : rightTab.value === "preview" ? (openBlock(), createBlock(PreviewPanel, {
                        key: 5,
                        engine: canvasEngine.value
                      }, null, 8, ["engine"])) : rightTab.value === "ai" ? (openBlock(), createBlock(AIChatPanel, { key: 6 })) : createCommentVNode("", true)
                    ], 8, _hoisted_56)
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        showExportDialog.value ? (openBlock(), createBlock(ExportDialog, {
          key: 0,
          onClose: _cache[35] || (_cache[35] = ($event) => showExportDialog.value = false),
          onExported: onExportComplete
        })) : createCommentVNode("", true),
        showComfyUIExportDialog.value ? (openBlock(), createBlock(ComfyUIExportDialog, {
          key: 1,
          layers: unref(store).layers,
          "camera-keyframes": activeCameraKeyframes.value,
          "current-frame": unref(store).currentFrame,
          "total-frames": unref(store).frameCount,
          onClose: _cache[36] || (_cache[36] = ($event) => showComfyUIExportDialog.value = false),
          onExported: onComfyUIExportComplete
        }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : createCommentVNode("", true),
        createVNode(CompositionSettingsDialog, {
          visible: showCompositionSettingsDialog.value,
          onClose: _cache[37] || (_cache[37] = ($event) => showCompositionSettingsDialog.value = false),
          onConfirm: onCompositionSettingsConfirm
        }, null, 8, ["visible"]),
        createVNode(PathSuggestionDialog, {
          visible: showPathSuggestionDialog.value,
          onClose: onPathSuggestionClose,
          onAccept: onPathSuggestionAccept,
          onPreview: onPathSuggestionPreview
        }, null, 8, ["visible"]),
        createVNode(HDPreviewWindow, {
          visible: showHDPreview.value,
          engine: canvasEngine.value,
          onClose: _cache[38] || (_cache[38] = ($event) => showHDPreview.value = false)
        }, null, 8, ["visible", "engine"]),
        pathSuggestions.value.length > 0 ? (openBlock(), createBlock(Teleport, {
          key: 2,
          to: ".viewport-content"
        }, [
          createVNode(PathPreviewOverlay, {
            width: compWidth.value,
            height: compHeight.value,
            suggestions: pathSuggestions.value,
            selectedIndex: selectedPathIndex.value,
            onSelect: _cache[39] || (_cache[39] = ($event) => selectedPathIndex.value = $event)
          }, null, 8, ["width", "height", "suggestions", "selectedIndex"])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});

const WorkspaceLayout = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-896bcd18"]]);

const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const themeStore = useThemeStore();
    onMounted(() => {
      themeStore.loadSavedTheme();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(WorkspaceLayout);
    };
  }
});

class WebGLBlurContext {
  gl = null;
  canvas = null;
  program = null;
  positionBuffer = null;
  texCoordBuffer = null;
  texture = null;
  framebuffer = null;
  pingPongTextures = [];
  _isAvailable = null;
  currentWidth = 0;
  currentHeight = 0;
  /**
   * Vertex shader for fullscreen quad
   */
  vertexShaderSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  /**
   * Fragment shader for separable Gaussian blur
   * Uses 9-tap kernel approximation
   */
  fragmentShaderSource = `
    precision mediump float;
    uniform sampler2D u_image;
    uniform vec2 u_direction;
    uniform vec2 u_resolution;
    uniform float u_radius;
    varying vec2 v_texCoord;

    void main() {
      vec2 texelSize = 1.0 / u_resolution;
      vec4 color = vec4(0.0);
      float total = 0.0;

      // Dynamic kernel based on radius
      int samples = int(min(u_radius * 2.0 + 1.0, 25.0));
      float sigma = max(u_radius / 2.0, 1.0);

      for (int i = -12; i <= 12; i++) {
        if (abs(float(i)) > u_radius) continue;

        float x = float(i);
        float weight = exp(-(x * x) / (2.0 * sigma * sigma));
        vec2 offset = u_direction * texelSize * x;
        color += texture2D(u_image, v_texCoord + offset) * weight;
        total += weight;
      }

      gl_FragColor = color / total;
    }
  `;
  /**
   * Check if WebGL blur is available
   */
  isAvailable() {
    if (this._isAvailable !== null) {
      return this._isAvailable;
    }
    try {
      const testCanvas = document.createElement("canvas");
      testCanvas.width = 1;
      testCanvas.height = 1;
      const gl = testCanvas.getContext("webgl") || testCanvas.getContext("experimental-webgl");
      this._isAvailable = gl !== null;
    } catch {
      this._isAvailable = false;
    }
    return this._isAvailable;
  }
  /**
   * Initialize WebGL context and shaders
   */
  init(width, height) {
    if (!this.isAvailable()) return false;
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
    }
    if (this.currentWidth !== width || this.currentHeight !== height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this.currentWidth = width;
      this.currentHeight = height;
      this.pingPongTextures = [];
    }
    if (!this.gl) {
      this.gl = this.canvas.getContext("webgl", {
        alpha: true,
        premultipliedAlpha: false,
        preserveDrawingBuffer: true
      });
      if (!this.gl) return false;
    }
    const gl = this.gl;
    if (!this.program) {
      const vertexShader = this.compileShader(gl, gl.VERTEX_SHADER, this.vertexShaderSource);
      const fragmentShader = this.compileShader(gl, gl.FRAGMENT_SHADER, this.fragmentShaderSource);
      if (!vertexShader || !fragmentShader) return false;
      this.program = gl.createProgram();
      gl.attachShader(this.program, vertexShader);
      gl.attachShader(this.program, fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.warn("[WebGLBlur] Program link failed:", gl.getProgramInfoLog(this.program));
        return false;
      }
      this.positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1,
        1
      ]), gl.STATIC_DRAW);
      this.texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1,
        1
      ]), gl.STATIC_DRAW);
    }
    if (this.pingPongTextures.length < 2) {
      for (let i = 0; i < 2; i++) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        this.pingPongTextures.push(tex);
      }
      this.framebuffer = gl.createFramebuffer();
    }
    return true;
  }
  /**
   * Compile a shader
   */
  compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.warn("[WebGLBlur] Shader compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  /**
   * Apply Gaussian blur using WebGL
   */
  blur(input, radiusX, radiusY) {
    const { width, height } = input;
    if (!this.init(width, height)) {
      return null;
    }
    const gl = this.gl;
    const program = this.program;
    gl.useProgram(program);
    gl.viewport(0, 0, width, height);
    const positionLoc = gl.getAttribLocation(program, "a_position");
    const texCoordLoc = gl.getAttribLocation(program, "a_texCoord");
    const imageLoc = gl.getUniformLocation(program, "u_image");
    const directionLoc = gl.getUniformLocation(program, "u_direction");
    const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
    const radiusLoc = gl.getUniformLocation(program, "u_radius");
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.enableVertexAttribArray(texCoordLoc);
    gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1i(imageLoc, 0);
    gl.uniform2f(resolutionLoc, width, height);
    if (!this.texture) {
      this.texture = gl.createTexture();
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, input);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    let sourceTexture = this.texture;
    let destIdx = 0;
    if (radiusX > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 1, 0);
      gl.uniform1f(radiusLoc, radiusX);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
      destIdx = 1 - destIdx;
    }
    if (radiusY > 0) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.pingPongTextures[destIdx], 0);
      gl.bindTexture(gl.TEXTURE_2D, sourceTexture);
      gl.uniform2f(directionLoc, 0, 1);
      gl.uniform1f(radiusLoc, radiusY);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      sourceTexture = this.pingPongTextures[destIdx];
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sourceTexture, 0);
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    const outputCanvas = document.createElement("canvas");
    outputCanvas.width = width;
    outputCanvas.height = height;
    const ctx = outputCanvas.getContext("2d");
    const imageData = ctx.createImageData(width, height);
    for (let y = 0; y < height; y++) {
      const srcRow = (height - 1 - y) * width * 4;
      const dstRow = y * width * 4;
      for (let x = 0; x < width * 4; x++) {
        imageData.data[dstRow + x] = pixels[srcRow + x];
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return outputCanvas;
  }
  /**
   * Clean up WebGL resources
   */
  dispose() {
    if (this.gl) {
      if (this.program) this.gl.deleteProgram(this.program);
      if (this.texture) this.gl.deleteTexture(this.texture);
      if (this.positionBuffer) this.gl.deleteBuffer(this.positionBuffer);
      if (this.texCoordBuffer) this.gl.deleteBuffer(this.texCoordBuffer);
      if (this.framebuffer) this.gl.deleteFramebuffer(this.framebuffer);
      for (const tex of this.pingPongTextures) {
        this.gl.deleteTexture(tex);
      }
    }
    this.gl = null;
    this.canvas = null;
    this.program = null;
    this._isAvailable = null;
  }
}
const webglBlurContext = new WebGLBlurContext();
const GPU_BLUR_THRESHOLD = 15;
const MUL_TABLE = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
const SHG_TABLE = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function createBlurStack(size) {
  const first = { r: 0, g: 0, b: 0, a: 0, next: null };
  let current = first;
  for (let i = 1; i < size; i++) {
    current.next = { r: 0, g: 0, b: 0, a: 0, next: null };
    current = current.next;
  }
  current.next = first;
  return first;
}
function stackBlur(imageData, radiusX, radiusY) {
  const pixels = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  radiusX = Math.max(0, Math.min(255, Math.round(radiusX)));
  radiusY = Math.max(0, Math.min(255, Math.round(radiusY)));
  if (radiusX === 0 && radiusY === 0) return;
  if (radiusX > 0) {
    stackBlurHorizontal(pixels, width, height, radiusX);
  }
  if (radiusY > 0) {
    stackBlurVertical(pixels, width, height, radiusY);
  }
}
function stackBlurHorizontal(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const widthMinus1 = width - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let y = 0; y < height; y++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    const yOffset = y * width;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[yOffset * 4];
    const pg = pixels[yOffset * 4 + 1];
    const pb = pixels[yOffset * 4 + 2];
    const pa = pixels[yOffset * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, widthMinus1);
      const pOffset = (yOffset + p) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let x = 0; x < width; x++) {
      const pOffset = (yOffset + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(x + radius + 1, widthMinus1);
      const pIn = (yOffset + p) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function stackBlurVertical(pixels, width, height, radius) {
  const div = radius + radius + 1;
  const heightMinus1 = height - 1;
  const mulSum = MUL_TABLE[radius];
  const shgSum = SHG_TABLE[radius];
  const stack = createBlurStack(div);
  for (let x = 0; x < width; x++) {
    let rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0;
    let rOutSum = 0, gOutSum = 0, bOutSum = 0, aOutSum = 0;
    let rSum = 0, gSum = 0, bSum = 0, aSum = 0;
    let stackIn = stack;
    let stackOut = stack;
    const pr = pixels[x * 4];
    const pg = pixels[x * 4 + 1];
    const pb = pixels[x * 4 + 2];
    const pa = pixels[x * 4 + 3];
    for (let i = 0; i <= radius; i++) {
      stackIn.r = pr;
      stackIn.g = pg;
      stackIn.b = pb;
      stackIn.a = pa;
      const rbs = radius + 1 - i;
      rSum += pr * rbs;
      gSum += pg * rbs;
      bSum += pb * rbs;
      aSum += pa * rbs;
      if (i > 0) {
        rInSum += pr;
        gInSum += pg;
        bInSum += pb;
        aInSum += pa;
      } else {
        rOutSum += pr;
        gOutSum += pg;
        bOutSum += pb;
        aOutSum += pa;
      }
      stackIn = stackIn.next;
    }
    for (let i = 1; i <= radius; i++) {
      const p = Math.min(i, heightMinus1);
      const pOffset = (p * width + x) * 4;
      const pr2 = pixels[pOffset];
      const pg2 = pixels[pOffset + 1];
      const pb2 = pixels[pOffset + 2];
      const pa2 = pixels[pOffset + 3];
      stackIn.r = pr2;
      stackIn.g = pg2;
      stackIn.b = pb2;
      stackIn.a = pa2;
      const rbs = radius + 1 - i;
      rSum += pr2 * rbs;
      gSum += pg2 * rbs;
      bSum += pb2 * rbs;
      aSum += pa2 * rbs;
      rInSum += pr2;
      gInSum += pg2;
      bInSum += pb2;
      aInSum += pa2;
      stackIn = stackIn.next;
    }
    let stackStart = stack;
    for (let i = 0; i < radius; i++) {
      stackStart = stackStart.next;
    }
    stackOut = stackStart.next;
    for (let y = 0; y < height; y++) {
      const pOffset = (y * width + x) * 4;
      pixels[pOffset] = rSum * mulSum >>> shgSum;
      pixels[pOffset + 1] = gSum * mulSum >>> shgSum;
      pixels[pOffset + 2] = bSum * mulSum >>> shgSum;
      pixels[pOffset + 3] = aSum * mulSum >>> shgSum;
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackStart.r;
      gOutSum -= stackStart.g;
      bOutSum -= stackStart.b;
      aOutSum -= stackStart.a;
      const p = Math.min(y + radius + 1, heightMinus1);
      const pIn = (p * width + x) * 4;
      stackStart.r = pixels[pIn];
      stackStart.g = pixels[pIn + 1];
      stackStart.b = pixels[pIn + 2];
      stackStart.a = pixels[pIn + 3];
      rInSum += stackStart.r;
      gInSum += stackStart.g;
      bInSum += stackStart.b;
      aInSum += stackStart.a;
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackStart = stackStart.next;
      rOutSum += stackOut.r;
      gOutSum += stackOut.g;
      bOutSum += stackOut.b;
      aOutSum += stackOut.a;
      rInSum -= stackOut.r;
      gInSum -= stackOut.g;
      bInSum -= stackOut.b;
      aInSum -= stackOut.a;
      stackOut = stackOut.next;
    }
  }
}
function gaussianBlurRenderer(input, params) {
  const blurriness = params.blurriness ?? 10;
  const dimensions = params.blur_dimensions ?? "both";
  const useGpu = params.use_gpu !== false;
  if (blurriness <= 0) {
    return input;
  }
  let radiusX = 0;
  let radiusY = 0;
  switch (dimensions) {
    case "horizontal":
      radiusX = blurriness;
      break;
    case "vertical":
      radiusY = blurriness;
      break;
    case "both":
    default:
      radiusX = blurriness;
      radiusY = blurriness;
      break;
  }
  const maxRadius = Math.max(radiusX, radiusY);
  if (useGpu && maxRadius > GPU_BLUR_THRESHOLD && webglBlurContext.isAvailable()) {
    const gpuResult = webglBlurContext.blur(input.canvas, radiusX, radiusY);
    if (gpuResult) {
      const output2 = createMatchingCanvas(input.canvas);
      output2.ctx.drawImage(gpuResult, 0, 0);
      return output2;
    }
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  stackBlur(imageData, radiusX, radiusY);
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function directionalBlurRenderer(input, params) {
  const direction = (params.direction ?? 0) * Math.PI / 180;
  const blurLength = Math.max(0, Math.min(500, params.blur_length ?? 10));
  if (blurLength <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const dx = Math.cos(direction);
  const dy = Math.sin(direction);
  const samples = Math.max(3, Math.ceil(blurLength));
  const halfSamples = Math.floor(samples / 2);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, a = 0;
      let count = 0;
      for (let i = -halfSamples; i <= halfSamples; i++) {
        const sampleX = Math.round(x + dx * i * (blurLength / samples));
        const sampleY = Math.round(y + dy * i * (blurLength / samples));
        const sx = Math.max(0, Math.min(width - 1, sampleX));
        const sy = Math.max(0, Math.min(height - 1, sampleY));
        const idx = (sy * width + sx) * 4;
        r += src[idx];
        g += src[idx + 1];
        b += src[idx + 2];
        a += src[idx + 3];
        count++;
      }
      const outIdx = (y * width + x) * 4;
      dst[outIdx] = Math.round(r / count);
      dst[outIdx + 1] = Math.round(g / count);
      dst[outIdx + 2] = Math.round(b / count);
      dst[outIdx + 3] = Math.round(a / count);
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function radialBlurRenderer(input, params) {
  const type = params.type ?? "spin";
  const amount = Math.max(0, Math.min(100, params.amount ?? 10));
  const centerX = (params.center_x ?? 50) / 100;
  const centerY = (params.center_y ?? 50) / 100;
  const quality = params.quality ?? "good";
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const cx = centerX * width;
  const cy = centerY * height;
  const samples = quality === "best" ? 32 : quality === "good" ? 16 : 8;
  if (type === "spin") {
    const maxAngle = amount / 100 * Math.PI * 0.5;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const baseAngle = Math.atan2(dy, dx);
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1) - 0.5;
          const angle = baseAngle + t * maxAngle;
          const sampleX = Math.round(cx + Math.cos(angle) * dist);
          const sampleY = Math.round(cy + Math.sin(angle) * dist);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  } else {
    const maxZoom = amount / 100;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        const dx = x - cx;
        const dy = y - cy;
        for (let i = 0; i < samples; i++) {
          const t = i / (samples - 1);
          const scale = 1 - t * maxZoom;
          const sampleX = Math.round(cx + dx * scale);
          const sampleY = Math.round(cy + dy * scale);
          const sx = Math.max(0, Math.min(width - 1, sampleX));
          const sy = Math.max(0, Math.min(height - 1, sampleY));
          const idx = (sy * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / samples);
        dst[outIdx + 1] = Math.round(g / samples);
        dst[outIdx + 2] = Math.round(b / samples);
        dst[outIdx + 3] = Math.round(a / samples);
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function boxBlurRenderer(input, params) {
  const radius = Math.max(0, Math.min(100, Math.round(params.radius ?? 5)));
  const iterations = Math.max(1, Math.min(5, params.iterations ?? 1));
  if (radius <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  let current = createMatchingCanvas(input.canvas);
  current.ctx.drawImage(input.canvas, 0, 0);
  for (let iter = 0; iter < iterations; iter++) {
    const imageData = current.ctx.getImageData(0, 0, width, height);
    const src = imageData.data;
    const dst = new Uint8ClampedArray(src.length);
    const size = radius * 2 + 1;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dx = -radius; dx <= radius; dx++) {
          const sx = Math.max(0, Math.min(width - 1, x + dx));
          const idx = (y * width + sx) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    src.set(dst);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for (let dy = -radius; dy <= radius; dy++) {
          const sy = Math.max(0, Math.min(height - 1, y + dy));
          const idx = (sy * width + x) * 4;
          r += src[idx];
          g += src[idx + 1];
          b += src[idx + 2];
          a += src[idx + 3];
        }
        const outIdx = (y * width + x) * 4;
        dst[outIdx] = Math.round(r / size);
        dst[outIdx + 1] = Math.round(g / size);
        dst[outIdx + 2] = Math.round(b / size);
        dst[outIdx + 3] = Math.round(a / size);
      }
    }
    imageData.data.set(dst);
    current.ctx.putImageData(imageData, 0, 0);
  }
  return current;
}
function sharpenRenderer(input, params) {
  const amount = (params.amount ?? 100) / 100;
  const radius = Math.max(1, Math.min(100, params.radius ?? 1));
  const threshold = params.threshold ?? 0;
  if (amount <= 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const blurred = createMatchingCanvas(input.canvas);
  blurred.ctx.drawImage(input.canvas, 0, 0);
  const blurredData = blurred.ctx.getImageData(0, 0, width, height);
  stackBlur(blurredData, radius, radius);
  const output = createMatchingCanvas(input.canvas);
  const originalData = input.ctx.getImageData(0, 0, width, height);
  const orig = originalData.data;
  const blur = blurredData.data;
  for (let i = 0; i < orig.length; i += 4) {
    for (let c = 0; c < 3; c++) {
      const diff = orig[i + c] - blur[i + c];
      if (Math.abs(diff) >= threshold) {
        const sharpened = orig[i + c] + diff * amount;
        orig[i + c] = Math.max(0, Math.min(255, Math.round(sharpened)));
      }
    }
  }
  output.ctx.putImageData(originalData, 0, 0);
  return output;
}
function registerBlurEffects() {
  registerEffectRenderer("gaussian-blur", gaussianBlurRenderer);
  registerEffectRenderer("directional-blur", directionalBlurRenderer);
  registerEffectRenderer("radial-blur", radialBlurRenderer);
  registerEffectRenderer("box-blur", boxBlurRenderer);
  registerEffectRenderer("sharpen", sharpenRenderer);
}

function brightnessContrastRenderer(input, params) {
  const brightness = (params.brightness ?? 0) / 100;
  const contrast = (params.contrast ?? 0) / 100;
  const useLegacy = params.use_legacy ?? false;
  if (brightness === 0 && contrast === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const contrastFactor = useLegacy ? 1 + contrast : 259 * (contrast * 255 + 255) / (255 * (259 - contrast * 255));
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    r += brightness * 255;
    g += brightness * 255;
    b += brightness * 255;
    r = contrastFactor * (r - 128) + 128;
    g = contrastFactor * (g - 128) + 128;
    b = contrastFactor * (b - 128) + 128;
    data[i] = Math.max(0, Math.min(255, r));
    data[i + 1] = Math.max(0, Math.min(255, g));
    data[i + 2] = Math.max(0, Math.min(255, b));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h = 0;
  let s = 0;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }
  return [h, s, l];
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
function hueSaturationRenderer(input, params) {
  const hueShift = (params.master_hue ?? 0) / 360;
  const saturationShift = (params.master_saturation ?? 0) / 100;
  const lightnessShift = (params.master_lightness ?? 0) / 100;
  const colorize = params.colorize ?? false;
  if (hueShift === 0 && saturationShift === 0 && lightnessShift === 0 && !colorize) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    let [h, s, l] = rgbToHsl(r, g, b);
    if (colorize) {
      h = hueShift;
      s = Math.abs(saturationShift) + 0.25;
    } else {
      h = (h + hueShift) % 1;
      if (h < 0) h += 1;
      s = s + s * saturationShift;
    }
    l = l + l * lightnessShift;
    s = Math.max(0, Math.min(1, s));
    l = Math.max(0, Math.min(1, l));
    const [newR, newG, newB] = hslToRgb(h, s, l);
    data[i] = newR;
    data[i + 1] = newG;
    data[i + 2] = newB;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function levelsRenderer(input, params) {
  const inputBlack = params.input_black ?? 0;
  const inputWhite = params.input_white ?? 255;
  const gamma = params.gamma ?? 1;
  const outputBlack = params.output_black ?? 0;
  const outputWhite = params.output_white ?? 255;
  if (inputBlack === 0 && inputWhite === 255 && gamma === 1 && outputBlack === 0 && outputWhite === 255) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const inputRange = inputWhite - inputBlack;
  const outputRange = outputWhite - outputBlack;
  for (let i = 0; i < 256; i++) {
    let value = (i - inputBlack) / inputRange;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, 1 / gamma);
    value = outputBlack + value * outputRange;
    value = Math.max(0, Math.min(255, value));
    lut[i] = Math.round(value);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function tintRenderer(input, params) {
  const blackColor = params.map_black_to ?? { r: 0, g: 0, b: 0 };
  const whiteColor = params.map_white_to ?? { r: 255, g: 255, b: 255 };
  const amount = (params.amount_to_tint ?? 100) / 100;
  if (amount === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const tintR = blackColor.r + (whiteColor.r - blackColor.r) * lum;
    const tintG = blackColor.g + (whiteColor.g - blackColor.g) * lum;
    const tintB = blackColor.b + (whiteColor.b - blackColor.b) * lum;
    data[i] = Math.round(r + (tintR - r) * amount);
    data[i + 1] = Math.round(g + (tintG - g) * amount);
    data[i + 2] = Math.round(b + (tintB - b) * amount);
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function cubicBezier(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const mt = 1 - t;
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
}
function buildCurveLUT(points) {
  const lut = new Uint8Array(256);
  if (!points || points.length === 0) {
    for (let i = 0; i < 256; i++) {
      lut[i] = i;
    }
    return lut;
  }
  if (points.length === 1) {
    for (let i = 0; i < 256; i++) {
      lut[i] = Math.max(0, Math.min(255, Math.round(points[0].y)));
    }
    return lut;
  }
  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
  if (sortedPoints[0].x > 0) {
    sortedPoints.unshift({ x: 0, y: sortedPoints[0].y });
  }
  if (sortedPoints[sortedPoints.length - 1].x < 255) {
    sortedPoints.push({ x: 255, y: sortedPoints[sortedPoints.length - 1].y });
  }
  for (let i = 0; i < 256; i++) {
    let segmentIndex = 0;
    for (let j = 0; j < sortedPoints.length - 1; j++) {
      if (i >= sortedPoints[j].x && i <= sortedPoints[j + 1].x) {
        segmentIndex = j;
        break;
      }
    }
    const p0 = sortedPoints[segmentIndex];
    const p1 = sortedPoints[segmentIndex + 1];
    const t = (i - p0.x) / (p1.x - p0.x || 1);
    let tangent0 = 0;
    let tangent1 = 0;
    if (segmentIndex > 0) {
      const pPrev = sortedPoints[segmentIndex - 1];
      tangent0 = (p1.y - pPrev.y) / (p1.x - pPrev.x || 1) * (p1.x - p0.x);
    }
    if (segmentIndex < sortedPoints.length - 2) {
      const pNext = sortedPoints[segmentIndex + 2];
      tangent1 = (pNext.y - p0.y) / (pNext.x - p0.x || 1) * (p1.x - p0.x);
    }
    const cp1y = p0.y + tangent0 / 3;
    const cp2y = p1.y - tangent1 / 3;
    const value = cubicBezier(p0.y, cp1y, cp2y, p1.y, t);
    lut[i] = Math.max(0, Math.min(255, Math.round(value)));
  }
  return lut;
}
function curvesRenderer(input, params) {
  const masterCurve = params.master_curve;
  const redCurve = params.red_curve;
  const greenCurve = params.green_curve;
  const blueCurve = params.blue_curve;
  const alphaCurve = params.alpha_curve;
  const blend = (params.blend_with_original ?? 100) / 100;
  const hasCurves = masterCurve || redCurve || greenCurve || blueCurve || alphaCurve;
  if (!hasCurves || blend === 0) {
    return input;
  }
  const masterLUT = buildCurveLUT(masterCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const redLUT = buildCurveLUT(redCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const greenLUT = buildCurveLUT(greenCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const blueLUT = buildCurveLUT(blueCurve ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]);
  const alphaLUT = alphaCurve ? buildCurveLUT(alphaCurve) : null;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    const origA = data[i + 3];
    let r = masterLUT[origR];
    let g = masterLUT[origG];
    let b = masterLUT[origB];
    r = redLUT[r];
    g = greenLUT[g];
    b = blueLUT[b];
    const a = alphaLUT ? alphaLUT[origA] : origA;
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
    data[i + 3] = a;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function glowRenderer(input, params) {
  const threshold = params.glow_threshold ?? 128;
  const radius = params.glow_radius ?? 20;
  const intensity = (params.glow_intensity ?? 100) / 100;
  const operation = params.glow_operation ?? "add";
  if (intensity === 0 || radius === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const thresholdCanvas = document.createElement("canvas");
  thresholdCanvas.width = width;
  thresholdCanvas.height = height;
  const thresholdCtx = thresholdCanvas.getContext("2d");
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const thresholdData = thresholdCtx.createImageData(width, height);
  for (let i = 0; i < inputData.data.length; i += 4) {
    const r = inputData.data[i];
    const g = inputData.data[i + 1];
    const b = inputData.data[i + 2];
    const a = inputData.data[i + 3];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    if (lum > threshold) {
      const scale = (lum - threshold) / (255 - threshold) * intensity;
      thresholdData.data[i] = Math.min(255, r * scale);
      thresholdData.data[i + 1] = Math.min(255, g * scale);
      thresholdData.data[i + 2] = Math.min(255, b * scale);
      thresholdData.data[i + 3] = a;
    } else {
      thresholdData.data[i] = 0;
      thresholdData.data[i + 1] = 0;
      thresholdData.data[i + 2] = 0;
      thresholdData.data[i + 3] = 0;
    }
  }
  thresholdCtx.putImageData(thresholdData, 0, 0);
  const blurCanvas = document.createElement("canvas");
  blurCanvas.width = width;
  blurCanvas.height = height;
  const blurCtx = blurCanvas.getContext("2d");
  blurCtx.filter = `blur(${radius}px)`;
  blurCtx.drawImage(thresholdCanvas, 0, 0);
  output.ctx.drawImage(input.canvas, 0, 0);
  switch (operation) {
    case "screen":
      output.ctx.globalCompositeOperation = "screen";
      break;
    case "lighten":
      output.ctx.globalCompositeOperation = "lighten";
      break;
    case "add":
    default:
      output.ctx.globalCompositeOperation = "lighter";
      break;
  }
  output.ctx.drawImage(blurCanvas, 0, 0);
  output.ctx.globalCompositeOperation = "source-over";
  return output;
}
function dropShadowRenderer(input, params) {
  const shadowColor = params.shadow_color ?? { r: 0, g: 0, b: 0};
  const opacity = (params.opacity ?? 50) / 100;
  const direction = (params.direction ?? 135) * Math.PI / 180;
  const distance = params.distance ?? 5;
  const softness = params.softness ?? 5;
  const shadowOnly = params.shadow_only ?? false;
  const output = createMatchingCanvas(input.canvas);
  const offsetX = Math.cos(direction) * distance;
  const offsetY = Math.sin(direction) * distance;
  output.ctx.shadowColor = `rgba(${shadowColor.r}, ${shadowColor.g}, ${shadowColor.b}, ${opacity})`;
  output.ctx.shadowBlur = softness;
  output.ctx.shadowOffsetX = offsetX;
  output.ctx.shadowOffsetY = offsetY;
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.shadowColor = "transparent";
  output.ctx.shadowBlur = 0;
  output.ctx.shadowOffsetX = 0;
  output.ctx.shadowOffsetY = 0;
  if (!shadowOnly) {
    output.ctx.drawImage(input.canvas, 0, 0);
  }
  return output;
}
function colorBalanceRenderer(input, params) {
  const shadowR = (params.shadow_red ?? 0) / 100;
  const shadowG = (params.shadow_green ?? 0) / 100;
  const shadowB = (params.shadow_blue ?? 0) / 100;
  const midtoneR = (params.midtone_red ?? 0) / 100;
  const midtoneG = (params.midtone_green ?? 0) / 100;
  const midtoneB = (params.midtone_blue ?? 0) / 100;
  const highlightR = (params.highlight_red ?? 0) / 100;
  const highlightG = (params.highlight_green ?? 0) / 100;
  const highlightB = (params.highlight_blue ?? 0) / 100;
  const preserveLuminosity = params.preserve_luminosity ?? true;
  if (shadowR === 0 && shadowG === 0 && shadowB === 0 && midtoneR === 0 && midtoneG === 0 && midtoneB === 0 && highlightR === 0 && highlightG === 0 && highlightB === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
    const shadowWeight = Math.max(0, 1 - lum * 3);
    const highlightWeight = Math.max(0, (lum - 0.67) * 3);
    const midtoneWeight = 1 - shadowWeight - highlightWeight;
    const rAdjust = shadowR * shadowWeight + midtoneR * midtoneWeight + highlightR * highlightWeight;
    const gAdjust = shadowG * shadowWeight + midtoneG * midtoneWeight + highlightG * highlightWeight;
    const bAdjust = shadowB * shadowWeight + midtoneB * midtoneWeight + highlightB * highlightWeight;
    r = r + rAdjust * 255;
    g = g + gAdjust * 255;
    b = b + bAdjust * 255;
    if (preserveLuminosity) {
      const newLum = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
      if (newLum > 1e-3) {
        const lumRatio = lum / newLum;
        r *= lumRatio;
        g *= lumRatio;
        b *= lumRatio;
      }
    }
    data[i] = Math.max(0, Math.min(255, Math.round(r)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function exposureRenderer(input, params) {
  const exposure = params.exposure ?? 0;
  const offset = params.offset ?? 0;
  const gamma = params.gamma ?? 1;
  if (exposure === 0 && offset === 0 && gamma === 1) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const exposureMultiplier = Math.pow(2, exposure);
  const gammaInv = 1 / gamma;
  for (let i = 0; i < 256; i++) {
    let value = i / 255;
    value *= exposureMultiplier;
    value += offset;
    value = Math.max(0, Math.min(1, value));
    value = Math.pow(value, gammaInv);
    lut[i] = Math.round(value * 255);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function vibranceRenderer(input, params) {
  const vibrance = (params.vibrance ?? 0) / 100;
  const saturation = (params.saturation ?? 0) / 100;
  if (vibrance === 0 && saturation === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    let r = data[i] / 255;
    let g = data[i + 1] / 255;
    let b = data[i + 2] / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const currentSat = max - min;
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const skinProtection = 1 - Math.max(0, Math.min(
      1,
      Math.abs(r - 0.8) * 2 + Math.abs(g - 0.5) * 2 + Math.abs(b - 0.3) * 3
    ));
    const vibranceAmount = vibrance * (1 - currentSat) * (1 - skinProtection * 0.5);
    const satAdjust = 1 + saturation + vibranceAmount;
    r = lum + (r - lum) * satAdjust;
    g = lum + (g - lum) * satAdjust;
    b = lum + (b - lum) * satAdjust;
    data[i] = Math.max(0, Math.min(255, Math.round(r * 255)));
    data[i + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
    data[i + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function invertRenderer(input, params) {
  const blend = (params.blend ?? 100) / 100;
  const channel = params.channel ?? "rgb";
  if (blend === 0) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const origR = data[i];
    const origG = data[i + 1];
    const origB = data[i + 2];
    let r = origR;
    let g = origG;
    let b = origB;
    switch (channel) {
      case "rgb":
        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
        break;
      case "red":
        r = 255 - r;
        break;
      case "green":
        g = 255 - g;
        break;
      case "blue":
        b = 255 - b;
        break;
      case "hue":
      case "saturation":
      case "lightness": {
        let [h, s, l] = rgbToHsl(r, g, b);
        if (channel === "hue") h = (h + 0.5) % 1;
        else if (channel === "saturation") s = 1 - s;
        else if (channel === "lightness") l = 1 - l;
        [r, g, b] = hslToRgb(h, s, l);
        break;
      }
    }
    if (blend < 1) {
      r = Math.round(origR + (r - origR) * blend);
      g = Math.round(origG + (g - origG) * blend);
      b = Math.round(origB + (b - origB) * blend);
    }
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function posterizeRenderer(input, params) {
  const levels = Math.max(2, Math.min(256, params.levels ?? 6));
  if (levels === 256) {
    return input;
  }
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  const lut = new Uint8Array(256);
  const step = 255 / (levels - 1);
  for (let i = 0; i < 256; i++) {
    const level = Math.round(i / 255 * (levels - 1));
    lut[i] = Math.round(level * step);
  }
  for (let i = 0; i < data.length; i += 4) {
    data[i] = lut[data[i]];
    data[i + 1] = lut[data[i + 1]];
    data[i + 2] = lut[data[i + 2]];
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function thresholdRenderer(input, params) {
  const threshold = params.threshold ?? 128;
  const output = createMatchingCanvas(input.canvas);
  const imageData = input.ctx.getImageData(0, 0, input.canvas.width, input.canvas.height);
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const lum = r * 0.299 + g * 0.587 + b * 0.114;
    const value = lum >= threshold ? 255 : 0;
    data[i] = value;
    data[i + 1] = value;
    data[i + 2] = value;
  }
  output.ctx.putImageData(imageData, 0, 0);
  return output;
}
function registerColorEffects() {
  registerEffectRenderer("brightness-contrast", brightnessContrastRenderer);
  registerEffectRenderer("hue-saturation", hueSaturationRenderer);
  registerEffectRenderer("levels", levelsRenderer);
  registerEffectRenderer("tint", tintRenderer);
  registerEffectRenderer("curves", curvesRenderer);
  registerEffectRenderer("glow", glowRenderer);
  registerEffectRenderer("drop-shadow", dropShadowRenderer);
  registerEffectRenderer("color-balance", colorBalanceRenderer);
  registerEffectRenderer("exposure", exposureRenderer);
  registerEffectRenderer("vibrance", vibranceRenderer);
  registerEffectRenderer("invert", invertRenderer);
  registerEffectRenderer("posterize", posterizeRenderer);
  registerEffectRenderer("threshold", thresholdRenderer);
}

function transformRenderer(input, params) {
  const anchorPoint = params.anchor_point ?? { x: 0.5, y: 0.5 };
  const position = params.position ?? { x: 0.5, y: 0.5 };
  const scaleWidth = (params.scale_width ?? 100) / 100;
  const scaleHeight = (params.scale_height ?? 100) / 100;
  const skew = (params.skew ?? 0) * Math.PI / 180;
  const skewAxis = (params.skew_axis ?? 0) * Math.PI / 180;
  const rotation = (params.rotation ?? 0) * Math.PI / 180;
  const opacity = (params.opacity ?? 100) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const anchorX = anchorPoint.x * width;
  const anchorY = anchorPoint.y * height;
  const posX = position.x * width;
  const posY = position.y * height;
  output.ctx.globalAlpha = opacity;
  output.ctx.translate(posX, posY);
  output.ctx.rotate(rotation);
  if (skew !== 0) {
    const skewX = Math.tan(skew) * Math.cos(skewAxis);
    const skewY = Math.tan(skew) * Math.sin(skewAxis);
    output.ctx.transform(1, skewY, skewX, 1, 0, 0);
  }
  output.ctx.scale(scaleWidth, scaleHeight);
  output.ctx.translate(-anchorX, -anchorY);
  output.ctx.drawImage(input.canvas, 0, 0);
  output.ctx.setTransform(1, 0, 0, 1, 0, 0);
  output.ctx.globalAlpha = 1;
  return output;
}
function warpRenderer(input, params) {
  const warpStyle = params.warp_style ?? "arc";
  const bend = (params.bend ?? 0) / 100;
  const hDistort = (params.horizontal_distortion ?? 0) / 100;
  const vDistort = (params.vertical_distortion ?? 0) / 100;
  if (bend === 0 && hDistort === 0 && vDistort === 0) {
    return input;
  }
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const nx = (x - centerX) / centerX;
      const ny = (y - centerY) / centerY;
      let srcX = x;
      let srcY = y;
      switch (warpStyle) {
        case "arc": {
          const arcBend = bend * ny * ny;
          srcX = x + arcBend * centerX * nx;
          break;
        }
        case "bulge": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r < 1) {
            const factor = 1 + bend * (1 - r * r);
            srcX = centerX + (x - centerX) / factor;
            srcY = centerY + (y - centerY) / factor;
          }
          break;
        }
        case "wave": {
          srcX = x + Math.sin(ny * Math.PI * 2) * bend * width * 0.1;
          srcY = y + Math.sin(nx * Math.PI * 2) * bend * height * 0.1;
          break;
        }
        case "fisheye": {
          const r = Math.sqrt(nx * nx + ny * ny);
          if (r > 0 && r < 1) {
            const theta = Math.atan2(ny, nx);
            const newR = Math.pow(r, 1 + bend);
            srcX = centerX + newR * Math.cos(theta) * centerX;
            srcY = centerY + newR * Math.sin(theta) * centerY;
          }
          break;
        }
        case "twist": {
          const r = Math.sqrt(nx * nx + ny * ny);
          const angle = bend * Math.PI * (1 - r);
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          srcX = centerX + (nx * cos - ny * sin) * centerX;
          srcY = centerY + (nx * sin + ny * cos) * centerY;
          break;
        }
      }
      srcX += hDistort * centerX * (1 - ny * ny);
      srcY += vDistort * centerY * (1 - nx * nx);
      srcX = Math.max(0, Math.min(width - 1, srcX));
      srcY = Math.max(0, Math.min(height - 1, srcY));
      const x0 = Math.floor(srcX);
      const y0 = Math.floor(srcY);
      const x1 = Math.min(x0 + 1, width - 1);
      const y1 = Math.min(y0 + 1, height - 1);
      const fx = srcX - x0;
      const fy = srcY - y0;
      const idx00 = (y0 * width + x0) * 4;
      const idx01 = (y0 * width + x1) * 4;
      const idx10 = (y1 * width + x0) * 4;
      const idx11 = (y1 * width + x1) * 4;
      const outIdx = (y * width + x) * 4;
      for (let c = 0; c < 4; c++) {
        const v00 = src[idx00 + c];
        const v01 = src[idx01 + c];
        const v10 = src[idx10 + c];
        const v11 = src[idx11 + c];
        dst[outIdx + c] = Math.round(
          v00 * (1 - fx) * (1 - fy) + v01 * fx * (1 - fy) + v10 * (1 - fx) * fy + v11 * fx * fy
        );
      }
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function displacementMapRenderer(input, params) {
  return input;
}
function registerDistortEffects() {
  registerEffectRenderer("transform", transformRenderer);
  registerEffectRenderer("warp", warpRenderer);
  registerEffectRenderer("displacement-map", displacementMapRenderer);
}

class NoiseTileCache {
  cache = /* @__PURE__ */ new Map();
  maxSize = 32;
  // Max cached tiles
  maxAgeMs = 3e4;
  // 30 second TTL
  /**
   * Generate cache key from parameters
   */
  makeKey(width, height, scale, octave, seed) {
    const quantizedSeed = Math.round(seed * 100) / 100;
    return `${width}:${height}:${scale}:${octave}:${quantizedSeed}`;
  }
  /**
   * Get cached noise tile or null if not found/expired
   */
  get(width, height, scale, octave, seed) {
    const key = this.makeKey(width, height, scale, octave, seed);
    const entry = this.cache.get(key);
    if (!entry) return null;
    const now = Date.now();
    if (now - entry.timestamp > this.maxAgeMs) {
      this.cache.delete(key);
      return null;
    }
    this.cache.delete(key);
    this.cache.set(key, { ...entry, timestamp: now });
    return entry.tile;
  }
  /**
   * Store noise tile in cache
   */
  set(width, height, scale, octave, seed, tile) {
    while (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    const key = this.makeKey(width, height, scale, octave, seed);
    this.cache.set(key, {
      tile,
      width,
      height,
      scale,
      octave,
      seed,
      timestamp: Date.now()
    });
  }
  /**
   * Clear all cached tiles
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return { size: this.cache.size, maxSize: this.maxSize };
  }
}
const noiseTileCache = new NoiseTileCache();
function fillRenderer(input, params) {
  const color = params.color ?? { r: 255, g: 0, b: 0, a: 1 };
  const opacity = (params.opacity ?? 100) / 100;
  const invert = params.invert ?? false;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const inputData = input.ctx.getImageData(0, 0, width, height);
  const outputData = output.ctx.createImageData(width, height);
  const src = inputData.data;
  const dst = outputData.data;
  const r = color.r ?? 255;
  const g = color.g ?? 0;
  const b = color.b ?? 0;
  const a = (color.a ?? 1) * 255 * opacity;
  for (let i = 0; i < src.length; i += 4) {
    const srcAlpha = src[i + 3] / 255;
    if (invert) {
      const fillAmount = 1 - srcAlpha;
      dst[i] = Math.round(r * fillAmount + src[i] * (1 - fillAmount));
      dst[i + 1] = Math.round(g * fillAmount + src[i + 1] * (1 - fillAmount));
      dst[i + 2] = Math.round(b * fillAmount + src[i + 2] * (1 - fillAmount));
      dst[i + 3] = Math.max(src[i + 3], Math.round(a * fillAmount));
    } else {
      dst[i] = Math.round(r * srcAlpha * opacity + src[i] * (1 - opacity));
      dst[i + 1] = Math.round(g * srcAlpha * opacity + src[i + 1] * (1 - opacity));
      dst[i + 2] = Math.round(b * srcAlpha * opacity + src[i + 2] * (1 - opacity));
      dst[i + 3] = src[i + 3];
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function gradientRampRenderer(input, params) {
  const startPoint = params.start_of_ramp ?? { x: 0, y: 0.5 };
  const startColor = params.start_color ?? { r: 0, g: 0, b: 0, a: 1 };
  const endPoint = params.end_of_ramp ?? { x: 1, y: 0.5 };
  const endColor = params.end_color ?? { r: 255, g: 255, b: 255, a: 1 };
  const rampShape = params.ramp_shape ?? "linear";
  const scatter = (params.ramp_scatter ?? 0) / 100;
  const blend = (params.blend_with_original ?? 0) / 100;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  let gradient;
  if (rampShape === "radial") {
    const cx = startPoint.x * width;
    const cy = startPoint.y * height;
    const dx = (endPoint.x - startPoint.x) * width;
    const dy = (endPoint.y - startPoint.y) * height;
    const radius = Math.sqrt(dx * dx + dy * dy);
    gradient = output.ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
  } else {
    gradient = output.ctx.createLinearGradient(
      startPoint.x * width,
      startPoint.y * height,
      endPoint.x * width,
      endPoint.y * height
    );
  }
  const startRgba = `rgba(${startColor.r}, ${startColor.g}, ${startColor.b}, ${startColor.a ?? 1})`;
  const endRgba = `rgba(${endColor.r}, ${endColor.g}, ${endColor.b}, ${endColor.a ?? 1})`;
  gradient.addColorStop(0, startRgba);
  gradient.addColorStop(1, endRgba);
  output.ctx.fillStyle = gradient;
  output.ctx.fillRect(0, 0, width, height);
  if (scatter > 0) {
    const outputData = output.ctx.getImageData(0, 0, width, height);
    const dst = outputData.data;
    const scatterAmount = scatter * 25;
    for (let i = 0; i < dst.length; i += 4) {
      const noise = (Math.random() - 0.5) * scatterAmount;
      dst[i] = Math.max(0, Math.min(255, dst[i] + noise));
      dst[i + 1] = Math.max(0, Math.min(255, dst[i + 1] + noise));
      dst[i + 2] = Math.max(0, Math.min(255, dst[i + 2] + noise));
    }
    output.ctx.putImageData(outputData, 0, 0);
  }
  if (blend > 0) {
    output.ctx.globalAlpha = blend;
    output.ctx.drawImage(input.canvas, 0, 0);
    output.ctx.globalAlpha = 1;
  }
  return output;
}
function noise2D(x, y, seed) {
  const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
  return n - Math.floor(n);
}
function smoothNoise(x, y, seed) {
  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const fx = x - x0;
  const fy = y - y0;
  const v00 = noise2D(x0, y0, seed);
  const v10 = noise2D(x0 + 1, y0, seed);
  const v01 = noise2D(x0, y0 + 1, seed);
  const v11 = noise2D(x0 + 1, y0 + 1, seed);
  const sx = fx * fx * (3 - 2 * fx);
  const sy = fy * fy * (3 - 2 * fy);
  return v00 * (1 - sx) * (1 - sy) + v10 * sx * (1 - sy) + v01 * (1 - sx) * sy + v11 * sx * sy;
}
function getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent) {
  const octaveSeed = seed + octave * 100;
  const cached = noiseTileCache.get(width, height, scale, octave, octaveSeed);
  if (cached) {
    return cached;
  }
  const tile = new Float32Array(width * height);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const sampleX = x / scale * frequency;
      const sampleY = y / scale * frequency;
      let noiseValue = smoothNoise(sampleX, sampleY, octaveSeed);
      if (isTurbulent) {
        noiseValue = Math.abs(noiseValue * 2 - 1);
      }
      tile[y * width + x] = noiseValue;
    }
  }
  noiseTileCache.set(width, height, scale, octave, octaveSeed, tile);
  return tile;
}
function fractalNoiseRenderer(input, params) {
  const fractalType = params.fractal_type ?? "basic";
  const invert = params.invert ?? false;
  const contrast = (params.contrast ?? 100) / 100;
  const brightness = (params.brightness ?? 0) / 100;
  const scale = params.scale ?? 100;
  const complexity = Math.max(1, Math.min(20, params.complexity ?? 6));
  const evolution = (params.evolution ?? 0) * Math.PI / 180;
  const { width, height } = input.canvas;
  const output = createMatchingCanvas(input.canvas);
  const outputData = output.ctx.createImageData(width, height);
  const dst = outputData.data;
  const seed = evolution * 1e3;
  const isTurbulent = fractalType.includes("turbulent");
  const octaveTiles = [];
  const amplitudes = [];
  let frequency = 1;
  let amplitude = 1;
  let maxValue = 0;
  for (let octave = 0; octave < complexity; octave++) {
    octaveTiles.push(getOctaveTile(width, height, scale, octave, seed, frequency, isTurbulent));
    amplitudes.push(amplitude);
    maxValue += amplitude;
    amplitude *= 0.5;
    frequency *= 2;
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let value = 0;
      const pixelIdx = y * width + x;
      for (let octave = 0; octave < complexity; octave++) {
        value += octaveTiles[octave][pixelIdx] * amplitudes[octave];
      }
      value /= maxValue;
      value = (value - 0.5) * contrast + 0.5 + brightness;
      if (invert) {
        value = 1 - value;
      }
      value = Math.max(0, Math.min(1, value));
      const pixelValue = Math.round(value * 255);
      const idx = pixelIdx * 4;
      dst[idx] = pixelValue;
      dst[idx + 1] = pixelValue;
      dst[idx + 2] = pixelValue;
      dst[idx + 3] = 255;
    }
  }
  output.ctx.putImageData(outputData, 0, 0);
  return output;
}
function registerGenerateEffects() {
  registerEffectRenderer("fill", fillRenderer);
  registerEffectRenderer("gradient-ramp", gradientRampRenderer);
  registerEffectRenderer("fractal-noise", fractalNoiseRenderer);
}

function initializeEffects() {
  registerBlurEffects();
  registerColorEffects();
  registerDistortEffects();
  registerGenerateEffects();
}

let appInstance = null;
function mountApp(container) {
  let el = null;
  if (typeof container === "string") {
    el = document.getElementById(container) || document.querySelector(container);
  } else if (container instanceof HTMLElement) {
    el = container;
  } else {
    el = document.getElementById("weyl-compositor-root") || document.getElementById("app");
  }
  if (!el) return null;
  initializeEffects();
  const app = createApp(_sfc_main);
  app.use(createPinia());
  app.mount(el);
  appInstance = app;
  setupBridge();
  return app;
}
function setupBridge() {
  window.addEventListener("weyl:inputs-ready", (e) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: e.detail }));
  });
}
async function sendToComfyUI(matte, preview) {
  return window.WeylCompositor?.sendOutput?.(matte, preview) ?? false;
}
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => mountApp());
} else {
  setTimeout(() => {
    if (!appInstance) mountApp();
  }, 0);
}

export { mountApp, sendToComfyUI };
